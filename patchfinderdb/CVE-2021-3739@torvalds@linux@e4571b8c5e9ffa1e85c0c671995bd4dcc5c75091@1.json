{
  "cve_id": "CVE-2021-3739",
  "cve_desc": "A NULL pointer dereference flaw was found in the btrfs_rm_device function in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system or leak kernel internal information. The highest threat from this vulnerability is to system availability.",
  "repo": "torvalds/linux",
  "patch_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
  "patch_info": {
    "commit_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "files": [
      "fs/btrfs/volumes.c"
    ],
    "message": "btrfs: fix NULL pointer dereference when deleting device by invalid id\n\n[BUG]\nIt's easy to trigger NULL pointer dereference, just by removing a\nnon-existing device id:\n\n # mkfs.btrfs -f -m single -d single /dev/test/scratch1 \\\n\t\t\t\t     /dev/test/scratch2\n # mount /dev/test/scratch1 /mnt/btrfs\n # btrfs device remove 3 /mnt/btrfs\n\nThen we have the following kernel NULL pointer dereference:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 9 PID: 649 Comm: btrfs Not tainted 5.14.0-rc3-custom+ #35\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n RIP: 0010:btrfs_rm_device+0x4de/0x6b0 [btrfs]\n  btrfs_ioctl+0x18bb/0x3190 [btrfs]\n  ? lock_is_held_type+0xa5/0x120\n  ? find_held_lock.constprop.0+0x2b/0x80\n  ? do_user_addr_fault+0x201/0x6a0\n  ? lock_release+0xd2/0x2d0\n  ? __x64_sys_ioctl+0x83/0xb0\n  __x64_sys_ioctl+0x83/0xb0\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n[CAUSE]\nCommit a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return\nbtrfs_device directly\") moves the \"missing\" device path check into\nbtrfs_rm_device().\n\nBut btrfs_rm_device() itself can have case where it only receives\n@devid, with NULL as @device_path.\n\nIn that case, calling strcmp() on NULL will trigger the NULL pointer\ndereference.\n\nBefore that commit, we handle the \"missing\" case inside\nbtrfs_find_device_by_devspec(), which will not check @device_path at all\nif @devid is provided, thus no way to trigger the bug.\n\n[FIX]\nBefore calling strcmp(), also make sure @device_path is not NULL.\n\nFixes: a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly\")\nCC: stable@vger.kernel.org # 5.4+\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
    "before_after_code_files": [
      "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
    ]
  },
  "patch_diff": {
    "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
      "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2075:  if (IS_ERR(device)) {",
      "2076:   if (PTR_ERR(device) == -ENOENT &&",
      "2078:    ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;",
      "2079:   else",
      "2080:    ret = PTR_ERR(device);",
      "",
      "[Removed Lines]",
      "2077:       strcmp(device_path, \"missing\") == 0)",
      "",
      "[Added Lines]",
      "2077:       device_path && strcmp(device_path, \"missing\") == 0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "30f64e2066ab1b51139307eb33dc217838bd19bc",
      "candidate_info": {
        "commit_hash": "30f64e2066ab1b51139307eb33dc217838bd19bc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/30f64e2066ab1b51139307eb33dc217838bd19bc",
        "files": [
          "drivers/platform/x86/gigabyte-wmi.c"
        ],
        "message": "platform/x86: gigabyte-wmi: add support for B450M S2H V2\n\nReported as working here:\nhttps://github.com/t-8ch/linux-gigabyte-wmi-driver/issues/1#issuecomment-901207693\n\nSigned-off-by: Thomas Wei\u00dfschuh <linux@weissschuh.net>\nLink: https://lore.kernel.org/r/20210818164435.99821-1-linux@weissschuh.net\nSigned-off-by: Hans de Goede <hdegoede@redhat.com>",
        "before_after_code_files": [
          "drivers/platform/x86/gigabyte-wmi.c||drivers/platform/x86/gigabyte-wmi.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/platform/x86/gigabyte-wmi.c||drivers/platform/x86/gigabyte-wmi.c": [
          "File: drivers/platform/x86/gigabyte-wmi.c -> drivers/platform/x86/gigabyte-wmi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "140:  }}",
          "142: static const struct dmi_system_id gigabyte_wmi_known_working_platforms[] = {",
          "143:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B550 AORUS ELITE\"),",
          "144:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B550 AORUS ELITE V2\"),",
          "145:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B550 GAMING X V2\"),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "143:  DMI_EXACT_MATCH_GIGABYTE_BOARD_NAME(\"B450M S2H V2\"),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e0467866198f7f536806f39e5d0d91ae8018de08",
      "candidate_info": {
        "commit_hash": "e0467866198f7f536806f39e5d0d91ae8018de08",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e0467866198f7f536806f39e5d0d91ae8018de08",
        "files": [
          "fs/btrfs/file.c"
        ],
        "message": "btrfs: subpage: fix race between prepare_pages() and btrfs_releasepage()\n\n[BUG]\nWhen running generic/095, there is a high chance to crash with subpage\ndata RW support:\n\n assertion failed: PagePrivate(page) && page->private\n ------------[ cut here ]------------\n kernel BUG at fs/btrfs/ctree.h:3403!\n Internal error: Oops - BUG: 0 [#1] SMP\n CPU: 1 PID: 3567 Comm: fio Tainted: 5.12.0-rc7-custom+ #17\n Hardware name: Khadas VIM3 (DT)\n Call trace:\n  assertfail.constprop.0+0x28/0x2c [btrfs]\n  btrfs_subpage_assert+0x80/0xa0 [btrfs]\n  btrfs_subpage_set_uptodate+0x34/0xec [btrfs]\n  btrfs_page_clamp_set_uptodate+0x74/0xa4 [btrfs]\n  btrfs_dirty_pages+0x160/0x270 [btrfs]\n  btrfs_buffered_write+0x444/0x630 [btrfs]\n  btrfs_direct_write+0x1cc/0x2d0 [btrfs]\n  btrfs_file_write_iter+0xc0/0x160 [btrfs]\n  new_sync_write+0xe8/0x180\n  vfs_write+0x1b4/0x210\n  ksys_pwrite64+0x7c/0xc0\n  __arm64_sys_pwrite64+0x24/0x30\n  el0_svc_common.constprop.0+0x70/0x140\n  do_el0_svc+0x28/0x90\n  el0_svc+0x2c/0x54\n  el0_sync_handler+0x1a8/0x1ac\n  el0_sync+0x170/0x180\n Code: f0000160 913be042 913c4000 955444bc (d4210000)\n ---[ end trace 3fdd39f4cccedd68 ]---\n\n[CAUSE]\nAlthough prepare_pages() calls find_or_create_page(), which returns the\npage locked, but in later prepare_uptodate_page() calls, we may call\nbtrfs_readpage() which will unlock the page before it returns.\n\nThis leaves a window where btrfs_releasepage() can sneak in and release\nthe page, clearing page->private and causing above ASSERT().\n\n[FIX]\nIn prepare_uptodate_page(), we should not only check page->mapping, but\nalso PagePrivate() to ensure we are still holding the correct page which\nhas proper fs context setup.\n\nReported-by: Ritesh Harjani <riteshh@linux.ibm.com>\nTested-by: Ritesh Harjani <riteshh@linux.ibm.com>\nReviewed-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/file.c||fs/btrfs/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/file.c||fs/btrfs/file.c": [
          "File: fs/btrfs/file.c -> fs/btrfs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1340:    unlock_page(page);",
          "1341:    return -EIO;",
          "1342:   }",
          "1344:    unlock_page(page);",
          "1345:    return -EAGAIN;",
          "1346:   }",
          "",
          "[Removed Lines]",
          "1343:   if (page->mapping != inode->i_mapping) {",
          "",
          "[Added Lines]",
          "1354:   if (page->mapping != inode->i_mapping || !PagePrivate(page)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61e0d0cc51cd6b9d7447923f3ac7e60049de3e2e",
      "candidate_info": {
        "commit_hash": "61e0d0cc51cd6b9d7447923f3ac7e60049de3e2e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/61e0d0cc51cd6b9d7447923f3ac7e60049de3e2e",
        "files": [
          "fs/xfs/scrub/bmap.c",
          "fs/xfs/scrub/btree.c",
          "fs/xfs/scrub/fscounters.c",
          "fs/xfs/scrub/inode.c"
        ],
        "message": "xfs: fix perag structure refcounting error when scrub fails\n\nThe kernel test robot found the following bug when running xfs/355 to\nscrub a bmap btree:\n\nXFS: Assertion failed: !sa->pag, file: fs/xfs/scrub/common.c, line: 412\n------------[ cut here ]------------\nkernel BUG at fs/xfs/xfs_message.c:110!\ninvalid opcode: 0000 [#1] SMP PTI\nCPU: 2 PID: 1415 Comm: xfs_scrub Not tainted 5.14.0-rc4-00021-g48c6615cc557 #1\nHardware name: Hewlett-Packard p6-1451cx/2ADA, BIOS 8.15 02/05/2013\nRIP: 0010:assfail+0x23/0x28 [xfs]\nRSP: 0018:ffffc9000aacb890 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: ffffc9000aacbcc8 RCX: 0000000000000000\nRDX: 00000000ffffffc0 RSI: 000000000000000a RDI: ffffffffc09e7dcd\nRBP: ffffc9000aacbc80 R08: ffff8881fdf17d50 R09: 0000000000000000\nR10: 000000000000000a R11: f000000000000000 R12: 0000000000000000\nR13: ffff88820c7ed000 R14: 0000000000000001 R15: ffffc9000aacb980\nFS:  00007f185b955700(0000) GS:ffff8881fdf00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f7f6ef43000 CR3: 000000020de38002 CR4: 00000000001706e0\nCall Trace:\n xchk_ag_read_headers+0xda/0x100 [xfs]\n xchk_ag_init+0x15/0x40 [xfs]\n xchk_btree_check_block_owner+0x76/0x180 [xfs]\n xchk_btree_get_block+0xd0/0x140 [xfs]\n xchk_btree+0x32e/0x440 [xfs]\n xchk_bmap_btree+0xd4/0x140 [xfs]\n xchk_bmap+0x1eb/0x3c0 [xfs]\n xfs_scrub_metadata+0x227/0x4c0 [xfs]\n xfs_ioc_scrub_metadata+0x50/0xc0 [xfs]\n xfs_file_ioctl+0x90c/0xc40 [xfs]\n __x64_sys_ioctl+0x83/0xc0\n do_syscall_64+0x3b/0xc0\n\nThe unusual handling of errors while initializing struct xchk_ag is the\nroot cause here.  Since the beginning of xfs_scrub, the goal of\nxchk_ag_read_headers has been to read all three AG header buffers and\nattach them both to the xchk_ag structure and the scrub transaction.\nCorruption errors on any of the three headers doesn't necessarily\ntrigger an immediate return to userspace, because xfs_scrub can also\ntell us to /fix/ the problem.\n\nIn other words, it's possible for the xchk_ag init functions to return\nan error code and a partially filled out structure so that scrub can use\nhowever much information it managed to pull.  Before 5.15, it was\nsufficient to cancel (or commit) the scrub transaction on the way out of\nthe scrub code to release the buffers.\n\nCcommit 48c6615cc557 added a reference to the perag structure to struct\nxchk_ag.  Since perag structures are not attached to transactions like\nbuffers are, this adds the requirement that the perag ref be released\nexplicitly.  The scrub teardown function xchk_teardown was amended to do\nthis for the xchk_ag embedded in struct xfs_scrub.\n\nUnfortunately, I forgot that certain parts of the scrub code probe\nmultiple AGs and therefore handle the initialization and cleanup on\ntheir own.  Specifically, the bmbt scrubber will initialize it long\nenough to cross-reference AG metadata for btree blocks and for the\nextent mappings in the bmbt.\n\nIf one of the AG headers is corrupt, the init function returns with a\nlive perag structure reference and some of the AG header buffers.  If an\nerror occurs, the cross referencing will be noted as XCORRUPTion and\nskipped, but the main scrub process will move on to the next record.\nIt is now necessary to release the perag reference before we try to\nanalyze something from a different AG, or else we'll trip over the\nassertion noted above.\n\nFixes: 48c6615cc557 (\"xfs: grab active perag ref when reading AG headers\")\nReported-by: kernel test robot <oliver.sang@intel.com>\nSigned-off-by: Darrick J. Wong <djwong@kernel.org>\nReviewed-by: Chandan Babu R <chandanrlinux@gmail.com>",
        "before_after_code_files": [
          "fs/xfs/scrub/bmap.c||fs/xfs/scrubmap.c",
          "fs/xfs/scrub/btree.c||fs/xfs/scrubtree.c",
          "fs/xfs/scrub/fscounters.c||fs/xfs/scrufscounters.c",
          "fs/xfs/scrub/inode.c||fs/xfs/scruinode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/xfs/scrub/bmap.c||fs/xfs/scrubmap.c": [
          "File: fs/xfs/scrub/bmap.c -> fs/xfs/scrubmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "263:  error = xchk_ag_init_existing(info->sc, agno, &info->sc->sa);",
          "264:  if (!xchk_fblock_process_error(info->sc, info->whichfork,",
          "265:    irec->br_startoff, &error))",
          "268:  xchk_xref_is_used_space(info->sc, agbno, len);",
          "269:  xchk_xref_is_not_inode_chunk(info->sc, agbno, len);",
          "",
          "[Removed Lines]",
          "266:   return;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "283:   break;",
          "284:  }",
          "286:  xchk_ag_free(info->sc, &info->sc->sa);",
          "287: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/xfs/scrub/btree.c||fs/xfs/scrubtree.c": [
          "File: fs/xfs/scrub/btree.c -> fs/xfs/scrubtree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "377:   error = xchk_ag_init_existing(bs->sc, agno, &bs->sc->sa);",
          "378:   if (!xchk_btree_xref_process_error(bs->sc, bs->cur,",
          "379:     level, &error))",
          "381:  }",
          "383:  xchk_xref_is_used_space(bs->sc, agbno, 1);",
          "",
          "[Removed Lines]",
          "380:    return error;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "393:  if (!bs->sc->sa.rmap_cur && btnum == XFS_BTNUM_RMAP)",
          "394:   bs->cur = NULL;",
          "396:  if (init_sa)",
          "397:   xchk_ag_free(bs->sc, &bs->sc->sa);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/xfs/scrub/fscounters.c||fs/xfs/scrufscounters.c": [
          "File: fs/xfs/scrub/fscounters.c -> fs/xfs/scrufscounters.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "151:  error = xchk_ag_init_existing(sc, agno, &sc->sa);",
          "152:  if (error)",
          "155:  error = xfs_btree_count_blocks(sc->sa.bno_cur, &blocks);",
          "156:  if (error)",
          "",
          "[Removed Lines]",
          "153:   return error;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/xfs/scrub/inode.c||fs/xfs/scruinode.c": [
          "File: fs/xfs/scrub/inode.c -> fs/xfs/scruinode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "534:  error = xchk_ag_init_existing(sc, agno, &sc->sa);",
          "535:  if (!xchk_xref_process_error(sc, agno, agbno, &error))",
          "538:  xchk_xref_is_used_space(sc, agbno, 1);",
          "539:  xchk_inode_xref_finobt(sc, ino);",
          "",
          "[Removed Lines]",
          "536:   return;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "541:  xchk_xref_is_not_shared(sc, agbno, 1);",
          "542:  xchk_inode_xref_bmap(sc, dip);",
          "544:  xchk_ag_free(sc, &sc->sa);",
          "545: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "594286b7574c6e8217b1c233cc0d0650f2268a77",
      "candidate_info": {
        "commit_hash": "594286b7574c6e8217b1c233cc0d0650f2268a77",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/594286b7574c6e8217b1c233cc0d0650f2268a77",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "bpf: Fix NULL event->prog pointer access in bpf_overflow_handler\n\nAndrii reported that libbpf CI hit the following oops when\nrunning selftest send_signal:\n  [ 1243.160719] BUG: kernel NULL pointer dereference, address: 0000000000000030\n  [ 1243.161066] #PF: supervisor read access in kernel mode\n  [ 1243.161066] #PF: error_code(0x0000) - not-present page\n  [ 1243.161066] PGD 0 P4D 0\n  [ 1243.161066] Oops: 0000 [#1] PREEMPT SMP NOPTI\n  [ 1243.161066] CPU: 1 PID: 882 Comm: new_name Tainted: G           O      5.14.0-rc5 #1\n  [ 1243.161066] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n  [ 1243.161066] RIP: 0010:bpf_overflow_handler+0x9a/0x1e0\n  [ 1243.161066] Code: 5a 84 c0 0f 84 06 01 00 00 be 66 02 00 00 48 c7 c7 6d 96 07 82 48 8b ab 18 05 00 00 e8 df 55 eb ff 66 90 48 8d 75 48 48 89 e7 <ff> 55 30 41 89 c4 e8 fb c1 f0 ff 84 c0 0f 84 94 00 00 00 e8 6e 0f\n  [ 1243.161066] RSP: 0018:ffffc900000c0d80 EFLAGS: 00000046\n  [ 1243.161066] RAX: 0000000000000002 RBX: ffff8881002e0dd0 RCX: 00000000b4b47cf8\n  [ 1243.161066] RDX: ffffffff811dcb06 RSI: 0000000000000048 RDI: ffffc900000c0d80\n  [ 1243.161066] RBP: 0000000000000000 R08: 0000000000000000 R09: 1a9d56bb00000000\n  [ 1243.161066] R10: 0000000000000001 R11: 0000000000080000 R12: 0000000000000000\n  [ 1243.161066] R13: ffffc900000c0e00 R14: ffffc900001c3c68 R15: 0000000000000082\n  [ 1243.161066] FS:  00007fc0be2d3380(0000) GS:ffff88813bd00000(0000) knlGS:0000000000000000\n  [ 1243.161066] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [ 1243.161066] CR2: 0000000000000030 CR3: 0000000104f8e000 CR4: 00000000000006e0\n  [ 1243.161066] Call Trace:\n  [ 1243.161066]  <IRQ>\n  [ 1243.161066]  __perf_event_overflow+0x4f/0xf0\n  [ 1243.161066]  perf_swevent_hrtimer+0x116/0x130\n  [ 1243.161066]  ? __lock_acquire+0x378/0x2730\n  [ 1243.161066]  ? __lock_acquire+0x372/0x2730\n  [ 1243.161066]  ? lock_is_held_type+0xd5/0x130\n  [ 1243.161066]  ? find_held_lock+0x2b/0x80\n  [ 1243.161066]  ? lock_is_held_type+0xd5/0x130\n  [ 1243.161066]  ? perf_event_groups_first+0x80/0x80\n  [ 1243.161066]  ? perf_event_groups_first+0x80/0x80\n  [ 1243.161066]  __hrtimer_run_queues+0x1a3/0x460\n  [ 1243.161066]  hrtimer_interrupt+0x110/0x220\n  [ 1243.161066]  __sysvec_apic_timer_interrupt+0x8a/0x260\n  [ 1243.161066]  sysvec_apic_timer_interrupt+0x89/0xc0\n  [ 1243.161066]  </IRQ>\n  [ 1243.161066]  asm_sysvec_apic_timer_interrupt+0x12/0x20\n  [ 1243.161066] RIP: 0010:finish_task_switch+0xaf/0x250\n  [ 1243.161066] Code: 31 f6 68 90 2a 09 81 49 8d 7c 24 18 e8 aa d6 03 00 4c 89 e7 e8 12 ff ff ff 4c 89 e7 e8 ca 9c 80 00 e8 35 af 0d 00 fb 4d 85 f6 <58> 74 1d 65 48 8b 04 25 c0 6d 01 00 4c 3b b0 a0 04 00 00 74 37 f0\n  [ 1243.161066] RSP: 0018:ffffc900001c3d18 EFLAGS: 00000282\n  [ 1243.161066] RAX: 000000000000031f RBX: ffff888104cf4980 RCX: 0000000000000000\n  [ 1243.161066] RDX: 0000000000000000 RSI: ffffffff82095460 RDI: ffffffff820adc4e\n  [ 1243.161066] RBP: ffffc900001c3d58 R08: 0000000000000001 R09: 0000000000000001\n  [ 1243.161066] R10: 0000000000000001 R11: 0000000000080000 R12: ffff88813bd2bc80\n  [ 1243.161066] R13: ffff8881002e8000 R14: ffff88810022ad80 R15: 0000000000000000\n  [ 1243.161066]  ? finish_task_switch+0xab/0x250\n  [ 1243.161066]  ? finish_task_switch+0x70/0x250\n  [ 1243.161066]  __schedule+0x36b/0xbb0\n  [ 1243.161066]  ? _raw_spin_unlock_irqrestore+0x2d/0x50\n  [ 1243.161066]  ? lockdep_hardirqs_on+0x79/0x100\n  [ 1243.161066]  schedule+0x43/0xe0\n  [ 1243.161066]  pipe_read+0x30b/0x450\n  [ 1243.161066]  ? wait_woken+0x80/0x80\n  [ 1243.161066]  new_sync_read+0x164/0x170\n  [ 1243.161066]  vfs_read+0x122/0x1b0\n  [ 1243.161066]  ksys_read+0x93/0xd0\n  [ 1243.161066]  do_syscall_64+0x35/0x80\n  [ 1243.161066]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe oops can also be reproduced with the following steps:\n  ./vmtest.sh -s\n  # at qemu shell\n  cd /root/bpf && while true; do ./test_progs -t send_signal\n\nFurther analysis showed that the failure is introduced with\ncommit b89fbfbb854c (\"bpf: Implement minimal BPF perf link\").\nWith the above commit, the following scenario becomes possible:\n    cpu1                        cpu2\n                                hrtimer_interrupt -> bpf_overflow_handler\n    (due to closing link_fd)\n    bpf_perf_link_release ->\n    perf_event_free_bpf_prog ->\n    perf_event_free_bpf_handler ->\n      WRITE_ONCE(event->overflow_handler, event->orig_overflow_handler)\n      event->prog = NULL\n                                bpf_prog_run(event->prog, &ctx)\n\nIn the above case, the event->prog is NULL for bpf_prog_run, hence\ncausing oops.\n\nTo fix the issue, check whether event->prog is NULL or not. If it\nis, do not call bpf_prog_run. This seems working as the above\nreproducible step runs more than one hour and I didn't see any\nfailures.\n\nFixes: b89fbfbb854c (\"bpf: Implement minimal BPF perf link\")\nSigned-off-by: Yonghong Song <yhs@fb.com>\nSigned-off-by: Andrii Nakryiko <andrii@kernel.org>\nLink: https://lore.kernel.org/bpf/20210819155209.1927994-1-yhs@fb.com",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9920:   .data = data,",
          "9921:   .event = event,",
          "9922:  };",
          "9923:  int ret = 0;",
          "9925:  ctx.regs = perf_arch_bpf_user_pt_regs(regs);",
          "9926:  if (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1))",
          "9927:   goto out;",
          "9928:  rcu_read_lock();",
          "9930:  rcu_read_unlock();",
          "9931: out:",
          "9932:  __this_cpu_dec(bpf_prog_active);",
          "",
          "[Removed Lines]",
          "9929:  ret = bpf_prog_run(event->prog, &ctx);",
          "",
          "[Added Lines]",
          "9923:  struct bpf_prog *prog;",
          "9930:  prog = READ_ONCE(event->prog);",
          "9931:  if (prog)",
          "9932:   ret = bpf_prog_run(prog, &ctx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cd9b50adc6bb9ad3f7d244590a389522215865c4",
      "candidate_info": {
        "commit_hash": "cd9b50adc6bb9ad3f7d244590a389522215865c4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cd9b50adc6bb9ad3f7d244590a389522215865c4",
        "files": [
          "net/sched/sch_ets.c"
        ],
        "message": "net/sched: ets: fix crash when flipping from 'strict' to 'quantum'\n\nWhile running kselftests, Hangbin observed that sch_ets.sh often crashes,\nand splats like the following one are seen in the output of 'dmesg':\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 159f12067 P4D 159f12067 PUD 159f13067 PMD 0\n Oops: 0000 [#1] SMP NOPTI\n CPU: 2 PID: 921 Comm: tc Not tainted 5.14.0-rc6+ #458\n Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014\n RIP: 0010:__list_del_entry_valid+0x2d/0x50\n Code: 48 8b 57 08 48 b9 00 01 00 00 00 00 ad de 48 39 c8 0f 84 ac 6e 5b 00 48 b9 22 01 00 00 00 00 ad de 48 39 ca 0f 84 cf 6e 5b 00 <48> 8b 32 48 39 fe 0f 85 af 6e 5b 00 48 8b 50 08 48 39 f2 0f 85 94\n RSP: 0018:ffffb2da005c3890 EFLAGS: 00010217\n RAX: 0000000000000000 RBX: ffff9073ba23f800 RCX: dead000000000122\n RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff9073ba23fbc8\n RBP: ffff9073ba23f890 R08: 0000000000000001 R09: 0000000000000001\n R10: 0000000000000001 R11: 0000000000000001 R12: dead000000000100\n R13: ffff9073ba23fb00 R14: 0000000000000002 R15: 0000000000000002\n FS:  00007f93e5564e40(0000) GS:ffff9073bba00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 000000014ad34000 CR4: 0000000000350ee0\n Call Trace:\n  ets_qdisc_reset+0x6e/0x100 [sch_ets]\n  qdisc_reset+0x49/0x1d0\n  tbf_reset+0x15/0x60 [sch_tbf]\n  qdisc_reset+0x49/0x1d0\n  dev_reset_queue.constprop.42+0x2f/0x90\n  dev_deactivate_many+0x1d3/0x3d0\n  dev_deactivate+0x56/0x90\n  qdisc_graft+0x47e/0x5a0\n  tc_get_qdisc+0x1db/0x3e0\n  rtnetlink_rcv_msg+0x164/0x4c0\n  netlink_rcv_skb+0x50/0x100\n  netlink_unicast+0x1a5/0x280\n  netlink_sendmsg+0x242/0x480\n  sock_sendmsg+0x5b/0x60\n  ____sys_sendmsg+0x1f2/0x260\n  ___sys_sendmsg+0x7c/0xc0\n  __sys_sendmsg+0x57/0xa0\n  do_syscall_64+0x3a/0x80\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7f93e44b8338\n Code: 89 02 48 c7 c0 ff ff ff ff eb b5 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 8d 05 25 43 2c 00 8b 00 85 c0 75 17 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 58 c3 0f 1f 80 00 00 00 00 41 54 41 89 d4 55\n RSP: 002b:00007ffc0db737a8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n RAX: ffffffffffffffda RBX: 0000000061255c06 RCX: 00007f93e44b8338\n RDX: 0000000000000000 RSI: 00007ffc0db73810 RDI: 0000000000000003\n RBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\n R10: 000000000000000b R11: 0000000000000246 R12: 0000000000000001\n R13: 0000000000687880 R14: 0000000000000000 R15: 0000000000000000\n Modules linked in: sch_ets sch_tbf dummy rfkill iTCO_wdt iTCO_vendor_support intel_rapl_msr intel_rapl_common joydev i2c_i801 pcspkr i2c_smbus lpc_ich virtio_balloon ip_tables xfs libcrc32c crct10dif_pclmul crc32_pclmul crc32c_intel ahci libahci ghash_clmulni_intel libata serio_raw virtio_blk virtio_console virtio_net net_failover failover sunrpc dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000000\n\nWhen the change() function decreases the value of 'nstrict', we must take\ninto account that packets might be already enqueued on a class that flips\nfrom 'strict' to 'quantum': otherwise that class will not be added to the\nbandwidth-sharing list. Then, a call to ets_qdisc_reset() will attempt to\ndo list_del(&alist) with 'alist' filled with zero, hence the NULL pointer\ndereference.\nFor classes flipping from 'strict' to 'quantum', initialize an empty list\nand eventually add it to the bandwidth-sharing list, if there are packets\nalready enqueued. In this way, the kernel will:\n a) prevent crashing as described above.\n b) avoid retaining the backlog packets (for an arbitrarily long time) in\n    case no packet is enqueued after a change from 'strict' to 'quantum'.\n\nReported-by: Hangbin Liu <liuhangbin@gmail.com>\nFixes: dcc68b4d8084 (\"net: sch_ets: Add a new Qdisc\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/sch_ets.c||net/sched/sch_ets.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/sch_ets.c||net/sched/sch_ets.c": [
          "File: net/sched/sch_ets.c -> net/sched/sch_ets.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "660:  sch_tree_lock(sch);",
          "662:  q->nbands = nbands;",
          "663:  q->nstrict = nstrict;",
          "664:  memcpy(q->prio2band, priomap, sizeof(priomap));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "663:  for (i = nstrict; i < q->nstrict; i++) {",
          "664:   INIT_LIST_HEAD(&q->classes[i].alist);",
          "665:   if (q->classes[i].qdisc->q.qlen) {",
          "666:    list_add_tail(&q->classes[i].alist, &q->active);",
          "667:    q->classes[i].deficit = quanta[i];",
          "668:   }",
          "669:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
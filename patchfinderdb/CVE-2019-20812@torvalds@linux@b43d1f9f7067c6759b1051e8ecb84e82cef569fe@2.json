{
  "cve_id": "CVE-2019-20812",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.4.7. The prb_calc_retire_blk_tmo() function in net/packet/af_packet.c can result in a denial of service (CPU consumption and soft lockup) in a certain failure case involving TPACKET_V3, aka CID-b43d1f9f7067.",
  "repo": "torvalds/linux",
  "patch_hash": "b43d1f9f7067c6759b1051e8ecb84e82cef569fe",
  "patch_info": {
    "commit_hash": "b43d1f9f7067c6759b1051e8ecb84e82cef569fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b43d1f9f7067c6759b1051e8ecb84e82cef569fe",
    "files": [
      "net/packet/af_packet.c"
    ],
    "message": "af_packet: set defaule value for tmo\n\nThere is softlockup when using TPACKET_V3:\n...\nNMI watchdog: BUG: soft lockup - CPU#2 stuck for 60010ms!\n(__irq_svc) from [<c0558a0c>] (_raw_spin_unlock_irqrestore+0x44/0x54)\n(_raw_spin_unlock_irqrestore) from [<c027b7e8>] (mod_timer+0x210/0x25c)\n(mod_timer) from [<c0549c30>]\n(prb_retire_rx_blk_timer_expired+0x68/0x11c)\n(prb_retire_rx_blk_timer_expired) from [<c027a7ac>]\n(call_timer_fn+0x90/0x17c)\n(call_timer_fn) from [<c027ab6c>] (run_timer_softirq+0x2d4/0x2fc)\n(run_timer_softirq) from [<c021eaf4>] (__do_softirq+0x218/0x318)\n(__do_softirq) from [<c021eea0>] (irq_exit+0x88/0xac)\n(irq_exit) from [<c0240130>] (msa_irq_exit+0x11c/0x1d4)\n(msa_irq_exit) from [<c0209cf0>] (handle_IPI+0x650/0x7f4)\n(handle_IPI) from [<c02015bc>] (gic_handle_irq+0x108/0x118)\n(gic_handle_irq) from [<c0558ee4>] (__irq_usr+0x44/0x5c)\n...\n\nIf __ethtool_get_link_ksettings() is failed in\nprb_calc_retire_blk_tmo(), msec and tmo will be zero, so tov_in_jiffies\nis zero and the timer expire for retire_blk_timer is turn to\nmod_timer(&pkc->retire_blk_timer, jiffies + 0),\nwhich will trigger cpu usage of softirq is 100%.\n\nFixes: f6fb8f100b80 (\"af-packet: TPACKET_V3 flexible buffer implementation.\")\nTested-by: Xiao Jiangfeng <xiaojiangfeng@huawei.com>\nSigned-off-by: Mao Wenan <maowenan@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/packet/af_packet.c||net/packet/af_packet.c"
    ]
  },
  "patch_diff": {
    "net/packet/af_packet.c||net/packet/af_packet.c": [
      "File: net/packet/af_packet.c -> net/packet/af_packet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "544:    msec = 1;",
      "545:    div = ecmd.base.speed / 1000;",
      "546:   }",
      "549:  mbits = (blk_size_in_bytes * 8) / (1024 * 1024);",
      "",
      "[Removed Lines]",
      "547:  }",
      "",
      "[Added Lines]",
      "547:  } else",
      "548:   return DEFAULT_PRB_RETIRE_TOV;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8b1c78e06e6167f49beb27be073faa2c6c5c6eff",
      "candidate_info": {
        "commit_hash": "8b1c78e06e6167f49beb27be073faa2c6c5c6eff",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8b1c78e06e6167f49beb27be073faa2c6c5c6eff",
        "files": [
          "drivers/gpu/drm/i915/display/intel_display.c",
          "drivers/gpu/drm/i915/display/intel_overlay.c",
          "drivers/gpu/drm/i915/gem/i915_gem_domain.c"
        ],
        "message": "drm/i915: Avoid calling i915_gem_object_unbind holding object lock\n\nIn the extreme case, we may wish to wait on an rcu-barrier to reap stale\nvm to purge the last of the object bindings. However, we are not allowed\nto use rcu_barrier() beneath the dma_resv (i.e. object) lock and do not\ntake lightly the prospect of unlocking a mutex deep in the bowels of the\nroutine. i915_gem_object_unbind() itself does not need the object lock,\nand it turns out the callers do not need to the unbind as part of a\nlocked sequence around set-cache-level, so rearrange the code to avoid\ntaking the object lock in the callers.\n\n<4> [186.816311] ======================================================\n<4> [186.816313] WARNING: possible circular locking dependency detected\n<4> [186.816316] 5.4.0-rc8-CI-CI_DRM_7486+ #1 Tainted: G     U\n<4> [186.816318] ------------------------------------------------------\n<4> [186.816320] perf_pmu/1321 is trying to acquire lock:\n<4> [186.816322] ffff88849487c4d8 (&mm->mmap_sem#2){++++}, at: __might_fault+0x39/0x90\n<4> [186.816331]\nbut task is already holding lock:\n<4> [186.816333] ffffe8ffffa05008 (&cpuctx_mutex){+.+.}, at: perf_event_ctx_lock_nested+0xa9/0x1b0\n<4> [186.816339]\nwhich lock already depends on the new lock.\n\n<4> [186.816341]\nthe existing dependency chain (in reverse order) is:\n<4> [186.816343]\n-> #6 (&cpuctx_mutex){+.+.}:\n<4> [186.816349]        __mutex_lock+0x9a/0x9d0\n<4> [186.816352]        perf_event_init_cpu+0xa4/0x140\n<4> [186.816357]        perf_event_init+0x19d/0x1cd\n<4> [186.816362]        start_kernel+0x372/0x4f4\n<4> [186.816365]        secondary_startup_64+0xa4/0xb0\n<4> [186.816381]\n-> #5 (pmus_lock){+.+.}:\n<4> [186.816385]        __mutex_lock+0x9a/0x9d0\n<4> [186.816387]        perf_event_init_cpu+0x6b/0x140\n<4> [186.816404]        cpuhp_invoke_callback+0x9b/0x9d0\n<4> [186.816406]        _cpu_up+0xa2/0x140\n<4> [186.816409]        do_cpu_up+0x61/0xa0\n<4> [186.816411]        smp_init+0x57/0x96\n<4> [186.816413]        kernel_init_freeable+0xac/0x1c7\n<4> [186.816416]        kernel_init+0x5/0x100\n<4> [186.816419]        ret_from_fork+0x24/0x50\n<4> [186.816421]\n-> #4 (cpu_hotplug_lock.rw_sem){++++}:\n<4> [186.816424]        cpus_read_lock+0x34/0xd0\n<4> [186.816427]        rcu_barrier+0xaa/0x190\n<4> [186.816429]        kernel_init+0x21/0x100\n<4> [186.816431]        ret_from_fork+0x24/0x50\n<4> [186.816433]\n-> #3 (rcu_state.barrier_mutex){+.+.}:\n<4> [186.816436]        __mutex_lock+0x9a/0x9d0\n<4> [186.816438]        rcu_barrier+0x23/0x190\n<4> [186.816502]        i915_gem_object_unbind+0x3a6/0x400 [i915]\n<4> [186.816537]        i915_gem_object_set_cache_level+0x32/0x90 [i915]\n<4> [186.816571]        i915_gem_object_pin_to_display_plane+0x5d/0x160 [i915]\n<4> [186.816612]        intel_pin_and_fence_fb_obj+0x9e/0x200 [i915]\n<4> [186.816679]        intel_plane_pin_fb+0x3f/0xd0 [i915]\n<4> [186.816717]        intel_prepare_plane_fb+0x130/0x520 [i915]\n<4> [186.816722]        drm_atomic_helper_prepare_planes+0x85/0x110\n<4> [186.816761]        intel_atomic_commit+0xc6/0x350 [i915]\n<4> [186.816764]        drm_atomic_helper_update_plane+0xed/0x110\n<4> [186.816768]        setplane_internal+0x97/0x190\n<4> [186.816770]        drm_mode_setplane+0xcd/0x190\n<4> [186.816773]        drm_ioctl_kernel+0xa7/0xf0\n<4> [186.816775]        drm_ioctl+0x2e1/0x390\n<4> [186.816778]        do_vfs_ioctl+0xa0/0x6f0\n<4> [186.816780]        ksys_ioctl+0x35/0x60\n<4> [186.816782]        __x64_sys_ioctl+0x11/0x20\n<4> [186.816785]        do_syscall_64+0x4f/0x210\n<4> [186.816787]        entry_SYSCALL_64_after_hwframe+0x49/0xbe\n<4> [186.816789]\n-> #2 (reservation_ww_class_mutex){+.+.}:\n<4> [186.816793]        __ww_mutex_lock.constprop.15+0xc3/0x1090\n<4> [186.816795]        ww_mutex_lock+0x39/0x70\n<4> [186.816798]        dma_resv_lockdep+0x10e/0x1f7\n<4> [186.816800]        do_one_initcall+0x58/0x2ff\n<4> [186.816802]        kernel_init_freeable+0x137/0x1c7\n<4> [186.816804]        kernel_init+0x5/0x100\n<4> [186.816806]        ret_from_fork+0x24/0x50\n<4> [186.816808]\n-> #1 (reservation_ww_class_acquire){+.+.}:\n<4> [186.816811]        dma_resv_lockdep+0xec/0x1f7\n<4> [186.816813]        do_one_initcall+0x58/0x2ff\n<4> [186.816815]        kernel_init_freeable+0x137/0x1c7\n<4> [186.816817]        kernel_init+0x5/0x100\n<4> [186.816819]        ret_from_fork+0x24/0x50\n<4> [186.816820]\n-> #0 (&mm->mmap_sem#2){++++}:\n<4> [186.816824]        __lock_acquire+0x1328/0x15d0\n<4> [186.816826]        lock_acquire+0xa7/0x1c0\n<4> [186.816828]        __might_fault+0x63/0x90\n<4> [186.816831]        _copy_to_user+0x1e/0x80\n<4> [186.816834]        perf_read+0x200/0x2b0\n<4> [186.816836]        vfs_read+0x96/0x160\n<4> [186.816838]        ksys_read+0x9f/0xe0\n<4> [186.816839]        do_syscall_64+0x4f/0x210\n<4> [186.816841]        entry_SYSCALL_64_after_hwframe+0x49/0xbe\n<4> [186.816843]\nother info that might help us debug this:\n\n<4> [186.816846] Chain exists of:\n  &mm->mmap_sem#2 --> pmus_lock --> &cpuctx_mutex\n\n<4> [186.816849]  Possible unsafe locking scenario:\n\n<4> [186.816851]        CPU0                    CPU1\n<4> [186.816853]        ----                    ----\n<4> [186.816854]   lock(&cpuctx_mutex);\n<4> [186.816856]                                lock(pmus_lock);\n<4> [186.816858]                                lock(&cpuctx_mutex);\n<4> [186.816860]   lock(&mm->mmap_sem#2);\n<4> [186.816861]\n *** DEADLOCK ***\n\nCloses: https://gitlab.freedesktop.org/drm/intel/issues/728\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nReviewed-by: Andi Shyti <andi.shyti@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20191206105527.1130413-5-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/display/intel_display.c||drivers/gpu/drm/i915/display/intel_display.c",
          "drivers/gpu/drm/i915/display/intel_overlay.c||drivers/gpu/drm/i915/display/intel_overlay.c",
          "drivers/gpu/drm/i915/gem/i915_gem_domain.c||drivers/gpu/drm/i915/gem/i915_gem_domain.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/display/intel_display.c||drivers/gpu/drm/i915/display/intel_display.c": [
          "File: drivers/gpu/drm/i915/display/intel_display.c -> drivers/gpu/drm/i915/display/intel_display.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2167:  wakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);",
          "2170:  atomic_inc(&dev_priv->gpu_error.pending_fb_pin);",
          "2181:  if (HAS_GMCH(dev_priv))",
          "2182:   pinctl |= PIN_MAPPABLE;",
          "",
          "[Removed Lines]",
          "2168:  i915_gem_object_lock(obj);",
          "2172:  pinctl = 0;",
          "",
          "[Added Lines]",
          "2179:  pinctl = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2219:  i915_vma_get(vma);",
          "2220: err:",
          "2221:  atomic_dec(&dev_priv->gpu_error.pending_fb_pin);",
          "2224:  intel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);",
          "2225:  return vma;",
          "2226: }",
          "",
          "[Removed Lines]",
          "2223:  i915_gem_object_unlock(obj);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/display/intel_overlay.c||drivers/gpu/drm/i915/display/intel_overlay.c": [
          "File: drivers/gpu/drm/i915/display/intel_overlay.c -> drivers/gpu/drm/i915/display/intel_overlay.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "759:  atomic_inc(&dev_priv->gpu_error.pending_fb_pin);",
          "762:  vma = i915_gem_object_pin_to_display_plane(new_bo,",
          "763:          0, NULL, PIN_MAPPABLE);",
          "765:  if (IS_ERR(vma)) {",
          "766:   ret = PTR_ERR(vma);",
          "767:   goto out_pin_section;",
          "",
          "[Removed Lines]",
          "761:  i915_gem_object_lock(new_bo);",
          "764:  i915_gem_object_unlock(new_bo);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/gem/i915_gem_domain.c||drivers/gpu/drm/i915/gem/i915_gem_domain.c": [
          "File: drivers/gpu/drm/i915/gem/i915_gem_domain.c -> drivers/gpu/drm/i915/gem/i915_gem_domain.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187: {",
          "188:  int ret;",
          "192:  if (obj->cache_level == cache_level)",
          "193:   return 0;",
          "196:  if (ret)",
          "197:   return ret;",
          "205: }",
          "207: int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,",
          "",
          "[Removed Lines]",
          "190:  assert_object_held(obj);",
          "195:  ret = i915_gem_object_unbind(obj, I915_GEM_OBJECT_UNBIND_ACTIVE);",
          "201:  i915_gem_object_set_cache_coherency(obj, cache_level);",
          "204:  return 0;",
          "",
          "[Added Lines]",
          "193:  ret = i915_gem_object_lock_interruptible(obj);",
          "198:  if (obj->cache_level != cache_level) {",
          "199:   i915_gem_object_set_cache_coherency(obj, cache_level);",
          "200:   obj->cache_dirty = true;",
          "201:  }",
          "203:  i915_gem_object_unlock(obj);",
          "206:  return i915_gem_object_unbind(obj, I915_GEM_OBJECT_UNBIND_ACTIVE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "282:   goto out;",
          "283:  }",
          "300: out:",
          "301:  i915_gem_object_put(obj);",
          "",
          "[Removed Lines]",
          "285:  if (obj->cache_level == level)",
          "286:   goto out;",
          "288:  ret = i915_gem_object_wait(obj,",
          "289:        I915_WAIT_INTERRUPTIBLE,",
          "290:        MAX_SCHEDULE_TIMEOUT);",
          "291:  if (ret)",
          "292:   goto out;",
          "294:  ret = i915_gem_object_lock_interruptible(obj);",
          "295:  if (ret == 0) {",
          "296:   ret = i915_gem_object_set_cache_level(obj, level);",
          "297:   i915_gem_object_unlock(obj);",
          "298:  }",
          "",
          "[Added Lines]",
          "287:  ret = i915_gem_object_set_cache_level(obj, level);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "318:  struct i915_vma *vma;",
          "319:  int ret;",
          "324:  if (HAS_LMEM(i915) && !i915_gem_object_is_lmem(obj))",
          "325:   return ERR_PTR(-EINVAL);",
          "",
          "[Removed Lines]",
          "321:  assert_object_held(obj);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "363:  vma->display_alignment = max_t(u64, vma->display_alignment, alignment);",
          "373:  return vma;",
          "374: }",
          "",
          "[Removed Lines]",
          "365:  __i915_gem_object_flush_for_display(obj);",
          "371:  obj->read_domains |= I915_GEM_DOMAIN_GTT;",
          "",
          "[Added Lines]",
          "352:  i915_gem_object_flush_if_display(obj);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0914d2bb11cc182039084ac3b961dc359b647468",
      "candidate_info": {
        "commit_hash": "0914d2bb11cc182039084ac3b961dc359b647468",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0914d2bb11cc182039084ac3b961dc359b647468",
        "files": [
          "net/packet/af_packet.c"
        ],
        "message": "af_packet: refactoring code for prb_calc_retire_blk_tmo\n\nIf __ethtool_get_link_ksettings() is failed and with\nnon-zero value, prb_calc_retire_blk_tmo() should return\nDEFAULT_PRB_RETIRE_TOV firstly.\n\nThis patch is to refactory code and make it more readable.\n\nSigned-off-by: Mao Wenan <maowenan@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/packet/af_packet.c||net/packet/af_packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ],
          "candidate": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ]
        }
      },
      "candidate_diff": {
        "net/packet/af_packet.c||net/packet/af_packet.c": [
          "File: net/packet/af_packet.c -> net/packet/af_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "520:     int blk_size_in_bytes)",
          "521: {",
          "522:  struct net_device *dev;",
          "524:  struct ethtool_link_ksettings ecmd;",
          "525:  int err;",
          "",
          "[Removed Lines]",
          "523:  unsigned int mbits = 0, msec = 0, div = 0, tmo = 0;",
          "",
          "[Added Lines]",
          "523:  unsigned int mbits, div;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "532:  }",
          "533:  err = __ethtool_get_link_ksettings(dev, &ecmd);",
          "534:  rtnl_unlock();",
          "548:   return DEFAULT_PRB_RETIRE_TOV;",
          "550:  mbits = (blk_size_in_bytes * 8) / (1024 * 1024);",
          "552:  if (div)",
          "553:   mbits /= div;",
          "557:  if (div)",
          "560: }",
          "562: static void prb_init_ft_ops(struct tpacket_kbdq_core *p1,",
          "",
          "[Removed Lines]",
          "535:  if (!err) {",
          "540:   if (ecmd.base.speed < SPEED_1000 ||",
          "541:       ecmd.base.speed == SPEED_UNKNOWN) {",
          "542:    return DEFAULT_PRB_RETIRE_TOV;",
          "543:   } else {",
          "544:    msec = 1;",
          "545:    div = ecmd.base.speed / 1000;",
          "546:   }",
          "547:  } else",
          "555:  tmo = mbits * msec;",
          "558:   return tmo+1;",
          "559:  return tmo;",
          "",
          "[Added Lines]",
          "535:  if (err)",
          "541:  if (ecmd.base.speed < SPEED_1000 ||",
          "542:      ecmd.base.speed == SPEED_UNKNOWN)",
          "543:   return DEFAULT_PRB_RETIRE_TOV;",
          "545:  div = ecmd.base.speed / 1000;",
          "552:   return mbits + 1;",
          "553:  return mbits;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
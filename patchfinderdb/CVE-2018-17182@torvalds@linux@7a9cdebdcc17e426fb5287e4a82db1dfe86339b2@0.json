{
  "cve_id": "CVE-2018-17182",
  "cve_desc": "An issue was discovered in the Linux kernel through 4.18.8. The vmacache_flush_all function in mm/vmacache.c mishandles sequence number overflows. An attacker can trigger a use-after-free (and possibly gain privileges) via certain thread creation, map, unmap, invalidation, and dereference operations.",
  "repo": "torvalds/linux",
  "patch_hash": "7a9cdebdcc17e426fb5287e4a82db1dfe86339b2",
  "patch_info": {
    "commit_hash": "7a9cdebdcc17e426fb5287e4a82db1dfe86339b2",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2",
    "files": [
      "include/linux/mm_types.h",
      "include/linux/mm_types_task.h",
      "include/linux/vm_event_item.h",
      "include/linux/vmacache.h",
      "mm/debug.c",
      "mm/vmacache.c"
    ],
    "message": "mm: get rid of vmacache_flush_all() entirely\n\nJann Horn points out that the vmacache_flush_all() function is not only\npotentially expensive, it's buggy too.  It also happens to be entirely\nunnecessary, because the sequence number overflow case can be avoided by\nsimply making the sequence number be 64-bit.  That doesn't even grow the\ndata structures in question, because the other adjacent fields are\nalready 64-bit.\n\nSo simplify the whole thing by just making the sequence number overflow\ncase go away entirely, which gets rid of all the complications and makes\nthe code faster too.  Win-win.\n\n[ Oleg Nesterov points out that the VMACACHE_FULL_FLUSHES statistics\n  also just goes away entirely with this ]\n\nReported-by: Jann Horn <jannh@google.com>\nSuggested-by: Will Deacon <will.deacon@arm.com>\nAcked-by: Davidlohr Bueso <dave@stgolabs.net>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "include/linux/mm_types.h||include/linux/mm_types.h",
      "include/linux/mm_types_task.h||include/linux/mm_types_task.h",
      "include/linux/vm_event_item.h||include/linux/vm_event_item.h",
      "include/linux/vmacache.h||include/linux/vmacache.h",
      "mm/debug.c||mm/debug.c",
      "mm/vmacache.c||mm/vmacache.c"
    ]
  },
  "patch_diff": {
    "include/linux/mm_types.h||include/linux/mm_types.h": [
      "File: include/linux/mm_types.h -> include/linux/mm_types.h"
    ],
    "include/linux/mm_types_task.h||include/linux/mm_types_task.h": [
      "File: include/linux/mm_types_task.h -> include/linux/mm_types_task.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "32: #define VMACACHE_MASK (VMACACHE_SIZE - 1)",
      "34: struct vmacache {",
      "36:  struct vm_area_struct *vmas[VMACACHE_SIZE];",
      "37: };",
      "",
      "[Removed Lines]",
      "35:  u32 seqnum;",
      "",
      "[Added Lines]",
      "35:  u64 seqnum;",
      "",
      "---------------"
    ],
    "include/linux/vm_event_item.h||include/linux/vm_event_item.h": [
      "File: include/linux/vm_event_item.h -> include/linux/vm_event_item.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "105: #ifdef CONFIG_DEBUG_VM_VMACACHE",
      "106:   VMACACHE_FIND_CALLS,",
      "107:   VMACACHE_FIND_HITS,",
      "109: #endif",
      "110: #ifdef CONFIG_SWAP",
      "111:   SWAP_RA,",
      "",
      "[Removed Lines]",
      "108:   VMACACHE_FULL_FLUSHES,",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "include/linux/vmacache.h||include/linux/vmacache.h": [
      "File: include/linux/vmacache.h -> include/linux/vmacache.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "10:  memset(tsk->vmacache.vmas, 0, sizeof(tsk->vmacache.vmas));",
      "11: }",
      "14: extern void vmacache_update(unsigned long addr, struct vm_area_struct *newvma);",
      "15: extern struct vm_area_struct *vmacache_find(struct mm_struct *mm,",
      "16:           unsigned long addr);",
      "",
      "[Removed Lines]",
      "13: extern void vmacache_flush_all(struct mm_struct *mm);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "24: static inline void vmacache_invalidate(struct mm_struct *mm)",
      "25: {",
      "26:  mm->vmacache_seqnum++;",
      "31: }",
      "",
      "[Removed Lines]",
      "29:  if (unlikely(mm->vmacache_seqnum == 0))",
      "30:   vmacache_flush_all(mm);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "mm/debug.c||mm/debug.c": [
      "File: mm/debug.c -> mm/debug.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "115: void dump_mm(const struct mm_struct *mm)",
      "116: {",
      "118: #ifdef CONFIG_MMU",
      "119:   \"get_unmapped_area %px\\n\"",
      "120: #endif",
      "",
      "[Removed Lines]",
      "117:  pr_emerg(\"mm %px mmap %px seqnum %d task_size %lu\\n\"",
      "",
      "[Added Lines]",
      "117:  pr_emerg(\"mm %px mmap %px seqnum %llu task_size %lu\\n\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:   \"tlb_flush_pending %d\\n\"",
      "143:   \"def_flags: %#lx(%pGv)\\n\",",
      "146: #ifdef CONFIG_MMU",
      "147:   mm->get_unmapped_area,",
      "148: #endif",
      "",
      "[Removed Lines]",
      "145:   mm, mm->mmap, mm->vmacache_seqnum, mm->task_size,",
      "",
      "[Added Lines]",
      "145:   mm, mm->mmap, (long long) mm->vmacache_seqnum, mm->task_size,",
      "",
      "---------------"
    ],
    "mm/vmacache.c||mm/vmacache.c": [
      "File: mm/vmacache.c -> mm/vmacache.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "19: #endif",
      "20: #define VMACACHE_HASH(addr) ((addr >> VMACACHE_SHIFT) & VMACACHE_MASK)",
      "",
      "[Removed Lines]",
      "30: void vmacache_flush_all(struct mm_struct *mm)",
      "31: {",
      "32:  struct task_struct *g, *p;",
      "34:  count_vm_vmacache_event(VMACACHE_FULL_FLUSHES);",
      "43:  if (atomic_read(&mm->mm_users) == 1)",
      "44:   return;",
      "46:  rcu_read_lock();",
      "47:  for_each_process_thread(g, p) {",
      "54:   if (mm == p->mm)",
      "55:    vmacache_flush(p);",
      "56:  }",
      "57:  rcu_read_unlock();",
      "58: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "152a2d199e1385c6ccef17c24555103b30447c91",
      "candidate_info": {
        "commit_hash": "152a2d199e1385c6ccef17c24555103b30447c91",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/152a2d199e1385c6ccef17c24555103b30447c91",
        "files": [
          "mm/debug.c"
        ],
        "message": "mm/debug.c: provide useful debugging information for VM_BUG\n\nWith the recent addition of hashed kernel pointers, places which need to\nproduce useful debug output have to specify %px, not %p.  This patch\nfixes all the VM debug to use %px.  This is appropriate because it's\ndebug output that the user should never be able to trigger, and kernel\ndevelopers need to see the actual pointers.\n\nLink: http://lkml.kernel.org/r/20171219133236.GE13680@bombadil.infradead.org\nSigned-off-by: Matthew Wilcox <mawilcox@microsoft.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: \"Tobin C. Harding\" <me@tobin.cc>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/debug.c||mm/debug.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/debug.c||mm/debug.c"
          ],
          "candidate": [
            "mm/debug.c||mm/debug.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/debug.c||mm/debug.c": [
          "File: mm/debug.c -> mm/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:  int mapcount = PageSlab(page) ? 0 : page_mapcount(page);",
          "54:     page, page_ref_count(page), mapcount,",
          "55:     page->mapping, page_to_pgoff(page));",
          "56:  if (PageCompound(page))",
          "",
          "[Removed Lines]",
          "53:  pr_emerg(\"page:%p count:%d mapcount:%d mapping:%p index:%#lx\",",
          "",
          "[Added Lines]",
          "53:  pr_emerg(\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70: #ifdef CONFIG_MEMCG",
          "71:  if (page->mem_cgroup)",
          "73: #endif",
          "74: }",
          "",
          "[Removed Lines]",
          "72:   pr_alert(\"page->mem_cgroup:%p\\n\", page->mem_cgroup);",
          "",
          "[Added Lines]",
          "72:   pr_alert(\"page->mem_cgroup:%px\\n\", page->mem_cgroup);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85: void dump_vma(const struct vm_area_struct *vma)",
          "86: {",
          "91:   \"flags: %#lx(%pGv)\\n\",",
          "92:   vma, (void *)vma->vm_start, (void *)vma->vm_end, vma->vm_next,",
          "93:   vma->vm_prev, vma->vm_mm,",
          "",
          "[Removed Lines]",
          "87:  pr_emerg(\"vma %p start %p end %p\\n\"",
          "88:   \"next %p prev %p mm %p\\n\"",
          "89:   \"prot %lx anon_vma %p vm_ops %p\\n\"",
          "90:   \"pgoff %lx file %p private_data %p\\n\"",
          "",
          "[Added Lines]",
          "87:  pr_emerg(\"vma %px start %px end %px\\n\"",
          "88:   \"next %px prev %px mm %px\\n\"",
          "89:   \"prot %lx anon_vma %px vm_ops %px\\n\"",
          "90:   \"pgoff %lx file %px private_data %px\\n\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "101: void dump_mm(const struct mm_struct *mm)",
          "102: {",
          "104: #ifdef CONFIG_MMU",
          "106: #endif",
          "107:   \"mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\\n\"",
          "109:   \"hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\\n\"",
          "110:   \"pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\\n\"",
          "111:   \"start_code %lx end_code %lx start_data %lx end_data %lx\\n\"",
          "112:   \"start_brk %lx brk %lx start_stack %lx\\n\"",
          "113:   \"arg_start %lx arg_end %lx env_start %lx env_end %lx\\n\"",
          "115: #ifdef CONFIG_AIO",
          "117: #endif",
          "118: #ifdef CONFIG_MEMCG",
          "120: #endif",
          "122: #ifdef CONFIG_MMU_NOTIFIER",
          "124: #endif",
          "125: #ifdef CONFIG_NUMA_BALANCING",
          "126:   \"numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\\n\"",
          "",
          "[Removed Lines]",
          "103:  pr_emerg(\"mm %p mmap %p seqnum %d task_size %lu\\n\"",
          "105:   \"get_unmapped_area %p\\n\"",
          "108:   \"pgd %p mm_users %d mm_count %d pgtables_bytes %lu map_count %d\\n\"",
          "114:   \"binfmt %p flags %lx core_state %p\\n\"",
          "116:   \"ioctx_table %p\\n\"",
          "119:   \"owner %p \"",
          "121:   \"exe_file %p\\n\"",
          "123:   \"mmu_notifier_mm %p\\n\"",
          "",
          "[Added Lines]",
          "103:  pr_emerg(\"mm %px mmap %px seqnum %d task_size %lu\\n\"",
          "105:   \"get_unmapped_area %px\\n\"",
          "108:   \"pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\\n\"",
          "114:   \"binfmt %px flags %lx core_state %px\\n\"",
          "116:   \"ioctx_table %px\\n\"",
          "119:   \"owner %px \"",
          "121:   \"exe_file %px\\n\"",
          "123:   \"mmu_notifier_mm %px\\n\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
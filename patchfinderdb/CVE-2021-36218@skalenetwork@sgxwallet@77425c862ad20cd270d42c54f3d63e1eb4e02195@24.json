{
  "cve_id": "CVE-2021-36218",
  "cve_desc": "An issue was discovered in SKALE sgxwallet 1.58.3. sgx_disp_ippsAES_GCMEncrypt allows an out-of-bounds write, resulting in a segfault and compromised enclave. This issue describes a buffer overflow, which was resolved prior to v1.77.0 and not reproducible in latest sgxwallet v1.77.0",
  "repo": "skalenetwork/sgxwallet",
  "patch_hash": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
  "patch_info": {
    "commit_hash": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
    "repo": "skalenetwork/sgxwallet",
    "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195",
    "files": [
      "BLSCrypto.cpp",
      "DKGCrypto.cpp",
      "ECDSACrypto.cpp",
      "SEKManager.cpp",
      "SGXWalletServer.cpp",
      "secure_enclave/AESUtils.c",
      "secure_enclave/AESUtils.h",
      "secure_enclave/secure_enclave.c",
      "secure_enclave/secure_enclave.edl",
      "testw.cpp"
    ],
    "message": "SKALE-3205-restart",
    "before_after_code_files": [
      "BLSCrypto.cpp||BLSCrypto.cpp",
      "DKGCrypto.cpp||DKGCrypto.cpp",
      "ECDSACrypto.cpp||ECDSACrypto.cpp",
      "SEKManager.cpp||SEKManager.cpp",
      "SGXWalletServer.cpp||SGXWalletServer.cpp",
      "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
      "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
      "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
      "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl",
      "testw.cpp||testw.cpp"
    ]
  },
  "patch_diff": {
    "BLSCrypto.cpp||BLSCrypto.cpp": [
      "File: BLSCrypto.cpp -> BLSCrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "87:     CHECK_STATE(_hexArrayLen > 2 * _len);",
      "90:         _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];",
      "91:         _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];",
      "92:     }",
      "",
      "[Removed Lines]",
      "89:     for (int j = 0; j < _len; j++) {",
      "",
      "[Added Lines]",
      "89:     for (uint64_t j = 0; j < _len; j++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:     CHECK_STATE(_bin_len)",
      "110:     CHECK_STATE(len != 2 * _max_length + 1);",
      "",
      "[Removed Lines]",
      "108:     int len = strnlen(_hex, 2 * _max_length + 1);",
      "",
      "[Added Lines]",
      "108:     uint64_t len = strnlen(_hex, 2 * _max_length + 1);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "121:         int high = char2int((char) _hex[i * 2]);",
      "122:         int low = char2int((char) _hex[i * 2 + 1]);",
      "",
      "[Removed Lines]",
      "120:     for (int i = 0; i < len / 2; i++) {",
      "",
      "[Added Lines]",
      "120:     for (uint64_t i = 0; i < len / 2; i++) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "248:     strncpy(keyArray->data(), _key, BUF_LEN);",
      "252:     sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);",
      "",
      "[Removed Lines]",
      "250:     unsigned int encryptedLen = 0;",
      "",
      "[Added Lines]",
      "251:     uint64_t encryptedLen = 0;",
      "",
      "---------------"
    ],
    "DKGCrypto.cpp||DKGCrypto.cpp": [
      "File: DKGCrypto.cpp -> DKGCrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "135: string gen_dkg_poly(int _t) {",
      "136:     vector<char> errMsg(BUF_LEN, 0);",
      "137:     int errStatus = 0;",
      "140:     vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
      "145:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
      "147:     uint64_t length = enc_len;;",
      "",
      "[Removed Lines]",
      "138:     uint32_t enc_len = 0;",
      "144:     sgx_status_t status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
      "",
      "[Added Lines]",
      "138:     uint64_t enc_len = 0;",
      "142:     sgx_status_t status = trustedGenDkgSecretAES(",
      "143:             eid, &errStatus,errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "215:     for (int i = 0; i < _n; i++) {",
      "216:         vector <uint8_t> encryptedSkey(BUF_LEN, 0);",
      "218:         vector<char> currentShare(193, 0);",
      "219:         vector<char> sShareG2(320, 0);",
      "",
      "[Removed Lines]",
      "217:         uint32_t decLen;",
      "",
      "[Added Lines]",
      "217:         uint64_t decLen;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "300:         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
      "301:     }",
      "305:     sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,",
      "306:                                                  &enc_bls_len);",
      "",
      "[Removed Lines]",
      "303:     uint32_t enc_bls_len = 0;",
      "",
      "[Added Lines]",
      "303:     uint64_t enc_bls_len = 0;",
      "",
      "---------------"
    ],
    "ECDSACrypto.cpp||ECDSACrypto.cpp": [
      "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "54:     vector<char> pub_key_x(BUF_LEN, 0);",
      "55:     vector<char> pub_key_y(BUF_LEN, 0);",
      "59:     sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,",
      "60:                                         errMsg.data(), encr_pr_key.data(), &enc_len,",
      "",
      "[Removed Lines]",
      "57:     uint32_t enc_len = 0;",
      "",
      "[Added Lines]",
      "57:     uint64_t enc_len = 0;",
      "",
      "---------------"
    ],
    "SEKManager.cpp||SEKManager.cpp": [
      "File: SEKManager.cpp -> SEKManager.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: void create_test_key() {",
      "53:     int errStatus = 0;",
      "54:     vector<char> errMsg(1024, 0);",
      "57:     SAFE_UINT8_BUF(encrypted_key, BUF_LEN);",
      "",
      "[Removed Lines]",
      "55:     uint32_t enc_len;",
      "",
      "[Added Lines]",
      "55:     uint64_t enc_len;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "110:     auto encrypted_SEK = make_shared < vector < uint8_t >> (BUF_LEN, 0);",
      "114:     sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,",
      "115:                                                SEK.c_str());",
      "",
      "[Removed Lines]",
      "112:     uint32_t l = 0;",
      "",
      "[Added Lines]",
      "112:     uint64_t l = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "127:     vector<char> errMsg(1024, 0);",
      "128:     int err_status = 0;",
      "129:     vector <uint8_t> encrypted_SEK(1024, 0);",
      "132:     SAFE_CHAR_BUF(SEK, 65);",
      "",
      "[Removed Lines]",
      "130:     uint32_t enc_len = 0;",
      "",
      "[Added Lines]",
      "130:     uint64_t enc_len = 0;",
      "",
      "---------------"
    ],
    "SGXWalletServer.cpp||SGXWalletServer.cpp": [
      "File: SGXWalletServer.cpp -> SGXWalletServer.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "564:         vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);",
      "567:             throw SGXException(UNKNOWN_ERROR, \"\");",
      "568:         }",
      "",
      "[Removed Lines]",
      "566:         if (public_keys.size() != n) {",
      "",
      "[Added Lines]",
      "566:         if (public_keys.size() != (uint64_t)n) {",
      "",
      "---------------"
    ],
    "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c": [
      "File: secure_enclave/AESUtils.c -> secure_enclave/AESUtils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: #include \"stdlib.h\"",
      "28: #include <string.h>",
      "30: #include \"AESUtils.h\"",
      "32: sgx_aes_gcm_128bit_key_t AES_key;",
      "33: sgx_aes_gcm_128bit_key_t AES_DH_key;",
      "37:     if (!message) {",
      "38:         LOG_ERROR(\"Null message in AES_encrypt\");",
      "",
      "[Removed Lines]",
      "35: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {",
      "",
      "[Added Lines]",
      "37: #define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);",
      "39: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned  char type,",
      "40:                 unsigned char decryptable, uint64_t* resultLen) {",
      "44:     if (!type) {",
      "45:         LOG_ERROR(\"Null type in AES_encrypt\");",
      "46:         return -1;",
      "47:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "47:     uint64_t len = strlen(message) + 1;",
      "50:         LOG_ERROR(\"Output buffer too small\");",
      "51:         return -3;",
      "52:     }",
      "54:     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);",
      "57:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,",
      "58:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "59:                                                      NULL, 0,",
      "60:                                                      (sgx_aes_gcm_128bit_tag_t *) encr_message);",
      "62:     return status;",
      "63: }",
      "",
      "[Removed Lines]",
      "49:     if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {",
      "56:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message),",
      "",
      "[Added Lines]",
      "61:     if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {",
      "66:     SAFE_CHAR_BUF(fullMessage, len + 2);",
      "68:     fullMessage[0] = type;",
      "69:     fullMessage[1] = decryptable;",
      "71:     strncpy(fullMessage + 2, message, len );",
      "73:     len = len + 2;",
      "74:     message = fullMessage;",
      "78:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "96:                                                    NULL, 0,",
      "97:                                                    (sgx_aes_gcm_128bit_tag_t *)encr_message);",
      "133: }",
      "",
      "[Removed Lines]",
      "99:   return status;",
      "100: }",
      "105: int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen) {",
      "107:     if (!message) {",
      "108:         LOG_ERROR(\"Null message in AES_encrypt_DH\");",
      "109:         return -1;",
      "110:     }",
      "112:     if (!encr_message) {",
      "113:         LOG_ERROR(\"Null encr message in AES_encrypt_DH\");",
      "114:         return -2;",
      "115:     }",
      "117:     uint64_t len = strlen(message) + 1;",
      "119:     if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {",
      "120:         LOG_ERROR(\"Output buffer too small\");",
      "121:         return -3;",
      "122:     }",
      "124:     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);",
      "126:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_DH_key, (uint8_t*)message, strlen(message),",
      "127:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,",
      "128:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "129:                                                      NULL, 0,",
      "130:                                                      (sgx_aes_gcm_128bit_tag_t *) encr_message);",
      "132:     return status;",
      "135: int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {",
      "137:     if (!message) {",
      "138:         LOG_ERROR(\"Null message in AES_encrypt_DH\");",
      "139:         return -1;",
      "140:     }",
      "142:     if (!encr_message) {",
      "143:         LOG_ERROR(\"Null encr message in AES_encrypt_DH\");",
      "144:         return -2;",
      "145:     }",
      "148:     if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {",
      "149:         LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");",
      "150:         return -1;",
      "151:     }",
      "155:     uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;",
      "157:     if (msgLen < len) {",
      "158:         LOG_ERROR(\"Output buffer not large enough\");",
      "159:         return -2;",
      "160:     }",
      "162:     sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_DH_key,",
      "163:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,",
      "164:                                                      (unsigned char*) message,",
      "165:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "166:                                                      NULL, 0,",
      "167:                                                      (sgx_aes_gcm_128bit_tag_t *)encr_message);",
      "169:     return status;",
      "170: }",
      "",
      "[Added Lines]",
      "123:   for (int i = 2; i < strlen(message) + 1; i++) {",
      "124:       message[i - 2 ] = message[i];",
      "125:   }",
      "127:   return status;",
      "",
      "---------------"
    ],
    "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h": [
      "File: secure_enclave/AESUtils.h -> secure_enclave/AESUtils.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: extern sgx_aes_gcm_128bit_key_t AES_key;",
      "28: extern sgx_aes_gcm_128bit_key_t AES_DH_key;",
      "31: int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;",
      "33: int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen);",
      "",
      "[Removed Lines]",
      "30: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen);",
      "",
      "[Added Lines]",
      "30: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen,",
      "31:                 unsigned char type, unsigned char decryptable, uint64_t* resultLen);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "36: void derive_DH_Key();",
      "39: #endif //SGXD_AESUTILS_H",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "39: #define ECDSA '1'",
      "40: #define BLS '2'",
      "41: #define DKG '3'",
      "43: #define DECRYPTABLE '1'",
      "44: #define NON_DECRYPTABLE '2'",
      "",
      "---------------"
    ],
    "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
      "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "122:         abort(); \\",
      "123:     } else {called = true;};",
      "126:     CALL_ONCE",
      "127:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "125: void trustedEnclaveInit(uint32_t _logLevel) {",
      "",
      "[Added Lines]",
      "125: void trustedEnclaveInit(uint64_t _logLevel) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "234: void sealHexSEK(int *errStatus, char *errString,",
      "236:     CALL_ONCE",
      "237:     LOG_INFO(__FUNCTION__);",
      "238:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "235:                         uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {",
      "",
      "[Added Lines]",
      "235:                         uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "255:                                            (sgx_sealed_data_t *) encrypted_sek);",
      "256:     CHECK_STATUS(\"seal SEK failed after SEK generation\");",
      "260:     CHECK_STATE(encrypt_text_length = plaintextLen);",
      "",
      "[Removed Lines]",
      "258:     uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "[Added Lines]",
      "258:     uint64_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "263:     SAFE_CHAR_BUF(unsealedKey, BUF_LEN);",
      "264:     uint32_t decLen = BUF_LEN;",
      "267:     CHECK_STATE(add_text_length == 0);",
      "268:     CHECK_STATE(sgx_is_within_enclave(encrypted_sek,sizeof(sgx_sealed_data_t)));",
      "269:     status = sgx_unseal_data((const sgx_sealed_data_t *)encrypted_sek, NULL, NULL,",
      "",
      "[Removed Lines]",
      "266:     uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "[Added Lines]",
      "266:     uint64_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "279: }",
      "281: void trustedGenerateSEK(int *errStatus, char *errString,",
      "283:     CALL_ONCE",
      "284:     LOG_INFO(__FUNCTION__);",
      "285:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "282:                         uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {",
      "",
      "[Added Lines]",
      "282:                         uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "341: }",
      "343: void trustedSetSEK_backup(int *errStatus, char *errString,",
      "345:     CALL_ONCE",
      "346:     LOG_INFO(__FUNCTION__);",
      "347:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "344:                           uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {",
      "",
      "[Added Lines]",
      "344:                           uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "372: void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,",
      "374:     LOG_INFO(__FUNCTION__);",
      "375:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "373:                                 uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
      "",
      "[Added Lines]",
      "373:                                 uint8_t *encryptedPrivateKey, uint64_t *enc_len, char *pub_key_x, char *pub_key_y) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "410:     }",
      "411:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
      "414:     mpz_get_str(arr_skey_str, ECDSA_SKEY_BASE, skey);",
      "415:     n_zeroes = 64 - strlen(arr_skey_str);",
      "416:     for (int i = 0; i < n_zeroes; i++) {",
      "417:         skey_str[i] = '0';",
      "418:     }",
      "419:     strncpy(skey_str + n_zeroes, arr_skey_str, 65 - n_zeroes);",
      "421:     snprintf(errString, BUF_LEN, \"skey len is %d\\n\", (int) strlen(skey_str));",
      "424:     CHECK_STATUS(\"ecdsa private key encryption failed\");",
      "430:     CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");",
      "",
      "[Removed Lines]",
      "413:     SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN);SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);",
      "420:     skey_str[ECDSA_SKEY_LEN - 1] = 0;",
      "423:     int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);",
      "428:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "413:     SAFE_CHAR_BUF(skey_str, BUF_LEN);",
      "414:     SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);",
      "423:     int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN,",
      "424:                              ECDSA, NON_DECRYPTABLE, enc_len);",
      "427:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "439: }",
      "441: void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,",
      "443:     LOG_DEBUG(__FUNCTION__);",
      "444:     INIT_ERROR_STATE",
      "448:     mpz_t privateKeyMpz;",
      "449:     mpz_init(privateKeyMpz);",
      "",
      "[Removed Lines]",
      "442:                                  uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {",
      "446:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "441:                                  uint8_t *encryptedPrivateKey, uint64_t enc_len, char *pub_key_x, char *pub_key_y) {",
      "445:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "455:     CHECK_STATE(pub_key_x);",
      "456:     CHECK_STATE(pub_key_y);",
      "459:     CHECK_STATUS2(\"AES_decrypt failed with status %d\");",
      "461:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';",
      "",
      "[Removed Lines]",
      "458:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "457:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "516: static uint64_t sigCounter = 0;",
      "519:                          const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {",
      "520:     LOG_DEBUG(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "518: void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len,",
      "",
      "[Added Lines]",
      "517: void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "526:     CHECK_STATE(sigR);",
      "527:     CHECK_STATE(sigS);",
      "531:     mpz_t privateKeyMpz;",
      "532:     mpz_init(privateKeyMpz);",
      "",
      "[Removed Lines]",
      "529:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "528:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "534:     mpz_init(msgMpz);",
      "535:     signature sign = signature_init();",
      "539:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
      "",
      "[Removed Lines]",
      "537:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "536:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "602: void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
      "605:     LOG_DEBUG(__FUNCTION__);",
      "606:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "603:                           uint32_t enc_len, char *key) {",
      "",
      "[Added Lines]",
      "602:                           uint64_t enc_len, char *key) {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "615:     if (status != 0) {",
      "",
      "[Removed Lines]",
      "613:     int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);",
      "",
      "[Added Lines]",
      "612:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "638: void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,",
      "640:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "639:                           uint8_t *encryptedPrivateKey, uint32_t *enc_len) {",
      "",
      "[Added Lines]",
      "638:                           uint8_t *encryptedPrivateKey, uint64_t *enc_len) {",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "652:     CHECK_STATUS2(\"AES encrypt failed with status %d\");",
      "656:     SAFE_CHAR_BUF(decryptedKey, BUF_LEN);",
      "660:     CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");",
      "",
      "[Removed Lines]",
      "650:     int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);",
      "658:     status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);",
      "",
      "[Added Lines]",
      "649:     int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,",
      "650:                              DKG, DECRYPTABLE, enc_len);",
      "656:     status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "672:     if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {",
      "673:         snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");",
      "674:         LOG_ERROR(errString);",
      "675:         goto clean;",
      "676:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "672:         LOG_ERROR(key);",
      "673:         LOG_ERROR(decryptedKey);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "686: void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
      "688:                               char *_hashY, char *signature) {",
      "689:     LOG_DEBUG(__FUNCTION__);",
      "690:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "687:                               uint32_t enc_len, char *_hashX,",
      "",
      "[Added Lines]",
      "687:                               uint64_t enc_len, char *_hashX,",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "726: }",
      "728: void",
      "730:     LOG_INFO(__FUNCTION__);",
      "731:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "729: trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
      "",
      "[Added Lines]",
      "729: trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "739:     CHECK_STATUS(\"gen_dkg_poly failed\")",
      "743:     CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");",
      "747:     SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);",
      "",
      "[Removed Lines]",
      "741:     status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);",
      "",
      "[Added Lines]",
      "741:     status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN,",
      "742:                          DKG, DECRYPTABLE, enc_len);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "769: void",
      "770: trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,",
      "772:                            uint8_t *decrypted_dkg_secret) {",
      "773:     LOG_INFO(__FUNCTION__);",
      "774:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "771:                            uint32_t enc_len,",
      "",
      "[Added Lines]",
      "772:                            uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "790: }",
      "794:     LOG_INFO(__FUNCTION__);",
      "795:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "793: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {",
      "",
      "[Added Lines]",
      "794: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t enc_len) {",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "810:     LOG_INFO(\"SGX call completed\");",
      "811: }",
      "814:                                        char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,",
      "815:                                        uint8_t ind) {",
      "817:     LOG_INFO(__FUNCTION__);",
      "818:     INIT_ERROR_STATE",
      "821:     int status;",
      "823:     CHECK_STATE(encrypted_skey);",
      "",
      "[Removed Lines]",
      "813: void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,",
      "820:     uint32_t enc_len;",
      "",
      "[Added Lines]",
      "814: void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len,",
      "821:     uint64_t enc_len;",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "828:     LOG_DEBUG(__FUNCTION__);",
      "832:     SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN);",
      "",
      "[Removed Lines]",
      "830:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "831:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "836:     CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");",
      "840:     skey[ECDSA_SKEY_LEN - 1] = 0;",
      "",
      "[Removed Lines]",
      "838:     status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "839:     status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "848:     status = gen_session_key(skey, pub_keyB, common_key);",
      "850:     CHECK_STATUS(\"gen_session_key failed\")",
      "854:     status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind);",
      "855:     CHECK_STATUS(\"calc secret share failed\")",
      "",
      "[Removed Lines]",
      "846:     SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);",
      "852:     SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "847:     SAFE_CHAR_BUF(common_key, BUF_LEN);",
      "853:     SAFE_CHAR_BUF(s_share, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "858:     status = calc_secret_shareG2(s_share, s_shareG2);",
      "859:     CHECK_STATUS(\"invalid decr secret share\");",
      "862:     status=xor_encrypt(common_key, s_share, cypher);",
      "864:     CHECK_STATUS(\"xor_encrypt failed\")",
      "",
      "[Removed Lines]",
      "861:     SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "862:     SAFE_CHAR_BUF(cypher, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "875:     LOG_INFO(\"SGX call completed\");",
      "876: }",
      "879:                                char *public_shares,",
      "880:                                unsigned _t, unsigned _n) {",
      "881:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "878: void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
      "",
      "[Added Lines]",
      "879: void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "913:     CHECK_STATE(s_share);",
      "914:     CHECK_STATE(encryptedPrivateKey);",
      "918:     mpz_t s;",
      "919:     mpz_init(s);",
      "923:     CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");",
      "927:     strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);",
      "931:     status = session_key_recover(skey, s_share, common_key);",
      "933:     CHECK_STATUS(\"session_key_recover failed\");",
      "937:     status=xor_decrypt(common_key, encr_sshare, decr_sshare);",
      "",
      "[Removed Lines]",
      "916:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "921:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "925:     SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);",
      "929:     SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);",
      "935:     SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "917:     SAFE_CHAR_BUF(skey,BUF_LEN);",
      "922:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "926:     SAFE_CHAR_BUF(encr_sshare, BUF_LEN);",
      "930:     SAFE_CHAR_BUF(common_key, BUF_LEN);",
      "936:     SAFE_CHAR_BUF(decr_sshare, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "955: void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,",
      "956:                             uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key,",
      "959:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "957:                             uint32_t *enc_bls_key_len) {",
      "",
      "[Added Lines]",
      "958:                             uint64_t *enc_bls_key_len) {",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "964:     CHECK_STATE(encryptedPrivateKey);",
      "965:     CHECK_STATE(encr_bls_key);",
      "969:     mpz_t sum;",
      "970:     mpz_init(sum);",
      "",
      "[Removed Lines]",
      "967:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "968:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "978:     mpz_init(bls_key);",
      "982:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
      "984:     skey[ECDSA_SKEY_LEN - 1] = 0;",
      "",
      "[Removed Lines]",
      "981:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "982:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1038:     strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);",
      "1039:     key_share[BLS_KEY_LENGTH - 1] = 0;",
      "1043:     CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");",
      "1047:     SET_SUCCESS",
      "1048:     clean:",
      "",
      "[Removed Lines]",
      "1041:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);",
      "",
      "[Added Lines]",
      "1042:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1064:     CHECK_STATE(bls_pub_key);",
      "1065:     CHECK_STATE(encryptedPrivateKey);",
      "1071:     CHECK_STATUS2(\"AES decrypt failed %d\");",
      "",
      "[Removed Lines]",
      "1067:     SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);",
      "1069:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "1066:     SAFE_CHAR_BUF(skey_hex, BUF_LEN);",
      "1068:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);",
      "",
      "---------------"
    ],
    "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl": [
      "File: secure_enclave/secure_enclave.edl -> secure_enclave/secure_enclave.edl",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:  trusted {",
      "12:   include \"sgx_tgmp.h\"",
      "17:         public void trustedGenerateSEK(",
      "18:                                 [out] int *errStatus,",
      "19:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "20:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,",
      "22:                                 [out, count = 65] char* hex_SEK);",
      "24:         public void trustedSetSEK(",
      "",
      "[Removed Lines]",
      "14:   public void trustedEnclaveInit(uint32_t _logLevel);",
      "21:                                 [out] uint32_t *enc_len,",
      "",
      "[Added Lines]",
      "14:   public void trustedEnclaveInit(uint64_t _logLevel);",
      "21:                                 [out] uint64_t *enc_len,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "30:                                 [out] int *errStatus,",
      "31:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "32:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,",
      "34:                                 [in, string] const char* SEK_hex);",
      "36:         public void trustedGenerateEcdsaKeyAES (",
      "37:                                 [out] int *errStatus,",
      "38:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "39:                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "41:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,",
      "42:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);",
      "",
      "[Removed Lines]",
      "33:                                 [out] uint32_t *enc_len,",
      "40:                                 [out] uint32_t *enc_len,",
      "",
      "[Added Lines]",
      "33:                                 [out] uint64_t *enc_len,",
      "40:                                 [out] uint64_t *enc_len,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "45:                                 [out] int *errStatus,",
      "46:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "47:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "49:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,",
      "50:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);",
      "",
      "[Removed Lines]",
      "48:                                 uint32_t dec_len,",
      "",
      "[Added Lines]",
      "48:                                 uint64_t dec_len,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "53:                                 [out] int *errStatus,",
      "54:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "55:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "57:                                 [in, string] const char* hash,",
      "58:                                 [out, count = SMALL_BUF_SIZE] char* sig_r,",
      "59:                                 [out, count = SMALL_BUF_SIZE] char* sig_s,",
      "",
      "[Removed Lines]",
      "56:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "56:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "65:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "66:                                 [in, count = SMALL_BUF_SIZE] const char* key,",
      "67:                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "70:         public void trustedDecryptKeyAES (",
      "71:                                 [out] int *errStatus,",
      "72:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "73:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "75:                                 [out, count = SMALL_BUF_SIZE] char* key );",
      "77:         public void trustedGenDkgSecretAES (",
      "78:                                 [out] int *errStatus,",
      "79:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "80:                                 [out, count = 3072] uint8_t* encrypted_dkg_secret,",
      "83:         public void trustedDecryptDkgSecretAES (",
      "84:                                 [out] int *errStatus,",
      "85:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "86:                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,",
      "88:                                 [out, count = 3072] uint8_t* decrypted_dkg_secret",
      "89:                                 );",
      "",
      "[Removed Lines]",
      "68:                                 [out] uint32_t *enc_len);",
      "74:                                 uint32_t enc_len,",
      "81:                                 [out] uint32_t * enc_len, size_t _t);",
      "87:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "68:                                 [out] uint64_t *enc_len);",
      "74:                                 uint64_t enc_len,",
      "81:                                 [out] uint64_t * enc_len, size_t _t);",
      "87:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "92:                                 [out] int *errStatus,",
      "93:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "94:                                 [in, count = 3050] uint8_t* encrypted_poly,",
      "97:         public void trustedGetEncryptedSecretShareAES(",
      "98:                                 [out]int *errStatus,",
      "99:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "100:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_skey,",
      "102:                                 [out, count = 193] char* result_str,",
      "103:                                 [out, count = 320] char* s_shareG2,",
      "104:                                 [in, string] char* pub_keyB,",
      "",
      "[Removed Lines]",
      "95:                                 uint32_t enc_len);",
      "101:                                 [out] uint32_t* dec_len,",
      "",
      "[Added Lines]",
      "95:                                 uint64_t enc_len);",
      "101:                                 [out] uint64_t* dec_len,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "110:                                 [out] int *errStatus,",
      "111:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "112:                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,",
      "114:                                 [out, count = 10000] char* public_shares,",
      "115:                                 unsigned _t,",
      "116:                                 unsigned _n);",
      "",
      "[Removed Lines]",
      "113:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "113:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "133:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "134:                                 uint64_t key_len,",
      "135:                                 [out, count = SMALL_BUF_SIZE] uint8_t * encr_bls_key,",
      "138:         public void trustedBlsSignMessageAES (",
      "139:                                 [out] int *errStatus,",
      "140:                                 [out, count = TINY_BUF_SIZE] char* err_string,",
      "141:                                 [in, count = TINY_BUF_SIZE] uint8_t* encrypted_key,",
      "143:                                 [in, string] char* hashX ,",
      "144:                                 [in, string] char* hashY,",
      "145:                                 [out, count = SMALL_BUF_SIZE] char* signature);",
      "",
      "[Removed Lines]",
      "136:                                 [out] uint32_t *enc_bls_key_len);",
      "142:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "136:                                 [out] uint64_t *enc_bls_key_len);",
      "142:                                 uint64_t enc_len,",
      "",
      "---------------"
    ],
    "testw.cpp||testw.cpp": [
      "File: testw.cpp -> testw.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "127:     vector<char> pubKeyX(BUF_LEN, 0);",
      "128:     vector<char> pubKeyY(BUF_LEN, 0);",
      "131:     PRINT_SRC_LINE",
      "132:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,",
      "133:                                              pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "130:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "130:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "160:     vector <uint8_t> encrPrivKey(BUF_LEN, 0);",
      "161:     vector<char> pubKeyX(BUF_LEN, 0);",
      "162:     vector<char> pubKeyY(BUF_LEN, 0);",
      "164:     PRINT_SRC_LINE",
      "165:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,",
      "166:                                              pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "163:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "163:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "177:     vector <uint8_t> encPrivKey(BUF_LEN, 0);",
      "178:     vector<char> pubKeyX(BUF_LEN, 0);",
      "179:     vector<char> pubKeyY(BUF_LEN, 0);",
      "182:     PRINT_SRC_LINE",
      "183:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), &encLen, pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "180:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "181:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "291:     vector<char> errMsg(BUF_LEN, 0);",
      "293:     int errStatus = 0;",
      "296:     PRINT_SRC_LINE",
      "297:     auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 32);",
      "",
      "[Removed Lines]",
      "294:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "295:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "314:     vector<char> errMsg(BUF_LEN, 0);",
      "316:     int errStatus = 0;",
      "319:     unsigned t = 32, n = 32;",
      "320:     PRINT_SRC_LINE",
      "",
      "[Removed Lines]",
      "317:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "318:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "363:     vector<char> result(BUF_LEN, 0);",
      "365:     int errStatus = 0;",
      "368:     vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);",
      "369:     PRINT_SRC_LINE",
      "",
      "[Removed Lines]",
      "366:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "367:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "694: TEST_CASE_METHOD(TestFixture, \"AES encrypt/decrypt\", \"[aes-encrypt-decrypt]\") {",
      "695:     int errStatus = 0;",
      "696:     vector<char> errMsg(BUF_LEN, 0);",
      "698:     string key = SAMPLE_AES_KEY;",
      "699:     vector <uint8_t> encrypted_key(BUF_LEN, 0);",
      "",
      "[Removed Lines]",
      "697:     uint32_t encLen;",
      "",
      "[Added Lines]",
      "698:     uint64_t encLen;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b4546843f1e2e07234891ac1722315326a1f5636",
      "candidate_info": {
        "commit_hash": "b4546843f1e2e07234891ac1722315326a1f5636",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/b4546843f1e2e07234891ac1722315326a1f5636",
        "files": [
          "scripts/docker_test.py",
          "testw.cpp"
        ],
        "message": "SKALE-2003 Change docker test",
        "before_after_code_files": [
          "scripts/docker_test.py||scripts/docker_test.py",
          "testw.cpp||testw.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "testw.cpp||testw.cpp"
          ],
          "candidate": [
            "testw.cpp||testw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "scripts/docker_test.py||scripts/docker_test.py": [
          "File: scripts/docker_test.py -> scripts/docker_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: time.sleep(5);",
          "36: assert os.path.isdir(topDir + '/sgx_data/sgxwallet.db')",
          "37: assert os.path.isdir(topDir + '/sgx_data/cert_data');",
          "38: assert os.path.isdir(topDir + '/sgx_data/CSR_DB');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: obj = subprocess.Popen(stdin=PIPE)",
          "37: obj.communicate(input=\"i confirm\", timeout=1)",
          "38: obj.terminate()",
          "39: obj.wait()",
          "",
          "---------------"
        ],
        "testw.cpp||testw.cpp": [
          "File: testw.cpp -> testw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1347:   StubClient c(client, JSONRPC_CLIENT_V2);",
          "1348:   cerr << \"Client inited\" << endl;",
          "1349:   string hash = \"09c6137b97cdf159b9950f1492ee059d1e2b10eaf7d51f3a97d61f2eee2e81db\";",
          "1351:   int n = 4, t = 4;",
          "1353:   Json::Value pubBLSKey = c.getBLSPublicKeyShare(blsName);",
          "",
          "[Removed Lines]",
          "1350:   string blsName = \"BLS_KEY:SCHAIN_ID:1031067889:NODE_ID:0:DKG_ID:1112462780\";",
          "",
          "[Added Lines]",
          "1350:   string blsName = \"BLS_KEY:SCHAIN_ID:323669558:NODE_ID:1:DKG_ID:338183455\";",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0bf87ca879629b36052cdd72ee7b3bba13f2b923",
      "candidate_info": {
        "commit_hash": "0bf87ca879629b36052cdd72ee7b3bba13f2b923",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/0bf87ca879629b36052cdd72ee7b3bba13f2b923",
        "files": [
          "secure_enclave/secure_enclave.c",
          "secure_enclave/secure_enclave.i",
          "secure_enclave/signature.c",
          "secure_enclave/signature.h"
        ],
        "message": "SKALE-2201 Fixing ecdsa",
        "before_after_code_files": [
          "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
          "secure_enclave/secure_enclave.i||secure_enclave/secure_enclave.i",
          "secure_enclave/signature.c||secure_enclave/signature.c",
          "secure_enclave/signature.h||secure_enclave/signature.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ],
          "candidate": [
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ]
        }
      },
      "candidate_diff": {
        "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
          "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128: void generate_ecdsa_key(int *err_status, char *err_string,",
          "272: }",
          "277:     domain_parameters curve = domain_parameters_init();",
          "278:     domain_parameters_load_curve(curve, secp256k1);",
          "",
          "[Removed Lines]",
          "129:                         uint8_t *encrypted_key, uint32_t *enc_len, char * pub_key_x, char * pub_key_y) {",
          "131:   domain_parameters curve = domain_parameters_init();",
          "132:   domain_parameters_load_curve(curve, secp256k1);",
          "134:   unsigned char* rand_char= (unsigned char*)malloc(32);",
          "135:   sgx_read_rand( rand_char, 32);",
          "137:   mpz_t seed;",
          "138:   mpz_init(seed);",
          "139:   mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);",
          "141:   free(rand_char);",
          "143:   mpz_t skey;",
          "144:   mpz_init(skey);",
          "145:   mpz_mod(skey, seed, curve->p);",
          "146:   mpz_clear(seed);",
          "156:   point Pkey = point_init();",
          "158:   signature_generate_key(Pkey, skey, curve);",
          "160:   uint8_t base = 16;",
          "162:   int len = mpz_sizeinbase (Pkey->x, base) + 2;",
          "164:   char arr_x[len];",
          "165:   char* px = mpz_get_str(arr_x, base, Pkey->x);",
          "167:   int n_zeroes = 64 - strlen(arr_x);",
          "168:   for ( int i = 0; i < n_zeroes; i++){",
          "169:     pub_key_x[i] = '0';",
          "170:   }",
          "172:   strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "174:   char arr_y[mpz_sizeinbase (Pkey->y, base) + 2];",
          "175:   char* py = mpz_get_str(arr_y, base, Pkey->y);",
          "176:   n_zeroes = 64 - strlen(arr_y);",
          "177:   for ( int i = 0; i < n_zeroes; i++){",
          "178:     pub_key_y[i] = '0';",
          "179:   }",
          "180:   strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "181:   char skey_str[mpz_sizeinbase (skey, ECDSA_SKEY_BASE) + 2];",
          "182:   char* s  = mpz_get_str(skey_str, ECDSA_SKEY_BASE, skey);",
          "183:   snprintf(err_string, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "185:   uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "187:   sgx_status_t status = sgx_seal_data(0, NULL, ECDSA_SKEY_LEN, (uint8_t *)skey_str, sealedLen,(sgx_sealed_data_t*)encrypted_key);",
          "188:   if( status !=  SGX_SUCCESS) {",
          "189:     snprintf(err_string, BUF_LEN,\"seal ecsdsa private key failed\");",
          "191:     return;",
          "192:   }",
          "196:   mpz_clear(skey);",
          "197:   domain_parameters_clear(curve);",
          "198:   point_clear(Pkey);",
          "199: }",
          "202: void get_public_ecdsa_key(int *err_status, char *err_string,",
          "203:     uint8_t *encrypted_key, uint32_t dec_len, char * pub_key_x, char * pub_key_y) {",
          "207:   domain_parameters curve = domain_parameters_init();",
          "208:   domain_parameters_load_curve(curve, secp256k1);",
          "210:   char skey[ECDSA_SKEY_LEN];",
          "212:   sgx_status_t status = sgx_unseal_data(",
          "213:       (const sgx_sealed_data_t *)encrypted_key, NULL, 0, (uint8_t *)skey, &dec_len);",
          "215:   if (status != SGX_SUCCESS) {",
          "216:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data failed with status %d\", status);",
          "218:     return;",
          "219:   }",
          "223:   mpz_t skey_mpz;",
          "224:   mpz_init(skey_mpz);",
          "226:   if (mpz_set_str(skey_mpz, skey, ECDSA_SKEY_BASE) == -1){",
          "227:     snprintf(err_string, BUF_LEN,\"wrong string to init private key\");",
          "229:     mpz_clear(skey_mpz);",
          "230:     return;",
          "231:   }",
          "234:   point Pkey = point_init();",
          "236:   signature_generate_key(Pkey, skey_mpz, curve);",
          "238:   point Pkey_test = point_init();",
          "239:   point_multiplication(Pkey_test, skey_mpz, curve->G, curve);",
          "241:   if (!point_cmp(Pkey, Pkey_test)){",
          "242:     snprintf(err_string, BUF_LEN,\"Points are not equal\");",
          "244:     return;",
          "245:   }",
          "247:   int base = 16;",
          "249:   int len = mpz_sizeinbase (Pkey->x, base) + 2;",
          "251:   char arr_x[len];",
          "252:   char* px = mpz_get_str(arr_x, base, Pkey->x);",
          "254:   int n_zeroes = 64 - strlen(arr_x);",
          "255:   for ( int i = 0; i < n_zeroes; i++){",
          "256:     pub_key_x[i] = '0';",
          "257:   }",
          "259:   strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "261:   char arr_y[mpz_sizeinbase (Pkey->y, base) + 2];",
          "262:   char* py = mpz_get_str(arr_y, base, Pkey->y);",
          "263:   n_zeroes = 64 - strlen(arr_y);",
          "264:   for ( int i = 0; i < n_zeroes; i++){",
          "265:     pub_key_y[i] = '0';",
          "266:   }",
          "267:   strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "269:   mpz_clear(skey_mpz);",
          "270:   domain_parameters_clear(curve);",
          "271:   point_clear(Pkey);",
          "274: void ecdsa_sign1(int *err_status, char *err_string, uint8_t *encrypted_key, uint32_t dec_len,",
          "275:                  unsigned char* hash, char * sig_r, char * sig_s, uint8_t* sig_v, int base) {",
          "",
          "[Added Lines]",
          "129:                         uint8_t *encrypted_key, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
          "131:     domain_parameters curve = domain_parameters_init();",
          "132:     domain_parameters_load_curve(curve, secp256k1);",
          "134:     unsigned char *rand_char = (unsigned char *) malloc(32);",
          "135:     sgx_read_rand(rand_char, 32);",
          "137:     mpz_t seed;",
          "138:     mpz_init(seed);",
          "139:     mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);",
          "141:     free(rand_char);",
          "143:     mpz_t skey;",
          "144:     mpz_init(skey);",
          "145:     mpz_mod(skey, seed, curve->p);",
          "146:     mpz_clear(seed);",
          "156:     point Pkey = point_init();",
          "158:     signature_extract_public_key(Pkey, skey, curve);",
          "160:     uint8_t base = 16;",
          "162:     int len = mpz_sizeinbase(Pkey->x, base) + 2;",
          "164:     char arr_x[len];",
          "165:     char *px = mpz_get_str(arr_x, base, Pkey->x);",
          "167:     int n_zeroes = 64 - strlen(arr_x);",
          "168:     for (int i = 0; i < n_zeroes; i++) {",
          "169:         pub_key_x[i] = '0';",
          "170:     }",
          "172:     strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "174:     char arr_y[mpz_sizeinbase(Pkey->y, base) + 2];",
          "175:     char *py = mpz_get_str(arr_y, base, Pkey->y);",
          "176:     n_zeroes = 64 - strlen(arr_y);",
          "177:     for (int i = 0; i < n_zeroes; i++) {",
          "178:         pub_key_y[i] = '0';",
          "179:     }",
          "180:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "181:     char skey_str[mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2];",
          "182:     char *s = mpz_get_str(skey_str, ECDSA_SKEY_BASE, skey);",
          "183:     snprintf(err_string, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "185:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "187:     sgx_status_t status = sgx_seal_data(0, NULL, ECDSA_SKEY_LEN, (uint8_t *) skey_str, sealedLen,",
          "188:                                         (sgx_sealed_data_t *) encrypted_key);",
          "189:     if (status != SGX_SUCCESS) {",
          "190:         snprintf(err_string, BUF_LEN, \"seal ecsdsa private key failed\");",
          "192:         return;",
          "193:     }",
          "197:     mpz_clear(skey);",
          "198:     domain_parameters_clear(curve);",
          "199:     point_clear(Pkey);",
          "203: void get_public_ecdsa_key(int *err_status, char *err_string,",
          "204:                           uint8_t *encrypted_key, uint32_t dec_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "280:     char skey[ECDSA_SKEY_LEN];",
          "282:     sgx_status_t status = sgx_unseal_data(",
          "285:     if (status != SGX_SUCCESS) {",
          "288:         return;",
          "289:     }",
          "292:     mpz_t skey_mpz;",
          "293:     mpz_init(skey_mpz);",
          "297:         mpz_clear(skey_mpz);",
          "298:         return;",
          "299:     }",
          "315:         return;",
          "316:     }",
          "319:     signature sign = signature_init();",
          "331:     }",
          "343:     strncpy(sig_r, arr_r, 1024);",
          "347:     strncpy(sig_s, arr_s, 1024);",
          "351:     mpz_clear(skey_mpz);",
          "352:     mpz_clear(msg_mpz);",
          "353:     domain_parameters_clear(curve);",
          "357: }",
          "",
          "[Removed Lines]",
          "283:             (const sgx_sealed_data_t *)encrypted_key, NULL, 0, skey, &dec_len);",
          "287:         snprintf(err_string, BUF_LEN,\"sgx_unseal_data failed - encrypted_key with status %d\", status);",
          "291:     snprintf(err_string, BUF_LEN,\"pr key is %s length %d \", skey, strlen(skey));",
          "294:     if (mpz_set_str(skey_mpz, skey, ECDSA_SKEY_BASE) == -1){",
          "296:         snprintf(err_string, BUF_LEN ,\"invalid secret key\");",
          "302:     mpz_init(test_skey);",
          "303:     mpz_set_str(test_skey, \"4160780231445160889237664391382223604184857153814275770598791864649971919844\", 10);",
          "305:     if(!mpz_cmp(skey,test_skey)){",
          "306:       snprintf(err_string, BUF_LEN,\"keys are not equal \");",
          "309:     mpz_t msg_mpz;",
          "310:     mpz_init(msg_mpz);",
          "311:     if (mpz_set_str(msg_mpz, hash, 16) == -1){",
          "313:         snprintf(err_string, BUF_LEN ,\"invalid message hash\");",
          "314:         mpz_clear(msg_mpz);",
          "321:     signature_sign( sign, msg_mpz, skey_mpz, curve);",
          "323:     point Pkey = point_init();",
          "325:     signature_generate_key(Pkey, skey_mpz, curve);",
          "327:     if ( !signature_verify(msg_mpz, sign, Pkey, curve) ){",
          "329:          snprintf(err_string, BUF_LEN,\"signature is not verified! \");",
          "330:         return;",
          "337:     char arr_m[mpz_sizeinbase (msg_mpz, 16) + 2];",
          "338:     char* msg = mpz_get_str(arr_m, 16, msg_mpz);",
          "339:     snprintf(err_string, BUF_LEN,\"message is %s \", arr_m);",
          "341:     char arr_r[mpz_sizeinbase (sign->r, base) + 2];",
          "342:     char* r = mpz_get_str(arr_r, base, sign->r);",
          "345:     char arr_s[mpz_sizeinbase (sign->s, base) + 2];",
          "346:     char* s = mpz_get_str(arr_s, base, sign->s);",
          "354:     signature_clear(sign);",
          "355:     point_clear(Pkey);",
          "",
          "[Added Lines]",
          "214:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey, &dec_len);",
          "217:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "227:     if (mpz_set_str(skey_mpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "228:         snprintf(err_string, BUF_LEN, \"wrong string to init private key\");",
          "235:     point Pkey = point_init();",
          "237:     signature_extract_public_key(Pkey, skey_mpz, curve);",
          "239:     point Pkey_test = point_init();",
          "240:     point_multiplication(Pkey_test, skey_mpz, curve->G, curve);",
          "242:     if (!point_cmp(Pkey, Pkey_test)) {",
          "243:         snprintf(err_string, BUF_LEN, \"Points are not equal\");",
          "248:     int base = 16;",
          "250:     int len = mpz_sizeinbase(Pkey->x, base) + 2;",
          "252:     char arr_x[len];",
          "253:     char *px = mpz_get_str(arr_x, base, Pkey->x);",
          "255:     int n_zeroes = 64 - strlen(arr_x);",
          "256:     for (int i = 0; i < n_zeroes; i++) {",
          "257:         pub_key_x[i] = '0';",
          "258:     }",
          "260:     strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "262:     char arr_y[mpz_sizeinbase(Pkey->y, base) + 2];",
          "263:     char *py = mpz_get_str(arr_y, base, Pkey->y);",
          "264:     n_zeroes = 64 - strlen(arr_y);",
          "265:     for (int i = 0; i < n_zeroes; i++) {",
          "266:         pub_key_y[i] = '0';",
          "267:     }",
          "268:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "270:     mpz_clear(skey_mpz);",
          "271:     domain_parameters_clear(curve);",
          "272:     point_clear(Pkey);",
          "273: }",
          "275: void ecdsa_sign1(int *err_status, char *err_string, uint8_t *encrypted_key, uint32_t dec_len,",
          "276:                  unsigned char *hash, char *sig_r, char *sig_s, uint8_t *sig_v, int base) {",
          "278:     char* arr_m = NULL;",
          "279:     char* arr_r = NULL;",
          "280:     char* arr_s;",
          "282:     mpz_t skey_mpz;",
          "283:     mpz_init(skey_mpz);",
          "284:     mpz_t msg_mpz;",
          "285:     mpz_init(msg_mpz);",
          "289:     domain_parameters curve = domain_parameters_init();",
          "290:     domain_parameters_load_curve(curve, secp256k1);",
          "292:     point publicKey = point_init();",
          "294:     char* secretKey = calloc(ECDSA_SKEY_LEN,1);",
          "296:     sgx_status_t status = sgx_unseal_data(",
          "297:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, secretKey, &dec_len);",
          "299:     if (status != SGX_SUCCESS) {",
          "301:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed - encrypted_key with status %d\", status);",
          "302:         goto clean;",
          "303:     }",
          "307:     if (mpz_set_str(skey_mpz, secretKey, ECDSA_SKEY_BASE) == -1) {",
          "309:         snprintf(err_string, BUF_LEN, \"invalid secret key\");",
          "310:         goto clean;",
          "311:     }",
          "313:     if (mpz_set_str(msg_mpz, hash, 16) == -1) {",
          "315:         snprintf(err_string, BUF_LEN, \"invalid message hash\");",
          "316:         goto clean;",
          "317:     }",
          "320:     signature_sign(sign, msg_mpz, skey_mpz, curve);",
          "322:     signature_extract_public_key(publicKey, skey_mpz, curve);",
          "324:     if (!signature_verify(msg_mpz, sign, publicKey, curve)) {",
          "326:         snprintf(err_string, BUF_LEN, \"signature is not verified\");",
          "327:         goto clean;",
          "334:     arr_m = calloc(mpz_sizeinbase(msg_mpz, 16) + 2 ,1);",
          "335:     mpz_get_str(arr_m, 16, msg_mpz);",
          "339:     arr_r = calloc(mpz_sizeinbase(sign->r, base) + 2,1);",
          "340:     mpz_get_str(arr_r, base, sign->r);",
          "343:     arr_s = calloc(mpz_sizeinbase(sign->s, base) + 2, 1);",
          "344:     mpz_get_str(arr_s, base, sign->s);",
          "348:     clean:",
          "353:     point_clear(publicKey);",
          "354:     free(secretKey);",
          "355:     signature_free(sign);",
          "357:     if (arr_m != NULL) {",
          "358:         free(arr_m);",
          "359:     }",
          "360:     if (arr_r != NULL) {",
          "361:         free(arr_r);",
          "362:     }",
          "364:     if (arr_s != NULL) {",
          "365:         free(arr_s);",
          "366:     }",
          "368:     return;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "387:     memset(encrypted_key, 0, BUF_LEN);",
          "392:         snprintf(err_string, BUF_LEN, \"SGX seal data failed with status %d\", status);",
          "393:         return;",
          "",
          "[Removed Lines]",
          "389:     sgx_status_t status = sgx_seal_data(0, NULL, MAX_KEY_LENGTH, (uint8_t *) key, sealedLen, (sgx_sealed_data_t *) encrypted_key);",
          "390:     if ( status != SGX_SUCCESS) {",
          "",
          "[Added Lines]",
          "401:     sgx_status_t status = sgx_seal_data(0, NULL, MAX_KEY_LENGTH, (uint8_t *) key, sealedLen,",
          "402:                                         (sgx_sealed_data_t *) encrypted_key);",
          "403:     if (status != SGX_SUCCESS) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "481:                       char *_hashY, char *signature) {",
          "485:     char key[BUF_LEN];",
          "489:     init();",
          "",
          "[Removed Lines]",
          "486:     char* sig = (char*) calloc(BUF_LEN, 1);",
          "",
          "[Added Lines]",
          "498:     char *sig = (char *) calloc(BUF_LEN, 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "505:         return;",
          "506:     }",
          "509: }",
          "534: }",
          "550: }",
          "574: }",
          "595: }",
          "610: }",
          "686: }",
          "",
          "[Removed Lines]",
          "508:    free(sig);",
          "511: void gen_dkg_secret (int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t* enc_len, size_t _t){",
          "513:   char dkg_secret[DKG_BUFER_LENGTH]; //= (char*)malloc(DKG_BUFER_LENGTH);",
          "515:   if (gen_dkg_poly(dkg_secret, _t) != 0 ){",
          "517:      return;",
          "518:   }",
          "520:   snprintf(err_string, BUF_LEN,\"poly is %s \", dkg_secret);",
          "522:   uint32_t sealedLen = sgx_calc_sealed_data_size(0, DKG_BUFER_LENGTH);//sizeof(sgx_sealed_data_t) +  sizeof(dkg_secret);",
          "524:   sgx_status_t status = sgx_seal_data(0, NULL, DKG_BUFER_LENGTH, (uint8_t*)dkg_secret, sealedLen,(sgx_sealed_data_t*)encrypted_dkg_secret);",
          "526:   if(status !=  SGX_SUCCESS) {",
          "527:     snprintf(err_string, BUF_LEN,\"SGX seal data failed\");",
          "529:     return;",
          "530:   }",
          "536: void decrypt_dkg_secret (int *err_status, char* err_string, uint8_t* encrypted_dkg_secret, uint8_t* decrypted_dkg_secret, uint32_t* dec_len){",
          "539:   uint32_t decr_len;",
          "540:   sgx_status_t status = sgx_unseal_data(",
          "541:       (const sgx_sealed_data_t *)encrypted_dkg_secret, NULL, 0, decrypted_dkg_secret, &decr_len);",
          "543:   if (status != SGX_SUCCESS) {",
          "544:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", status);",
          "546:     return;",
          "547:   }",
          "552: void get_secret_shares(int *err_status, char* err_string, uint8_t* encrypted_dkg_secret, uint32_t* dec_len, char* secret_shares,",
          "553:     unsigned _t, unsigned _n){",
          "555:   char decrypted_dkg_secret[DKG_BUFER_LENGTH]; //= (char*)malloc(DKG_BUFER_LENGTH);",
          "558:   uint32_t decr_len ;",
          "560:   decrypt_dkg_secret(err_status, err_string, encrypted_dkg_secret, (uint8_t*)decrypted_dkg_secret, &decr_len);",
          "564:   if (*err_status != 0) {",
          "565:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *err_status);",
          "566:     return;",
          "567:   }",
          "572:  calc_secret_shares(decrypted_dkg_secret, secret_shares, _t, _n);",
          "576: void get_public_shares(int *err_status, char* err_string, uint8_t* encrypted_dkg_secret, uint32_t enc_len, char* public_shares,",
          "577:                        unsigned _t, unsigned _n){",
          "580:   char* decrypted_dkg_secret = (char*)malloc(DKG_MAX_SEALED_LEN);",
          "581:   uint32_t decr_len ;",
          "582:   decrypt_dkg_secret(err_status, err_string, (uint8_t*)encrypted_dkg_secret, decrypted_dkg_secret, &decr_len);",
          "583:   if(  *err_status != 0 ){",
          "584:     snprintf(err_string, BUF_LEN,\"decrypt_dkg_secret failed with status %d\", *err_status);",
          "585:     return;",
          "586:   }",
          "589:   if ( calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0 ){",
          "591:     snprintf(err_string, BUF_LEN,\"t does not match polynomial in db\");",
          "592:     return;",
          "593:   }",
          "594:   free(decrypted_dkg_secret);",
          "598: void set_encrypted_dkg_poly(int *err_status, char *err_string, uint8_t* encrypted_poly){",
          "599:   memset(Decrypted_dkg_poly, 0, DKG_BUFER_LENGTH);",
          "600:   uint32_t decr_len;",
          "601:   sgx_status_t status = sgx_unseal_data(",
          "602:       (const sgx_sealed_data_t *)encrypted_poly, NULL, 0, Decrypted_dkg_poly, &decr_len);",
          "604:   if (status != SGX_SUCCESS) {",
          "606:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "607:     return;",
          "608:   }",
          "612: void get_encr_sshare(int *err_status, char *err_string, uint8_t *encrypted_skey, uint32_t* dec_len,",
          "613:     char* result_str, char * s_shareG2, char* pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind ){",
          "615:   char skey[ECDSA_SKEY_LEN];",
          "616:   char pub_key_x[BUF_LEN];",
          "617:   memset(pub_key_x, 0, BUF_LEN);",
          "618:   char pub_key_y[BUF_LEN];",
          "619:   memset(pub_key_y, 0, BUF_LEN);",
          "623:   uint32_t enc_len;",
          "625:   generate_ecdsa_key(err_status, err_string, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "626:   if ( *err_status != 0){",
          "627:     return;",
          "628:   }",
          "633:   sgx_status_t status = sgx_unseal_data(",
          "634:       (const sgx_sealed_data_t *)encrypted_skey, NULL, 0, (uint8_t *)skey, &enc_len);",
          "636:   if (status != SGX_SUCCESS) {",
          "637:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data failed - encrypted_skey with status %d\", status);",
          "639:     return;",
          "640:   }",
          "641:   snprintf(err_string, BUF_LEN,\"unsealed random skey is %s\\n\", skey);",
          "643:   char * common_key[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "644:   gen_session_key(skey, pub_keyB, common_key);",
          "648:   char* s_share[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "651:   if (calc_secret_share(Decrypted_dkg_poly, s_share, _t, _n, ind) != 0){",
          "653:     snprintf(err_string, BUF_LEN,\"\\nt does not match poly degree\\n\");",
          "654:     return;",
          "655:   }",
          "656:   snprintf(err_string + 88, BUF_LEN,\"\\nsecret share is %s\", s_share);",
          "658:   if (calc_secret_shareG2(s_share, s_shareG2) != 0){",
          "660:     snprintf(err_string, BUF_LEN,\"invalid decr secret share\\n\");",
          "661:     return;",
          "662:   }",
          "664:   char* cypher[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "665:   xor_encrypt(common_key, s_share, cypher);",
          "666:   if (cypher == NULL){",
          "668:       snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "669:       return;",
          "670:   }",
          "673:   strncpy(result_str, cypher, strlen(cypher));",
          "674:   strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));",
          "675:   strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));",
          "688: void complaint_response(int *err_status, char *err_string, uint8_t *encrypted_DHkey, uint8_t *encrypted_dkg_secret, uint32_t* dec_len,",
          "689:                     char* DH_key, char* s_shareG2, uint8_t _t, uint8_t _n, uint8_t ind1){",
          "691:   uint32_t enc_len;",
          "",
          "[Added Lines]",
          "520:     free(sig);",
          "523: void gen_dkg_secret(int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
          "525:     char dkg_secret[DKG_BUFER_LENGTH]; //= (char*)malloc(DKG_BUFER_LENGTH);",
          "527:     if (gen_dkg_poly(dkg_secret, _t) != 0) {",
          "529:         return;",
          "530:     }",
          "532:     snprintf(err_string, BUF_LEN, \"poly is %s \", dkg_secret);",
          "534:     uint32_t sealedLen = sgx_calc_sealed_data_size(0,",
          "535:                                                    DKG_BUFER_LENGTH);//sizeof(sgx_sealed_data_t) +  sizeof(dkg_secret);",
          "537:     sgx_status_t status = sgx_seal_data(0, NULL, DKG_BUFER_LENGTH, (uint8_t *) dkg_secret, sealedLen,",
          "538:                                         (sgx_sealed_data_t *) encrypted_dkg_secret);",
          "540:     if (status != SGX_SUCCESS) {",
          "541:         snprintf(err_string, BUF_LEN, \"SGX seal data failed\");",
          "543:         return;",
          "544:     }",
          "550: void decrypt_dkg_secret(int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint8_t *decrypted_dkg_secret,",
          "551:                         uint32_t *dec_len) {",
          "554:     uint32_t decr_len;",
          "555:     sgx_status_t status = sgx_unseal_data(",
          "556:             (const sgx_sealed_data_t *) encrypted_dkg_secret, NULL, 0, decrypted_dkg_secret, &decr_len);",
          "558:     if (status != SGX_SUCCESS) {",
          "559:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", status);",
          "561:         return;",
          "562:     }",
          "567: void get_secret_shares(int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t *dec_len,",
          "568:                        char *secret_shares,",
          "569:                        unsigned _t, unsigned _n) {",
          "571:     char decrypted_dkg_secret[DKG_BUFER_LENGTH]; //= (char*)malloc(DKG_BUFER_LENGTH);",
          "574:     uint32_t decr_len;",
          "576:     decrypt_dkg_secret(err_status, err_string, encrypted_dkg_secret, (uint8_t *) decrypted_dkg_secret, &decr_len);",
          "580:     if (*err_status != 0) {",
          "581:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *err_status);",
          "582:         return;",
          "583:     }",
          "588:     calc_secret_shares(decrypted_dkg_secret, secret_shares, _t, _n);",
          "592: void get_public_shares(int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
          "593:                        char *public_shares,",
          "594:                        unsigned _t, unsigned _n) {",
          "597:     char *decrypted_dkg_secret = (char *) malloc(DKG_MAX_SEALED_LEN);",
          "598:     uint32_t decr_len;",
          "599:     decrypt_dkg_secret(err_status, err_string, (uint8_t *) encrypted_dkg_secret, decrypted_dkg_secret, &decr_len);",
          "600:     if (*err_status != 0) {",
          "601:         snprintf(err_string, BUF_LEN, \"decrypt_dkg_secret failed with status %d\", *err_status);",
          "602:         return;",
          "603:     }",
          "606:     if (calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0) {",
          "608:         snprintf(err_string, BUF_LEN, \"t does not match polynomial in db\");",
          "609:         return;",
          "610:     }",
          "611:     free(decrypted_dkg_secret);",
          "615: void set_encrypted_dkg_poly(int *err_status, char *err_string, uint8_t *encrypted_poly) {",
          "616:     memset(Decrypted_dkg_poly, 0, DKG_BUFER_LENGTH);",
          "617:     uint32_t decr_len;",
          "618:     sgx_status_t status = sgx_unseal_data(",
          "619:             (const sgx_sealed_data_t *) encrypted_poly, NULL, 0, Decrypted_dkg_poly, &decr_len);",
          "621:     if (status != SGX_SUCCESS) {",
          "623:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "624:         return;",
          "625:     }",
          "629: void get_encr_sshare(int *err_status, char *err_string, uint8_t *encrypted_skey, uint32_t *dec_len,",
          "630:                      char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) {",
          "632:     char skey[ECDSA_SKEY_LEN];",
          "633:     char pub_key_x[BUF_LEN];",
          "634:     memset(pub_key_x, 0, BUF_LEN);",
          "635:     char pub_key_y[BUF_LEN];",
          "636:     memset(pub_key_y, 0, BUF_LEN);",
          "640:     uint32_t enc_len;",
          "642:     generate_ecdsa_key(err_status, err_string, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "643:     if (*err_status != 0) {",
          "644:         return;",
          "645:     }",
          "650:     sgx_status_t status = sgx_unseal_data(",
          "651:             (const sgx_sealed_data_t *) encrypted_skey, NULL, 0, (uint8_t *) skey, &enc_len);",
          "653:     if (status != SGX_SUCCESS) {",
          "654:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed - encrypted_skey with status %d\", status);",
          "656:         return;",
          "657:     }",
          "658:     snprintf(err_string, BUF_LEN, \"unsealed random skey is %s\\n\", skey);",
          "660:     char *common_key[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "661:     gen_session_key(skey, pub_keyB, common_key);",
          "665:     char *s_share[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "668:     if (calc_secret_share(Decrypted_dkg_poly, s_share, _t, _n, ind) != 0) {",
          "670:         snprintf(err_string, BUF_LEN, \"\\nt does not match poly degree\\n\");",
          "671:         return;",
          "672:     }",
          "673:     snprintf(err_string + 88, BUF_LEN, \"\\nsecret share is %s\", s_share);",
          "675:     if (calc_secret_shareG2(s_share, s_shareG2) != 0) {",
          "677:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\\n\");",
          "678:         return;",
          "679:     }",
          "681:     char *cypher[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "682:     xor_encrypt(common_key, s_share, cypher);",
          "683:     if (cypher == NULL) {",
          "685:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "686:         return;",
          "687:     }",
          "690:     strncpy(result_str, cypher, strlen(cypher));",
          "691:     strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));",
          "692:     strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));",
          "705: void complaint_response(int *err_status, char *err_string, uint8_t *encrypted_DHkey, uint8_t *encrypted_dkg_secret,",
          "706:                         uint32_t *dec_len,",
          "707:                         char *DH_key, char *s_shareG2, uint8_t _t, uint8_t _n, uint8_t ind1) {",
          "709:     uint32_t enc_len;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "715: }",
          "773: }",
          "840:         mpz_clear(decr_secret_share);",
          "842:     }",
          "",
          "[Removed Lines]",
          "700:   char decrypted_dkg_secret[DKG_BUFER_LENGTH]; //= (char*)malloc(DKG_BUFER_LENGTH);",
          "701:   uint32_t decr_len;",
          "702:   decrypt_dkg_secret(err_status, err_string, encrypted_dkg_secret, (uint8_t*)decrypted_dkg_secret, &decr_len);",
          "703:   if (*err_status != 0) {",
          "704:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *err_status);",
          "705:     return;",
          "706:   }",
          "708:   calc_secret_shareG2_old(decrypted_dkg_secret, s_shareG2, _t, ind1);",
          "717: void dkg_verification(int *err_status, char* err_string, const char * public_shares, const char* s_share,",
          "718:                       uint8_t* encrypted_key, uint64_t key_len, unsigned _t, int _ind, int * result){",
          "721:   char skey[ECDSA_SKEY_LEN];",
          "722:   sgx_status_t status = sgx_unseal_data(",
          "723:       (const sgx_sealed_data_t *)encrypted_key, NULL, 0, (uint8_t*)skey, &key_len);",
          "724:   if (status != SGX_SUCCESS) {",
          "726:     snprintf(err_string, BUF_LEN,\"sgx_unseal_key failed with status %d\", status);",
          "727:     return;",
          "728:   }",
          "730:   char encr_sshare[ECDSA_SKEY_LEN];",
          "731:   strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);",
          "732:   encr_sshare[64] = 0;",
          "734:   char common_key[ECDSA_SKEY_LEN];",
          "735:   char decr_sshare[ECDSA_SKEY_LEN];",
          "736:   session_key_recover(skey, s_share, common_key);",
          "737:   common_key[ECDSA_SKEY_LEN - 1] = 0;",
          "738:   if (common_key == NULL){",
          "740:     snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "741:     return;",
          "742:   }",
          "744:   xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "745:   if (decr_sshare == NULL){",
          "747:       snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "748:       return;",
          "749:   }",
          "760:   mpz_t s;",
          "761:   mpz_init(s);",
          "762:   if (mpz_set_str(s, decr_sshare, 16) == -1){",
          "764:       snprintf(err_string, BUF_LEN ,\"invalid decr secret share\");",
          "765:       mpz_clear(s);",
          "766:       return;",
          "767:   }",
          "771:   snprintf(err_string, BUF_LEN,\"common_key in verification is %s\", common_key);",
          "775: void create_bls_key(int *err_status, char* err_string, const char* s_shares,",
          "776:                       uint8_t* encrypted_key, uint64_t key_len, uint8_t * encr_bls_key, uint32_t *enc_bls_key_len){",
          "778:   char skey[ECDSA_SKEY_LEN];",
          "779:   sgx_status_t status = sgx_unseal_data(",
          "780:       (const sgx_sealed_data_t *)encrypted_key, NULL, 0, (uint8_t*)skey, &key_len);",
          "781:   if (status != SGX_SUCCESS) {",
          "783:     snprintf(err_string, BUF_LEN,\"sgx_unseal_key failed with status %d\", status);",
          "784:     return;",
          "785:   }",
          "787:   int num_shares = strlen(s_shares)/192;",
          "789:   mpz_t sum;",
          "790:   mpz_init(sum);",
          "791:   mpz_set_ui(sum, 0);",
          "797:   for ( int i = 0; i < num_shares; i++) {",
          "798:     char encr_sshare[65];",
          "799:     strncpy(encr_sshare, s_shares + 192 * i, 64);",
          "800:     encr_sshare[64] = 0;",
          "802:     char s_share[193];",
          "803:     strncpy(s_share, s_shares + 192 * i, 192);",
          "804:     s_share[192] = 0;",
          "806:     char common_key[65];",
          "807:     session_key_recover(skey, s_share, common_key);",
          "808:     common_key[64] = 0;",
          "810:     if (common_key == NULL){",
          "812:       snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "813:       mpz_clear(sum);",
          "814:       return;",
          "815:     }",
          "821:     char decr_sshare[65];",
          "822:     xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "823:     if (decr_sshare == NULL){",
          "825:         snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "826:         mpz_clear(sum);",
          "827:         return;",
          "828:     }",
          "835:     mpz_t decr_secret_share;",
          "836:     mpz_init(decr_secret_share);",
          "837:     if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1){",
          "839:         snprintf(err_string, BUF_LEN ,\"invalid decrypted secret share\");",
          "841:         return;",
          "844:     mpz_addmul_ui(sum, decr_secret_share, 1);",
          "845:     mpz_clear(decr_secret_share);",
          "846:   }",
          "848:    mpz_t q;",
          "849:    mpz_init(q);",
          "850:    mpz_set_str(q, \"21888242871839275222246405745257275088548364400416034343698204186575808495617\", 10);",
          "852:    mpz_t bls_key;",
          "853:    mpz_init(bls_key);",
          "855:    mpz_mod(bls_key, sum, q);",
          "857:    char key_share[mpz_sizeinbase(bls_key, 16) + 2];",
          "858:    char *key = mpz_get_str(key_share, 16, bls_key);",
          "859:    snprintf(err_string, BUF_LEN,\" bls private key is %s\", key_share);",
          "860:    uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "863:    status = sgx_seal_data(0, NULL, ECDSA_SKEY_LEN, (uint8_t *)key_share, sealedLen,(sgx_sealed_data_t*)encr_bls_key);",
          "864:    if( status !=  SGX_SUCCESS) {",
          "866:     snprintf(err_string, BUF_LEN,\"seal bls private key failed with status %d \", status);",
          "867:     mpz_clear(bls_key);",
          "868:     mpz_clear(sum);",
          "869:     mpz_clear(q);",
          "870:     return;",
          "871:    }",
          "",
          "[Added Lines]",
          "718:     char decrypted_dkg_secret[DKG_BUFER_LENGTH]; //= (char*)malloc(DKG_BUFER_LENGTH);",
          "719:     uint32_t decr_len;",
          "720:     decrypt_dkg_secret(err_status, err_string, encrypted_dkg_secret, (uint8_t *) decrypted_dkg_secret, &decr_len);",
          "721:     if (*err_status != 0) {",
          "722:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *err_status);",
          "723:         return;",
          "724:     }",
          "726:     calc_secret_shareG2_old(decrypted_dkg_secret, s_shareG2, _t, ind1);",
          "735: void dkg_verification(int *err_status, char *err_string, const char *public_shares, const char *s_share,",
          "736:                       uint8_t *encrypted_key, uint64_t key_len, unsigned _t, int _ind, int *result) {",
          "739:     char skey[ECDSA_SKEY_LEN];",
          "740:     sgx_status_t status = sgx_unseal_data(",
          "741:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey, &key_len);",
          "742:     if (status != SGX_SUCCESS) {",
          "744:         snprintf(err_string, BUF_LEN, \"sgx_unseal_key failed with status %d\", status);",
          "745:         return;",
          "746:     }",
          "748:     char encr_sshare[ECDSA_SKEY_LEN];",
          "749:     strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);",
          "750:     encr_sshare[64] = 0;",
          "752:     char common_key[ECDSA_SKEY_LEN];",
          "753:     char decr_sshare[ECDSA_SKEY_LEN];",
          "754:     session_key_recover(skey, s_share, common_key);",
          "755:     common_key[ECDSA_SKEY_LEN - 1] = 0;",
          "756:     if (common_key == NULL) {",
          "758:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "759:         return;",
          "760:     }",
          "762:     xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "763:     if (decr_sshare == NULL) {",
          "765:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "766:         return;",
          "767:     }",
          "778:     mpz_t s;",
          "779:     mpz_init(s);",
          "780:     if (mpz_set_str(s, decr_sshare, 16) == -1) {",
          "782:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\");",
          "783:         mpz_clear(s);",
          "784:         return;",
          "785:     }",
          "789:     snprintf(err_string, BUF_LEN, \"common_key in verification is %s\", common_key);",
          "793: void create_bls_key(int *err_status, char *err_string, const char *s_shares,",
          "794:                     uint8_t *encrypted_key, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {",
          "796:     char skey[ECDSA_SKEY_LEN];",
          "797:     sgx_status_t status = sgx_unseal_data(",
          "798:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey, &key_len);",
          "799:     if (status != SGX_SUCCESS) {",
          "801:         snprintf(err_string, BUF_LEN, \"sgx_unseal_key failed with status %d\", status);",
          "802:         return;",
          "803:     }",
          "805:     int num_shares = strlen(s_shares) / 192;",
          "807:     mpz_t sum;",
          "808:     mpz_init(sum);",
          "809:     mpz_set_ui(sum, 0);",
          "815:     for (int i = 0; i < num_shares; i++) {",
          "816:         char encr_sshare[65];",
          "817:         strncpy(encr_sshare, s_shares + 192 * i, 64);",
          "818:         encr_sshare[64] = 0;",
          "820:         char s_share[193];",
          "821:         strncpy(s_share, s_shares + 192 * i, 192);",
          "822:         s_share[192] = 0;",
          "824:         char common_key[65];",
          "825:         session_key_recover(skey, s_share, common_key);",
          "826:         common_key[64] = 0;",
          "828:         if (common_key == NULL) {",
          "830:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "831:             mpz_clear(sum);",
          "832:             return;",
          "833:         }",
          "839:         char decr_sshare[65];",
          "840:         xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "841:         if (decr_sshare == NULL) {",
          "843:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "844:             mpz_clear(sum);",
          "845:             return;",
          "846:         }",
          "853:         mpz_t decr_secret_share;",
          "854:         mpz_init(decr_secret_share);",
          "855:         if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {",
          "857:             snprintf(err_string, BUF_LEN, \"invalid decrypted secret share\");",
          "858:             mpz_clear(decr_secret_share);",
          "859:             return;",
          "860:         }",
          "862:         mpz_addmul_ui(sum, decr_secret_share, 1);",
          "866:     mpz_t q;",
          "867:     mpz_init(q);",
          "868:     mpz_set_str(q, \"21888242871839275222246405745257275088548364400416034343698204186575808495617\", 10);",
          "870:     mpz_t bls_key;",
          "871:     mpz_init(bls_key);",
          "873:     mpz_mod(bls_key, sum, q);",
          "875:     char key_share[mpz_sizeinbase(bls_key, 16) + 2];",
          "876:     char *key = mpz_get_str(key_share, 16, bls_key);",
          "877:     snprintf(err_string, BUF_LEN, \" bls private key is %s\", key_share);",
          "878:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "881:     status = sgx_seal_data(0, NULL, ECDSA_SKEY_LEN, (uint8_t *) key_share, sealedLen,",
          "882:                            (sgx_sealed_data_t *) encr_bls_key);",
          "883:     if (status != SGX_SUCCESS) {",
          "885:         snprintf(err_string, BUF_LEN, \"seal bls private key failed with status %d \", status);",
          "886:         mpz_clear(bls_key);",
          "887:         mpz_clear(sum);",
          "888:         mpz_clear(q);",
          "889:         return;",
          "890:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "886: }",
          "907: }",
          "909: void generate_SEK(int *err_status, char *err_string,",
          "936: }",
          "956: }",
          "958: void set_SEK_backup(int *err_status, char *err_string,",
          "976: }",
          "978: void generate_ecdsa_key_aes(int *err_status, char *err_string,",
          "1048: }",
          "1050: void get_public_ecdsa_key_aes(int *err_status, char *err_string,",
          "1119: }",
          "1121: void ecdsa_sign_aes(int *err_status, char *err_string, uint8_t *encrypted_key, uint32_t enc_len,",
          "1197: }",
          "1199: void encrypt_key_aes(int *err_status, char *err_string, const char *key,",
          "",
          "[Removed Lines]",
          "883:   mpz_clear(bls_key);",
          "884:   mpz_clear(sum);",
          "885:   mpz_clear(q);",
          "888: void get_bls_pub_key(int *err_status, char* err_string, uint8_t* encrypted_key, uint64_t key_len, char* bls_pub_key){",
          "890:   char skey_hex[ECDSA_SKEY_LEN];",
          "892:   uint32_t len = key_len;",
          "894:   sgx_status_t status = sgx_unseal_data(",
          "895:       (const sgx_sealed_data_t *)encrypted_key, NULL, 0, (uint8_t *)skey_hex, &len);",
          "896:   if (status != SGX_SUCCESS) {",
          "898:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data failed with status %d\", status);",
          "899:     return;",
          "900:   }",
          "902:   if (calc_bls_public_key(skey_hex, bls_pub_key) != 0){",
          "904:     snprintf(err_string, BUF_LEN,\"could not calculate bls public key\");",
          "905:     return;",
          "906:   }",
          "910:                         uint8_t *encrypted_SEK, uint32_t *enc_len, char* SEK_hex){",
          "911:   uint8_t SEK_raw[SGX_AESGCM_KEY_SIZE];",
          "913:   sgx_read_rand(SEK_raw, SGX_AESGCM_KEY_SIZE);",
          "915:   uint32_t hex_aes_key_length = SGX_AESGCM_KEY_SIZE * 2;",
          "916:   uint8_t SEK[hex_aes_key_length];",
          "917:   carray2Hex(SEK_raw, SGX_AESGCM_KEY_SIZE, SEK_hex);",
          "919:   uint32_t sealedLen = sgx_calc_sealed_data_size(0, hex_aes_key_length + 1);",
          "921:   for ( uint8_t i = 0; i < 16; i++){",
          "922:     AES_key[i] = SEK_raw[i];",
          "923:   }",
          "925:   sgx_status_t status = sgx_seal_data(0, NULL, hex_aes_key_length + 1, SEK_hex, sealedLen,(sgx_sealed_data_t*)encrypted_SEK);",
          "926:   if( status !=  SGX_SUCCESS) {",
          "927:     snprintf(err_string, BUF_LEN, \"seal SEK failed\");",
          "929:     return;",
          "930:   }",
          "938: void set_SEK(int *err_status, char *err_string, uint8_t *encrypted_SEK, uint64_t encr_len){",
          "942:   uint8_t aes_key_hex[SGX_AESGCM_KEY_SIZE * 2];",
          "943:   memset(aes_key_hex, 0, SGX_AESGCM_KEY_SIZE * 2);",
          "945:   sgx_status_t status = sgx_unseal_data(",
          "946:       (const sgx_sealed_data_t *)encrypted_SEK, NULL, 0, aes_key_hex, &encr_len);",
          "947:   if (status != SGX_SUCCESS) {",
          "949:     snprintf(err_string, BUF_LEN,\"sgx unseal SEK failed with status %d\", status);",
          "950:     return;",
          "951:   }",
          "953:   uint64_t len;",
          "954:   hex2carray(aes_key_hex, &len, (uint8_t* )AES_key);",
          "959:                     uint8_t *encrypted_SEK, uint32_t *enc_len, const char* SEK_hex){",
          "961:   uint64_t len;",
          "962:   hex2carray(SEK_hex, &len, (uint8_t* )AES_key);",
          "964:   uint32_t sealedLen = sgx_calc_sealed_data_size(0, strlen(SEK_hex) + 1);",
          "966:   sgx_status_t status = sgx_seal_data(0, NULL, strlen(SEK_hex) + 1, SEK_hex, sealedLen,(sgx_sealed_data_t*)encrypted_SEK);",
          "967:   if( status !=  SGX_SUCCESS) {",
          "968:     snprintf(err_string, BUF_LEN, \"seal SEK failed with status %d\", status);",
          "970:     return;",
          "971:   }",
          "979:                         uint8_t *encrypted_key, uint32_t *enc_len, char * pub_key_x, char * pub_key_y) {",
          "981:   domain_parameters curve = domain_parameters_init();",
          "982:   domain_parameters_load_curve(curve, secp256k1);",
          "984:   unsigned char* rand_char = (unsigned char*)malloc(32);",
          "985:   sgx_read_rand( rand_char, 32);",
          "987:   mpz_t seed;",
          "988:   mpz_init(seed);",
          "989:   mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);",
          "991:   free(rand_char);",
          "993:   mpz_t skey;",
          "994:   mpz_init(skey);",
          "995:   mpz_mod(skey, seed, curve->p);",
          "996:   mpz_clear(seed);",
          "999:   point Pkey = point_init();",
          "1001:   signature_generate_key(Pkey, skey, curve);",
          "1003:   uint8_t base = 16;",
          "1005:   int len = mpz_sizeinbase (Pkey->x, base) + 2;",
          "1007:   char arr_x[len];",
          "1008:   char* px = mpz_get_str(arr_x, base, Pkey->x);",
          "1010:   int n_zeroes = 64 - strlen(arr_x);",
          "1011:   for ( int i = 0; i < n_zeroes; i++){",
          "1012:     pub_key_x[i] = '0';",
          "1013:   }",
          "1015:   strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "1017:   char arr_y[mpz_sizeinbase (Pkey->y, base) + 2];",
          "1018:   char* py = mpz_get_str(arr_y, base, Pkey->y);",
          "1019:   n_zeroes = 64 - strlen(arr_y);",
          "1020:   for ( int i = 0; i < n_zeroes; i++){",
          "1021:     pub_key_y[i] = '0';",
          "1022:   }",
          "1023:   strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "1024:   char skey_str[mpz_sizeinbase (skey, ECDSA_SKEY_BASE) + 2];",
          "1025:   char* s  = mpz_get_str(skey_str, ECDSA_SKEY_BASE, skey);",
          "1026:   snprintf(err_string, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "1028:   int stat = AES_encrypt(skey_str, encrypted_key);",
          "1030:   if( stat != 0) {",
          "1031:     snprintf(err_string, BUF_LEN,\"ecdsa private key encryption failed\");",
          "1033:     return;",
          "1034:   }",
          "1038:   stat = AES_decrypt(encrypted_key, *enc_len, skey_str);",
          "1039:   if( stat != 0) {",
          "1040:     snprintf(err_string + 19 + strlen(skey_str), BUF_LEN,\"ecdsa private key decr failed with status %d\", stat);",
          "1042:     return;",
          "1043:   }",
          "1045:   mpz_clear(skey);",
          "1046:   domain_parameters_clear(curve);",
          "1047:   point_clear(Pkey);",
          "1051:                           uint8_t *encrypted_key, uint32_t enc_len, char * pub_key_x, char * pub_key_y) {",
          "1053:   domain_parameters curve = domain_parameters_init();",
          "1054:   domain_parameters_load_curve(curve, secp256k1);",
          "1056:   char skey[ECDSA_SKEY_LEN];",
          "1058:   int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1060:   if (status != 0) {",
          "1061:     snprintf(err_string, BUF_LEN,\"AES_decrypt failed with status %d\", status);",
          "1063:     return;",
          "1064:   }",
          "1066:   skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';",
          "1068:   strncpy(err_string, skey, 1024);",
          "1070:   mpz_t skey_mpz;",
          "1071:   mpz_init(skey_mpz);",
          "1073:   if (mpz_set_str(skey_mpz, skey, ECDSA_SKEY_BASE) == -1){",
          "1074:     snprintf(err_string, BUF_LEN,\"wrong string to init private key  - %s\", skey);",
          "1076:     mpz_clear(skey_mpz);",
          "1077:     return;",
          "1078:   }",
          "1081:   point Pkey = point_init();",
          "1083:   signature_generate_key(Pkey, skey_mpz, curve);",
          "1085:   point Pkey_test = point_init();",
          "1086:   point_multiplication(Pkey_test, skey_mpz, curve->G, curve);",
          "1088:   if (!point_cmp(Pkey, Pkey_test)){",
          "1089:     snprintf(err_string, BUF_LEN,\"Points are not equal\");",
          "1091:     return;",
          "1092:   }",
          "1094:   int base = 16;",
          "1096:   int len = mpz_sizeinbase (Pkey->x, base) + 2;",
          "1098:   char arr_x[len];",
          "1099:   char* px = mpz_get_str(arr_x, base, Pkey->x);",
          "1101:   int n_zeroes = 64 - strlen(arr_x);",
          "1102:   for ( int i = 0; i < n_zeroes; i++){",
          "1103:     pub_key_x[i] = '0';",
          "1104:   }",
          "1106:   strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "1108:   char arr_y[mpz_sizeinbase (Pkey->y, base) + 2];",
          "1109:   char* py = mpz_get_str(arr_y, base, Pkey->y);",
          "1110:   n_zeroes = 64 - strlen(arr_y);",
          "1111:   for ( int i = 0; i < n_zeroes; i++){",
          "1112:     pub_key_y[i] = '0';",
          "1113:   }",
          "1114:   strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "1116:   mpz_clear(skey_mpz);",
          "1117:   domain_parameters_clear(curve);",
          "1118:   point_clear(Pkey);",
          "1122:                  unsigned char* hash, char * sig_r, char * sig_s, uint8_t* sig_v, int base) {",
          "1124:   domain_parameters curve = domain_parameters_init();",
          "1125:   domain_parameters_load_curve(curve, secp256k1);",
          "1127:   char skey[ECDSA_SKEY_LEN];",
          "1129:   int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1131:   if (status != 0) {",
          "1133:     snprintf(err_string, BUF_LEN,\"aes decrypt failed with status %d\", status);",
          "1134:     return;",
          "1135:   }",
          "1137:   skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE - 1] = '\\0';",
          "1139:   snprintf(err_string, BUF_LEN,\"pr key is %s length %d \", skey, strlen(skey));",
          "1140:   mpz_t skey_mpz;",
          "1141:   mpz_init(skey_mpz);",
          "1142:   if (mpz_set_str(skey_mpz, skey, ECDSA_SKEY_BASE) == -1){",
          "1144:     snprintf(err_string, BUF_LEN ,\"invalid secret key\");",
          "1145:     mpz_clear(skey_mpz);",
          "1146:     return;",
          "1147:   }",
          "1150:   mpz_t msg_mpz;",
          "1151:   mpz_init(msg_mpz);",
          "1152:   if (mpz_set_str(msg_mpz, hash, 16) == -1){",
          "1154:     snprintf(err_string, BUF_LEN ,\"invalid message hash\");",
          "1155:     mpz_clear(msg_mpz);",
          "1156:     return;",
          "1157:   }",
          "1159:   signature sign = signature_init();",
          "1161:   signature_sign( sign, msg_mpz, skey_mpz, curve);",
          "1163:   point Pkey = point_init();",
          "1165:   signature_generate_key(Pkey, skey_mpz, curve);",
          "1167:   if ( !signature_verify(msg_mpz, sign, Pkey, curve) ){",
          "1169:     snprintf(err_string, BUF_LEN,\"signature is not verified! \");",
          "1170:     return;",
          "1171:   }",
          "1177:   char arr_m[mpz_sizeinbase (msg_mpz, 16) + 2];",
          "1178:   char* msg = mpz_get_str(arr_m, 16, msg_mpz);",
          "1179:   snprintf(err_string, BUF_LEN,\"message is %s \", arr_m);",
          "1181:   char arr_r[mpz_sizeinbase (sign->r, base) + 2];",
          "1182:   char* r = mpz_get_str(arr_r, base, sign->r);",
          "1183:   strncpy(sig_r, arr_r, 1024);",
          "1185:   char arr_s[mpz_sizeinbase (sign->s, base) + 2];",
          "1186:   char* s = mpz_get_str(arr_s, base, sign->s);",
          "1187:   strncpy(sig_s, arr_s, 1024);",
          "1191:   mpz_clear(skey_mpz);",
          "1192:   mpz_clear(msg_mpz);",
          "1193:   domain_parameters_clear(curve);",
          "1194:   signature_clear(sign);",
          "1195:   point_clear(Pkey);",
          "1200:                  uint8_t *encrypted_key, uint32_t *enc_len) {",
          "1206:   memset(err_string, 0, BUF_LEN);",
          "",
          "[Added Lines]",
          "902:     mpz_clear(bls_key);",
          "903:     mpz_clear(sum);",
          "904:     mpz_clear(q);",
          "907: void get_bls_pub_key(int *err_status, char *err_string, uint8_t *encrypted_key, uint64_t key_len, char *bls_pub_key) {",
          "909:     char skey_hex[ECDSA_SKEY_LEN];",
          "911:     uint32_t len = key_len;",
          "913:     sgx_status_t status = sgx_unseal_data(",
          "914:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey_hex, &len);",
          "915:     if (status != SGX_SUCCESS) {",
          "917:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "918:         return;",
          "919:     }",
          "921:     if (calc_bls_public_key(skey_hex, bls_pub_key) != 0) {",
          "923:         snprintf(err_string, BUF_LEN, \"could not calculate bls public key\");",
          "924:         return;",
          "925:     }",
          "929:                   uint8_t *encrypted_SEK, uint32_t *enc_len, char *SEK_hex) {",
          "930:     uint8_t SEK_raw[SGX_AESGCM_KEY_SIZE];",
          "932:     sgx_read_rand(SEK_raw, SGX_AESGCM_KEY_SIZE);",
          "934:     uint32_t hex_aes_key_length = SGX_AESGCM_KEY_SIZE * 2;",
          "935:     uint8_t SEK[hex_aes_key_length];",
          "936:     carray2Hex(SEK_raw, SGX_AESGCM_KEY_SIZE, SEK_hex);",
          "938:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, hex_aes_key_length + 1);",
          "940:     for (uint8_t i = 0; i < 16; i++) {",
          "941:         AES_key[i] = SEK_raw[i];",
          "942:     }",
          "944:     sgx_status_t status = sgx_seal_data(0, NULL, hex_aes_key_length + 1, SEK_hex, sealedLen,",
          "945:                                         (sgx_sealed_data_t *) encrypted_SEK);",
          "946:     if (status != SGX_SUCCESS) {",
          "947:         snprintf(err_string, BUF_LEN, \"seal SEK failed\");",
          "949:         return;",
          "950:     }",
          "958: void set_SEK(int *err_status, char *err_string, uint8_t *encrypted_SEK, uint64_t encr_len) {",
          "962:     uint8_t aes_key_hex[SGX_AESGCM_KEY_SIZE * 2];",
          "963:     memset(aes_key_hex, 0, SGX_AESGCM_KEY_SIZE * 2);",
          "965:     sgx_status_t status = sgx_unseal_data(",
          "966:             (const sgx_sealed_data_t *) encrypted_SEK, NULL, 0, aes_key_hex, &encr_len);",
          "967:     if (status != SGX_SUCCESS) {",
          "969:         snprintf(err_string, BUF_LEN, \"sgx unseal SEK failed with status %d\", status);",
          "970:         return;",
          "971:     }",
          "973:     uint64_t len;",
          "974:     hex2carray(aes_key_hex, &len, (uint8_t *) AES_key);",
          "979:                     uint8_t *encrypted_SEK, uint32_t *enc_len, const char *SEK_hex) {",
          "981:     uint64_t len;",
          "982:     hex2carray(SEK_hex, &len, (uint8_t *) AES_key);",
          "984:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, strlen(SEK_hex) + 1);",
          "986:     sgx_status_t status = sgx_seal_data(0, NULL, strlen(SEK_hex) + 1, SEK_hex, sealedLen,",
          "987:                                         (sgx_sealed_data_t *) encrypted_SEK);",
          "988:     if (status != SGX_SUCCESS) {",
          "989:         snprintf(err_string, BUF_LEN, \"seal SEK failed with status %d\", status);",
          "991:         return;",
          "992:     }",
          "1000:                             uint8_t *encrypted_key, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
          "1002:     domain_parameters curve = domain_parameters_init();",
          "1003:     domain_parameters_load_curve(curve, secp256k1);",
          "1005:     unsigned char *rand_char = (unsigned char *) malloc(32);",
          "1006:     sgx_read_rand(rand_char, 32);",
          "1008:     mpz_t seed;",
          "1009:     mpz_init(seed);",
          "1010:     mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);",
          "1012:     free(rand_char);",
          "1014:     mpz_t skey;",
          "1015:     mpz_init(skey);",
          "1016:     mpz_mod(skey, seed, curve->p);",
          "1017:     mpz_clear(seed);",
          "1020:     point Pkey = point_init();",
          "1022:     signature_extract_public_key(Pkey, skey, curve);",
          "1024:     uint8_t base = 16;",
          "1026:     int len = mpz_sizeinbase(Pkey->x, base) + 2;",
          "1028:     char arr_x[len];",
          "1029:     char *px = mpz_get_str(arr_x, base, Pkey->x);",
          "1031:     int n_zeroes = 64 - strlen(arr_x);",
          "1032:     for (int i = 0; i < n_zeroes; i++) {",
          "1033:         pub_key_x[i] = '0';",
          "1034:     }",
          "1036:     strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "1038:     char arr_y[mpz_sizeinbase(Pkey->y, base) + 2];",
          "1039:     char *py = mpz_get_str(arr_y, base, Pkey->y);",
          "1040:     n_zeroes = 64 - strlen(arr_y);",
          "1041:     for (int i = 0; i < n_zeroes; i++) {",
          "1042:         pub_key_y[i] = '0';",
          "1043:     }",
          "1044:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "1045:     char skey_str[mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2];",
          "1046:     char *s = mpz_get_str(skey_str, ECDSA_SKEY_BASE, skey);",
          "1047:     snprintf(err_string, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "1049:     int stat = AES_encrypt(skey_str, encrypted_key);",
          "1051:     if (stat != 0) {",
          "1052:         snprintf(err_string, BUF_LEN, \"ecdsa private key encryption failed\");",
          "1054:         return;",
          "1055:     }",
          "1059:     stat = AES_decrypt(encrypted_key, *enc_len, skey_str);",
          "1060:     if (stat != 0) {",
          "1061:         snprintf(err_string + 19 + strlen(skey_str), BUF_LEN, \"ecdsa private key decr failed with status %d\", stat);",
          "1063:         return;",
          "1064:     }",
          "1066:     mpz_clear(skey);",
          "1067:     domain_parameters_clear(curve);",
          "1068:     point_clear(Pkey);",
          "1072:                               uint8_t *encrypted_key, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {",
          "1074:     domain_parameters curve = domain_parameters_init();",
          "1075:     domain_parameters_load_curve(curve, secp256k1);",
          "1077:     char skey[ECDSA_SKEY_LEN];",
          "1079:     int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1081:     if (status != 0) {",
          "1082:         snprintf(err_string, BUF_LEN, \"AES_decrypt failed with status %d\", status);",
          "1084:         return;",
          "1085:     }",
          "1087:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';",
          "1089:     strncpy(err_string, skey, 1024);",
          "1091:     mpz_t skey_mpz;",
          "1092:     mpz_init(skey_mpz);",
          "1094:     if (mpz_set_str(skey_mpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "1095:         snprintf(err_string, BUF_LEN, \"wrong string to init private key  - %s\", skey);",
          "1097:         mpz_clear(skey_mpz);",
          "1098:         return;",
          "1099:     }",
          "1102:     point Pkey = point_init();",
          "1104:     signature_extract_public_key(Pkey, skey_mpz, curve);",
          "1106:     point Pkey_test = point_init();",
          "1107:     point_multiplication(Pkey_test, skey_mpz, curve->G, curve);",
          "1109:     if (!point_cmp(Pkey, Pkey_test)) {",
          "1110:         snprintf(err_string, BUF_LEN, \"Points are not equal\");",
          "1112:         return;",
          "1113:     }",
          "1115:     int base = 16;",
          "1117:     int len = mpz_sizeinbase(Pkey->x, base) + 2;",
          "1119:     char arr_x[len];",
          "1120:     char *px = mpz_get_str(arr_x, base, Pkey->x);",
          "1122:     int n_zeroes = 64 - strlen(arr_x);",
          "1123:     for (int i = 0; i < n_zeroes; i++) {",
          "1124:         pub_key_x[i] = '0';",
          "1125:     }",
          "1127:     strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);",
          "1129:     char arr_y[mpz_sizeinbase(Pkey->y, base) + 2];",
          "1130:     char *py = mpz_get_str(arr_y, base, Pkey->y);",
          "1131:     n_zeroes = 64 - strlen(arr_y);",
          "1132:     for (int i = 0; i < n_zeroes; i++) {",
          "1133:         pub_key_y[i] = '0';",
          "1134:     }",
          "1135:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "1137:     mpz_clear(skey_mpz);",
          "1138:     domain_parameters_clear(curve);",
          "1139:     point_clear(Pkey);",
          "1143:                     unsigned char *hash, char *sig_r, char *sig_s, uint8_t *sig_v, int base) {",
          "1145:     domain_parameters curve = domain_parameters_init();",
          "1146:     domain_parameters_load_curve(curve, secp256k1);",
          "1148:     char skey[ECDSA_SKEY_LEN];",
          "1150:     int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1152:     if (status != 0) {",
          "1154:         snprintf(err_string, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1155:         return;",
          "1156:     }",
          "1158:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE - 1] = '\\0';",
          "1160:     snprintf(err_string, BUF_LEN, \"pr key is %s length %d \", skey, strlen(skey));",
          "1161:     mpz_t skey_mpz;",
          "1162:     mpz_init(skey_mpz);",
          "1163:     if (mpz_set_str(skey_mpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "1165:         snprintf(err_string, BUF_LEN, \"invalid secret key\");",
          "1166:         mpz_clear(skey_mpz);",
          "1167:         return;",
          "1168:     }",
          "1171:     mpz_t msg_mpz;",
          "1172:     mpz_init(msg_mpz);",
          "1173:     if (mpz_set_str(msg_mpz, hash, 16) == -1) {",
          "1175:         snprintf(err_string, BUF_LEN, \"invalid message hash\");",
          "1176:         mpz_clear(msg_mpz);",
          "1177:         return;",
          "1178:     }",
          "1180:     signature sign = signature_init();",
          "1182:     signature_sign(sign, msg_mpz, skey_mpz, curve);",
          "1184:     point Pkey = point_init();",
          "1186:     signature_extract_public_key(Pkey, skey_mpz, curve);",
          "1188:     if (!signature_verify(msg_mpz, sign, Pkey, curve)) {",
          "1190:         snprintf(err_string, BUF_LEN, \"signature is not verified! \");",
          "1191:         return;",
          "1192:     }",
          "1198:     char arr_m[mpz_sizeinbase(msg_mpz, 16) + 2];",
          "1199:     char *msg = mpz_get_str(arr_m, 16, msg_mpz);",
          "1200:     snprintf(err_string, BUF_LEN, \"message is %s \", arr_m);",
          "1202:     char arr_r[mpz_sizeinbase(sign->r, base) + 2];",
          "1203:     char *r = mpz_get_str(arr_r, base, sign->r);",
          "1204:     strncpy(sig_r, arr_r, 1024);",
          "1206:     char arr_s[mpz_sizeinbase(sign->s, base) + 2];",
          "1207:     char *s = mpz_get_str(arr_s, base, sign->s);",
          "1208:     strncpy(sig_s, arr_s, 1024);",
          "1212:     mpz_clear(skey_mpz);",
          "1213:     mpz_clear(msg_mpz);",
          "1214:     domain_parameters_clear(curve);",
          "1215:     signature_free(sign);",
          "1216:     point_clear(Pkey);",
          "1221:                      uint8_t *encrypted_key, uint32_t *enc_len) {",
          "1227:     memset(err_string, 0, BUF_LEN);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1253: }",
          "1255: void decrypt_key_aes(int *err_status, char *err_string, uint8_t *encrypted_key,",
          "1294: }",
          "1296: void bls_sign_message_aes(int *err_status, char *err_string, uint8_t *encrypted_key,",
          "1326: }",
          "1368: }",
          "1380: }",
          "1391: }",
          "1470: }",
          "1497: }",
          "1561: }",
          "1631:     }",
          "1657:     mpz_clear(bls_key);",
          "1658:     mpz_clear(sum);",
          "1659:     mpz_clear(q);",
          "1667: }",
          "1671:     char skey_hex[ECDSA_SKEY_LEN];",
          "",
          "[Removed Lines]",
          "1215:   memset(encrypted_key, 0, BUF_LEN);",
          "1217:   int stat = AES_encrypt(key, encrypted_key);",
          "1218:   if ( stat != 0) {",
          "1220:     snprintf(err_string, BUF_LEN, \"AES encrypt failed with status %d\", stat);",
          "1221:     return;",
          "1222:   }",
          "1226:   char decryptedKey[BUF_LEN];",
          "1227:   memset(decryptedKey, 0, BUF_LEN);",
          "1229:   stat = AES_decrypt(encrypted_key, *enc_len, decryptedKey);",
          "1231:   if (stat != 0) {",
          "1233:     snprintf(err_string, BUF_LEN, \":decrypt_key failed with status %d\", stat);",
          "1234:     return;",
          "1235:   }",
          "1237:   uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);",
          "1239:   if (decryptedKeyLen == MAX_KEY_LENGTH) {",
          "1240:     snprintf(err_string, BUF_LEN, \"Decrypted key is not null terminated\");",
          "1241:     return;",
          "1242:   }",
          "1247:   if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {",
          "1248:     snprintf(err_string, BUF_LEN, \"Decrypted key does not match original key\");",
          "1249:     return;",
          "1250:   }",
          "1256:                  uint32_t enc_len, char *key) {",
          "1258:   init();",
          "1260:   uint32_t decLen;",
          "1264:   int status = AES_decrypt(encrypted_key, enc_len, key);",
          "1266:   if (status != 0) {",
          "1268:     snprintf(err_string, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1269:     return;",
          "1270:   }",
          "1274:   if (decLen > MAX_KEY_LENGTH) {",
          "1276:     snprintf(err_string, BUF_LEN, \"wrong decLen\");//\"decLen != MAX_KEY_LENGTH\");",
          "1277:     return;",
          "1278:   }",
          "1283:   uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH);",
          "1286:   if (keyLen == MAX_KEY_LENGTH) {",
          "1287:     snprintf(err_string, BUF_LEN, \"Key is not null terminated\");",
          "1288:     return;",
          "1289:   }",
          "1292:   memcpy(err_string, AES_key, 1024);",
          "1297:                       uint32_t enc_len, char *_hashX,",
          "1298:                       char *_hashY, char *signature) {",
          "1300:   char key[BUF_LEN];",
          "1301:   memset(key, 0, BUF_LEN);",
          "1302:   char sig[BUF_LEN];",
          "1303:   memset(sig, 0, BUF_LEN);",
          "1306:   init();",
          "1309:   int stat = AES_decrypt(encrypted_key, enc_len, key);",
          "1311:   if ( stat != 0) {",
          "1313:     strncpy(signature, err_string, BUF_LEN);",
          "1314:     return;",
          "1315:   }",
          "1317:   enclave_sign(key, _hashX, _hashY, sig);",
          "1319:   strncpy(signature, sig, BUF_LEN);",
          "1321:   if (strnlen(signature, BUF_LEN) < 10) {",
          "1323:     return;",
          "1324:   }",
          "1328: void gen_dkg_secret_aes (int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t* enc_len, size_t _t){",
          "1330:   char dkg_secret[DKG_BUFER_LENGTH];// = (char*)calloc(DKG_BUFER_LENGTH, 1);",
          "1331:   memset(dkg_secret, 0, DKG_BUFER_LENGTH);",
          "1333:   if (gen_dkg_poly(dkg_secret, _t) != 0 ){",
          "1335:     return;",
          "1336:   }",
          "1338:   snprintf(err_string, BUF_LEN,\"poly is %s \", dkg_secret);",
          "1340:   int status = AES_encrypt(dkg_secret, encrypted_dkg_secret);",
          "1342:   if(status !=  SGX_SUCCESS) {",
          "1343:     snprintf(err_string, BUF_LEN,\"SGX AES encrypt DKG poly failed\");",
          "1345:     return;",
          "1346:   }",
          "1351:   char decr_dkg_secret[DKG_BUFER_LENGTH];",
          "1352:   memset(decr_dkg_secret, 0, DKG_BUFER_LENGTH);",
          "1354:   status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret);",
          "1355:   if(status !=  SGX_SUCCESS) {",
          "1356:     snprintf(err_string, BUF_LEN,\"aes decrypt  dkg poly failed\");",
          "1358:     return;",
          "1359:   }",
          "1361:   if ( strcmp(dkg_secret, decr_dkg_secret) != 0){",
          "1362:     snprintf(err_string, BUF_LEN,\"poly is %s \", dkg_secret);",
          "1363:     snprintf(err_string + strlen(dkg_secret) + 8, BUF_LEN - strlen(dkg_secret) - 8,\"encrypted poly is not equal to decrypted poly\");",
          "1365:   }",
          "1370: void decrypt_dkg_secret_aes (int *err_status, char* err_string, uint8_t* encrypted_dkg_secret, uint8_t* decrypted_dkg_secret, uint32_t* dec_len){",
          "1372:   int status = AES_decrypt(encrypted_dkg_secret, dec_len, decrypted_dkg_secret);",
          "1374:   if (status != SGX_SUCCESS) {",
          "1375:     snprintf(err_string, BUF_LEN,\"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1377:     return;",
          "1378:   }",
          "1382: void set_encrypted_dkg_poly_aes(int *err_status, char *err_string, uint8_t* encrypted_poly,  uint64_t* enc_len){",
          "1383:   memset(Decrypted_dkg_poly, 0, DKG_BUFER_LENGTH);",
          "1384:   int status = AES_decrypt(encrypted_poly, *enc_len, Decrypted_dkg_poly);",
          "1386:   if (status != SGX_SUCCESS) {",
          "1388:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "1389:     return;",
          "1390:   }",
          "1393: void get_encr_sshare_aes(int *err_status, char *err_string, uint8_t *encrypted_skey, uint32_t* dec_len,",
          "1394:                      char* result_str, char * s_shareG2, char* pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind ){",
          "1396:   char skey[ECDSA_SKEY_LEN];",
          "1397:   memset(skey, 0, BUF_LEN);",
          "1398:   char pub_key_x[BUF_LEN];",
          "1399:   memset(pub_key_x, 0, BUF_LEN);",
          "1400:   char pub_key_y[BUF_LEN];",
          "1401:   memset(pub_key_y, 0, BUF_LEN);",
          "1405:   uint32_t enc_len;",
          "1407:   generate_ecdsa_key_aes(err_status, err_string, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "1408:   if ( *err_status != 0){",
          "1409:     return;",
          "1410:   }",
          "1413:   int status = AES_decrypt(encrypted_skey, enc_len, skey);",
          "1414:   skey[ECDSA_SKEY_LEN - 1] = 0;",
          "1416:   if (status != SGX_SUCCESS) {",
          "1417:     snprintf(err_string, BUF_LEN,\"AES_decrypt failed (in get_encr_sshare_aes)  with status %d\", status);",
          "1419:     return;",
          "1420:   }",
          "1421:   snprintf(err_string, BUF_LEN,\"unsealed random skey is %s\\n\", skey);",
          "1425:   char * common_key[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "1426:   gen_session_key(skey, pub_keyB, common_key);",
          "1430:   char* s_share[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "1433:   if (calc_secret_share(Decrypted_dkg_poly, s_share, _t, _n, ind) != 0){",
          "1436:     snprintf(err_string, BUF_LEN, Decrypted_dkg_poly);",
          "1437:     return;",
          "1438:   }",
          "1439:   snprintf(err_string + 88, BUF_LEN,\"\\nsecret share is %s\", s_share);",
          "1441:   if (calc_secret_shareG2(s_share, s_shareG2) != 0){",
          "1443:     snprintf(err_string, BUF_LEN,\"invalid decr secret share\");",
          "1444:     return;",
          "1445:   }",
          "1447:   char* cypher[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "1448:   xor_encrypt(common_key, s_share, cypher);",
          "1449:   if (cypher == NULL){",
          "1451:     snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "1452:     return;",
          "1453:   }",
          "1456:   strncpy(result_str, cypher, strlen(cypher));",
          "1457:   strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));",
          "1458:   strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));",
          "1472: void get_public_shares_aes(int *err_status, char* err_string, uint8_t* encrypted_dkg_secret, uint32_t enc_len, char* public_shares,",
          "1473:                        unsigned _t, unsigned _n){",
          "1475:   char* decrypted_dkg_secret = (char*)calloc(DKG_MAX_SEALED_LEN, 1);",
          "1476:   memset(decrypted_dkg_secret, 0, DKG_MAX_SEALED_LEN);",
          "1479:   int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret);",
          "1482:   if (status != SGX_SUCCESS) {",
          "1483:     snprintf(err_string, BUF_LEN,\"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1485:     return;",
          "1486:   }",
          "1490:   if ( calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0 ){",
          "1492:     snprintf(err_string, BUF_LEN,\"t does not match polynomial in db\");",
          "1493:     return;",
          "1494:   }",
          "1499: void dkg_verification_aes(int *err_status, char* err_string, const char * public_shares, const char* s_share,",
          "1500:                       uint8_t* encrypted_key, uint64_t enc_len, unsigned _t, int _ind, int * result){",
          "1503:   char skey[ECDSA_SKEY_LEN];",
          "1504:   memset(skey, 0, ECDSA_SKEY_LEN);",
          "1505:   int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1508:   if (status != SGX_SUCCESS) {",
          "1509:     snprintf(err_string, BUF_LEN,\"AES_decrypt failed (in dkg_verification_aes)  with status %d\", status);",
          "1511:     return;",
          "1512:   }",
          "1514:   char encr_sshare[ECDSA_SKEY_LEN];",
          "1515:   memset(encr_sshare, 0, ECDSA_SKEY_LEN);",
          "1516:   strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1 );",
          "1519:   char common_key[ECDSA_SKEY_LEN];",
          "1520:   memset(common_key, 0, ECDSA_SKEY_LEN);",
          "1522:   session_key_recover(skey, s_share, common_key);",
          "1524:   if (common_key == NULL || strlen(common_key) == 0 ){",
          "1526:     snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "1527:     return;",
          "1528:   }",
          "1530:   char decr_sshare[ECDSA_SKEY_LEN];",
          "1531:   memset(decr_sshare, 0, ECDSA_SKEY_LEN);",
          "1532:   xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "1533:   if (decr_sshare == NULL){",
          "1535:     snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "1536:     return;",
          "1537:   }",
          "1548:   mpz_t s;",
          "1549:   mpz_init(s);",
          "1550:   if (mpz_set_str(s, decr_sshare, 16) == -1){",
          "1552:     snprintf(err_string, BUF_LEN ,\"invalid decr secret share\");",
          "1553:     mpz_clear(s);",
          "1554:     return;",
          "1555:   }",
          "1559:   snprintf(err_string, BUF_LEN,\"secret share dec %s\", public_shares);",
          "1563: void create_bls_key_aes(int *err_status, char* err_string, const char* s_shares,",
          "1564:                     uint8_t* encrypted_key, uint64_t key_len, uint8_t * encr_bls_key, uint32_t *enc_bls_key_len){",
          "1566:   char skey[ECDSA_SKEY_LEN];",
          "1567:   int status = AES_decrypt(encrypted_key, key_len, skey);",
          "1568:   if (status != SGX_SUCCESS) {",
          "1570:     snprintf(err_string, BUF_LEN,\"aes decrypt failed with status %d\", status);",
          "1571:     return;",
          "1572:   }",
          "1573:   skey[ECDSA_SKEY_LEN - 1] = 0;",
          "1575:   int num_shares = strlen(s_shares)/192;",
          "1577:   mpz_t sum;",
          "1578:   mpz_init(sum);",
          "1579:   mpz_set_ui(sum, 0);",
          "1585:   for ( int i = 0; i < num_shares; i++) {",
          "1586:     char encr_sshare[65];",
          "1587:     strncpy(encr_sshare, s_shares + 192 * i, 64);",
          "1588:     encr_sshare[64] = 0;",
          "1590:     char s_share[193];",
          "1591:     strncpy(s_share, s_shares + 192 * i, 192);",
          "1592:     s_share[192] = 0;",
          "1594:     char common_key[65];",
          "1595:     session_key_recover(skey, s_share, common_key);",
          "1596:     common_key[64] = 0;",
          "1598:     if (common_key == NULL){",
          "1600:       snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "1601:       mpz_clear(sum);",
          "1602:       return;",
          "1603:     }",
          "1609:     char decr_sshare[65];",
          "1610:     xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "1611:     if (decr_sshare == NULL){",
          "1613:       snprintf(err_string, BUF_LEN ,\"invalid common_key\");",
          "1614:       mpz_clear(sum);",
          "1615:       return;",
          "1616:     }",
          "1617:     decr_sshare[64] = 0;",
          "1623:     mpz_t decr_secret_share;",
          "1624:     mpz_init(decr_secret_share);",
          "1625:     if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1){",
          "1628:       snprintf(err_string, BUF_LEN ,decr_sshare);",
          "1629:       mpz_clear(decr_secret_share);",
          "1630:       return;",
          "1633:     mpz_addmul_ui(sum, decr_secret_share, 1);",
          "1634:     mpz_clear(decr_secret_share);",
          "1635:   }",
          "1637:   mpz_t q;",
          "1638:   mpz_init(q);",
          "1639:   mpz_set_str(q, \"21888242871839275222246405745257275088548364400416034343698204186575808495617\", 10);",
          "1641:   mpz_t bls_key;",
          "1642:   mpz_init(bls_key);",
          "1644:   mpz_mod(bls_key, sum, q);",
          "1646:   char key_share[mpz_sizeinbase(bls_key, 16) + 2];",
          "1647:   char *key = mpz_get_str(key_share, 16, bls_key);",
          "1648:   snprintf(err_string, BUF_LEN,\" bls private key is %s\", key_share);",
          "1649:   uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "1652:   status = AES_encrypt(key_share, encr_bls_key);",
          "1654:   if( status !=  SGX_SUCCESS) {",
          "1656:     snprintf(err_string, BUF_LEN,\"aes encrypt bls private key failed with status %d \", status);",
          "1660:     return;",
          "1661:   }",
          "1664:   mpz_clear(bls_key);",
          "1665:   mpz_clear(sum);",
          "1666:   mpz_clear(q);",
          "1669: void get_bls_pub_key_aes(int *err_status, char* err_string, uint8_t* encrypted_key, uint64_t key_len, char* bls_pub_key){",
          "",
          "[Added Lines]",
          "1236:     memset(encrypted_key, 0, BUF_LEN);",
          "1238:     int stat = AES_encrypt(key, encrypted_key);",
          "1239:     if (stat != 0) {",
          "1241:         snprintf(err_string, BUF_LEN, \"AES encrypt failed with status %d\", stat);",
          "1242:         return;",
          "1243:     }",
          "1247:     char decryptedKey[BUF_LEN];",
          "1248:     memset(decryptedKey, 0, BUF_LEN);",
          "1250:     stat = AES_decrypt(encrypted_key, *enc_len, decryptedKey);",
          "1252:     if (stat != 0) {",
          "1254:         snprintf(err_string, BUF_LEN, \":decrypt_key failed with status %d\", stat);",
          "1255:         return;",
          "1256:     }",
          "1258:     uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);",
          "1260:     if (decryptedKeyLen == MAX_KEY_LENGTH) {",
          "1261:         snprintf(err_string, BUF_LEN, \"Decrypted key is not null terminated\");",
          "1262:         return;",
          "1263:     }",
          "1268:     if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {",
          "1269:         snprintf(err_string, BUF_LEN, \"Decrypted key does not match original key\");",
          "1270:         return;",
          "1271:     }",
          "1277:                      uint32_t enc_len, char *key) {",
          "1279:     init();",
          "1281:     uint32_t decLen;",
          "1285:     int status = AES_decrypt(encrypted_key, enc_len, key);",
          "1287:     if (status != 0) {",
          "1289:         snprintf(err_string, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1290:         return;",
          "1291:     }",
          "1295:     if (decLen > MAX_KEY_LENGTH) {",
          "1297:         snprintf(err_string, BUF_LEN, \"wrong decLen\");//\"decLen != MAX_KEY_LENGTH\");",
          "1298:         return;",
          "1299:     }",
          "1304:     uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH);",
          "1307:     if (keyLen == MAX_KEY_LENGTH) {",
          "1308:         snprintf(err_string, BUF_LEN, \"Key is not null terminated\");",
          "1309:         return;",
          "1310:     }",
          "1313:     memcpy(err_string, AES_key, 1024);",
          "1318:                           uint32_t enc_len, char *_hashX,",
          "1319:                           char *_hashY, char *signature) {",
          "1321:     char key[BUF_LEN];",
          "1322:     memset(key, 0, BUF_LEN);",
          "1323:     char sig[BUF_LEN];",
          "1324:     memset(sig, 0, BUF_LEN);",
          "1327:     init();",
          "1330:     int stat = AES_decrypt(encrypted_key, enc_len, key);",
          "1332:     if (stat != 0) {",
          "1334:         strncpy(signature, err_string, BUF_LEN);",
          "1335:         return;",
          "1336:     }",
          "1338:     enclave_sign(key, _hashX, _hashY, sig);",
          "1340:     strncpy(signature, sig, BUF_LEN);",
          "1342:     if (strnlen(signature, BUF_LEN) < 10) {",
          "1344:         return;",
          "1345:     }",
          "1349: void",
          "1350: gen_dkg_secret_aes(int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
          "1352:     char dkg_secret[DKG_BUFER_LENGTH];// = (char*)calloc(DKG_BUFER_LENGTH, 1);",
          "1353:     memset(dkg_secret, 0, DKG_BUFER_LENGTH);",
          "1355:     if (gen_dkg_poly(dkg_secret, _t) != 0) {",
          "1357:         return;",
          "1358:     }",
          "1360:     snprintf(err_string, BUF_LEN, \"poly is %s \", dkg_secret);",
          "1362:     int status = AES_encrypt(dkg_secret, encrypted_dkg_secret);",
          "1364:     if (status != SGX_SUCCESS) {",
          "1365:         snprintf(err_string, BUF_LEN, \"SGX AES encrypt DKG poly failed\");",
          "1367:         return;",
          "1368:     }",
          "1373:     char decr_dkg_secret[DKG_BUFER_LENGTH];",
          "1374:     memset(decr_dkg_secret, 0, DKG_BUFER_LENGTH);",
          "1376:     status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret);",
          "1377:     if (status != SGX_SUCCESS) {",
          "1378:         snprintf(err_string, BUF_LEN, \"aes decrypt  dkg poly failed\");",
          "1380:         return;",
          "1381:     }",
          "1383:     if (strcmp(dkg_secret, decr_dkg_secret) != 0) {",
          "1384:         snprintf(err_string, BUF_LEN, \"poly is %s \", dkg_secret);",
          "1385:         snprintf(err_string + strlen(dkg_secret) + 8, BUF_LEN - strlen(dkg_secret) - 8,",
          "1386:                  \"encrypted poly is not equal to decrypted poly\");",
          "1388:     }",
          "1393: void",
          "1394: decrypt_dkg_secret_aes(int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint8_t *decrypted_dkg_secret,",
          "1395:                        uint32_t *dec_len) {",
          "1397:     int status = AES_decrypt(encrypted_dkg_secret, dec_len, decrypted_dkg_secret);",
          "1399:     if (status != SGX_SUCCESS) {",
          "1400:         snprintf(err_string, BUF_LEN, \"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1402:         return;",
          "1403:     }",
          "1407: void set_encrypted_dkg_poly_aes(int *err_status, char *err_string, uint8_t *encrypted_poly, uint64_t *enc_len) {",
          "1408:     memset(Decrypted_dkg_poly, 0, DKG_BUFER_LENGTH);",
          "1409:     int status = AES_decrypt(encrypted_poly, *enc_len, Decrypted_dkg_poly);",
          "1411:     if (status != SGX_SUCCESS) {",
          "1413:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "1414:         return;",
          "1415:     }",
          "1418: void get_encr_sshare_aes(int *err_status, char *err_string, uint8_t *encrypted_skey, uint32_t *dec_len,",
          "1419:                          char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) {",
          "1421:     char skey[ECDSA_SKEY_LEN];",
          "1422:     memset(skey, 0, BUF_LEN);",
          "1423:     char pub_key_x[BUF_LEN];",
          "1424:     memset(pub_key_x, 0, BUF_LEN);",
          "1425:     char pub_key_y[BUF_LEN];",
          "1426:     memset(pub_key_y, 0, BUF_LEN);",
          "1430:     uint32_t enc_len;",
          "1432:     generate_ecdsa_key_aes(err_status, err_string, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "1433:     if (*err_status != 0) {",
          "1434:         return;",
          "1435:     }",
          "1438:     int status = AES_decrypt(encrypted_skey, enc_len, skey);",
          "1439:     skey[ECDSA_SKEY_LEN - 1] = 0;",
          "1441:     if (status != SGX_SUCCESS) {",
          "1442:         snprintf(err_string, BUF_LEN, \"AES_decrypt failed (in get_encr_sshare_aes)  with status %d\", status);",
          "1444:         return;",
          "1445:     }",
          "1446:     snprintf(err_string, BUF_LEN, \"unsealed random skey is %s\\n\", skey);",
          "1450:     char *common_key[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "1451:     gen_session_key(skey, pub_keyB, common_key);",
          "1455:     char *s_share[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "1458:     if (calc_secret_share(Decrypted_dkg_poly, s_share, _t, _n, ind) != 0) {",
          "1461:         snprintf(err_string, BUF_LEN, Decrypted_dkg_poly);",
          "1462:         return;",
          "1463:     }",
          "1464:     snprintf(err_string + 88, BUF_LEN, \"\\nsecret share is %s\", s_share);",
          "1466:     if (calc_secret_shareG2(s_share, s_shareG2) != 0) {",
          "1468:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\");",
          "1469:         return;",
          "1470:     }",
          "1472:     char *cypher[ECDSA_SKEY_LEN]; //= (char *)malloc(65);",
          "1473:     xor_encrypt(common_key, s_share, cypher);",
          "1474:     if (cypher == NULL) {",
          "1476:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "1477:         return;",
          "1478:     }",
          "1481:     strncpy(result_str, cypher, strlen(cypher));",
          "1482:     strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));",
          "1483:     strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));",
          "1497: void get_public_shares_aes(int *err_status, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
          "1498:                            char *public_shares,",
          "1499:                            unsigned _t, unsigned _n) {",
          "1501:     char *decrypted_dkg_secret = (char *) calloc(DKG_MAX_SEALED_LEN, 1);",
          "1502:     memset(decrypted_dkg_secret, 0, DKG_MAX_SEALED_LEN);",
          "1505:     int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret);",
          "1508:     if (status != SGX_SUCCESS) {",
          "1509:         snprintf(err_string, BUF_LEN, \"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1511:         return;",
          "1512:     }",
          "1516:     if (calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0) {",
          "1518:         snprintf(err_string, BUF_LEN, \"t does not match polynomial in db\");",
          "1519:         return;",
          "1520:     }",
          "1525: void dkg_verification_aes(int *err_status, char *err_string, const char *public_shares, const char *s_share,",
          "1526:                           uint8_t *encrypted_key, uint64_t enc_len, unsigned _t, int _ind, int *result) {",
          "1529:     char skey[ECDSA_SKEY_LEN];",
          "1530:     memset(skey, 0, ECDSA_SKEY_LEN);",
          "1531:     int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1534:     if (status != SGX_SUCCESS) {",
          "1535:         snprintf(err_string, BUF_LEN, \"AES_decrypt failed (in dkg_verification_aes)  with status %d\", status);",
          "1537:         return;",
          "1538:     }",
          "1540:     char encr_sshare[ECDSA_SKEY_LEN];",
          "1541:     memset(encr_sshare, 0, ECDSA_SKEY_LEN);",
          "1542:     strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);",
          "1545:     char common_key[ECDSA_SKEY_LEN];",
          "1546:     memset(common_key, 0, ECDSA_SKEY_LEN);",
          "1548:     session_key_recover(skey, s_share, common_key);",
          "1550:     if (common_key == NULL || strlen(common_key) == 0) {",
          "1552:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "1553:         return;",
          "1554:     }",
          "1556:     char decr_sshare[ECDSA_SKEY_LEN];",
          "1557:     memset(decr_sshare, 0, ECDSA_SKEY_LEN);",
          "1558:     xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "1559:     if (decr_sshare == NULL) {",
          "1561:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "1562:         return;",
          "1563:     }",
          "1574:     mpz_t s;",
          "1575:     mpz_init(s);",
          "1576:     if (mpz_set_str(s, decr_sshare, 16) == -1) {",
          "1578:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\");",
          "1579:         mpz_clear(s);",
          "1580:         return;",
          "1581:     }",
          "1585:     snprintf(err_string, BUF_LEN, \"secret share dec %s\", public_shares);",
          "1589: void create_bls_key_aes(int *err_status, char *err_string, const char *s_shares,",
          "1590:                         uint8_t *encrypted_key, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {",
          "1592:     char skey[ECDSA_SKEY_LEN];",
          "1593:     int status = AES_decrypt(encrypted_key, key_len, skey);",
          "1594:     if (status != SGX_SUCCESS) {",
          "1596:         snprintf(err_string, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1597:         return;",
          "1598:     }",
          "1599:     skey[ECDSA_SKEY_LEN - 1] = 0;",
          "1601:     int num_shares = strlen(s_shares) / 192;",
          "1603:     mpz_t sum;",
          "1604:     mpz_init(sum);",
          "1605:     mpz_set_ui(sum, 0);",
          "1611:     for (int i = 0; i < num_shares; i++) {",
          "1612:         char encr_sshare[65];",
          "1613:         strncpy(encr_sshare, s_shares + 192 * i, 64);",
          "1614:         encr_sshare[64] = 0;",
          "1616:         char s_share[193];",
          "1617:         strncpy(s_share, s_shares + 192 * i, 192);",
          "1618:         s_share[192] = 0;",
          "1620:         char common_key[65];",
          "1621:         session_key_recover(skey, s_share, common_key);",
          "1622:         common_key[64] = 0;",
          "1624:         if (common_key == NULL) {",
          "1626:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "1627:             mpz_clear(sum);",
          "1628:             return;",
          "1629:         }",
          "1635:         char decr_sshare[65];",
          "1636:         xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "1637:         if (decr_sshare == NULL) {",
          "1639:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "1640:             mpz_clear(sum);",
          "1641:             return;",
          "1642:         }",
          "1643:         decr_sshare[64] = 0;",
          "1649:         mpz_t decr_secret_share;",
          "1650:         mpz_init(decr_secret_share);",
          "1651:         if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {",
          "1654:             snprintf(err_string, BUF_LEN, decr_sshare);",
          "1655:             mpz_clear(decr_secret_share);",
          "1656:             return;",
          "1657:         }",
          "1659:         mpz_addmul_ui(sum, decr_secret_share, 1);",
          "1660:         mpz_clear(decr_secret_share);",
          "1663:     mpz_t q;",
          "1664:     mpz_init(q);",
          "1665:     mpz_set_str(q, \"21888242871839275222246405745257275088548364400416034343698204186575808495617\", 10);",
          "1667:     mpz_t bls_key;",
          "1668:     mpz_init(bls_key);",
          "1670:     mpz_mod(bls_key, sum, q);",
          "1672:     char key_share[mpz_sizeinbase(bls_key, 16) + 2];",
          "1673:     char *key = mpz_get_str(key_share, 16, bls_key);",
          "1674:     snprintf(err_string, BUF_LEN, \" bls private key is %s\", key_share);",
          "1675:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "1678:     status = AES_encrypt(key_share, encr_bls_key);",
          "1680:     if (status != SGX_SUCCESS) {",
          "1682:         snprintf(err_string, BUF_LEN, \"aes encrypt bls private key failed with status %d \", status);",
          "1683:         mpz_clear(bls_key);",
          "1684:         mpz_clear(sum);",
          "1685:         mpz_clear(q);",
          "1686:         return;",
          "1687:     }",
          "1695: void",
          "1696: get_bls_pub_key_aes(int *err_status, char *err_string, uint8_t *encrypted_key, uint64_t key_len, char *bls_pub_key) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1675:     int status = AES_decrypt(encrypted_key, key_len, skey_hex);",
          "1676:     if (status != SGX_SUCCESS) {",
          "1679:         return;",
          "1680:     }",
          "1682:     skey_hex[ECDSA_SKEY_LEN - 1] = 0;",
          "1687:         return;",
          "1688:     }",
          "1689: }",
          "",
          "[Removed Lines]",
          "1678:         snprintf(err_string, BUF_LEN,\"aes_decrypt failed with status %d\", status);",
          "1684:     if (calc_bls_public_key(skey_hex, bls_pub_key) != 0){",
          "1686:         snprintf(err_string, BUF_LEN,\"could not calculate bls public key\");",
          "",
          "[Added Lines]",
          "1705:         snprintf(err_string, BUF_LEN, \"aes_decrypt failed with status %d\", status);",
          "1711:     if (calc_bls_public_key(skey_hex, bls_pub_key) != 0) {",
          "1713:         snprintf(err_string, BUF_LEN, \"could not calculate bls public key\");",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.i||secure_enclave/secure_enclave.i": [
          "File: secure_enclave/secure_enclave.i -> secure_enclave/secure_enclave.i",
          "--- Hunk 1 ---",
          "[Context before]",
          "6532: _Bool signature_cmp(signature sig1, signature sig2);",
          "6538: void signature_generate_key(point public_key, mpz_t private_key, domain_parameters curve);",
          "",
          "[Removed Lines]",
          "6535: void signature_clear(signature sig);",
          "",
          "[Added Lines]",
          "6535: void signature_free(signature sig);",
          "",
          "---------------"
        ],
        "secure_enclave/signature.c||secure_enclave/signature.c": [
          "File: secure_enclave/signature.c -> secure_enclave/signature.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"numbertheory.h\"",
          "43: }",
          "53: }",
          "60: }",
          "66: }",
          "73: }",
          "80: }",
          "87: }",
          "93: }",
          "211: }",
          "272: }",
          "280: }",
          "",
          "[Removed Lines]",
          "35: signature signature_init()",
          "36: {",
          "37:  signature sig;",
          "38:  sig = malloc(sizeof(struct signature_s));",
          "39:  mpz_init(sig->r);",
          "40:  mpz_init(sig->s);",
          "41:  sig->v = 0;",
          "42:  return sig;",
          "46: void signature_print(signature sig)",
          "47: {",
          "49:  mpz_out_str(stdout, 10, sig->r);",
          "50:  printf(\",\\n\\t\");",
          "51:  mpz_out_str(stdout, 10, sig->s);",
          "56: void signature_set_str(signature sig, char *r, char *s, int base)",
          "57: {",
          "58:  mpz_set_str(sig->r, r, base);",
          "59:  mpz_set_str(sig->s, s, base);",
          "63: void signature_set_hex(signature sig, char *r, char *s)",
          "64: {",
          "65:  signature_set_str(sig,r,s,16);",
          "69: void signature_set_ui(signature sig, unsigned long int r, unsigned long int s)",
          "70: {",
          "71:  mpz_set_ui(sig->r, r);",
          "72:  mpz_set_ui(sig->s, s);",
          "76: void signature_copy(signature R, signature sig)",
          "77: {",
          "78:  mpz_set(R->r, sig->r);",
          "79:  mpz_set(R->s, sig->s);",
          "84: bool signature_cmp(signature sig1, signature sig2)",
          "85: {",
          "86:  return !mpz_cmp(sig1->r,sig2->r) && !mpz_cmp(sig1->s,sig2->s);",
          "90: void signature_generate_key(point public_key, mpz_t private_key, domain_parameters curve)",
          "91: {",
          "92:  point_multiplication(public_key, private_key, curve->G, curve);",
          "96: void signature_sign(signature sig, mpz_t message, mpz_t private_key, domain_parameters curve)",
          "97: {",
          "100:  assert(mpz_sizeinbase(message, 2) <= mpz_sizeinbase(curve->n, 2));",
          "103:  mpz_t k;mpz_init(k);",
          "104:  mpz_t x;mpz_init(x);",
          "105:  point Q = point_init();",
          "106:  mpz_t r;mpz_init(r);",
          "107:  mpz_t t1;mpz_init(t1);",
          "108:  mpz_t t2;mpz_init(t2);",
          "109:  mpz_t t3;mpz_init(t3);",
          "110:  mpz_t s;mpz_init(s);",
          "112:     unsigned char* rand_char = (unsigned char*)malloc(32);",
          "113:     sgx_read_rand( rand_char, 32);",
          "115:  gmp_randstate_t r_state;",
          "117:  signature_sign_start:",
          "120:     sgx_read_rand( rand_char, 32);",
          "121:     mpz_t seed;",
          "122:     mpz_init(seed);",
          "123:     mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);",
          "124:     free(rand_char);",
          "127:     mpz_mod(k, seed, curve->p);",
          "128:     mpz_clear(seed);",
          "135:  point_multiplication(Q, k, curve->G, curve);",
          "136:  mpz_set(x, Q->x);",
          "139:  mpz_mod(r, x, curve->n);",
          "140:  if(!mpz_sgn(r)) //Start over if r=0, note haven't been tested memory might die :)",
          "141:   goto signature_sign_start;",
          "142:  mpz_clear(x);",
          "147:  mpz_invert(t1, k, curve->n);",
          "148:  mpz_mul(t2, private_key, r);    //t2 = d*r",
          "149:  mpz_add(t3, message, t2); //t3 = e+t2",
          "150:  mpz_clear(t2);",
          "151:  mpz_init(t2);",
          "152:  mpz_mod(t2, t3, curve->n); //t2 = t3 mod n",
          "153:  mpz_clear(t3);",
          "154:         mpz_init(t3);",
          "155:  mpz_mul(t3, t2, t1);  //t3 = t2 * t1",
          "156:  mpz_mod(s, t3, curve->n); //s = t3 mod n",
          "160:   mpz_t rem;",
          "161:   mpz_init(rem);",
          "162:   mpz_mod_ui(rem, Q->y, 2);",
          "164:   mpz_t s_mul_2;",
          "165:   mpz_init(s_mul_2);",
          "166:   mpz_mul_ui(s_mul_2, s, 2);",
          "168:   unsigned b = 0;",
          "169:   if (mpz_cmp(s_mul_2, curve->n) > 0) {",
          "170:     b = 1;",
          "171:   }",
          "172:   sig->v = mpz_get_ui(rem) ^ b ;",
          "174:   point_clear(Q);",
          "175:   mpz_clear(rem);",
          "176:   mpz_clear(s_mul_2);",
          "180:   mpz_t n_div_2;",
          "181:  mpz_init(n_div_2);",
          "182:         mpz_cdiv_q_ui(n_div_2, curve->n , 2);",
          "184:  if (mpz_cmp(s, n_div_2) > 0) {",
          "185:    mpz_t neg;",
          "186:    mpz_init(neg);",
          "187:    mpz_sub(neg, curve->n, s);",
          "189:    mpz_clear(s);",
          "190:    mpz_init(s);",
          "191:    mpz_set(s, neg);",
          "193:    mpz_clear(neg);",
          "194:  }",
          "196:  mpz_clear(n_div_2);",
          "198:  mpz_clear(t1);",
          "199:  mpz_clear(t2);",
          "200:  mpz_clear(t3);",
          "204:  mpz_set(sig->r, r);",
          "205:  mpz_set(sig->s, s);",
          "208:  mpz_clear(k);",
          "209:  mpz_clear(r);",
          "210:  mpz_clear(s);",
          "214: bool signature_verify(mpz_t message, signature sig, point public_key, domain_parameters curve)",
          "215: {",
          "217:  mpz_t one;mpz_init(one);",
          "218:  mpz_set_ui(one, 1);",
          "219:  if( mpz_cmp(sig->r,one) < 0 &&",
          "220:   mpz_cmp(curve->n,sig->r) <= 0 &&",
          "221:   mpz_cmp(sig->s,one) < 0 &&",
          "222:   mpz_cmp(curve->n,sig->s) <= 0)",
          "223:  {",
          "224:   mpz_clear(one);",
          "225:   return false;",
          "226:  }",
          "228:  mpz_clear(one);",
          "231:  mpz_t w;mpz_init(w);",
          "232:  mpz_t u1;mpz_init(u1);",
          "233:  mpz_t u2;mpz_init(u2);",
          "234:  mpz_t t;mpz_init(t);",
          "235:  mpz_t tt2;mpz_init(tt2);",
          "236:  point x = point_init();",
          "237:  point t1 = point_init();",
          "238:  point t2 = point_init();",
          "241:  number_theory_inverse(w, sig->s, curve->n);",
          "244:  mpz_mod(tt2, message, curve->n);",
          "245:  mpz_mul(t, tt2, w);",
          "246:  mpz_mod(u1, t, curve->n);",
          "249:  mpz_mul(t, sig->r, w);",
          "250:  mpz_mod(u2, t, curve->n);",
          "253:  point_multiplication(t1, u1, curve->G, curve);",
          "254:  point_multiplication(t2, u2, public_key, curve);",
          "255:  point_addition(x, t1, t2, curve);",
          "258:  bool result = mpz_cmp(sig->r, x->x) == 0 && !x->infinity;",
          "261:  point_clear(x);",
          "262:  point_clear(t1);",
          "263:  point_clear(t2);",
          "264:  mpz_clear(w);",
          "265:  mpz_clear(u1);",
          "266:  mpz_clear(u2);",
          "267:  mpz_clear(t);",
          "268:  mpz_clear(tt2);",
          "271:  return result;",
          "275: void signature_clear(signature sig)",
          "276: {",
          "277:  mpz_clear(sig->r);",
          "278:  mpz_clear(sig->s);",
          "279:  free(sig);",
          "",
          "[Added Lines]",
          "35: signature signature_init() {",
          "36:     signature sig;",
          "37:     sig = calloc(sizeof(struct signature_s), 1);",
          "38:     mpz_init(sig->r);",
          "39:     mpz_init(sig->s);",
          "40:     sig->v = 0;",
          "41:     return sig;",
          "45: void signature_print(signature sig) {",
          "47:     mpz_out_str(stdout, 10, sig->r);",
          "48:     printf(\",\\n\\t\");",
          "49:     mpz_out_str(stdout, 10, sig->s);",
          "54: void signature_set_str(signature sig, char *r, char *s, int base) {",
          "55:     mpz_set_str(sig->r, r, base);",
          "56:     mpz_set_str(sig->s, s, base);",
          "60: void signature_set_hex(signature sig, char *r, char *s) {",
          "61:     signature_set_str(sig, r, s, 16);",
          "65: void signature_set_ui(signature sig, unsigned long int r, unsigned long int s) {",
          "66:     mpz_set_ui(sig->r, r);",
          "67:     mpz_set_ui(sig->s, s);",
          "71: void signature_copy(signature R, signature sig) {",
          "72:     mpz_set(R->r, sig->r);",
          "73:     mpz_set(R->s, sig->s);",
          "78: bool signature_cmp(signature sig1, signature sig2) {",
          "79:     return !mpz_cmp(sig1->r, sig2->r) && !mpz_cmp(sig1->s, sig2->s);",
          "83: void signature_extract_public_key(point public_key, mpz_t private_key, domain_parameters curve) {",
          "84:     point_multiplication(public_key, private_key, curve->G, curve);",
          "88: void signature_sign(signature sig, mpz_t message, mpz_t private_key, domain_parameters curve) {",
          "91:     assert(mpz_sizeinbase(message, 2) <= mpz_sizeinbase(curve->n, 2));",
          "93:     point Q = point_init();",
          "96:     mpz_t k, x, r, t1, t2, t3, s, n_div_2, rem, neg, seed;",
          "97:     mpz_init(k); mpz_init(x); mpz_init(r); mpz_init(t1); mpz_init(t2); mpz_init(t3); mpz_init(s);",
          "98:     mpz_init(n_div_2); mpz_init(rem); mpz_init(neg); mpz_init(seed);",
          "100:     unsigned char *rand_char = (unsigned char *) malloc(32);",
          "102:     sgx_read_rand(rand_char, 32);",
          "104:     gmp_randstate_t r_state;",
          "106:     signature_sign_start:",
          "109:     sgx_read_rand(rand_char, 32);",
          "110: ;",
          "111:     mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);",
          "113:     mpz_mod(k, seed, curve->p);",
          "120:     point_multiplication(Q, k, curve->G, curve);",
          "121:     mpz_set(x, Q->x);",
          "124:     mpz_mod(r, x, curve->n);",
          "125:     if (!mpz_sgn(r))    //Start over if r=0, note haven't been tested memory might die :)",
          "126:         goto signature_sign_start;",
          "132:     mpz_invert(t1, k, curve->n);",
          "133:     mpz_mul(t2, private_key, r);    //t2 = d*r",
          "134:     mpz_add(t3, message, t2);    //t3 = e+t2",
          "135:     mpz_clear(t2); mpz_init(t2);",
          "136:     mpz_mod(t2, t3, curve->n);    //t2 = t3 mod n",
          "137:     mpz_clear(t3); mpz_init(t3);",
          "138:     mpz_mul(t3, t2, t1);        //t3 = t2 * t1",
          "139:     mpz_mod(s, t3, curve->n);    //s = t3 mod n",
          "143:     mpz_mod_ui(rem, Q->y, 2);",
          "144:     mpz_t s_mul_2;",
          "145:     mpz_init(s_mul_2);",
          "146:     mpz_mul_ui(s_mul_2, s, 2);",
          "148:     unsigned b = 0;",
          "149:     if (mpz_cmp(s_mul_2, curve->n) > 0) {",
          "150:         b = 1;",
          "151:     }",
          "152:     sig->v = mpz_get_ui(rem) ^ b;",
          "154:     mpz_cdiv_q_ui(n_div_2, curve->n, 2);",
          "156:     if (mpz_cmp(s, n_div_2) > 0) {",
          "157:         mpz_sub(neg, curve->n, s);",
          "158:         mpz_clear(s); mpz_init(s);",
          "159:         mpz_set(s, neg);",
          "160:     }",
          "163:     mpz_set(sig->r, r);",
          "164:     mpz_set(sig->s, s);",
          "166:     clean:",
          "168:     free(rand_char);",
          "169:     point_clear(Q);",
          "171:     mpz_clear(k); mpz_clear(r); mpz_clear(s); mpz_clear(x); mpz_clear(rem); mpz_clear(neg);",
          "172:     mpz_clear(t1); mpz_clear(t2); mpz_clear(t3); mpz_clear(seed); mpz_clear(n_div_2);",
          "173:     mpz_clear(s_mul_2);",
          "178: bool signature_verify(mpz_t message, signature sig, point public_key, domain_parameters curve) {",
          "180:     mpz_t one;",
          "181:     mpz_init(one);",
          "182:     mpz_set_ui(one, 1);",
          "185:     mpz_t w;",
          "186:     mpz_init(w);",
          "187:     mpz_t u1;",
          "188:     mpz_init(u1);",
          "189:     mpz_t u2;",
          "190:     mpz_init(u2);",
          "191:     mpz_t t;",
          "192:     mpz_init(t);",
          "193:     mpz_t tt2;",
          "194:     mpz_init(tt2);",
          "195:     point x = point_init();",
          "196:     point t1 = point_init();",
          "197:     point t2 = point_init();",
          "199:     bool result = false;",
          "202:     if (mpz_cmp(sig->r, one) < 0 &&",
          "203:         mpz_cmp(curve->n, sig->r) <= 0 &&",
          "204:         mpz_cmp(sig->s, one) < 0 &&",
          "205:         mpz_cmp(curve->n, sig->s) <= 0) {",
          "206:         goto clean;",
          "207:     }",
          "210:     number_theory_inverse(w, sig->s, curve->n);",
          "213:     mpz_mod(tt2, message, curve->n);",
          "214:     mpz_mul(t, tt2, w);",
          "215:     mpz_mod(u1, t, curve->n);",
          "218:     mpz_mul(t, sig->r, w);",
          "219:     mpz_mod(u2, t, curve->n);",
          "222:     point_multiplication(t1, u1, curve->G, curve);",
          "223:     point_multiplication(t2, u2, public_key, curve);",
          "224:     point_addition(x, t1, t2, curve);",
          "228:     result = mpz_cmp(sig->r, x->x) == 0 && !x->infinity;",
          "231:     clean:",
          "234:     point_clear(x);",
          "235:     point_clear(t1);",
          "236:     point_clear(t2);",
          "238:     mpz_clear(one);",
          "239:     mpz_clear(w);",
          "240:     mpz_clear(u1);",
          "241:     mpz_clear(u2);",
          "242:     mpz_clear(t);",
          "243:     mpz_clear(tt2);",
          "245:     return result;",
          "249: void signature_free(signature sig) {",
          "250:     mpz_clear(sig->r);",
          "251:     mpz_clear(sig->s);",
          "252:     free(sig);",
          "",
          "---------------"
        ],
        "secure_enclave/signature.h||secure_enclave/signature.h": [
          "File: secure_enclave/signature.h -> secure_enclave/signature.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: bool signature_cmp(signature sig1, signature sig2);",
          "62: void signature_sign(signature sig, mpz_t message, mpz_t private_key, domain_parameters curve);",
          "",
          "[Removed Lines]",
          "56: void signature_clear(signature sig);",
          "59: void signature_generate_key(point public_key, mpz_t private_key, domain_parameters curve);",
          "",
          "[Added Lines]",
          "56: void signature_free(signature sig);",
          "59: void signature_extract_public_key(point public_key, mpz_t private_key, domain_parameters curve);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "85590b1ee4afde624c75b923df34038f9090a762",
      "candidate_info": {
        "commit_hash": "85590b1ee4afde624c75b923df34038f9090a762",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/85590b1ee4afde624c75b923df34038f9090a762",
        "files": [
          "secure_enclave/AESUtils.c",
          "secure_enclave/AESUtils.h",
          "secure_enclave/secure_enclave.c"
        ],
        "message": "SKALE-3039",
        "before_after_code_files": [
          "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
          "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
          "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
            "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ],
          "candidate": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
            "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ]
        }
      },
      "candidate_diff": {
        "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c": [
          "File: secure_enclave/AESUtils.c -> secure_enclave/AESUtils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #include \"AESUtils.h\"",
          "37: #define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);",
          "",
          "[Removed Lines]",
          "33: sgx_aes_gcm_128bit_key_t AES_key;",
          "34: sgx_aes_gcm_128bit_key_t AES_DH_key;",
          "",
          "[Added Lines]",
          "33: uint8_t AES_key[2* BUF_LEN];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);",
          "79:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,",
          "80:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
          "81:                                                      NULL, 0,",
          "",
          "[Removed Lines]",
          "78:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len,",
          "",
          "[Added Lines]",
          "77:     sgx_status_t status = sgx_rijndael128GCM_encrypt(AES_key + BUF_LEN, (uint8_t*)message, len,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "124:         return -2;",
          "125:   }",
          "128:                                                    encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,",
          "129:                                                    (unsigned char*) message,",
          "130:                                                    encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
          "",
          "[Removed Lines]",
          "127:   sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_key,",
          "",
          "[Added Lines]",
          "126:   sgx_status_t status = sgx_rijndael128GCM_decrypt(AES_key + BUF_LEN,",
          "",
          "---------------"
        ],
        "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h": [
          "File: secure_enclave/AESUtils.h -> secure_enclave/AESUtils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifndef SGXD_AESUTILS_H",
          "25: #define SGXD_AESUTILS_H",
          "29: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen,",
          "30:                 unsigned char type, unsigned char exportable, uint64_t* resultLen);",
          "",
          "[Removed Lines]",
          "27: extern sgx_aes_gcm_128bit_key_t AES_key;",
          "",
          "[Added Lines]",
          "27: #define BUF_LEN 1024",
          "28: extern uint8_t AES_key[2* BUF_LEN] ;",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
          "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "291:     RANDOM_CHAR_BUF(SEK_raw, SGX_AESGCM_KEY_SIZE);",
          "293:     carray2Hex((uint8_t*) SEK_raw, SGX_AESGCM_KEY_SIZE, sek_hex);",
          "297:     sealHexSEK(errStatus, errString, encrypted_sek, enc_len, sek_hex);",
          "",
          "[Removed Lines]",
          "294:     memcpy(AES_key, SEK_raw, SGX_AESGCM_KEY_SIZE);",
          "",
          "[Added Lines]",
          "294:     memcpy(AES_key + BUF_LEN, SEK_raw, SGX_AESGCM_KEY_SIZE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "331:     uint64_t len;",
          "336:     SET_SUCCESS",
          "337:     clean:",
          "",
          "[Removed Lines]",
          "334:     hex2carray(aes_key_hex, &len, (uint8_t *) AES_key);",
          "",
          "[Added Lines]",
          "334:     hex2carray(aes_key_hex, &len, (uint8_t *) AES_key + BUF_LEN);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "349:     CHECK_STATE(sek_hex);",
          "351:     uint64_t len;",
          "355:     sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex);",
          "",
          "[Removed Lines]",
          "352:     hex2carray(sek_hex, &len, (uint8_t *) AES_key);",
          "",
          "[Added Lines]",
          "352:     hex2carray(sek_hex, &len, (uint8_t *) AES_key + BUF_LEN);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eaa8c60a87ab77262f83ff17bb127b96f4caabe0",
      "candidate_info": {
        "commit_hash": "eaa8c60a87ab77262f83ff17bb127b96f4caabe0",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/eaa8c60a87ab77262f83ff17bb127b96f4caabe0",
        "files": [
          "secure_enclave/AESUtils.c",
          "secure_enclave/AESUtils.h",
          "secure_enclave/secure_enclave.c"
        ],
        "message": "SKALE-3205",
        "before_after_code_files": [
          "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
          "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
          "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
            "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ],
          "candidate": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
            "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ]
        }
      },
      "candidate_diff": {
        "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c": [
          "File: secure_enclave/AESUtils.c -> secure_enclave/AESUtils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:     return status;",
          "87: }",
          "91:     if (!message) {",
          "92:         LOG_ERROR(\"Null message in AES_encrypt\");",
          "",
          "[Removed Lines]",
          "89: int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {",
          "",
          "[Added Lines]",
          "89: int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen,",
          "90:                 uint8_t *type, uint8_t* decryptable){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98:         return -2;",
          "99:     }",
          "102:   if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {",
          "103:       LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:     if (!type) {",
          "103:         LOG_ERROR(\"Null type in AES_encrypt\");",
          "104:         return -3;",
          "105:     }",
          "107:     if (!encr_message) {",
          "108:         LOG_ERROR(\"Null decryptable in AES_encrypt\");",
          "109:         return -4;",
          "110:     }",
          "",
          "---------------"
        ],
        "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h": [
          "File: secure_enclave/AESUtils.h -> secure_enclave/AESUtils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen,",
          "31:                 unsigned char type, unsigned char decryptable, uint64_t* resultLen);",
          "37: void derive_DH_Key();",
          "",
          "[Removed Lines]",
          "32: int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;",
          "34: int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen);",
          "35: int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;",
          "",
          "[Added Lines]",
          "32: int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen,",
          "33:                 uint8_t *type, uint8_t* decryptable) ;",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
          "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "424:                              ECDSA, NON_DECRYPTABLE, enc_len);",
          "425:     CHECK_STATUS(\"ecdsa private key encryption failed\");",
          "429:     CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");",
          "",
          "[Removed Lines]",
          "427:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);",
          "",
          "[Added Lines]",
          "427:     uint8_t type = 0;",
          "428:     uint8_t decryptable = 0;",
          "430:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN, &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "454:     CHECK_STATE(pub_key_x);",
          "455:     CHECK_STATE(pub_key_y);",
          "458:     CHECK_STATUS2(\"AES_decrypt failed with status %d\");",
          "460:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';",
          "",
          "[Removed Lines]",
          "457:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
          "",
          "[Added Lines]",
          "460:     uint8_t type = 0;",
          "461:     uint8_t decryptable = 0;",
          "463:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN,",
          "464:                              &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "533:     mpz_init(msgMpz);",
          "534:     signature sign = signature_init();",
          "538:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
          "",
          "[Removed Lines]",
          "536:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
          "",
          "[Added Lines]",
          "543:     uint8_t type = 0;",
          "544:     uint8_t decryptable = 0;",
          "547:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN,",
          "548:                              &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "614:     if (status != 0) {",
          "",
          "[Removed Lines]",
          "612:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);",
          "",
          "[Added Lines]",
          "624:     uint8_t type = 0;",
          "625:     uint8_t decryptable = 0;",
          "627:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072,",
          "628:                              &type, &decryptable);",
          "630:     if (decryptable != DECRYPTABLE) {",
          "632:         snprintf(errString, BUF_LEN, \"Key is not exportable\");",
          "633:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "654:     SAFE_CHAR_BUF(decryptedKey, BUF_LEN);",
          "658:     CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");",
          "",
          "[Removed Lines]",
          "656:     status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);",
          "",
          "[Added Lines]",
          "677:     uint8_t type = 0;",
          "678:     uint8_t decryptable = 0;",
          "680:     status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN,",
          "681:                          &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "697:     SAFE_CHAR_BUF(key, BUF_LEN);SAFE_CHAR_BUF(sig, BUF_LEN);",
          "701:     CHECK_STATUS(\"AES decrypt failed\")",
          "",
          "[Removed Lines]",
          "699:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key, BUF_LEN);",
          "",
          "[Added Lines]",
          "724:     uint8_t type = 0;",
          "725:     uint8_t decryptable = 0;",
          "727:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key, BUF_LEN, &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "748:     SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);",
          "750:     status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,",
          "753:     CHECK_STATUS(\"aes decrypt dkg poly failed\");",
          "",
          "[Removed Lines]",
          "751:                          DKG_BUFER_LENGTH);",
          "",
          "[Added Lines]",
          "778:     uint8_t type = 0;",
          "779:     uint8_t decryptable = 0;",
          "782:                          DKG_BUFER_LENGTH, &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "777:     CHECK_STATE(encrypted_dkg_secret);",
          "778:     CHECK_STATE(decrypted_dkg_secret);",
          "780:     int status = AES_decrypt(encrypted_dkg_secret, enc_len, (char *) decrypted_dkg_secret,",
          "783:     CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\")",
          "",
          "[Removed Lines]",
          "781:                              3072);",
          "",
          "[Added Lines]",
          "811:     uint8_t  type;",
          "812:     uint8_t  decryptable;",
          "815:                              3072, &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "800:     memset(getThreadLocalDecryptedDkgPoly(), 0, DKG_BUFER_LENGTH);",
          "802:     int status = AES_decrypt(encrypted_poly, enc_len, (char *) getThreadLocalDecryptedDkgPoly(),",
          "805:     CHECK_STATUS2(\"sgx_unseal_data - encrypted_poly failed with status %d\")",
          "",
          "[Removed Lines]",
          "803:                              DKG_BUFER_LENGTH);",
          "",
          "[Added Lines]",
          "836:     uint8_t type = 0;",
          "837:     uint8_t decryptable = 0;",
          "840:                              DKG_BUFER_LENGTH, &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "837:     CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");",
          "841:     skey[ECDSA_SKEY_LEN - 1] = 0;",
          "",
          "[Removed Lines]",
          "839:     status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);",
          "",
          "[Added Lines]",
          "876:     uint8_t type = 0;",
          "877:     uint8_t decryptable = 0;",
          "879:     status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN, &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "890:     SAFE_CHAR_BUF(decrypted_dkg_secret, DKG_MAX_SEALED_LEN);",
          "892:     int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret,",
          "895:     CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\");",
          "",
          "[Removed Lines]",
          "893:                              DKG_MAX_SEALED_LEN);",
          "",
          "[Added Lines]",
          "932:     uint8_t type = 0;",
          "933:     uint8_t decryptable = 0;",
          "936:                              DKG_MAX_SEALED_LEN, &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "919:     mpz_t s;",
          "920:     mpz_init(s);",
          "924:     CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");",
          "",
          "[Removed Lines]",
          "922:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
          "",
          "[Added Lines]",
          "965:     uint8_t type = 0;",
          "966:     uint8_t decryptable = 0;",
          "968:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN,",
          "969:                              &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "978:     mpz_t bls_key;",
          "979:     mpz_init(bls_key);",
          "983:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
          "985:     skey[ECDSA_SKEY_LEN - 1] = 0;",
          "",
          "[Removed Lines]",
          "982:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);",
          "",
          "[Added Lines]",
          "1028:     uint8_t type = 0;",
          "1029:     uint8_t decryptable = 0;",
          "1032:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN,",
          "1033:                              &type, &decryptable);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1039:     strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);",
          "1040:     key_share[BLS_KEY_LENGTH - 1] = 0;",
          "1044:     CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");",
          "",
          "[Removed Lines]",
          "1042:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);",
          "",
          "[Added Lines]",
          "1093:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, DECRYPTABLE, enc_bls_key_len);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1066:     SAFE_CHAR_BUF(skey_hex, BUF_LEN);",
          "1070:     CHECK_STATUS2(\"AES decrypt failed %d\");",
          "",
          "[Removed Lines]",
          "1068:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);",
          "",
          "[Added Lines]",
          "1119:     uint8_t type = 0;",
          "1120:     uint8_t decryptable = 0;",
          "1124:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN,",
          "1125:                              &type, &decryptable);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "08dd658d06c1ccbaddc728afa6cd298d2c48ee3b",
      "candidate_info": {
        "commit_hash": "08dd658d06c1ccbaddc728afa6cd298d2c48ee3b",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/08dd658d06c1ccbaddc728afa6cd298d2c48ee3b",
        "files": [
          "ECDSACrypto.cpp",
          "SGXWalletServer.cpp",
          "ServerDataChecker.cpp",
          "secure_enclave/secure_enclave.c",
          "sgxwallet_common.h",
          "testw.cpp"
        ],
        "message": "SKALE-1795 Comment some checks",
        "before_after_code_files": [
          "ECDSACrypto.cpp||ECDSACrypto.cpp",
          "SGXWalletServer.cpp||SGXWalletServer.cpp",
          "ServerDataChecker.cpp||ServerDataChecker.cpp",
          "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
          "sgxwallet_common.h||sgxwallet_common.h",
          "testw.cpp||testw.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
            "testw.cpp||testw.cpp"
          ],
          "candidate": [
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
            "testw.cpp||testw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "ECDSACrypto.cpp||ECDSACrypto.cpp": [
          "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include \"ECDSACrypto.h\"",
          "6: #include \"BLSCrypto.h\"",
          "7: #include \"sgxwallet.h\"",
          "10: #include <gmp.h>",
          "11: #include <random>",
          "",
          "[Removed Lines]",
          "8: #include <iostream>",
          "",
          "[Added Lines]",
          "9: #include \"RPCException.h\"",
          "11: #include <iostream>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "21:   uint32_t enc_len = 0;",
          "23:   status = generate_ecdsa_key(eid, &err_status, errMsg, encr_pr_key, &enc_len, pub_key_x, pub_key_y );",
          "24:   std::vector<std::string> keys(3);",
          "25:   std::cerr << \"account key is \" << errMsg << std::endl;",
          "26:   char *hexEncrKey = (char *) calloc(2*BUF_LEN, 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26:   if ( err_status != 0 ){",
          "27:     std::cerr << \"RPCException thrown\" << std::endl;",
          "28:     throw RPCException(-666, errMsg) ;",
          "29:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:   hex2carray(encryptedKeyHex, &enc_len, encr_pr_key);",
          "72:   status = get_public_ecdsa_key(eid, &err_status, errMsg, encr_pr_key, enc_len, pub_key_x, pub_key_y );",
          "73:   std::string pubKey = std::string(pub_key_x) + std::string(pub_key_y);",
          "74:   std::cerr << \"err str \" << errMsg << std::endl;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79:   if ( err_status != 0){",
          "80:     throw RPCException(-666, errMsg) ;",
          "81:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "100:   std::cerr << \"encrypted len\" << dec_len << std::endl;",
          "102:   status = ecdsa_sign1(eid, &err_status, errMsg, encr_key, ECDSA_ENCR_LEN, (unsigned char*)hashHex, signature_r, signature_s, &signature_v, base );",
          "104:   std::cerr << \"signature r in  ecdsa_sign_hash \"<< signature_r << std::endl;",
          "105:   std::cerr << \"signature s in  ecdsa_sign_hash \"<< signature_s << std::endl;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112:   if ( err_status != 0){",
          "113:     throw RPCException(-666, errMsg ) ;",
          "114:   }",
          "",
          "---------------"
        ],
        "SGXWalletServer.cpp||SGXWalletServer.cpp": [
          "File: SGXWalletServer.cpp -> SGXWalletServer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: int init_server() {",
          "53:   s = new SGXWalletServer(*hs,",
          "54:                       JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)",
          "",
          "[Removed Lines]",
          "52:   hs = new HttpServer(1026);",
          "",
          "[Added Lines]",
          "52:   hs = new HttpServer(1025);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:     result[\"encryptedKeyShare\"] = \"\";",
          "75:     try {",
          "77:         char *encryptedKeyShareHex = encryptBLSKeyShare2Hex(&errStatus, errMsg, _keyShare.c_str());",
          "79:         if (encryptedKeyShareHex == nullptr) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76:         if ( !checkName(_keyShare, \"BLS_KEY\")){",
          "77:           throw RPCException(INVALID_POLY_NAME, \"Invalid BLSKey name\");",
          "78:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "115:     try {",
          "117:     } catch (RPCException _e) {",
          "118:         result[\"status\"] = _e.status;",
          "119:         result[\"errorMessage\"] = _e.errString;",
          "",
          "[Removed Lines]",
          "116:         value = readFromDb(keyShareName);",
          "",
          "[Added Lines]",
          "118:       if ( !checkName(keyShareName, \"BLS_KEY\")){",
          "119:         throw RPCException(INVALID_POLY_NAME, \"Invalid BLSKey name\");",
          "120:       }",
          "122:       value = readFromDb(keyShareName);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "169:     try {",
          "170:         keys = gen_ecdsa_key();",
          "171:         if (keys.size() == 0 ) {",
          "173:         }",
          "175:         std::cerr << \"encr key length is\" << keys.at(0).length() << std::endl;",
          "",
          "[Removed Lines]",
          "172:             throw RPCException(UNKNOWN_ERROR, \"\");",
          "",
          "[Added Lines]",
          "178:             throw RPCException(UNKNOWN_ERROR, \"key was not generated\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "434:     if( !check_n_t(n, t) || ind > n || ind < 0){",
          "435:       throw RPCException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");",
          "436:     }",
          "",
          "[Removed Lines]",
          "437:     if ( !checkHex(SecretShare, SECRET_SHARE_NUM_BYTES)){",
          "438:       throw RPCException(INVALID_HEX, \"Invalid Secret share\");",
          "439:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "472:       result[\"errorMessage\"] = \"wrong length of secret shares\";",
          "473:       return result;",
          "474:     }",
          "478:     if ( !checkName(polyName, \"POLY\")){",
          "479:       throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "480:     }",
          "481:     if ( !checkName(BLSKeyName, \"BLS_KEY\")){",
          "483:     }",
          "484:     std::vector<std::string> sshares_vect;",
          "485:     std::cerr << \"sshares are \" << SecretShare << std::endl;",
          "486:     char sshares[192 * n + 1];",
          "487:     for ( int i = 0; i < n ; i++){",
          "488:       std::string cur_share = SecretShare.substr(192*i, 192*i + 192);",
          "493:       sshares_vect.push_back(cur_share);",
          "",
          "[Removed Lines]",
          "475:     if ( !checkECDSAKeyName(EthKeyName)){",
          "476:       throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "477:     }",
          "482:       throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "489:       if ( !checkHex(SecretShare, SECRET_SHARE_NUM_BYTES)){",
          "490:         throw RPCException(INVALID_HEX, \"Invalid Secret share\");",
          "491:       }",
          "",
          "[Added Lines]",
          "488:       throw RPCException(INVALID_POLY_NAME, \"Invalid BLS key name\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "533:     try {",
          "534:       if ( !checkName(BLSKeyName, \"BLS_KEY\")){",
          "536:       }",
          "537:       std::shared_ptr<std::string> encryptedKeyHex_ptr = readFromDb(BLSKeyName);",
          "538:       std::cerr << \"encr_bls_key_share is \" << *encryptedKeyHex_ptr << std::endl;",
          "",
          "[Removed Lines]",
          "535:         throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "",
          "[Added Lines]",
          "541:         throw RPCException(INVALID_POLY_NAME, \"Invalid BLSKey name\");",
          "",
          "---------------"
        ],
        "ServerDataChecker.cpp||ServerDataChecker.cpp": [
          "File: ServerDataChecker.cpp -> ServerDataChecker.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "132:         return false;",
          "133:     }",
          "136:         return false;",
          "137:     }",
          "138:     if (parts.at(4).length() > 5 || parts.at(4).length() < 1){",
          "139:         return false;",
          "140:     }",
          "142:         return false;",
          "143:     }",
          "145:     mpz_t num;",
          "146:     mpz_init(num);",
          "149:         mpz_clear(num);",
          "150:         return false;",
          "151:     }",
          "",
          "[Removed Lines]",
          "135:     if ( parts.at(2).length() > 64 || parts.at(2).length() < 1){",
          "141:     if ( parts.at(6).length() > 64 || parts.at(6).length() < 1){",
          "148:     if ( mpz_set_str(num, parts.at(2).c_str(), 16) == -1){",
          "",
          "[Added Lines]",
          "135:     if ( parts.at(2).length() > 78 || parts.at(2).length() < 1){",
          "141:     if ( parts.at(6).length() > 78 || parts.at(6).length() < 1){",
          "148:     if ( mpz_set_str(num, parts.at(2).c_str(), 10) == -1){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "159:     mpz_clear(num);",
          "160:     mpz_init(num);",
          "163:         mpz_clear(num);",
          "164:         return false;",
          "165:     }",
          "",
          "[Removed Lines]",
          "162:     if ( mpz_set_str(num, parts.at(6).c_str(),16) == -1){",
          "",
          "[Added Lines]",
          "162:     if ( mpz_set_str(num, parts.at(6).c_str(),10) == -1){",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
          "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c"
        ],
        "sgxwallet_common.h||sgxwallet_common.h": [
          "File: sgxwallet_common.h -> sgxwallet_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: #define INVALID_ECDSA_KEY_NAME -20",
          "55: #define INVALID_HEX -21",
          "59: #define WALLETDB_NAME  \"test_sgxwallet.db\"//\"sgxwallet.db\" //",
          "",
          "[Removed Lines]",
          "57: #define SGX_ERROR -666;",
          "",
          "[Added Lines]",
          "57: #define SGX_ENCLAVE_ERROR -666;",
          "",
          "---------------"
        ],
        "testw.cpp||testw.cpp": [
          "File: testw.cpp -> testw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "718: using namespace jsonrpc;",
          "719: using namespace std;",
          "721: TEST_CASE(\"API test\", \"[api_test]\") {",
          "722:     cerr << \"API test started\" << endl;",
          "723:     init_all();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "721: TEST_CASE(\"BLS_DKG test\", \"[bls_dkg]\") {",
          "722:   cerr << \"Server inited\" << endl;",
          "723:   HttpClient client(\"http://localhost:1026\");",
          "724:   StubClient c(client, JSONRPC_CLIENT_V2);",
          "725:   cerr << \"Client inited\" << endl;",
          "727:   int n = 2, t = 2;",
          "728:   Json::Value EthKeys[n];",
          "729:   Json::Value Polys[n];",
          "730:   Json::Value VerifVects[n];",
          "731:   std::vector <std::string> pub_keys;",
          "732:   for ( uint8_t i = 0; i < n; i++){",
          "733:     EthKeys[i] = c.generateECDSAKey();",
          "734:     std::string polyName = \"POLY:SCHAIN_ID:1:NODE_ID:\" + std::to_string(i) + \"DKG_ID:0\";",
          "735:     Polys[i] = c.generateDKGPoly(polyName, t);",
          "736:     VerifVects[i] = c.getVerificationVector(polyName, n, t);",
          "738:   }",
          "741: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "728:     cerr << \"Server inited\" << endl;",
          "730:     StubClient c(client, JSONRPC_CLIENT_V2);",
          "732:     cerr << \"Client inited\" << endl;",
          "",
          "[Removed Lines]",
          "729:     HttpClient client(\"http://localhost:1026\");",
          "",
          "[Added Lines]",
          "751:     HttpClient client(\"http://localhost:1025\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "765:         cout<<c.getPublicECDSAKey(\"NEK:697fadfc597bdbfae9ffb7412b80939e848c9c2fec2657bb2122b6d0d4a0dca8\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "802:     } catch (JsonRpcException &e) {",
          "803:         cerr << e.what() << endl;",
          "",
          "[Removed Lines]",
          "800:      cout << c.ComplaintResponse(\"POLY:SCHAIN_ID:1:NODE_ID:1:DKG_ID:1\", 0);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
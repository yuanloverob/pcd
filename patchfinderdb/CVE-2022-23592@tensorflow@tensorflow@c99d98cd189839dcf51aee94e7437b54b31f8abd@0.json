{
  "cve_id": "CVE-2022-23592",
  "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "c99d98cd189839dcf51aee94e7437b54b31f8abd",
  "patch_info": {
    "commit_hash": "c99d98cd189839dcf51aee94e7437b54b31f8abd",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/c99d98cd189839dcf51aee94e7437b54b31f8abd",
    "files": [
      "tensorflow/core/graph/graph.cc"
    ],
    "message": "Handle invalid inputs instead of crashing.\n\nPiperOrigin-RevId: 409549744\nChange-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24",
    "before_after_code_files": [
      "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
      "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "222:       const auto& node_t = node->def().experimental_type();",
      "223:       if (node_t.type_id() != TFT_UNSET) {",
      "224:         int ix = input_idx[i];",
      "229:         input_types.emplace_back(node_t.args(ix));",
      "230:       } else {",
      "231:         input_types.emplace_back(*no_type);",
      "",
      "[Removed Lines]",
      "225:         DCHECK(ix < node_t.args_size())",
      "226:             << \"input \" << i << \" should have an output \" << ix",
      "227:             << \" but instead only has \" << node_t.args_size()",
      "228:             << \" outputs: \" << node_t.DebugString();",
      "",
      "[Added Lines]",
      "225:         if (ix >= node_t.args_size()) {",
      "226:           LOG(WARNING) << name() << \" has bad type information: input \" << i",
      "227:                        << \" should have an output \" << ix",
      "228:                        << \" but instead only has \" << node_t.args_size()",
      "229:                        << \" outputs: \" << node_t.DebugString()",
      "230:                        << \"\\nThis indicates either \"",
      "231:                           \"a bug in op registration or a corrupted graph.\";",
      "232:           ClearTypeInfo();",
      "233:           return;",
      "234:         }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4ca885b43f5fea465def250602660af213e1ccf8",
      "candidate_info": {
        "commit_hash": "4ca885b43f5fea465def250602660af213e1ccf8",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/4ca885b43f5fea465def250602660af213e1ccf8",
        "files": [
          "tensorflow/core/framework/full_type_inference_util.cc",
          "tensorflow/core/framework/full_type_inference_util.h",
          "tensorflow/core/framework/full_type_inference_util_test.cc",
          "tensorflow/core/framework/op_def_builder.h",
          "tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc"
        ],
        "message": "Improve the robustness of the ReplicateIdenticalInputs utility. Change their contract to accept a list of singular types, rather than list of records: that's because each edge represents a particular op's output, rather than all the outputs.\n\nPiperOrigin-RevId: 406150039\nChange-Id: I4aacb098de11d4752507b9c3c3bf3f1a77474a60",
        "before_after_code_files": [
          "tensorflow/core/framework/full_type_inference_util.cc||tensorflow/core/framework/full_type_inference_util.cc",
          "tensorflow/core/framework/full_type_inference_util.h||tensorflow/core/framework/full_type_inference_util.h",
          "tensorflow/core/framework/full_type_inference_util_test.cc||tensorflow/core/framework/full_type_inference_util_test.cc",
          "tensorflow/core/framework/op_def_builder.h||tensorflow/core/framework/op_def_builder.h",
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ],
          "candidate": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/full_type_inference_util.cc||tensorflow/core/framework/full_type_inference_util.cc": [
          "File: tensorflow/core/framework/full_type_inference_util.cc -> tensorflow/core/framework/full_type_inference_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: namespace full_type {",
          "26: ForwardTypeInferenceFn ReplicateInputs(int n) {",
          "27:   return [n](const std::vector<std::reference_wrapper<const FullTypeDef>>&",
          "28:                  input_types) {",
          "33:       }",
          "34:     }",
          "35:     return ret_type;",
          "36:   };",
          "37: }",
          "39: ForwardTypeInferenceFn ReplicateIdenticalInputs() {",
          "40:   return [](const std::vector<std::reference_wrapper<const FullTypeDef>>&",
          "41:                 input_types) -> StatusOr<FullTypeDef> {",
          "54:       }",
          "55:     }",
          "56:     return ret_type;",
          "57:   };",
          "",
          "[Removed Lines]",
          "29:     FullTypeDef ret_type = input_types[0].get();",
          "30:     if (ret_type.type_id() != TFT_UNSET) {",
          "31:       for (int i = 1; i < n; i++) {",
          "42:     FullTypeDef ret_type = input_types[0].get();",
          "43:     if (ret_type.type_id() != TFT_UNSET) {",
          "44:       for (int i = 1; i < input_types.size(); i++) {",
          "45:         if (ret_type.args(0).type_id() !=",
          "46:                input_types[i].get().args(0).type_id()) {",
          "47:           return Status(",
          "48:               error::INVALID_ARGUMENT,",
          "49:               absl::StrCat(\"expected identical input types, but input \", i,",
          "50:                            \" differed from 0:\\n\",",
          "51:                            input_types[i].get().DebugString(), \"\\nvs.\\n\",",
          "52:                            input_types[i].get().DebugString()));",
          "53:         }",
          "",
          "[Added Lines]",
          "30:     DCHECK(input_types.size() == 1)",
          "31:         << \"expected exactly one input, got \" << input_types.size();",
          "33:     const auto& in_type = input_types[0].get();",
          "34:     FullTypeDef ret_type;",
          "35:     if (in_type.type_id() != TFT_UNSET) {",
          "36:       ret_type.set_type_id(TFT_PRODUCT);",
          "37:       for (int i = 0; i < n; i++) {",
          "49:     DCHECK(!input_types.empty());",
          "51:     FullTypeDef ret_type;",
          "52:     int first_known = -1;",
          "53:     FullTypeDef const* first_known_t = nullptr;",
          "54:     for (int i = 0; i < input_types.size(); i++) {",
          "55:       const auto& t = input_types[i].get();",
          "57:       if (t.type_id() == TFT_UNSET) {",
          "58:         continue;",
          "59:       }",
          "61:       if (first_known < 0) {",
          "62:         first_known = i;",
          "63:         first_known_t = &t;",
          "65:         continue;",
          "69:       if (first_known_t->type_id() != t.type_id()) {",
          "70:         return Status(",
          "71:             error::INVALID_ARGUMENT,",
          "72:             absl::StrCat(\"expected identical input types, but input \", i,",
          "73:                          \" differed from \", first_known, \":\\n\", t.DebugString(),",
          "74:                          \"\\nvs.\\n\", first_known_t->DebugString()));",
          "75:       }",
          "76:     }",
          "78:     if (first_known >= 0) {",
          "79:       ret_type.set_type_id(TFT_PRODUCT);",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_inference_util.h||tensorflow/core/framework/full_type_inference_util.h": [
          "File: tensorflow/core/framework/full_type_inference_util.h -> tensorflow/core/framework/full_type_inference_util.h"
        ],
        "tensorflow/core/framework/full_type_inference_util_test.cc||tensorflow/core/framework/full_type_inference_util_test.cc": [
          "File: tensorflow/core/framework/full_type_inference_util_test.cc -> tensorflow/core/framework/full_type_inference_util_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: TEST(ReplicateInputs, Default) {",
          "28:   FullTypeDef t;",
          "32:   const auto ret = ReplicateInputs()({t});",
          "33:   TF_EXPECT_OK(ret.status());",
          "",
          "[Removed Lines]",
          "29:   t.set_type_id(TFT_PRODUCT);",
          "30:   t.add_args()->set_type_id(TFT_ARRAY);",
          "",
          "[Added Lines]",
          "29:   t.set_type_id(TFT_ARRAY);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41: TEST(ReplicateInputs, Duplicate) {",
          "42:   FullTypeDef t;",
          "46:   const auto ret = ReplicateInputs(2)({t});",
          "47:   TF_EXPECT_OK(ret.status());",
          "",
          "[Removed Lines]",
          "43:   t.set_type_id(TFT_PRODUCT);",
          "44:   t.add_args()->set_type_id(TFT_ARRAY);",
          "",
          "[Added Lines]",
          "42:   t.set_type_id(TFT_ARRAY);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "56: TEST(ReplicateInputs, Unset) {",
          "57:   FullTypeDef t;",
          "60:   const auto ret = ReplicateInputs()({t});",
          "61:   TF_EXPECT_OK(ret.status());",
          "",
          "[Removed Lines]",
          "58:   t.set_type_id(TFT_UNSET);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "67: TEST(ReplicateIdenticalInputs, Single) {",
          "68:   FullTypeDef t;",
          "72:   const auto ret = ReplicateIdenticalInputs()({t});",
          "73:   TF_EXPECT_OK(ret.status());",
          "",
          "[Removed Lines]",
          "69:   t.set_type_id(TFT_PRODUCT);",
          "70:   t.add_args()->set_type_id(TFT_ARRAY);",
          "",
          "[Added Lines]",
          "66:   t.set_type_id(TFT_ARRAY);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "81: TEST(ReplicateIdenticalInputs, Double) {",
          "82:   FullTypeDef t;",
          "86:   const auto ret = ReplicateIdenticalInputs()({t, t});",
          "87:   TF_EXPECT_OK(ret.status());",
          "",
          "[Removed Lines]",
          "83:   t.set_type_id(TFT_PRODUCT);",
          "84:   t.add_args()->set_type_id(TFT_ARRAY);",
          "",
          "[Added Lines]",
          "79:   t.set_type_id(TFT_ARRAY);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "103:   EXPECT_EQ(rt.type_id(), TFT_UNSET);",
          "104: }",
          "107:   FullTypeDef t1;",
          "111:   FullTypeDef t2;",
          "115:   const auto ret = ReplicateIdenticalInputs()({t1, t2});",
          "116:   EXPECT_FALSE(ret.status().ok());",
          "",
          "[Removed Lines]",
          "106: TEST(ReplicateIdenticalInputs, RejectsMismatched) {",
          "108:   t1.set_type_id(TFT_PRODUCT);",
          "109:   t1.add_args()->set_type_id(TFT_ARRAY);",
          "112:   t2.set_type_id(TFT_PRODUCT);",
          "113:   t2.add_args()->set_type_id(TFT_TENSOR);",
          "",
          "[Added Lines]",
          "101: TEST(ReplicateIdenticalInputs, UnsetComponents) {",
          "102:   FullTypeDef t1;",
          "103:   FullTypeDef t2;",
          "105:   const auto ret = ReplicateIdenticalInputs()({t1, t2});",
          "106:   TF_EXPECT_OK(ret.status());",
          "108:   const FullTypeDef& rt = ret.ValueOrDie();",
          "109:   EXPECT_EQ(rt.type_id(), TFT_UNSET);",
          "110: }",
          "112: TEST(ReplicateIdenticalInputs, UsesPartialInfo_FirstUnknown) {",
          "113:   FullTypeDef t1;",
          "114:   FullTypeDef t2;",
          "115:   t2.set_type_id(TFT_ARRAY);",
          "117:   const auto ret = ReplicateIdenticalInputs()({t1, t2});",
          "118:   TF_EXPECT_OK(ret.status());",
          "120:   const FullTypeDef& rt = ret.ValueOrDie();",
          "121:   EXPECT_EQ(rt.type_id(), TFT_PRODUCT);",
          "122:   ASSERT_EQ(rt.args_size(), 1);",
          "123:   EXPECT_EQ(rt.args(0).type_id(), TFT_ARRAY);",
          "124: }",
          "126: TEST(ReplicateIdenticalInputs, UsesPartialInfo_SecondUnknown) {",
          "128:   t1.set_type_id(TFT_ARRAY);",
          "129:   FullTypeDef t2;",
          "131:   const auto ret = ReplicateIdenticalInputs()({t1, t2});",
          "132:   TF_EXPECT_OK(ret.status());",
          "134:   const FullTypeDef& rt = ret.ValueOrDie();",
          "135:   EXPECT_EQ(rt.type_id(), TFT_PRODUCT);",
          "136:   ASSERT_EQ(rt.args_size(), 1);",
          "137:   EXPECT_EQ(rt.args(0).type_id(), TFT_ARRAY);",
          "138: }",
          "140: TEST(ReplicateIdenticalInputs, RejectsMismatched) {",
          "141:   FullTypeDef t1;",
          "142:   t1.set_type_id(TFT_ARRAY);",
          "144:   t2.set_type_id(TFT_TENSOR);",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/op_def_builder.h||tensorflow/core/framework/op_def_builder.h": [
          "File: tensorflow/core/framework/op_def_builder.h -> tensorflow/core/framework/op_def_builder.h"
        ],
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include <vector>",
          "21: #include \"absl/container/flat_hash_map.h\"",
          "22: #include \"tensorflow/core/framework/graph.pb.h\"",
          "23: #include \"tensorflow/core/framework/node_def.pb.h\"",
          "24: #include \"tensorflow/core/framework/node_properties.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "187:   }",
          "189:   std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);",
          "190:   for (const auto& edge : in_edges_) {",
          "191:     if (edge->IsControlEdge()) {",
          "192:       continue;",
          "193:     }",
          "194:     DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();",
          "196:   }",
          "",
          "[Removed Lines]",
          "195:     input_nodes.at(edge->dst_input()) = edge->src();",
          "",
          "[Added Lines]",
          "191:   std::vector<int> input_idx(props_->input_types.size(), 0);",
          "197:     int i = edge->dst_input();",
          "198:     input_nodes.at(i) = edge->src();",
          "199:     input_idx.at(i) = edge->src_output();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:     }",
          "208:   }",
          "210:   std::vector<std::reference_wrapper<const FullTypeDef>> input_types;",
          "212:     if (node->def().has_experimental_type()) {",
          "214:     } else {",
          "216:       ClearTypeInfo();",
          "",
          "[Removed Lines]",
          "211:   for (const auto* node : input_nodes) {",
          "213:       input_types.emplace_back(node->def().experimental_type());",
          "",
          "[Added Lines]",
          "214:   static FullTypeDef* no_type = new FullTypeDef();",
          "217:   for (int i = 0; i < input_nodes.size(); i++) {",
          "218:     const auto* node = input_nodes[i];",
          "220:       const auto& node_t = node->def().experimental_type();",
          "221:       if (node_t.type_id() != TFT_UNSET) {",
          "222:         int ix = input_idx[i];",
          "223:         DCHECK(ix < node_t.args_size())",
          "224:             << \"input \" << i << \" should have an output \" << ix",
          "225:             << \" but instead only has \" << node_t.args_size()",
          "226:             << \" outputs: \" << node_t.DebugString();",
          "227:         input_types.emplace_back(node_t.args(ix));",
          "228:       } else {",
          "229:         input_types.emplace_back(*no_type);",
          "230:       }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "539:                                    : Node::GetNodeClassForOp(node_def.op());",
          "541:   if (op_reg_data->type_ctor != nullptr) {",
          "542:     const auto ctor_type =",
          "543:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
          "544:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "545:     if (ctor_typedef.type_id() != TFT_UNSET) {",
          "547:     }",
          "548:   }",
          "550:   Node* node = AllocateNode(std::make_shared<NodeProperties>(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "559:     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
          "566:   } else {",
          "567:     VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc": [
          "File: tensorflow/core/graph/node_builder_test.cc -> tensorflow/core/graph/node_builder_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "127:     .SetForwardTypeFn(",
          "128:         [](const std::vector<std::reference_wrapper<const FullTypeDef>>&",
          "129:                input_types) {",
          "132:           } else {",
          "135:             mock.add_args()->set_type_id(TFT_ARRAY);",
          "137:           }",
          "138:         });",
          "140: TEST(NodeBuilderTest, FwdTypeInferenceBasicType) {",
          "",
          "[Removed Lines]",
          "130:           if (input_types[0].get().args(0).type_id() == TFT_TENSOR) {",
          "131:             return input_types[0].get();",
          "133:             FullTypeDef mock;",
          "134:             mock.set_type_id(TFT_PRODUCT);",
          "136:             return mock;",
          "",
          "[Added Lines]",
          "130:           FullTypeDef mock;",
          "131:           mock.set_type_id(TFT_PRODUCT);",
          "132:           if (input_types[0].get().type_id() == TFT_TENSOR) {",
          "133:             mock.add_args()->set_type_id(TFT_TENSOR);",
          "137:           return mock;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "10817842a7e1f3ece0da5eb9338e1abbb0828739",
      "candidate_info": {
        "commit_hash": "10817842a7e1f3ece0da5eb9338e1abbb0828739",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/10817842a7e1f3ece0da5eb9338e1abbb0828739",
        "files": [
          "tensorflow/core/framework/BUILD",
          "tensorflow/core/framework/node_properties.h",
          "tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/graph.h",
          "tensorflow/core/graph/node_builder.cc"
        ],
        "message": "Cleanup: move type construction and inference from NodeBuilder::Finalize into Graph::AddNode and Graph.:AddEdge. This allows type information to be more reliably created, especially when new nodes are added by graph transformations.\n\nPiperOrigin-RevId: 402309816\nChange-Id: Ife2ff3f888527ee4f2a7c45a8b40a0f4556ddb82",
        "before_after_code_files": [
          "tensorflow/core/framework/node_properties.h||tensorflow/core/framework/node_properties.h",
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/graph.h||tensorflow/core/graph/graph.h",
          "tensorflow/core/graph/node_builder.cc||tensorflow/core/graph/node_builder.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ],
          "candidate": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/node_properties.h||tensorflow/core/framework/node_properties.h": [
          "File: tensorflow/core/framework/node_properties.h -> tensorflow/core/framework/node_properties.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include \"tensorflow/core/framework/node_def.pb.h\"",
          "20: #include \"tensorflow/core/framework/op_def.pb.h\"",
          "21: #include \"tensorflow/core/framework/types.h\"",
          "22: #include \"tensorflow/core/lib/core/status.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include \"tensorflow/core/framework/op_def_builder.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:   NodeProperties(const OpDef* _op_def, NodeDef&& _node_def,",
          "37:                  DataTypeVector inputs, DataTypeVector outputs)",
          "38:       : op_def(_op_def),",
          "39:         node_def(std::move(_node_def)),",
          "40:         input_types(std::move(inputs)),",
          "41:         input_types_slice(input_types),",
          "42:         output_types(std::move(outputs)),",
          "",
          "[Removed Lines]",
          "43:         output_types_slice(output_types) {}",
          "",
          "[Added Lines]",
          "39:       : NodeProperties(_op_def, std::move(_node_def), inputs, outputs,",
          "40:                        nullptr) {}",
          "42:   NodeProperties(const OpDef* _op_def, NodeDef&& _node_def,",
          "43:                  DataTypeVector inputs, DataTypeVector outputs,",
          "44:                  ForwardTypeInferenceFn fwd_type_fn)",
          "50:         output_types_slice(output_types),",
          "51:         fwd_type_fn(fwd_type_fn) {}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "56:   DataTypeSlice input_types_slice;",
          "57:   DataTypeVector output_types;",
          "58:   DataTypeSlice output_types_slice;",
          "59: };",
          "61: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67:   ForwardTypeInferenceFn fwd_type_fn;",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:   }",
          "175: }",
          "177: const std::string& Node::name() const { return props_->node_def.name(); }",
          "178: const std::string& Node::type_string() const { return props_->node_def.op(); }",
          "179: const NodeDef& Node::def() const { return props_->node_def; }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "177: void Node::ClearTypeInfo() {",
          "178:   if (props_->node_def.has_experimental_type()) {",
          "179:     MaybeCopyOnWrite();",
          "180:     props_->node_def.clear_experimental_type();",
          "181:   }",
          "182: }",
          "184: void Node::RunForwardTypeInference() {",
          "185:   if (props_->fwd_type_fn == nullptr) {",
          "186:     return;",
          "187:   }",
          "189:   std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);",
          "190:   for (const auto& edge : in_edges_) {",
          "191:     if (edge->IsControlEdge()) {",
          "192:       continue;",
          "193:     }",
          "194:     DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();",
          "195:     input_nodes.at(edge->dst_input()) = edge->src();",
          "196:   }",
          "202:   for (const auto* node : input_nodes) {",
          "203:     if (node == nullptr) {",
          "205:       ClearTypeInfo();",
          "206:       return;",
          "207:     }",
          "208:   }",
          "210:   std::vector<std::reference_wrapper<const FullTypeDef>> input_types;",
          "211:   for (const auto* node : input_nodes) {",
          "212:     if (node->def().has_experimental_type()) {",
          "213:       input_types.emplace_back(node->def().experimental_type());",
          "214:     } else {",
          "216:       ClearTypeInfo();",
          "217:       return;",
          "218:     }",
          "219:   }",
          "221:   const auto infer_type = props_->fwd_type_fn(input_types);",
          "222:   const FullTypeDef infer_typedef = infer_type.ValueOrDie();",
          "223:   if (infer_typedef.type_id() != TFT_UNSET) {",
          "224:     MaybeCopyOnWrite();",
          "226:   }",
          "227: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "485:                                    ? Node::NC_FUNCTION_OP",
          "486:                                    : Node::GetNodeClassForOp(node_def.op());",
          "492:   return node;",
          "493: }",
          "",
          "[Removed Lines]",
          "488:   Node* node = AllocateNode(",
          "489:       std::make_shared<NodeProperties>(&op_reg_data->op_def,",
          "490:                                        std::move(node_def), inputs, outputs),",
          "491:       nullptr, node_class);",
          "",
          "[Added Lines]",
          "541:   if (op_reg_data->type_ctor != nullptr) {",
          "542:     const auto ctor_type =",
          "543:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
          "544:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "545:     if (ctor_typedef.type_id() != TFT_UNSET) {",
          "547:     }",
          "548:   }",
          "550:   Node* node = AllocateNode(std::make_shared<NodeProperties>(",
          "551:                                 &op_reg_data->op_def, std::move(node_def),",
          "552:                                 inputs, outputs, op_reg_data->fwd_type_fn),",
          "553:                             nullptr, node_class);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "563:   CHECK(dest->in_edges_.insert(e).second);",
          "564:   edges_.push_back(e);",
          "565:   ++num_edges_;",
          "566:   return e;",
          "567: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "629:   if (!e->IsControlEdge()) {",
          "630:     if (dest->in_edges_.size() >= dest->props_->input_types.size()) {",
          "639:       dest->RunForwardTypeInference();",
          "640:     }",
          "641:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "577:   edges_[e->id_] = nullptr;",
          "578:   RecycleEdge(e);",
          "579:   --num_edges_;",
          "580: }",
          "582: void Graph::RecycleEdge(const Edge* e) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "658:   if (!e->IsControlEdge()) {",
          "660:     e->dst_->RunForwardTypeInference();",
          "661:   }",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/graph.h||tensorflow/core/graph/graph.h": [
          "File: tensorflow/core/graph/graph.h -> tensorflow/core/graph/graph.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "267:   void UpdateProperties();",
          "269:  private:",
          "270:   friend class Graph;",
          "271:   Node();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:   void ClearTypeInfo();",
          "274:   void RunForwardTypeInference();",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/node_builder.cc||tensorflow/core/graph/node_builder.cc": [
          "File: tensorflow/core/graph/node_builder.cc -> tensorflow/core/graph/node_builder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <unordered_map>",
          "19: #include <vector>",
          "23: #include \"tensorflow/core/framework/node_def_util.h\"",
          "24: #include \"tensorflow/core/framework/types.pb.h\"",
          "25: #include \"tensorflow/core/framework/versions.pb.h\"",
          "",
          "[Removed Lines]",
          "21: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "22: #include \"tensorflow/core/framework/full_type_util.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:   return *this;",
          "120: }",
          "161: Status NodeBuilder::Finalize(Graph* graph, Node** created_node, bool consume) {",
          "164:   if (!errors_.empty()) {",
          "165:     return errors::InvalidArgument(absl::StrJoin(errors_, \"\\n\"));",
          "166:   }",
          "",
          "[Removed Lines]",
          "122: namespace {",
          "124: StatusOr<FullTypeDef> run_type_constructor(",
          "125:     const tensorflow::OpRegistrationData& op_reg_data,",
          "126:     const NodeDef& node_def) {",
          "127:   static FullTypeDef no_type;",
          "130:   if (op_reg_data.type_ctor == nullptr) {",
          "131:     return no_type;",
          "132:   }",
          "135:   return full_type::SpecializeType(AttrSlice(node_def), op_reg_data.op_def);",
          "136: }",
          "138: StatusOr<FullTypeDef> run_forward_type_inference(",
          "139:     const tensorflow::OpRegistrationData& op_reg_data, const NodeDef& node,",
          "140:     const std::vector<NodeBuilder::NodeOut>& inputs) {",
          "141:   static FullTypeDef no_type;",
          "143:   if (op_reg_data.fwd_type_fn == nullptr) {",
          "144:     return no_type;",
          "145:   }",
          "147:   std::vector<std::reference_wrapper<const FullTypeDef>> input_types;",
          "148:   for (const auto& input : inputs) {",
          "149:     if (input.node && input.node->def().has_experimental_type()) {",
          "150:       input_types.emplace_back(input.node->def().experimental_type());",
          "151:     } else {",
          "152:       input_types.emplace_back(no_type);",
          "153:     }",
          "154:   }",
          "156:   return op_reg_data.fwd_type_fn(input_types);",
          "157: }",
          "159: }  // namespace",
          "163:   if (created_node != nullptr) *created_node = nullptr;",
          "",
          "[Added Lines]",
          "122:   if (created_node != nullptr) {",
          "124:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171:   TF_RETURN_IF_ERROR(",
          "172:       CheckOpDeprecation(def_builder_.op_def(), graph->versions().producer()));",
          "194:   Status status;",
          "195:   Node* node = graph->AddNode(std::move(node_def), &status);",
          "196:   TF_RETURN_IF_ERROR(status);",
          "",
          "[Removed Lines]",
          "174:   const auto* op_registry = graph->op_registry();",
          "175:   const tensorflow::OpRegistrationData* op_reg_data;",
          "176:   TF_RETURN_IF_ERROR(op_registry->LookUp(node_def.op(), &op_reg_data));",
          "178:   const auto ctor_type = run_type_constructor(*op_reg_data, node_def);",
          "179:   TF_RETURN_IF_ERROR(ctor_type.status());",
          "180:   const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "181:   if (ctor_typedef.type_id() != TFT_UNSET) {",
          "183:   }",
          "185:   const auto infer_type =",
          "186:       run_forward_type_inference(*op_reg_data, node_def, inputs_);",
          "187:   TF_RETURN_IF_ERROR(infer_type.status());",
          "189:   const auto infer_typedef = infer_type.ValueOrDie();",
          "190:   if (infer_typedef.type_id() != TFT_UNSET) {",
          "192:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-2188",
  "cve_desc": "epan/dissectors/packet-wcp.c in the WCP dissector in Wireshark 1.10.x before 1.10.13 and 1.12.x before 1.12.4 does not properly initialize a data structure, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted packet that is improperly handled during decompression.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b204ff4846fe84b7789893c6b1d9afbdecac5b5d",
  "patch_info": {
    "commit_hash": "b204ff4846fe84b7789893c6b1d9afbdecac5b5d",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b204ff4846fe84b7789893c6b1d9afbdecac5b5d",
    "files": [
      "epan/dissectors/packet-wcp.c"
    ],
    "message": "Do bounds checking when decompressing WCP packets.\n\nExtract the data offset and count only once, and make sure we don't run\npast the end of the data we've copied from the packet; have\ndecompressed_entry() just do the decompression, rather than also\nfetching the data offset and count.\n\nAdd some comments while we're at it.\n\nBug: 10844\nChange-Id: I2dc2f9594422ffa8f15fd5c57c9dac2e30e363f4\nReviewed-on: https://code.wireshark.org/review/6514\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
    "before_after_code_files": [
      "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
      "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "104: #include <epan/etypes.h>",
      "105: #include <epan/nlpid.h>",
      "106: #include <epan/expert.h>",
      "112: void proto_register_wcp(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "107: #include <epan/exceptions.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "393: }",
      "416:  src = (dst - 1 - data_offset);",
      "417:  if ( src < buf_start)",
      "418:   src += MAX_WIN_BUF_LEN;",
      "",
      "[Removed Lines]",
      "396: static guint8 *decompressed_entry( guint8 *src, guint8 *dst, int *len, guint8 * buf_start, guint8 *buf_end){",
      "400:  guint16 data_offset, data_cnt;",
      "401:  guint8 tmp = *src;",
      "407:   data_cnt = *src;",
      "408:   data_cnt++;",
      "411:   data_cnt = tmp >> 4;",
      "412:   data_cnt++;",
      "413:  }",
      "",
      "[Added Lines]",
      "397: static guint8 *",
      "398: decompressed_entry(guint8 *dst, guint16 data_offset,",
      "399:     guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)",
      "400: {",
      "401:  const guint8 *src;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "478:  guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;",
      "479:  guint8 src_buf[ MAX_WCP_BUF_LEN];",
      "480:  tvbuff_t *tvb;",
      "481:  wcp_window_t *buf_ptr = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "468:  guint16 data_offset, data_cnt;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "496:   return NULL;",
      "497:  }",
      "499:  src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);",
      "500:  dst = buf_ptr->buf_cur;",
      "501:  len = 0;",
      "502:  i = -1;",
      "504:  while( offset < cnt){",
      "506:   if ( --i >= 0){",
      "517:     }",
      "518:     if ((*src & 0xf0) == 0x10){",
      "519:      if ( tree) {",
      "520:       ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,",
      "521:         offset, 3, ENC_NA);",
      "522:       sub_tree = proto_item_add_subtree(ti, ett_wcp_field);",
      "523:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
      "526:       proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,",
      "527:         offset+2, 1, ENC_BIG_ENDIAN);",
      "",
      "[Removed Lines]",
      "510:      dst = decompressed_entry( src, dst, &len, buf_start, buf_end);",
      "511:      if (dst == NULL){",
      "512:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
      "513:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
      "514:        len, MAX_WCP_BUF_LEN);",
      "515:       return NULL;",
      "516:      }",
      "524:         offset, 2, pntoh16(src));",
      "",
      "[Added Lines]",
      "509:    if ( comp_flag_bits & 0x80){",
      "511:     if (!(offset + 1 < cnt)) {",
      "516:      THROW(ReportedBoundsError);",
      "518:     data_offset = pntoh16(src) & WCP_OFFSET_MASK;",
      "525:      if (!(offset + 2 < cnt)) {",
      "530:       THROW(ReportedBoundsError);",
      "531:      }",
      "532:      data_cnt = *(src + 2) + 1;",
      "538:         offset, 2, data_offset);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "529:      src += 3;",
      "530:      offset += 3;",
      "531:     }else{",
      "532:      if ( tree) {",
      "533:       ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,",
      "534:         offset, 2, ENC_NA);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "552:      data_cnt = (*src >> 4) + 1;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "536:       proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,",
      "537:         offset, 1, *src);",
      "538:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
      "540:      }",
      "541:      src += 2;",
      "542:      offset += 2;",
      "543:     }",
      "544:    }else {",
      "545:     if ( ++len >MAX_WCP_BUF_LEN){",
      "546:      expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
      "547:       \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
      "548:       len, MAX_WCP_BUF_LEN);",
      "549:      return NULL;",
      "550:     }",
      "554:      if ( dst++ == buf_end)",
      "555:       dst = buf_start;",
      "",
      "[Removed Lines]",
      "539:         offset, 2, pntoh16(src));",
      "",
      "[Added Lines]",
      "560:         offset, 2, data_offset);",
      "566:      dst = decompressed_entry(dst,",
      "567:          data_offset, data_cnt, &len,",
      "568:          buf_start, buf_end);",
      "569:      if (dst == NULL){",
      "570:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
      "571:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
      "572:        len, MAX_WCP_BUF_LEN);",
      "573:       return NULL;",
      "574:      }",
      "575:     }",
      "590:     if ( !pinfo->fd->flags.visited){",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "558:     ++offset;",
      "559:    }",
      "561:    comp_flag_bits <<= 1;",
      "565:    comp_flag_bits = *src++;",
      "566:    if (cd_tree)",
      "567:     proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "607:   }else {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f69d9d2a59477cd1d2f3747b57abce1b29a6a40c",
      "candidate_info": {
        "commit_hash": "f69d9d2a59477cd1d2f3747b57abce1b29a6a40c",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/f69d9d2a59477cd1d2f3747b57abce1b29a6a40c",
        "files": [
          "epan/dissectors/packet-wcp.c"
        ],
        "message": "Do bounds checking when decompressing WCP packets.\n\nExtract the data offset and count only once, and make sure we don't run\npast the end of the data we've copied from the packet; have\ndecompressed_entry() just do the decompression, rather than also\nfetching the data offset and count.\n\nAdd some comments while we're at it.\n\nI have basically copied the new code except for the whitespaces\ninstead of just back-porting the changes because the changes were\nan almost full rewrite already.\n\nBug: 10844\nChange-Id: I2dc2f9594422ffa8f15fd5c57c9dac2e30e363f4\nReviewed-on: https://code.wireshark.org/review/6514\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit b204ff4846fe84b7789893c6b1d9afbdecac5b5d)\nReviewed-on: https://code.wireshark.org/review/6515\nReviewed-on: https://code.wireshark.org/review/7712\nReviewed-by: Balint Reczey <balint@balintreczey.hu>\nTested-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
          "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "105: #include <string.h>",
          "106: #include <epan/packet.h>",
          "107: #include \"packet-frame.h\"",
          "108: #include <epan/circuit.h>",
          "109: #include <epan/emem.h>",
          "110: #include <epan/etypes.h>",
          "111: #include <epan/nlpid.h>",
          "117: typedef struct {",
          "119:  guint8  *buf_cur;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108: #include <epan/pint.h>",
          "113: #include <epan/exceptions.h>",
          "119: void proto_register_wcp(void);",
          "120: void proto_reg_handoff_wcp(void);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "156: static int hf_wcp_ppc = -1;",
          "157: static int hf_wcp_pib = -1;",
          "159: static int hf_wcp_comp_bits = -1;",
          "160: static int hf_wcp_comp_marker = -1;",
          "161: static int hf_wcp_short_len = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164: static int hf_wcp_compressed_data = -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165: static int hf_wcp_offset = -1;",
          "167: static gint ett_wcp = -1;",
          "168: static gint ett_wcp_field = -1;",
          "170: static dissector_handle_t fr_uncompressed_handle;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174: static gint ett_wcp_comp_data = -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "394: }",
          "417:  src = (dst - 1 - data_offset);",
          "418:  if ( src < buf_start)",
          "419:   src += MAX_WIN_BUF_LEN;",
          "",
          "[Removed Lines]",
          "397: static guint8 *decompressed_entry( guint8 *src, guint8 *dst, int *len, guint8 * buf_start, guint8 *buf_end){",
          "401:  guint16 data_offset, data_cnt;",
          "402:  guint8 tmp = *src;",
          "408:   data_cnt = *src;",
          "409:   data_cnt++;",
          "412:   data_cnt = tmp >> 4;",
          "413:   data_cnt++;",
          "414:  }",
          "",
          "[Added Lines]",
          "404: static guint8 *",
          "405: decompressed_entry(guint8 *dst, guint16 data_offset,",
          "406:     guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)",
          "407: {",
          "408:  const guint8 *src;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "481:  guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;",
          "482:  guint8 src_buf[ MAX_WCP_BUF_LEN];",
          "484:  wcp_window_t *buf_ptr = 0;",
          "488:  buf_ptr = get_wcp_window_ptr( pinfo);",
          "490:  buf_start = buf_ptr->buffer;",
          "491:  buf_end = buf_start + MAX_WIN_BUF_LEN;",
          "493:  if (cnt - offset > MAX_WCP_BUF_LEN) {",
          "494:   if (tree)",
          "495:    proto_tree_add_text( tree, src_tvb, offset, -1,",
          "",
          "[Removed Lines]",
          "475:  proto_tree *sub_tree;",
          "476:  proto_item *ti;",
          "478:  int len=0, i = -1;",
          "483:  tvbuff_t *volatile tvb = 0;",
          "485:  wcp_pdata_t *volatile pdata_ptr;",
          "486:  volatile gboolean bounds_error = FALSE;",
          "",
          "[Added Lines]",
          "470:  proto_tree *cd_tree, *sub_tree;",
          "471:  proto_item *cd_item, *ti;",
          "473:  int len, i;",
          "477:  guint16 data_offset, data_cnt;",
          "479:  tvbuff_t *tvb;",
          "481:  wcp_pdata_t *pdata_ptr;",
          "488:  cd_item = proto_tree_add_item(tree, hf_wcp_compressed_data,",
          "489:      src_tvb, offset, cnt - offset, ENC_NA);",
          "490:  cd_tree = proto_item_add_subtree(cd_item, ett_wcp_comp_data);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "498:   return NULL;",
          "499:  }",
          "502:  dst = buf_ptr->buf_cur;",
          "506:   if ( --i >= 0){",
          "511:     }",
          "512:     if ((*src & 0xf0) == 0x10){",
          "513:      if ( tree) {",
          "516:       sub_tree = proto_item_add_subtree(ti, ett_wcp_field);",
          "517:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "520:       proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,",
          "522:      }",
          "523:      src += 3;",
          "525:     }else{",
          "526:      if ( tree) {",
          "529:       sub_tree = proto_item_add_subtree(ti, ett_wcp_field);",
          "530:       proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,",
          "532:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "534:      }",
          "535:      src += 2;",
          "537:     }",
          "541:      if ( dst++ == buf_end)",
          "542:       dst = buf_start;",
          "543:     }",
          "544:     ++src;",
          "551:    }",
          "553:    comp_flag_bits <<= 1;",
          "557:    comp_flag_bits = *src++;",
          "560:      comp_flag_bits);",
          "562:    i = 8;",
          "563:   }",
          "",
          "[Removed Lines]",
          "501:  src = tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);",
          "504:  while( offset++ < cnt){",
          "510:      dst = decompressed_entry( src, dst, &len, buf_start, buf_end);",
          "514:       ti = proto_tree_add_item( tree, hf_wcp_long_run, src_tvb,",
          "515:         offset-1, 3, ENC_NA);",
          "518:         offset-1, 2, pntohs(src));",
          "521:         offset+1, 1, ENC_BIG_ENDIAN);",
          "524:      offset += 2;",
          "527:       ti = proto_tree_add_item( tree, hf_wcp_short_run, src_tvb,",
          "528:         offset - 1, 2, ENC_NA);",
          "531:         offset-1, 1, *src);",
          "533:         offset-1, 2, pntohs(src));",
          "536:      offset += 1;",
          "538:    }else {",
          "545:     ++len;",
          "547:    }",
          "549:    if ( len >MAX_WCP_BUF_LEN){",
          "550:     return NULL;",
          "558:    if (tree)",
          "559:     proto_tree_add_uint( tree, hf_wcp_comp_bits,  src_tvb, offset-1, 1,",
          "",
          "[Added Lines]",
          "506:  src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);",
          "508:  len = 0;",
          "509:  i = -1;",
          "511:  while( offset < cnt){",
          "519:    if ( comp_flag_bits & 0x80){",
          "521:     if (!(offset + 1 < cnt)) {",
          "526:      THROW(ReportedBoundsError);",
          "528:     data_offset = pntohs(src) & WCP_OFFSET_MASK;",
          "535:      if (!(offset + 2 < cnt)) {",
          "540:       THROW(ReportedBoundsError);",
          "541:     }",
          "542:      data_cnt = *(src + 2) + 1;",
          "544:       ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,",
          "545:         offset, 3, ENC_NA);",
          "548:         offset, 2, data_offset);",
          "551:         offset+2, 1, ENC_BIG_ENDIAN);",
          "554:      offset += 3;",
          "562:      data_cnt = (*src >> 4) + 1;",
          "564:       ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,",
          "565:         offset, 2, ENC_NA);",
          "568:         offset, 1, *src);",
          "570:         offset, 2, data_offset);",
          "573:      offset += 2;",
          "576:      dst = decompressed_entry(dst,",
          "577:          data_offset, data_cnt, &len,",
          "578:          buf_start, buf_end);",
          "579:      if (dst == NULL){",
          "580:       return NULL;",
          "581:      }",
          "582:     }",
          "583:    }else {",
          "589:     if ( ++len >MAX_WCP_BUF_LEN){",
          "591:      return NULL;",
          "592:     }",
          "594:     if ( !pinfo->fd->flags.visited){",
          "605:     ++offset;",
          "611:   }else {",
          "618:    if (cd_tree)",
          "619:     proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,",
          "621:    offset++;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "568:   pdata_ptr = p_get_proto_data( pinfo->fd, proto_wcp);",
          "571:    return NULL;",
          "572:   len = pdata_ptr->len;",
          "573:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "632:    REPORT_DISSECTOR_BUG(\"Can't find uncompressed data\");",
          "634:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "582:   buf_ptr->buf_cur = dst;",
          "583:  }",
          "587:                 tvb = tvb_new_child_real_data(src_tvb,  pdata_ptr->buffer, pdata_ptr->len, pdata_ptr->len);",
          "600:  add_new_data_source( pinfo, tvb, \"Uncompressed WCP\");",
          "",
          "[Removed Lines]",
          "586:         TRY {",
          "588:         }",
          "589:         CATCH(BoundsError) {",
          "590:   DISSECTOR_ASSERT_NOT_REACHED();",
          "591:         }",
          "592:         CATCH(ReportedBoundsError) {",
          "593:   bounds_error = TRUE;",
          "594:         }",
          "595:         ENDTRY;",
          "597:  if (bounds_error) return NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "661:  { &hf_wcp_pib,",
          "662:    { \"PIB\", \"wcp.pib\", FT_UINT8, BASE_DEC, NULL, 0,",
          "663:     NULL, HFILL }},",
          "664:  { &hf_wcp_comp_bits,",
          "665:    { \"Compress Flag\", \"wcp.flag\", FT_UINT8, BASE_HEX, NULL, 0,",
          "666:     \"Compressed byte flag\", HFILL }},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "715:  { &hf_wcp_compressed_data,",
          "716:    { \"Compressed Data\", \"wcp.compressed_data\", FT_NONE, BASE_NONE, NULL, 0,",
          "717:      \"Raw compressed data\", HFILL }},",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "689:     static gint *ett[] = {",
          "690:         &ett_wcp,",
          "691:  &ett_wcp_field,",
          "692:     };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "745:         &ett_wcp_comp_data,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2c9b3f3e3f753723ecfd0927b668ae2af6ee5830",
      "candidate_info": {
        "commit_hash": "2c9b3f3e3f753723ecfd0927b668ae2af6ee5830",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/2c9b3f3e3f753723ecfd0927b668ae2af6ee5830",
        "files": [
          "epan/dissectors/packet-wcp.c"
        ],
        "message": "Do bounds checking when decompressing WCP packets.\n\nExtract the data offset and count only once, and make sure we don't run\npast the end of the data we've copied from the packet; have\ndecompressed_entry() just do the decompression, rather than also\nfetching the data offset and count.\n\nAdd some comments while we're at it.\n\nBug: 10844\nChange-Id: I2dc2f9594422ffa8f15fd5c57c9dac2e30e363f4\nReviewed-on: https://code.wireshark.org/review/6514\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit b204ff4846fe84b7789893c6b1d9afbdecac5b5d)\nReviewed-on: https://code.wireshark.org/review/6515\nReviewed-on: https://code.wireshark.org/review/7703\nReviewed-by: Balint Reczey <balint@balintreczey.hu>\nTested-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
          "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: #include <epan/etypes.h>",
          "109: #include <epan/nlpid.h>",
          "110: #include <epan/expert.h>",
          "116: void proto_register_wcp(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: #include <epan/exceptions.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "397: }",
          "420:  src = (dst - 1 - data_offset);",
          "421:  if ( src < buf_start)",
          "422:   src += MAX_WIN_BUF_LEN;",
          "",
          "[Removed Lines]",
          "400: static guint8 *decompressed_entry( guint8 *src, guint8 *dst, int *len, guint8 * buf_start, guint8 *buf_end){",
          "404:  guint16 data_offset, data_cnt;",
          "405:  guint8 tmp = *src;",
          "411:   data_cnt = *src;",
          "412:   data_cnt++;",
          "415:   data_cnt = tmp >> 4;",
          "416:   data_cnt++;",
          "417:  }",
          "",
          "[Added Lines]",
          "401: static guint8 *",
          "402: decompressed_entry(guint8 *dst, guint16 data_offset,",
          "403:     guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)",
          "404: {",
          "405:  const guint8 *src;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "482:  guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;",
          "483:  guint8 src_buf[ MAX_WCP_BUF_LEN];",
          "484:  tvbuff_t *tvb;",
          "485:  wcp_window_t *buf_ptr = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "472:  guint16 data_offset, data_cnt;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "500:   return NULL;",
          "501:  }",
          "503:  src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);",
          "504:  dst = buf_ptr->buf_cur;",
          "505:  len = 0;",
          "506:  i = -1;",
          "508:  while( offset < cnt){",
          "510:   if ( --i >= 0){",
          "521:     }",
          "522:     if ((*src & 0xf0) == 0x10){",
          "523:      if ( tree) {",
          "524:       ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,",
          "525:         offset, 3, ENC_NA);",
          "526:       sub_tree = proto_item_add_subtree(ti, ett_wcp_field);",
          "527:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "530:       proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,",
          "531:         offset+2, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "514:      dst = decompressed_entry( src, dst, &len, buf_start, buf_end);",
          "515:      if (dst == NULL){",
          "516:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
          "517:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "518:        len, MAX_WCP_BUF_LEN);",
          "519:       return NULL;",
          "520:      }",
          "528:         offset, 2, pntoh16(src));",
          "",
          "[Added Lines]",
          "513:    if ( comp_flag_bits & 0x80){",
          "515:     if (!(offset + 1 < cnt)) {",
          "520:      THROW(ReportedBoundsError);",
          "522:     data_offset = pntoh16(src) & WCP_OFFSET_MASK;",
          "529:      if (!(offset + 2 < cnt)) {",
          "534:       THROW(ReportedBoundsError);",
          "535:      }",
          "536:      data_cnt = *(src + 2) + 1;",
          "542:         offset, 2, data_offset);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "533:      src += 3;",
          "534:      offset += 3;",
          "535:     }else{",
          "536:      if ( tree) {",
          "537:       ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,",
          "538:         offset, 2, ENC_NA);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "556:      data_cnt = (*src >> 4) + 1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "540:       proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,",
          "541:         offset, 1, *src);",
          "542:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "544:      }",
          "545:      src += 2;",
          "546:      offset += 2;",
          "547:     }",
          "548:    }else {",
          "549:     if ( ++len >MAX_WCP_BUF_LEN){",
          "550:      expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
          "551:       \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "552:       len, MAX_WCP_BUF_LEN);",
          "553:      return NULL;",
          "554:     }",
          "558:      if ( dst++ == buf_end)",
          "559:       dst = buf_start;",
          "",
          "[Removed Lines]",
          "543:         offset, 2, pntoh16(src));",
          "",
          "[Added Lines]",
          "564:         offset, 2, data_offset);",
          "570:      dst = decompressed_entry(dst,",
          "571:          data_offset, data_cnt, &len,",
          "572:          buf_start, buf_end);",
          "573:      if (dst == NULL){",
          "574:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
          "575:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "576:        len, MAX_WCP_BUF_LEN);",
          "577:       return NULL;",
          "578:      }",
          "579:     }",
          "594:     if ( !pinfo->fd->flags.visited){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "562:     ++offset;",
          "563:    }",
          "565:    comp_flag_bits <<= 1;",
          "569:    comp_flag_bits = *src++;",
          "570:    if (cd_tree)",
          "571:     proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "611:   }else {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c59e0a85e2a378e87a9c0bfb2fd58bd88f1ac890",
      "candidate_info": {
        "commit_hash": "c59e0a85e2a378e87a9c0bfb2fd58bd88f1ac890",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/c59e0a85e2a378e87a9c0bfb2fd58bd88f1ac890",
        "files": [
          "epan/dissectors/packet-wcp.c"
        ],
        "message": "Do bounds checking when decompressing WCP packets.\n\nExtract the data offset and count only once, and make sure we don't run\npast the end of the data we've copied from the packet; have\ndecompressed_entry() just do the decompression, rather than also\nfetching the data offset and count.\n\nAdd some comments while we're at it.\n\nBug: 10844\nChange-Id: I2dc2f9594422ffa8f15fd5c57c9dac2e30e363f4\nReviewed-on: https://code.wireshark.org/review/6514\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit b204ff4846fe84b7789893c6b1d9afbdecac5b5d)\nReviewed-on: https://code.wireshark.org/review/6515",
        "before_after_code_files": [
          "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
          "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: #include <epan/etypes.h>",
          "109: #include <epan/nlpid.h>",
          "110: #include <epan/expert.h>",
          "116: void proto_register_wcp(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: #include <epan/exceptions.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "397: }",
          "420:  src = (dst - 1 - data_offset);",
          "421:  if ( src < buf_start)",
          "422:   src += MAX_WIN_BUF_LEN;",
          "",
          "[Removed Lines]",
          "400: static guint8 *decompressed_entry( guint8 *src, guint8 *dst, int *len, guint8 * buf_start, guint8 *buf_end){",
          "404:  guint16 data_offset, data_cnt;",
          "405:  guint8 tmp = *src;",
          "411:   data_cnt = *src;",
          "412:   data_cnt++;",
          "415:   data_cnt = tmp >> 4;",
          "416:   data_cnt++;",
          "417:  }",
          "",
          "[Added Lines]",
          "401: static guint8 *",
          "402: decompressed_entry(guint8 *dst, guint16 data_offset,",
          "403:     guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)",
          "404: {",
          "405:  const guint8 *src;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "482:  guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;",
          "483:  guint8 src_buf[ MAX_WCP_BUF_LEN];",
          "484:  tvbuff_t *tvb;",
          "485:  wcp_window_t *buf_ptr = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "472:  guint16 data_offset, data_cnt;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "500:   return NULL;",
          "501:  }",
          "503:  src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);",
          "504:  dst = buf_ptr->buf_cur;",
          "505:  len = 0;",
          "506:  i = -1;",
          "508:  while( offset < cnt){",
          "510:   if ( --i >= 0){",
          "521:     }",
          "522:     if ((*src & 0xf0) == 0x10){",
          "523:      if ( tree) {",
          "524:       ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,",
          "525:         offset, 3, ENC_NA);",
          "526:       sub_tree = proto_item_add_subtree(ti, ett_wcp_field);",
          "527:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "530:       proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,",
          "531:         offset+2, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "514:      dst = decompressed_entry( src, dst, &len, buf_start, buf_end);",
          "515:      if (dst == NULL){",
          "516:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
          "517:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "518:        len, MAX_WCP_BUF_LEN);",
          "519:       return NULL;",
          "520:      }",
          "528:         offset, 2, pntoh16(src));",
          "",
          "[Added Lines]",
          "513:    if ( comp_flag_bits & 0x80){",
          "515:     if (!(offset + 1 < cnt)) {",
          "520:      THROW(ReportedBoundsError);",
          "522:     data_offset = pntoh16(src) & WCP_OFFSET_MASK;",
          "529:      if (!(offset + 2 < cnt)) {",
          "534:       THROW(ReportedBoundsError);",
          "535:      }",
          "536:      data_cnt = *(src + 2) + 1;",
          "542:         offset, 2, data_offset);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "533:      src += 3;",
          "534:      offset += 3;",
          "535:     }else{",
          "536:      if ( tree) {",
          "537:       ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,",
          "538:         offset, 2, ENC_NA);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "556:      data_cnt = (*src >> 4) + 1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "540:       proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,",
          "541:         offset, 1, *src);",
          "542:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "544:      }",
          "545:      src += 2;",
          "546:      offset += 2;",
          "547:     }",
          "548:    }else {",
          "549:     if ( ++len >MAX_WCP_BUF_LEN){",
          "550:      expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
          "551:       \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "552:       len, MAX_WCP_BUF_LEN);",
          "553:      return NULL;",
          "554:     }",
          "558:      if ( dst++ == buf_end)",
          "559:       dst = buf_start;",
          "",
          "[Removed Lines]",
          "543:         offset, 2, pntoh16(src));",
          "",
          "[Added Lines]",
          "564:         offset, 2, data_offset);",
          "570:      dst = decompressed_entry(dst,",
          "571:          data_offset, data_cnt, &len,",
          "572:          buf_start, buf_end);",
          "573:      if (dst == NULL){",
          "574:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
          "575:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "576:        len, MAX_WCP_BUF_LEN);",
          "577:       return NULL;",
          "578:      }",
          "579:     }",
          "594:     if ( !pinfo->fd->flags.visited){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "562:     ++offset;",
          "563:    }",
          "565:    comp_flag_bits <<= 1;",
          "569:    comp_flag_bits = *src++;",
          "570:    if (cd_tree)",
          "571:     proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "611:   }else {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a6fc6aa0b4efc1a1c3d7a2e3b5189e888fb6ccc2",
      "candidate_info": {
        "commit_hash": "a6fc6aa0b4efc1a1c3d7a2e3b5189e888fb6ccc2",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/a6fc6aa0b4efc1a1c3d7a2e3b5189e888fb6ccc2",
        "files": [
          "epan/dissectors/packet-wcp.c"
        ],
        "message": "wcp: add validations to decompressed_entry\n\nEnsure that a reference to past bytes refers to bytes that actually exist.\n\nBug: 10978\nChange-Id: If95d785ee15243c88edcd7115b5ff25fbaa08e6c\nReviewed-on: https://code.wireshark.org/review/7783\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Evan Huus <eapache@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
          "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:  guint8  *buf_cur;",
          "119:  guint8  buffer[MAX_WIN_BUF_LEN];",
          "121: }wcp_window_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121:  guint16 initialized;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171: static expert_field ei_wcp_compressed_data_exceeds = EI_INIT;",
          "172: static expert_field ei_wcp_uncompressed_data_exceeds = EI_INIT;",
          "174: static dissector_handle_t fr_uncompressed_handle;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "175: static expert_field ei_wcp_invalid_window_offset = EI_INIT;",
          "176: static expert_field ei_wcp_invalid_match_length = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "397: static guint8 *",
          "398: decompressed_entry(guint8 *dst, guint16 data_offset,",
          "400: {",
          "401:  const guint8 *src;",
          "",
          "[Removed Lines]",
          "399:     guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)",
          "",
          "[Added Lines]",
          "403:     guint16 data_cnt, int *len, wcp_window_t *buf_ptr)",
          "406:  guint8 *buf_start, *buf_end;",
          "408:  buf_start = buf_ptr->buffer;",
          "409:  buf_end = buf_ptr->buffer + MAX_WIN_BUF_LEN;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "412:  while( data_cnt--){",
          "414:   if ( ++(*len) >MAX_WCP_BUF_LEN){",
          "416:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "422:   if ( buf_ptr->initialized < MAX_WIN_BUF_LEN)",
          "423:    buf_ptr->initialized++;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "444:  if ( !wcp_circuit_data){",
          "445:   wcp_circuit_data = wmem_new(wmem_file_scope(), wcp_circuit_data_t);",
          "446:   wcp_circuit_data->recv.buf_cur = wcp_circuit_data->recv.buffer;",
          "447:   wcp_circuit_data->send.buf_cur = wcp_circuit_data->send.buffer;",
          "448:   circuit_add_proto_data(circuit, proto_wcp, wcp_circuit_data);",
          "449:  }",
          "450:  if (pinfo->pseudo_header->x25.flags & FROM_DCE)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "457:   wcp_circuit_data->recv.initialized = 0;",
          "459:   wcp_circuit_data->send.initialized = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "562:      src += 2;",
          "563:      offset += 2;",
          "564:     }",
          "566:      dst = decompressed_entry(dst,",
          "567:          data_offset, data_cnt, &len,",
          "569:      if (dst == NULL){",
          "570:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
          "571:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "",
          "[Removed Lines]",
          "568:          buf_start, buf_end);",
          "",
          "[Added Lines]",
          "577:     if (data_offset + 1 > buf_ptr->initialized) {",
          "578:      expert_add_info_format(pinfo, cd_item, &ei_wcp_invalid_window_offset,",
          "579:        \"Data offset exceeds valid window size (%d > %d)\",",
          "580:        data_offset+1, buf_ptr->initialized);",
          "581:      return NULL;",
          "582:     }",
          "584:     if (data_offset + 1 < data_cnt) {",
          "585:      expert_add_info_format(pinfo, cd_item, &ei_wcp_invalid_window_offset,",
          "586:        \"Data count exceeds offset (%d > %d)\",",
          "587:        data_cnt, data_offset+1);",
          "588:      return NULL;",
          "589:     }",
          "593:          buf_ptr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "597:      if ( dst++ == buf_end)",
          "598:       dst = buf_start;",
          "599:     }",
          "600:     ++src;",
          "601:     ++offset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "624:      if (buf_ptr->initialized < MAX_WIN_BUF_LEN)",
          "625:       buf_ptr->initialized++;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "749:  static ei_register_info ei[] = {",
          "750:   { &ei_wcp_compressed_data_exceeds, { \"wcp.compressed_data.exceeds\", PI_MALFORMED, PI_ERROR, \"Compressed data exceeds maximum buffer length\", EXPFILL }},",
          "751:   { &ei_wcp_uncompressed_data_exceeds, { \"wcp.uncompressed_data.exceeds\", PI_MALFORMED, PI_ERROR, \"Uncompressed data exceeds maximum buffer length\", EXPFILL }},",
          "752:  };",
          "754:  expert_module_t* expert_wcp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "779:   { &ei_wcp_invalid_window_offset, { \"wcp.off.invalid\", PI_MALFORMED, PI_ERROR, \"Offset points outside of visible window\", EXPFILL }},",
          "780:   { &ei_wcp_invalid_match_length, { \"wcp.len.invalid\", PI_MALFORMED, PI_ERROR, \"Length greater than offset\", EXPFILL }},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9e4c79c15366e7e3f44dc3d03dfc4ea23929ecfe",
      "candidate_info": {
        "commit_hash": "9e4c79c15366e7e3f44dc3d03dfc4ea23929ecfe",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/9e4c79c15366e7e3f44dc3d03dfc4ea23929ecfe",
        "files": [
          "epan/dissectors/packet-wcp.c"
        ],
        "message": "[wcp] don't THROW() an exception from a dissector\n\nin this case, we can simply abort the decompression,\nthe caller is already prepared to handle this\n\nChange-Id: I2fb8132878ecd58d9370c49083aa7db959803cae\nReviewed-on: https://code.wireshark.org/review/13150\nPetri-Dish: Alexis La Goutte <alexis.lagoutte@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
          "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "521:     }",
          "522:     data_offset = pntoh16(src) & WCP_OFFSET_MASK;",
          "523:     if ((*src & 0xf0) == 0x10){",
          "",
          "[Removed Lines]",
          "520:      THROW(ReportedBoundsError);",
          "",
          "[Added Lines]",
          "520:      return NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "535:      }",
          "536:      data_cnt = *(src + 2) + 1;",
          "537:      if ( tree) {",
          "",
          "[Removed Lines]",
          "534:       THROW(ReportedBoundsError);",
          "",
          "[Added Lines]",
          "534:       return NULL;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
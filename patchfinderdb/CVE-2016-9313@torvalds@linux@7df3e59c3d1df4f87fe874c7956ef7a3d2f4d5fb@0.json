{
  "cve_id": "CVE-2016-9313",
  "cve_desc": "security/keys/big_key.c in the Linux kernel before 4.8.7 mishandles unsuccessful crypto registration in conjunction with successful key-type registration, which allows local users to cause a denial of service (NULL pointer dereference and panic) or possibly have unspecified other impact via a crafted application that uses the big_key data type.",
  "repo": "torvalds/linux",
  "patch_hash": "7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb",
  "patch_info": {
    "commit_hash": "7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb",
    "files": [
      "security/keys/big_key.c"
    ],
    "message": "KEYS: Sort out big_key initialisation\n\nbig_key has two separate initialisation functions, one that registers the\nkey type and one that registers the crypto.  If the key type fails to\nregister, there's no problem if the crypto registers successfully because\nthere's no way to reach the crypto except through the key type.\n\nHowever, if the key type registers successfully but the crypto does not,\nbig_key_rng and big_key_blkcipher may end up set to NULL - but the code\nneither checks for this nor unregisters the big key key type.\n\nFurthermore, since the key type is registered before the crypto, it is\ntheoretically possible for the kernel to try adding a big_key before the\ncrypto is set up, leading to the same effect.\n\nFix this by merging big_key_crypto_init() and big_key_init() and calling\nthe resulting function late.  If they're going to be encrypted, we\nshouldn't be creating big_keys before we have the facilities to do the\nencryption available.  The key type registration is also moved after the\ncrypto initialisation.\n\nThe fix also includes message printing on failure.\n\nIf the big_key type isn't correctly set up, simply doing:\n\n\tdd if=/dev/zero bs=4096 count=1 | keyctl padd big_key a @s\n\nought to cause an oops.\n\nFixes: 13100a72f40f5748a04017e0ab3df4cf27c809ef ('Security: Keys: Big keys stored encrypted')\nSigned-off-by: David Howells <dhowells@redhat.com>\ncc: Peter Hlavaty <zer0mem@yahoo.com>\ncc: Kirill Marinushkin <k.marinushkin@gmail.com>\ncc: Artem Savkov <asavkov@redhat.com>\ncc: stable@vger.kernel.org\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "before_after_code_files": [
      "security/keys/big_key.c||security/keys/big_key.c"
    ]
  },
  "patch_diff": {
    "security/keys/big_key.c||security/keys/big_key.c": [
      "File: security/keys/big_key.c -> security/keys/big_key.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "12: #include <linux/init.h>",
      "13: #include <linux/seq_file.h>",
      "14: #include <linux/file.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: #define pr_fmt(fmt) \"big_key: \"fmt",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "342: static int __init big_key_init(void)",
      "343: {",
      "359:  }",
      "373:  }",
      "375:  return 0;",
      "378:  crypto_free_rng(big_key_rng);",
      "380:  return ret;",
      "381: }",
      "",
      "[Removed Lines]",
      "344:  return register_key_type(&key_type_big_key);",
      "345: }",
      "350: static int __init big_key_crypto_init(void)",
      "351: {",
      "352:  int ret = -EINVAL;",
      "355:  big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);",
      "356:  if (IS_ERR(big_key_rng)) {",
      "357:   big_key_rng = NULL;",
      "358:   return -EFAULT;",
      "362:  ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));",
      "363:  if (ret)",
      "364:   goto error;",
      "367:  big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,",
      "368:        0, CRYPTO_ALG_ASYNC);",
      "369:  if (IS_ERR(big_key_skcipher)) {",
      "370:   big_key_skcipher = NULL;",
      "371:   ret = -EFAULT;",
      "372:   goto error;",
      "377: error:",
      "379:  big_key_rng = NULL;",
      "383: device_initcall(big_key_init);",
      "384: late_initcall(big_key_crypto_init);",
      "",
      "[Added Lines]",
      "345:  struct crypto_skcipher *cipher;",
      "346:  struct crypto_rng *rng;",
      "347:  int ret;",
      "349:  rng = crypto_alloc_rng(big_key_rng_name, 0, 0);",
      "350:  if (IS_ERR(rng)) {",
      "351:   pr_err(\"Can't alloc rng: %ld\\n\", PTR_ERR(rng));",
      "352:   return PTR_ERR(rng);",
      "355:  big_key_rng = rng;",
      "358:  ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));",
      "359:  if (ret) {",
      "360:   pr_err(\"Can't reset rng: %d\\n\", ret);",
      "361:   goto error_rng;",
      "362:  }",
      "365:  cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);",
      "366:  if (IS_ERR(cipher)) {",
      "367:   ret = PTR_ERR(cipher);",
      "368:   pr_err(\"Can't alloc crypto: %d\\n\", ret);",
      "369:   goto error_rng;",
      "370:  }",
      "372:  big_key_skcipher = cipher;",
      "374:  ret = register_key_type(&key_type_big_key);",
      "375:  if (ret < 0) {",
      "376:   pr_err(\"Can't register type: %d\\n\", ret);",
      "377:   goto error_cipher;",
      "382: error_cipher:",
      "383:  crypto_free_skcipher(big_key_skcipher);",
      "384: error_rng:",
      "389: late_initcall(big_key_init);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "428490e38b2e352812e0b765d8bceafab0ec441d",
      "candidate_info": {
        "commit_hash": "428490e38b2e352812e0b765d8bceafab0ec441d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/428490e38b2e352812e0b765d8bceafab0ec441d",
        "files": [
          "security/keys/Kconfig",
          "security/keys/big_key.c"
        ],
        "message": "security/keys: rewrite all of big_key crypto\n\nThis started out as just replacing the use of crypto/rng with\nget_random_bytes_wait, so that we wouldn't use bad randomness at boot\ntime. But, upon looking further, it appears that there were even deeper\nunderlying cryptographic problems, and that this seems to have been\ncommitted with very little crypto review. So, I rewrote the whole thing,\ntrying to keep to the conventions introduced by the previous author, to\nfix these cryptographic flaws.\n\nIt makes no sense to seed crypto/rng at boot time and then keep\nusing it like this, when in fact there's already get_random_bytes_wait,\nwhich can ensure there's enough entropy and be a much more standard way\nof generating keys. Since this sensitive material is being stored\nuntrusted, using ECB and no authentication is simply not okay at all. I\nfind it surprising and a bit horrifying that this code even made it past\nbasic crypto review, which perhaps points to some larger issues. This\npatch moves from using AES-ECB to using AES-GCM. Since keys are uniquely\ngenerated each time, we can set the nonce to zero. There was also a race\ncondition in which the same key would be reused at the same time in\ndifferent threads. A mutex fixes this issue now.\n\nSo, to summarize, this commit fixes the following vulnerabilities:\n\n  * Low entropy key generation, allowing an attacker to potentially\n    guess or predict keys.\n  * Unauthenticated encryption, allowing an attacker to modify the\n    cipher text in particular ways in order to manipulate the plaintext,\n    which is is even more frightening considering the next point.\n  * Use of ECB mode, allowing an attacker to trivially swap blocks or\n    compare identical plaintext blocks.\n  * Key re-use.\n  * Faulty memory zeroing.\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nReviewed-by: Eric Biggers <ebiggers3@gmail.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nCc: Kirill Marinushkin <k.marinushkin@gmail.com>\nCc: security@kernel.org\nCc: stable@vger.kernel.org",
        "before_after_code_files": [
          "security/keys/big_key.c||security/keys/big_key.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "security/keys/big_key.c||security/keys/big_key.c"
          ],
          "candidate": [
            "security/keys/big_key.c||security/keys/big_key.c"
          ]
        }
      },
      "candidate_diff": {
        "security/keys/big_key.c||security/keys/big_key.c": [
          "File: security/keys/big_key.c -> security/keys/big_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include <linux/shmem_fs.h>",
          "17: #include <linux/err.h>",
          "18: #include <linux/scatterlist.h>",
          "19: #include <keys/user-type.h>",
          "20: #include <keys/big_key-type.h>",
          "",
          "[Removed Lines]",
          "21: #include <crypto/rng.h>",
          "22: #include <crypto/skcipher.h>",
          "",
          "[Added Lines]",
          "20: #include <linux/random.h>",
          "23: #include <crypto/aead.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "52: #define ENC_KEY_SIZE 16",
          "",
          "[Added Lines]",
          "53: #define ENC_KEY_SIZE 32",
          "58: #define ENC_AUTHTAG_SIZE 16",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:  .destroy  = big_key_destroy,",
          "65:  .describe  = big_key_describe,",
          "66:  .read   = big_key_read,",
          "67: };",
          "92: static int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)",
          "93: {",
          "95:  struct scatterlist sgio;",
          "99:   ret = -EAGAIN;",
          "100:   goto error;",
          "101:  }",
          "110:  if (op == BIG_KEY_ENC)",
          "112:  else",
          "117: error:",
          "118:  return ret;",
          "119: }",
          "",
          "[Removed Lines]",
          "72: static const char big_key_rng_name[] = \"stdrng\";",
          "73: static const char big_key_alg_name[] = \"ecb(aes)\";",
          "78: static struct crypto_rng *big_key_rng;",
          "79: static struct crypto_skcipher *big_key_skcipher;",
          "84: static inline int big_key_gen_enckey(u8 *key)",
          "85: {",
          "86:  return crypto_rng_get_bytes(big_key_rng, key, ENC_KEY_SIZE);",
          "87: }",
          "94:  int ret = -EINVAL;",
          "96:  SKCIPHER_REQUEST_ON_STACK(req, big_key_skcipher);",
          "98:  if (crypto_skcipher_setkey(big_key_skcipher, key, ENC_KEY_SIZE)) {",
          "103:  skcipher_request_set_tfm(req, big_key_skcipher);",
          "104:  skcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,",
          "105:           NULL, NULL);",
          "107:  sg_init_one(&sgio, data, datalen);",
          "108:  skcipher_request_set_crypt(req, &sgio, &sgio, datalen, NULL);",
          "111:   ret = crypto_skcipher_encrypt(req);",
          "113:   ret = crypto_skcipher_decrypt(req);",
          "115:  skcipher_request_zero(req);",
          "",
          "[Added Lines]",
          "79: static const char big_key_alg_name[] = \"gcm(aes)\";",
          "84: static struct crypto_aead *big_key_aead;",
          "89: static DEFINE_MUTEX(big_key_aead_lock);",
          "96:  int ret;",
          "98:  struct aead_request *aead_req;",
          "105:  u8 zero_nonce[crypto_aead_ivsize(big_key_aead)];",
          "107:  aead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);",
          "108:  if (!aead_req)",
          "109:   return -ENOMEM;",
          "111:  memset(zero_nonce, 0, sizeof(zero_nonce));",
          "112:  sg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));",
          "113:  aead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);",
          "114:  aead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);",
          "115:  aead_request_set_ad(aead_req, 0);",
          "117:  mutex_lock(&big_key_aead_lock);",
          "118:  if (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {",
          "123:   ret = crypto_aead_encrypt(aead_req);",
          "125:   ret = crypto_aead_decrypt(aead_req);",
          "127:  mutex_unlock(&big_key_aead_lock);",
          "128:  aead_request_free(aead_req);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:   loff_t pos = 0;",
          "153:   data = kmalloc(enclen, GFP_KERNEL);",
          "154:   if (!data)",
          "155:    return -ENOMEM;",
          "157:   memcpy(data, prep->data, datalen);",
          "161:   enckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "149:   size_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));",
          "158:   memset(data + datalen, 0x00, enclen - datalen);",
          "",
          "[Added Lines]",
          "160:   size_t enclen = datalen + ENC_AUTHTAG_SIZE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "163:    ret = -ENOMEM;",
          "164:    goto error;",
          "165:   }",
          "169:    goto err_enckey;",
          "173:   if (ret)",
          "174:    goto err_enckey;",
          "",
          "[Removed Lines]",
          "167:   ret = big_key_gen_enckey(enckey);",
          "168:   if (ret)",
          "172:   ret = big_key_crypt(BIG_KEY_ENC, data, enclen, enckey);",
          "",
          "[Added Lines]",
          "174:   ret = get_random_bytes_wait(enckey, ENC_KEY_SIZE);",
          "175:   if (unlikely(ret))",
          "179:   ret = big_key_crypt(BIG_KEY_ENC, data, datalen, enckey);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "295:   struct file *file;",
          "296:   u8 *data;",
          "297:   u8 *enckey = (u8 *)key->payload.data[big_key_data];",
          "299:   loff_t pos = 0;",
          "301:   data = kmalloc(enclen, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "298:   size_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));",
          "",
          "[Added Lines]",
          "305:   size_t enclen = datalen + ENC_AUTHTAG_SIZE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "345: static int __init big_key_init(void)",
          "346: {",
          "349:  int ret;",
          "370:   pr_err(\"Can't alloc crypto: %d\\n\", ret);",
          "372:  }",
          "376:  ret = register_key_type(&key_type_big_key);",
          "377:  if (ret < 0) {",
          "378:   pr_err(\"Can't register type: %d\\n\", ret);",
          "380:  }",
          "382:  return 0;",
          "388:  return ret;",
          "389: }",
          "",
          "[Removed Lines]",
          "347:  struct crypto_skcipher *cipher;",
          "348:  struct crypto_rng *rng;",
          "351:  rng = crypto_alloc_rng(big_key_rng_name, 0, 0);",
          "352:  if (IS_ERR(rng)) {",
          "353:   pr_err(\"Can't alloc rng: %ld\\n\", PTR_ERR(rng));",
          "354:   return PTR_ERR(rng);",
          "355:  }",
          "357:  big_key_rng = rng;",
          "360:  ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));",
          "361:  if (ret) {",
          "362:   pr_err(\"Can't reset rng: %d\\n\", ret);",
          "363:   goto error_rng;",
          "364:  }",
          "367:  cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);",
          "368:  if (IS_ERR(cipher)) {",
          "369:   ret = PTR_ERR(cipher);",
          "371:   goto error_rng;",
          "374:  big_key_skcipher = cipher;",
          "379:   goto error_cipher;",
          "384: error_cipher:",
          "385:  crypto_free_skcipher(big_key_skcipher);",
          "386: error_rng:",
          "387:  crypto_free_rng(big_key_rng);",
          "",
          "[Added Lines]",
          "357:  big_key_aead = crypto_alloc_aead(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);",
          "358:  if (IS_ERR(big_key_aead)) {",
          "359:   ret = PTR_ERR(big_key_aead);",
          "361:   return ret;",
          "362:  }",
          "363:  ret = crypto_aead_setauthsize(big_key_aead, ENC_AUTHTAG_SIZE);",
          "364:  if (ret < 0) {",
          "365:   pr_err(\"Can't set crypto auth tag len: %d\\n\", ret);",
          "366:   goto free_aead;",
          "372:   goto free_aead;",
          "377: free_aead:",
          "378:  crypto_free_aead(big_key_aead);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d56d72c6a0612be14ccb455c92886d2cb102c2ab",
      "candidate_info": {
        "commit_hash": "d56d72c6a0612be14ccb455c92886d2cb102c2ab",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d56d72c6a0612be14ccb455c92886d2cb102c2ab",
        "files": [
          "security/keys/big_key.c"
        ],
        "message": "KEYS: Use skcipher for big keys\n\nThis patch replaces use of the obsolete blkcipher with skcipher.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nAcked-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "security/keys/big_key.c||security/keys/big_key.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "security/keys/big_key.c||security/keys/big_key.c"
          ],
          "candidate": [
            "security/keys/big_key.c||security/keys/big_key.c"
          ]
        }
      },
      "candidate_diff": {
        "security/keys/big_key.c||security/keys/big_key.c": [
          "File: security/keys/big_key.c -> security/keys/big_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <keys/user-type.h>",
          "19: #include <keys/big_key-type.h>",
          "20: #include <crypto/rng.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <crypto/skcipher.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76: static struct crypto_rng *big_key_rng;",
          "",
          "[Removed Lines]",
          "77: static struct crypto_blkcipher *big_key_blkcipher;",
          "",
          "[Added Lines]",
          "78: static struct crypto_skcipher *big_key_skcipher;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "91: {",
          "92:  int ret = -EINVAL;",
          "93:  struct scatterlist sgio;",
          "97:   ret = -EAGAIN;",
          "98:   goto error;",
          "99:  }",
          "104:  sg_init_one(&sgio, data, datalen);",
          "106:  if (op == BIG_KEY_ENC)",
          "108:  else",
          "111: error:",
          "112:  return ret;",
          "",
          "[Removed Lines]",
          "94:  struct blkcipher_desc desc;",
          "96:  if (crypto_blkcipher_setkey(big_key_blkcipher, key, ENC_KEY_SIZE)) {",
          "101:  desc.flags = 0;",
          "102:  desc.tfm = big_key_blkcipher;",
          "107:   ret = crypto_blkcipher_encrypt(&desc, &sgio, &sgio, datalen);",
          "109:   ret = crypto_blkcipher_decrypt(&desc, &sgio, &sgio, datalen);",
          "",
          "[Added Lines]",
          "95:  SKCIPHER_REQUEST_ON_STACK(req, big_key_skcipher);",
          "97:  if (crypto_skcipher_setkey(big_key_skcipher, key, ENC_KEY_SIZE)) {",
          "102:  skcipher_request_set_tfm(req, big_key_skcipher);",
          "103:  skcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,",
          "104:           NULL, NULL);",
          "107:  skcipher_request_set_crypt(req, &sgio, &sgio, datalen, NULL);",
          "110:   ret = crypto_skcipher_encrypt(req);",
          "112:   ret = crypto_skcipher_decrypt(req);",
          "114:  skcipher_request_zero(req);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "146:   data = kmalloc(enclen, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "143:   size_t enclen = ALIGN(datalen, crypto_blkcipher_blocksize(big_key_blkcipher));",
          "",
          "[Added Lines]",
          "148:   size_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "288:   struct file *file;",
          "289:   u8 *data;",
          "290:   u8 *enckey = (u8 *)key->payload.data[big_key_data];",
          "293:   data = kmalloc(enclen, GFP_KERNEL);",
          "294:   if (!data)",
          "",
          "[Removed Lines]",
          "291:   size_t enclen = ALIGN(datalen, crypto_blkcipher_blocksize(big_key_blkcipher));",
          "",
          "[Added Lines]",
          "296:   size_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "359:   goto error;",
          "365:   ret = -EFAULT;",
          "366:   goto error;",
          "367:  }",
          "",
          "[Removed Lines]",
          "362:  big_key_blkcipher = crypto_alloc_blkcipher(big_key_alg_name, 0, 0);",
          "363:  if (IS_ERR(big_key_blkcipher)) {",
          "364:   big_key_blkcipher = NULL;",
          "",
          "[Added Lines]",
          "367:  big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,",
          "368:        0, CRYPTO_ALG_ASYNC);",
          "369:  if (IS_ERR(big_key_skcipher)) {",
          "370:   big_key_skcipher = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "13100a72f40f5748a04017e0ab3df4cf27c809ef",
      "candidate_info": {
        "commit_hash": "13100a72f40f5748a04017e0ab3df4cf27c809ef",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/13100a72f40f5748a04017e0ab3df4cf27c809ef",
        "files": [
          "security/keys/Kconfig",
          "security/keys/big_key.c"
        ],
        "message": "Security: Keys: Big keys stored encrypted\n\nSolved TODO task: big keys saved to shmem file are now stored encrypted.\nThe encryption key is randomly generated and saved to payload[big_key_data].\n\nSigned-off-by: Kirill Marinushkin <k.marinushkin@gmail.com>\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "security/keys/big_key.c||security/keys/big_key.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "security/keys/big_key.c||security/keys/big_key.c"
          ],
          "candidate": [
            "security/keys/big_key.c||security/keys/big_key.c"
          ]
        }
      },
      "candidate_diff": {
        "security/keys/big_key.c||security/keys/big_key.c": [
          "File: security/keys/big_key.c -> security/keys/big_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include <linux/file.h>",
          "15: #include <linux/shmem_fs.h>",
          "16: #include <linux/err.h>",
          "17: #include <keys/user-type.h>",
          "18: #include <keys/big_key-type.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #include <linux/scatterlist.h>",
          "20: #include <crypto/rng.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27:  big_key_len,",
          "28: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: enum big_key_op {",
          "36:  BIG_KEY_ENC,",
          "37:  BIG_KEY_DEC,",
          "38: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "35: #define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: #define ENC_KEY_SIZE 16",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "49:  .read   = big_key_read,",
          "50: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: static const char big_key_rng_name[] = \"stdrng\";",
          "71: static const char big_key_alg_name[] = \"ecb(aes)\";",
          "76: static struct crypto_rng *big_key_rng;",
          "77: static struct crypto_blkcipher *big_key_blkcipher;",
          "82: static inline int big_key_gen_enckey(u8 *key)",
          "83: {",
          "84:  return crypto_rng_get_bytes(big_key_rng, key, ENC_KEY_SIZE);",
          "85: }",
          "90: static int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)",
          "91: {",
          "92:  int ret = -EINVAL;",
          "93:  struct scatterlist sgio;",
          "94:  struct blkcipher_desc desc;",
          "96:  if (crypto_blkcipher_setkey(big_key_blkcipher, key, ENC_KEY_SIZE)) {",
          "97:   ret = -EAGAIN;",
          "98:   goto error;",
          "99:  }",
          "101:  desc.flags = 0;",
          "102:  desc.tfm = big_key_blkcipher;",
          "104:  sg_init_one(&sgio, data, datalen);",
          "106:  if (op == BIG_KEY_ENC)",
          "107:   ret = crypto_blkcipher_encrypt(&desc, &sgio, &sgio, datalen);",
          "108:  else",
          "109:   ret = crypto_blkcipher_decrypt(&desc, &sgio, &sgio, datalen);",
          "111: error:",
          "112:  return ret;",
          "113: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "56: {",
          "57:  struct path *path = (struct path *)&prep->payload.data[big_key_path];",
          "58:  struct file *file;",
          "59:  ssize_t written;",
          "60:  size_t datalen = prep->datalen;",
          "61:  int ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:  u8 *enckey;",
          "123:  u8 *data = NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "79:   if (IS_ERR(file)) {",
          "80:    ret = PTR_ERR(file);",
          "82:   }",
          "86:    ret = written;",
          "87:    if (written >= 0)",
          "88:     ret = -ENOMEM;",
          "",
          "[Removed Lines]",
          "78:   file = shmem_kernel_file_setup(\"\", datalen, 0);",
          "81:    goto error;",
          "84:   written = kernel_write(file, prep->data, prep->datalen, 0);",
          "85:   if (written != datalen) {",
          "",
          "[Added Lines]",
          "143:   size_t enclen = ALIGN(datalen, crypto_blkcipher_blocksize(big_key_blkcipher));",
          "146:   data = kmalloc(enclen, GFP_KERNEL);",
          "147:   if (!data)",
          "148:    return -ENOMEM;",
          "150:   memcpy(data, prep->data, datalen);",
          "151:   memset(data + datalen, 0x00, enclen - datalen);",
          "154:   enckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);",
          "155:   if (!enckey) {",
          "156:    ret = -ENOMEM;",
          "157:    goto error;",
          "158:   }",
          "160:   ret = big_key_gen_enckey(enckey);",
          "161:   if (ret)",
          "162:    goto err_enckey;",
          "165:   ret = big_key_crypt(BIG_KEY_ENC, data, enclen, enckey);",
          "166:   if (ret)",
          "167:    goto err_enckey;",
          "170:   file = shmem_kernel_file_setup(\"\", enclen, 0);",
          "173:    goto err_enckey;",
          "176:   written = kernel_write(file, data, enclen, 0);",
          "177:   if (written != enclen) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "96:   path_get(path);",
          "97:   fput(file);",
          "98:  } else {",
          "100:   void *data = kmalloc(datalen, GFP_KERNEL);",
          "101:   if (!data)",
          "102:    return -ENOMEM;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187:   prep->payload.data[big_key_data] = enckey;",
          "191:   kfree(data);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "109: err_fput:",
          "110:  fput(file);",
          "111: error:",
          "112:  return ret;",
          "113: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206: err_enckey:",
          "207:  kfree(enckey);",
          "209:  kfree(data);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "119: {",
          "120:  if (prep->datalen > BIG_KEY_FILE_THRESHOLD) {",
          "121:   struct path *path = (struct path *)&prep->payload.data[big_key_path];",
          "122:   path_put(path);",
          "125:  }",
          "126: }",
          "",
          "[Removed Lines]",
          "123:  } else {",
          "124:   kfree(prep->payload.data[big_key_data]);",
          "",
          "[Added Lines]",
          "223:  kfree(prep->payload.data[big_key_data]);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "147: {",
          "148:  size_t datalen = (size_t)key->payload.data[big_key_len];",
          "151:   struct path *path = (struct path *)&key->payload.data[big_key_path];",
          "152:   path_put(path);",
          "153:   path->mnt = NULL;",
          "154:   path->dentry = NULL;",
          "158:  }",
          "159: }",
          "",
          "[Removed Lines]",
          "150:  if (datalen) {",
          "155:  } else {",
          "156:   kfree(key->payload.data[big_key_data]);",
          "157:   key->payload.data[big_key_data] = NULL;",
          "",
          "[Added Lines]",
          "248:  if (datalen > BIG_KEY_FILE_THRESHOLD) {",
          "255:  kfree(key->payload.data[big_key_data]);",
          "256:  key->payload.data[big_key_data] = NULL;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "188:  if (datalen > BIG_KEY_FILE_THRESHOLD) {",
          "189:   struct path *path = (struct path *)&key->payload.data[big_key_path];",
          "190:   struct file *file;",
          "193:   file = dentry_open(path, O_RDONLY, current_cred());",
          "201:    ret = -EIO;",
          "202:  } else {",
          "203:   ret = datalen;",
          "204:   if (copy_to_user(buffer, key->payload.data[big_key_data],",
          "",
          "[Removed Lines]",
          "191:   loff_t pos;",
          "194:   if (IS_ERR(file))",
          "195:    return PTR_ERR(file);",
          "197:   pos = 0;",
          "198:   ret = vfs_read(file, buffer, datalen, &pos);",
          "199:   fput(file);",
          "200:   if (ret >= 0 && ret != datalen)",
          "",
          "[Added Lines]",
          "289:   u8 *data;",
          "290:   u8 *enckey = (u8 *)key->payload.data[big_key_data];",
          "291:   size_t enclen = ALIGN(datalen, crypto_blkcipher_blocksize(big_key_blkcipher));",
          "293:   data = kmalloc(enclen, GFP_KERNEL);",
          "294:   if (!data)",
          "295:    return -ENOMEM;",
          "298:   if (IS_ERR(file)) {",
          "299:    ret = PTR_ERR(file);",
          "300:    goto error;",
          "301:   }",
          "304:   ret = kernel_read(file, 0, data, enclen);",
          "305:   if (ret >= 0 && ret != enclen) {",
          "307:    goto err_fput;",
          "308:   }",
          "310:   ret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);",
          "311:   if (ret)",
          "312:    goto err_fput;",
          "314:   ret = datalen;",
          "317:   if (copy_to_user(buffer, data, datalen) != 0)",
          "318:    ret = -EFAULT;",
          "320: err_fput:",
          "321:   fput(file);",
          "322: error:",
          "323:   kfree(data);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "209:  return ret;",
          "210: }",
          "212: static int __init big_key_init(void)",
          "213: {",
          "214:  return register_key_type(&key_type_big_key);",
          "215: }",
          "216: device_initcall(big_key_init);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345: static int __init big_key_crypto_init(void)",
          "346: {",
          "347:  int ret = -EINVAL;",
          "350:  big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);",
          "351:  if (IS_ERR(big_key_rng)) {",
          "352:   big_key_rng = NULL;",
          "353:   return -EFAULT;",
          "354:  }",
          "357:  ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));",
          "358:  if (ret)",
          "359:   goto error;",
          "362:  big_key_blkcipher = crypto_alloc_blkcipher(big_key_alg_name, 0, 0);",
          "363:  if (IS_ERR(big_key_blkcipher)) {",
          "364:   big_key_blkcipher = NULL;",
          "365:   ret = -EFAULT;",
          "366:   goto error;",
          "367:  }",
          "369:  return 0;",
          "371: error:",
          "372:  crypto_free_rng(big_key_rng);",
          "373:  big_key_rng = NULL;",
          "374:  return ret;",
          "375: }",
          "378: late_initcall(big_key_crypto_init);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
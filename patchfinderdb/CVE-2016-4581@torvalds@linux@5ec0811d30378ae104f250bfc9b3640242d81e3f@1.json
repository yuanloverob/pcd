{
  "cve_id": "CVE-2016-4581",
  "cve_desc": "fs/pnode.c in the Linux kernel before 4.5.4 does not properly traverse a mount propagation tree in a certain case involving a slave mount, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted series of mount system calls.",
  "repo": "torvalds/linux",
  "patch_hash": "5ec0811d30378ae104f250bfc9b3640242d81e3f",
  "patch_info": {
    "commit_hash": "5ec0811d30378ae104f250bfc9b3640242d81e3f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5ec0811d30378ae104f250bfc9b3640242d81e3f",
    "files": [
      "fs/pnode.c"
    ],
    "message": "propogate_mnt: Handle the first propogated copy being a slave\n\nWhen the first propgated copy was a slave the following oops would result:\n> BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n> IP: [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> PGD bacd4067 PUD bac66067 PMD 0\n> Oops: 0000 [#1] SMP\n> Modules linked in:\n> CPU: 1 PID: 824 Comm: mount Not tainted 4.6.0-rc5userns+ #1523\n> Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007\n> task: ffff8800bb0a8000 ti: ffff8800bac3c000 task.ti: ffff8800bac3c000\n> RIP: 0010:[<ffffffff811fba4e>]  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> RSP: 0018:ffff8800bac3fd38  EFLAGS: 00010283\n> RAX: 0000000000000000 RBX: ffff8800bb77ec00 RCX: 0000000000000010\n> RDX: 0000000000000000 RSI: ffff8800bb58c000 RDI: ffff8800bb58c480\n> RBP: ffff8800bac3fd48 R08: 0000000000000001 R09: 0000000000000000\n> R10: 0000000000001ca1 R11: 0000000000001c9d R12: 0000000000000000\n> R13: ffff8800ba713800 R14: ffff8800bac3fda0 R15: ffff8800bb77ec00\n> FS:  00007f3c0cd9b7e0(0000) GS:ffff8800bfb00000(0000) knlGS:0000000000000000\n> CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n> CR2: 0000000000000010 CR3: 00000000bb79d000 CR4: 00000000000006e0\n> Stack:\n>  ffff8800bb77ec00 0000000000000000 ffff8800bac3fd88 ffffffff811fbf85\n>  ffff8800bac3fd98 ffff8800bb77f080 ffff8800ba713800 ffff8800bb262b40\n>  0000000000000000 0000000000000000 ffff8800bac3fdd8 ffffffff811f1da0\n> Call Trace:\n>  [<ffffffff811fbf85>] propagate_mnt+0x105/0x140\n>  [<ffffffff811f1da0>] attach_recursive_mnt+0x120/0x1e0\n>  [<ffffffff811f1ec3>] graft_tree+0x63/0x70\n>  [<ffffffff811f1f6b>] do_add_mount+0x9b/0x100\n>  [<ffffffff811f2c1a>] do_mount+0x2aa/0xdf0\n>  [<ffffffff8117efbe>] ? strndup_user+0x4e/0x70\n>  [<ffffffff811f3a45>] SyS_mount+0x75/0xc0\n>  [<ffffffff8100242b>] do_syscall_64+0x4b/0xa0\n>  [<ffffffff81988f3c>] entry_SYSCALL64_slow_path+0x25/0x25\n> Code: 00 00 75 ec 48 89 0d 02 22 22 01 8b 89 10 01 00 00 48 89 05 fd 21 22 01 39 8e 10 01 00 00 0f 84 e0 00 00 00 48 8b 80 d8 00 00 00 <48> 8b 50 10 48 89 05 df 21 22 01 48 89 15 d0 21 22 01 8b 53 30\n> RIP  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n>  RSP <ffff8800bac3fd38>\n> CR2: 0000000000000010\n> ---[ end trace 2725ecd95164f217 ]---\n\nThis oops happens with the namespace_sem held and can be triggered by\nnon-root users.  An all around not pleasant experience.\n\nTo avoid this scenario when finding the appropriate source mount to\ncopy stop the walk up the mnt_master chain when the first source mount\nis encountered.\n\nFurther rewrite the walk up the last_source mnt_master chain so that\nit is clear what is going on.\n\nThe reason why the first source mount is special is that it it's\nmnt_parent is not a mount in the dest_mnt propagation tree, and as\nsuch termination conditions based up on the dest_mnt mount propgation\ntree do not make sense.\n\nTo avoid other kinds of confusion last_dest is not changed when\ncomputing last_source.  last_dest is only used once in propagate_one\nand that is above the point of the code being modified, so changing\nthe global variable is meaningless and confusing.\n\nCc: stable@vger.kernel.org\nfixes: f2ebb3a921c1ca1e2ddd9242e95a1989a50c4c68 (\"smarter propagate_mnt()\")\nReported-by: Tycho Andersen <tycho.andersen@canonical.com>\nReviewed-by: Seth Forshee <seth.forshee@canonical.com>\nTested-by: Seth Forshee <seth.forshee@canonical.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "fs/pnode.c||fs/pnode.c"
    ]
  },
  "patch_diff": {
    "fs/pnode.c||fs/pnode.c": [
      "File: fs/pnode.c -> fs/pnode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "200: static struct user_namespace *user_ns;",
      "202: static struct mountpoint *mp;",
      "203: static struct hlist_head *list;",
      "",
      "[Removed Lines]",
      "201: static struct mount *last_dest, *last_source, *dest_master;",
      "",
      "[Added Lines]",
      "201: static struct mount *last_dest, *first_source, *last_source, *dest_master;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "221:   type = CL_MAKE_SHARED;",
      "222:  } else {",
      "223:   struct mount *n, *p;",
      "224:   for (n = m; ; n = p) {",
      "225:    p = n->mnt_master;",
      "235:     break;",
      "237:   }",
      "238:   type = CL_SLAVE;",
      "240:   if (IS_MNT_SHARED(m))",
      "",
      "[Removed Lines]",
      "226:    if (p == dest_master || IS_MNT_MARKED(p)) {",
      "227:     while (last_dest->mnt_master != p) {",
      "228:      last_source = last_source->mnt_master;",
      "229:      last_dest = last_source->mnt_parent;",
      "230:     }",
      "231:     if (!peers(n, last_dest)) {",
      "232:      last_source = last_source->mnt_master;",
      "233:      last_dest = last_source->mnt_parent;",
      "234:     }",
      "236:    }",
      "",
      "[Added Lines]",
      "224:   bool done;",
      "227:    if (p == dest_master || IS_MNT_MARKED(p))",
      "230:   do {",
      "231:    struct mount *parent = last_source->mnt_parent;",
      "232:    if (last_source == first_source)",
      "233:     break;",
      "234:    done = parent->mnt_master == p;",
      "235:    if (done && peers(n, parent))",
      "236:     break;",
      "237:    last_source = last_source->mnt_master;",
      "238:   } while (!done);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "287:  user_ns = current->nsproxy->mnt_ns->user_ns;",
      "288:  last_dest = dest_mnt;",
      "289:  last_source = source_mnt;",
      "290:  mp = dest_mp;",
      "291:  list = tree_list;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291:  first_source = source_mnt;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fa0c879ffc869e2597364c72080fd4756a96e99a",
      "candidate_info": {
        "commit_hash": "fa0c879ffc869e2597364c72080fd4756a96e99a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fa0c879ffc869e2597364c72080fd4756a96e99a",
        "files": [
          "arch/mips/oprofile/common.c"
        ],
        "message": "MIPS: oprofile: Fix a preemption issue\n\nUse boot_cpu_type() instead of current_cpu_type() in oprofile_arch_init()\nto avoid the below warning, cpu_type is normally consistent in a MIPS SMP\nsystem.  There are a few exceptions such as SGI servers where it is\npossible to mix R10000, R12000, R14000 and R16000 within certain\nconstraints.  Let's not worry about those now.\n\nBUG: using smp_processor_id() in preemptible [00000000] code: insmod/952\ncaller is oprofile_arch_init+0x30/0x194 [oprofile]\nCPU: 5 PID: 952 Comm: insmod Not tainted 4.1.13-WR8.0.0.0_standard #1\nStack : ffffffff80c10000 0000000000000001 8000000025bf0790 ffffffff80e10000\n\t  ffffffff80e50000 ffffffff80254e2c ffffffff80b64428 ffffffff80e10790\n\t  0000000000000000 ffffffff801caeb8 0000000000000045 0000000000000005\n\t  ffffffff80c10000 ffffffff801cb798 0000000000000000 ffffffff80e30000\n\t  0000000000000000 ffffffff801ff1c0 ffffffff80e2d2f8 000000000000000b\n\t  ffffffff801cbba0 ffffffff80e107b0 ffffffff80a77828 0000000000000005\n\t  00000000000003b8 ffffffff80e2d2f8 800000040ad39960 ffffffff801f9950\n\t  0000000000000124 80000004093b7990 80000004093b7ab8 ffffffff80925108\n\t  ffffffff80b69a07 ffffffff80a6f0d0 8000000407240e00 ffffffff801cc934\n\t  000000000000005d ffffffff80159080 0000000000000005 00000000000003b8\n\t  ...\nCall Trace:\n[<ffffffff80159080>] show_stack+0xe8/0x108\n[<ffffffff80925108>] dump_stack+0x8c/0xd8\n[<ffffffff80606570>] check_preemption_disabled+0x110/0x118\n[<ffffffffc0086104>] oprofile_arch_init+0x30/0x194 [oprofile]\n[<ffffffffc008602c>] oprofile_init+0x2c/0xc0 [oprofile]\n[<ffffffff80100550>] do_one_initcall+0xa0/0x1c0\n[<ffffffff80921e04>] do_init_module+0x80/0x1d8\n[<ffffffff801fd0d4>] load_module+0x1b74/0x2278\n[<ffffffff801fdab4>] SyS_finit_module+0xcc/0xf0\n[<ffffffff80165884>] handle_sysn32+0x44/0x70\n\n[ralf@linux-mips.org: Correct commit message.]\n\nSigned-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>\nCc: rric@kernel.org\nCc: jinyanjiang@gmail.com\nCc: linux-mips@linux-mips.org\nCc: oprofile-list@lists.sf.net\nCc: linux-kernel@vger.kernel.org\nPatchwork: https://patchwork.linux-mips.org/patch/11769/\nSigned-off-by: Ralf Baechle <ralf@linux-mips.org>",
        "before_after_code_files": [
          "arch/mips/oprofile/common.c||arch/mips/oprofile/common.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/mips/oprofile/common.c||arch/mips/oprofile/common.c": [
          "File: arch/mips/oprofile/common.c -> arch/mips/oprofile/common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:  struct op_mips_model *lmodel = NULL;",
          "78:  int res;",
          "81:  case CPU_5KC:",
          "82:  case CPU_M14KC:",
          "83:  case CPU_M14KEC:",
          "",
          "[Removed Lines]",
          "80:  switch (current_cpu_type()) {",
          "",
          "[Added Lines]",
          "80:  switch (boot_cpu_type()) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f942380c12394002efe0ca0be023e0f6fafbf29b",
      "candidate_info": {
        "commit_hash": "f942380c12394002efe0ca0be023e0f6fafbf29b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f942380c12394002efe0ca0be023e0f6fafbf29b",
        "files": [
          "drivers/net/ethernet/mellanox/mlx5/core/en_main.c",
          "drivers/net/ethernet/mellanox/mlx5/core/eswitch.c",
          "drivers/net/ethernet/mellanox/mlx5/core/eswitch.h"
        ],
        "message": "net/mlx5: E-Switch, Vport ingress/egress ACLs rules for spoofchk\n\nConfigure ingress and egress vport ACL rules according to spoofchk\nadmin parameters.\n\nIngress ACL flow table rules:\nif (!spoofchk && !vst) allow all traffic.\nelse :\n1) one of the following rules :\n* if (spoofchk && vst) allow only untagged traffic with smac=original\nmac sent from the VF.\n* if (spoofchk && !vst) allow only traffic with smac=original mac sent\nfrom the VF.\n* if (!spoofchk && vst) allow only untagged traffic.\n2) drop all traffic that didn't hit #1.\n\nAdd support for set vf spoofchk ndo.\n\nAdd non zero mac validation in case of spoofchk to set mac ndo:\nwhen setting new mac we need to validate that the new mac is\nnot zero while the spoofchk is on because it is illegal\ncombination.\n\nSigned-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>\nSigned-off-by: Saeed Mahameed <saeedm@mellanox.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/mellanox/mlx5/core/en_main.c||drivers/net/ethernet/mellanox/mlx5/core/en_main.c",
          "drivers/net/ethernet/mellanox/mlx5/core/eswitch.c||drivers/net/ethernet/mellanox/mlx5/core/eswitch.c",
          "drivers/net/ethernet/mellanox/mlx5/core/eswitch.h||drivers/net/ethernet/mellanox/mlx5/core/eswitch.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/mellanox/mlx5/core/en_main.c||drivers/net/ethernet/mellanox/mlx5/core/en_main.c": [
          "File: drivers/net/ethernet/mellanox/mlx5/core/en_main.c -> drivers/net/ethernet/mellanox/mlx5/core/en_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2438:         vlan, qos);",
          "2439: }",
          "2441: static int mlx5_vport_link2ifla(u8 esw_link)",
          "2442: {",
          "2443:  switch (esw_link) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2441: static int mlx5e_set_vf_spoofchk(struct net_device *dev, int vf, bool setting)",
          "2442: {",
          "2443:  struct mlx5e_priv *priv = netdev_priv(dev);",
          "2444:  struct mlx5_core_dev *mdev = priv->mdev;",
          "2446:  return mlx5_eswitch_set_vport_spoofchk(mdev->priv.eswitch, vf + 1, setting);",
          "2447: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2607: #endif",
          "2608:  .ndo_set_vf_mac          = mlx5e_set_vf_mac,",
          "2609:  .ndo_set_vf_vlan         = mlx5e_set_vf_vlan,",
          "2610:  .ndo_get_vf_config       = mlx5e_get_vf_config,",
          "2611:  .ndo_set_vf_link_state   = mlx5e_set_vf_link_state,",
          "2612:  .ndo_get_vf_stats        = mlx5e_get_vf_stats,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2618:  .ndo_set_vf_spoofchk     = mlx5e_set_vf_spoofchk,",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/mellanox/mlx5/core/eswitch.c||drivers/net/ethernet/mellanox/mlx5/core/eswitch.c": [
          "File: drivers/net/ethernet/mellanox/mlx5/core/eswitch.c -> drivers/net/ethernet/mellanox/mlx5/core/eswitch.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "951: {",
          "952:  if (!IS_ERR_OR_NULL(vport->ingress.drop_rule))",
          "953:   mlx5_del_flow_rule(vport->ingress.drop_rule);",
          "954:  vport->ingress.drop_rule = NULL;",
          "955: }",
          "957: static void esw_vport_disable_ingress_acl(struct mlx5_eswitch *esw,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "955:  if (!IS_ERR_OR_NULL(vport->ingress.allow_rule))",
          "956:   mlx5_del_flow_rule(vport->ingress.allow_rule);",
          "959:  vport->ingress.allow_rule = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "978: static int esw_vport_ingress_config(struct mlx5_eswitch *esw,",
          "979:         struct mlx5_vport *vport)",
          "980: {",
          "981:  u32 *match_v;",
          "982:  u32 *match_c;",
          "983:  int err = 0;",
          "985:  if (IS_ERR_OR_NULL(vport->ingress.acl)) {",
          "986:   esw_warn(esw->dev,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "986:  u8 smac[ETH_ALEN];",
          "990:  u8 *smac_v;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "989:   return -EPERM;",
          "990:  }",
          "992:  esw_vport_cleanup_ingress_rules(esw, vport);",
          "995:   return 0;",
          "997:  esw_debug(esw->dev,",
          "",
          "[Removed Lines]",
          "994:  if (!vport->vlan && !vport->qos)",
          "",
          "[Added Lines]",
          "999:  if (vport->spoofchk) {",
          "1000:   err = mlx5_query_nic_vport_mac_address(esw->dev, vport->vport, smac);",
          "1001:   if (err) {",
          "1002:    esw_warn(esw->dev,",
          "1003:      \"vport[%d] configure ingress rules failed, query smac failed, err(%d)\\n\",",
          "1004:      vport->vport, err);",
          "1005:    return err;",
          "1006:   }",
          "1008:   if (!is_valid_ether_addr(smac)) {",
          "1009:    mlx5_core_warn(esw->dev,",
          "1010:            \"vport[%d] configure ingress rules failed, illegal mac with spoofchk\\n\",",
          "1011:            vport->vport);",
          "1012:    return -EPERM;",
          "1013:   }",
          "1014:  }",
          "1018:  if (!vport->vlan && !vport->qos && !vport->spoofchk)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1006:     vport->vport, err);",
          "1007:   goto out;",
          "1008:  }",
          "1013:   mlx5_add_flow_rule(vport->ingress.acl,",
          "1014:        MLX5_MATCH_OUTER_HEADERS,",
          "1015:        match_c,",
          "1016:        match_v,",
          "1017:        MLX5_FLOW_CONTEXT_ACTION_DROP,",
          "1018:        0, NULL);",
          "1019:  if (IS_ERR_OR_NULL(vport->ingress.drop_rule)) {",
          "1020:   err = PTR_ERR(vport->ingress.drop_rule);",
          "1022:    vport->vport, err);",
          "1023:   vport->ingress.drop_rule = NULL;",
          "1024:  }",
          "1025: out:",
          "1026:  kfree(match_v);",
          "1027:  kfree(match_c);",
          "1028:  return err;",
          "",
          "[Removed Lines]",
          "1009:  MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.vlan_tag);",
          "1010:  MLX5_SET_TO_ONES(fte_match_param, match_v, outer_headers.vlan_tag);",
          "1012:  vport->ingress.drop_rule =",
          "1021:   pr_warn(\"vport[%d] configure ingress rules, err(%d)\\n\",",
          "",
          "[Added Lines]",
          "1034:  if (vport->vlan || vport->qos)",
          "1035:   MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.vlan_tag);",
          "1037:  if (vport->spoofchk) {",
          "1038:   MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.smac_47_16);",
          "1039:   MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.smac_15_0);",
          "1040:   smac_v = MLX5_ADDR_OF(fte_match_param,",
          "1041:           match_v,",
          "1042:           outer_headers.smac_47_16);",
          "1043:   ether_addr_copy(smac_v, smac);",
          "1044:  }",
          "1046:  vport->ingress.allow_rule =",
          "1051:        MLX5_FLOW_CONTEXT_ACTION_ALLOW,",
          "1052:        0, NULL);",
          "1053:  if (IS_ERR_OR_NULL(vport->ingress.allow_rule)) {",
          "1054:   err = PTR_ERR(vport->ingress.allow_rule);",
          "1055:   pr_warn(\"vport[%d] configure ingress allow rule, err(%d)\\n\",",
          "1056:    vport->vport, err);",
          "1057:   vport->ingress.allow_rule = NULL;",
          "1058:   goto out;",
          "1059:  }",
          "1061:  memset(match_c, 0, MLX5_ST_SZ_BYTES(fte_match_param));",
          "1062:  memset(match_v, 0, MLX5_ST_SZ_BYTES(fte_match_param));",
          "1063:  vport->ingress.drop_rule =",
          "1064:   mlx5_add_flow_rule(vport->ingress.acl,",
          "1065:        0,",
          "1066:        match_c,",
          "1067:        match_v,",
          "1072:   pr_warn(\"vport[%d] configure ingress drop rule, err(%d)\\n\",",
          "1075:   goto out;",
          "1079:  if (err)",
          "1080:   esw_vport_cleanup_ingress_rules(esw, vport);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1367:           int vport, u8 mac[ETH_ALEN])",
          "1368: {",
          "1369:  int err = 0;",
          "1371:  if (!ESW_ALLOWED(esw))",
          "1372:   return -EPERM;",
          "1373:  if (!LEGAL_VPORT(esw, vport))",
          "1374:   return -EINVAL;",
          "1376:  err = mlx5_modify_nic_vport_mac_address(esw->dev, vport, mac);",
          "1377:  if (err) {",
          "1378:   mlx5_core_warn(esw->dev,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1426:  struct mlx5_vport *evport;",
          "1433:  evport = &esw->vports[vport];",
          "1435:  if (evport->spoofchk && !is_valid_ether_addr(mac)) {",
          "1436:   mlx5_core_warn(esw->dev,",
          "1437:           \"MAC invalidation is not allowed when spoofchk is on, vport(%d)\\n\",",
          "1438:           vport);",
          "1439:   return -EPERM;",
          "1440:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1381:   return err;",
          "1382:  }",
          "1384:  return err;",
          "1385: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1450:  mutex_lock(&esw->state_lock);",
          "1451:  if (evport->enabled)",
          "1452:   err = esw_vport_ingress_config(esw, evport);",
          "1453:  mutex_unlock(&esw->state_lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1400: int mlx5_eswitch_get_vport_config(struct mlx5_eswitch *esw,",
          "1401:       int vport, struct ifla_vf_info *ivi)",
          "1402: {",
          "1403:  u16 vlan;",
          "1404:  u8 qos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1474:  struct mlx5_vport *evport;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1408:  if (!LEGAL_VPORT(esw, vport))",
          "1409:   return -EINVAL;",
          "1411:  memset(ivi, 0, sizeof(*ivi));",
          "1412:  ivi->vf = vport - 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1483:  evport = &esw->vports[vport];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1418:  query_esw_vport_cvlan(esw->dev, vport, &vlan, &qos);",
          "1419:  ivi->vlan = vlan;",
          "1420:  ivi->qos = qos;",
          "1423:  return 0;",
          "1424: }",
          "",
          "[Removed Lines]",
          "1421:  ivi->spoofchk = 0;",
          "",
          "[Added Lines]",
          "1495:  ivi->spoofchk = evport->spoofchk;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1459:  return err;",
          "1460: }",
          "1462: int mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,",
          "1463:      int vport,",
          "1464:      struct ifla_vf_stats *vf_stats)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1536: int mlx5_eswitch_set_vport_spoofchk(struct mlx5_eswitch *esw,",
          "1537:         int vport, bool spoofchk)",
          "1538: {",
          "1539:  struct mlx5_vport *evport;",
          "1540:  bool pschk;",
          "1541:  int err = 0;",
          "1543:  if (!ESW_ALLOWED(esw))",
          "1544:   return -EPERM;",
          "1545:  if (!LEGAL_VPORT(esw, vport))",
          "1546:   return -EINVAL;",
          "1548:  evport = &esw->vports[vport];",
          "1550:  mutex_lock(&esw->state_lock);",
          "1551:  pschk = evport->spoofchk;",
          "1552:  evport->spoofchk = spoofchk;",
          "1553:  if (evport->enabled)",
          "1554:   err = esw_vport_ingress_config(esw, evport);",
          "1555:  if (err)",
          "1556:   evport->spoofchk = pschk;",
          "1557:  mutex_unlock(&esw->state_lock);",
          "1559:  return err;",
          "1560: }",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/mellanox/mlx5/core/eswitch.h||drivers/net/ethernet/mellanox/mlx5/core/eswitch.h": [
          "File: drivers/net/ethernet/mellanox/mlx5/core/eswitch.h -> drivers/net/ethernet/mellanox/mlx5/core/eswitch.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:  u16                     vlan;",
          "120:  u8                      qos;",
          "121:  bool                    enabled;",
          "122:  u16                     enabled_events;",
          "123: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121:  bool                    spoofchk;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:      int vport, int link_state);",
          "161: int mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,",
          "162:     int vport, u16 vlan, u8 qos);",
          "163: int mlx5_eswitch_get_vport_config(struct mlx5_eswitch *esw,",
          "164:       int vport, struct ifla_vf_info *ivi);",
          "165: int mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164: int mlx5_eswitch_set_vport_spoofchk(struct mlx5_eswitch *esw,",
          "165:         int vport, bool spoofchk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c612505f860c6d4fac03924879982adcd042e239",
      "candidate_info": {
        "commit_hash": "c612505f860c6d4fac03924879982adcd042e239",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c612505f860c6d4fac03924879982adcd042e239",
        "files": [
          "arch/arm64/include/asm/kvm_host.h",
          "arch/arm64/kvm/hyp-init.S",
          "arch/arm64/kvm/hyp/entry.S",
          "arch/arm64/kvm/reset.c"
        ],
        "message": "arm64: kvm: Fix kvm teardown for systems using the extended idmap\n\nIf memory is located above 1<<VA_BITS, kvm adds an extra level to its page\ntables, merging the runtime tables and boot tables that contain the idmap.\nThis lets us avoid the trampoline dance during initialisation.\n\nThis also means there is no trampoline page mapped, so\n__cpu_reset_hyp_mode() can't call __kvm_hyp_reset() in this page. The good\nnews is the idmap is still mapped, so we don't need the trampoline page.\nThe bad news is we can't call it directly as the idmap is above\nHYP_PAGE_OFFSET, so its address is masked by kvm_call_hyp.\n\nAdd a function __extended_idmap_trampoline which will branch into\n__kvm_hyp_reset in the idmap, change kvm_hyp_reset_entry() to return\nthis address if __kvm_cpu_uses_extended_idmap(). In this case\n__kvm_hyp_reset() will still switch to the boot tables (which are the\nmerged tables that were already in use), and branch into the idmap (where\nit already was).\n\nThis fixes boot failures on these systems, where we fail to execute the\nmissing trampoline page when tearing down kvm in init_subsystems():\n[    2.508922] kvm [1]: 8-bit VMID\n[    2.512057] kvm [1]: Hyp mode initialized successfully\n[    2.517242] kvm [1]: interrupt-controller@e1140000 IRQ13\n[    2.522622] kvm [1]: timer IRQ3\n[    2.525783] Kernel panic - not syncing: HYP panic:\n[    2.525783] PS:200003c9 PC:0000007ffffff820 ESR:86000005\n[    2.525783] FAR:0000007ffffff820 HPFAR:00000000003ffff0 PAR:0000000000000000\n[    2.525783] VCPU:          (null)\n[    2.525783]\n[    2.547667] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W       4.6.0-rc5+ #1\n[    2.555137] Hardware name: Default string Default string/Default string, BIOS ROD0084E 09/03/2015\n[    2.563994] Call trace:\n[    2.566432] [<ffffff80080888d0>] dump_backtrace+0x0/0x240\n[    2.571818] [<ffffff8008088b24>] show_stack+0x14/0x20\n[    2.576858] [<ffffff80083423ac>] dump_stack+0x94/0xb8\n[    2.581899] [<ffffff8008152130>] panic+0x10c/0x250\n[    2.586677] [<ffffff8008152024>] panic+0x0/0x250\n[    2.591281] SMP: stopping secondary CPUs\n[    3.649692] SMP: failed to stop secondary CPUs 0-2,4-7\n[    3.654818] Kernel Offset: disabled\n[    3.658293] Memory Limit: none\n[    3.661337] ---[ end Kernel panic - not syncing: HYP panic:\n[    3.661337] PS:200003c9 PC:0000007ffffff820 ESR:86000005\n[    3.661337] FAR:0000007ffffff820 HPFAR:00000000003ffff0 PAR:0000000000000000\n[    3.661337] VCPU:          (null)\n[    3.661337]\n\nReported-by: Will Deacon <will.deacon@arm.com>\nReviewed-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: James Morse <james.morse@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
        "before_after_code_files": [
          "arch/arm64/include/asm/kvm_host.h||arch/arm64/include/asm/kvm_host.h",
          "arch/arm64/kvm/hyp-init.S||arch/arm64/kvm/hyp-init.S",
          "arch/arm64/kvm/hyp/entry.S||arch/arm64/kvm/hyp/entry.S",
          "arch/arm64/kvm/reset.c||arch/arm64/kvm/reset.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm64/include/asm/kvm_host.h||arch/arm64/include/asm/kvm_host.h": [
          "File: arch/arm64/include/asm/kvm_host.h -> arch/arm64/include/asm/kvm_host.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: int __attribute_const__ kvm_target_cpu(void);",
          "47: int kvm_reset_vcpu(struct kvm_vcpu *vcpu);",
          "48: int kvm_arch_dev_ioctl_check_extension(long ext);",
          "51: struct kvm_arch {",
          "",
          "[Removed Lines]",
          "49: phys_addr_t kvm_hyp_reset_entry(void);",
          "",
          "[Added Lines]",
          "49: unsigned long kvm_hyp_reset_entry(void);",
          "50: void __extended_idmap_trampoline(phys_addr_t boot_pgd, phys_addr_t idmap_start);",
          "",
          "---------------"
        ],
        "arch/arm64/kvm/hyp-init.S||arch/arm64/kvm/hyp-init.S": [
          "File: arch/arm64/kvm/hyp-init.S -> arch/arm64/kvm/hyp-init.S"
        ],
        "arch/arm64/kvm/hyp/entry.S||arch/arm64/kvm/hyp/entry.S": [
          "File: arch/arm64/kvm/hyp/entry.S -> arch/arm64/kvm/hyp/entry.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:  eret",
          "166: ENDPROC(__fpsimd_guest_restore)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "178: ENTRY(__extended_idmap_trampoline)",
          "179:  mov x4, x1",
          "180:  adr_l x3, __kvm_hyp_reset",
          "183:  bfi x4, x3, #0, #PAGE_SHIFT",
          "184:  br x4",
          "185: ENDPROC(__extended_idmap_trampoline)",
          "",
          "---------------"
        ],
        "arch/arm64/kvm/reset.c||arch/arm64/kvm/reset.c": [
          "File: arch/arm64/kvm/reset.c -> arch/arm64/kvm/reset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "136: extern char __hyp_idmap_text_start[];",
          "139: {",
          "146: }",
          "",
          "[Removed Lines]",
          "138: phys_addr_t kvm_hyp_reset_entry(void)",
          "140:  unsigned long offset;",
          "142:  offset = (unsigned long)__kvm_hyp_reset",
          "143:    - ((unsigned long)__hyp_idmap_text_start & PAGE_MASK);",
          "145:  return TRAMPOLINE_VA + offset;",
          "",
          "[Added Lines]",
          "138: unsigned long kvm_hyp_reset_entry(void)",
          "140:  if (!__kvm_cpu_uses_extended_idmap()) {",
          "141:   unsigned long offset;",
          "149:   offset = (unsigned long)__kvm_hyp_reset",
          "150:     - ((unsigned long)__hyp_idmap_text_start & PAGE_MASK);",
          "152:   return TRAMPOLINE_VA + offset;",
          "153:  } else {",
          "160:   return (unsigned long)kvm_ksym_ref(__extended_idmap_trampoline);",
          "161:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f4eaa89fb20d9fd178d2f9db5aa2df5af358dcd",
      "candidate_info": {
        "commit_hash": "7f4eaa89fb20d9fd178d2f9db5aa2df5af358dcd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7f4eaa89fb20d9fd178d2f9db5aa2df5af358dcd",
        "files": [
          "drivers/gpu/drm/drm_atomic.c"
        ],
        "message": "drm/atomic: Add WARN_ON when state->acquire_ctx is not set.\n\nWhen I was writing an atomic wrapper for rmfb, I ran into the\nfollowing backtrace from lockdep:\n\n=============================================\n[ INFO: possible recursive locking detected ]\n4.5.0-patser+ #4696 Tainted: G     U\n---------------------------------------------\nkworker/2:2/2608 is trying to acquire lock:\n (crtc_ww_class_mutex){+.+.+.}, at: [<ffffffffc00c9ddc>] drm_modeset_lock+0x7c/0x120 [drm]\n\nbut task is already holding lock:\n (crtc_ww_class_mutex){+.+.+.}, at: [<ffffffffc00c98cd>] modeset_backoff+0x8d/0x220 [drm]\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(crtc_ww_class_mutex);\n  lock(crtc_ww_class_mutex);\n\n *** DEADLOCK ***\n\n May be due to missing lock nesting notation\n\n4 locks held by kworker/2:2/2608:\n #0:  (\"events\"){.+.+.+}, at: [<ffffffff810a5eea>] process_one_work+0x15a/0x6c0\n #1:  ((&arg.work)){+.+.+.}, at: [<ffffffff810a5eea>] process_one_work+0x15a/0x6c0\n #2:  (crtc_ww_class_acquire){+.+.+.}, at: [<ffffffffc004532a>] drm_atomic_helper_remove_fb+0x4a/0x1d0 [drm_kms_helper]\n #3:  (crtc_ww_class_mutex){+.+.+.}, at: [<ffffffffc00c98cd>] modeset_backoff+0x8d/0x220 [drm]\n\nWhile lockdep probably catches this bug when it happens, it's better\nto explicitly warn when state->acquire_ctx is not set.\n\nSigned-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>\nLink: http://patchwork.freedesktop.org/patch/msgid/1462266751-29123-1-git-send-email-maarten.lankhorst@linux.intel.com",
        "before_after_code_files": [
          "drivers/gpu/drm/drm_atomic.c||drivers/gpu/drm/drm_atomic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/drm_atomic.c||drivers/gpu/drm/drm_atomic.c": [
          "File: drivers/gpu/drm/drm_atomic.c -> drivers/gpu/drm/drm_atomic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "263:  int ret, index = drm_crtc_index(crtc);",
          "264:  struct drm_crtc_state *crtc_state;",
          "266:  crtc_state = drm_atomic_get_existing_crtc_state(state, crtc);",
          "267:  if (crtc_state)",
          "268:   return crtc_state;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266:  WARN_ON(!state->acquire_ctx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "622:  int ret, index = drm_plane_index(plane);",
          "623:  struct drm_plane_state *plane_state;",
          "625:  plane_state = drm_atomic_get_existing_plane_state(state, plane);",
          "626:  if (plane_state)",
          "627:   return plane_state;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627:  WARN_ON(!state->acquire_ctx);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "890:  struct drm_mode_config *config = &connector->dev->mode_config;",
          "891:  struct drm_connector_state *connector_state;",
          "893:  ret = drm_modeset_lock(&config->connection_mutex, state->acquire_ctx);",
          "894:  if (ret)",
          "895:   return ERR_PTR(ret);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "897:  WARN_ON(!state->acquire_ctx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6071bd1aa13ed9e41824bafad845b7b7f4df5cfd",
      "candidate_info": {
        "commit_hash": "6071bd1aa13ed9e41824bafad845b7b7f4df5cfd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6071bd1aa13ed9e41824bafad845b7b7f4df5cfd",
        "files": [
          "net/sched/sch_netem.c"
        ],
        "message": "netem: Segment GSO packets on enqueue\n\nThis was recently reported to me, and reproduced on the latest net kernel,\nwhen attempting to run netperf from a host that had a netem qdisc attached\nto the egress interface:\n\n[  788.073771] ---------------------[ cut here ]---------------------------\n[  788.096716] WARNING: at net/core/dev.c:2253 skb_warn_bad_offload+0xcd/0xda()\n[  788.129521] bnx2: caps=(0x00000001801949b3, 0x0000000000000000) len=2962\ndata_len=0 gso_size=1448 gso_type=1 ip_summed=3\n[  788.182150] Modules linked in: sch_netem kvm_amd kvm crc32_pclmul ipmi_ssif\nghash_clmulni_intel sp5100_tco amd64_edac_mod aesni_intel lrw gf128mul\nglue_helper ablk_helper edac_mce_amd cryptd pcspkr sg edac_core hpilo ipmi_si\ni2c_piix4 k10temp fam15h_power hpwdt ipmi_msghandler shpchp acpi_power_meter\npcc_cpufreq nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs libcrc32c\nsd_mod crc_t10dif crct10dif_generic mgag200 syscopyarea sysfillrect sysimgblt\ni2c_algo_bit drm_kms_helper ahci ata_generic pata_acpi ttm libahci\ncrct10dif_pclmul pata_atiixp tg3 libata crct10dif_common drm crc32c_intel ptp\nserio_raw bnx2 r8169 hpsa pps_core i2c_core mii dm_mirror dm_region_hash dm_log\ndm_mod\n[  788.465294] CPU: 16 PID: 0 Comm: swapper/16 Tainted: G        W\n------------   3.10.0-327.el7.x86_64 #1\n[  788.511521] Hardware name: HP ProLiant DL385p Gen8, BIOS A28 12/17/2012\n[  788.542260]  ffff880437c036b8 f7afc56532a53db9 ffff880437c03670\nffffffff816351f1\n[  788.576332]  ffff880437c036a8 ffffffff8107b200 ffff880633e74200\nffff880231674000\n[  788.611943]  0000000000000001 0000000000000003 0000000000000000\nffff880437c03710\n[  788.647241] Call Trace:\n[  788.658817]  <IRQ>  [<ffffffff816351f1>] dump_stack+0x19/0x1b\n[  788.686193]  [<ffffffff8107b200>] warn_slowpath_common+0x70/0xb0\n[  788.713803]  [<ffffffff8107b29c>] warn_slowpath_fmt+0x5c/0x80\n[  788.741314]  [<ffffffff812f92f3>] ? ___ratelimit+0x93/0x100\n[  788.767018]  [<ffffffff81637f49>] skb_warn_bad_offload+0xcd/0xda\n[  788.796117]  [<ffffffff8152950c>] skb_checksum_help+0x17c/0x190\n[  788.823392]  [<ffffffffa01463a1>] netem_enqueue+0x741/0x7c0 [sch_netem]\n[  788.854487]  [<ffffffff8152cb58>] dev_queue_xmit+0x2a8/0x570\n[  788.880870]  [<ffffffff8156ae1d>] ip_finish_output+0x53d/0x7d0\n...\n\nThe problem occurs because netem is not prepared to handle GSO packets (as it\nuses skb_checksum_help in its enqueue path, which cannot manipulate these\nframes).\n\nThe solution I think is to simply segment the skb in a simmilar fashion to the\nway we do in __dev_queue_xmit (via validate_xmit_skb), with some minor changes.\nWhen we decide to corrupt an skb, if the frame is GSO, we segment it, corrupt\nthe first segment, and enqueue the remaining ones.\n\ntested successfully by myself on the latest net kernel, to which this applies\n\nSigned-off-by: Neil Horman <nhorman@tuxdriver.com>\nCC: Jamal Hadi Salim <jhs@mojatatu.com>\nCC: \"David S. Miller\" <davem@davemloft.net>\nCC: netem@lists.linux-foundation.org\nCC: eric.dumazet@gmail.com\nCC: stephen@networkplumber.org\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/sch_netem.c||net/sched/sch_netem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/sch_netem.c||net/sched/sch_netem.c": [
          "File: net/sched/sch_netem.c -> net/sched/sch_netem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "395:  sch->q.qlen++;",
          "396: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "402: static struct sk_buff *netem_segment(struct sk_buff *skb, struct Qdisc *sch)",
          "403: {",
          "404:  struct sk_buff *segs;",
          "405:  netdev_features_t features = netif_skb_features(skb);",
          "407:  segs = skb_gso_segment(skb, features & ~NETIF_F_GSO_MASK);",
          "409:  if (IS_ERR_OR_NULL(segs)) {",
          "410:   qdisc_reshape_fail(skb, sch);",
          "411:   return NULL;",
          "412:  }",
          "413:  consume_skb(skb);",
          "414:  return segs;",
          "415: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "408:  struct netem_skb_cb *cb;",
          "409:  struct sk_buff *skb2;",
          "410:  int count = 1;",
          "413:  if (q->duplicate && q->duplicate >= get_crandom(&q->dup_cor))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "429:  struct sk_buff *segs = NULL;",
          "430:  unsigned int len = 0, last_len, prev_len = qdisc_pkt_len(skb);",
          "431:  int nb = 0;",
          "433:  int rc = NET_XMIT_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "455:  if (q->corrupt && q->corrupt >= get_crandom(&q->corrupt_cor)) {",
          "456:   if (!(skb = skb_unshare(skb, GFP_ATOMIC)) ||",
          "457:       (skb->ip_summed == CHECKSUM_PARTIAL &&",
          "461:   skb->data[prandom_u32() % skb_headlen(skb)] ^=",
          "462:    1<<(prandom_u32() % 8);",
          "",
          "[Removed Lines]",
          "458:        skb_checksum_help(skb)))",
          "459:    return qdisc_drop(skb, sch);",
          "",
          "[Added Lines]",
          "479:   if (skb_is_gso(skb)) {",
          "480:    segs = netem_segment(skb, sch);",
          "481:    if (!segs)",
          "482:     return NET_XMIT_DROP;",
          "483:   } else {",
          "484:    segs = skb;",
          "485:   }",
          "487:   skb = segs;",
          "488:   segs = segs->next;",
          "492:        skb_checksum_help(skb))) {",
          "493:    rc = qdisc_drop(skb, sch);",
          "494:    goto finish_segs;",
          "495:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "516:   sch->qstats.requeues++;",
          "517:  }",
          "519:  return NET_XMIT_SUCCESS;",
          "520: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "555: finish_segs:",
          "556:  if (segs) {",
          "557:   while (segs) {",
          "558:    skb2 = segs->next;",
          "559:    segs->next = NULL;",
          "560:    qdisc_skb_cb(segs)->pkt_len = segs->len;",
          "561:    last_len = segs->len;",
          "562:    rc = qdisc_enqueue(segs, sch);",
          "563:    if (rc != NET_XMIT_SUCCESS) {",
          "564:     if (net_xmit_drop_count(rc))",
          "565:      qdisc_qstats_drop(sch);",
          "566:    } else {",
          "567:     nb++;",
          "568:     len += last_len;",
          "569:    }",
          "570:    segs = skb2;",
          "571:   }",
          "572:   sch->q.qlen += nb;",
          "573:   if (nb > 1)",
          "574:    qdisc_tree_reduce_backlog(sch, 1 - nb, prev_len - len);",
          "575:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
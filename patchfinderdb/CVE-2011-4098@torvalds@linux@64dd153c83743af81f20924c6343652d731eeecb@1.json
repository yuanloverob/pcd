{
  "cve_id": "CVE-2011-4098",
  "cve_desc": "The fallocate implementation in the GFS2 filesystem in the Linux kernel before 3.2 relies on the page cache, which might allow local users to cause a denial of service by preallocating blocks in certain situations involving insufficient memory.",
  "repo": "torvalds/linux",
  "patch_hash": "64dd153c83743af81f20924c6343652d731eeecb",
  "patch_info": {
    "commit_hash": "64dd153c83743af81f20924c6343652d731eeecb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb",
    "files": [
      "fs/gfs2/bmap.c",
      "fs/gfs2/file.c",
      "fs/gfs2/incore.h"
    ],
    "message": "GFS2: rewrite fallocate code to write blocks directly\n\nGFS2's fallocate code currently goes through the page cache. Since it's only\nwriting to the end of the file or to holes in it, it doesn't need to, and it\nwas causing issues on low memory environments. This patch pulls in some of\nSteve's block allocation work, and uses it to simply allocate the blocks for\nthe file, and zero them out at allocation time.  It provides a slight\nperformance increase, and it dramatically simplifies the code.\n\nSigned-off-by: Benjamin Marzinski <bmarzins@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
    "before_after_code_files": [
      "fs/gfs2/bmap.c||fs/gfs2/bmap.c",
      "fs/gfs2/file.c||fs/gfs2/file.c",
      "fs/gfs2/incore.h||fs/gfs2/incore.h"
    ]
  },
  "patch_diff": {
    "fs/gfs2/bmap.c||fs/gfs2/bmap.c": [
      "File: fs/gfs2/bmap.c -> fs/gfs2/bmap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: #include <linux/spinlock.h>",
      "11: #include <linux/completion.h>",
      "12: #include <linux/buffer_head.h>",
      "13: #include <linux/gfs2_ondisk.h>",
      "14: #include <linux/crc32.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13: #include <linux/blkdev.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "427: {",
      "428:  struct gfs2_inode *ip = GFS2_I(inode);",
      "429:  struct gfs2_sbd *sdp = GFS2_SB(inode);",
      "430:  struct buffer_head *dibh = mp->mp_bh[0];",
      "431:  u64 bn, dblock = 0;",
      "432:  unsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;",
      "433:  unsigned dblks = 0;",
      "434:  unsigned ptrs_per_blk;",
      "435:  const unsigned end_of_metadata = height - 1;",
      "436:  int eob = 0;",
      "437:  enum alloc_state state;",
      "438:  __be64 *ptr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "431:  struct super_block *sb = sdp->sd_vfs;",
      "438:  int ret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "535:    dblock = bn;",
      "536:    while (n-- > 0)",
      "538:    break;",
      "539:   }",
      "540:  } while ((state != ALLOC_DATA) || !dblock);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "541:    if (buffer_zeronew(bh_map)) {",
      "542:     ret = sb_issue_zeroout(sb, dblock, dblks,",
      "543:              GFP_NOFS);",
      "544:     if (ret) {",
      "545:      fs_err(sdp,",
      "546:             \"Failed to zero data buffers\\n\");",
      "547:      clear_buffer_zeronew(bh_map);",
      "548:     }",
      "549:    }",
      "",
      "---------------"
    ],
    "fs/gfs2/file.c||fs/gfs2/file.c": [
      "File: fs/gfs2/file.c -> fs/gfs2/file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "669:  return generic_file_aio_write(iocb, iov, nr_segs, pos);",
      "670: }",
      "781: static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,",
      "782:       int mode)",
      "783: {",
      "784:  struct gfs2_inode *ip = GFS2_I(inode);",
      "785:  struct buffer_head *dibh;",
      "786:  int error;",
      "798:  error = gfs2_meta_inode_buffer(ip, &dibh);",
      "799:  if (unlikely(error))",
      "802:  gfs2_trans_add_bh(ip->i_gl, dibh, 1);",
      "",
      "[Removed Lines]",
      "672: static int empty_write_end(struct page *page, unsigned from,",
      "673:       unsigned to, int mode)",
      "674: {",
      "675:  struct inode *inode = page->mapping->host;",
      "676:  struct gfs2_inode *ip = GFS2_I(inode);",
      "677:  struct buffer_head *bh;",
      "678:  unsigned offset, blksize = 1 << inode->i_blkbits;",
      "679:  pgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;",
      "681:  zero_user(page, from, to-from);",
      "682:  mark_page_accessed(page);",
      "684:  if (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {",
      "685:   if (!gfs2_is_writeback(ip))",
      "686:    gfs2_page_add_databufs(ip, page, from, to);",
      "688:   block_commit_write(page, from, to);",
      "689:   return 0;",
      "690:  }",
      "692:  offset = 0;",
      "693:  bh = page_buffers(page);",
      "694:  while (offset < to) {",
      "695:   if (offset >= from) {",
      "696:    set_buffer_uptodate(bh);",
      "697:    mark_buffer_dirty(bh);",
      "698:    clear_buffer_new(bh);",
      "699:    write_dirty_buffer(bh, WRITE);",
      "700:   }",
      "701:   offset += blksize;",
      "702:   bh = bh->b_this_page;",
      "703:  }",
      "705:  offset = 0;",
      "706:  bh = page_buffers(page);",
      "707:  while (offset < to) {",
      "708:   if (offset >= from) {",
      "709:    wait_on_buffer(bh);",
      "710:    if (!buffer_uptodate(bh))",
      "711:     return -EIO;",
      "712:   }",
      "713:   offset += blksize;",
      "714:   bh = bh->b_this_page;",
      "715:  }",
      "716:  return 0;",
      "717: }",
      "719: static int needs_empty_write(sector_t block, struct inode *inode)",
      "720: {",
      "721:  int error;",
      "722:  struct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };",
      "724:  bh_map.b_size = 1 << inode->i_blkbits;",
      "725:  error = gfs2_block_map(inode, block, &bh_map, 0);",
      "726:  if (unlikely(error))",
      "727:   return error;",
      "728:  return !buffer_mapped(&bh_map);",
      "729: }",
      "731: static int write_empty_blocks(struct page *page, unsigned from, unsigned to,",
      "732:          int mode)",
      "733: {",
      "734:  struct inode *inode = page->mapping->host;",
      "735:  unsigned start, end, next, blksize;",
      "736:  sector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);",
      "737:  int ret;",
      "739:  blksize = 1 << inode->i_blkbits;",
      "740:  next = end = 0;",
      "741:  while (next < from) {",
      "742:   next += blksize;",
      "743:   block++;",
      "744:  }",
      "745:  start = next;",
      "746:  do {",
      "747:   next += blksize;",
      "748:   ret = needs_empty_write(block, inode);",
      "749:   if (unlikely(ret < 0))",
      "750:    return ret;",
      "751:   if (ret == 0) {",
      "752:    if (end) {",
      "753:     ret = __block_write_begin(page, start, end - start,",
      "754:          gfs2_block_map);",
      "755:     if (unlikely(ret))",
      "756:      return ret;",
      "757:     ret = empty_write_end(page, start, end, mode);",
      "758:     if (unlikely(ret))",
      "759:      return ret;",
      "760:     end = 0;",
      "761:    }",
      "762:    start = next;",
      "763:   }",
      "764:   else",
      "765:    end = next;",
      "766:   block++;",
      "767:  } while (next < to);",
      "769:  if (end) {",
      "770:   ret = __block_write_begin(page, start, end - start, gfs2_block_map);",
      "771:   if (unlikely(ret))",
      "772:    return ret;",
      "773:   ret = empty_write_end(page, start, end, mode);",
      "774:   if (unlikely(ret))",
      "775:    return ret;",
      "776:  }",
      "778:  return 0;",
      "779: }",
      "787:  u64 start = offset >> PAGE_CACHE_SHIFT;",
      "788:  unsigned int start_offset = offset & ~PAGE_CACHE_MASK;",
      "789:  u64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;",
      "790:  pgoff_t curr;",
      "791:  struct page *page;",
      "792:  unsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;",
      "793:  unsigned int from, to;",
      "795:  if (!end_offset)",
      "796:   end_offset = PAGE_CACHE_SIZE;",
      "800:   goto out;",
      "",
      "[Added Lines]",
      "678:  unsigned int nr_blks;",
      "679:  sector_t lblock = offset >> inode->i_blkbits;",
      "683:   return error;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "807:    goto out;",
      "808:  }",
      "832:    goto out;",
      "836:  }",
      "838:  mark_inode_dirty(inode);",
      "842: out:",
      "843:  return error;",
      "844: }",
      "",
      "[Removed Lines]",
      "810:  curr = start;",
      "811:  offset = start << PAGE_CACHE_SHIFT;",
      "812:  from = start_offset;",
      "813:  to = PAGE_CACHE_SIZE;",
      "814:  while (curr <= end) {",
      "815:   page = grab_cache_page_write_begin(inode->i_mapping, curr,",
      "816:          AOP_FLAG_NOFS);",
      "817:   if (unlikely(!page)) {",
      "818:    error = -ENOMEM;",
      "819:    goto out;",
      "820:   }",
      "822:   if (curr == end)",
      "823:    to = end_offset;",
      "824:   error = write_empty_blocks(page, from, to, mode);",
      "825:   if (!error && offset + to > inode->i_size &&",
      "826:       !(mode & FALLOC_FL_KEEP_SIZE)) {",
      "827:    i_size_write(inode, offset + to);",
      "828:   }",
      "829:   unlock_page(page);",
      "830:   page_cache_release(page);",
      "831:   if (error)",
      "833:   curr++;",
      "834:   offset += PAGE_CACHE_SIZE;",
      "835:   from = 0;",
      "840:  brelse(dibh);",
      "",
      "[Added Lines]",
      "693:  while (len) {",
      "694:   struct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };",
      "695:   bh_map.b_size = len;",
      "696:   set_buffer_zeronew(&bh_map);",
      "698:   error = gfs2_block_map(inode, lblock, &bh_map, 1);",
      "699:   if (unlikely(error))",
      "700:    goto out;",
      "701:   len -= bh_map.b_size;",
      "702:   nr_blks = bh_map.b_size >> inode->i_blkbits;",
      "703:   lblock += nr_blks;",
      "704:   if (!buffer_new(&bh_map))",
      "705:    continue;",
      "706:   if (unlikely(!buffer_zeronew(&bh_map))) {",
      "707:    error = -EIO;",
      "709:   }",
      "711:  if (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))",
      "712:   i_size_write(inode, offset + len);",
      "717:  brelse(dibh);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "879:  int error;",
      "880:  loff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);",
      "881:  loff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;",
      "882:  next = (next + 1) << sdp->sd_sb.sb_bsize_shift;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "757:  loff_t max_chunk_size = UINT_MAX & bsize_mask;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "932:    goto out_qunlock;",
      "933:   }",
      "934:   max_bytes = bytes;",
      "936:   al->al_requested = data_blocks + ind_blocks;",
      "938:   rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +",
      "",
      "[Removed Lines]",
      "935:   calc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);",
      "",
      "[Added Lines]",
      "811:   calc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,",
      "812:     &max_bytes, &data_blocks, &ind_blocks);",
      "",
      "---------------"
    ],
    "fs/gfs2/incore.h||fs/gfs2/incore.h": [
      "File: fs/gfs2/incore.h -> fs/gfs2/incore.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "103: enum gfs2_state_bits {",
      "104:  BH_Pinned = BH_PrivateStart,",
      "105:  BH_Escaped = BH_PrivateStart + 1,",
      "106: };",
      "108: BUFFER_FNS(Pinned, pinned)",
      "109: TAS_BUFFER_FNS(Pinned, pinned)",
      "110: BUFFER_FNS(Escaped, escaped)",
      "111: TAS_BUFFER_FNS(Escaped, escaped)",
      "113: struct gfs2_bufdata {",
      "114:  struct buffer_head *bd_bh;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "106:  BH_Zeronew = BH_PrivateStart + 2,",
      "113: BUFFER_FNS(Zeronew, zeronew)",
      "114: TAS_BUFFER_FNS(Zeronew, zeronew)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0ee532062fa7ff0795b3862c2d50efe32e552f9f",
      "candidate_info": {
        "commit_hash": "0ee532062fa7ff0795b3862c2d50efe32e552f9f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0ee532062fa7ff0795b3862c2d50efe32e552f9f",
        "files": [
          "fs/gfs2/file.c"
        ],
        "message": "GFS2: directly write blocks past i_size\n\nGFS2 was relying on the writepage code to write out the zeroed data for\nfallocate.  However, with FALLOC_FL_KEEP_SIZE set, this may be past i_size.\nIf it is, it will be ignored.  To work around this, gfs2 now calls\nwrite_dirty_buffer directly on the buffer_heads when FALLOC_FL_KEEP_SIZE\nis set, and it's writing past i_size.\n\nThis version is just a cleanup of my last version\n\nSigned-off-by: Benjamin Marzinski <bmarzins@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
        "before_after_code_files": [
          "fs/gfs2/file.c||fs/gfs2/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ],
          "candidate": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/gfs2/file.c||fs/gfs2/file.c": [
          "File: fs/gfs2/file.c -> fs/gfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "617:  return generic_file_aio_write(iocb, iov, nr_segs, pos);",
          "618: }",
          "622: {",
          "625:  zero_user(page, from, to-from);",
          "626:  mark_page_accessed(page);",
          "632: }",
          "634: static int needs_empty_write(sector_t block, struct inode *inode)",
          "",
          "[Removed Lines]",
          "620: static void empty_write_end(struct page *page, unsigned from,",
          "621:       unsigned to)",
          "623:  struct gfs2_inode *ip = GFS2_I(page->mapping->host);",
          "628:  if (!gfs2_is_writeback(ip))",
          "629:   gfs2_page_add_databufs(ip, page, from, to);",
          "631:  block_commit_write(page, from, to);",
          "",
          "[Added Lines]",
          "620: static int empty_write_end(struct page *page, unsigned from,",
          "621:       unsigned to, int mode)",
          "623:  struct inode *inode = page->mapping->host;",
          "624:  struct gfs2_inode *ip = GFS2_I(inode);",
          "625:  struct buffer_head *bh;",
          "626:  unsigned offset, blksize = 1 << inode->i_blkbits;",
          "627:  pgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;",
          "632:  if (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {",
          "633:   if (!gfs2_is_writeback(ip))",
          "634:    gfs2_page_add_databufs(ip, page, from, to);",
          "636:   block_commit_write(page, from, to);",
          "637:   return 0;",
          "638:  }",
          "640:  offset = 0;",
          "641:  bh = page_buffers(page);",
          "642:  while (offset < to) {",
          "643:   if (offset >= from) {",
          "644:    set_buffer_uptodate(bh);",
          "645:    mark_buffer_dirty(bh);",
          "646:    clear_buffer_new(bh);",
          "647:    write_dirty_buffer(bh, WRITE);",
          "648:   }",
          "649:   offset += blksize;",
          "650:   bh = bh->b_this_page;",
          "651:  }",
          "653:  offset = 0;",
          "654:  bh = page_buffers(page);",
          "655:  while (offset < to) {",
          "656:   if (offset >= from) {",
          "657:    wait_on_buffer(bh);",
          "658:    if (!buffer_uptodate(bh))",
          "659:     return -EIO;",
          "660:   }",
          "661:   offset += blksize;",
          "662:   bh = bh->b_this_page;",
          "663:  }",
          "664:  return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "643:  return !buffer_mapped(&bh_map);",
          "644: }",
          "647: {",
          "648:  struct inode *inode = page->mapping->host;",
          "649:  unsigned start, end, next, blksize;",
          "",
          "[Removed Lines]",
          "646: static int write_empty_blocks(struct page *page, unsigned from, unsigned to)",
          "",
          "[Added Lines]",
          "679: static int write_empty_blocks(struct page *page, unsigned from, unsigned to,",
          "680:          int mode)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "668:          gfs2_block_map);",
          "669:     if (unlikely(ret))",
          "670:      return ret;",
          "672:     end = 0;",
          "673:    }",
          "674:    start = next;",
          "",
          "[Removed Lines]",
          "671:     empty_write_end(page, start, end);",
          "",
          "[Added Lines]",
          "705:     ret = empty_write_end(page, start, end, mode);",
          "706:     if (unlikely(ret))",
          "707:      return ret;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "682:   ret = __block_write_begin(page, start, end - start, gfs2_block_map);",
          "683:   if (unlikely(ret))",
          "684:    return ret;",
          "686:  }",
          "688:  return 0;",
          "",
          "[Removed Lines]",
          "685:   empty_write_end(page, start, end);",
          "",
          "[Added Lines]",
          "721:   ret = empty_write_end(page, start, end, mode);",
          "722:   if (unlikely(ret))",
          "723:    return ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "732:   if (curr == end)",
          "733:    to = end_offset;",
          "735:   if (!error && offset + to > inode->i_size &&",
          "736:       !(mode & FALLOC_FL_KEEP_SIZE)) {",
          "737:    i_size_write(inode, offset + to);",
          "",
          "[Removed Lines]",
          "734:   error = write_empty_blocks(page, from, to);",
          "",
          "[Added Lines]",
          "772:   error = write_empty_blocks(page, from, to, mode);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
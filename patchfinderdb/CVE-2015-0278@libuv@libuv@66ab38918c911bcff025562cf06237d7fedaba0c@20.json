{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d34fad7325902486a7835f6c8e809d6fb04fe7c9",
      "candidate_info": {
        "commit_hash": "d34fad7325902486a7835f6c8e809d6fb04fe7c9",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/d34fad7325902486a7835f6c8e809d6fb04fe7c9",
        "files": [
          "ChangeLog",
          "src/version.c"
        ],
        "message": "Now working on v0.11.8",
        "before_after_code_files": [
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #define UV_VERSION_MAJOR 0",
          "33: #define UV_VERSION_MINOR 11",
          "38: #define UV_VERSION  ((UV_VERSION_MAJOR << 16) | \\",
          "",
          "[Removed Lines]",
          "34: #define UV_VERSION_PATCH 7",
          "35: #define UV_VERSION_IS_RELEASE 1",
          "",
          "[Added Lines]",
          "34: #define UV_VERSION_PATCH 8",
          "35: #define UV_VERSION_IS_RELEASE 0",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6abe1e4b953bda1e9bd5dab33826bfead591551d",
      "candidate_info": {
        "commit_hash": "6abe1e4b953bda1e9bd5dab33826bfead591551d",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/6abe1e4b953bda1e9bd5dab33826bfead591551d",
        "files": [
          "include/uv-unix.h",
          "src/unix/fs.c",
          "src/unix/internal.h",
          "src/unix/loop.c",
          "src/unix/process.c",
          "test/run-tests.c",
          "test/test-list.h",
          "test/test-spawn.c"
        ],
        "message": "fs: `uv__cloexec()` opened fd\n\nEvery file descriptor opened using libuv should be automatically marked\nas CLOEXEC to prevent it from leaking to a child process. Note that\nsince we are opening fds in a thread pool, there is a possible race\ncondition between `uv_spawn()` and the `open()` + `uv__cloexec()`. The\nrwlock was added to avoid it.\n\nsee https://github.com/joyent/node/issues/6905",
        "before_after_code_files": [
          "include/uv-unix.h||include/uv-unix.h",
          "src/unix/fs.c||src/unix/fs.c",
          "src/unix/internal.h||src/unix/internal.h",
          "src/unix/loop.c||src/unix/loop.c",
          "src/unix/process.c||src/unix/process.c",
          "test/run-tests.c||test/run-tests.c",
          "test/test-list.h||test/test-list.h",
          "test/test-spawn.c||test/test-spawn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [
            "src/unix/process.c||src/unix/process.c"
          ],
          "candidate": [
            "src/unix/process.c||src/unix/process.c"
          ]
        }
      },
      "candidate_diff": {
        "include/uv-unix.h||include/uv-unix.h": [
          "File: include/uv-unix.h -> include/uv-unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:   void* wq[2];                                                                \\",
          "170:   uv_mutex_t wq_mutex;                                                        \\",
          "171:   uv_async_t wq_async;                                                        \\",
          "172:   uv_handle_t* closing_handles;                                               \\",
          "173:   void* process_handles[1][2];                                                \\",
          "174:   void* prepare_handles[2];                                                   \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:   uv_rwlock_t cloexec_lock;                                                   \\",
          "",
          "---------------"
        ],
        "src/unix/fs.c||src/unix/fs.c": [
          "File: src/unix/fs.c -> src/unix/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "608:   int retry_on_eintr;",
          "609:   uv_fs_t* req;",
          "610:   ssize_t r;",
          "612:   req = container_of(w, uv_fs_t, work_req);",
          "613:   retry_on_eintr = !(req->fs_type == UV_FS_CLOSE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "611: #ifdef O_CLOEXEC",
          "612:   static int no_cloexec_support;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "634:     X(LSTAT, uv__fs_lstat(req->path, &req->statbuf));",
          "635:     X(LINK, link(req->path, req->new_path));",
          "636:     X(MKDIR, mkdir(req->path, req->mode));",
          "638:     X(READ, uv__fs_read(req));",
          "639:     X(READDIR, uv__fs_readdir(req));",
          "640:     X(READLINK, uv__fs_readlink(req));",
          "",
          "[Removed Lines]",
          "637:     X(OPEN, open(req->path, req->flags, req->mode));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "646:     X(UNLINK, unlink(req->path));",
          "647:     X(UTIME, uv__fs_utime(req));",
          "648:     X(WRITE, uv__fs_write(req));",
          "649:     default: abort();",
          "650:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "651:     case UV_FS_OPEN:",
          "652: #ifdef O_CLOEXEC",
          "654:       if (!no_cloexec_support) {",
          "655:         r = open(req->path, req->flags | O_CLOEXEC, req->mode);",
          "656:         if (r >= 0)",
          "657:           break;",
          "658:         if (errno != EINVAL)",
          "659:           break;",
          "660:         no_cloexec_support = 1;",
          "661:       }",
          "663:       if (req->cb != NULL)",
          "664:         uv_rwlock_rdlock(&req->loop->cloexec_lock);",
          "665:       r = open(req->path, req->flags, req->mode);",
          "671:       if (r >= 0 && uv__cloexec(r, 1) != 0) {",
          "672:         r = uv__close(r);",
          "673:         if (r != 0 && r != -EINPROGRESS)",
          "674:           abort();",
          "675:         r = -1;",
          "676:       }",
          "677:       if (req->cb != NULL)",
          "678:         uv_rwlock_rdunlock(&req->loop->cloexec_lock);",
          "679:       break;",
          "",
          "---------------"
        ],
        "src/unix/internal.h||src/unix/internal.h": [
          "File: src/unix/internal.h -> src/unix/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "111: # define UV__POLLHUP  8",
          "112: #endif",
          "115: enum {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "115: #if !defined(O_CLOEXEC) && defined(__FreeBSD__)",
          "120: # define O_CLOEXEC 0x00100000",
          "121: #endif",
          "",
          "---------------"
        ],
        "src/unix/loop.c||src/unix/loop.c": [
          "File: src/unix/loop.c -> src/unix/loop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "117:   for (i = 0; i < ARRAY_SIZE(loop->process_handles); i++)",
          "118:     QUEUE_INIT(loop->process_handles + i);",
          "120:   if (uv_mutex_init(&loop->wq_mutex))",
          "121:     abort();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "120:   if (uv_rwlock_init(&loop->cloexec_lock))",
          "121:     abort();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:   uv_mutex_unlock(&loop->wq_mutex);",
          "152:   uv_mutex_destroy(&loop->wq_mutex);",
          "154: #if 0",
          "155:   assert(QUEUE_EMPTY(&loop->pending_queue));",
          "156:   assert(QUEUE_EMPTY(&loop->watcher_queue));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:   uv_rwlock_destroy(&loop->cloexec_lock);",
          "",
          "---------------"
        ],
        "src/unix/process.c||src/unix/process.c": [
          "File: src/unix/process.c -> src/unix/process.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "423:   uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD);",
          "425:   pid = fork();",
          "427:   if (pid == -1) {",
          "428:     err = -errno;",
          "429:     uv__close(signal_pipe[0]);",
          "430:     uv__close(signal_pipe[1]);",
          "431:     goto error;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "426:   uv_rwlock_wrlock(&loop->cloexec_lock);",
          "431:     uv_rwlock_wrunlock(&loop->cloexec_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "436:     abort();",
          "437:   }",
          "439:   uv__close(signal_pipe[1]);",
          "441:   process->status = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "443:   uv_rwlock_wrunlock(&loop->cloexec_lock);",
          "",
          "---------------"
        ],
        "test/run-tests.c||test/run-tests.c": [
          "File: test/run-tests.c -> test/run-tests.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:     return 1;",
          "153:   }",
          "155:   return run_test(argv[1], 0, 1);",
          "156: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "155: #ifndef _WIN32",
          "156:   if (strcmp(argv[1], \"spawn_helper8\") == 0) {",
          "157:     int fd;",
          "158:     ASSERT(sizeof(fd) == read(0, &fd, sizeof(fd)));",
          "159:     ASSERT(fd > 2);",
          "160:     ASSERT(-1 == write(fd, \"x\", 1));",
          "162:     return 1;",
          "163:   }",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "155: TEST_DECLARE   (fail_always)",
          "156: TEST_DECLARE   (pass_always)",
          "157: TEST_DECLARE   (spawn_fails)",
          "158: TEST_DECLARE   (spawn_exit_code)",
          "159: TEST_DECLARE   (spawn_stdout)",
          "160: TEST_DECLARE   (spawn_stdin)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158: TEST_DECLARE   (spawn_fs_open)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "445:   TEST_ENTRY  (poll_close)",
          "447:   TEST_ENTRY  (spawn_fails)",
          "448:   TEST_ENTRY  (spawn_exit_code)",
          "449:   TEST_ENTRY  (spawn_stdout)",
          "450:   TEST_ENTRY  (spawn_stdin)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "449:   TEST_ENTRY  (spawn_fs_open)",
          "",
          "---------------"
        ],
        "test/test-spawn.c||test/test-spawn.c": [
          "File: test/test-spawn.c -> test/test-spawn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1049:   MAKE_VALGRIND_HAPPY();",
          "1050:   return 0;",
          "1051: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1054: #ifndef _WIN32",
          "1055: TEST_IMPL(spawn_fs_open) {",
          "1056:   int fd;",
          "1057:   uv_fs_t fs_req;",
          "1058:   uv_pipe_t in;",
          "1059:   uv_write_t write_req;",
          "1060:   uv_buf_t buf;",
          "1061:   uv_stdio_container_t stdio[1];",
          "1063:   fd = uv_fs_open(uv_default_loop(), &fs_req, \"/dev/null\", O_RDWR, 0, NULL);",
          "1064:   ASSERT(fd >= 0);",
          "1066:   init_process_options(\"spawn_helper8\", exit_cb);",
          "1068:   ASSERT(0 == uv_pipe_init(uv_default_loop(), &in, 0));",
          "1070:   options.stdio = stdio;",
          "1071:   options.stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;",
          "1072:   options.stdio[0].data.stream = (uv_stream_t*) &in;",
          "1073:   options.stdio_count = 1;",
          "1075:   ASSERT(0 == uv_spawn(uv_default_loop(), &process, &options));",
          "1077:   buf = uv_buf_init((char*) &fd, sizeof(fd));",
          "1078:   ASSERT(0 == uv_write(&write_req, (uv_stream_t*) &in, &buf, 1, write_cb));",
          "1080:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "1081:   ASSERT(0 == uv_fs_close(uv_default_loop(), &fs_req, fd, NULL));",
          "1083:   ASSERT(exit_cb_called == 1);",
          "1086:   MAKE_VALGRIND_HAPPY();",
          "1087:   return 0;",
          "1088: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f17c535b73a888b0efca816b00361ea21cdc94be",
      "candidate_info": {
        "commit_hash": "f17c535b73a888b0efca816b00361ea21cdc94be",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/f17c535b73a888b0efca816b00361ea21cdc94be",
        "files": [
          "Makefile.am",
          "Makefile.mingw",
          "include/uv-unix.h",
          "src/heap-inl.h",
          "src/unix/loop.c",
          "src/unix/timer.c",
          "uv.gyp"
        ],
        "message": "unix: use a heap for timers\n\nReplace the red-black tree with a heap.  The most common operation that\nlibuv performs on timers is looking up the first timer to expire.  With\na red-black tree, that operation is O(log n).  With a heap, it's O(1).",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "Makefile.mingw||Makefile.mingw",
          "include/uv-unix.h||include/uv-unix.h",
          "src/heap-inl.h||src/heap-inl.h",
          "src/unix/loop.c||src/unix/loop.c",
          "src/unix/timer.c||src/unix/timer.c",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: libuv_la_CFLAGS = @CFLAGS@",
          "26: libuv_la_LDFLAGS = -no-undefined -version-info 11:0:0",
          "27: libuv_la_SOURCES = src/fs-poll.c \\",
          "28:                    src/inet.c \\",
          "29:                    src/queue.h \\",
          "30:                    src/uv-common.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:                    src/heap-inl.h \\",
          "",
          "---------------"
        ],
        "Makefile.mingw||Makefile.mingw": [
          "File: Makefile.mingw -> Makefile.mingw",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:            include/uv-version.h \\",
          "30:            include/uv-win.h \\",
          "31:            include/uv.h \\",
          "32:            src/queue.h \\",
          "33:            src/uv-common.h \\",
          "34:            src/win/atomicops-inl.h \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32:            src/heap-inl.h \\",
          "",
          "---------------"
        ],
        "include/uv-unix.h||include/uv-unix.h": [
          "File: include/uv-unix.h -> include/uv-unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "177:   void* idle_handles[2];                                                      \\",
          "178:   void* async_handles[2];                                                     \\",
          "179:   struct uv__async async_watcher;                                             \\",
          "184:   uint64_t time;                                                              \\",
          "185:   int signal_pipefd[2];                                                       \\",
          "186:   uv__io_t signal_io_watcher;                                                 \\",
          "187:   uv_signal_t child_watcher;                                                  \\",
          "188:   int emfile_fd;                                                              \\",
          "190:   UV_PLATFORM_LOOP_FIELDS                                                     \\",
          "",
          "[Removed Lines]",
          "181:   struct uv__timers {                                                         \\",
          "182:     struct uv_timer_s* rbh_root;                                              \\",
          "183:   } timer_handles;                                                            \\",
          "189:   uint64_t timer_counter;                                                     \\",
          "",
          "[Added Lines]",
          "180:   struct {                                                                    \\",
          "181:     void* min;                                                                \\",
          "182:     unsigned int nelts;                                                       \\",
          "183:   } timer_heap;                                                               \\",
          "184:   uint64_t timer_counter;                                                     \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "265:   int pending;                                                                \\",
          "267: #define UV_TIMER_PRIVATE_FIELDS                                               \\",
          "275:   uv_timer_cb timer_cb;                                                       \\",
          "276:   uint64_t timeout;                                                           \\",
          "277:   uint64_t repeat;                                                            \\",
          "278:   uint64_t start_id;",
          "",
          "[Removed Lines]",
          "269:   struct {                                                                    \\",
          "270:     struct uv_timer_s* rbe_left;                                              \\",
          "271:     struct uv_timer_s* rbe_right;                                             \\",
          "272:     struct uv_timer_s* rbe_parent;                                            \\",
          "273:     int rbe_color;                                                            \\",
          "274:   } tree_entry;                                                               \\",
          "",
          "[Added Lines]",
          "269:   void* heap_node[3];                                                         \\",
          "",
          "---------------"
        ],
        "src/heap-inl.h||src/heap-inl.h": [
          "File: src/heap-inl.h -> src/heap-inl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #ifndef UV_SRC_HEAP_H_",
          "17: #define UV_SRC_HEAP_H_",
          "21: #if defined(__GNUC__)",
          "22: # define HEAP_EXPORT(declaration) __attribute__((unused)) static declaration",
          "23: #else",
          "24: # define HEAP_EXPORT(declaration) static declaration",
          "25: #endif",
          "27: struct heap_node {",
          "28:   struct heap_node* left;",
          "29:   struct heap_node* right;",
          "30:   struct heap_node* parent;",
          "31: };",
          "40: struct heap {",
          "41:   struct heap_node* min;",
          "42:   unsigned int nelts;",
          "43: };",
          "46: typedef int (*heap_compare_fn)(const struct heap_node* a,",
          "47:                                const struct heap_node* b);",
          "50: HEAP_EXPORT(void heap_init(struct heap* heap));",
          "51: HEAP_EXPORT(struct heap_node* heap_min(const struct heap* heap));",
          "52: HEAP_EXPORT(void heap_insert(struct heap* heap,",
          "53:                              struct heap_node* newnode,",
          "54:                              heap_compare_fn less_than));",
          "55: HEAP_EXPORT(void heap_remove(struct heap* heap,",
          "56:                              struct heap_node* node,",
          "57:                              heap_compare_fn less_than));",
          "58: HEAP_EXPORT(void heap_dequeue(struct heap* heap, heap_compare_fn less_than));",
          "62: HEAP_EXPORT(void heap_init(struct heap* heap)) {",
          "63:   heap->min = NULL;",
          "64:   heap->nelts = 0;",
          "65: }",
          "67: HEAP_EXPORT(struct heap_node* heap_min(const struct heap* heap)) {",
          "68:   return heap->min;",
          "69: }",
          "72: static void heap_node_swap(struct heap* heap,",
          "73:                            struct heap_node* parent,",
          "74:                            struct heap_node* child) {",
          "75:   struct heap_node* sibling;",
          "76:   struct heap_node t;",
          "78:   t = *parent;",
          "82:   parent->parent = child;",
          "83:   if (child->left == child) {",
          "84:     child->left = parent;",
          "85:     sibling = child->right;",
          "86:   } else {",
          "87:     child->right = parent;",
          "88:     sibling = child->left;",
          "89:   }",
          "90:   if (sibling != NULL)",
          "91:     sibling->parent = child;",
          "93:   if (parent->left != NULL)",
          "94:     parent->left->parent = parent;",
          "95:   if (parent->right != NULL)",
          "96:     parent->right->parent = parent;",
          "98:   if (child->parent == NULL)",
          "99:     heap->min = child;",
          "100:   else if (child->parent->left == parent)",
          "101:     child->parent->left = child;",
          "102:   else",
          "103:     child->parent->right = child;",
          "104: }",
          "106: HEAP_EXPORT(void heap_insert(struct heap* heap,",
          "107:                              struct heap_node* newnode,",
          "108:                              heap_compare_fn less_than)) {",
          "109:   struct heap_node** parent;",
          "110:   struct heap_node** child;",
          "111:   unsigned int path;",
          "112:   unsigned int n;",
          "113:   unsigned int k;",
          "115:   newnode->left = NULL;",
          "116:   newnode->right = NULL;",
          "117:   newnode->parent = NULL;",
          "122:   path = 0;",
          "123:   for (k = 0, n = 1 + heap->nelts; n >= 2; k += 1, n /= 2)",
          "124:     path = (path << 1) | (n & 1);",
          "127:   parent = child = &heap->min;",
          "128:   while (k > 0) {",
          "129:     parent = child;",
          "130:     if (path & 1)",
          "131:       child = &(*child)->right;",
          "132:     else",
          "133:       child = &(*child)->left;",
          "134:     path >>= 1;",
          "135:     k -= 1;",
          "136:   }",
          "139:   newnode->parent = *parent;",
          "141:   heap->nelts += 1;",
          "146:   while (newnode->parent != NULL && less_than(newnode, newnode->parent))",
          "147:     heap_node_swap(heap, newnode->parent, newnode);",
          "148: }",
          "150: HEAP_EXPORT(void heap_remove(struct heap* heap,",
          "151:                              struct heap_node* node,",
          "152:                              heap_compare_fn less_than)) {",
          "153:   struct heap_node* smallest;",
          "154:   struct heap_node** max;",
          "155:   struct heap_node* child;",
          "156:   unsigned int path;",
          "157:   unsigned int k;",
          "158:   unsigned int n;",
          "160:   if (heap->nelts == 0)",
          "161:     return;",
          "166:   path = 0;",
          "167:   for (k = 0, n = heap->nelts; n >= 2; k += 1, n /= 2)",
          "168:     path = (path << 1) | (n & 1);",
          "171:   max = &heap->min;",
          "172:   while (k > 0) {",
          "173:     if (path & 1)",
          "174:       max = &(*max)->right;",
          "175:     else",
          "176:       max = &(*max)->left;",
          "177:     path >>= 1;",
          "178:     k -= 1;",
          "179:   }",
          "181:   heap->nelts -= 1;",
          "184:   child = *max;",
          "187:   if (child == node) {",
          "189:     if (child == heap->min) {",
          "190:       heap->min = NULL;",
          "191:     }",
          "192:     return;",
          "193:   }",
          "196:   child->left = node->left;",
          "197:   child->right = node->right;",
          "198:   child->parent = node->parent;",
          "200:   if (child->left != NULL) {",
          "201:     child->left->parent = child;",
          "202:   }",
          "204:   if (child->right != NULL) {",
          "205:     child->right->parent = child;",
          "206:   }",
          "208:   if (node->parent == NULL) {",
          "209:     heap->min = child;",
          "210:   } else if (node->parent->left == node) {",
          "211:     node->parent->left = child;",
          "212:   } else {",
          "213:     node->parent->right = child;",
          "214:   }",
          "220:   for (;;) {",
          "221:     smallest = child;",
          "222:     if (child->left != NULL && less_than(smallest, child))",
          "223:       smallest = child->left;",
          "224:     if (child->right != NULL && less_than(smallest, child))",
          "225:       smallest = child->right;",
          "226:     if (smallest == child)",
          "227:       break;",
          "228:     heap_node_swap(heap, child, smallest);",
          "229:   }",
          "230: }",
          "232: HEAP_EXPORT(void heap_dequeue(struct heap* heap, heap_compare_fn less_than)) {",
          "233:   heap_remove(heap, heap->min, less_than);",
          "234: }",
          "236: #undef HEAP_EXPORT",
          "",
          "---------------"
        ],
        "src/unix/loop.c||src/unix/loop.c": [
          "File: src/unix/loop.c -> src/unix/loop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include \"uv.h\"",
          "23: #include \"tree.h\"",
          "24: #include \"internal.h\"",
          "25: #include <stdlib.h>",
          "26: #include <string.h>",
          "27: #include <unistd.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"heap-inl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:   uv__signal_global_once_init();",
          "82:   memset(loop, 0, sizeof(*loop));",
          "84:   QUEUE_INIT(&loop->wq);",
          "85:   QUEUE_INIT(&loop->active_reqs);",
          "86:   QUEUE_INIT(&loop->idle_handles);",
          "",
          "[Removed Lines]",
          "83:   RB_INIT(&loop->timer_handles);",
          "",
          "[Added Lines]",
          "84:   heap_init((struct heap*) &loop->timer_heap);",
          "",
          "---------------"
        ],
        "src/unix/timer.c||src/unix/timer.c": [
          "File: src/unix/timer.c -> src/unix/timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"uv.h\"",
          "22: #include \"internal.h\"",
          "23: #include <assert.h>",
          "24: #include <limits.h>",
          "28:   if (a->timeout < b->timeout)",
          "31:     return 1;",
          "36:   if (a->start_id < b->start_id)",
          "39:     return 1;",
          "40:   return 0;",
          "41: }",
          "47: int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle) {",
          "48:   uv__handle_init(loop, (uv_handle_t*)handle, UV_TIMER);",
          "49:   handle->timer_cb = NULL;",
          "50:   handle->repeat = 0;",
          "52:   return 0;",
          "53: }",
          "",
          "[Removed Lines]",
          "27: static int uv__timer_cmp(const uv_timer_t* a, const uv_timer_t* b) {",
          "29:     return -1;",
          "30:   if (a->timeout > b->timeout)",
          "37:     return -1;",
          "38:   if (a->start_id > b->start_id)",
          "44: RB_GENERATE_STATIC(uv__timers, uv_timer_s, tree_entry, uv__timer_cmp)",
          "",
          "[Added Lines]",
          "23: #include \"heap-inl.h\"",
          "29: static int timer_less_than(const struct heap_node* ha,",
          "30:                            const struct heap_node* hb) {",
          "31:   const uv_timer_t* a;",
          "32:   const uv_timer_t* b;",
          "34:   a = container_of(ha, const uv_timer_t, heap_node);",
          "35:   b = container_of(hb, const uv_timer_t, heap_node);",
          "39:   if (b->timeout < a->timeout)",
          "40:     return 0;",
          "47:   if (b->start_id < a->start_id)",
          "48:     return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:   handle->start_id = handle->loop->timer_counter++;",
          "76:   uv__handle_start(handle);",
          "78:   return 0;",
          "",
          "[Removed Lines]",
          "75:   RB_INSERT(uv__timers, &handle->loop->timer_handles, handle);",
          "",
          "[Added Lines]",
          "81:   heap_insert((struct heap*) &handle->loop->timer_heap,",
          "82:               (struct heap_node*) &handle->heap_node,",
          "83:               timer_less_than);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83:   if (!uv__is_active(handle))",
          "84:     return 0;",
          "87:   uv__handle_stop(handle);",
          "89:   return 0;",
          "",
          "[Removed Lines]",
          "86:   RB_REMOVE(uv__timers, &handle->loop->timer_handles, handle);",
          "",
          "[Added Lines]",
          "94:   heap_remove((struct heap*) &handle->loop->timer_heap,",
          "95:               (struct heap_node*) &handle->heap_node,",
          "96:               timer_less_than);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "116: int uv__next_timeout(const uv_loop_t* loop) {",
          "117:   const uv_timer_t* handle;",
          "118:   uint64_t diff;",
          "126:   if (handle->timeout <= loop->time)",
          "127:     return 0;",
          "",
          "[Removed Lines]",
          "121:   handle = RB_MIN(uv__timers, (struct uv__timers*) &loop->timer_handles);",
          "123:   if (handle == NULL)",
          "",
          "[Added Lines]",
          "127:   const struct heap_node* heap_node;",
          "131:   heap_node = heap_min((const struct heap*) &loop->timer_heap);",
          "132:   if (heap_node == NULL)",
          "135:   handle = container_of(heap_node, const uv_timer_t, heap_node);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "137: void uv__run_timers(uv_loop_t* loop) {",
          "138:   uv_timer_t* handle;",
          "141:     if (handle->timeout > loop->time)",
          "142:       break;",
          "",
          "[Removed Lines]",
          "140:   while ((handle = RB_MIN(uv__timers, &loop->timer_handles))) {",
          "",
          "[Added Lines]",
          "148:   struct heap_node* heap_node;",
          "151:   for (;;) {",
          "152:     heap_node = heap_min((struct heap*) &loop->timer_heap);",
          "153:     if (heap_node == NULL)",
          "154:       break;",
          "156:     handle = container_of(heap_node, uv_timer_t, heap_node);",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:         'include/uv-errno.h',",
          "64:         'include/uv-version.h',",
          "65:         'src/fs-poll.c',",
          "66:         'src/inet.c',",
          "67:         'src/queue.h',",
          "68:         'src/uv-common.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:         'src/heap-inl.h',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0f7b2963ada3198348b04ae564b56ac9774a2c47",
      "candidate_info": {
        "commit_hash": "0f7b2963ada3198348b04ae564b56ac9774a2c47",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/0f7b2963ada3198348b04ae564b56ac9774a2c47",
        "files": [
          "include/uv.h",
          "src/unix/udp.c",
          "src/win/udp.c",
          "test/benchmark-udp-pummel.c",
          "test/echo-server.c",
          "test/test-getsockname.c",
          "test/test-udp-ipv6.c",
          "test/test-udp-multicast-join.c",
          "test/test-udp-open.c",
          "test/test-udp-send-and-recv.c"
        ],
        "message": "include: uv_udp_recv_cb now takes const uv_buf_t*\n\nPassing or returning structs as values makes life hard for people that\nwork with libuv through a foreign function interface. Switch to a\npointer-based approach.\n\nFixes #684.",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/unix/udp.c||src/unix/udp.c",
          "src/win/udp.c||src/win/udp.c",
          "test/benchmark-udp-pummel.c||test/benchmark-udp-pummel.c",
          "test/echo-server.c||test/echo-server.c",
          "test/test-getsockname.c||test/test-getsockname.c",
          "test/test-udp-ipv6.c||test/test-udp-ipv6.c",
          "test/test-udp-multicast-join.c||test/test-udp-multicast-join.c",
          "test/test-udp-open.c||test/test-udp-open.c",
          "test/test-udp-send-and-recv.c||test/test-udp-send-and-recv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "833: struct uv_udp_s {",
          "",
          "[Removed Lines]",
          "829: typedef void (*uv_udp_recv_cb)(uv_udp_t* handle, ssize_t nread, uv_buf_t buf,",
          "830:     struct sockaddr* addr, unsigned flags);",
          "",
          "[Added Lines]",
          "829: typedef void (*uv_udp_recv_cb)(uv_udp_t* handle,",
          "830:                                ssize_t nread,",
          "831:                                const uv_buf_t* buf,",
          "832:                                const struct sockaddr* addr,",
          "833:                                unsigned flags);",
          "",
          "---------------"
        ],
        "src/unix/udp.c||src/unix/udp.c": [
          "File: src/unix/udp.c -> src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "207:   do {",
          "208:     handle->alloc_cb((uv_handle_t*) handle, 64 * 1024, &buf);",
          "209:     if (buf.len == 0) {",
          "211:       return;",
          "212:     }",
          "213:     assert(buf.base != NULL);",
          "",
          "[Removed Lines]",
          "210:       handle->recv_cb(handle, UV_ENOBUFS, buf, NULL, 0);",
          "",
          "[Added Lines]",
          "210:       handle->recv_cb(handle, UV_ENOBUFS, &buf, NULL, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:     if (nread == -1) {",
          "225:       if (errno == EAGAIN || errno == EWOULDBLOCK)",
          "227:       else",
          "229:     }",
          "230:     else {",
          "231:       flags = 0;",
          "",
          "[Removed Lines]",
          "226:         handle->recv_cb(handle, 0, buf, NULL, 0);",
          "228:         handle->recv_cb(handle, -errno, buf, NULL, 0);",
          "",
          "[Added Lines]",
          "226:         handle->recv_cb(handle, 0, &buf, NULL, 0);",
          "228:         handle->recv_cb(handle, -errno, &buf, NULL, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "236:       handle->recv_cb(handle,",
          "237:                       nread,",
          "240:                       flags);",
          "241:     }",
          "242:   }",
          "",
          "[Removed Lines]",
          "238:                       buf,",
          "239:                       (struct sockaddr*)&peer,",
          "",
          "[Added Lines]",
          "238:                       &buf,",
          "239:                       (const struct sockaddr*) &peer,",
          "",
          "---------------"
        ],
        "src/win/udp.c||src/win/udp.c": [
          "File: src/win/udp.c -> src/win/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "274:     handle->alloc_cb((uv_handle_t*) handle, 65536, &handle->recv_buffer);",
          "275:     if (handle->recv_buffer.len == 0) {",
          "277:       return;",
          "278:     }",
          "279:     assert(handle->recv_buffer.base != NULL);",
          "",
          "[Removed Lines]",
          "276:       handle->recv_cb(handle, UV_ENOBUFS, handle->recv_buffer, NULL, 0);",
          "",
          "[Added Lines]",
          "276:       handle->recv_cb(handle, UV_ENOBUFS, &handle->recv_buffer, NULL, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "497:         uv_udp_recv_stop(handle);",
          "498:         buf = (handle->flags & UV_HANDLE_ZERO_READ) ?",
          "499:               uv_buf_init(NULL, 0) : handle->recv_buffer;",
          "501:       }",
          "502:       goto done;",
          "503:     }",
          "",
          "[Removed Lines]",
          "500:         handle->recv_cb(handle, uv_translate_sys_error(err), buf, NULL, 0);",
          "",
          "[Added Lines]",
          "500:         handle->recv_cb(handle, uv_translate_sys_error(err), &buf, NULL, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "508:     partial = !REQ_SUCCESS(req);",
          "509:     handle->recv_cb(handle,",
          "510:                     req->overlapped.InternalHigh,",
          "513:                     partial ? UV_UDP_PARTIAL : 0);",
          "514:   } else if (handle->flags & UV_HANDLE_READING) {",
          "515:     DWORD bytes, err, flags;",
          "",
          "[Removed Lines]",
          "511:                     handle->recv_buffer,",
          "512:                     (struct sockaddr*) &handle->recv_from,",
          "",
          "[Added Lines]",
          "511:                     &handle->recv_buffer,",
          "512:                     (const struct sockaddr*) &handle->recv_from,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "521:     handle->alloc_cb((uv_handle_t*) handle, 65536, &buf);",
          "522:     if (buf.len == 0) {",
          "524:       goto done;",
          "525:     }",
          "526:     assert(buf.base != NULL);",
          "",
          "[Removed Lines]",
          "523:       handle->recv_cb(handle, UV_ENOBUFS, buf, NULL, 0);",
          "",
          "[Added Lines]",
          "523:       handle->recv_cb(handle, UV_ENOBUFS, &buf, NULL, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "541:                     NULL) != SOCKET_ERROR) {",
          "545:     } else {",
          "546:       err = WSAGetLastError();",
          "547:       if (err == WSAEMSGSIZE) {",
          "549:         handle->recv_cb(handle,",
          "550:                         bytes,",
          "553:                         UV_UDP_PARTIAL);",
          "554:       } if (err == WSAEWOULDBLOCK) {",
          "557:       } else if (err != WSAECONNRESET && err != WSAENETRESET) {",
          "560:         uv_udp_recv_stop(handle);",
          "562:       }",
          "563:     }",
          "564:   }",
          "",
          "[Removed Lines]",
          "544:       handle->recv_cb(handle, bytes, buf, (struct sockaddr*) &from, 0);",
          "551:                         buf,",
          "552:                         (struct sockaddr*) &from,",
          "556:         handle->recv_cb(handle, 0, buf, NULL, 0);",
          "561:         handle->recv_cb(handle, uv_translate_sys_error(err), buf, NULL, 0);",
          "",
          "[Added Lines]",
          "544:       handle->recv_cb(handle, bytes, &buf, (const struct sockaddr*) &from, 0);",
          "551:                         &buf,",
          "552:                         (const struct sockaddr*) &from,",
          "556:         handle->recv_cb(handle, 0, &buf, NULL, 0);",
          "561:         handle->recv_cb(handle, uv_translate_sys_error(err), &buf, NULL, 0);",
          "",
          "---------------"
        ],
        "test/benchmark-udp-pummel.c||test/benchmark-udp-pummel.c": [
          "File: test/benchmark-udp-pummel.c -> test/benchmark-udp-pummel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "109: static void recv_cb(uv_udp_t* handle,",
          "110:                     ssize_t nread,",
          "113:                     unsigned flags) {",
          "114:   if (nread == 0)",
          "115:     return;",
          "",
          "[Removed Lines]",
          "111:                     uv_buf_t buf,",
          "112:                     struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "111:                     const uv_buf_t* buf,",
          "112:                     const struct sockaddr* addr,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:   }",
          "122:   ASSERT(addr->sa_family == AF_INET);",
          "125:   recv_cb_called++;",
          "126: }",
          "",
          "[Removed Lines]",
          "123:   ASSERT(!memcmp(buf.base, EXPECTED, nread));",
          "",
          "[Added Lines]",
          "123:   ASSERT(!memcmp(buf->base, EXPECTED, nread));",
          "",
          "---------------"
        ],
        "test/echo-server.c||test/echo-server.c": [
          "File: test/echo-server.c -> test/echo-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "191: static void on_recv(uv_udp_t* handle,",
          "192:                     ssize_t nread,",
          "195:                     unsigned flags) {",
          "196:   uv_udp_send_t* req;",
          "197:   int r;",
          "199:   ASSERT(nread > 0);",
          "",
          "[Removed Lines]",
          "193:                     uv_buf_t buf,",
          "194:                     struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "193:                     const uv_buf_t* rcvbuf,",
          "194:                     const struct sockaddr* addr,",
          "197:   uv_buf_t sndbuf;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202:   req = malloc(sizeof(*req));",
          "203:   ASSERT(req != NULL);",
          "206:   ASSERT(r == 0);",
          "207: }",
          "",
          "[Removed Lines]",
          "205:   r = uv_udp_send(req, handle, &buf, 1, *(struct sockaddr_in*)addr, on_send);",
          "",
          "[Added Lines]",
          "206:   sndbuf = *rcvbuf;",
          "207:   r = uv_udp_send(req,",
          "208:                   handle,",
          "209:                   &sndbuf,",
          "210:                   1,",
          "212:                   on_send);",
          "",
          "---------------"
        ],
        "test/test-getsockname.c||test/test-getsockname.c": [
          "File: test/test-getsockname.c -> test/test-getsockname.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "235: static void udp_recv(uv_udp_t* handle,",
          "236:                      ssize_t nread,",
          "239:                      unsigned flags) {",
          "240:   struct sockaddr sockname;",
          "241:   int namelen;",
          "242:   int r;",
          "244:   ASSERT(nread >= 0);",
          "247:   if (nread == 0) {",
          "248:     return;",
          "",
          "[Removed Lines]",
          "237:                      uv_buf_t buf,",
          "238:                      struct sockaddr* addr,",
          "245:   free(buf.base);",
          "",
          "[Added Lines]",
          "237:                      const uv_buf_t* buf,",
          "238:                      const struct sockaddr* addr,",
          "245:   free(buf->base);",
          "",
          "---------------"
        ],
        "test/test-udp-ipv6.c||test/test-udp-ipv6.c": [
          "File: test/test-udp-ipv6.c -> test/test-udp-ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71: static void ipv6_recv_fail(uv_udp_t* handle,",
          "72:                            ssize_t nread,",
          "75:                            unsigned flags) {",
          "76:   ASSERT(0 && \"this function should not have been called\");",
          "77: }",
          "",
          "[Removed Lines]",
          "73:                            uv_buf_t buf,",
          "74:                            struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "73:                            const uv_buf_t* buf,",
          "74:                            const struct sockaddr* addr,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80: static void ipv6_recv_ok(uv_udp_t* handle,",
          "81:                          ssize_t nread,",
          "84:                          unsigned flags) {",
          "85:   CHECK_HANDLE(handle);",
          "86:   ASSERT(nread >= 0);",
          "",
          "[Removed Lines]",
          "82:                          uv_buf_t buf,",
          "83:                          struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "82:                          const uv_buf_t* buf,",
          "83:                          const struct sockaddr* addr,",
          "",
          "---------------"
        ],
        "test/test-udp-multicast-join.c||test/test-udp-multicast-join.c": [
          "File: test/test-udp-multicast-join.c -> test/test-udp-multicast-join.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: static void cl_recv_cb(uv_udp_t* handle,",
          "70:                        ssize_t nread,",
          "73:                        unsigned flags) {",
          "74:   CHECK_HANDLE(handle);",
          "75:   ASSERT(flags == 0);",
          "",
          "[Removed Lines]",
          "71:                        uv_buf_t buf,",
          "72:                        struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "71:                        const uv_buf_t* buf,",
          "72:                        const struct sockaddr* addr,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:   ASSERT(addr != NULL);",
          "91:   ASSERT(nread == 4);",
          "95:   uv_close((uv_handle_t*) &client, close_cb);",
          "",
          "[Removed Lines]",
          "92:   ASSERT(!memcmp(\"PING\", buf.base, nread));",
          "",
          "[Added Lines]",
          "92:   ASSERT(!memcmp(\"PING\", buf->base, nread));",
          "",
          "---------------"
        ],
        "test/test-udp-open.c||test/test-udp-open.c": [
          "File: test/test-udp-open.c -> test/test-udp-open.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: static void recv_cb(uv_udp_t* handle,",
          "87:                        ssize_t nread,",
          "90:                        unsigned flags) {",
          "91:   int r;",
          "",
          "[Removed Lines]",
          "88:                        uv_buf_t buf,",
          "89:                        struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "88:                        const uv_buf_t* buf,",
          "89:                        const struct sockaddr* addr,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "106:   ASSERT(addr != NULL);",
          "107:   ASSERT(nread == 4);",
          "110:   r = uv_udp_recv_stop(handle);",
          "111:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "108:   ASSERT(memcmp(\"PING\", buf.base, nread) == 0);",
          "",
          "[Added Lines]",
          "108:   ASSERT(memcmp(\"PING\", buf->base, nread) == 0);",
          "",
          "---------------"
        ],
        "test/test-udp-send-and-recv.c||test/test-udp-send-and-recv.c": [
          "File: test/test-udp-send-and-recv.c -> test/test-udp-send-and-recv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: static void cl_recv_cb(uv_udp_t* handle,",
          "63:                        ssize_t nread,",
          "66:                        unsigned flags) {",
          "67:   CHECK_HANDLE(handle);",
          "68:   ASSERT(flags == 0);",
          "",
          "[Removed Lines]",
          "64:                        uv_buf_t buf,",
          "65:                        struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "64:                        const uv_buf_t* buf,",
          "65:                        const struct sockaddr* addr,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:   ASSERT(addr != NULL);",
          "82:   ASSERT(nread == 4);",
          "85:   cl_recv_cb_called++;",
          "",
          "[Removed Lines]",
          "83:   ASSERT(!memcmp(\"PONG\", buf.base, nread));",
          "",
          "[Added Lines]",
          "83:   ASSERT(!memcmp(\"PONG\", buf->base, nread));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "117: static void sv_recv_cb(uv_udp_t* handle,",
          "118:                        ssize_t nread,",
          "121:                        unsigned flags) {",
          "122:   uv_udp_send_t* req;",
          "123:   int r;",
          "125:   if (nread < 0) {",
          "",
          "[Removed Lines]",
          "119:                        uv_buf_t buf,",
          "120:                        struct sockaddr* addr,",
          "",
          "[Added Lines]",
          "119:                        const uv_buf_t* rcvbuf,",
          "120:                        const struct sockaddr* addr,",
          "123:   uv_buf_t sndbuf;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "139:   ASSERT(addr != NULL);",
          "140:   ASSERT(nread == 4);",
          "",
          "[Removed Lines]",
          "141:   ASSERT(!memcmp(\"PING\", buf.base, nread));",
          "",
          "[Added Lines]",
          "142:   ASSERT(!memcmp(\"PING\", rcvbuf->base, nread));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "150:   req = malloc(sizeof *req);",
          "151:   ASSERT(req != NULL);",
          "155:   r = uv_udp_send(req,",
          "156:                   handle,",
          "158:                   1,",
          "160:                   sv_send_cb);",
          "161:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "153:   buf = uv_buf_init(\"PONG\", 4);",
          "157:                   &buf,",
          "",
          "[Added Lines]",
          "154:   sndbuf = uv_buf_init(\"PONG\", 4);",
          "157:                   &sndbuf,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f756955b643fdd2e3b803e1a04d5a0f3095e41b",
      "candidate_info": {
        "commit_hash": "7f756955b643fdd2e3b803e1a04d5a0f3095e41b",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/7f756955b643fdd2e3b803e1a04d5a0f3095e41b",
        "files": [
          "src/win/fs.c"
        ],
        "message": "windows: make uv_fs_chmod() report errors correctly\n\nBefore this patch libuv would attempt to use GetLastError() to retrieve\nthe cause of NtQueryInformationFile failure, but that's not how it\nshould be done.",
        "before_after_code_files": [
          "src/win/fs.c||src/win/fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/fs.c||src/win/fs.c": [
          "File: src/win/fs.c -> src/win/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1070: static void fs__fchmod(uv_fs_t* req) {",
          "1071:   int fd = req->fd;",
          "1073:   HANDLE handle;",
          "1074:   NTSTATUS nt_status;",
          "1075:   IO_STATUS_BLOCK io_status;",
          "",
          "[Removed Lines]",
          "1072:   int result;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1078:   VERIFY_FD(fd, req);",
          "1082:   nt_status = pNtQueryInformationFile(handle,",
          "1083:                                       &io_status,",
          "",
          "[Removed Lines]",
          "1080:   handle = (HANDLE)_get_osfhandle(fd);",
          "",
          "[Added Lines]",
          "1079:   handle = (HANDLE) _get_osfhandle(fd);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1085:                                       sizeof file_info,",
          "1086:                                       FileBasicInformation);",
          "1091:   }",
          "1093:   if (req->mode & _S_IWRITE) {",
          "",
          "[Removed Lines]",
          "1088:   if (nt_status != STATUS_SUCCESS) {",
          "1089:     result = -1;",
          "1090:     goto done;",
          "",
          "[Added Lines]",
          "1087:   if (!NT_SUCCESS(nt_status)) {",
          "1088:     SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(nt_status));",
          "1089:     return;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1102:                                     sizeof file_info,",
          "1103:                                     FileBasicInformation);",
          "1108:   }",
          "1114: }",
          "",
          "[Removed Lines]",
          "1105:   if (nt_status != STATUS_SUCCESS) {",
          "1106:     result = -1;",
          "1107:     goto done;",
          "1110:   result = 0;",
          "1112: done:",
          "1113:   SET_REQ_RESULT(req, result);",
          "",
          "[Added Lines]",
          "1104:   if (!NT_SUCCESS(nt_status)) {",
          "1105:     SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(nt_status));",
          "1106:     return;",
          "1109:   SET_REQ_SUCCESS(req);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
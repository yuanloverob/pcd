{
  "cve_id": "CVE-2019-19926",
  "cve_desc": "multiSelect in select.c in SQLite 3.30.1 mishandles certain errors during parsing, as demonstrated by errors from sqlite3WindowRewrite() calls. NOTE: this vulnerability exists because of an incomplete fix for CVE-2019-19880.",
  "repo": "sqlite/sqlite",
  "patch_hash": "8428b3b437569338a9d1e10c4cd8154acbe33089",
  "patch_info": {
    "commit_hash": "8428b3b437569338a9d1e10c4cd8154acbe33089",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/8428b3b437569338a9d1e10c4cd8154acbe33089",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c"
    ],
    "message": "Continuation of [e2bddcd4c55ba3cb]: Add another spot where it is necessary to abort early due to prior errors in sqlite3WindowRewrite().\n\nFossilOrigin-Name: cba2a2a44cdf138a629109bb0ad088ed4ef67fc66bed3e0373554681a39615d2",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 3d4c0bf8904135fa68c75801bfa738715cacc3b19dc8ad6ef550b11798d4b121",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2809:     }",
      "2810:   #endif",
      "2811:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2812:   if( pParse->nErr ) goto multi_select_end;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f7c92e82d27b88b1fa56ff72796ed42e89f614c9",
      "candidate_info": {
        "commit_hash": "f7c92e82d27b88b1fa56ff72796ed42e89f614c9",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f7c92e82d27b88b1fa56ff72796ed42e89f614c9",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "test/distinct2.test"
        ],
        "message": "Avoid assuming that \"column IS ?\", where column is declared UNIQUE, matches only a single row (as \"?\" might be NULL). Fix for [b8689402].\n\nFossilOrigin-Name: d02490a2f0cae047087130b4ad8f55f265845c2ffb3bde3b7d507edb54acea6d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "test/distinct2.test||test/distinct2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4c01e0170e113ad052b6c3980beb4be9f1dc03fb3cf34132b90e8b82b23f654e",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3765:           u16 eOp = pLoop->aLTerm[j]->eOperator;",
          "3775:           if( (eOp & eqOpMask)!=0 ){",
          "3777:               testcase( isOrderDistinct );",
          "3778:               isOrderDistinct = 0;",
          "3779:             }",
          "",
          "[Removed Lines]",
          "3776:             if( eOp & WO_ISNULL ){",
          "",
          "[Added Lines]",
          "3780:             if( eOp & (WO_ISNULL|WO_IS) ){",
          "3781:               testcase( eOp & WO_ISNULL );",
          "3782:               testcase( eOp & WO_IS );",
          "",
          "---------------"
        ],
        "test/distinct2.test||test/distinct2.test": [
          "File: test/distinct2.test -> test/distinct2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "274:   two 1 1",
          "275: }",
          "279: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277: #-------------------------------------------------------------------------",
          "278: #",
          "279: reset_db",
          "280: do_execsql_test 3000 {",
          "281:   CREATE TABLE t0 (c0, c1 NOT NULL DEFAULT 1, c2, PRIMARY KEY (c0, c1));",
          "282:   INSERT INTO t0(c2) VALUES (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL);",
          "283:   INSERT INTO t0(c2) VALUES('a');",
          "284: }",
          "286: do_execsql_test 3010 {",
          "287:   SELECT DISTINCT * FROM t0 WHERE NULL IS t0.c0;",
          "288: } {",
          "289:   {} 1 {}",
          "290:   {} 1 a",
          "291: }",
          "293: do_execsql_test 3020 {",
          "294:   ANALYZE;",
          "295: }",
          "297: do_execsql_test 3030 {",
          "298:   SELECT DISTINCT * FROM t0 WHERE NULL IS c0;",
          "299: } {",
          "300:   {} 1 {}",
          "301:   {} 1 a",
          "302: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d471bcb3964e8ee417dfb45acee824dd77238acc",
      "candidate_info": {
        "commit_hash": "d471bcb3964e8ee417dfb45acee824dd77238acc",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d471bcb3964e8ee417dfb45acee824dd77238acc",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c"
        ],
        "message": "Remove an optimization that can no longer occur, being superceded by the subquery-reuse optimization.  Put an assert in place of the optimization to detect if the need for this optimization ever returns.\n\nFossilOrigin-Name: 4fcdc7a2939457e51aab37cab168677cd7f464a9a0aff4f8981e864a30828b3b",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/select.c||src/select.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/select.c||src/select.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9fb646f29c05bca5f677a2c7c4f45c36bfe0a0c6a88cb7968b4a0459bdd63bb2",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5835:     pSub = pItem->pSelect;",
          "5836:     if( pSub==0 ) continue;",
          "",
          "[Removed Lines]",
          "5844:     if( pItem->addrFillSub ){",
          "5845:       if( pItem->fg.viaCoroutine==0 ){",
          "5849:         testcase( sqlite3VdbeGetOp(v, pItem->addrFillSub)->opcode==OP_Once );",
          "5850:         sqlite3VdbeAddOp2(v, OP_Gosub, pItem->regReturn, pItem->addrFillSub);",
          "5851:       }",
          "5852:       continue;",
          "5853:     }",
          "",
          "[Added Lines]",
          "5843:     assert( pItem->addrFillSub==0 );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d985f7260b2f7b8a4977f1af330f49c110aa3f43",
      "candidate_info": {
        "commit_hash": "d985f7260b2f7b8a4977f1af330f49c110aa3f43",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d985f7260b2f7b8a4977f1af330f49c110aa3f43",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "CLI enhancements:  Add the \".filectrl\" command.  Make the \".testctrl\" command visible to \".help\".\n\nFossilOrigin-Name: 7b3a99fce8b4a757f2b2ef2f0b02d68566f2528d9ae1e30628522717f872466c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3a477fd0c944440be03d23c667053b346c769c6a4f6ba1ef094b7581a08d7bd4",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "3513:   \".fullschema ?--indent?   Show schema and the content of sqlite_stat tables\",",
          "3514:   \".headers on|off          Turn display of headers on or off\",",
          "3515:   \".help ?-all? ?PATTERN?   Show help text for PATTERN\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3513:   \".filectrl CMD ...        Run various sqlite3_file_control() operations\",",
          "3514:   \"                           Run \\\".filectrl\\\" with no arguments for details\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3627: #endif",
          "3628:   \".tables ?TABLE?          List names of tables matching LIKE pattern TABLE\",",
          "3629:   \".testcase NAME           Begin redirecting output to 'testcase-out.txt'\",",
          "3630:   \".timeout MS              Try opening locked tables for MS milliseconds\",",
          "3631:   \".timer on|off            Turn SQL timer on or off\",",
          "3632: #ifndef SQLITE_OMIT_TRACE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3632:   \".testctrl CMD ...        Run various sqlite3_test_control() operations\",",
          "3633:   \"                           Run \\\".testctrl\\\" with no arguments for details\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7277:   }else",
          "7278: #endif",
          "7280:   if( c=='f' && strncmp(azArg[0], \"fullschema\", n)==0 ){",
          "7281:     ShellState data;",
          "7282:     char *zErrMsg = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7284:   if( c=='f' && strncmp(azArg[0], \"filectrl\", n)==0 ){",
          "7285:     static const struct {",
          "7289:     } aCtrl[] = {",
          "7290:       { \"size_limit\",     SQLITE_FCNTL_SIZE_LIMIT,      \"[LIMIT]\"        },",
          "7291:       { \"chunk_size\",     SQLITE_FCNTL_CHUNK_SIZE,      \"SIZE\"           },",
          "7293:       { \"persist_wal\",    SQLITE_FCNTL_PERSIST_WAL,     \"[BOOLEAN]\"      },",
          "7294:       { \"psow\",       SQLITE_FCNTL_POWERSAFE_OVERWRITE, \"[BOOLEAN]\"      },",
          "7296:       { \"tempfilename\",   SQLITE_FCNTL_TEMPFILENAME,    \"\"               },",
          "7297:       { \"has_moved\",      SQLITE_FCNTL_HAS_MOVED,       \"\"               },",
          "7298:       { \"lock_timeout\",   SQLITE_FCNTL_LOCK_TIMEOUT,    \"MILLISEC\"       },",
          "7299:     };",
          "7300:     int filectrl = -1;",
          "7301:     int iCtrl = -1;",
          "7304:     int n2, i;",
          "7305:     const char *zCmd = 0;",
          "7307:     open_db(p, 0);",
          "7308:     zCmd = nArg>=2 ? azArg[1] : \"help\";",
          "7311:     if( zCmd[0]=='-' && zCmd[1] ){",
          "7312:       zCmd++;",
          "7313:       if( zCmd[0]=='-' && zCmd[1] ) zCmd++;",
          "7314:     }",
          "7317:     if( strcmp(zCmd,\"help\")==0 ){",
          "7318:       utf8_printf(p->out, \"Available file-controls:\\n\");",
          "7319:       for(i=0; i<ArraySize(aCtrl); i++){",
          "7320:         utf8_printf(p->out, \"  .filectrl %s %s\\n\",",
          "7321:                     aCtrl[i].zCtrlName, aCtrl[i].zUsage);",
          "7322:       }",
          "7323:       rc = 1;",
          "7324:       goto meta_command_exit;",
          "7325:     }",
          "7329:     n2 = strlen30(zCmd);",
          "7330:     for(i=0; i<ArraySize(aCtrl); i++){",
          "7331:       if( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 ){",
          "7332:         if( filectrl<0 ){",
          "7333:           filectrl = aCtrl[i].ctrlCode;",
          "7334:           iCtrl = i;",
          "7335:         }else{",
          "7336:           utf8_printf(stderr, \"Error: ambiguous file-control: \\\"%s\\\"\\n\"",
          "7337:                               \"Use \\\".filectrl --help\\\" for help\\n\", zCmd);",
          "7338:           rc = 1;",
          "7339:           goto meta_command_exit;",
          "7340:         }",
          "7341:       }",
          "7342:     }",
          "7343:     if( filectrl<0 ){",
          "7344:       utf8_printf(stderr,\"Error: unknown file-control: %s\\n\"",
          "7345:                          \"Use \\\".filectrl --help\\\" for help\\n\", zCmd);",
          "7346:     }else{",
          "7347:       switch(filectrl){",
          "7348:         case SQLITE_FCNTL_SIZE_LIMIT: {",
          "7349:           if( nArg!=2 && nArg!=3 ) break;",
          "7350:           iRes = nArg==3 ? integerValue(azArg[2]) : -1;",
          "7351:           sqlite3_file_control(p->db, 0, SQLITE_FCNTL_SIZE_LIMIT, &iRes);",
          "7352:           isOk = 1;",
          "7353:           break;",
          "7354:         }",
          "7355:         case SQLITE_FCNTL_LOCK_TIMEOUT:",
          "7356:         case SQLITE_FCNTL_CHUNK_SIZE: {",
          "7357:           int x;",
          "7358:           if( nArg!=3 ) break;",
          "7359:           x = (int)integerValue(azArg[2]);",
          "7360:           sqlite3_file_control(p->db, 0, filectrl, &x);",
          "7361:           isOk = 2;",
          "7362:           break;",
          "7363:         }",
          "7364:         case SQLITE_FCNTL_PERSIST_WAL:",
          "7365:         case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {",
          "7366:           int x;",
          "7367:           if( nArg!=2 && nArg!=3 ) break;",
          "7368:           x = nArg==3 ? booleanValue(azArg[2]) : -1;",
          "7369:           sqlite3_file_control(p->db, 0, filectrl, &x);",
          "7370:           iRes = x;",
          "7371:           isOk = 1;",
          "7372:           break;",
          "7373:         }",
          "7374:         case SQLITE_FCNTL_HAS_MOVED: {",
          "7375:           int x;",
          "7376:           if( nArg!=2 ) break;",
          "7377:           sqlite3_file_control(p->db, 0, filectrl, &x);",
          "7378:           iRes = x;",
          "7379:           isOk = 1;",
          "7380:           break;",
          "7381:         }",
          "7382:         case SQLITE_FCNTL_TEMPFILENAME: {",
          "7383:           char *z = 0;",
          "7384:           if( nArg!=2 ) break;",
          "7385:           sqlite3_file_control(p->db, 0, filectrl, &z);",
          "7386:           if( z ){",
          "7387:             utf8_printf(p->out, \"%s\\n\", z);",
          "7388:             sqlite3_free(z);",
          "7389:           }",
          "7390:           isOk = 2;",
          "7391:           break;",
          "7392:         }",
          "7393:       }",
          "7394:     }",
          "7395:     if( isOk==0 && iCtrl>=0 ){",
          "7396:       utf8_printf(p->out, \"Usage: .filectrl %s %s\\n\", zCmd,aCtrl[iCtrl].zUsage);",
          "7397:       rc = 1;",
          "7398:     }else if( isOk==1 ){",
          "7399:       raw_printf(p->out, \"%lld\\n\", iRes);",
          "7400:     }",
          "7401:   }else",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a88c8c1ae4f6e44f52096f0f17203dc20f8bb900",
      "candidate_info": {
        "commit_hash": "a88c8c1ae4f6e44f52096f0f17203dc20f8bb900",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a88c8c1ae4f6e44f52096f0f17203dc20f8bb900",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c",
          "src/analyze.c",
          "src/build.c",
          "src/expr.c",
          "src/fkey.c",
          "src/insert.c",
          "src/parse.y",
          "src/pragma.c",
          "src/resolve.c",
          "src/sqliteInt.h",
          "src/update.c",
          "src/upsert.c",
          "src/vdbe.c",
          "src/vdbe.h",
          "src/vdbeapi.c",
          "src/vdbeaux.c",
          "src/vtab.c",
          "src/where.c",
          "src/wherecode.c",
          "tool/mkkeywordhash.c"
        ],
        "message": "Add support for generated columns.\n\nFossilOrigin-Name: b855acf1831943b3914491ed0bc333131321930cab480a5281012a3aebbba492",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c",
          "src/analyze.c||src/analyze.c",
          "src/build.c||src/build.c",
          "src/expr.c||src/expr.c",
          "src/fkey.c||src/fkey.c",
          "src/insert.c||src/insert.c",
          "src/parse.y||src/parse.y",
          "src/pragma.c||src/pragma.c",
          "src/resolve.c||src/resolve.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/update.c||src/update.c",
          "src/upsert.c||src/upsert.c",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbe.h||src/vdbe.h",
          "src/vdbeapi.c||src/vdbeapi.c",
          "src/vdbeaux.c||src/vdbeaux.c",
          "src/vtab.c||src/vtab.c",
          "src/where.c||src/where.c",
          "src/wherecode.c||src/wherecode.c",
          "tool/mkkeywordhash.c||tool/mkkeywordhash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: e3c3f4d7872f431a95627d52553101388c1e39458cc7e7f93fc81255f49a89a5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "298:   }",
          "299: #endif",
          "",
          "[Removed Lines]",
          "305:   assert( pDflt==0 || pDflt->op==TK_SPAN );",
          "306:   if( pDflt && pDflt->pLeft->op==TK_NULL ){",
          "307:     pDflt = 0;",
          "308:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "319:     sqlite3ErrorMsg(pParse, \"Cannot add a UNIQUE column\");",
          "320:     return;",
          "321:   }",
          "343:       return;",
          "344:     }",
          "347:       return;",
          "348:     }",
          "350:   }",
          "353:   zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);",
          "354:   if( zCol ){",
          "",
          "[Removed Lines]",
          "322:   if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){",
          "323:     sqlite3ErrorMsg(pParse,",
          "324:         \"Cannot add a REFERENCES column with non-NULL default value\");",
          "325:     return;",
          "326:   }",
          "327:   if( pCol->notNull && !pDflt ){",
          "328:     sqlite3ErrorMsg(pParse,",
          "329:         \"Cannot add a NOT NULL column with default value NULL\");",
          "330:     return;",
          "331:   }",
          "336:   if( pDflt ){",
          "337:     sqlite3_value *pVal = 0;",
          "338:     int rc;",
          "339:     rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);",
          "340:     assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );",
          "341:     if( rc!=SQLITE_OK ){",
          "342:       assert( db->mallocFailed == 1 );",
          "345:     if( !pVal ){",
          "346:       sqlite3ErrorMsg(pParse, \"Cannot add a column with non-constant default\");",
          "349:     sqlite3ValueFree(pVal);",
          "",
          "[Added Lines]",
          "314:   if( (pCol->colFlags & COLFLAG_GENERATED)==0 ){",
          "319:     assert( pDflt==0 || pDflt->op==TK_SPAN );",
          "320:     if( pDflt && pDflt->pLeft->op==TK_NULL ){",
          "321:       pDflt = 0;",
          "322:     }",
          "323:     if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){",
          "324:       sqlite3ErrorMsg(pParse,",
          "325:           \"Cannot add a REFERENCES column with non-NULL default value\");",
          "328:     if( pCol->notNull && !pDflt ){",
          "329:       sqlite3ErrorMsg(pParse,",
          "330:           \"Cannot add a NOT NULL column with default value NULL\");",
          "337:     if( pDflt ){",
          "338:       sqlite3_value *pVal = 0;",
          "339:       int rc;",
          "340:       rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);",
          "341:       assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );",
          "342:       if( rc!=SQLITE_OK ){",
          "343:         assert( db->mallocFailed == 1 );",
          "344:         return;",
          "345:       }",
          "346:       if( !pVal ){",
          "347:         sqlite3ErrorMsg(pParse,\"Cannot add a column with non-constant default\");",
          "348:         return;",
          "349:       }",
          "350:       sqlite3ValueFree(pVal);",
          "351:     }",
          "352:   }else if( pCol->colFlags & COLFLAG_STORED ){",
          "353:     sqlite3ErrorMsg(pParse, \"cannot add a STORED column\");",
          "354:     return;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1331:           sqlite3WalkExprList(&sWalker, pIdx->aColExpr);",
          "1332:         }",
          "1333:       }",
          "1335:       for(pFKey=sParse.pNewTable->pFKey; pFKey; pFKey=pFKey->pNextFrom){",
          "1336:         for(i=0; i<pFKey->nCol; i++){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1340: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1341:       for(i=0; i<sParse.pNewTable->nCol; i++){",
          "1342:         sqlite3WalkExpr(&sWalker, sParse.pNewTable->aCol[i].pDflt);",
          "1343:       }",
          "1344: #endif",
          "",
          "---------------"
        ],
        "src/analyze.c||src/analyze.c": [
          "File: src/analyze.c -> src/analyze.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1182:       int j, k, regKey;",
          "1183:       regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);",
          "1184:       for(j=0; j<pPk->nKeyCol; j++){",
          "1186:         assert( k>=0 && k<pIdx->nColumn );",
          "1187:         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);",
          "1188:         VdbeComment((v, \"%s\", pTab->aCol[pPk->aiColumn[j]].zName));",
          "",
          "[Removed Lines]",
          "1185:         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "[Added Lines]",
          "1185:         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "877: }",
          "884:   int i;",
          "885:   for(i=0; i<pIdx->nColumn; i++){",
          "886:     if( iCol==pIdx->aiColumn[i] ) return i;",
          "",
          "[Removed Lines]",
          "883: i16 sqlite3ColumnOfIndex(Index *pIdx, i16 iCol){",
          "",
          "[Added Lines]",
          "885: i16 sqlite3TableColumnToIndex(Index *pIdx, i16 iCol){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "888:   return -1;",
          "889: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "893: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "905: i16 sqlite3StorageColumnToTable(Table *pTab, i16 iCol){",
          "906:   if( pTab->tabFlags & TF_HasVirtual ){",
          "907:     int i;",
          "908:     for(i=0; i<=iCol; i++){",
          "909:       if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) iCol++;",
          "910:     }",
          "911:   }",
          "912:   return iCol;",
          "913: }",
          "914: #endif",
          "916: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "951: i16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){",
          "952:   int i;",
          "953:   i16 n;",
          "954:   assert( iCol<pTab->nCol );",
          "955:   if( (pTab->tabFlags & TF_HasVirtual)==0 ) return iCol;",
          "956:   for(i=0, n=0; i<iCol; i++){",
          "957:     if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) n++;",
          "958:   }",
          "959:   if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ){",
          "961:     return pTab->nNVCol + i - n;",
          "962:   }else{",
          "964:     return n;",
          "965:   }",
          "966: }",
          "967: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1178:     pCol->colFlags |= COLFLAG_HASTYPE;",
          "1179:   }",
          "1180:   p->nCol++;",
          "1181:   pParse->constraintName.n = 0;",
          "1182: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1259:   p->nNVCol++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1326:     if( !sqlite3ExprIsConstantOrFunction(pExpr, db->init.busy) ){",
          "1327:       sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",",
          "1328:           pCol->zName);",
          "1329:     }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1408: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1409:     }else if( pCol->colFlags & COLFLAG_GENERATED ){",
          "1410:       testcase( pCol->colFlags & COLFLAG_VIRTUAL );",
          "1411:       testcase( pCol->colFlags & COLFLAG_STORED );",
          "1412:       sqlite3ErrorMsg(pParse, \"cannot use DEFAULT on a generated column\");",
          "1413: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1371:   }",
          "1372: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1462: static void makeColumnPartOfPrimaryKey(Parse *pParse, Column *pCol){",
          "1463:   pCol->colFlags |= COLFLAG_PRIMKEY;",
          "1464: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1465:   if( pCol->colFlags & COLFLAG_GENERATED ){",
          "1466:     testcase( pCol->colFlags & COLFLAG_VIRTUAL );",
          "1467:     testcase( pCol->colFlags & COLFLAG_STORED );",
          "1468:     sqlite3ErrorMsg(pParse,",
          "1469:       \"generated columns cannot be part of the PRIMARY KEY\");",
          "1470:   }",
          "1471: #endif",
          "1472: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1410:   if( pList==0 ){",
          "1411:     iCol = pTab->nCol - 1;",
          "1412:     pCol = &pTab->aCol[iCol];",
          "1414:     nTerm = 1;",
          "1415:   }else{",
          "1416:     nTerm = pList->nExpr;",
          "",
          "[Removed Lines]",
          "1413:     pCol->colFlags |= COLFLAG_PRIMKEY;",
          "",
          "[Added Lines]",
          "1513:     makeColumnPartOfPrimaryKey(pParse, pCol);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1423:         for(iCol=0; iCol<pTab->nCol; iCol++){",
          "1424:           if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zName)==0 ){",
          "1425:             pCol = &pTab->aCol[iCol];",
          "1427:             break;",
          "1428:           }",
          "1429:         }",
          "",
          "[Removed Lines]",
          "1426:             pCol->colFlags |= COLFLAG_PRIMKEY;",
          "",
          "[Added Lines]",
          "1526:             makeColumnPartOfPrimaryKey(pParse, pCol);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1520:   }",
          "1521: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1626: void sqlite3AddGenerated(Parse *pParse, Expr *pExpr, Token *pType){",
          "1627: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1628:   u8 eType = COLFLAG_VIRTUAL;",
          "1629:   Table *pTab = pParse->pNewTable;",
          "1630:   Column *pCol;",
          "1631:   if( NEVER(pTab==0) ) goto generated_done;",
          "1632:   pCol = &(pTab->aCol[pTab->nCol-1]);",
          "1633:   if( IN_DECLARE_VTAB ){",
          "1634:     sqlite3ErrorMsg(pParse, \"virtual tables cannot use computed columns\");",
          "1635:     goto generated_done;",
          "1636:   }",
          "1637:   if( pCol->pDflt ) goto generated_error;",
          "1638:   if( pType ){",
          "1639:     if( pType->n==7 && sqlite3StrNICmp(\"virtual\",pType->z,7)==0 ){",
          "1641:     }else if( pType->n==6 && sqlite3StrNICmp(\"stored\",pType->z,6)==0 ){",
          "1642:       eType = COLFLAG_STORED;",
          "1643:     }else{",
          "1644:       goto generated_error;",
          "1645:     }",
          "1646:   }",
          "1647:   if( eType==COLFLAG_VIRTUAL ) pTab->nNVCol--;",
          "1648:   pCol->colFlags |= eType;",
          "1649:   assert( TF_HasVirtual==COLFLAG_VIRTUAL );",
          "1650:   assert( TF_HasStored==COLFLAG_STORED );",
          "1651:   pTab->tabFlags |= eType;",
          "1652:   pCol->pDflt = pExpr;",
          "1653:   pExpr = 0;",
          "1654:   goto generated_done;",
          "1656: generated_error:",
          "1657:   sqlite3ErrorMsg(pParse, \"error in generated column \\\"%s\\\"\",",
          "1658:                   pCol->zName);",
          "1659: generated_done:",
          "1660:   sqlite3ExprDelete(pParse->db, pExpr);",
          "1661: #else",
          "1664:   sqlite3ErrorMsg(pParse, \"generated columns not supported\");",
          "1665:   sqlite3ExprDelete(pParse->db, pExpr);",
          "1666: #endif",
          "1667: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1783: static void recomputeColumnsNotIndexed(Index *pIdx){",
          "1784:   Bitmask m = 0;",
          "1785:   int j;",
          "1786:   for(j=pIdx->nColumn-1; j>=0; j--){",
          "1787:     int x = pIdx->aiColumn[j];",
          "1789:       testcase( x==BMS-1 );",
          "1790:       testcase( x==BMS-2 );",
          "1791:       if( x<BMS-1 ) m |= MASKBIT(x);",
          "",
          "[Removed Lines]",
          "1788:     if( x>=0 ){",
          "",
          "[Added Lines]",
          "1940:   Table *pTab = pIdx->pTable;",
          "1943:     if( x>=0 && (pTab->aCol[x].colFlags & COLFLAG_VIRTUAL)==0 ){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1945:   nExtra = 0;",
          "1946:   for(i=0; i<pTab->nCol; i++){",
          "1948:   }",
          "1949:   if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;",
          "1950:   for(i=0, j=nPk; i<pTab->nCol; i++){",
          "1952:       assert( j<pPk->nColumn );",
          "1953:       pPk->aiColumn[j] = i;",
          "1954:       pPk->azColl[j] = sqlite3StrBINARY;",
          "",
          "[Removed Lines]",
          "1947:     if( !hasColumn(pPk->aiColumn, nPk, i) ) nExtra++;",
          "1951:     if( !hasColumn(pPk->aiColumn, j, i) ){",
          "",
          "[Added Lines]",
          "2102:     if( !hasColumn(pPk->aiColumn, nPk, i)",
          "2103:      && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) nExtra++;",
          "2107:     if( !hasColumn(pPk->aiColumn, j, i)",
          "2108:      && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0",
          "2109:     ){",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1956:     }",
          "1957:   }",
          "1958:   assert( pPk->nColumn==j );",
          "1960:   recomputeColumnsNotIndexed(pPk);",
          "1961: }",
          "",
          "[Removed Lines]",
          "1959:   assert( pTab->nCol<=j );",
          "",
          "[Added Lines]",
          "2117:   assert( pTab->nNVCol<=j );",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2065:     }",
          "2066:     if( (p->tabFlags & TF_HasPrimaryKey)==0 ){",
          "2067:       sqlite3ErrorMsg(pParse, \"PRIMARY KEY missing on table %s\", p->zName);",
          "2071:     }",
          "2072:   }",
          "2074:   iDb = sqlite3SchemaToIndex(db, p->pSchema);",
          "2076: #ifndef SQLITE_OMIT_CHECK",
          "",
          "[Removed Lines]",
          "2068:     }else{",
          "2069:       p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;",
          "2070:       convertToWithoutRowidTable(pParse, p);",
          "",
          "[Added Lines]",
          "2226:       return;",
          "2228:     p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;",
          "2229:     convertToWithoutRowidTable(pParse, p);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2080:     sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);",
          "2081:   }",
          "2085:   estimateTableWidth(p);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2240: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "2241:   if( p->tabFlags & TF_HasGenerated ){",
          "2242:     int ii;",
          "2243:     testcase( p->tabFlags & TF_HasVirtual );",
          "2244:     testcase( p->tabFlags & TF_HasStored );",
          "2245:     for(ii=0; ii<p->nCol; ii++){",
          "2246:       u32 colFlags = p->aCol[ii].colFlags;",
          "2247:       if( (colFlags & COLFLAG_GENERATED)!=0 ){",
          "2248:         testcase( colFlags & COLFLAG_VIRTUAL );",
          "2249:         testcase( colFlags & COLFLAG_STORED );",
          "2250:         sqlite3ResolveSelfReference(pParse, p, NC_GenCol,",
          "2251:                                     p->aCol[ii].pDflt, 0);",
          "2252:       }",
          "2253:     }",
          "2254:   }",
          "2255: #endif",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2156:       pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);",
          "2157:       if( pSelTab==0 ) return;",
          "2158:       assert( p->aCol==0 );",
          "2160:       p->aCol = pSelTab->aCol;",
          "2161:       pSelTab->nCol = 0;",
          "2162:       pSelTab->aCol = 0;",
          "",
          "[Removed Lines]",
          "2159:       p->nCol = pSelTab->nCol;",
          "",
          "[Added Lines]",
          "2332:       p->nCol = p->nNVCol = pSelTab->nCol;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2446:       assert( pTable->aCol==0 );",
          "2448:       pTable->aCol = pSelTab->aCol;",
          "2449:       pSelTab->nCol = 0;",
          "2450:       pSelTab->aCol = 0;",
          "",
          "[Removed Lines]",
          "2447:       pTable->nCol = pSelTab->nCol;",
          "",
          "[Added Lines]",
          "2620:       pTable->nCol = pTable->nNVCol = pSelTab->nCol;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3454:       assert( j<=0x7fff );",
          "3455:       if( j<0 ){",
          "3456:         j = pTab->iPKey;",
          "3459:       }",
          "3460:       pIndex->aiColumn[i] = (i16)j;",
          "3461:     }",
          "",
          "[Removed Lines]",
          "3457:       }else if( pTab->aCol[j].notNull==0 ){",
          "3458:         pIndex->uniqNotNull = 0;",
          "",
          "[Added Lines]",
          "3630:       }else{",
          "3631:         if( pTab->aCol[j].notNull==0 ){",
          "3632:           pIndex->uniqNotNull = 0;",
          "3633:         }",
          "3634:         if( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL ){",
          "3635:           pIndex->bHasVCol = 1;",
          "3636:         }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3512:   assert( HasRowid(pTab)",
          "3514:   recomputeColumnsNotIndexed(pIndex);",
          "3515:   if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){",
          "3516:     pIndex->isCovering = 1;",
          "3517:     for(j=0; j<pTab->nCol; j++){",
          "3518:       if( j==pTab->iPKey ) continue;",
          "3520:       pIndex->isCovering = 0;",
          "3521:       break;",
          "3522:     }",
          "",
          "[Removed Lines]",
          "3513:       || pTab->iPKey<0 || sqlite3ColumnOfIndex(pIndex, pTab->iPKey)>=0 );",
          "3519:       if( sqlite3ColumnOfIndex(pIndex,j)>=0 ) continue;",
          "",
          "[Added Lines]",
          "3691:       || pTab->iPKey<0 || sqlite3TableColumnToIndex(pIndex, pTab->iPKey)>=0 );",
          "3697:       if( sqlite3TableColumnToIndex(pIndex,j)>=0 ) continue;",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3399:   }",
          "3400: }",
          "3405: void sqlite3ExprCodeGetColumnOfTable(",
          "3411: ){",
          "3412:   if( pTab==0 ){",
          "3413:     sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);",
          "3414:     return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3402: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "3407: void sqlite3ExprCodeGeneratedColumn(",
          "3408:   Parse *pParse,",
          "3409:   Column *pCol,",
          "3410:   int regOut",
          "3411: ){",
          "3412:   sqlite3ExprCode(pParse, pCol->pDflt, regOut);",
          "3413:   if( pCol->affinity>=SQLITE_AFF_TEXT ){",
          "3414:     sqlite3VdbeAddOp4(pParse->pVdbe, OP_Affinity, regOut, 1, 0,",
          "3415:                       &pCol->affinity, 1);",
          "3416:   }",
          "3417: }",
          "3430:   Column *pCol;",
          "3431:   assert( v!=0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3416:   if( iCol<0 || iCol==pTab->iPKey ){",
          "3417:     sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);",
          "3418:   }else{",
          "3423:     }",
          "3424:     sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);",
          "3427:     sqlite3ColumnDefault(v, pTab, iCol, regOut);",
          "3428:   }",
          "3429: }",
          "",
          "[Removed Lines]",
          "3419:     int op = IsVirtual(pTab) ? OP_VColumn : OP_Column;",
          "3420:     int x = iCol;",
          "3421:     if( !HasRowid(pTab) && !IsVirtual(pTab) ){",
          "3422:       x = sqlite3ColumnOfIndex(sqlite3PrimaryKeyIndex(pTab), iCol);",
          "3425:   }",
          "3426:   if( iCol>=0 ){",
          "",
          "[Added Lines]",
          "3439:     int op;",
          "3440:     int x;",
          "3441:     if( IsVirtual(pTab) ){",
          "3442:       op = OP_VColumn;",
          "3443:       x = iCol;",
          "3444: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "3445:     }else if( (pCol = &pTab->aCol[iCol])->colFlags & COLFLAG_VIRTUAL ){",
          "3446:       Parse *pParse = sqlite3VdbeParser(v);",
          "3447:       if( pCol->colFlags & COLFLAG_BUSY ){",
          "3448:         sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zName);",
          "3449:       }else{",
          "3450:         int savedSelfTab = pParse->iSelfTab;",
          "3451:         pCol->colFlags |= COLFLAG_BUSY;",
          "3452:         pParse->iSelfTab = iTabCur+1;",
          "3453:         sqlite3ExprCodeGeneratedColumn(pParse, pCol, regOut);",
          "3454:         pParse->iSelfTab = savedSelfTab;",
          "3455:         pCol->colFlags &= ~COLFLAG_BUSY;",
          "3456:       }",
          "3457:       return;",
          "3458: #endif",
          "3459:     }else if( !HasRowid(pTab) ){",
          "3460:       testcase( iCol!=sqlite3TableColumnToStorage(pTab, iCol) );",
          "3461:       x = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), iCol);",
          "3462:       op = OP_Column;",
          "3463:     }else{",
          "3464:       x = sqlite3TableColumnToStorage(pTab,iCol);",
          "3465:       testcase( x!=iCol );",
          "3466:       op = OP_Column;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3445: ){",
          "3449:   if( p5 ){",
          "3451:   }",
          "3452:   return iReg;",
          "3453: }",
          "",
          "[Removed Lines]",
          "3446:   Vdbe *v = pParse->pVdbe;",
          "3447:   assert( v!=0 );",
          "3448:   sqlite3ExprCodeGetColumnOfTable(v, pTab, iTable, iColumn, iReg);",
          "3450:     sqlite3VdbeChangeP5(v, p5);",
          "",
          "[Added Lines]",
          "3488:   assert( pParse->pVdbe!=0 );",
          "3489:   sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pTab, iTable, iColumn, iReg);",
          "3491:     sqlite3VdbeChangeP5(pParse->pVdbe, p5);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3583:       }",
          "3584:       if( iTab<0 ){",
          "3585:         if( pParse->iSelfTab<0 ){",
          "3595:             sqlite3VdbeAddOp1(v, OP_RealAffinity, target);",
          "3596:             return target;",
          "3597:           }else{",
          "3599:           }",
          "3600:         }else{",
          "",
          "[Removed Lines]",
          "3587:           assert( pExpr->y.pTab!=0 );",
          "3588:           assert( pExpr->iColumn>=XN_ROWID );",
          "3589:           assert( pExpr->iColumn<pExpr->y.pTab->nCol );",
          "3590:           if( pExpr->iColumn>=0",
          "3591:             && pExpr->y.pTab->aCol[pExpr->iColumn].affinity==SQLITE_AFF_REAL",
          "3592:           ){",
          "3593:             sqlite3VdbeAddOp2(v, OP_SCopy, pExpr->iColumn - pParse->iSelfTab,",
          "3594:                               target);",
          "3598:             return pExpr->iColumn - pParse->iSelfTab;",
          "",
          "[Added Lines]",
          "3633:           Column *pCol;",
          "3634:           Table *pTab = pExpr->y.pTab;",
          "3635:           int iSrc;",
          "3636:           int iCol = pExpr->iColumn;",
          "3637:           assert( pTab!=0 );",
          "3638:           assert( iCol>=XN_ROWID );",
          "3639:           assert( iCol<pExpr->y.pTab->nCol );",
          "3640:           if( iCol<0 ){",
          "3641:             return -1-pParse->iSelfTab;",
          "3642:           }",
          "3643:           pCol = pTab->aCol + iCol;",
          "3644:           testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );",
          "3645:           iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;",
          "3646: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "3647:           if( pCol->colFlags & COLFLAG_GENERATED ){",
          "3648:             if( pCol->colFlags & COLFLAG_BUSY ){",
          "3649:               sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",",
          "3650:                               pCol->zName);",
          "3651:               return 0;",
          "3652:             }",
          "3653:             pCol->colFlags |= COLFLAG_BUSY;",
          "3654:             if( pCol->colFlags & COLFLAG_NOTAVAIL ){",
          "3655:               sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);",
          "3656:             }",
          "3657:             pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);",
          "3658:             return iSrc;",
          "3659:           }else",
          "3661:           if( pCol->affinity==SQLITE_AFF_REAL ){",
          "3662:             sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);",
          "3666:             return iSrc;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4065:       Table *pTab = pExpr->y.pTab;",
          "4068:       assert( pExpr->iTable==0 || pExpr->iTable==1 );",
          "4071:       assert( p1>=0 && p1<(pTab->nCol*2+2) );",
          "4073:       sqlite3VdbeAddOp2(v, OP_Param, p1, target);",
          "4074:       VdbeComment((v, \"r[%d]=%s.%s\", target,",
          "4075:         (pExpr->iTable ? \"new\" : \"old\"),",
          "4077:       ));",
          "4079: #ifndef SQLITE_OMIT_FLOATING_POINT",
          "",
          "[Removed Lines]",
          "4066:       int p1 = pExpr->iTable * (pTab->nCol+1) + 1 + pExpr->iColumn;",
          "4069:       assert( pExpr->iColumn>=-1 && pExpr->iColumn<pTab->nCol );",
          "4070:       assert( pTab->iPKey<0 || pExpr->iColumn!=pTab->iPKey );",
          "4076:         (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[pExpr->iColumn].zName)",
          "",
          "[Added Lines]",
          "4134:       int iCol = pExpr->iColumn;",
          "4135:       int p1 = pExpr->iTable * (pTab->nCol+1) + 1",
          "4136:                      + (iCol>=0 ? sqlite3TableColumnToStorage(pTab, iCol) : -1);",
          "4139:       assert( iCol>=-1 && iCol<pTab->nCol );",
          "4140:       assert( pTab->iPKey<0 || iCol!=pTab->iPKey );",
          "4146:         (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zName)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4088:         sqlite3VdbeAddOp1(v, OP_RealAffinity, target);",
          "4089:       }",
          "4090: #endif",
          "",
          "[Removed Lines]",
          "4085:       if( pExpr->iColumn>=0",
          "4086:        && pTab->aCol[pExpr->iColumn].affinity==SQLITE_AFF_REAL",
          "4087:       ){",
          "",
          "[Added Lines]",
          "4155:       if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4317:   int inReg;",
          "4319:   assert( target>0 && target<=pParse->nMem );",
          "4328:   }",
          "4329: }",
          "",
          "[Removed Lines]",
          "4320:   if( pExpr && pExpr->op==TK_REGISTER ){",
          "4321:     sqlite3VdbeAddOp2(pParse->pVdbe, OP_Copy, pExpr->iTable, target);",
          "4322:   }else{",
          "4323:     inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);",
          "4324:     assert( pParse->pVdbe!=0 || pParse->db->mallocFailed );",
          "4325:     if( inReg!=target && pParse->pVdbe ){",
          "4326:       sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, inReg, target);",
          "4327:     }",
          "",
          "[Added Lines]",
          "4388:   inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);",
          "4389:   assert( pParse->pVdbe!=0 || pParse->db->mallocFailed );",
          "4390:   if( inReg!=target && pParse->pVdbe ){",
          "4391:     sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, inReg, target);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4354:   }",
          "4355: }",
          "",
          "[Removed Lines]",
          "4369: void sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){",
          "4370:   Vdbe *v = pParse->pVdbe;",
          "4371:   int iMem;",
          "4373:   assert( target>0 );",
          "4374:   assert( pExpr->op!=TK_REGISTER );",
          "4375:   sqlite3ExprCode(pParse, pExpr, target);",
          "4376:   iMem = ++pParse->nMem;",
          "4377:   sqlite3VdbeAddOp2(v, OP_Copy, target, iMem);",
          "4378:   exprToRegister(pExpr, iMem);",
          "4379: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5300: static int exprIdxCover(Walker *pWalker, Expr *pExpr){",
          "5301:   if( pExpr->op==TK_COLUMN",
          "5302:    && pExpr->iTable==pWalker->u.pIdxCover->iCur",
          "5304:   ){",
          "5305:     pWalker->eCode = 1;",
          "5306:     return WRC_Abort;",
          "",
          "[Removed Lines]",
          "5303:    && sqlite3ColumnOfIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0",
          "",
          "[Added Lines]",
          "5343:    && sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0",
          "",
          "---------------"
        ],
        "src/fkey.c||src/fkey.c": [
          "File: src/fkey.c -> src/fkey.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "349:     VdbeCoverage(v);",
          "350:   }",
          "351:   for(i=0; i<pFKey->nCol; i++){",
          "353:     sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iOk); VdbeCoverage(v);",
          "354:   }",
          "",
          "[Removed Lines]",
          "352:     int iReg = aiCol[i] + regData + 1;",
          "",
          "[Added Lines]",
          "352:     int iReg = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i]) + regData + 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "369:       iMustBeInt = sqlite3VdbeAddOp2(v, OP_MustBeInt, regTemp, 0);",
          "370:       VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "368:       sqlite3VdbeAddOp2(v, OP_SCopy, aiCol[0]+1+regData, regTemp);",
          "",
          "[Added Lines]",
          "368:       sqlite3VdbeAddOp2(v, OP_SCopy,",
          "369:         sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[0])+1+regData, regTemp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "392:       sqlite3VdbeAddOp3(v, OP_OpenRead, iCur, pIdx->tnum, iDb);",
          "393:       sqlite3VdbeSetP4KeyInfo(pParse, pIdx);",
          "394:       for(i=0; i<nCol; i++){",
          "396:       }",
          "",
          "[Removed Lines]",
          "395:         sqlite3VdbeAddOp2(v, OP_Copy, aiCol[i]+1+regData, regTemp+i);",
          "",
          "[Added Lines]",
          "396:         sqlite3VdbeAddOp2(v, OP_Copy,",
          "397:                sqlite3TableColumnToStorage(pFKey->pFrom, aiCol[i])+1+regData,",
          "398:                regTemp+i);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "408:       if( pTab==pFKey->pFrom && nIncr==1 ){",
          "409:         int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;",
          "410:         for(i=0; i<nCol; i++){",
          "413:           assert( pIdx->aiColumn[i]>=0 );",
          "414:           assert( aiCol[i]!=pTab->iPKey );",
          "415:           if( pIdx->aiColumn[i]==pTab->iPKey ){",
          "",
          "[Removed Lines]",
          "411:           int iChild = aiCol[i]+1+regData;",
          "412:           int iParent = pIdx->aiColumn[i]+1+regData;",
          "",
          "[Added Lines]",
          "414:           int iChild = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i])",
          "415:                               +1+regData;",
          "416:           int iParent = 1+regData;",
          "417:           iParent += sqlite3TableColumnToStorage(pIdx->pTable,",
          "418:                                                  pIdx->aiColumn[i]);",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:   sqlite3TableLock(pParse, iDb, pTab->tnum,",
          "38:                    (opcode==OP_OpenWrite)?1:0, pTab->zName);",
          "39:   if( HasRowid(pTab) ){",
          "41:     VdbeComment((v, \"%s\", pTab->zName));",
          "42:   }else{",
          "43:     Index *pPk = sqlite3PrimaryKeyIndex(pTab);",
          "",
          "[Removed Lines]",
          "40:     sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, pTab->nCol);",
          "",
          "[Added Lines]",
          "40:     sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, pTab->nNVCol);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131: void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg){",
          "133:   char *zColAff = pTab->zColAff;",
          "134:   if( zColAff==0 ){",
          "135:     sqlite3 *db = sqlite3VdbeDb(v);",
          "",
          "[Removed Lines]",
          "132:   int i;",
          "",
          "[Added Lines]",
          "132:   int i, j;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "139:       return;",
          "140:     }",
          "143:       assert( pTab->aCol[i].affinity!=0 );",
          "145:     }",
          "146:     do{",
          "149:     pTab->zColAff = zColAff;",
          "150:   }",
          "151:   assert( zColAff!=0 );",
          "",
          "[Removed Lines]",
          "142:     for(i=0; i<pTab->nCol; i++){",
          "144:       zColAff[i] = pTab->aCol[i].affinity;",
          "147:       zColAff[i--] = 0;",
          "148:     }while( i>=0 && zColAff[i]<=SQLITE_AFF_BLOB );",
          "",
          "[Added Lines]",
          "142:     for(i=j=0; i<pTab->nCol; i++){",
          "144:       if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){",
          "145:         zColAff[j++] = pTab->aCol[i].affinity;",
          "146:       }",
          "149:       zColAff[j--] = 0;",
          "150:     }while( j>=0 && zColAff[j]<=SQLITE_AFF_BLOB );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "199:   return 0;",
          "200: }",
          "202: #ifndef SQLITE_OMIT_AUTOINCREMENT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "204: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "212: void sqlite3ComputeGeneratedColumns(",
          "216: ){",
          "217:   int i;",
          "218:   int nv;",
          "223:   for(i=0; i<pTab->nCol; i++){",
          "224:     if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "225:       testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "226:       testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "227:       pTab->aCol[i].colFlags |= COLFLAG_NOTAVAIL;",
          "228:     }",
          "229:   }",
          "235:   pParse->iSelfTab = -iRegStore;",
          "236:   for(i=nv=0; i<pTab->nCol; i++){",
          "237:     u32 colFlags = pTab->aCol[i].colFlags;",
          "238:     if( (colFlags & COLFLAG_NOTAVAIL)!=0 ){",
          "239:       assert( colFlags & COLFLAG_GENERATED );",
          "240:       if( colFlags & COLFLAG_VIRTUAL ){",
          "242:         assert( pTab->nNVCol+nv == sqlite3TableColumnToStorage(pTab,i) );",
          "243:         sqlite3ExprCodeGeneratedColumn(pParse, &pTab->aCol[i],",
          "244:                                        iRegStore+pTab->nNVCol+nv);",
          "245:       }else{",
          "247:         assert( i-nv == sqlite3TableColumnToStorage(pTab,i) );",
          "248:         sqlite3ExprCodeGeneratedColumn(pParse, &pTab->aCol[i], iRegStore+i-nv);",
          "249:       }",
          "250:       pTab->aCol[i].colFlags &= ~COLFLAG_NOTAVAIL;",
          "251:     }",
          "252:     if( (colFlags & COLFLAG_VIRTUAL)!=0 ) nv++;",
          "253:   }",
          "254:   pParse->iSelfTab = 0;",
          "255: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "664:   if( pColumn ){",
          "665:     for(i=0; i<pColumn->nId; i++){",
          "666:       pColumn->a[i].idx = -1;",
          "",
          "[Removed Lines]",
          "663:   bIdListInOrder = (pTab->tabFlags & TF_OOOHidden)==0;",
          "",
          "[Added Lines]",
          "729:   bIdListInOrder = (pTab->tabFlags & (TF_OOOHidden|TF_HasStored))==0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "673:           if( j==pTab->iPKey ){",
          "674:             ipkColumn = i;  assert( !withoutRowid );",
          "675:           }",
          "676:           break;",
          "677:         }",
          "678:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "743:           if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){",
          "744:             sqlite3ErrorMsg(pParse,",
          "745:                \"cannot INSERT into generated column \\\"%s\\\"\",",
          "746:                pTab->aCol[j].zName);",
          "747:             goto insert_cleanup;",
          "748:           }",
          "749: #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "783:   if( pColumn==0 && nColumn>0 ){",
          "784:     ipkColumn = pTab->iPKey;",
          "785:   }",
          "790:   for(i=0; i<pTab->nCol; i++){",
          "792:   }",
          "793:   if( pColumn==0 && nColumn && nColumn!=(pTab->nCol-nHidden) ){",
          "794:     sqlite3ErrorMsg(pParse,",
          "",
          "[Removed Lines]",
          "791:     nHidden += (IsHiddenColumn(&pTab->aCol[i]) ? 1 : 0);",
          "",
          "[Added Lines]",
          "859: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "860:     if( ipkColumn>=0 && (pTab->tabFlags & TF_HasGenerated)!=0 ){",
          "861:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "862:       testcase( pTab->tabFlags & TF_HasStored );",
          "863:       for(i=ipkColumn-1; i>=0; i--){",
          "864:         if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "865:           testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "866:           testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "867:           ipkColumn--;",
          "868:         }",
          "869:       }",
          "870:     }",
          "871: #endif",
          "878:     if( pTab->aCol[i].colFlags & COLFLAG_NOINSERT ) nHidden++;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "874:     addrInsTop = addrCont = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);",
          "875:     VdbeCoverage(v);",
          "876:   }",
          "880:   endOfLoop = sqlite3VdbeMakeLabel(pParse);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "963:     if( ipkColumn>=0 ){",
          "967:       sqlite3VdbeAddOp2(v, OP_Copy, regFromSelect+ipkColumn, regRowid);",
          "968:     }",
          "969:   }",
          "978:   nHidden = 0;",
          "979:   iRegStore = regData;  assert( regData==regRowid+1 );",
          "980:   for(i=0; i<pTab->nCol; i++, iRegStore++){",
          "981:     int k;",
          "982:     u32 colFlags;",
          "983:     assert( i>=nHidden );",
          "984:     if( i==pTab->iPKey ){",
          "989:       sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);",
          "990:       continue;",
          "991:     }",
          "992:     if( ((colFlags = pTab->aCol[i].colFlags) & COLFLAG_NOINSERT)!=0 ){",
          "993:       nHidden++;",
          "994:       if( (colFlags & COLFLAG_VIRTUAL)!=0 ){",
          "998:         iRegStore--;",
          "999:         continue;",
          "1000:       }else if( (colFlags & COLFLAG_STORED)!=0 ){",
          "1005:         if( tmask & TRIGGER_BEFORE ){",
          "1006:           sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);",
          "1007:         }",
          "1008:         continue;",
          "1009:       }else if( pColumn==0 ){",
          "1012:         sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);",
          "1013:         continue;",
          "1014:       }",
          "1015:     }",
          "1016:     if( pColumn ){",
          "1017:       for(j=0; j<pColumn->nId && pColumn->a[j].idx!=i; j++){}",
          "1018:       if( j>=pColumn->nId ){",
          "1021:         sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);",
          "1022:         continue;",
          "1023:       }",
          "1024:       k = j;",
          "1025:     }else if( nColumn==0 ){",
          "1027:       sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);",
          "1028:       continue;",
          "1029:     }else{",
          "1030:       k = i - nHidden;",
          "1031:     }",
          "1033:     if( useTempTable ){",
          "1034:       sqlite3VdbeAddOp3(v, OP_Column, srcTab, k, iRegStore);",
          "1035:     }else if( pSelect ){",
          "1036:       if( regFromSelect!=regData ){",
          "1037:         sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+k, iRegStore);",
          "1038:       }",
          "1039:     }else{",
          "1040:       sqlite3ExprCode(pParse, pList->a[k].pExpr, iRegStore);",
          "1041:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "910:     assert( !IsVirtual(pTab) );",
          "930:     }",
          "",
          "[Removed Lines]",
          "914:     for(i=j=0; i<pTab->nCol; i++){",
          "915:       if( pColumn ){",
          "916:         for(j=0; j<pColumn->nId; j++){",
          "917:           if( pColumn->a[j].idx==i ) break;",
          "918:         }",
          "919:       }",
          "920:       if( (!useTempTable && !pList) || (pColumn && j>=pColumn->nId)",
          "921:             || (pColumn==0 && IsOrdinaryHiddenColumn(&pTab->aCol[i])) ){",
          "922:         sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regCols+i+1);",
          "923:       }else if( useTempTable ){",
          "924:         sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, regCols+i+1);",
          "925:       }else{",
          "927:         sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, regCols+i+1);",
          "928:       }",
          "929:       if( pColumn==0 && !IsOrdinaryHiddenColumn(&pTab->aCol[i]) ) j++;",
          "",
          "[Added Lines]",
          "1080:     assert( pTab->nNVCol>0 );",
          "1081:     sqlite3VdbeAddOp3(v, OP_Copy, regRowid+1, regCols+1, pTab->nNVCol-1);",
          "1083: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1088:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1089:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1090:       testcase( pTab->tabFlags & TF_HasStored );",
          "1091:       sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab);",
          "1093: #endif",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "945:     sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol+1);",
          "946:   }",
          "951:   if( !isView ){",
          "952:     if( IsVirtual(pTab) ){",
          "954:       sqlite3VdbeAddOp2(v, OP_Null, 0, regIns);",
          "955:     }",
          "956:     if( ipkColumn>=0 ){",
          "957:       if( useTempTable ){",
          "958:         sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regRowid);",
          "959:       }else if( pSelect ){",
          "961:       }else{",
          "962:         Expr *pIpk = pList->a[ipkColumn].pExpr;",
          "963:         if( pIpk->op==TK_NULL && !IsVirtual(pTab) ){",
          "",
          "[Removed Lines]",
          "960:         sqlite3VdbeAddOp2(v, OP_Copy, regFromSelect+ipkColumn, regRowid);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "990:     }",
          "991:     autoIncStep(pParse, regAutoinc, regRowid);",
          "1031:     }",
          "",
          "[Removed Lines]",
          "996:     nHidden = 0;",
          "997:     for(i=0; i<pTab->nCol; i++){",
          "998:       int iRegStore = regRowid+1+i;",
          "999:       if( i==pTab->iPKey ){",
          "1005:         sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);",
          "1006:         continue;",
          "1007:       }",
          "1008:       if( pColumn==0 ){",
          "1009:         if( IsHiddenColumn(&pTab->aCol[i]) ){",
          "1010:           j = -1;",
          "1011:           nHidden++;",
          "1012:         }else{",
          "1013:           j = i - nHidden;",
          "1014:         }",
          "1015:       }else{",
          "1016:         for(j=0; j<pColumn->nId; j++){",
          "1017:           if( pColumn->a[j].idx==i ) break;",
          "1018:         }",
          "1019:       }",
          "1020:       if( j<0 || nColumn==0 || (pColumn && j>=pColumn->nId) ){",
          "1021:         sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);",
          "1022:       }else if( useTempTable ){",
          "1023:         sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, iRegStore);",
          "1024:       }else if( pSelect ){",
          "1025:         if( regFromSelect!=regData ){",
          "1026:           sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+j, iRegStore);",
          "1027:         }",
          "1028:       }else{",
          "1029:         sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);",
          "1030:       }",
          "",
          "[Added Lines]",
          "1154: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1159:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1160:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1161:       testcase( pTab->tabFlags & TF_HasStored );",
          "1162:       sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab);",
          "1164: #endif",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1355:   if( pTab->tabFlags & TF_HasNotNull ){",
          "1356:     for(i=0; i<nCol; i++){",
          "1357:       onError = pTab->aCol[i].notNull;",
          "1360:       if( i==pTab->iPKey ){",
          "1362:       }",
          "",
          "[Removed Lines]",
          "1359:       assert( pTab->tabFlags & TF_HasNotNull );",
          "",
          "[Added Lines]",
          "1490:       int iReg;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1365:         continue;",
          "1366:       }",
          "1367:       if( overrideError!=OE_Default ){",
          "1368:         onError = overrideError;",
          "1369:       }else if( onError==OE_Default ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1500:       onError = pTab->aCol[i].notNull;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1375:       assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail",
          "1376:           || onError==OE_Ignore || onError==OE_Replace );",
          "1377:       addr1 = 0;",
          "1378:       switch( onError ){",
          "1379:         case OE_Replace: {",
          "1380:           assert( onError==OE_Replace );",
          "1381:           addr1 = sqlite3VdbeMakeLabel(pParse);",
          "1383:             VdbeCoverage(v);",
          "1384:           sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regNewData+1+i);",
          "1386:             VdbeCoverage(v);",
          "1387:           onError = OE_Abort;",
          "",
          "[Removed Lines]",
          "1382:           sqlite3VdbeAddOp2(v, OP_NotNull, regNewData+1+i, addr1);",
          "1385:           sqlite3VdbeAddOp2(v, OP_NotNull, regNewData+1+i, addr1);",
          "",
          "[Added Lines]",
          "1513:       testcase( i!=sqlite3TableColumnToStorage(pTab, i) );",
          "1514:       testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "1515:       testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "1516:       iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;",
          "1521:           sqlite3VdbeAddOp2(v, OP_NotNull, iReg, addr1);",
          "1524:           sqlite3VdbeAddOp2(v, OP_NotNull, iReg, addr1);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1396:           char *zMsg = sqlite3MPrintf(db, \"%s.%s\", pTab->zName,",
          "1397:                                       pTab->aCol[i].zName);",
          "1398:           sqlite3VdbeAddOp3(v, OP_HaltIfNull, SQLITE_CONSTRAINT_NOTNULL,",
          "1400:           sqlite3VdbeAppendP4(v, zMsg, P4_DYNAMIC);",
          "1401:           sqlite3VdbeChangeP5(v, P5_ConstraintNotNull);",
          "1402:           VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "1399:                             onError, regNewData+1+i);",
          "",
          "[Added Lines]",
          "1538:                             onError, iReg);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1405:         }",
          "1406:         default: {",
          "1407:           assert( onError==OE_Ignore );",
          "1409:           VdbeCoverage(v);",
          "1410:           break;",
          "1411:         }",
          "1412:       }",
          "1413:     }",
          "1414:   }",
          "1418: #ifndef SQLITE_OMIT_CHECK",
          "",
          "[Removed Lines]",
          "1408:           sqlite3VdbeAddOp2(v, OP_IsNull, regNewData+1+i, ignoreDest);",
          "",
          "[Added Lines]",
          "1547:           sqlite3VdbeAddOp2(v, OP_IsNull, iReg, ignoreDest);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1721:         sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);",
          "1722:         pParse->iSelfTab = 0;",
          "1723:         VdbeComment((v, \"%s column %d\", pIdx->zName, i));",
          "1724:       }else{",
          "1732:       }",
          "1733:     }",
          "1734:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regIdx, pIdx->nColumn, aRegIdx[ix]);",
          "",
          "[Removed Lines]",
          "1725:         if( iField==XN_ROWID || iField==pTab->iPKey ){",
          "1726:           x = regNewData;",
          "1727:         }else{",
          "1728:           x = iField + regNewData + 1;",
          "1729:         }",
          "1730:         sqlite3VdbeAddOp2(v, iField<0 ? OP_IntCopy : OP_SCopy, x, regIdx+i);",
          "1731:         VdbeComment((v, \"%s\", iField<0 ? \"rowid\" : pTab->aCol[iField].zName));",
          "",
          "[Added Lines]",
          "1863:       }else if( iField==XN_ROWID || iField==pTab->iPKey ){",
          "1864:         x = regNewData;",
          "1865:         sqlite3VdbeAddOp2(v, OP_IntCopy, x, regIdx+i);",
          "1866:         VdbeComment((v, \"rowid\"));",
          "1867: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1868:       }else if( pTab->aCol[iField].colFlags & COLFLAG_VIRTUAL ){",
          "1869:         pParse->iSelfTab = -(regNewData+1);",
          "1870:         sqlite3ExprCodeCopy(pParse, pTab->aCol[iField].pDflt, regIdx+i);",
          "1871:         pParse->iSelfTab = 0;",
          "1872:         VdbeComment((v, \"%s column %d\", pIdx->zName, i));",
          "1873: #endif",
          "1875:         testcase( sqlite3TableColumnToStorage(pTab, iField)!=iField );",
          "1876:         x = sqlite3TableColumnToStorage(pTab, iField) + regNewData + 1;",
          "1877:         sqlite3VdbeAddOp2(v, OP_SCopy, x, regIdx+i);",
          "1878:         VdbeComment((v, \"%s\", pTab->aCol[iField].zName));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1818:         if( pIdx!=pPk ){",
          "1819:           for(i=0; i<pPk->nKeyCol; i++){",
          "1820:             assert( pPk->aiColumn[i]>=0 );",
          "1822:             sqlite3VdbeAddOp3(v, OP_Column, iThisCur, x, regR+i);",
          "1823:             VdbeComment((v, \"%s.%s\", pTab->zName,",
          "1824:                          pTab->aCol[pPk->aiColumn[i]].zName));",
          "",
          "[Removed Lines]",
          "1821:             x = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "[Added Lines]",
          "1968:             x = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1983:   if( HasRowid(pTab) ){",
          "1984:     int regRec = aRegIdx[ix];",
          "1986:     sqlite3SetMakeRecordP5(v, pTab);",
          "1987:     if( !bAffinityDone ){",
          "1988:       sqlite3TableAffinity(v, pTab, 0);",
          "",
          "[Removed Lines]",
          "1985:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nCol, regRec);",
          "",
          "[Added Lines]",
          "2132:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nNVCol, regRec);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2376:     ){",
          "2378:     }",
          "2379: #endif",
          "2380:     if( pDestCol->affinity!=pSrcCol->affinity ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2526: #endif",
          "2527: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "2544:     if( (pDestCol->colFlags & COLFLAG_GENERATED) !=",
          "2545:         (pSrcCol->colFlags & COLFLAG_GENERATED) ){",
          "2547:     }",
          "2552:     if( (pDestCol->colFlags & COLFLAG_GENERATED)!=0 ){",
          "2553:       if( sqlite3ExprCompare(0, pSrcCol->pDflt, pDestCol->pDflt, -1)!=0 ){",
          "2554:         testcase( pDestCol->colFlags & COLFLAG_VIRTUAL );",
          "2555:         testcase( pDestCol->colFlags & COLFLAG_STORED );",
          "2557:       }",
          "2558:     }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2388:     }",
          "2391:       assert( pDestCol->pDflt==0 || pDestCol->pDflt->op==TK_SPAN );",
          "2392:       assert( pSrcCol->pDflt==0 || pSrcCol->pDflt->op==TK_SPAN );",
          "2393:       if( (pDestCol->pDflt==0)!=(pSrcCol->pDflt==0)",
          "",
          "[Removed Lines]",
          "2390:     if( i>0 ){",
          "",
          "[Added Lines]",
          "2570:     if( (pDestCol->colFlags & COLFLAG_GENERATED)==0 && i>0 ){",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "347:                                  {sqlite3CreateForeignKey(pParse,0,&T,TA,R);}",
          "348: ccons ::= defer_subclause(D).    {sqlite3DeferForeignKey(pParse,D);}",
          "349: ccons ::= COLLATE ids(C).        {sqlite3AddCollateType(pParse, &C);}",
          "352: %type autoinc {int}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "350: ccons ::= GENERATED ALWAYS AS generated.",
          "351: ccons ::= AS generated.",
          "352: generated ::= LP expr(E) RP.          {sqlite3AddGenerated(pParse,E,0);}",
          "353: generated ::= LP expr(E) RP ID(TYPE). {sqlite3AddGenerated(pParse,E,&TYPE);}",
          "",
          "---------------"
        ],
        "src/pragma.c||src/pragma.c": [
          "File: src/pragma.c -> src/pragma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1100:       sqlite3CodeVerifySchema(pParse, iTabDb);",
          "1101:       sqlite3ViewGetColumnNames(pParse, pTab);",
          "1102:       for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){",
          "1107:         }",
          "1108:         if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){",
          "1109:           k = 0;",
          "",
          "[Removed Lines]",
          "1103:         int isHidden = IsHiddenColumn(pCol);",
          "1104:         if( isHidden && pPragma->iArg==0 ){",
          "1105:           nHidden++;",
          "1106:           continue;",
          "",
          "[Added Lines]",
          "1103:         int isHidden = 0;",
          "1104:         if( pCol->colFlags & COLFLAG_NOINSERT ){",
          "1105:           if( pPragma->iArg==0 ){",
          "1106:             nHidden++;",
          "1107:             continue;",
          "1108:           }",
          "1109:           if( pCol->colFlags & COLFLAG_VIRTUAL ){",
          "1111:           }else if( pCol->colFlags & COLFLAG_STORED ){",
          "1113:           }else{ assert( pCol->colFlags & COLFLAG_HIDDEN );",
          "1115:           }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1112:         }else{",
          "1113:           for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}",
          "1114:         }",
          "1116:         sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\",",
          "1117:                i-nHidden,",
          "1118:                pCol->zName,",
          "1119:                sqlite3ColumnType(pCol,\"\"),",
          "1120:                pCol->notNull ? 1 : 0,",
          "1122:                k,",
          "1123:                isHidden);",
          "1124:       }",
          "",
          "[Removed Lines]",
          "1115:         assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN );",
          "1121:                pCol->pDflt ? pCol->pDflt->u.zToken : 0,",
          "",
          "[Added Lines]",
          "1124:         assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN || isHidden>=2 );",
          "1130:                pCol->pDflt && isHidden<2 ? pCol->pDflt->u.zToken : 0,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1577:         loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);",
          "1578:         if( !isQuick ){",
          "1581:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
          "1582:         }",
          "",
          "[Removed Lines]",
          "1580:           sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nCol-1, 3);",
          "",
          "[Added Lines]",
          "1589:           sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "414:     if( cnt==0",
          "415:      && cntTab==1",
          "416:      && pMatch",
          "418:      && sqlite3IsRowid(zCol)",
          "419:      && VisibleRowid(pMatch->pTab)",
          "420:     ){",
          "",
          "[Removed Lines]",
          "417:      && (pNC->ncFlags & NC_IdxExpr)==0",
          "",
          "[Added Lines]",
          "417:      && (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "627: ){",
          "629:   if( (pNC->ncFlags & validMask)!=0 ){",
          "630:     const char *zIn = \"partial index WHERE clauses\";",
          "631:     if( pNC->ncFlags & NC_IdxExpr )      zIn = \"index expressions\";",
          "632: #ifndef SQLITE_OMIT_CHECK",
          "633:     else if( pNC->ncFlags & NC_IsCheck ) zIn = \"CHECK constraints\";",
          "634: #endif",
          "635:     sqlite3ErrorMsg(pParse, \"%s prohibited in %s\", zMsg, zIn);",
          "636:   }",
          "",
          "[Removed Lines]",
          "628:   assert( (validMask&~(NC_IsCheck|NC_PartIdx|NC_IdxExpr))==0 );",
          "",
          "[Added Lines]",
          "628:   assert( (validMask&~(NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol))==0 );",
          "634: #endif",
          "635: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "636:     else if( pNC->ncFlags & NC_GenCol ) zIn = \"generated columns\";",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "723:         zColumn = pExpr->u.zToken;",
          "724:       }else{",
          "725:         Expr *pLeft = pExpr->pLeft;",
          "727:         pRight = pExpr->pRight;",
          "728:         if( pRight->op==TK_ID ){",
          "729:           zDb = 0;",
          "",
          "[Removed Lines]",
          "726:         notValid(pParse, pNC, \"the \\\".\\\" operator\", NC_IdxExpr);",
          "",
          "[Added Lines]",
          "729:         notValid(pParse, pNC, \"the \\\".\\\" operator\", NC_IdxExpr|NC_GenCol);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "822:           notValid(pParse, pNC, \"non-deterministic functions\",",
          "824:         }",
          "825:         if( (pDef->funcFlags & SQLITE_FUNC_INTERNAL)!=0",
          "826:          && pParse->nested==0",
          "",
          "[Removed Lines]",
          "823:                    NC_IdxExpr|NC_PartIdx);",
          "",
          "[Added Lines]",
          "826:                    NC_IdxExpr|NC_PartIdx|NC_GenCol);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "964:       testcase( pExpr->op==TK_IN );",
          "965:       if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "966:         int nRef = pNC->nRef;",
          "968:         sqlite3WalkSelect(pWalker, pExpr->x.pSelect);",
          "969:         assert( pNC->nRef>=nRef );",
          "970:         if( nRef!=pNC->nRef ){",
          "",
          "[Removed Lines]",
          "967:         notValid(pParse, pNC, \"subqueries\", NC_IsCheck|NC_PartIdx|NC_IdxExpr);",
          "",
          "[Added Lines]",
          "970:         notValid(pParse, pNC, \"subqueries\",",
          "971:                  NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "975:       break;",
          "976:     }",
          "977:     case TK_VARIABLE: {",
          "979:       break;",
          "980:     }",
          "981:     case TK_IS:",
          "",
          "[Removed Lines]",
          "978:       notValid(pParse, pNC, \"parameters\", NC_IsCheck|NC_PartIdx|NC_IdxExpr);",
          "",
          "[Added Lines]",
          "982:       notValid(pParse, pNC, \"parameters\",",
          "983:                NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1798: int sqlite3ResolveSelfReference(",
          "1804: ){",
          "1807:   int rc;",
          "1809:   assert( type==0 || pTab!=0 );",
          "1811:   memset(&sNC, 0, sizeof(sNC));",
          "1812:   memset(&sSrc, 0, sizeof(sSrc));",
          "1813:   if( pTab ){",
          "",
          "[Removed Lines]",
          "1810:   assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr || pTab==0 );",
          "",
          "[Added Lines]",
          "1816:   assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr",
          "1817:           || type==NC_GenCol || pTab==0 );",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3937: Table *sqlite3ResultSetOfSelect(Parse*,Select*,char);",
          "3938: void sqlite3OpenMasterTable(Parse *, int);",
          "3939: Index *sqlite3PrimaryKeyIndex(Table*);",
          "3941: void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);",
          "3942: #if SQLITE_ENABLE_HIDDEN_COLUMNS",
          "3943:   void sqlite3ColumnPropertiesFromName(Table*, Column*);",
          "",
          "[Removed Lines]",
          "3940: i16 sqlite3ColumnOfIndex(Index*, i16);",
          "",
          "[Added Lines]",
          "3970: i16 sqlite3TableColumnToIndex(Index*, i16);",
          "3971: #ifdef SQLITE_OMIT_GENERATED_COLUMNS",
          "3974: #else",
          "3975:   i16 sqlite3TableColumnToStorage(Table*, i16);",
          "3976:   i16 sqlite3StorageColumnToTable(Table*, i16);",
          "3977: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3950: void sqlite3AddCheckConstraint(Parse*, Expr*);",
          "3951: void sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*);",
          "3952: void sqlite3AddCollateType(Parse*, Token*);",
          "3953: void sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);",
          "3954: int sqlite3ParseUri(const char*,const char*,unsigned int*,",
          "3955:                     sqlite3_vfs**,char**,char **);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3990: void sqlite3AddGenerated(Parse*,Expr*,Token*);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4007: # define sqlite3AutoincrementEnd(X)",
          "4008: #endif",
          "4009: void sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int, Upsert*);",
          "4010: void *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*);",
          "4011: IdList *sqlite3IdListAppend(Parse*, IdList*, Token*);",
          "4012: int sqlite3IdListIndex(IdList*,const char*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4048: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "4049:   void sqlite3ComputeGeneratedColumns(Parse*, int, Table*);",
          "4050: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4056: void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);",
          "4057: void sqlite3ExprCodeMove(Parse*, int, int, int);",
          "4058: void sqlite3ExprCode(Parse*, Expr*, int);",
          "4059: void sqlite3ExprCodeCopy(Parse*, Expr*, int);",
          "4060: void sqlite3ExprCodeFactorable(Parse*, Expr*, int);",
          "4061: int sqlite3ExprCodeAtInit(Parse*, Expr*, int);",
          "4062: int sqlite3ExprCodeTemp(Parse*, Expr*, int*);",
          "4063: int sqlite3ExprCodeTarget(Parse*, Expr*, int);",
          "4065: int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);",
          "",
          "[Removed Lines]",
          "4064: void sqlite3ExprCodeAndCache(Parse*, Expr*, int);",
          "",
          "[Added Lines]",
          "4100: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "4101: void sqlite3ExprCodeGeneratedColumn(Parse*, Column*, int);",
          "4102: #endif",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "312:         }else if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){",
          "313:           chngPk = 1;",
          "314:         }",
          "315:         aXRef[j] = i;",
          "316:         break;",
          "317:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "316:         else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){",
          "317:           testcase( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL );",
          "318:           testcase( pTab->aCol[j].colFlags & COLFLAG_STORED );",
          "319:           sqlite3ErrorMsg(pParse,",
          "320:              \"cannot UPDATE generated column \\\"%s\\\"\",",
          "321:              pTab->aCol[j].zName);",
          "322:           goto update_cleanup;",
          "323:         }",
          "324: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "346:   assert( chngPk==0 || chngPk==1 );",
          "347:   chngKey = chngRowid + chngPk;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "359: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "367:   if( pTab->tabFlags & TF_HasGenerated ){",
          "368:     int bProgress;",
          "369:     testcase( pTab->tabFlags & TF_HasVirtual );",
          "370:     testcase( pTab->tabFlags & TF_HasStored );",
          "371:     do{",
          "372:       bProgress = 0;",
          "373:       for(i=0; i<pTab->nCol; i++){",
          "374:         if( aXRef[i]>=0 ) continue;",
          "375:         if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 ) continue;",
          "376:         if( sqlite3ExprReferencesUpdatedColumn(pTab->aCol[i].pDflt,",
          "377:                                                aXRef, chngRowid) ){",
          "378:           aXRef[i] = 99999;",
          "379:           bProgress = 1;",
          "380:         }",
          "381:       }",
          "382:     }while( bProgress );",
          "383:   }",
          "384: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "544:     for(i=0; i<nPk; i++){",
          "545:       assert( pPk->aiColumn[i]>=0 );",
          "547:     }",
          "548:     if( eOnePass ){",
          "549:       if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);",
          "",
          "[Removed Lines]",
          "546:       sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,pPk->aiColumn[i],iPk+i);",
          "",
          "[Added Lines]",
          "583:       sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,",
          "584:                                       pPk->aiColumn[i], iPk+i);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "623:     oldmask |= sqlite3TriggerColmask(pParse,",
          "624:         pTrigger, pChanges, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onError",
          "625:     );",
          "627:       if( oldmask==0xffffffff",
          "628:        || (i<32 && (oldmask & MASKBIT32(i))!=0)",
          "630:       ){",
          "631:         testcase(  oldmask!=0xffffffff && i==31 );",
          "633:       }else{",
          "635:       }",
          "636:     }",
          "637:     if( chngRowid==0 && pPk==0 ){",
          "",
          "[Removed Lines]",
          "626:     for(i=0; i<pTab->nCol; i++){",
          "629:        || (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY)!=0",
          "632:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regOld+i);",
          "634:         sqlite3VdbeAddOp2(v, OP_Null, 0, regOld+i);",
          "",
          "[Added Lines]",
          "664:     for(i=0, k=regOld; i<pTab->nCol; i++, k++){",
          "665:       u32 colFlags = pTab->aCol[i].colFlags;",
          "666:       if( colFlags & COLFLAG_VIRTUAL ){",
          "667:         k--;",
          "668:         continue;",
          "669:       }",
          "672:        || (colFlags & COLFLAG_PRIMKEY)!=0",
          "675:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "677:         sqlite3VdbeAddOp2(v, OP_Null, 0, k);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "655:   newmask = sqlite3TriggerColmask(",
          "656:       pParse, pTrigger, pChanges, 1, TRIGGER_BEFORE, pTab, onError",
          "657:   );",
          "659:     if( i==pTab->iPKey ){",
          "661:     }else{",
          "662:       j = aXRef[i];",
          "663:       if( j>=0 ){",
          "665:       }else if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i)) ){",
          "",
          "[Removed Lines]",
          "658:   for(i=0; i<pTab->nCol; i++){",
          "660:       sqlite3VdbeAddOp2(v, OP_Null, 0, regNew+i);",
          "664:         sqlite3ExprCode(pParse, pChanges->a[j].pExpr, regNew+i);",
          "",
          "[Added Lines]",
          "701:   for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "703:       sqlite3VdbeAddOp2(v, OP_Null, 0, k);",
          "704:     }else if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)!=0 ){",
          "705:       if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "709:         sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "671:         testcase( i==31 );",
          "672:         testcase( i==32 );",
          "674:       }else{",
          "676:       }",
          "677:     }",
          "678:   }",
          "",
          "[Removed Lines]",
          "673:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew+i);",
          "675:         sqlite3VdbeAddOp2(v, OP_Null, 0, regNew+i);",
          "",
          "[Added Lines]",
          "718:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "720:         sqlite3VdbeAddOp2(v, OP_Null, 0, k);",
          "724: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "725:   if( pTab->tabFlags & TF_HasGenerated ){",
          "726:     testcase( pTab->tabFlags & TF_HasVirtual );",
          "727:     testcase( pTab->tabFlags & TF_HasStored );",
          "728:     sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "729:   }",
          "730: #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "714:       }",
          "715:     }",
          "716:   }",
          "718:   if( !isView ){",
          "",
          "[Removed Lines]",
          "711:     for(i=0; i<pTab->nCol; i++){",
          "712:       if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "713:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew+i);",
          "",
          "[Added Lines]",
          "763:     for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "764:       if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "765:         if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "766:       }else if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "767:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "770: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "771:     if( pTab->tabFlags & TF_HasGenerated ){",
          "772:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "773:       testcase( pTab->tabFlags & TF_HasStored );",
          "774:       sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "775:     }",
          "776: #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "920:   for(i=0; i<pTab->nCol; i++){",
          "921:     if( aXRef[i]>=0 ){",
          "922:       sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);",
          "923:     }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "982:     assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );",
          "",
          "---------------"
        ],
        "src/upsert.c||src/upsert.c": [
          "File: src/upsert.c -> src/upsert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "226:       for(i=0; i<nPk; i++){",
          "227:         int k;",
          "228:         assert( pPk->aiColumn[i]>=0 );",
          "230:         sqlite3VdbeAddOp3(v, OP_Column, iCur, k, iPk+i);",
          "231:         VdbeComment((v, \"%s.%s\", pIdx->zName,",
          "232:                     pTab->aCol[pPk->aiColumn[i]].zName));",
          "",
          "[Removed Lines]",
          "229:         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "[Added Lines]",
          "229:         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3375:       p->rc = rc = SQLITE_BUSY;",
          "3376:       goto vdbe_return;",
          "3377:     }",
          "3379:     sqlite3CloseSavepoints(db);",
          "3380:     if( p->rc==SQLITE_OK ){",
          "3381:       rc = SQLITE_DONE;",
          "",
          "[Removed Lines]",
          "3378:     assert( db->nStatement==0 );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.h||src/vdbe.h": [
          "File: src/vdbe.h -> src/vdbe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "181: Vdbe *sqlite3VdbeCreate(Parse*);",
          "182: int sqlite3VdbeAddOp0(Vdbe*,int);",
          "183: int sqlite3VdbeAddOp1(Vdbe*,int,int);",
          "184: int sqlite3VdbeAddOp2(Vdbe*,int,int,int);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: Parse *sqlite3VdbeParser(Vdbe*);",
          "",
          "---------------"
        ],
        "src/vdbeapi.c||src/vdbeapi.c": [
          "File: src/vdbeapi.c -> src/vdbeapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1831:     goto preupdate_old_out;",
          "1832:   }",
          "1833:   if( p->pPk ){",
          "1835:   }",
          "1836:   if( iIdx>=p->pCsr->nField || iIdx<0 ){",
          "1837:     rc = SQLITE_RANGE;",
          "",
          "[Removed Lines]",
          "1834:     iIdx = sqlite3ColumnOfIndex(p->pPk, iIdx);",
          "",
          "[Added Lines]",
          "1834:     iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1921:     goto preupdate_new_out;",
          "1922:   }",
          "1923:   if( p->pPk && p->op!=SQLITE_UPDATE ){",
          "1925:   }",
          "1926:   if( iIdx>=p->pCsr->nField || iIdx<0 ){",
          "1927:     rc = SQLITE_RANGE;",
          "",
          "[Removed Lines]",
          "1924:     iIdx = sqlite3ColumnOfIndex(p->pPk, iIdx);",
          "",
          "[Added Lines]",
          "1924:     iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:   return p;",
          "43: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: Parse *sqlite3VdbeParser(Vdbe *p){",
          "49:   return p->pParse;",
          "50: }",
          "",
          "---------------"
        ],
        "src/vtab.c||src/vtab.c": [
          "File: src/vtab.c -> src/vtab.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "624:       rc = SQLITE_ERROR;",
          "625:     }else{",
          "626:       int iCol;",
          "",
          "[Removed Lines]",
          "627:       u8 oooHidden = 0;",
          "",
          "[Added Lines]",
          "627:       u16 oooHidden = 0;",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5376:             Index *pPk = sqlite3PrimaryKeyIndex(pTab);",
          "5377:             x = pPk->aiColumn[x];",
          "5378:             assert( x>=0 );",
          "5379:           }",
          "5381:           if( x>=0 ){",
          "5382:             pOp->p2 = x;",
          "5383:             pOp->p1 = pLevel->iIdxCur;",
          "",
          "[Removed Lines]",
          "5380:           x = sqlite3ColumnOfIndex(pIdx, x);",
          "",
          "[Added Lines]",
          "5379:           }else{",
          "5380:             testcase( x!=sqlite3StorageColumnToTable(pTab,x) );",
          "5381:             x = sqlite3StorageColumnToTable(pTab,x);",
          "5383:           x = sqlite3TableColumnToIndex(pIdx, x);",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "823:   assert( pHint->pIdx!=0 );",
          "824:   if( pExpr->op==TK_COLUMN",
          "825:    && pExpr->iTable==pHint->iTabCur",
          "827:   ){",
          "828:     pWalker->eCode = 1;",
          "829:   }",
          "",
          "[Removed Lines]",
          "826:    && sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn)<0",
          "",
          "[Added Lines]",
          "826:    && sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn)<0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "891:       pExpr->iTable = reg;",
          "892:     }else if( pHint->pIdx!=0 ){",
          "893:       pExpr->iTable = pHint->iIdxCur;",
          "895:       assert( pExpr->iColumn>=0 );",
          "896:     }",
          "897:   }else if( pExpr->op==TK_AGG_FUNCTION ){",
          "",
          "[Removed Lines]",
          "894:       pExpr->iColumn = sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn);",
          "",
          "[Added Lines]",
          "894:       pExpr->iColumn = sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1128:   }",
          "1129: }",
          "1136: static void whereIndexExprTrans(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1132: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1136: static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){",
          "1137:   if( pExpr->op==TK_COLUMN ){",
          "1138:     IdxExprTrans *pX = p->u.pIdxTrans;",
          "1139:     if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){",
          "1140:       pExpr->iTable = pX->iIdxCur;",
          "1141:       pExpr->iColumn = pX->iIdxCol;",
          "1142:       pExpr->y.pTab = 0;",
          "1143:     }",
          "1144:   }",
          "1145:   return WRC_Continue;",
          "1146: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1141: ){",
          "1144:   Walker w;",
          "1145:   IdxExprTrans x;",
          "1146:   aColExpr = pIdx->aColExpr;",
          "1148:   memset(&w, 0, sizeof(w));",
          "1150:   w.u.pIdxTrans = &x;",
          "1151:   x.iTabCur = iTabCur;",
          "1152:   x.iIdxCur = iIdxCur;",
          "1156:     x.iIdxCol = iIdxCol;",
          "1158:     sqlite3WalkExpr(&w, pWInfo->pWhere);",
          "1159:     sqlite3WalkExprList(&w, pWInfo->pOrderBy);",
          "1160:     sqlite3WalkExprList(&w, pWInfo->pResultSet);",
          "",
          "[Removed Lines]",
          "1149:   w.xExprCallback = whereIndexExprTransNode;",
          "1153:   for(iIdxCol=0; iIdxCol<aColExpr->nExpr; iIdxCol++){",
          "1154:     if( pIdx->aiColumn[iIdxCol]!=XN_EXPR ) continue;",
          "1155:     assert( aColExpr->a[iIdxCol].pExpr!=0 );",
          "1157:     x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;",
          "",
          "[Added Lines]",
          "1166:   Table *pTab;",
          "1170:   if( aColExpr==0 && !pIdx->bHasVCol ){",
          "1173:     return;",
          "1174:   }",
          "1175:   pTab = pIdx->pTable;",
          "1180:   for(iIdxCol=0; iIdxCol<pIdx->nColumn; iIdxCol++){",
          "1181:     i16 iRef = pIdx->aiColumn[iIdxCol];",
          "1182:     if( iRef==XN_EXPR ){",
          "1183:       assert( aColExpr->a[iIdxCol].pExpr!=0 );",
          "1184:       x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;",
          "1185:       w.xExprCallback = whereIndexExprTransNode;",
          "1186: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1187:     }else if( iRef>=0 && (pTab->aCol[iRef].colFlags & COLFLAG_VIRTUAL)!=0 ){",
          "1188:       x.iTabCol = iRef;",
          "1189:       w.xExprCallback = whereIndexExprTransColumn;",
          "1191:     }else{",
          "1192:       continue;",
          "1193:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1826:       Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);",
          "1827:       iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);",
          "1828:       for(j=0; j<pPk->nKeyCol; j++){",
          "1830:         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, iRowidReg+j);",
          "1831:       }",
          "1832:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iCur, addrCont,",
          "",
          "[Removed Lines]",
          "1829:         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "[Added Lines]",
          "1866:         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2086:               r = sqlite3GetTempRange(pParse, nPk);",
          "2087:               for(iPk=0; iPk<nPk; iPk++){",
          "2088:                 int iCol = pPk->aiColumn[iPk];",
          "2090:               }",
          "",
          "[Removed Lines]",
          "2089:                 sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r+iPk);",
          "",
          "[Added Lines]",
          "2128:                 sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol,r+iPk);",
          "",
          "---------------"
        ],
        "tool/mkkeywordhash.c||tool/mkkeywordhash.c": [
          "File: tool/mkkeywordhash.c -> tool/mkkeywordhash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "164:   { \"AFTER\",            \"TK_AFTER\",        TRIGGER                },",
          "165:   { \"ALL\",              \"TK_ALL\",          ALWAYS                 },",
          "166:   { \"ALTER\",            \"TK_ALTER\",        ALTER                  },",
          "167:   { \"ANALYZE\",          \"TK_ANALYZE\",      ANALYZE                },",
          "168:   { \"AND\",              \"TK_AND\",          ALWAYS                 },",
          "169:   { \"AS\",               \"TK_AS\",           ALWAYS                 },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "167:   { \"ALWAYS\",           \"TK_ALWAYS\",       ALWAYS                 },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "216:   { \"FOREIGN\",          \"TK_FOREIGN\",      FKEY                   },",
          "217:   { \"FROM\",             \"TK_FROM\",         ALWAYS                 },",
          "218:   { \"FULL\",             \"TK_JOIN_KW\",      ALWAYS                 },",
          "219:   { \"GLOB\",             \"TK_LIKE_KW\",      ALWAYS                 },",
          "220:   { \"GROUP\",            \"TK_GROUP\",        ALWAYS                 },",
          "221:   { \"GROUPS\",           \"TK_GROUPS\",       WINDOWFUNC             },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220:   { \"GENERATED\",        \"TK_GENERATED\",    ALWAYS                 },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20cee7d0bb8f627c3952f24a5c4772f8fbb4d720",
      "candidate_info": {
        "commit_hash": "20cee7d0bb8f627c3952f24a5c4772f8fbb4d720",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/20cee7d0bb8f627c3952f24a5c4772f8fbb4d720",
        "files": [
          "ext/misc/totype.c",
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/resolve.c",
          "src/sqliteInt.h",
          "src/vdbeaux.c",
          "test/check.test",
          "test/date2.test",
          "test/indexexpr1.test"
        ],
        "message": "Always disallow the use of non-deterministic functions in CHECK constraints, even date/time functions that use the 'now' or similar keywords.  Provide improved error messages when this requirement is not met. Ticket [830277d9db6c3ba1]\n\nFossilOrigin-Name: 2978b65ebe25eeabe543b67cb266308cceb20082a4ae71565d6d083d7c08bc9f",
        "before_after_code_files": [
          "ext/misc/totype.c||ext/misc/totype.c",
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/resolve.c||src/resolve.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/vdbeaux.c||src/vdbeaux.c",
          "test/check.test||test/check.test",
          "test/date2.test||test/date2.test",
          "test/indexexpr1.test||test/indexexpr1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/totype.c||ext/misc/totype.c": [
          "File: ext/misc/totype.c -> ext/misc/totype.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "502:   int rc = SQLITE_OK;",
          "503:   SQLITE_EXTENSION_INIT2(pApi);",
          "507:   if( rc==SQLITE_OK ){",
          "510:   }",
          "511:   return rc;",
          "512: }",
          "",
          "[Removed Lines]",
          "505:   rc = sqlite3_create_function(db, \"tointeger\", 1, SQLITE_UTF8, 0,",
          "506:                                tointegerFunc, 0, 0);",
          "508:     rc = sqlite3_create_function(db, \"toreal\", 1, SQLITE_UTF8, 0,",
          "509:                                  torealFunc, 0, 0);",
          "",
          "[Added Lines]",
          "505:   rc = sqlite3_create_function(db, \"tointeger\", 1,",
          "506:         SQLITE_UTF8 | SQLITE_DETERMINISTIC, 0,",
          "507:         tointegerFunc, 0, 0);",
          "509:     rc = sqlite3_create_function(db, \"toreal\", 1,",
          "510:         SQLITE_UTF8 | SQLITE_DETERMINISTIC, 0,",
          "511:         torealFunc, 0, 0);",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 84e02d773d60cffe619104991d21d7f0c68616c0f6bb99686bf54f5306c756d0",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4033: #endif",
          "4034:       {",
          "4035:         sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,",
          "4037:       }",
          "4038:       if( nFarg && constMask==0 ){",
          "4039:         sqlite3ReleaseTempRange(pParse, r1, nFarg);",
          "",
          "[Removed Lines]",
          "4036:                                    pDef, pParse->iSelfTab);",
          "",
          "[Added Lines]",
          "4036:                                    pDef, pExpr->op2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5028:      && (combinedFlags & EP_Reduced)==0",
          "5029:     ){",
          "5030:       if( pA->iColumn!=pB->iColumn ) return 2;",
          "5032:       if( pA->op!=TK_IN && pA->iTable!=pB->iTable && pA->iTable!=iTab ){",
          "5033:         return 2;",
          "5034:       }",
          "",
          "[Removed Lines]",
          "5031:       if( pA->op2!=pB->op2 ) return 2;",
          "",
          "[Added Lines]",
          "5031:       if( pA->op2!=pB->op2 && (pA->op!=TK_FUNCTION || iTab<0) ) return 2;",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "815:         if( pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG) ){",
          "819:           ExprSetProperty(pExpr,EP_ConstFunc);",
          "820:         }",
          "821:         if( (pDef->funcFlags & SQLITE_FUNC_CONSTANT)==0 ){",
          "827:         }",
          "828:         if( (pDef->funcFlags & SQLITE_FUNC_INTERNAL)!=0",
          "829:          && pParse->nested==0",
          "",
          "[Removed Lines]",
          "825:           notValid(pParse, pNC, \"non-deterministic functions\",",
          "826:                    NC_IdxExpr|NC_PartIdx|NC_GenCol);",
          "",
          "[Added Lines]",
          "826:           notValid(pParse, pNC, \"non-deterministic functions\", NC_SelfRef);",
          "827:         }else{",
          "829:           pExpr->op2 = pNC->ncFlags & NC_SelfRef;",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2487: struct Expr {",
          "2491:   union {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2490:   u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2532:   union {",
          "2533:     Table *pTab;           /* TK_COLUMN: Table containing column. Can be NULL",
          "",
          "[Removed Lines]",
          "2528:   u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "365:   }",
          "366:   pCtx->pOut = 0;",
          "367:   pCtx->pFunc = (FuncDef*)pFunc;",
          "369:   pCtx->isError = 0;",
          "370:   pCtx->argc = nArg;",
          "371:   addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,",
          "372:                            p1, p2, p3, (char*)pCtx, P4_FUNCCTX);",
          "373:   pCtx->iOp = addr;",
          "374:   return addr;",
          "375: }",
          "",
          "[Removed Lines]",
          "368:   pCtx->pVdbe = v;",
          "",
          "[Added Lines]",
          "368:   pCtx->pVdbe = 0;",
          "373:   sqlite3VdbeChangeP5(v, eCallCtx & NC_SelfRef);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5001: int sqlite3NotPureFunc(sqlite3_context *pCtx){",
          "5002: #ifdef SQLITE_ENABLE_STAT4",
          "5003:   if( pCtx->pVdbe==0 ) return 1;",
          "5004: #endif",
          "5010:     sqlite3_result_error(pCtx, zMsg, -1);",
          "5011:     sqlite3_free(zMsg);",
          "5017:     return 0;",
          "5018:   }",
          "5019:   return 1;",
          "",
          "[Removed Lines]",
          "5005:   if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==OP_PureFunc ){",
          "5006: #if 0",
          "5007:     char *zMsg = sqlite3_mprintf(",
          "5008:        \"non-deterministic use of %s() in an index, CHECK constraint, \"",
          "5009:        \"or generated column\", pCtx->pFunc->zName);",
          "5012: #else",
          "5013:     sqlite3_result_error(pCtx,",
          "5014:        \"non-deterministic function in index expression or CHECK constraint\",",
          "5015:        -1);",
          "5016: #endif",
          "",
          "[Added Lines]",
          "5003:   const VdbeOp *pOp;",
          "5007:   pOp = pCtx->pVdbe->aOp + pCtx->iOp;",
          "5008:   if( pOp->opcode==OP_PureFunc ){",
          "5009:     const char *zContext;",
          "5010:     char *zMsg;",
          "5011:     if( pOp->p5 & NC_IsCheck ){",
          "5012:       zContext = \"a CHECK constraint\";",
          "5013:     }else if( pOp->p5 & NC_GenCol ){",
          "5014:       zContext = \"a generated column\";",
          "5015:     }else{",
          "5016:       zContext = \"an index\";",
          "5017:     }",
          "5018:     zMsg = sqlite3_mprintf(\"non-deterministic use of %s() in %s\",",
          "5019:                            pCtx->pFunc->zName, zContext);",
          "",
          "---------------"
        ],
        "test/check.test||test/check.test": [
          "File: test/check.test -> test/check.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "442: #",
          "443: reset_db",
          "444: proc myfunc {x} {expr $x < 10}",
          "447: do_execsql_test  7.1 { CREATE TABLE t6(a CHECK (myfunc(a))) }",
          "448: do_execsql_test  7.2 { INSERT INTO t6 VALUES(9)  }",
          "",
          "[Removed Lines]",
          "445: db func myfunc myfunc",
          "",
          "[Added Lines]",
          "445: db func myfunc -deterministic myfunc",
          "",
          "---------------"
        ],
        "test/date2.test||test/date2.test": [
          "File: test/date2.test -> test/date2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: } {}",
          "31: do_catchsql_test date2-110 {",
          "32:   INSERT INTO t1(x,y) VALUES('now','two');",
          "34: do_execsql_test date2-120 {",
          "35:   SELECT * FROM t1;",
          "36: } {2017-07-20 one}",
          "",
          "[Removed Lines]",
          "33: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "33: } {1 {non-deterministic use of date() in a CHECK constraint}}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45: }",
          "46: do_catchsql_test date2-210 {",
          "47:   INSERT INTO t2(x,y) VALUES(3, 'now');",
          "49: do_execsql_test date2-220 {",
          "50:   SELECT x, y FROM t2 ORDER BY x;",
          "51: } {1 2017-07-20 2 xyzzy}",
          "",
          "[Removed Lines]",
          "48: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "48: } {1 {non-deterministic use of date() in an index}}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "58: }",
          "59: do_catchsql_test date2-310 {",
          "60:   CREATE INDEX t3b1 ON t3(datetime(b));",
          "62: do_catchsql_test date2-320 {",
          "63:   CREATE INDEX t3b1 ON t3(datetime(b)) WHERE typeof(b)='real';",
          "64: } {0 {}}",
          "",
          "[Removed Lines]",
          "61: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "61: } {1 {non-deterministic use of datetime() in an index}}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "84: do_catchsql_test date2-410 {",
          "85:   CREATE INDEX t4b1 ON t4(b)",
          "86:     WHERE date(b) BETWEEN '2017-06-01' AND '2017-08-31';",
          "88: do_execsql_test date2-420 {",
          "89:   DELETE FROM t4 WHERE a=500;",
          "90:   CREATE INDEX t4b1 ON t4(b)",
          "",
          "[Removed Lines]",
          "87: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "87: } {1 {non-deterministic use of date() in an index}}",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "92: }",
          "93: do_catchsql_test date2-430 {",
          "94:   INSERT INTO t4(a,b) VALUES(9999,'now');",
          "97: do_execsql_test date2-500 {",
          "98:   CREATE TABLE mods(x);",
          "",
          "[Removed Lines]",
          "95: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "95: } {1 {non-deterministic use of date() in an index}}",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "121: }",
          "122: do_catchsql_test date2-510 {",
          "123:   INSERT INTO t5(y,m) VALUES('2017-07-20','localtime');",
          "125: do_catchsql_test date2-520 {",
          "126:   INSERT INTO t5(y,m) VALUES('2017-07-20','utc');",
          "134: finish_test",
          "",
          "[Removed Lines]",
          "124: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "127: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "124: } {1 {non-deterministic use of datetime() in an index}}",
          "127: } {1 {non-deterministic use of datetime() in an index}}",
          "129: # 2019-10-30 Ticket 830277d9db6c3ba1",
          "130: #",
          "131: do_catchsql_test date2-600 {",
          "132:   CREATE TABLE t600(a REAL CHECK( a<julianday('now') ));",
          "133:   INSERT INTO t600(a) VALUES(1.0);",
          "134: } {1 {non-deterministic use of julianday() in a CHECK constraint}}",
          "135: do_catchsql_test date2-601 {",
          "136:   CREATE TABLE t601(a REAL, b TEXT, CHECK( a<julianday(b) ));",
          "137:   INSERT INTO t601(a,b) VALUES(1.0, '1970-01-01');",
          "138: } {0 {}}",
          "139: do_catchsql_test date2-602 {",
          "140:   INSERT INTO t601(a,b) VALUES(1e100, '1970-01-01');",
          "141: } {1 {CHECK constraint failed: t601}}",
          "142: do_catchsql_test date2-603 {",
          "143:   INSERT INTO t601(a,b) VALUES(10, 'now');",
          "144: } {1 {non-deterministic use of julianday() in a CHECK constraint}}",
          "145: do_catchsql_test date2-604 {",
          "146:   INSERT INTO t600(a) VALUES(julianday('now')+10);",
          "147: } {1 {non-deterministic use of julianday() in a CHECK constraint}}",
          "150: do_catchsql_test date2-610 {",
          "151:   CREATE TABLE t610(a,b);",
          "152:   CREATE INDEX t610x1 ON t610(julianday('now')+b);",
          "153:   INSERT INTO t610(a,b) VALUES(123,456);",
          "154: } {1 {non-deterministic use of julianday() in an index}}",
          "155: do_catchsql_test date2-611 {",
          "156:   CREATE TABLE t611(a,b);",
          "157:   CREATE INDEX t611x1 ON t611(julianday(a)+b);",
          "158:   INSERT INTO t611(a,b) VALUES('1970-01-01',10.0);",
          "159: } {0 {}}",
          "160: do_catchsql_test date2-612 {",
          "161:   INSERT INTO t611(a,b) VALUES('now',10.0);",
          "162: } {1 {non-deterministic use of julianday() in an index}}",
          "164: do_catchsql_test date3-620 {",
          "165:   CREATE TABLE t620(a, b AS (a+julianday('now')));",
          "166:   INSERT INTO t620 VALUES(10);",
          "167: } {1 {non-deterministic use of julianday() in a generated column}}",
          "",
          "---------------"
        ],
        "test/indexexpr1.test||test/indexexpr1.test": [
          "File: test/indexexpr1.test -> test/indexexpr1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "186: } {1 {non-deterministic functions prohibited in index expressions}}",
          "187: do_catchsql_test indexexpr1-301 {",
          "188:   CREATE INDEX t2x1 ON t2(julianday('now',a));",
          "190: do_catchsql_test indexexpr1-310 {",
          "191:   CREATE INDEX t2x2 ON t2(a,b+(SELECT 15));",
          "192: } {1 {subqueries prohibited in index expressions}}",
          "",
          "[Removed Lines]",
          "189: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "189: } {1 {non-deterministic use of julianday() in an index}}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-6019",
  "cve_desc": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles inlined statistics messages in function CConnectionTransportUDPBase::Received_Data(), leading to an exception thrown from libprotobuf and resulting in a crash.",
  "repo": "ValveSoftware/GameNetworkingSockets",
  "patch_hash": "d944a10808891d202bb1d5e1998de6e0423af678",
  "patch_info": {
    "commit_hash": "d944a10808891d202bb1d5e1998de6e0423af678",
    "repo": "ValveSoftware/GameNetworkingSockets",
    "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/d944a10808891d202bb1d5e1998de6e0423af678",
    "files": [
      "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
    ],
    "message": "Tweak pointer math to avoid possible integer overflow",
    "before_after_code_files": [
      "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
    ]
  },
  "patch_diff": {
    "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp": [
      "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "840:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );",
      "841:    return;",
      "842:   }",
      "844:   {",
      "846:    return;",
      "847:   }",
      "",
      "[Removed Lines]",
      "843:   if ( pIn + cbStatsMsgIn > pPktEnd )",
      "845:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );",
      "",
      "[Added Lines]",
      "843:   if ( cbStatsMsgIn > pPktEnd - pIn )",
      "845:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %u, packet size %d\", cbStatsMsgIn, cbPkt );",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "56092ec7e73acb32ed18ca99505fb8f3cd160da3",
      "candidate_info": {
        "commit_hash": "56092ec7e73acb32ed18ca99505fb8f3cd160da3",
        "repo": "ValveSoftware/GameNetworkingSockets",
        "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/56092ec7e73acb32ed18ca99505fb8f3cd160da3",
        "files": [
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
        ],
        "message": "Fix compiler warning",
        "before_after_code_files": [
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
          ],
          "candidate": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "840:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );",
          "841:    return;",
          "842:   }",
          "844:   {",
          "845:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %u, packet size %d\", cbStatsMsgIn, cbPkt );",
          "846:    return;",
          "",
          "[Removed Lines]",
          "843:   if ( cbStatsMsgIn > pPktEnd - pIn )",
          "",
          "[Added Lines]",
          "843:   if ( cbStatsMsgIn > (uint32)(pPktEnd - pIn) )",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "96ea8abeda78a674eb16065094ba50339222eaa2",
      "candidate_info": {
        "commit_hash": "96ea8abeda78a674eb16065094ba50339222eaa2",
        "repo": "ValveSoftware/GameNetworkingSockets",
        "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/96ea8abeda78a674eb16065094ba50339222eaa2",
        "files": [
          "src/common/steamnetworkingsockets_messages_udp.proto",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.h",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.h"
        ],
        "message": "Make ICE connections wire equivalent with plain UDP.\n\n(Once NAT is pierced, and assuming we are not relaying through TURN, and\nignoring the actual STUN packets.)\n\nRefactored code so that almost all of the UDP code is shared.\n\nHaving this exact wire compatibility is really important for the future.\nI had assumed that the WebRTC code was putting some connection IDs, etc\nin the envelope, but I was wrong.  I believe that is happening at a higher\nlayer in their code (the DTLS layer), and I'm below that.\n\nI am pretty sur ethat I could get rid of the special \"ping check\" messages,\nand in fact they probably are just delaying the connection and I should\ntrust the WebRTC code.  Will probably revisit this later.",
        "before_after_code_files": [
          "src/common/steamnetworkingsockets_messages_udp.proto||src/common/steamnetworkingsockets_messages_udp.proto",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.h",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
          ],
          "candidate": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/common/steamnetworkingsockets_messages_udp.proto||src/common/steamnetworkingsockets_messages_udp.proto": [
          "File: src/common/steamnetworkingsockets_messages_udp.proto -> src/common/steamnetworkingsockets_messages_udp.proto",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:  k_ESteamNetworkingUDPMsg_ConnectionClosed = 36;   // Client<->server.  A reply is requested to this packet",
          "25:  k_ESteamNetworkingUDPMsg_NoConnection = 37;    // Client<->server.  A reply should never be sent to this packet",
          "27: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27:  k_ESteamNetworkingUDPMsg_ICEPingCheck = 39;    // Peer-to-peer, confirm end-to-end ICE connectivity",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "149:  optional uint32 flags = 3;",
          "150: };",
          "183: {",
          "184:  optional fixed64 send_timestamp = 1; // If present, receiver should immediately reply with this in recv_timestamp",
          "185:  optional fixed64 recv_timestamp = 2;",
          "186: };",
          "",
          "[Removed Lines]",
          "161: enum ESteamNetworkingICEMsgID",
          "162: {",
          "165:  k_ESteamNetworkingICEMsg_ConnectionClosed = 36; // Used to initiate graceful connection closure.  Peer is expected to close ICE connection in reply",
          "167:  k_ESteamNetworkingICEMsg_PingCheck = 39;",
          "168: };",
          "171: message CMsgSteamSockets_ICE_ConnectionClosed",
          "172: {",
          "177:  optional string debug = 2;",
          "178:  optional uint32 reason_code = 3;",
          "179: };",
          "182: message CMsgSteamSockets_ICE_PingCheck",
          "",
          "[Added Lines]",
          "154: message CMsgSteamSockets_UDP_ICEPingCheck",
          "158:  optional fixed32 to_connection_id = 3;",
          "159:  optional fixed32 from_connection_id = 4;",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.cpp": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: namespace SteamNetworkingSocketsLib {",
          "",
          "[Removed Lines]",
          "18: #pragma pack( push, 1 )",
          "19: struct ICEDataMsgHdr",
          "20: {",
          "21:  enum",
          "22:  {",
          "23:   kFlag_ProtobufBlob  = 0x01, // Protobuf-encoded message is inline (CMsgSteamSockets_UDP_Stats)",
          "24:  };",
          "32:  uint8 m_unMsgFlags;",
          "33:  uint16 m_unSeqNum;",
          "38: };",
          "39: #pragma pack( pop )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47: CConnectionTransportP2PICE::CConnectionTransportP2PICE( CSteamNetworkConnectionP2P &connection )",
          "49: , m_pICESession( nullptr )",
          "50: , m_pszNeedToSendSignalReason( nullptr )",
          "51: , m_usecSendSignalDeadline( INT64_MAX )",
          "",
          "[Removed Lines]",
          "48: : CConnectionTransport( connection )",
          "",
          "[Added Lines]",
          "25: : CConnectionTransportUDPBase( connection )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "331:     )",
          "332:    )",
          "333:   ) {",
          "335:    msgPing.set_send_timestamp( usecNow );",
          "337:    TrackSentPingRequest( usecNow, false );",
          "339:    Assert( m_usecInFlightReplyTimeout > usecNow );",
          "",
          "[Removed Lines]",
          "334:    CMsgSteamSockets_ICE_PingCheck msgPing;",
          "336:    SendMsg( k_ESteamNetworkingICEMsg_PingCheck, msgPing );",
          "",
          "[Added Lines]",
          "311:    CMsgSteamSockets_UDP_ICEPingCheck msgPing;",
          "313:    msgPing.set_from_connection_id( ConnectionIDLocal() );",
          "314:    msgPing.set_to_connection_id( ConnectionIDRemote() );",
          "315:    SendMsg( k_ESteamNetworkingUDPMsg_ICEPingCheck, msgPing );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "384:  m_ping.m_usecTimeLastSentPingRequest = usecNow;",
          "385: }",
          "561: #define ParseProtobufBody( pvMsg, cbMsg, CMsgCls, msgVar ) \\",
          "562:  CMsgCls msgVar; \\",
          "563:  if ( !msgVar.ParseFromArray( pvMsg, cbMsg ) ) \\",
          "564:  { \\",
          "566:   return; \\",
          "567:  }",
          "569: void CConnectionTransportP2PICE::ProcessPacket( const uint8_t *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )",
          "570: {",
          "571:  Assert( cbPkt >= 1 ); // Caller should have checked this",
          "",
          "[Removed Lines]",
          "387: void CConnectionTransportP2PICE::SendStatsMsg( EStatsReplyRequest eReplyRequested, SteamNetworkingMicroseconds usecNow, const char *pszReason )",
          "388: {",
          "389:  UDPSendPacketContext_t ctx( usecNow, pszReason );",
          "390:  ctx.Populate( sizeof(ICEDataMsgHdr), eReplyRequested, m_connection );",
          "393:  m_connection.SNP_SendPacket( this, ctx );",
          "394: }",
          "396: void CConnectionTransportP2PICE::SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason )",
          "397: {",
          "398:  SendStatsMsg( eRequest, usecNow, pszReason );",
          "399: }",
          "401: bool CConnectionTransportP2PICE::SendDataPacket( SteamNetworkingMicroseconds usecNow )",
          "402: {",
          "403:  if ( !m_pICESession )",
          "404:  {",
          "405:   Assert( false );",
          "406:   return false;",
          "407:  }",
          "411:  UDPSendPacketContext_t ctx( usecNow, \"data\" );",
          "412:  ctx.Populate( sizeof(ICEDataMsgHdr), k_EStatsReplyRequest_NothingToSend, m_connection );",
          "415:  return m_connection.SNP_SendPacket( this, ctx );",
          "416: }",
          "418: int CConnectionTransportP2PICE::SendEncryptedDataChunk( const void *pChunk, int cbChunk, SendPacketContext_t &ctxBase )",
          "419: {",
          "420:  if ( !m_pICESession )",
          "421:  {",
          "422:   Assert( false );",
          "423:   return 0;",
          "424:  }",
          "426:  UDPSendPacketContext_t &ctx = static_cast<UDPSendPacketContext_t &>( ctxBase );",
          "428:  uint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];",
          "429:  ICEDataMsgHdr *hdr = (ICEDataMsgHdr *)pkt;",
          "430:  hdr->m_unMsgFlags = 0x80;",
          "431:  hdr->m_unSeqNum = LittleWord( m_connection.m_statsEndToEnd.ConsumeSendPacketNumberAndGetWireFmt( ctx.m_usecNow ) );",
          "433:  byte *p = (byte*)( hdr + 1 );",
          "437:  int cbHdrOutSpaceRemaining = pkt + sizeof(pkt) - p - cbChunk;",
          "438:  if ( cbHdrOutSpaceRemaining < 0 )",
          "439:  {",
          "440:   AssertMsg( false, \"MTU / header size problem!\" );",
          "441:   return 0;",
          "442:  }",
          "444:  ctx.Trim( cbHdrOutSpaceRemaining);",
          "445:  if ( ctx.Serialize( p ) )",
          "446:  {",
          "448:   TrackSentStats( ctx.msg, true, ctx.m_usecNow );",
          "451:   hdr->m_unMsgFlags |= hdr->kFlag_ProtobufBlob;",
          "452:  }",
          "457:  memcpy( p, pChunk, cbChunk );",
          "458:  p += cbChunk;",
          "459:  int cbSend = p - pkt;",
          "460:  Assert( cbSend <= sizeof(pkt) ); // Bug in the code above.  We should never \"overflow\" the packet.  (Ignoring the fact that we using a gather-based send.  The data could be tiny with a large header for piggy-backed stats.)",
          "466:  ETW_ICESendPacket( m_connection.m_hConnectionSelf, cbSend );",
          "467:  if ( !m_pICESession->BSendData( pkt, cbSend ) )",
          "468:  {",
          "469:   SpewMsg( \"IICESession::BSendData FAILED\\n\" );",
          "470:   return -1;",
          "471:  }",
          "473:  return cbSend;",
          "474: }",
          "476: void CConnectionTransportP2PICE::RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, bool bInline, SteamNetworkingMicroseconds usecNow )",
          "477: {",
          "480:  if ( msgStatsIn.has_stats() )",
          "481:   m_connection.m_statsEndToEnd.ProcessMessage( msgStatsIn.stats(), usecNow );",
          "484:  SpewVerbose( \"[%s] Recv %s stats:%s\\n\",",
          "485:   ConnectionDescription(),",
          "486:   bInline ? \"inline\" : \"standalone\",",
          "487:   DescribeStatsContents( msgStatsIn ).c_str()",
          "488:  );",
          "491:  if ( m_connection.BStateIsConnectedForWirePurposes() )",
          "492:  {",
          "495:   bool bImmediate = ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_IMMEDIATE ) != 0;",
          "496:   if ( ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_E2E ) || msgStatsIn.has_stats() )",
          "497:   {",
          "498:    m_connection.QueueEndToEndAck( bImmediate, usecNow );",
          "499:   }",
          "502:   const char *pszReason = m_connection.NeedToSendEndToEndStatsOrAcks( usecNow );",
          "503:   if ( pszReason )",
          "504:   {",
          "506:    SendStatsMsg( k_EStatsReplyRequest_NothingToSend, usecNow, pszReason );",
          "507:   }",
          "508:  }",
          "509: }",
          "511: void CConnectionTransportP2PICE::TrackSentStats( const CMsgSteamSockets_UDP_Stats &msgStatsOut, bool bInline, SteamNetworkingMicroseconds usecNow )",
          "512: {",
          "515:  bool bAllowDelayedReply = ( msgStatsOut.flags() & msgStatsOut.ACK_REQUEST_IMMEDIATE ) == 0;",
          "518:  if ( msgStatsOut.has_stats() )",
          "519:  {",
          "520:   m_connection.m_statsEndToEnd.TrackSentStats( msgStatsOut.stats(), usecNow, bAllowDelayedReply );",
          "521:  }",
          "522:  else if ( msgStatsOut.flags() & msgStatsOut.ACK_REQUEST_E2E )",
          "523:  {",
          "524:   m_connection.m_statsEndToEnd.TrackSentMessageExpectingSeqNumAck( usecNow, bAllowDelayedReply );",
          "525:  }",
          "528:  if ( m_usecInFlightReplyTimeout == 0 && m_connection.m_pTransport == this )",
          "529:  {",
          "530:   m_usecInFlightReplyTimeout = m_connection.m_statsEndToEnd.m_usecInFlightReplyTimeout;",
          "531:   EnsureMinThinkTime( m_usecInFlightReplyTimeout );",
          "532:  }",
          "535:  SpewVerbose( \"[%s] Sent %s stats:%s\\n\",",
          "536:   ConnectionDescription(),",
          "537:   bInline ? \"inline\" : \"standalone\",",
          "538:   DescribeStatsContents( msgStatsOut ).c_str()",
          "539:  );",
          "540: }",
          "542: static void ReallyReportBadICEPacket( CConnectionTransportP2PICE *pTransport, const char *pszMsgType, const char *pszFmt, ... )",
          "543: {",
          "544:  char buf[ 2048 ];",
          "545:  va_list ap;",
          "546:  va_start( ap, pszFmt );",
          "547:  V_vsprintf_safe( buf, pszFmt, ap );",
          "548:  va_end( ap );",
          "549:  V_StripTrailingWhitespaceASCII( buf );",
          "551:  if ( !pszMsgType || !pszMsgType[0] )",
          "552:   pszMsgType = \"message\";",
          "554:  SpewMsg( \"[%s] Ignored bad %s.  %s\\n\", pTransport->ConnectionDescription(), pszMsgType, buf );",
          "555: }",
          "558: #define ReportBadPacket( pszMsgType, /* fmt */ ... ) \\",
          "559:  ( BCheckRateLimitReportBadPacket( usecNow ) ? ReallyReportBadICEPacket( this, pszMsgType, __VA_ARGS__ ) : (void)0 )",
          "565:   ReportBadPacket( # CMsgCls, \"Protobuf parse failed.\" ); \\",
          "",
          "[Added Lines]",
          "370:   ReportBadUDPPacketFromConnectionPeer( # CMsgCls, \"Protobuf parse failed.\" ); \\",
          "374: #define ParsePaddedPacket( pvPkt, cbPkt, CMsgCls, msgVar ) \\",
          "375:  CMsgCls msgVar; \\",
          "376:  { \\",
          "377:   if ( cbPkt < k_cbSteamNetworkingMinPaddedPacketSize ) \\",
          "378:   { \\",
          "379:    ReportBadUDPPacketFromConnectionPeer( # CMsgCls, \"Packet is %d bytes, must be padded to at least %d bytes.\", cbPkt, k_cbSteamNetworkingMinPaddedPacketSize ); \\",
          "380:    return; \\",
          "381:   } \\",
          "382:   const UDPPaddedMessageHdr *hdr =  (const UDPPaddedMessageHdr *)( pvPkt ); \\",
          "383:   int nMsgLength = LittleWord( hdr->m_nMsgLength ); \\",
          "384:   if ( nMsgLength <= 0 || int(nMsgLength+sizeof(UDPPaddedMessageHdr)) > cbPkt ) \\",
          "385:   { \\",
          "386:    ReportBadUDPPacketFromConnectionPeer( # CMsgCls, \"Invalid encoded message length %d.  Packet is %d bytes.\", nMsgLength, cbPkt ); \\",
          "387:    return; \\",
          "388:   } \\",
          "389:   if ( !msgVar.ParseFromArray( hdr+1, nMsgLength ) ) \\",
          "390:   { \\",
          "391:    ReportBadUDPPacketFromConnectionPeer( # CMsgCls, \"Protobuf parse failed.\" ); \\",
          "392:    return; \\",
          "393:   } \\",
          "394:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "586:  m_connection.m_statsEndToEnd.TrackRecvPacket( cbPkt, usecNow );",
          "589:  {",
          "591:   Received_ConnectionClosed( msg, usecNow );",
          "592:  }",
          "609:  {",
          "612:  }",
          "616:  {",
          "645:  }",
          "659:  {",
          "685:  }",
          "705: }",
          "708: {",
          "715:  if ( msg.has_recv_timestamp() )",
          "716:  {",
          "717:   SteamNetworkingMicroseconds usecElapsed = usecNow - msg.recv_timestamp();",
          "718:   if ( usecElapsed < 0 || usecElapsed > 2*k_nMillion )",
          "719:   {",
          "721:     (long long)usecElapsed, (long long)msg.recv_timestamp(), (long long)usecNow );",
          "722:   }",
          "723:   else",
          "",
          "[Removed Lines]",
          "588:  if ( *pPkt == k_ESteamNetworkingICEMsg_ConnectionClosed )",
          "590:   ParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_ICE_ConnectionClosed, msg )",
          "593:  else if ( *pPkt == k_ESteamNetworkingICEMsg_PingCheck )",
          "594:  {",
          "595:   ParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_ICE_PingCheck, msg )",
          "596:   Received_PingCheck( msg, usecNow );",
          "597:  }",
          "598:  else",
          "599:  {",
          "600:   ReportBadPacket( \"packet\", \"Lead byte 0x%02x not a known message ID\", *pPkt );",
          "601:  }",
          "602: }",
          "604: void CConnectionTransportP2PICE::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )",
          "605: {",
          "606:  ETW_ICERecvPacket( m_connection.m_hConnectionSelf, cbPkt );",
          "608:  if ( cbPkt < sizeof(ICEDataMsgHdr) )",
          "610:   ReportBadPacket( \"data\", \"Packet of size %d is too small.\", cbPkt );",
          "611:   return;",
          "615:  switch ( ConnectionState() )",
          "617:   case k_ESteamNetworkingConnectionState_Dead:",
          "618:   case k_ESteamNetworkingConnectionState_None:",
          "619:   case k_ESteamNetworkingConnectionState_Connecting: // Shouldn't be possible!",
          "620:   default:",
          "621:    Assert( false );",
          "622:    return;",
          "624:   case k_ESteamNetworkingConnectionState_ClosedByPeer:",
          "627:    return;",
          "629:   case k_ESteamNetworkingConnectionState_FinWait:",
          "630:   case k_ESteamNetworkingConnectionState_ProblemDetectedLocally:",
          "631:    SendConnectionClosed();",
          "632:    return;",
          "634:   case k_ESteamNetworkingConnectionState_FindingRoute:",
          "640:   case k_ESteamNetworkingConnectionState_Linger:",
          "641:   case k_ESteamNetworkingConnectionState_Connected:",
          "644:    break;",
          "648:  const ICEDataMsgHdr *hdr = (const ICEDataMsgHdr *)pPkt;",
          "649:  uint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );",
          "651:  const uint8 *pIn = pPkt + sizeof(*hdr);",
          "652:  const uint8 *pPktEnd = pPkt + cbPkt;",
          "655:  static CMsgSteamSockets_UDP_Stats msgStats;",
          "656:  CMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;",
          "657:  uint32 cbStatsMsgIn = 0;",
          "658:  if ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )",
          "662:   pIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );",
          "663:   if ( pIn == NULL )",
          "664:   {",
          "665:    ReportBadPacket( \"DataPacket\", \"Failed to varint decode size of stats blob\" );",
          "666:    return;",
          "667:   }",
          "668:   if ( pIn + cbStatsMsgIn > pPktEnd )",
          "669:   {",
          "670:    ReportBadPacket( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );",
          "671:    return;",
          "672:   }",
          "674:   if ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )",
          "675:   {",
          "676:    ReportBadPacket( \"DataPacket\", \"protobuf failed to parse inline stats message\" );",
          "677:    return;",
          "678:   }",
          "681:   pMsgStatsIn = &msgStats;",
          "684:   pIn += cbStatsMsgIn;",
          "687:  const void *pChunk = pIn;",
          "688:  int cbChunk = pPktEnd - pIn;",
          "691:  uint8 tempDecrypted[ k_cbSteamNetworkingSocketsMaxPlaintextPayloadRecv ];",
          "692:  void *pDecrypted = tempDecrypted;",
          "693:  uint32 cbDecrypted = sizeof(tempDecrypted);",
          "694:  int64 nFullSequenceNumber = m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, pDecrypted, cbDecrypted, usecNow );",
          "695:  if ( nFullSequenceNumber <= 0 )",
          "696:   return;",
          "699:  if ( !m_connection.ProcessPlainTextDataChunk( nFullSequenceNumber, pDecrypted, cbDecrypted, 0, usecNow ) )",
          "700:   return;",
          "703:  if ( pMsgStatsIn )",
          "704:   RecvStats( *pMsgStatsIn, true, usecNow );",
          "707: void CConnectionTransportP2PICE::Received_ConnectionClosed( const CMsgSteamSockets_ICE_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow )",
          "710:  m_connection.ConnectionState_ClosedByPeer( msg.reason_code(), msg.debug().c_str() );",
          "711: }",
          "713: void CConnectionTransportP2PICE::Received_PingCheck( const CMsgSteamSockets_ICE_PingCheck &msg, SteamNetworkingMicroseconds usecNow )",
          "714: {",
          "720:    ReportBadPacket( \"WeirdPingTimestamp\", \"Ignoring ping timestamp of %lld (%lld -> %lld)\",",
          "",
          "[Added Lines]",
          "415:  if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectionClosed )",
          "417:   ParsePaddedPacket( pPkt, cbPkt, CMsgSteamSockets_UDP_ConnectionClosed, msg )",
          "420:  else if ( *pPkt == k_ESteamNetworkingUDPMsg_NoConnection )",
          "422:   ParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_NoConnection, msg )",
          "423:   Received_NoConnection( msg, usecNow );",
          "425:  else if ( *pPkt == k_ESteamNetworkingUDPMsg_ICEPingCheck )",
          "427:   ParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ICEPingCheck, msg )",
          "428:   Received_PingCheck( msg, usecNow );",
          "430:  else",
          "432:   ReportBadUDPPacketFromConnectionPeer( \"packet\", \"Lead byte 0x%02x not a known message ID\", *pPkt );",
          "436: void CConnectionTransportP2PICE::Received_PingCheck( const CMsgSteamSockets_UDP_ICEPingCheck &msg, SteamNetworkingMicroseconds usecNow )",
          "445:    ReportBadUDPPacketFromConnectionPeer( \"WeirdPingTimestamp\", \"Ignoring ping timestamp of %lld (%lld -> %lld)\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "738:  if ( msg.has_send_timestamp() )",
          "739:  {",
          "741:   pong.set_recv_timestamp( msg.send_timestamp() );",
          "",
          "[Removed Lines]",
          "740:   CMsgSteamSockets_ICE_PingCheck pong;",
          "",
          "[Added Lines]",
          "465:   CMsgSteamSockets_UDP_ICEPingCheck pong;",
          "466:   pong.set_from_connection_id( ConnectionIDLocal() );",
          "467:   pong.set_to_connection_id( ConnectionIDRemote() );",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "748:    TrackSentPingRequest( usecNow, false );",
          "749:   }",
          "752:  }",
          "753: }",
          "769: void CConnectionTransportP2PICE::TransportConnectionStateChanged( ESteamNetworkingConnectionState eOldState )",
          "770: {",
          "771:  CConnectionTransport::TransportConnectionStateChanged( eOldState );",
          "",
          "[Removed Lines]",
          "751:   SendMsg( k_ESteamNetworkingICEMsg_PingCheck, pong );",
          "755: void CConnectionTransportP2PICE::SendConnectionClosed()",
          "756: {",
          "757:  CMsgSteamSockets_UDP_ConnectionClosed msg;",
          "758:  msg.set_from_connection_id( ConnectionIDLocal() );",
          "760:  if ( ConnectionIDRemote() )",
          "761:   msg.set_to_connection_id( ConnectionIDRemote() );",
          "763:  msg.set_reason_code( m_connection.m_eEndReason );",
          "764:  if ( m_connection.m_szEndDebug[0] )",
          "765:   msg.set_debug( m_connection.m_szEndDebug );",
          "766:  SendMsg( k_ESteamNetworkingUDPMsg_ConnectionClosed, msg );",
          "767: }",
          "",
          "[Added Lines]",
          "478:   SendMsg( k_ESteamNetworkingUDPMsg_ICEPingCheck, pong );",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "786:   case k_ESteamNetworkingConnectionState_FinWait:",
          "787:   case k_ESteamNetworkingConnectionState_ProblemDetectedLocally:",
          "789:    break;",
          "791:   case k_ESteamNetworkingConnectionState_ClosedByPeer:",
          "",
          "[Removed Lines]",
          "788:    SendConnectionClosed();",
          "",
          "[Added Lines]",
          "501:    SendConnectionClosedOrNoConnection();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "794:  }",
          "795: }",
          "798: {",
          "799:  if ( !m_pICESession )",
          "802:  uint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];",
          "806:  {",
          "809:  }",
          "816: }",
          "818: bool CConnectionTransportP2PICE::BCanSendEndToEndData() const",
          "",
          "[Removed Lines]",
          "797: void CConnectionTransportP2PICE::SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )",
          "800:   return;",
          "803:  pkt[0] = nMsgID;",
          "804:  int cbPkt = ProtoMsgByteSize( msg )+1;",
          "805:  if ( cbPkt > sizeof(pkt) )",
          "807:   AssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( cbPkt ), (int)sizeof(pkt) );",
          "808:   return;",
          "810:  uint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt+1 );",
          "811:  Assert( cbPkt == pEnd - pkt );",
          "813:  ETW_ICESendPacket( m_connection.m_hConnectionSelf, cbPkt );",
          "814:  m_pICESession->BSendData( pkt, cbPkt );",
          "",
          "[Added Lines]",
          "510: bool CConnectionTransportP2PICE::SendPacket( const void *pkt, int cbPkt )",
          "513:   return false;",
          "515:  ETW_ICESendPacket( m_connection.m_hConnectionSelf, cbPkt );",
          "516:  if ( !m_pICESession->BSendData( pkt, cbPkt ) )",
          "517:   return false;",
          "520:  m_connection.m_statsEndToEnd.TrackSentPacket( cbPkt );",
          "521:  return true;",
          "522: }",
          "524: bool CConnectionTransportP2PICE::SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal )",
          "525: {",
          "526:  if ( nChunks == 1 )",
          "527:  {",
          "528:   Assert( (int)pChunks->iov_len == cbSendTotal );",
          "529:   SendPacket( pChunks->iov_base, pChunks->iov_len );",
          "530:   return false;",
          "531:  }",
          "532:  if ( cbSendTotal > k_cbSteamNetworkingSocketsMaxUDPMsgLen )",
          "533:  {",
          "534:   Assert( false );",
          "535:   return false;",
          "536:  }",
          "538:  uint8 *p = pkt;",
          "539:  while ( nChunks > 0 )",
          "541:   if ( p + pChunks->iov_len > pkt+cbSendTotal )",
          "542:   {",
          "543:    Assert( false );",
          "544:    return false;",
          "545:   }",
          "546:   memcpy( p, pChunks->iov_base, pChunks->iov_len );",
          "547:   p += pChunks->iov_len;",
          "548:   --nChunks;",
          "549:   ++pChunks;",
          "551:  Assert( p == pkt+cbSendTotal );",
          "552:  return SendPacket( pkt, p-pkt );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "985:  if ( nSize < 1 )",
          "986:  {",
          "988:   return;",
          "989:  }",
          "",
          "[Removed Lines]",
          "987:   ReportBadPacket( \"packet\", \"Bad packet size: %d\", cbPkt );",
          "",
          "[Added Lines]",
          "724:   ReportBadUDPPacketFromConnectionPeer( \"packet\", \"Bad packet size: %d\", cbPkt );",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.h": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.h -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_p2p_ice.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #pragma once",
          "7: #include \"steamnetworkingsockets_p2p.h\"",
          "8: #include <mutex>",
          "10: #ifdef STEAMNETWORKINGSOCKETS_ENABLE_ICE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"steamnetworkingsockets_udp.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14: extern \"C\" CreateICESession_t g_SteamNetworkingSockets_CreateICESessionFunc;",
          "20: namespace SteamNetworkingSocketsLib {",
          "",
          "[Removed Lines]",
          "16: class CMsgSteamSockets_UDP_Stats;",
          "17: class CMsgSteamSockets_ICE_ConnectionClosed;",
          "18: class CMsgSteamSockets_ICE_PingCheck;",
          "",
          "[Added Lines]",
          "17: class CMsgSteamSockets_UDP_ICEPingCheck;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "23: struct UDPSendPacketContext_t;",
          "28: , public IThinker",
          "29: , private IICESessionDelegate",
          "30: {",
          "",
          "[Removed Lines]",
          "26: class CConnectionTransportP2PICE",
          "27: : public CConnectionTransport",
          "",
          "[Added Lines]",
          "25: class CConnectionTransportP2PICE final",
          "26: : public CConnectionTransportUDPBase",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "43:  virtual void TransportFreeResources() override;",
          "44:  virtual void TransportConnectionStateChanged( ESteamNetworkingConnectionState eOldState ) override;",
          "45:  virtual bool BCanSendEndToEndData() const override;",
          "51:  virtual void Think( SteamNetworkingMicroseconds usecNow ) override;",
          "",
          "[Removed Lines]",
          "46:  virtual bool SendDataPacket( SteamNetworkingMicroseconds usecNow ) override;",
          "47:  virtual void SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason ) override;",
          "48:  virtual int SendEncryptedDataChunk( const void *pChunk, int cbChunk, SendPacketContext_t &ctx ) override;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "64:  uint32 m_nLocalCandidatesRevision;",
          "65:  uint32 m_nRemoteCandidatesRevision;",
          "67:  void NotifyConnectionFailed( int nReasonCode, const char *pszReason );",
          "68:  void QueueSelfDestruct();",
          "69:  void ScheduleSendSignal( const char *pszReason );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:  std::string m_sPwdFragLocal;",
          "64:  std::string m_sPwdFragRemote;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "118:  void DrainPacketQueue( SteamNetworkingMicroseconds usecNow );",
          "119:  void ProcessPacket( const uint8_t *pData, int cbPkt, SteamNetworkingMicroseconds usecNow );",
          "132:  void TrackSentPingRequest( SteamNetworkingMicroseconds usecNow, bool bAllowDelayedReply );",
          "133: };",
          "",
          "[Removed Lines]",
          "120:  void Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow );",
          "121:  void Received_ConnectionClosed( const CMsgSteamSockets_ICE_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow );",
          "122:  void Received_PingCheck( const CMsgSteamSockets_ICE_PingCheck &msg, SteamNetworkingMicroseconds usecNow );",
          "124:  void SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg );",
          "126:  void SendConnectionClosed();",
          "129:  void RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, bool bInline, SteamNetworkingMicroseconds usecNow );",
          "130:  void SendStatsMsg( EStatsReplyRequest eReplyRequested, SteamNetworkingMicroseconds usecNow, const char *pszReason );",
          "131:  void TrackSentStats( const CMsgSteamSockets_UDP_Stats &msgStatsOut, bool bInline, SteamNetworkingMicroseconds usecNow );",
          "",
          "[Added Lines]",
          "119:  void Received_PingCheck( const CMsgSteamSockets_UDP_ICEPingCheck &msg, SteamNetworkingMicroseconds usecNow );",
          "122:  virtual bool SendPacket( const void *pkt, int cbPkt ) override;",
          "123:  virtual bool SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal ) override;",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include \"tier0/memdbgon.h\"",
          "13: namespace SteamNetworkingSocketsLib {",
          "",
          "[Removed Lines]",
          "10: const int k_cbSteamNetworkingMinPaddedPacketSize = 512;",
          "15: #pragma pack( push, 1 )",
          "18: struct UDPPaddedMessageHdr",
          "19: {",
          "20:  uint8 m_nMsgID;",
          "21:  uint16 m_nMsgLength;",
          "22: };",
          "24: struct UDPDataMsgHdr",
          "25: {",
          "26:  enum",
          "27:  {",
          "28:   kFlag_ProtobufBlob  = 0x01, // Protobuf-encoded message is inline (CMsgSteamSockets_UDP_Stats)",
          "29:  };",
          "31:  uint8 m_unMsgFlags;",
          "32:  uint32 m_unToConnectionID; // Recipient's portion of the connection ID",
          "33:  uint16 m_unSeqNum;",
          "38: };",
          "39: #pragma pack( pop )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:  return true;",
          "54: }",
          "57: {",
          "58:  char buf[ 2048 ];",
          "59:  va_list ap;",
          "",
          "[Removed Lines]",
          "56: static void ReallyReportBadUDPPacket( const netadr_t &adrFrom, const char *pszMsgType, const char *pszFmt, ... )",
          "",
          "[Added Lines]",
          "28: void ReallyReportBadUDPPacket( const char *pszFrom, const char *pszMsgType, const char *pszFmt, ... )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "65:  if ( !pszMsgType || !pszMsgType[0] )",
          "66:   pszMsgType = \"message\";",
          "69: }",
          "74: #define ReportBadPacket( pszMsgType, /* fmt */ ... ) \\",
          "78: #define ParseProtobufBody( pvMsg, cbMsg, CMsgCls, msgVar ) \\",
          "",
          "[Removed Lines]",
          "68:  SpewMsg( \"Ignored bad %s from %s.  %s\\n\", pszMsgType, CUtlNetAdrRender( adrFrom ).String(), buf );",
          "71: #define ReportBadPacketFrom( adrFrom, pszMsgType, /* fmt */ ... ) \\",
          "72:  ( BCheckRateLimitReportBadPacket( usecNow ) ? ReallyReportBadUDPPacket( adrFrom, pszMsgType, __VA_ARGS__ ) : (void)0 )",
          "75:  ReportBadPacketFrom( adrFrom, pszMsgType, __VA_ARGS__ )",
          "",
          "[Added Lines]",
          "40:  SpewMsg( \"[%s] Ignored bad %s.  %s\\n\", pszMsgType, pszFrom, buf );",
          "44:  ReportBadUDPPacketFrom( CUtlNetAdrRender( adrFrom ).String(), pszMsgType, __VA_ARGS__ )",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "537: : CConnectionTransport( connection )",
          "640: {",
          "667: }",
          "670: {",
          "671:  UDPSendPacketContext_t ctx( usecNow, pszReason );",
          "672:  ctx.Populate( sizeof(UDPDataMsgHdr), eReplyRequested, m_connection );",
          "",
          "[Removed Lines]",
          "527: CSteamNetworkConnectionUDP::CSteamNetworkConnectionUDP( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface )",
          "528: : CSteamNetworkConnectionBase( pSteamNetworkingSocketsInterface )",
          "529: {",
          "530: }",
          "532: CSteamNetworkConnectionUDP::~CSteamNetworkConnectionUDP()",
          "533: {",
          "534: }",
          "536: CConnectionTransportUDP::CConnectionTransportUDP( CSteamNetworkConnectionUDP &connection )",
          "538: , m_pSocket( nullptr )",
          "539: {",
          "540: }",
          "542: CConnectionTransportUDP::~CConnectionTransportUDP()",
          "543: {",
          "544:  Assert( !m_pSocket ); // Use TransportDestroySelfNow!",
          "545: }",
          "547: void CConnectionTransportUDP::TransportFreeResources()",
          "548: {",
          "549:  CConnectionTransport::TransportFreeResources();",
          "551:  if ( m_pSocket )",
          "552:  {",
          "553:   m_pSocket->Close();",
          "554:   m_pSocket = nullptr;",
          "555:  }",
          "556: }",
          "558: void CSteamNetworkConnectionUDP::GetConnectionTypeDescription( ConnectionTypeDescription_t &szDescription ) const",
          "559: {",
          "560:  char szAddr[ 64 ];",
          "561:  if ( Transport() && Transport()->m_pSocket )",
          "562:  {",
          "563:   SteamNetworkingIPAddr adrRemote;",
          "564:   NetAdrToSteamNetworkingIPAddr( adrRemote, Transport()->m_pSocket->GetRemoteHostAddr() );",
          "565:   adrRemote.ToString( szAddr, sizeof(szAddr), true );",
          "566:   if (",
          "567:    m_identityRemote.IsLocalHost()",
          "568:    || ( m_identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress && adrRemote == m_identityRemote.m_ip )",
          "569:   ) {",
          "570:    V_sprintf_safe( szDescription, \"UDP %s\", szAddr );",
          "571:    return;",
          "572:   }",
          "573:  }",
          "574:  else",
          "575:  {",
          "576:   V_strcpy_safe( szAddr, \"???\" );",
          "577:  }",
          "579:  SteamNetworkingIdentityRender sIdentity( m_identityRemote );",
          "581:  V_sprintf_safe( szDescription, \"UDP %s@%s\", sIdentity.c_str(), szAddr );",
          "582: }",
          "584: void UDPSendPacketContext_t::Populate( size_t cbHdrtReserve, EStatsReplyRequest eReplyRequested, CSteamNetworkConnectionBase &connection )",
          "585: {",
          "586:  LinkStatsTracker<LinkStatsTrackerEndToEnd> &statsEndToEnd = connection.m_statsEndToEnd;",
          "589:  uint32 nFlags = 0;",
          "590:  int nReadyToSendTracer = 0;",
          "591:  if ( eReplyRequested == k_EStatsReplyRequest_Immediate || statsEndToEnd.BNeedToSendPingImmediate( m_usecNow ) )",
          "592:   nFlags |= msg.ACK_REQUEST_E2E | msg.ACK_REQUEST_IMMEDIATE;",
          "593:  else if ( eReplyRequested == k_EStatsReplyRequest_DelayedOK || statsEndToEnd.BNeedToSendKeepalive( m_usecNow ) )",
          "594:   nFlags |= msg.ACK_REQUEST_E2E;",
          "595:  else",
          "596:  {",
          "597:   nReadyToSendTracer = statsEndToEnd.ReadyToSendTracerPing( m_usecNow );",
          "598:   if ( nReadyToSendTracer > 1 )",
          "599:    nFlags |= msg.ACK_REQUEST_E2E;",
          "600:  }",
          "602:  m_nFlags = nFlags;",
          "605:  if ( statsEndToEnd.BNeedToSendStats( m_usecNow ) )",
          "606:  {",
          "607:   m_nStatsNeed = 2;",
          "608:   statsEndToEnd.PopulateMessage( *msg.mutable_stats(), m_usecNow );",
          "610:   if ( nReadyToSendTracer > 0 )",
          "611:    nFlags |= msg.ACK_REQUEST_E2E;",
          "613:   SlamFlagsAndCalcSize();",
          "614:   CalcMaxEncryptedPayloadSize( cbHdrtReserve, &connection );",
          "615:  }",
          "616:  else",
          "617:  {",
          "619:   SlamFlagsAndCalcSize();",
          "620:   CalcMaxEncryptedPayloadSize( cbHdrtReserve, &connection );",
          "623:   if ( statsEndToEnd.BReadyToSendStats( m_usecNow ) )",
          "624:   {",
          "625:    if ( nReadyToSendTracer > 0 )",
          "626:     nFlags |= msg.ACK_REQUEST_E2E;",
          "627:    statsEndToEnd.PopulateMessage( *msg.mutable_stats(), m_usecNow );",
          "628:    SlamFlagsAndCalcSize();",
          "629:    m_nStatsNeed = 1;",
          "630:   }",
          "631:   else",
          "632:   {",
          "634:    m_nStatsNeed = 0;",
          "635:   }",
          "636:  }",
          "637: }",
          "639: void UDPSendPacketContext_t::Trim( int cbHdrOutSpaceRemaining )",
          "641:  while ( m_cbTotalSize > cbHdrOutSpaceRemaining )",
          "642:  {",
          "644:   if ( msg.has_stats() )",
          "645:   {",
          "646:    AssertMsg( m_nStatsNeed == 1, \"We didn't reserve enough space for stats!\" );",
          "647:    if ( msg.stats().has_instantaneous() && msg.stats().has_lifetime() )",
          "648:    {",
          "650:     msg.mutable_stats()->clear_instantaneous();",
          "651:    }",
          "652:    else",
          "653:    {",
          "655:     msg.clear_stats();",
          "656:    }",
          "658:    SlamFlagsAndCalcSize();",
          "659:    continue;",
          "660:   }",
          "663:   AssertMsg( false, \"Serialized stats message still won't fit, ever after clearing everything?\" );",
          "664:   m_cbTotalSize = 0;",
          "665:   break;",
          "666:  }",
          "669: void CConnectionTransportUDP::SendStatsMsg( EStatsReplyRequest eReplyRequested, SteamNetworkingMicroseconds usecNow, const char *pszReason )",
          "",
          "[Added Lines]",
          "496: CConnectionTransportUDPBase::CConnectionTransportUDPBase( CSteamNetworkConnectionBase &connection )",
          "501: void CConnectionTransportUDPBase::SendStatsMsg( EStatsReplyRequest eReplyRequested, SteamNetworkingMicroseconds usecNow, const char *pszReason )",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "675:  m_connection.SNP_SendPacket( this, ctx );",
          "676: }",
          "679: {",
          "681:  UDPSendPacketContext_t ctx( usecNow, \"data\" );",
          "",
          "[Removed Lines]",
          "678: bool CConnectionTransportUDP::SendDataPacket( SteamNetworkingMicroseconds usecNow )",
          "",
          "[Added Lines]",
          "510: bool CConnectionTransportUDPBase::SendDataPacket( SteamNetworkingMicroseconds usecNow )",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "685:  return m_connection.SNP_SendPacket( this, ctx );",
          "686: }",
          "689: {",
          "696:  UDPSendPacketContext_t &ctx = static_cast<UDPSendPacketContext_t &>( ctxBase );",
          "698:  uint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];",
          "",
          "[Removed Lines]",
          "688: int CConnectionTransportUDP::SendEncryptedDataChunk( const void *pChunk, int cbChunk, SendPacketContext_t &ctxBase )",
          "690:  if ( !m_pSocket )",
          "691:  {",
          "692:   Assert( false );",
          "693:   return 0;",
          "694:  }",
          "",
          "[Added Lines]",
          "520: int CConnectionTransportUDPBase::SendEncryptedDataChunk( const void *pChunk, int cbChunk, SendPacketContext_t &ctxBase )",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "746: }",
          "749: {",
          "763: }",
          "766: {",
          "786:  {",
          "796: }",
          "799: {",
          "",
          "[Removed Lines]",
          "744:  SendPacketGather( 2, gather, cbSend );",
          "745:  return cbSend;",
          "748: bool CConnectionTransportUDP::BConnect( const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )",
          "758:  Assert( !m_pSocket );",
          "759:  m_pSocket = OpenUDPSocketBoundToHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ), errMsg );",
          "760:  if ( !m_pSocket )",
          "761:   return false;",
          "762:  return true;",
          "765: bool CConnectionTransportUDP::BAccept( CSharedSocket *pSharedSock, const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )",
          "768:  m_pSocket = pSharedSock->AddRemoteHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ) );",
          "769:  if ( !m_pSocket )",
          "770:  {",
          "772:   V_strcpy_safe( errMsg, \"Unable to create a bound socket on the shared socket.\" );",
          "773:   return false;",
          "774:  }",
          "776:  return true;",
          "777: }",
          "779: bool CConnectionTransportUDP::CreateLoopbackPair( CConnectionTransportUDP *pTransport[2] )",
          "780: {",
          "781:  IBoundUDPSocket *sock[2];",
          "782:  SteamNetworkingErrMsg errMsg;",
          "783:  if ( !CreateBoundSocketPair(",
          "784:   CRecvPacketCallback( PacketReceived, pTransport[0] ),",
          "785:   CRecvPacketCallback( PacketReceived, pTransport[1] ), sock, errMsg ) )",
          "788:   AssertMsg1( false, \"Failed to create UDP socket pair.  %s\", errMsg );",
          "789:   return false;",
          "790:  }",
          "792:  pTransport[0]->m_pSocket = sock[0];",
          "793:  pTransport[1]->m_pSocket = sock[1];",
          "795:  return true;",
          "798: bool CSteamNetworkConnectionUDP::BInitConnect( const SteamNetworkingIPAddr &addressRemote, int nOptions, const SteamNetworkingConfigValue_t *pOptions, SteamDatagramErrMsg &errMsg )",
          "800:  AssertMsg( !m_pTransport, \"Trying to connect when we already have a socket?\" );",
          "803:  Assert( !m_pParentListenSocket );",
          "804:  Assert( !m_bConnectionInitiatedRemotely );",
          "806:  netadr_t netadrRemote;",
          "807:  SteamNetworkingIPAddrToNetAdr( netadrRemote, addressRemote );",
          "",
          "[Added Lines]",
          "570:  if ( SendPacketGather( 2, gather, cbSend ) )",
          "571:   return cbSend;",
          "572:  return 0;",
          "575: std::string DescribeStatsContents( const CMsgSteamSockets_UDP_Stats &msg )",
          "577:  std::string sWhat;",
          "578:  if ( msg.flags() & msg.ACK_REQUEST_E2E )",
          "579:   sWhat += \" request_ack\";",
          "580:  if ( msg.flags() & msg.ACK_REQUEST_IMMEDIATE )",
          "581:   sWhat += \" request_ack_immediate\";",
          "582:  if ( msg.stats().has_lifetime() )",
          "583:   sWhat += \" stats.life\";",
          "584:  if ( msg.stats().has_instantaneous() )",
          "585:   sWhat += \" stats.rate\";",
          "586:  return sWhat;",
          "589: void CConnectionTransportUDPBase::RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, bool bInline, SteamNetworkingMicroseconds usecNow )",
          "593:  if ( msgStatsIn.has_stats() )",
          "594:   m_connection.m_statsEndToEnd.ProcessMessage( msgStatsIn.stats(), usecNow );",
          "597:  SpewVerbose( \"[%s] Recv %s stats:%s\\n\",",
          "598:   ConnectionDescription(),",
          "599:   bInline ? \"inline\" : \"standalone\",",
          "600:   DescribeStatsContents( msgStatsIn ).c_str()",
          "601:  );",
          "604:  if ( m_connection.BStateIsConnectedForWirePurposes() )",
          "608:   bool bImmediate = ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_IMMEDIATE ) != 0;",
          "609:   if ( ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_E2E ) || msgStatsIn.has_stats() )",
          "610:   {",
          "611:    m_connection.QueueEndToEndAck( bImmediate, usecNow );",
          "612:   }",
          "615:   const char *pszReason = m_connection.NeedToSendEndToEndStatsOrAcks( usecNow );",
          "616:   if ( pszReason )",
          "617:   {",
          "619:    SendStatsMsg( k_EStatsReplyRequest_NothingToSend, usecNow, pszReason );",
          "620:   }",
          "621:  }",
          "624: void CConnectionTransportUDPBase::TrackSentStats( const CMsgSteamSockets_UDP_Stats &msgStatsOut, bool bInline, SteamNetworkingMicroseconds usecNow )",
          "628:  bool bAllowDelayedReply = ( msgStatsOut.flags() & msgStatsOut.ACK_REQUEST_IMMEDIATE ) == 0;",
          "631:  if ( msgStatsOut.has_stats() )",
          "632:  {",
          "633:   m_connection.m_statsEndToEnd.TrackSentStats( msgStatsOut.stats(), usecNow, bAllowDelayedReply );",
          "634:  }",
          "635:  else if ( msgStatsOut.flags() & msgStatsOut.ACK_REQUEST_E2E )",
          "636:  {",
          "637:   m_connection.m_statsEndToEnd.TrackSentMessageExpectingSeqNumAck( usecNow, bAllowDelayedReply );",
          "638:  }",
          "641:  SpewVerbose( \"[%s] Sent %s stats:%s\\n\",",
          "642:   ConnectionDescription(),",
          "643:   bInline ? \"inline\" : \"standalone\",",
          "644:   DescribeStatsContents( msgStatsOut ).c_str()",
          "645:  );",
          "646: }",
          "648: void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )",
          "649: {",
          "651:  if ( cbPkt < sizeof(UDPDataMsgHdr) )",
          "652:  {",
          "653:   ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Packet of size %d is too small.\", cbPkt );",
          "654:   return;",
          "655:  }",
          "658:  const UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;",
          "659:  if ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )",
          "660:  {",
          "663:   ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Incorrect connection ID\" );",
          "664:   if ( BCheckGlobalSpamReplyRateLimit( usecNow ) )",
          "665:   {",
          "666:    SendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );",
          "667:   }",
          "668:   return;",
          "669:  }",
          "670:  uint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );",
          "673:  switch ( ConnectionState() )",
          "674:  {",
          "675:   case k_ESteamNetworkingConnectionState_Dead:",
          "676:   case k_ESteamNetworkingConnectionState_None:",
          "677:   case k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP",
          "678:   default:",
          "679:    Assert( false );",
          "680:    return;",
          "682:   case k_ESteamNetworkingConnectionState_ClosedByPeer:",
          "683:   case k_ESteamNetworkingConnectionState_FinWait:",
          "684:   case k_ESteamNetworkingConnectionState_ProblemDetectedLocally:",
          "685:    SendConnectionClosedOrNoConnection();",
          "686:    return;",
          "688:   case k_ESteamNetworkingConnectionState_Connecting:",
          "693:    return;",
          "695:   case k_ESteamNetworkingConnectionState_Linger:",
          "696:   case k_ESteamNetworkingConnectionState_Connected:",
          "699:    break;",
          "700:  }",
          "702:  const uint8 *pIn = pPkt + sizeof(*hdr);",
          "703:  const uint8 *pPktEnd = pPkt + cbPkt;",
          "706:  static CMsgSteamSockets_UDP_Stats msgStats;",
          "707:  CMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;",
          "708:  uint32 cbStatsMsgIn = 0;",
          "709:  if ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )",
          "710:  {",
          "713:   pIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );",
          "714:   if ( pIn == NULL )",
          "715:   {",
          "716:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );",
          "717:    return;",
          "718:   }",
          "719:   if ( pIn + cbStatsMsgIn > pPktEnd )",
          "720:   {",
          "721:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );",
          "722:    return;",
          "723:   }",
          "725:   if ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )",
          "726:   {",
          "727:    ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"protobuf failed to parse inline stats message\" );",
          "728:    return;",
          "729:   }",
          "732:   pMsgStatsIn = &msgStats;",
          "735:   pIn += cbStatsMsgIn;",
          "736:  }",
          "738:  const void *pChunk = pIn;",
          "739:  int cbChunk = pPktEnd - pIn;",
          "742:  uint8 tempDecrypted[ k_cbSteamNetworkingSocketsMaxPlaintextPayloadRecv ];",
          "743:  void *pDecrypted = tempDecrypted;",
          "744:  uint32 cbDecrypted = sizeof(tempDecrypted);",
          "745:  int64 nFullSequenceNumber = m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, pDecrypted, cbDecrypted, usecNow );",
          "746:  if ( nFullSequenceNumber <= 0 )",
          "747:   return;",
          "750:  if ( !m_connection.ProcessPlainTextDataChunk( nFullSequenceNumber, pDecrypted, cbDecrypted, 0, usecNow ) )",
          "751:   return;",
          "754:  if ( pMsgStatsIn )",
          "755:   RecvStats( *pMsgStatsIn, true, usecNow );",
          "756: }",
          "758: void CConnectionTransportUDPBase::SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason )",
          "759: {",
          "760:  SendStatsMsg( eRequest, usecNow, pszReason );",
          "761: }",
          "763: void CConnectionTransportUDPBase::SendConnectionClosedOrNoConnection()",
          "764: {",
          "765:  if ( ConnectionState() == k_ESteamNetworkingConnectionState_ClosedByPeer )",
          "766:  {",
          "767:   SendNoConnection( ConnectionIDLocal(), ConnectionIDRemote() );",
          "768:  }",
          "769:  else",
          "770:  {",
          "771:   CMsgSteamSockets_UDP_ConnectionClosed msg;",
          "772:   msg.set_from_connection_id( ConnectionIDLocal() );",
          "774:   if ( ConnectionIDRemote() )",
          "775:    msg.set_to_connection_id( ConnectionIDRemote() );",
          "777:   msg.set_reason_code( m_connection.m_eEndReason );",
          "778:   if ( m_connection.m_szEndDebug[0] )",
          "779:    msg.set_debug( m_connection.m_szEndDebug );",
          "780:   SendPaddedMsg( k_ESteamNetworkingUDPMsg_ConnectionClosed, msg );",
          "781:  }",
          "782: }",
          "784: void CConnectionTransportUDPBase::SendNoConnection( uint32 unFromConnectionID, uint32 unToConnectionID )",
          "785: {",
          "786:  CMsgSteamSockets_UDP_NoConnection msg;",
          "787:  if ( unFromConnectionID == 0 && unToConnectionID == 0 )",
          "788:  {",
          "789:   AssertMsg( false, \"Can't send NoConnection, we need at least one of from/to connection ID!\" );",
          "790:   return;",
          "791:  }",
          "792:  if ( unFromConnectionID )",
          "793:   msg.set_from_connection_id( unFromConnectionID );",
          "794:  if ( unToConnectionID )",
          "795:   msg.set_to_connection_id( unToConnectionID );",
          "796:  SendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msg );",
          "797: }",
          "799: void CConnectionTransportUDPBase::SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )",
          "800: {",
          "802:  uint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];",
          "803:  pkt[0] = nMsgID;",
          "804:  int cbPkt = ProtoMsgByteSize( msg )+1;",
          "805:  if ( cbPkt > sizeof(pkt) )",
          "806:  {",
          "807:   AssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( cbPkt ), (int)sizeof(pkt) );",
          "808:   return;",
          "809:  }",
          "810:  uint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt+1 );",
          "811:  Assert( cbPkt == pEnd - pkt );",
          "813:  SendPacket( pkt, cbPkt );",
          "814: }",
          "816: void CConnectionTransportUDPBase::SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )",
          "817: {",
          "819:  uint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];",
          "820:  V_memset( pkt, 0, sizeof(pkt) ); // don't send random bits from our process memory over the wire!",
          "821:  UDPPaddedMessageHdr *hdr = (UDPPaddedMessageHdr *)pkt;",
          "822:  int nMsgLength = ProtoMsgByteSize( msg );",
          "823:  if ( nMsgLength + sizeof(*hdr) > k_cbSteamNetworkingSocketsMaxUDPMsgLen )",
          "824:  {",
          "825:   AssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( nMsgLength + sizeof(*hdr) ), (int)sizeof(pkt) );",
          "826:   return;",
          "827:  }",
          "828:  hdr->m_nMsgID = nMsgID;",
          "829:  hdr->m_nMsgLength = LittleWord( uint16( nMsgLength ) );",
          "830:  uint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt + sizeof(*hdr) );",
          "831:  int cbPkt = pEnd - pkt;",
          "832:  Assert( cbPkt == int( sizeof(*hdr) + nMsgLength ) );",
          "833:  cbPkt = MAX( cbPkt, k_cbSteamNetworkingMinPaddedPacketSize );",
          "835:  SendPacket( pkt, cbPkt );",
          "836: }",
          "838: void CConnectionTransportUDPBase::Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow )",
          "839: {",
          "847:  bool bConnectionIDMatch =",
          "848:   msg.to_connection_id() == ConnectionIDLocal()",
          "849:   || ( msg.to_connection_id() == 0 && msg.from_connection_id() && msg.from_connection_id() == m_connection.m_unConnectionIDRemote ); // they might not know our ID yet, if they are a client aborting the connection really early.",
          "850:  if ( bConnectionIDMatch || BCheckGlobalSpamReplyRateLimit( usecNow ) )",
          "851:  {",
          "853:   CMsgSteamSockets_UDP_NoConnection msgReply;",
          "854:   if ( msg.to_connection_id() )",
          "855:    msgReply.set_from_connection_id( msg.to_connection_id() );",
          "856:   if ( msg.from_connection_id() )",
          "857:    msgReply.set_to_connection_id( msg.from_connection_id() );",
          "858:   SendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msgReply );",
          "859:  }",
          "863:  if ( !bConnectionIDMatch )",
          "864:   return;",
          "867:  m_connection.ConnectionState_ClosedByPeer( msg.reason_code(), msg.debug().c_str() );",
          "868: }",
          "870: void CConnectionTransportUDPBase::Received_NoConnection( const CMsgSteamSockets_UDP_NoConnection &msg, SteamNetworkingMicroseconds usecNow )",
          "871: {",
          "873:  if ( msg.to_connection_id() != ConnectionIDLocal() || msg.from_connection_id() != m_connection.m_unConnectionIDRemote )",
          "874:  {",
          "875:   ReportBadUDPPacketFromConnectionPeer( \"NoConnection\", \"Old/incorrect connection ID.  Message is for a stale connection, or is spoofed.  Ignoring.\" );",
          "876:   return;",
          "877:  }",
          "880:  m_connection.ConnectionState_ClosedByPeer( 0, nullptr );",
          "881: }",
          "889: CSteamNetworkConnectionUDP::CSteamNetworkConnectionUDP( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface )",
          "890: : CSteamNetworkConnectionBase( pSteamNetworkingSocketsInterface )",
          "891: {",
          "892: }",
          "894: CSteamNetworkConnectionUDP::~CSteamNetworkConnectionUDP()",
          "895: {",
          "896: }",
          "898: CConnectionTransportUDP::CConnectionTransportUDP( CSteamNetworkConnectionUDP &connection )",
          "899: : CConnectionTransportUDPBase( connection )",
          "900: , m_pSocket( nullptr )",
          "901: {",
          "902: }",
          "904: CConnectionTransportUDP::~CConnectionTransportUDP()",
          "905: {",
          "906:  Assert( !m_pSocket ); // Use TransportDestroySelfNow!",
          "907: }",
          "909: void CConnectionTransportUDP::TransportFreeResources()",
          "910: {",
          "911:  CConnectionTransport::TransportFreeResources();",
          "913:  if ( m_pSocket )",
          "914:  {",
          "915:   m_pSocket->Close();",
          "916:   m_pSocket = nullptr;",
          "917:  }",
          "918: }",
          "920: void CSteamNetworkConnectionUDP::GetConnectionTypeDescription( ConnectionTypeDescription_t &szDescription ) const",
          "921: {",
          "922:  char szAddr[ 64 ];",
          "923:  if ( Transport() && Transport()->m_pSocket )",
          "924:  {",
          "925:   SteamNetworkingIPAddr adrRemote;",
          "926:   NetAdrToSteamNetworkingIPAddr( adrRemote, Transport()->m_pSocket->GetRemoteHostAddr() );",
          "927:   adrRemote.ToString( szAddr, sizeof(szAddr), true );",
          "928:   if (",
          "929:    m_identityRemote.IsLocalHost()",
          "930:    || ( m_identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress && adrRemote == m_identityRemote.m_ip )",
          "931:   ) {",
          "932:    V_sprintf_safe( szDescription, \"UDP %s\", szAddr );",
          "933:    return;",
          "934:   }",
          "935:  }",
          "936:  else",
          "937:  {",
          "938:   V_strcpy_safe( szAddr, \"???\" );",
          "939:  }",
          "941:  SteamNetworkingIdentityRender sIdentity( m_identityRemote );",
          "943:  V_sprintf_safe( szDescription, \"UDP %s@%s\", sIdentity.c_str(), szAddr );",
          "944: }",
          "946: void UDPSendPacketContext_t::Populate( size_t cbHdrtReserve, EStatsReplyRequest eReplyRequested, CSteamNetworkConnectionBase &connection )",
          "947: {",
          "948:  LinkStatsTracker<LinkStatsTrackerEndToEnd> &statsEndToEnd = connection.m_statsEndToEnd;",
          "951:  uint32 nFlags = 0;",
          "952:  int nReadyToSendTracer = 0;",
          "953:  if ( eReplyRequested == k_EStatsReplyRequest_Immediate || statsEndToEnd.BNeedToSendPingImmediate( m_usecNow ) )",
          "954:   nFlags |= msg.ACK_REQUEST_E2E | msg.ACK_REQUEST_IMMEDIATE;",
          "955:  else if ( eReplyRequested == k_EStatsReplyRequest_DelayedOK || statsEndToEnd.BNeedToSendKeepalive( m_usecNow ) )",
          "956:   nFlags |= msg.ACK_REQUEST_E2E;",
          "957:  else",
          "958:  {",
          "959:   nReadyToSendTracer = statsEndToEnd.ReadyToSendTracerPing( m_usecNow );",
          "960:   if ( nReadyToSendTracer > 1 )",
          "961:    nFlags |= msg.ACK_REQUEST_E2E;",
          "962:  }",
          "964:  m_nFlags = nFlags;",
          "967:  if ( statsEndToEnd.BNeedToSendStats( m_usecNow ) )",
          "968:  {",
          "969:   m_nStatsNeed = 2;",
          "970:   statsEndToEnd.PopulateMessage( *msg.mutable_stats(), m_usecNow );",
          "972:   if ( nReadyToSendTracer > 0 )",
          "973:    nFlags |= msg.ACK_REQUEST_E2E;",
          "975:   SlamFlagsAndCalcSize();",
          "976:   CalcMaxEncryptedPayloadSize( cbHdrtReserve, &connection );",
          "977:  }",
          "978:  else",
          "979:  {",
          "981:   SlamFlagsAndCalcSize();",
          "982:   CalcMaxEncryptedPayloadSize( cbHdrtReserve, &connection );",
          "985:   if ( statsEndToEnd.BReadyToSendStats( m_usecNow ) )",
          "986:   {",
          "987:    if ( nReadyToSendTracer > 0 )",
          "988:     nFlags |= msg.ACK_REQUEST_E2E;",
          "989:    statsEndToEnd.PopulateMessage( *msg.mutable_stats(), m_usecNow );",
          "990:    SlamFlagsAndCalcSize();",
          "991:    m_nStatsNeed = 1;",
          "992:   }",
          "993:   else",
          "994:   {",
          "996:    m_nStatsNeed = 0;",
          "997:   }",
          "998:  }",
          "999: }",
          "1001: void UDPSendPacketContext_t::Trim( int cbHdrOutSpaceRemaining )",
          "1002: {",
          "1003:  while ( m_cbTotalSize > cbHdrOutSpaceRemaining )",
          "1004:  {",
          "1006:   if ( msg.has_stats() )",
          "1007:   {",
          "1008:    AssertMsg( m_nStatsNeed == 1, \"We didn't reserve enough space for stats!\" );",
          "1009:    if ( msg.stats().has_instantaneous() && msg.stats().has_lifetime() )",
          "1010:    {",
          "1012:     msg.mutable_stats()->clear_instantaneous();",
          "1013:    }",
          "1014:    else",
          "1015:    {",
          "1017:     msg.clear_stats();",
          "1018:    }",
          "1020:    SlamFlagsAndCalcSize();",
          "1021:    continue;",
          "1022:   }",
          "1025:   AssertMsg( false, \"Serialized stats message still won't fit, ever after clearing everything?\" );",
          "1026:   m_cbTotalSize = 0;",
          "1027:   break;",
          "1028:  }",
          "1029: }",
          "1031: bool CConnectionTransportUDP::BConnect( const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )",
          "1032: {",
          "1041:  Assert( !m_pSocket );",
          "1042:  m_pSocket = OpenUDPSocketBoundToHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ), errMsg );",
          "1043:  if ( !m_pSocket )",
          "1044:   return false;",
          "1045:  return true;",
          "1046: }",
          "1048: bool CConnectionTransportUDP::BAccept( CSharedSocket *pSharedSock, const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )",
          "1049: {",
          "1051:  m_pSocket = pSharedSock->AddRemoteHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ) );",
          "1052:  if ( !m_pSocket )",
          "1053:  {",
          "1055:   V_strcpy_safe( errMsg, \"Unable to create a bound socket on the shared socket.\" );",
          "1056:   return false;",
          "1057:  }",
          "1059:  return true;",
          "1060: }",
          "1062: bool CConnectionTransportUDP::CreateLoopbackPair( CConnectionTransportUDP *pTransport[2] )",
          "1063: {",
          "1064:  IBoundUDPSocket *sock[2];",
          "1065:  SteamNetworkingErrMsg errMsg;",
          "1066:  if ( !CreateBoundSocketPair(",
          "1067:   CRecvPacketCallback( PacketReceived, pTransport[0] ),",
          "1068:   CRecvPacketCallback( PacketReceived, pTransport[1] ), sock, errMsg ) )",
          "1069:  {",
          "1071:   AssertMsg1( false, \"Failed to create UDP socket pair.  %s\", errMsg );",
          "1072:   return false;",
          "1073:  }",
          "1075:  pTransport[0]->m_pSocket = sock[0];",
          "1076:  pTransport[1]->m_pSocket = sock[1];",
          "1078:  return true;",
          "1079: }",
          "1081: bool CSteamNetworkConnectionUDP::BInitConnect( const SteamNetworkingIPAddr &addressRemote, int nOptions, const SteamNetworkingConfigValue_t *pOptions, SteamDatagramErrMsg &errMsg )",
          "1082: {",
          "1083:  AssertMsg( !m_pTransport, \"Trying to connect when we already have a socket?\" );",
          "1086:  Assert( !m_pParentListenSocket );",
          "1087:  Assert( !m_bConnectionInitiatedRemotely );",
          "1089:  netadr_t netadrRemote;",
          "1090:  SteamNetworkingIPAddrToNetAdr( netadrRemote, addressRemote );",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "885:  m_connection.m_statsEndToEnd.TrackSentPingRequest( usecNow, false );",
          "886: }",
          "893: void CSteamNetworkConnectionUDP::ThinkConnection( SteamNetworkingMicroseconds usecNow )",
          "894: {",
          "",
          "[Removed Lines]",
          "888: void CConnectionTransportUDP::SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason )",
          "889: {",
          "890:  SendStatsMsg( eRequest, usecNow, pszReason );",
          "891: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "991:  ConnectionState_Connected( usecNow );",
          "1034: }",
          "1037: {",
          "1038:  iovec temp;",
          "1039:  temp.iov_base = const_cast<void*>( pkt );",
          "1040:  temp.iov_len = cbPkt;",
          "1042: }",
          "1045: {",
          "1047:  if ( !m_pSocket )",
          "1048:  {",
          "1049:   AssertMsg( false, \"Attemt to send packet, but socket has been closed!\" );",
          "1051:  }",
          "1054:  m_connection.m_statsEndToEnd.TrackSentPacket( cbSendTotal );",
          "1058: }",
          "1060: void CConnectionTransportUDP::TransportConnectionStateChanged( ESteamNetworkingConnectionState eOldState )",
          "",
          "[Removed Lines]",
          "994:  return k_EResultOK;",
          "995: }",
          "997: void CConnectionTransportUDP::SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )",
          "998: {",
          "1000:  uint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];",
          "1001:  pkt[0] = nMsgID;",
          "1002:  int cbPkt = ProtoMsgByteSize( msg )+1;",
          "1003:  if ( cbPkt > sizeof(pkt) )",
          "1004:  {",
          "1005:   AssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( cbPkt ), (int)sizeof(pkt) );",
          "1006:   return;",
          "1007:  }",
          "1008:  uint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt+1 );",
          "1009:  Assert( cbPkt == pEnd - pkt );",
          "1011:  SendPacket( pkt, cbPkt );",
          "1012: }",
          "1014: void CConnectionTransportUDP::SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )",
          "1015: {",
          "1017:  uint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];",
          "1018:  V_memset( pkt, 0, sizeof(pkt) ); // don't send random bits from our process memory over the wire!",
          "1019:  UDPPaddedMessageHdr *hdr = (UDPPaddedMessageHdr *)pkt;",
          "1020:  int nMsgLength = ProtoMsgByteSize( msg );",
          "1021:  if ( nMsgLength + sizeof(*hdr) > k_cbSteamNetworkingSocketsMaxUDPMsgLen )",
          "1022:  {",
          "1023:   AssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( nMsgLength + sizeof(*hdr) ), (int)sizeof(pkt) );",
          "1024:   return;",
          "1025:  }",
          "1026:  hdr->m_nMsgID = nMsgID;",
          "1027:  hdr->m_nMsgLength = LittleWord( uint16( nMsgLength ) );",
          "1028:  uint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt + sizeof(*hdr) );",
          "1029:  int cbPkt = pEnd - pkt;",
          "1030:  Assert( cbPkt == int( sizeof(*hdr) + nMsgLength ) );",
          "1031:  cbPkt = MAX( cbPkt, k_cbSteamNetworkingMinPaddedPacketSize );",
          "1033:  SendPacket( pkt, cbPkt );",
          "1036: void CConnectionTransportUDP::SendPacket( const void *pkt, int cbPkt )",
          "1041:  SendPacketGather( 1, &temp, cbPkt );",
          "1044: void CConnectionTransportUDP::SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal )",
          "1050:   return;",
          "1057:  m_pSocket->BSendRawPacketGather( nChunks, pChunks );",
          "",
          "[Added Lines]",
          "1272:  return k_EResultOK;",
          "1275: bool CConnectionTransportUDP::SendPacket( const void *pkt, int cbPkt )",
          "1280:  return SendPacketGather( 1, &temp, cbPkt );",
          "1283: bool CConnectionTransportUDP::SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal )",
          "1289:   return false;",
          "1296:  return m_pSocket->BSendRawPacketGather( nChunks, pChunks );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1102:  }",
          "1103: }",
          "1108: void CConnectionTransportUDP::PacketReceived( const void *pvPkt, int cbPkt, const netadr_t &adrFrom, CConnectionTransportUDP *pSelf )",
          "1109: {",
          "1110:  const uint8 *pPkt = static_cast<const uint8 *>( pvPkt );",
          "",
          "[Removed Lines]",
          "1105: #define ReportBadPacketFromSocketPeer( pszMsgType, /* fmt */ ... ) \\",
          "1106:  ReportBadPacketFrom( m_pSocket->GetRemoteHostAddr(), pszMsgType, __VA_ARGS__ )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1163:  }",
          "1164: }",
          "1349: void CConnectionTransportUDP::Received_ChallengeReply( const CMsgSteamSockets_UDP_ChallengeReply &msg, SteamNetworkingMicroseconds usecNow )",
          "1350: {",
          "1352:  if ( ListenSocket() )",
          "1353:  {",
          "1355:   return;",
          "1356:  }",
          "",
          "[Removed Lines]",
          "1166: std::string DescribeStatsContents( const CMsgSteamSockets_UDP_Stats &msg )",
          "1167: {",
          "1168:  std::string sWhat;",
          "1169:  if ( msg.flags() & msg.ACK_REQUEST_E2E )",
          "1170:   sWhat += \" request_ack\";",
          "1171:  if ( msg.flags() & msg.ACK_REQUEST_IMMEDIATE )",
          "1172:   sWhat += \" request_ack_immediate\";",
          "1173:  if ( msg.stats().has_lifetime() )",
          "1174:   sWhat += \" stats.life\";",
          "1175:  if ( msg.stats().has_instantaneous() )",
          "1176:   sWhat += \" stats.rate\";",
          "1177:  return sWhat;",
          "1178: }",
          "1180: void CConnectionTransportUDP::RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, bool bInline, SteamNetworkingMicroseconds usecNow )",
          "1181: {",
          "1184:  if ( msgStatsIn.has_stats() )",
          "1185:   m_connection.m_statsEndToEnd.ProcessMessage( msgStatsIn.stats(), usecNow );",
          "1188:  SpewVerbose( \"[%s] Recv %s stats:%s\\n\",",
          "1189:   ConnectionDescription(),",
          "1190:   bInline ? \"inline\" : \"standalone\",",
          "1191:   DescribeStatsContents( msgStatsIn ).c_str()",
          "1192:  );",
          "1195:  if ( m_connection.BStateIsConnectedForWirePurposes() )",
          "1196:  {",
          "1199:   bool bImmediate = ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_IMMEDIATE ) != 0;",
          "1200:   if ( ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_E2E ) || msgStatsIn.has_stats() )",
          "1201:   {",
          "1202:    m_connection.QueueEndToEndAck( bImmediate, usecNow );",
          "1203:   }",
          "1206:   const char *pszReason = m_connection.NeedToSendEndToEndStatsOrAcks( usecNow );",
          "1207:   if ( pszReason )",
          "1208:   {",
          "1210:    SendStatsMsg( k_EStatsReplyRequest_NothingToSend, usecNow, pszReason );",
          "1211:   }",
          "1212:  }",
          "1213: }",
          "1215: void CConnectionTransportUDP::TrackSentStats( const CMsgSteamSockets_UDP_Stats &msgStatsOut, bool bInline, SteamNetworkingMicroseconds usecNow )",
          "1216: {",
          "1219:  bool bAllowDelayedReply = ( msgStatsOut.flags() & msgStatsOut.ACK_REQUEST_IMMEDIATE ) == 0;",
          "1222:  if ( msgStatsOut.has_stats() )",
          "1223:  {",
          "1224:   m_connection.m_statsEndToEnd.TrackSentStats( msgStatsOut.stats(), usecNow, bAllowDelayedReply );",
          "1225:  }",
          "1226:  else if ( msgStatsOut.flags() & msgStatsOut.ACK_REQUEST_E2E )",
          "1227:  {",
          "1228:   m_connection.m_statsEndToEnd.TrackSentMessageExpectingSeqNumAck( usecNow, bAllowDelayedReply );",
          "1229:  }",
          "1232:  SpewVerbose( \"[%s] Sent %s stats:%s\\n\",",
          "1233:   ConnectionDescription(),",
          "1234:   bInline ? \"inline\" : \"standalone\",",
          "1235:   DescribeStatsContents( msgStatsOut ).c_str()",
          "1236:  );",
          "1237: }",
          "1239: void CConnectionTransportUDP::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )",
          "1240: {",
          "1242:  if ( cbPkt < sizeof(UDPDataMsgHdr) )",
          "1243:  {",
          "1244:   ReportBadPacketFromSocketPeer( \"DataPacket\", \"Packet of size %d is too small.\", cbPkt );",
          "1245:   return;",
          "1246:  }",
          "1249:  const UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;",
          "1250:  if ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )",
          "1251:  {",
          "1254:   ReportBadPacketFromSocketPeer( \"DataPacket\", \"Incorrect connection ID\" );",
          "1255:   if ( BCheckGlobalSpamReplyRateLimit( usecNow ) )",
          "1256:   {",
          "1257:    SendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );",
          "1258:   }",
          "1259:   return;",
          "1260:  }",
          "1261:  uint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );",
          "1264:  switch ( ConnectionState() )",
          "1265:  {",
          "1266:   case k_ESteamNetworkingConnectionState_Dead:",
          "1267:   case k_ESteamNetworkingConnectionState_None:",
          "1268:   case k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP",
          "1269:   default:",
          "1270:    Assert( false );",
          "1271:    return;",
          "1273:   case k_ESteamNetworkingConnectionState_ClosedByPeer:",
          "1274:   case k_ESteamNetworkingConnectionState_FinWait:",
          "1275:   case k_ESteamNetworkingConnectionState_ProblemDetectedLocally:",
          "1276:    SendConnectionClosedOrNoConnection();",
          "1277:    return;",
          "1279:   case k_ESteamNetworkingConnectionState_Connecting:",
          "1284:    return;",
          "1286:   case k_ESteamNetworkingConnectionState_Linger:",
          "1287:   case k_ESteamNetworkingConnectionState_Connected:",
          "1290:    break;",
          "1291:  }",
          "1293:  const uint8 *pIn = pPkt + sizeof(*hdr);",
          "1294:  const uint8 *pPktEnd = pPkt + cbPkt;",
          "1297:  static CMsgSteamSockets_UDP_Stats msgStats;",
          "1298:  CMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;",
          "1299:  uint32 cbStatsMsgIn = 0;",
          "1300:  if ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )",
          "1301:  {",
          "1304:   pIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );",
          "1305:   if ( pIn == NULL )",
          "1306:   {",
          "1307:    ReportBadPacketFromSocketPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );",
          "1308:    return;",
          "1309:   }",
          "1310:   if ( pIn + cbStatsMsgIn > pPktEnd )",
          "1311:   {",
          "1312:    ReportBadPacketFromSocketPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );",
          "1313:    return;",
          "1314:   }",
          "1316:   if ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )",
          "1317:   {",
          "1318:    ReportBadPacketFromSocketPeer( \"DataPacket\", \"protobuf failed to parse inline stats message\" );",
          "1319:    return;",
          "1320:   }",
          "1323:   pMsgStatsIn = &msgStats;",
          "1326:   pIn += cbStatsMsgIn;",
          "1327:  }",
          "1329:  const void *pChunk = pIn;",
          "1330:  int cbChunk = pPktEnd - pIn;",
          "1333:  uint8 tempDecrypted[ k_cbSteamNetworkingSocketsMaxPlaintextPayloadRecv ];",
          "1334:  void *pDecrypted = tempDecrypted;",
          "1335:  uint32 cbDecrypted = sizeof(tempDecrypted);",
          "1336:  int64 nFullSequenceNumber = m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, pDecrypted, cbDecrypted, usecNow );",
          "1337:  if ( nFullSequenceNumber <= 0 )",
          "1338:   return;",
          "1341:  if ( !m_connection.ProcessPlainTextDataChunk( nFullSequenceNumber, pDecrypted, cbDecrypted, 0, usecNow ) )",
          "1342:   return;",
          "1345:  if ( pMsgStatsIn )",
          "1346:   RecvStats( *pMsgStatsIn, true, usecNow );",
          "1347: }",
          "1354:   ReportBadPacketFromSocketPeer( \"ChallengeReply\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );",
          "",
          "[Added Lines]",
          "1407:   ReportBadUDPPacketFromConnectionPeer( \"ChallengeReply\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1363:  if ( msg.connection_id() != ConnectionIDLocal() )",
          "1364:  {",
          "1366:   return;",
          "1367:  }",
          "1368:  if ( msg.protocol_version() < k_nMinRequiredProtocolVersion )",
          "",
          "[Removed Lines]",
          "1365:   ReportBadPacketFromSocketPeer( \"ChallengeReply\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );",
          "",
          "[Added Lines]",
          "1418:   ReportBadUDPPacketFromConnectionPeer( \"ChallengeReply\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1438:  if ( ListenSocket() )",
          "1439:  {",
          "1441:   return;",
          "1442:  }",
          "1445:  if ( msg.client_connection_id() != ConnectionIDLocal() )",
          "1446:  {",
          "1448:   return;",
          "1449:  }",
          "",
          "[Removed Lines]",
          "1440:   ReportBadPacketFromSocketPeer( \"ConnectOK\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );",
          "1447:   ReportBadPacketFromSocketPeer( \"ConnectOK\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );",
          "",
          "[Added Lines]",
          "1493:   ReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );",
          "1500:   ReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1458:   int r = SteamNetworkingIdentityFromSignedCert( identityRemote, msg.cert(), errMsg );",
          "1459:   if ( r < 0 )",
          "1460:   {",
          "1462:    return;",
          "1463:   }",
          "1464:   if ( r == 0 )",
          "",
          "[Removed Lines]",
          "1461:    ReportBadPacketFromSocketPeer( \"ConnectRequest\", \"Bad identity in cert.  %s\", errMsg );",
          "",
          "[Added Lines]",
          "1514:    ReportBadUDPPacketFromConnectionPeer( \"ConnectRequest\", \"Bad identity in cert.  %s\", errMsg );",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1468:    r = SteamNetworkingIdentityFromProtobuf( identityRemote, msg, identity_string, legacy_identity_binary, legacy_server_steam_id, errMsg );",
          "1469:    if ( r < 0 )",
          "1470:    {",
          "1472:     return;",
          "1473:    }",
          "1474:    if ( r == 0 )",
          "",
          "[Removed Lines]",
          "1471:     ReportBadPacketFromSocketPeer( \"ConnectRequest\", \"Bad identity.  %s\", errMsg );",
          "",
          "[Added Lines]",
          "1524:     ReportBadUDPPacketFromConnectionPeer( \"ConnectRequest\", \"Bad identity.  %s\", errMsg );",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1493:    if ( m_connection.m_connectionConfig.m_IP_AllowWithoutAuth.Get() == 0 )",
          "1494:    {",
          "1497:     return;",
          "1498:    }",
          "",
          "[Removed Lines]",
          "1496:     ReportBadPacketFromSocketPeer( \"ConnectOK\", \"Unauthenticated connections not allowed.\" );",
          "",
          "[Added Lines]",
          "1549:     ReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Unauthenticated connections not allowed.\" );",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1530:  if ( !m_connection.m_identityRemote.IsInvalid() && !( m_connection.m_identityRemote == identityRemote ) )",
          "1531:  {",
          "1533:   return;",
          "1534:  }",
          "",
          "[Removed Lines]",
          "1532:   ReportBadPacketFromSocketPeer( \"ConnectOK\", \"server_steam_id doesn't match who we expect to be connecting to!\" );",
          "",
          "[Added Lines]",
          "1585:   ReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"server_steam_id doesn't match who we expect to be connecting to!\" );",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1588:  if ( !m_connection.BRecvCryptoHandshake( msg.cert(), msg.crypt(), false ) )",
          "1589:  {",
          "1590:   Assert( ConnectionState() == k_ESteamNetworkingConnectionState_ProblemDetectedLocally );",
          "1592:   return;",
          "1593:  }",
          "",
          "[Removed Lines]",
          "1591:   ReportBadPacketFromSocketPeer( \"ConnectOK\", \"Failed crypto init.  %s\", m_connection.m_szEndDebug );",
          "",
          "[Added Lines]",
          "1644:   ReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Failed crypto init.  %s\", m_connection.m_szEndDebug );",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1596:  m_connection.ConnectionState_Connected( usecNow );",
          "1597: }",
          "1644: void CConnectionTransportUDP::Received_ChallengeOrConnectRequest( const char *pszDebugPacketType, uint32 unPacketConnectionID, SteamNetworkingMicroseconds usecNow )",
          "1645: {",
          "1647:  if ( unPacketConnectionID != m_connection.m_unConnectionIDRemote )",
          "1648:  {",
          "",
          "[Removed Lines]",
          "1599: void CConnectionTransportUDP::Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow )",
          "1600: {",
          "1608:  bool bConnectionIDMatch =",
          "1609:   msg.to_connection_id() == ConnectionIDLocal()",
          "1610:   || ( msg.to_connection_id() == 0 && msg.from_connection_id() && msg.from_connection_id() == m_connection.m_unConnectionIDRemote ); // they might not know our ID yet, if they are a client aborting the connection really early.",
          "1611:  if ( bConnectionIDMatch || BCheckGlobalSpamReplyRateLimit( usecNow ) )",
          "1612:  {",
          "1614:   CMsgSteamSockets_UDP_NoConnection msgReply;",
          "1615:   if ( msg.to_connection_id() )",
          "1616:    msgReply.set_from_connection_id( msg.to_connection_id() );",
          "1617:   if ( msg.from_connection_id() )",
          "1618:    msgReply.set_to_connection_id( msg.from_connection_id() );",
          "1619:   SendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msgReply );",
          "1620:  }",
          "1624:  if ( !bConnectionIDMatch )",
          "1625:   return;",
          "1628:  m_connection.ConnectionState_ClosedByPeer( msg.reason_code(), msg.debug().c_str() );",
          "1629: }",
          "1631: void CConnectionTransportUDP::Received_NoConnection( const CMsgSteamSockets_UDP_NoConnection &msg, SteamNetworkingMicroseconds usecNow )",
          "1632: {",
          "1634:  if ( msg.to_connection_id() != ConnectionIDLocal() || msg.from_connection_id() != m_connection.m_unConnectionIDRemote )",
          "1635:  {",
          "1636:   ReportBadPacketFromSocketPeer( \"NoConnection\", \"Old/incorrect connection ID.  Message is for a stale connection, or is spoofed.  Ignoring.\" );",
          "1637:   return;",
          "1638:  }",
          "1641:  m_connection.ConnectionState_ClosedByPeer( 0, nullptr );",
          "1642: }",
          "1649:   ReportBadPacketFromSocketPeer( pszDebugPacketType, \"Incorrect connection ID, when we do have a connection for this address.  Could be spoofed, ignoring.\" );",
          "",
          "[Added Lines]",
          "1657:   ReportBadUDPPacketFromConnectionPeer( pszDebugPacketType, \"Incorrect connection ID, when we do have a connection for this address.  Could be spoofed, ignoring.\" );",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1678:    if ( !ListenSocket() )",
          "1679:    {",
          "1682:     return;",
          "1683:    }",
          "",
          "[Removed Lines]",
          "1681:     ReportBadPacketFromSocketPeer( pszDebugPacketType, \"We are the 'client' who initiated the connection, so 'server' shouldn't be sending us this!\" );",
          "",
          "[Added Lines]",
          "1689:     ReportBadUDPPacketFromConnectionPeer( pszDebugPacketType, \"We are the 'client' who initiated the connection, so 'server' shouldn't be sending us this!\" );",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1690: }",
          "1728: void CConnectionTransportUDP::SendConnectOK( SteamNetworkingMicroseconds usecNow )",
          "1729: {",
          "1730:  Assert( ConnectionIDLocal() );",
          "",
          "[Removed Lines]",
          "1692: void CConnectionTransportUDP::SendConnectionClosedOrNoConnection()",
          "1693: {",
          "1694:  if ( ConnectionState() == k_ESteamNetworkingConnectionState_ClosedByPeer )",
          "1695:  {",
          "1696:   SendNoConnection( ConnectionIDLocal(), ConnectionIDRemote() );",
          "1697:  }",
          "1698:  else",
          "1699:  {",
          "1700:   CMsgSteamSockets_UDP_ConnectionClosed msg;",
          "1701:   msg.set_from_connection_id( ConnectionIDLocal() );",
          "1703:   if ( ConnectionIDRemote() )",
          "1704:    msg.set_to_connection_id( ConnectionIDRemote() );",
          "1706:   msg.set_reason_code( m_connection.m_eEndReason );",
          "1707:   if ( m_connection.m_szEndDebug[0] )",
          "1708:    msg.set_debug( m_connection.m_szEndDebug );",
          "1709:   SendPaddedMsg( k_ESteamNetworkingUDPMsg_ConnectionClosed, msg );",
          "1710:  }",
          "1711: }",
          "1713: void CConnectionTransportUDP::SendNoConnection( uint32 unFromConnectionID, uint32 unToConnectionID )",
          "1714: {",
          "1715:  CMsgSteamSockets_UDP_NoConnection msg;",
          "1716:  if ( unFromConnectionID == 0 && unToConnectionID == 0 )",
          "1717:  {",
          "1718:   AssertMsg( false, \"Can't send NoConnection, we need at least one of from/to connection ID!\" );",
          "1719:   return;",
          "1720:  }",
          "1721:  if ( unFromConnectionID )",
          "1722:   msg.set_from_connection_id( unFromConnectionID );",
          "1723:  if ( unToConnectionID )",
          "1724:   msg.set_to_connection_id( unToConnectionID );",
          "1725:  SendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msg );",
          "1726: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.h": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.h -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: namespace SteamNetworkingSocketsLib {",
          "12: template<>",
          "13: inline uint32 StatsMsgImpliedFlags<CMsgSteamSockets_UDP_Stats>( const CMsgSteamSockets_UDP_Stats &msg )",
          "14: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #pragma pack( push, 1 )",
          "14: const int k_cbSteamNetworkingMinPaddedPacketSize = 512;",
          "17: struct UDPPaddedMessageHdr",
          "18: {",
          "19:  uint8 m_nMsgID;",
          "20:  uint16 m_nMsgLength;",
          "21: };",
          "23: struct UDPDataMsgHdr",
          "24: {",
          "25:  enum",
          "26:  {",
          "27:   kFlag_ProtobufBlob  = 0x01, // Protobuf-encoded message is inline (CMsgSteamSockets_UDP_Stats)",
          "28:  };",
          "30:  uint8 m_unMsgFlags;",
          "31:  uint32 m_unToConnectionID; // Recipient's portion of the connection ID",
          "32:  uint16 m_unSeqNum;",
          "37: };",
          "38: #pragma pack( pop )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: extern std::string DescribeStatsContents( const CMsgSteamSockets_UDP_Stats &msg );",
          "30: extern bool BCheckRateLimitReportBadPacket( SteamNetworkingMicroseconds usecNow );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: extern void ReallyReportBadUDPPacket( const char *pszFrom, const char *pszMsgType, const char *pszFmt, ... );",
          "61: #define ReportBadUDPPacketFrom( pszFrom, pszMsgType, /* fmt */ ... ) \\",
          "62:  ( BCheckRateLimitReportBadPacket( usecNow ) ? ReallyReportBadUDPPacket( pszFrom, pszMsgType, __VA_ARGS__ ) : (void)0 )",
          "64: #define ReportBadUDPPacketFromConnectionPeer( pszMsgType, /* fmt */ ... ) \\",
          "65:  ReportBadUDPPacketFrom( ConnectionDescription(), pszMsgType, __VA_ARGS__ )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78: class CSteamNetworkConnectionUDP;",
          "82: {",
          "83: public:",
          "88:  virtual bool SendDataPacket( SteamNetworkingMicroseconds usecNow ) override;",
          "89:  virtual int SendEncryptedDataChunk( const void *pChunk, int cbChunk, SendPacketContext_t &ctx ) override;",
          "90:  virtual bool BCanSendEndToEndConnectRequest() const override;",
          "91:  virtual bool BCanSendEndToEndData() const override;",
          "92:  virtual void SendEndToEndConnectRequest( SteamNetworkingMicroseconds usecNow ) override;",
          "94:  virtual void TransportConnectionStateChanged( ESteamNetworkingConnectionState eOldState ) override;",
          "95:  virtual void TransportPopulateConnectionInfo( SteamNetConnectionInfo_t &info ) const override;",
          "",
          "[Removed Lines]",
          "81: class CConnectionTransportUDP final : public CConnectionTransport",
          "84:  CConnectionTransportUDP( CSteamNetworkConnectionUDP &connection );",
          "87:  virtual void TransportFreeResources() override;",
          "93:  virtual void SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason ) override;",
          "",
          "[Added Lines]",
          "117: class CConnectionTransportUDPBase : public CConnectionTransport",
          "120:  CConnectionTransportUDPBase( CSteamNetworkConnectionBase &connection );",
          "125:  virtual void SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason ) override;",
          "127: protected:",
          "128:  void Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow );",
          "129:  void Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow );",
          "130:  void Received_NoConnection( const CMsgSteamSockets_UDP_NoConnection &msg, SteamNetworkingMicroseconds usecNow );",
          "132:  void SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg );",
          "133:  void SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg );",
          "134:  void SendConnectionClosedOrNoConnection();",
          "135:  void SendNoConnection( uint32 unFromConnectionID, uint32 unToConnectionID );",
          "137:  virtual bool SendPacket( const void *pkt, int cbPkt ) = 0;",
          "138:  virtual bool SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal ) = 0;",
          "141:  void RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, bool bInline, SteamNetworkingMicroseconds usecNow );",
          "142:  void SendStatsMsg( EStatsReplyRequest eReplyRequested, SteamNetworkingMicroseconds usecNow, const char *pszReason );",
          "143:  void TrackSentStats( const CMsgSteamSockets_UDP_Stats &msgStatsOut, bool bInline, SteamNetworkingMicroseconds usecNow );",
          "144: };",
          "148: class CConnectionTransportUDP final : public CConnectionTransportUDPBase",
          "149: {",
          "150: public:",
          "151:  CConnectionTransportUDP( CSteamNetworkConnectionUDP &connection );",
          "154:  virtual void TransportFreeResources() override;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "110:  static void PacketReceived( const void *pPkt, int cbPkt, const netadr_t &adrFrom, CConnectionTransportUDP *pSelf );",
          "113:  void Received_ChallengeReply( const CMsgSteamSockets_UDP_ChallengeReply &msg, SteamNetworkingMicroseconds usecNow );",
          "114:  void Received_ConnectOK( const CMsgSteamSockets_UDP_ConnectOK &msg, SteamNetworkingMicroseconds usecNow );",
          "117:  void Received_ChallengeOrConnectRequest( const char *pszDebugPacketType, uint32 unPacketConnectionID, SteamNetworkingMicroseconds usecNow );",
          "131: };",
          "",
          "[Removed Lines]",
          "112:  void Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow );",
          "115:  void Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow );",
          "116:  void Received_NoConnection( const CMsgSteamSockets_UDP_NoConnection &msg, SteamNetworkingMicroseconds usecNow );",
          "119:  void SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg );",
          "120:  void SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg );",
          "121:  void SendPacket( const void *pkt, int cbPkt );",
          "122:  void SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal );",
          "124:  void SendConnectionClosedOrNoConnection();",
          "125:  void SendNoConnection( uint32 unFromConnectionID, uint32 unToConnectionID );",
          "128:  void RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, bool bInline, SteamNetworkingMicroseconds usecNow );",
          "129:  void SendStatsMsg( EStatsReplyRequest eReplyRequested, SteamNetworkingMicroseconds usecNow, const char *pszReason );",
          "130:  void TrackSentStats( const CMsgSteamSockets_UDP_Stats &msgStatsOut, bool bInline, SteamNetworkingMicroseconds usecNow );",
          "",
          "[Added Lines]",
          "181:  virtual bool SendPacket( const void *pkt, int cbPkt ) override;",
          "182:  virtual bool SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal ) override;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
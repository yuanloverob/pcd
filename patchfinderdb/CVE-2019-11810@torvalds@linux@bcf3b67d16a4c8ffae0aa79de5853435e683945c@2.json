{
  "cve_id": "CVE-2019-11810",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.0.7. A NULL pointer dereference can occur when megasas_create_frame_pool() fails in megasas_alloc_cmds() in drivers/scsi/megaraid/megaraid_sas_base.c. This causes a Denial of Service, related to a use-after-free.",
  "repo": "torvalds/linux",
  "patch_hash": "bcf3b67d16a4c8ffae0aa79de5853435e683945c",
  "patch_info": {
    "commit_hash": "bcf3b67d16a4c8ffae0aa79de5853435e683945c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
    "files": [
      "drivers/scsi/megaraid/megaraid_sas_base.c"
    ],
    "message": "scsi: megaraid_sas: return error when create DMA pool failed\n\nwhen create DMA pool for cmd frames failed, we should return -ENOMEM,\ninstead of 0.\nIn some case in:\n\n    megasas_init_adapter_fusion()\n\n    -->megasas_alloc_cmds()\n       -->megasas_create_frame_pool\n          create DMA pool failed,\n        --> megasas_free_cmds() [1]\n\n    -->megasas_alloc_cmds_fusion()\n       failed, then goto fail_alloc_cmds.\n    -->megasas_free_cmds() [2]\n\nwe will call megasas_free_cmds twice, [1] will kfree cmd_list,\n[2] will use cmd_list.it will cause a problem:\n\nUnable to handle kernel NULL pointer dereference at virtual address\n00000000\npgd = ffffffc000f70000\n[00000000] *pgd=0000001fbf893003, *pud=0000001fbf893003,\n*pmd=0000001fbf894003, *pte=006000006d000707\nInternal error: Oops: 96000005 [#1] SMP\n Modules linked in:\n CPU: 18 PID: 1 Comm: swapper/0 Not tainted\n task: ffffffdfb9290000 ti: ffffffdfb923c000 task.ti: ffffffdfb923c000\n PC is at megasas_free_cmds+0x30/0x70\n LR is at megasas_free_cmds+0x24/0x70\n ...\n Call trace:\n [<ffffffc0005b779c>] megasas_free_cmds+0x30/0x70\n [<ffffffc0005bca74>] megasas_init_adapter_fusion+0x2f4/0x4d8\n [<ffffffc0005b926c>] megasas_init_fw+0x2dc/0x760\n [<ffffffc0005b9ab0>] megasas_probe_one+0x3c0/0xcd8\n [<ffffffc0004a5abc>] local_pci_probe+0x4c/0xb4\n [<ffffffc0004a5c40>] pci_device_probe+0x11c/0x14c\n [<ffffffc00053a5e4>] driver_probe_device+0x1ec/0x430\n [<ffffffc00053a92c>] __driver_attach+0xa8/0xb0\n [<ffffffc000538178>] bus_for_each_dev+0x74/0xc8\n  [<ffffffc000539e88>] driver_attach+0x28/0x34\n [<ffffffc000539a18>] bus_add_driver+0x16c/0x248\n [<ffffffc00053b234>] driver_register+0x6c/0x138\n [<ffffffc0004a5350>] __pci_register_driver+0x5c/0x6c\n [<ffffffc000ce3868>] megasas_init+0xc0/0x1a8\n [<ffffffc000082a58>] do_one_initcall+0xe8/0x1ec\n [<ffffffc000ca7be8>] kernel_init_freeable+0x1c8/0x284\n [<ffffffc0008d90b8>] kernel_init+0x1c/0xe4\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nAcked-by: Sumit Saxena <sumit.saxena@broadcom.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "before_after_code_files": [
      "drivers/scsi/megaraid/megaraid_sas_base.c||drivers/scsi/megaraid/megaraid_sas_base.c"
    ]
  },
  "patch_diff": {
    "drivers/scsi/megaraid/megaraid_sas_base.c||drivers/scsi/megaraid/megaraid_sas_base.c": [
      "File: drivers/scsi/megaraid/megaraid_sas_base.c -> drivers/scsi/megaraid/megaraid_sas_base.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4188:  if (megasas_create_frame_pool(instance)) {",
      "4189:   dev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");",
      "4190:   megasas_free_cmds(instance);",
      "4191:  }",
      "4193:  return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4191:   return -ENOMEM;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9cfef55bb57e7620c63087be18a76351628f8d0f",
      "candidate_info": {
        "commit_hash": "9cfef55bb57e7620c63087be18a76351628f8d0f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9cfef55bb57e7620c63087be18a76351628f8d0f",
        "files": [
          "drivers/nvme/host/pci.c",
          "include/linux/interrupt.h",
          "kernel/irq/affinity.c"
        ],
        "message": "genirq/affinity: Store interrupt sets size in struct irq_affinity\n\nThe interrupt affinity spreading mechanism supports to spread out\naffinities for one or more interrupt sets. A interrupt set contains one\nor more interrupts. Each set is mapped to a specific functionality of a\ndevice, e.g. general I/O queues and read I/O queus of multiqueue block\ndevices.\n\nThe number of interrupts per set is defined by the driver. It depends on\nthe total number of available interrupts for the device, which is\ndetermined by the PCI capabilites and the availability of underlying CPU\nresources, and the number of queues which the device provides and the\ndriver wants to instantiate.\n\nThe driver passes initial configuration for the interrupt allocation via\na pointer to struct irq_affinity.\n\nRight now the allocation mechanism is complex as it requires to have a\nloop in the driver to determine the maximum number of interrupts which\nare provided by the PCI capabilities and the underlying CPU resources.\nThis loop would have to be replicated in every driver which wants to\nutilize this mechanism. That's unwanted code duplication and error\nprone.\n\nIn order to move this into generic facilities it is required to have a\nmechanism, which allows the recalculation of the interrupt sets and\ntheir size, in the core code. As the core code does not have any\nknowledge about the underlying device, a driver specific callback will\nbe added to struct affinity_desc, which will be invoked by the core\ncode. The callback will get the number of available interupts as an\nargument, so the driver can calculate the corresponding number and size\nof interrupt sets.\n\nTo support this, two modifications for the handling of struct irq_affinity\nare required:\n\n1) The (optional) interrupt sets size information is contained in a\n   separate array of integers and struct irq_affinity contains a\n   pointer to it.\n\n   This is cumbersome and as the maximum number of interrupt sets is small,\n   there is no reason to have separate storage. Moving the size array into\n   struct affinity_desc avoids indirections and makes the code simpler.\n\n2) At the moment the struct irq_affinity pointer which is handed in from\n   the driver and passed through to several core functions is marked\n   'const'.\n\n   With the upcoming callback to recalculate the number and size of\n   interrupt sets, it's necessary to remove the 'const'\n   qualifier. Otherwise the callback would not be able to update the data.\n\nImplement #1 and store the interrupt sets size in 'struct irq_affinity'.\n\nNo functional change.\n\n[ tglx: Fixed the memcpy() size so it won't copy beyond the size of the\n  \tsource. Fixed the kernel doc comments for struct irq_affinity and\n  \tde-'This patch'-ed the changelog ]\n\nSigned-off-by: Ming Lei <ming.lei@redhat.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nAcked-by: Marc Zyngier <marc.zyngier@arm.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Bjorn Helgaas <helgaas@kernel.org>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: linux-block@vger.kernel.org\nCc: Sagi Grimberg <sagi@grimberg.me>\nCc: linux-nvme@lists.infradead.org\nCc: linux-pci@vger.kernel.org\nCc: Keith Busch <keith.busch@intel.com>\nCc: Sumit Saxena <sumit.saxena@broadcom.com>\nCc: Kashyap Desai <kashyap.desai@broadcom.com>\nCc: Shivasharan Srikanteshwara <shivasharan.srikanteshwara@broadcom.com>\nLink: https://lkml.kernel.org/r/20190216172228.423723127@linutronix.de",
        "before_after_code_files": [
          "drivers/nvme/host/pci.c||drivers/nvme/host/pci.c",
          "include/linux/interrupt.h||include/linux/interrupt.h",
          "kernel/irq/affinity.c||kernel/irq/affinity.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/nvme/host/pci.c||drivers/nvme/host/pci.c": [
          "File: drivers/nvme/host/pci.c -> drivers/nvme/host/pci.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2081: static int nvme_setup_irqs(struct nvme_dev *dev, unsigned int nr_io_queues)",
          "2082: {",
          "2083:  struct pci_dev *pdev = to_pci_dev(dev->dev);",
          "2085:  struct irq_affinity affd = {",
          "2089:  };",
          "2090:  int result = 0;",
          "2091:  unsigned int irq_queues, this_p_queues;",
          "",
          "[Removed Lines]",
          "2084:  int irq_sets[2];",
          "2086:   .pre_vectors = 1,",
          "2087:   .nr_sets = ARRAY_SIZE(irq_sets),",
          "2088:   .sets = irq_sets,",
          "",
          "[Added Lines]",
          "2085:   .pre_vectors = 1,",
          "2086:   .nr_sets = 2,",
          "2088:  unsigned int *irq_sets = affd.set_size;",
          "",
          "---------------"
        ],
        "include/linux/interrupt.h||include/linux/interrupt.h": [
          "File: include/linux/interrupt.h -> include/linux/interrupt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:  void (*release)(struct kref *ref);",
          "242: };",
          "253: struct irq_affinity {",
          "254:  unsigned int pre_vectors;",
          "255:  unsigned int post_vectors;",
          "256:  unsigned int nr_sets;",
          "258: };",
          "",
          "[Removed Lines]",
          "257:  unsigned int *sets;",
          "",
          "[Added Lines]",
          "244: #define IRQ_AFFINITY_MAX_SETS  4",
          "260:  unsigned int set_size[IRQ_AFFINITY_MAX_SETS];",
          "",
          "---------------"
        ],
        "kernel/irq/affinity.c||kernel/irq/affinity.c": [
          "File: kernel/irq/affinity.c -> kernel/irq/affinity.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "240: struct irq_affinity_desc *",
          "242: {",
          "243:  unsigned int affvecs, curvec, usedvecs, nr_sets, i;",
          "244:  struct irq_affinity_desc *masks = NULL;",
          "",
          "[Removed Lines]",
          "241: irq_create_affinity_masks(unsigned int nvecs, const struct irq_affinity *affd)",
          "",
          "[Added Lines]",
          "241: irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)",
          "244:  unsigned int set_size[IRQ_AFFINITY_MAX_SETS];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "250:  if (nvecs == affd->pre_vectors + affd->post_vectors)",
          "251:   return NULL;",
          "253:  masks = kcalloc(nvecs, sizeof(*masks), GFP_KERNEL);",
          "254:  if (!masks)",
          "255:   return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "254:  if (WARN_ON_ONCE(affd->nr_sets > IRQ_AFFINITY_MAX_SETS))",
          "255:   return NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "264:  affvecs = nvecs - affd->pre_vectors - affd->post_vectors;",
          "265:  nr_sets = affd->nr_sets;",
          "267:   nr_sets = 1;",
          "269:  for (i = 0, usedvecs = 0; i < nr_sets; i++) {",
          "271:   int ret;",
          "273:   ret = irq_build_affinity_masks(affd, curvec, this_vecs,",
          "",
          "[Removed Lines]",
          "266:  if (!nr_sets)",
          "270:   unsigned int this_vecs = affd->sets ? affd->sets[i] : affvecs;",
          "",
          "[Added Lines]",
          "270:  if (!nr_sets) {",
          "272:   set_size[0] = affvecs;",
          "273:  } else {",
          "274:   memcpy(set_size, affd->set_size, nr_sets * sizeof(unsigned int));",
          "275:  }",
          "278:   unsigned int this_vecs = set_size[i];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "314:   unsigned int i;",
          "316:   for (i = 0, set_vecs = 0;  i < affd->nr_sets; i++)",
          "318:  } else {",
          "319:   get_online_cpus();",
          "320:   set_vecs = cpumask_weight(cpu_possible_mask);",
          "",
          "[Removed Lines]",
          "317:    set_vecs += affd->sets[i];",
          "",
          "[Added Lines]",
          "325:    set_vecs += affd->set_size[i];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f5b27347e88b171c755562f0090ce40e514fc00",
      "candidate_info": {
        "commit_hash": "8f5b27347e88b171c755562f0090ce40e514fc00",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8f5b27347e88b171c755562f0090ce40e514fc00",
        "files": [
          "arch/powerpc/platforms/powernv/pci-ioda.c",
          "arch/powerpc/platforms/powernv/pci.c"
        ],
        "message": "powerpc/powernv/sriov: Register IOMMU groups for VFs\n\nThe compound IOMMU group rework moved iommu_register_group() together\nin pnv_pci_ioda_setup_iommu_api() (which is a part of\nppc_md.pcibios_fixup). As the result, pnv_ioda_setup_bus_iommu_group()\ndoes not create groups any more, it only adds devices to groups.\n\nThis works fine for boot time devices. However IOMMU groups for\nSRIOV's VFs were added by pnv_ioda_setup_bus_iommu_group() so this got\nbroken: pnv_tce_iommu_bus_notifier() expects a group to be registered\nfor VF and it is not.\n\nThis adds missing group registration and adds a NULL pointer check\ninto the bus notifier so we won't crash if there is no group, although\nit is not expected to happen now because of the change above.\n\nExample oops seen prior to this patch:\n\n  $ echo 1 > /sys/bus/pci/devices/0000\\:01\\:00.0/sriov_numvfs\n  Unable to handle kernel paging request for data at address 0x00000030\n  Faulting instruction address: 0xc0000000004a6018\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  LE SMP NR_CPUS=2048 NUMA PowerNV\n  CPU: 46 PID: 7006 Comm: bash Not tainted 4.15-ish\n  NIP:  c0000000004a6018 LR: c0000000004a6014 CTR: 0000000000000000\n  REGS: c000008fc876b400 TRAP: 0300   Not tainted  (4.15-ish)\n  MSR:  900000000280b033 <SF,HV,VEC,VSX,EE,FP,ME,IR,DR,RI,LE>\n  CFAR: c000000000d0be20 DAR: 0000000000000030 DSISR: 40000000 SOFTE: 1\n  ...\n  NIP sysfs_do_create_link_sd.isra.0+0x68/0x150\n  LR  sysfs_do_create_link_sd.isra.0+0x64/0x150\n  Call Trace:\n    pci_dev_type+0x0/0x30 (unreliable)\n    iommu_group_add_device+0x8c/0x600\n    iommu_add_device+0xe8/0x180\n    pnv_tce_iommu_bus_notifier+0xb0/0xf0\n    notifier_call_chain+0x9c/0x110\n    blocking_notifier_call_chain+0x64/0xa0\n    device_add+0x524/0x7d0\n    pci_device_add+0x248/0x450\n    pci_iov_add_virtfn+0x294/0x3e0\n    pci_enable_sriov+0x43c/0x580\n    mlx5_core_sriov_configure+0x15c/0x2f0 [mlx5_core]\n    sriov_numvfs_store+0x180/0x240\n    dev_attr_store+0x3c/0x60\n    sysfs_kf_write+0x64/0x90\n    kernfs_fop_write+0x1ac/0x240\n    __vfs_write+0x3c/0x70\n    vfs_write+0xd8/0x220\n    SyS_write+0x6c/0x110\n    system_call+0x58/0x6c\n\nFixes: 0bd971676e68 (\"powerpc/powernv/npu: Add compound IOMMU groups\")\nSigned-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nReported-by: Santwana Samantray <santwana.samantray@in.ibm.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>",
        "before_after_code_files": [
          "arch/powerpc/platforms/powernv/pci-ioda.c||arch/powerpc/platforms/powernv/pci-ioda.c",
          "arch/powerpc/platforms/powernv/pci.c||arch/powerpc/platforms/powernv/pci.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/platforms/powernv/pci-ioda.c||arch/powerpc/platforms/powernv/pci-ioda.c": [
          "File: arch/powerpc/platforms/powernv/pci-ioda.c -> arch/powerpc/platforms/powernv/pci-ioda.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1594:   pnv_pci_ioda2_setup_dma_pe(phb, pe);",
          "1595: #ifdef CONFIG_IOMMU_API",
          "1596:   pnv_ioda_setup_bus_iommu_group(pe, &pe->table_group, NULL);",
          "1597: #endif",
          "1598:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1596:   iommu_register_group(&pe->table_group,",
          "1597:     pe->phb->hose->global_number, pe->pe_number);",
          "",
          "---------------"
        ],
        "arch/powerpc/platforms/powernv/pci.c||arch/powerpc/platforms/powernv/pci.c": [
          "File: arch/powerpc/platforms/powernv/pci.c -> arch/powerpc/platforms/powernv/pci.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1147:    return 0;",
          "1149:   pe = &phb->ioda.pe_array[pdn->pe_number];",
          "1150:   iommu_add_device(&pe->table_group, dev);",
          "1151:   return 0;",
          "1152:  case BUS_NOTIFY_DEL_DEVICE:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1150:   if (!pe->table_group.group)",
          "1151:    return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b9c77583b0a242e02615b3c295d613e7fe4df415",
      "candidate_info": {
        "commit_hash": "b9c77583b0a242e02615b3c295d613e7fe4df415",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b9c77583b0a242e02615b3c295d613e7fe4df415",
        "files": [
          "drivers/nvme/host/core.c"
        ],
        "message": "nvme: avoid that deleting a controller triggers a circular locking complaint\n\nRework nvme_delete_ctrl_sync() such that it does not have to wait for\nqueued work. This patch avoids that test nvme/008 triggers the following\ncomplaint:\n\nWARNING: possible circular locking dependency detected\n5.0.0-rc6-dbg+ #10 Not tainted\n------------------------------------------------------\nnvme/7918 is trying to acquire lock:\n000000009a1a7b69 ((work_completion)(&ctrl->delete_work)){+.+.}, at: __flush_work+0x379/0x410\n\nbut task is already holding lock:\n00000000ef5a45b4 (kn->count#389){++++}, at: kernfs_remove_self+0x196/0x210\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (kn->count#389){++++}:\n       lock_acquire+0xc5/0x1e0\n       __kernfs_remove+0x42a/0x4a0\n       kernfs_remove_by_name_ns+0x45/0x90\n       remove_files.isra.1+0x3a/0x90\n       sysfs_remove_group+0x5c/0xc0\n       sysfs_remove_groups+0x39/0x60\n       device_remove_attrs+0x68/0xb0\n       device_del+0x24d/0x570\n       cdev_device_del+0x1a/0x50\n       nvme_delete_ctrl_work+0xbd/0xe0\n       process_one_work+0x4f1/0xa40\n       worker_thread+0x67/0x5b0\n       kthread+0x1cf/0x1f0\n       ret_from_fork+0x24/0x30\n\n-> #0 ((work_completion)(&ctrl->delete_work)){+.+.}:\n       __lock_acquire+0x1323/0x17b0\n       lock_acquire+0xc5/0x1e0\n       __flush_work+0x399/0x410\n       flush_work+0x10/0x20\n       nvme_delete_ctrl_sync+0x65/0x70\n       nvme_sysfs_delete+0x4f/0x60\n       dev_attr_store+0x3e/0x50\n       sysfs_kf_write+0x87/0xa0\n       kernfs_fop_write+0x186/0x240\n       __vfs_write+0xd7/0x430\n       vfs_write+0xfa/0x260\n       ksys_write+0xab/0x130\n       __x64_sys_write+0x43/0x50\n       do_syscall_64+0x71/0x210\n       entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(kn->count#389);\n                               lock((work_completion)(&ctrl->delete_work));\n                               lock(kn->count#389);\n  lock((work_completion)(&ctrl->delete_work));\n\n *** DEADLOCK ***\n\n3 locks held by nvme/7918:\n #0: 00000000e2223b44 (sb_writers#6){.+.+}, at: vfs_write+0x1eb/0x260\n #1: 000000003404976f (&of->mutex){+.+.}, at: kernfs_fop_write+0x128/0x240\n #2: 00000000ef5a45b4 (kn->count#389){++++}, at: kernfs_remove_self+0x196/0x210\n\nstack backtrace:\nCPU: 4 PID: 7918 Comm: nvme Not tainted 5.0.0-rc6-dbg+ #10\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014\nCall Trace:\n dump_stack+0x86/0xca\n print_circular_bug.isra.36.cold.54+0x173/0x1d5\n check_prev_add.constprop.45+0x996/0x1110\n __lock_acquire+0x1323/0x17b0\n lock_acquire+0xc5/0x1e0\n __flush_work+0x399/0x410\n flush_work+0x10/0x20\n nvme_delete_ctrl_sync+0x65/0x70\n nvme_sysfs_delete+0x4f/0x60\n dev_attr_store+0x3e/0x50\n sysfs_kf_write+0x87/0xa0\n kernfs_fop_write+0x186/0x240\n __vfs_write+0xd7/0x430\n vfs_write+0xfa/0x260\n ksys_write+0xab/0x130\n __x64_sys_write+0x43/0x50\n do_syscall_64+0x71/0x210\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nSigned-off-by: Bart Van Assche <bvanassche@acm.org>\nReviewed-by: Keith Busch <keith.busch@intel.com>\nSigned-off-by: Christoph Hellwig <hch@lst.de>",
        "before_after_code_files": [
          "drivers/nvme/host/core.c||drivers/nvme/host/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/nvme/host/core.c||drivers/nvme/host/core.c": [
          "File: drivers/nvme/host/core.c -> drivers/nvme/host/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "193:  nvme_get_ctrl(ctrl);",
          "195:  if (!ret)",
          "197:  nvme_put_ctrl(ctrl);",
          "198:  return ret;",
          "199: }",
          "",
          "[Removed Lines]",
          "194:  ret = nvme_delete_ctrl(ctrl);",
          "196:   flush_work(&ctrl->delete_work);",
          "",
          "[Added Lines]",
          "194:  if (!nvme_change_ctrl_state(ctrl, NVME_CTRL_DELETING))",
          "195:   ret = -EBUSY;",
          "197:   nvme_do_delete_ctrl(ctrl);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "69216a545cf81b2b32d01948f7039315abaf75a0",
      "candidate_info": {
        "commit_hash": "69216a545cf81b2b32d01948f7039315abaf75a0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/69216a545cf81b2b32d01948f7039315abaf75a0",
        "files": [
          "arch/arm/crypto/sha256-armv4.pl",
          "arch/arm/crypto/sha256-core.S_shipped"
        ],
        "message": "crypto: sha256/arm - fix crash bug in Thumb2 build\n\nThe SHA256 code we adopted from the OpenSSL project uses a rather\npeculiar way to take the address of the round constant table: it\ntakes the address of the sha256_block_data_order() routine, and\nsubstracts a constant known quantity to arrive at the base of the\ntable, which is emitted by the same assembler code right before\nthe routine's entry point.\n\nHowever, recent versions of binutils have helpfully changed the\nbehavior of references emitted via an ADR instruction when running\nin Thumb2 mode: it now takes the Thumb execution mode bit into\naccount, which is bit 0 af the address. This means the produced\ntable address also has bit 0 set, and so we end up with an address\nvalue pointing 1 byte past the start of the table, which results\nin crashes such as\n\n  Unable to handle kernel paging request at virtual address bf825000\n  pgd = 42f44b11\n  [bf825000] *pgd=80000040206003, *pmd=5f1bd003, *pte=00000000\n  Internal error: Oops: 207 [#1] PREEMPT SMP THUMB2\n  Modules linked in: sha256_arm(+) sha1_arm_ce sha1_arm ...\n  CPU: 7 PID: 396 Comm: cryptomgr_test Not tainted 5.0.0-rc6+ #144\n  Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015\n  PC is at sha256_block_data_order+0xaaa/0xb30 [sha256_arm]\n  LR is at __this_module+0x17fd/0xffffe800 [sha256_arm]\n  pc : [<bf820bca>]    lr : [<bf824ffd>]    psr: 800b0033\n  sp : ebc8bbe8  ip : faaabe1c  fp : 2fdd3433\n  r10: 4c5f1692  r9 : e43037df  r8 : b04b0a5a\n  r7 : c369d722  r6 : 39c3693e  r5 : 7a013189  r4 : 1580d26b\n  r3 : 8762a9b0  r2 : eea9c2cd  r1 : 3e9ab536  r0 : 1dea4ae7\n  Flags: Nzcv  IRQs on  FIQs on  Mode SVC_32  ISA Thumb  Segment user\n  Control: 70c5383d  Table: 6b8467c0  DAC: dbadc0de\n  Process cryptomgr_test (pid: 396, stack limit = 0x69e1fe23)\n  Stack: (0xebc8bbe8 to 0xebc8c000)\n  ...\n  unwind: Unknown symbol address bf820bca\n  unwind: Index not found bf820bca\n  Code: 441a ea80 40f9 440a (f85e) 3b04\n  ---[ end trace e560cce92700ef8a ]---\n\nGiven that this affects older kernels as well, in case they are built\nwith a recent toolchain, apply a minimal backportable fix, which is\nto emit another non-code label at the start of the routine, and\nreference that instead. (This is similar to the current upstream state\nof this file in OpenSSL)\n\nSigned-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
        "before_after_code_files": [
          "arch/arm/crypto/sha256-armv4.pl||arch/arm/crypto/sha256-armv4.pl",
          "arch/arm/crypto/sha256-core.S_shipped||arch/arm/crypto/sha256-core.S_shipped"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm/crypto/sha256-armv4.pl||arch/arm/crypto/sha256-armv4.pl": [
          "File: arch/arm/crypto/sha256-armv4.pl -> arch/arm/crypto/sha256-armv4.pl",
          "--- Hunk 1 ---",
          "[Context before]",
          "212: .global sha256_block_data_order",
          "213: .type sha256_block_data_order,%function",
          "214: sha256_block_data_order:",
          "215: #if __ARM_ARCH__<7",
          "216:  sub r3,pc,#8  @ sha256_block_data_order",
          "217: #else",
          "219: #endif",
          "220: #if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)",
          "221:  ldr r12,.LOPENSSL_armcap",
          "",
          "[Removed Lines]",
          "218:  adr r3,sha256_block_data_order",
          "",
          "[Added Lines]",
          "215: .Lsha256_block_data_order:",
          "219:  adr r3,.Lsha256_block_data_order",
          "",
          "---------------"
        ],
        "arch/arm/crypto/sha256-core.S_shipped||arch/arm/crypto/sha256-core.S_shipped": [
          "File: arch/arm/crypto/sha256-core.S_shipped -> arch/arm/crypto/sha256-core.S_shipped",
          "--- Hunk 1 ---",
          "[Context before]",
          "93: .global sha256_block_data_order",
          "94: .type sha256_block_data_order,%function",
          "95: sha256_block_data_order:",
          "96: #if __ARM_ARCH__<7",
          "97:  sub r3,pc,#8  @ sha256_block_data_order",
          "98: #else",
          "100: #endif",
          "101: #if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)",
          "102:  ldr r12,.LOPENSSL_armcap",
          "",
          "[Removed Lines]",
          "99:  adr r3,sha256_block_data_order",
          "",
          "[Added Lines]",
          "96: .Lsha256_block_data_order:",
          "100:  adr r3,.Lsha256_block_data_order",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b6835ea77729e7faf4656ca637ba53f42b8ee3fd",
      "candidate_info": {
        "commit_hash": "b6835ea77729e7faf4656ca637ba53f42b8ee3fd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b6835ea77729e7faf4656ca637ba53f42b8ee3fd",
        "files": [
          "arch/arc/include/asm/cache.h"
        ],
        "message": "ARC: define ARCH_SLAB_MINALIGN = 8\n\nThe default value of ARCH_SLAB_MINALIGN in \"include/linux/slab.h\" is\n\"__alignof__(unsigned long long)\" which for ARC unexpectedly turns out\nto be 4. This is not a compiler bug, but as defined by ARC ABI [1]\n\nThus slab allocator would allocate a struct which is 32-bit aligned,\nwhich is generally OK even if struct has long long members.\nThere was however potetial problem when it had any atomic64_t which\nuse LLOCKD/SCONDD instructions which are required by ISA to take\n64-bit addresses. This is the problem we ran into\n\n[    4.015732] EXT4-fs (mmcblk0p2): re-mounted. Opts: (null)\n[    4.167881] Misaligned Access\n[    4.172356] Path: /bin/busybox.nosuid\n[    4.176004] CPU: 2 PID: 171 Comm: rm Not tainted 4.19.14-yocto-standard #1\n[    4.182851]\n[    4.182851] [ECR   ]: 0x000d0000 => Check Programmer's Manual\n[    4.190061] [EFA   ]: 0xbeaec3fc\n[    4.190061] [BLINK ]: ext4_delete_entry+0x210/0x234\n[    4.190061] [ERET  ]: ext4_delete_entry+0x13e/0x234\n[    4.202985] [STAT32]: 0x80080002 : IE K\n[    4.207236] BTA: 0x9009329c   SP: 0xbe5b1ec4  FP: 0x00000000\n[    4.212790] LPS: 0x9074b118  LPE: 0x9074b120 LPC: 0x00000000\n[    4.218348] r00: 0x00000040  r01: 0x00000021 r02: 0x00000001\n...\n...\n[    4.270510] Stack Trace:\n[    4.274510]   ext4_delete_entry+0x13e/0x234\n[    4.278695]   ext4_rmdir+0xe0/0x238\n[    4.282187]   vfs_rmdir+0x50/0xf0\n[    4.285492]   do_rmdir+0x9e/0x154\n[    4.288802]   EV_Trap+0x110/0x114\n\nThe fix is to make sure slab allocations are 64-bit aligned.\n\nDo note that atomic64_t is __attribute__((aligned(8)) which means gcc\ndoes generate 64-bit aligned references, relative to beginning of\ncontainer struct. However the issue is if the container itself is not\n64-bit aligned, atomic64_t ends up unaligned which is what this patch\nensures.\n\n[1] https://github.com/foss-for-synopsys-dwc-arc-processors/toolchain/wiki/files/ARCv2_ABI.pdf\n\nSigned-off-by: Alexey Brodkin <abrodkin@synopsys.com>\nCc: <stable@vger.kernel.org> # 4.8+\nSigned-off-by: Vineet Gupta <vgupta@synopsys.com>\n[vgupta: reworked changelog, added dependency on LL64+LLSC]",
        "before_after_code_files": [
          "arch/arc/include/asm/cache.h||arch/arc/include/asm/cache.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arc/include/asm/cache.h||arch/arc/include/asm/cache.h": [
          "File: arch/arc/include/asm/cache.h -> arch/arc/include/asm/cache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: #define cache_line_size() SMP_CACHE_BYTES",
          "53: #define ARCH_DMA_MINALIGN SMP_CACHE_BYTES",
          "55: extern void arc_cache_init(void);",
          "56: extern char *arc_cache_mumbojumbo(int cpu_id, char *buf, int len);",
          "57: extern void read_decode_cache_bcr(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #if defined(CONFIG_ARC_HAS_LL64) && defined(CONFIG_ARC_HAS_LLSC)",
          "63: #define ARCH_SLAB_MINALIGN 8",
          "64: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
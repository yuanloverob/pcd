{
  "cve_id": "CVE-2015-6520",
  "cve_desc": "IPPUSBXD before 1.22 listens on all interfaces, which allows remote attackers to obtain access to USB connected printers via a direct request.",
  "repo": "tillkamppeter/ippusbxd",
  "patch_hash": "46844402bca7a38fc224483ba6f0a93c4613203f",
  "patch_info": {
    "commit_hash": "46844402bca7a38fc224483ba6f0a93c4613203f",
    "repo": "tillkamppeter/ippusbxd",
    "commit_url": "https://github.com/tillkamppeter/ippusbxd/commit/46844402bca7a38fc224483ba6f0a93c4613203f",
    "files": [
      "src/ippusbxd.c",
      "src/tcp.c",
      "src/tcp.h"
    ],
    "message": "SECURITY FIX: Actually restrict the access to the printer to localhost\n\nBefore, any machine in any network connected by any of the interfaces (as\nlisted by \"ifconfig\") could access to an IPP-over-USB printer on the assigned\nport, allowing users on remote machines to print and to access the web\nconfiguration interface of a IPP-over-USB printer in contrary to conventional\nUSB printers which are only accessible locally.",
    "before_after_code_files": [
      "src/ippusbxd.c||src/ippusbxd.c",
      "src/tcp.c||src/tcp.c",
      "src/tcp.h||src/tcp.h"
    ]
  },
  "patch_diff": {
    "src/ippusbxd.c||src/ippusbxd.c": [
      "File: src/ippusbxd.c -> src/ippusbxd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "173:  uint16_t desired_port = g_options.desired_port;",
      "178:   desired_port ++;",
      "",
      "[Removed Lines]",
      "174:  struct tcp_sock_t *tcp_socket;",
      "175:  while ((tcp_socket = tcp_open(desired_port)) == NULL &&",
      "176:         g_options.only_desired_port == 0) {",
      "",
      "[Added Lines]",
      "174:  struct tcp_sock_t *tcp_socket = NULL, *tcp6_socket = NULL;",
      "175:  for (;;) {",
      "176:   tcp_socket = tcp_open(desired_port);",
      "177:   tcp6_socket = tcp6_open(desired_port);",
      "178:   if (tcp_socket || tcp6_socket || g_options.only_desired_port)",
      "179:    break;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:    desired_port = 49152;",
      "186:  }",
      "188:   goto cleanup_tcp;",
      "191:  if (desired_port != 0 && g_options.only_desired_port == 1 &&",
      "192:      desired_port != real_port) {",
      "193:   ERR(\"Received port number did not match requested port number.\"",
      "",
      "[Removed Lines]",
      "187:  if (tcp_socket == NULL)",
      "190:  uint16_t real_port = tcp_port_number_get(tcp_socket);",
      "",
      "[Added Lines]",
      "189:   NOTE(\"Access to desired port failed, trying alternative port %d\", desired_port);",
      "191:  if (tcp_socket == NULL && tcp6_socket == NULL)",
      "194:  uint16_t real_port;",
      "195:  if (tcp_socket)",
      "196:    real_port = tcp_port_number_get(tcp_socket);",
      "197:  else",
      "198:    real_port = tcp_port_number_get(tcp6_socket);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "197:  printf(\"%u|\", real_port);",
      "198:  fflush(stdout);",
      "201:  uint16_t pid;",
      "202:  if (!g_options.nofork_mode && (pid = fork()) > 0) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "208:  NOTE(\"Port: %d, IPv4 %savailable, IPv6 %savailable\",",
      "209:       real_port, tcp_socket ? \"\" : \"not \", tcp6_socket ? \"\" : \"not \");",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "216:   }",
      "218:   args->usb_sock = usb_sock;",
      "220:   if (args->tcp == NULL) {",
      "221:    ERR(\"Failed to open tcp connection\");",
      "222:    goto cleanup_thread;",
      "",
      "[Removed Lines]",
      "219:   args->tcp = tcp_conn_accept(tcp_socket);",
      "",
      "[Added Lines]",
      "233:   args->tcp = tcp_conn_select(tcp_socket, tcp6_socket);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "243: cleanup_tcp:",
      "244:  if (tcp_socket!= NULL)",
      "245:   tcp_close(tcp_socket);",
      "246: cleanup_usb:",
      "247:  if (usb_sock != NULL)",
      "248:   usb_close(usb_sock);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "260:  if (tcp6_socket!= NULL)",
      "261:   tcp_close(tcp6_socket);",
      "",
      "---------------"
    ],
    "src/tcp.c||src/tcp.c": [
      "File: src/tcp.c -> src/tcp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: #include <stdlib.h>",
      "18: #include <string.h>",
      "19: #include <ctype.h>",
      "21: #include <fcntl.h>",
      "22: #include <unistd.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20: #include <sys/time.h>",
      "21: #include <sys/types.h>",
      "22: #include <unistd.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "31: {",
      "32:  struct tcp_sock_t *this = calloc(1, sizeof *this);",
      "33:  if (this == NULL) {",
      "35:   goto error;",
      "36:  }",
      "",
      "[Removed Lines]",
      "34:   ERR(\"callocing this failed\");",
      "",
      "[Added Lines]",
      "37:   ERR(\"IPv4: callocing this failed\");",
      "38:   goto error;",
      "39:  }",
      "42:  this->sd = -1;",
      "43:  this->sd = socket(AF_INET, SOCK_STREAM, 0);",
      "44:  if (this->sd < 0) {",
      "45:   ERR(\"IPv4 socket open failed\");",
      "46:   goto error;",
      "47:  }",
      "50:  struct sockaddr_in addr;",
      "51:  memset(&addr, 0, sizeof addr);",
      "52:  addr.sin_family = AF_INET;",
      "53:  addr.sin_port = htons(port);",
      "54:  addr.sin_addr.s_addr = htonl(0x7F000001);",
      "57:  if (bind(this->sd,",
      "58:          (struct sockaddr *)&addr,",
      "59:          sizeof addr) < 0) {",
      "60:   if (g_options.only_desired_port == 1)",
      "61:    ERR(\"IPv4 bind on port failed. \"",
      "62:        \"Requested port may be taken or require root permissions.\");",
      "63:   goto error;",
      "64:  }",
      "67:  if (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {",
      "68:   ERR(\"IPv4 listen failed on socket\");",
      "69:   goto error;",
      "70:  }",
      "72:  return this;",
      "74: error:",
      "75:  if (this != NULL) {",
      "76:   if (this->sd != -1) {",
      "77:    close(this->sd);",
      "78:   }",
      "79:   free(this);",
      "80:  }",
      "81:  return NULL;",
      "82: }",
      "84: struct tcp_sock_t *tcp6_open(uint16_t port)",
      "85: {",
      "86:  struct tcp_sock_t *this = calloc(1, sizeof *this);",
      "87:  if (this == NULL) {",
      "88:   ERR(\"IPv6: callocing this failed\");",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "39:  this->sd = -1;",
      "40:  this->sd = socket(AF_INET6, SOCK_STREAM, 0);",
      "41:  if (this->sd < 0) {",
      "43:   goto error;",
      "44:  }",
      "",
      "[Removed Lines]",
      "42:   ERR(\"sockect open failed\");",
      "",
      "[Added Lines]",
      "96:   ERR(\"Ipv6 socket open failed\");",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "48:  memset(&addr, 0, sizeof addr);",
      "49:  addr.sin6_family = AF_INET6;",
      "50:  addr.sin6_port = htons(port);",
      "54:  if (bind(this->sd,",
      "55:          (struct sockaddr *)&addr,",
      "56:          sizeof addr) < 0) {",
      "57:   if (g_options.only_desired_port == 1)",
      "59:        \"Requested port may be taken or require root permissions.\");",
      "60:   goto error;",
      "61:  }",
      "64:  if (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {",
      "66:   goto error;",
      "67:  }",
      "",
      "[Removed Lines]",
      "51:  addr.sin6_addr = in6addr_any;",
      "58:    ERR(\"Bind on port failed. \"",
      "65:   ERR(\"listen failed on socket\");",
      "",
      "[Added Lines]",
      "105:  addr.sin6_addr = in6addr_loopback;",
      "112:    ERR(\"IPv6 bind on port failed. \"",
      "119:   ERR(\"IPv6 listen failed on socket\");",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "179: }",
      "183: {",
      "184:  struct tcp_conn_t *conn = calloc(1, sizeof *conn);",
      "185:  if (conn == NULL) {",
      "186:   ERR(\"Calloc for connection struct failed\");",
      "187:   goto error;",
      "188:  }",
      "191:  if (conn->sd < 0) {",
      "192:   ERR(\"accept failed\");",
      "193:   goto error;",
      "194:  }",
      "196:  return conn;",
      "198: error:",
      "",
      "[Removed Lines]",
      "182: struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)",
      "190:  conn->sd = accept(sock->sd, NULL, NULL);",
      "",
      "[Added Lines]",
      "236: struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,",
      "237:        struct tcp_sock_t *sock6)",
      "244:  fd_set rfds;",
      "245:  struct timeval tv;",
      "246:  int retval = 0;",
      "247:  int nfds = 0;",
      "248:  while (retval == 0) {",
      "249:   FD_ZERO(&rfds);",
      "250:   if (sock) {",
      "251:    FD_SET(sock->sd, &rfds);",
      "252:    nfds = sock->sd;",
      "253:   }",
      "254:   if (sock6) {",
      "255:    FD_SET(sock6->sd, &rfds);",
      "256:    if (sock6->sd > nfds)",
      "257:     nfds = sock6->sd;",
      "258:   }",
      "259:   if (nfds == 0) {",
      "260:    ERR(\"No valid TCP socket supplied.\");",
      "261:    goto error;",
      "262:   }",
      "263:   nfds += 1;",
      "265:   tv.tv_sec = 5;",
      "266:   tv.tv_usec = 0;",
      "267:   retval = select(nfds, &rfds, NULL, NULL, &tv);",
      "268:   if (retval == -1) {",
      "269:    ERR(\"Failed to open tcp connection\");",
      "270:    goto error;",
      "271:   }",
      "272:  }",
      "274:  if (sock && FD_ISSET(sock->sd, &rfds)) {",
      "275:   conn->sd = accept(sock->sd, NULL, NULL);",
      "276:   NOTE (\"Using IPv4\");",
      "277:  } else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {",
      "278:   conn->sd = accept(sock6->sd, NULL, NULL);",
      "279:   NOTE (\"Using IPv6\");",
      "280:  } else {",
      "281:   ERR(\"select failed\");",
      "282:   goto error;",
      "283:  }",
      "",
      "---------------"
    ],
    "src/tcp.h||src/tcp.h": [
      "File: src/tcp.h -> src/tcp.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: };",
      "42: struct tcp_sock_t *tcp_open(uint16_t);",
      "43: void tcp_close(struct tcp_sock_t *);",
      "44: uint16_t tcp_port_number_get(struct tcp_sock_t *);",
      "47: void tcp_conn_close(struct tcp_conn_t *);",
      "49: struct http_packet_t *tcp_packet_get(struct tcp_conn_t *,",
      "",
      "[Removed Lines]",
      "46: struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *);",
      "",
      "[Added Lines]",
      "43: struct tcp_sock_t *tcp6_open(uint16_t);",
      "47: struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,",
      "48:        struct tcp_sock_t *sock6);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b420fa9ed581b77fa61008420a66083a5b56fe01",
      "candidate_info": {
        "commit_hash": "b420fa9ed581b77fa61008420a66083a5b56fe01",
        "repo": "tillkamppeter/ippusbxd",
        "commit_url": "https://github.com/tillkamppeter/ippusbxd/commit/b420fa9ed581b77fa61008420a66083a5b56fe01",
        "files": [
          "src/ippusbxd.c",
          "src/options.h",
          "src/tcp.c"
        ],
        "message": "Introduced new \"-P\" option to supply a desired port\n\nBefore, we had only the choice of using a random free port (no option)\nor select a port but error out if the port is already taken by\nsomething else (\"-p\" option). Now we have also the \"-P\" option where\nwe also select a port but if the selected port is busy we search for a\nfree one incrementing the port number by 1 until getting\nsuccessful. This way we have our printer(s) usualkly on the same port\nand it is eaier for the user to call the configuration web interface\nof the printer.",
        "before_after_code_files": [
          "src/ippusbxd.c||src/ippusbxd.c",
          "src/options.h||src/options.h",
          "src/tcp.c||src/tcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/ippusbxd.c||src/ippusbxd.c",
            "src/tcp.c||src/tcp.c"
          ],
          "candidate": [
            "src/ippusbxd.c||src/ippusbxd.c",
            "src/tcp.c||src/tcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/ippusbxd.c||src/ippusbxd.c": [
          "File: src/ippusbxd.c -> src/ippusbxd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:  uint16_t desired_port = g_options.desired_port;",
          "135:  if (tcp_socket == NULL)",
          "136:   goto cleanup_tcp;",
          "138:  uint16_t real_port = tcp_port_number_get(tcp_socket);",
          "140:   ERR(\"Received port number did not match requested port number.\"",
          "141:       \" The requested port number may be too high.\");",
          "142:   goto cleanup_tcp;",
          "",
          "[Removed Lines]",
          "134:  struct tcp_sock_t *tcp_socket = tcp_open(desired_port);",
          "139:  if (desired_port != 0 && desired_port != real_port) {",
          "",
          "[Added Lines]",
          "134:  struct tcp_sock_t *tcp_socket;",
          "135:  while ((tcp_socket = tcp_open(desired_port)) == NULL &&",
          "136:         g_options.only_desired_port == 0) {",
          "138:   desired_port ++;",
          "141:   if (desired_port == 1 || desired_port == 0)",
          "145:    desired_port = 49152;",
          "146:  }",
          "151:  if (desired_port != 0 && g_options.only_desired_port == 1 &&",
          "152:      desired_port != real_port) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "206: {",
          "207:  int c;",
          "208:  g_options.log_destination = LOGGING_STDERR;",
          "211:   switch (c) {",
          "212:   case '?':",
          "213:   case 'h':",
          "214:    g_options.help_mode = 1;",
          "215:    break;",
          "216:   case 'p':",
          "217:   {",
          "218:    long long port = 0;",
          "",
          "[Removed Lines]",
          "210:  while ((c = getopt(argc, argv, \"qnhdp:s:lv:m:\")) != -1) {",
          "",
          "[Added Lines]",
          "222:  g_options.only_desired_port = 1;",
          "224:  while ((c = getopt(argc, argv, \"qnhdp:P:s:lv:m:\")) != -1) {",
          "231:   case 'P':",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:     return 2;",
          "229:    }",
          "230:    g_options.desired_port = (uint16_t)port;",
          "231:    break;",
          "232:   }",
          "233:   case 'l':",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246:    if (c == 'p')",
          "247:      g_options.only_desired_port = 1;",
          "248:    else",
          "249:      g_options.only_desired_port = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "263:   \"  -v <vid>     Vendor ID of desired printer\\n\"",
          "264:   \"  -m <pid>     Product ID of desired printer\\n\"",
          "265:   \"  -s <serial>  Serial number of desired printer\\n\"",
          "267:   \"  -l           Redirect logging to syslog\\n\"",
          "268:   \"  -q           Enable verbose tracing\\n\"",
          "269:   \"  -d           Debug mode for verbose output and no fork\\n\"",
          "",
          "[Removed Lines]",
          "266:   \"  -p <portnum> Port number to bind against\\n\"",
          "",
          "[Added Lines]",
          "285:   \"  -p <portnum> Port number to bind against, error out if port already taken\\n\"",
          "286:   \"  -P <portnum> Port number to bind against, use another port if port already\\n\"",
          "287:   \"               taken\\n\"",
          "",
          "---------------"
        ],
        "src/options.h||src/options.h": [
          "File: src/options.h -> src/options.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: struct options {",
          "25:  uint16_t desired_port;",
          "26:  enum log_target log_destination;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26:  int only_desired_port;",
          "",
          "---------------"
        ],
        "src/tcp.c||src/tcp.c": [
          "File: src/tcp.c -> src/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include <unistd.h>",
          "23: #include <errno.h>",
          "25: #include \"logging.h\"",
          "26: #include \"tcp.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"options.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:  if (bind(this->sd,",
          "54:          (struct sockaddr *)&addr,",
          "55:          sizeof addr) < 0) {",
          "58:   goto error;",
          "59:  }",
          "",
          "[Removed Lines]",
          "56:   ERR(\"Bind on port failed. \"",
          "57:       \"Requested port may be taken or require root permissions.\");",
          "",
          "[Added Lines]",
          "57:   if (g_options.only_desired_port == 1)",
          "58:    ERR(\"Bind on port failed. \"",
          "59:        \"Requested port may be taken or require root permissions.\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ced985a90519c00d7e036db6d424d4c3b9b26dc7",
      "candidate_info": {
        "commit_hash": "ced985a90519c00d7e036db6d424d4c3b9b26dc7",
        "repo": "tillkamppeter/ippusbxd",
        "commit_url": "https://github.com/tillkamppeter/ippusbxd/commit/ced985a90519c00d7e036db6d424d4c3b9b26dc7",
        "files": [
          "src/ippusbxd.c",
          "src/usb.c",
          "src/usb.h"
        ],
        "message": "Register for callback on unplug event",
        "before_after_code_files": [
          "src/ippusbxd.c||src/ippusbxd.c",
          "src/usb.c||src/usb.c",
          "src/usb.h||src/usb.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/ippusbxd.c||src/ippusbxd.c"
          ],
          "candidate": [
            "src/ippusbxd.c||src/ippusbxd.c"
          ]
        }
      },
      "candidate_diff": {
        "src/ippusbxd.c||src/ippusbxd.c": [
          "File: src/ippusbxd.c -> src/ippusbxd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:  if (!g_options.nofork_mode && fork() > 0)",
          "135:   exit(0);",
          "137:  for (;;) {",
          "138:   struct service_thread_param *args = calloc(1, sizeof(*args));",
          "139:   if (args == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139:  if (usb_can_callback(usb_sock))",
          "140:   usb_register_callback(usb_sock);",
          "",
          "---------------"
        ],
        "src/usb.c||src/usb.c": [
          "File: src/usb.c -> src/usb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include \"http.h\"",
          "13: #include \"usb.h\"",
          "15: static int is_ippusb_interface(const struct libusb_interface_descriptor *interf)",
          "16: {",
          "17:  return interf->bInterfaceClass == 0x07 &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #define IGNORE(x) (void)(x)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:    desc.iSerialNumber, serial, SERIAL_MAX);",
          "71:  libusb_close(handle);",
          "76:  return strcmp((char *)serial, (char *)g_options.serial_num) == 0;",
          "77: }",
          "",
          "[Removed Lines]",
          "73:  if (status <= 0)",
          "74:   ERR_AND_EXIT(\"Failed to get serial from device\");",
          "",
          "[Added Lines]",
          "75:  if (status <= 0) {",
          "76:   WARN(\"Failed to get serial from device\");",
          "77:   return 0;",
          "78:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "342:  return;",
          "343: }",
          "346: static void usb_conn_mark_staled(struct usb_conn_t *conn)",
          "347: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "349: int usb_can_callback(struct usb_sock_t *usb)",
          "350: {",
          "351:  IGNORE(usb);",
          "353:  if (!g_options.vendor_id ||",
          "354:      !g_options.product_id)",
          "355:  {",
          "356:   NOTE(\"Exit on unplug requires vid & pid\");",
          "357:   return 0;",
          "358:  }",
          "360:  int works = !!libusb_has_capability(LIBUSB_CAP_HAS_HOTPLUG);",
          "361:  if (!works)",
          "362:   WARN(\"Libusb cannot tell us when to disconnect\");",
          "363:  return works;",
          "364: }",
          "366: int usb_exit_on_unplug(libusb_context *context,",
          "367:                               libusb_device *device,",
          "368:          libusb_hotplug_event event,",
          "369:          void *call_data)",
          "370: {",
          "371:  IGNORE(context);",
          "372:  IGNORE(event);",
          "373:  IGNORE(call_data);",
          "375:  NOTE(\"Received unplug callback\");",
          "377:  struct libusb_device_descriptor desc;",
          "378:  libusb_get_device_descriptor(device, &desc);",
          "380:  if (is_our_device(device, desc))",
          "381:   exit(0);",
          "383:  return 0;",
          "384: }",
          "386: void usb_register_callback(struct usb_sock_t *usb)",
          "387: {",
          "388:  int status = libusb_hotplug_register_callback(",
          "389:    NULL,",
          "390:    LIBUSB_HOTPLUG_MATCH_ANY, // LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT,",
          "391:    0,",
          "392:    LIBUSB_HOTPLUG_MATCH_ANY, // g_options.vendor_id,",
          "393:    LIBUSB_HOTPLUG_MATCH_ANY, // g_options.product_id,",
          "394:    LIBUSB_HOTPLUG_MATCH_ANY, // LIBUSB_CLASS_PRINTER,",
          "395:    &usb_exit_on_unplug,",
          "396:    NULL,",
          "397:    NULL);",
          "398:  if (status == LIBUSB_SUCCESS)",
          "399:   NOTE(\"Registered unplug callback\");",
          "400:  else",
          "401:   ERR(\"Failed to register unplug callback\");",
          "402: }",
          "",
          "---------------"
        ],
        "src/usb.h||src/usb.h": [
          "File: src/usb.h -> src/usb.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: struct usb_sock_t *usb_open(void);",
          "45: void usb_close(struct usb_sock_t *);",
          "47: struct usb_conn_t *usb_conn_aquire(struct usb_sock_t *, int);",
          "48: void usb_conn_release(struct usb_conn_t *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: int usb_can_callback(struct usb_sock_t *);",
          "48: void usb_register_callback(struct usb_sock_t *);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a632841f8e65d402e13e81921515f5a1e2736c82",
      "candidate_info": {
        "commit_hash": "a632841f8e65d402e13e81921515f5a1e2736c82",
        "repo": "tillkamppeter/ippusbxd",
        "commit_url": "https://github.com/tillkamppeter/ippusbxd/commit/a632841f8e65d402e13e81921515f5a1e2736c82",
        "files": [
          "src/tcp.c"
        ],
        "message": "Simplified usage of select() for simultaneous listening via IPv4 and IPv6\n\nOn the introducion of select() to simultaneously listen on the\nassigned port on localhost both via IPv4 and via IPv6 unnecessarily a\ntimeout was used and the select() call repeated in a loop if the\ntimeout expired without incoming data. Now the code is simplified to\nnot use a timeout and a loop but let select() wait for input\nindefinitely.",
        "before_after_code_files": [
          "src/tcp.c||src/tcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/tcp.c||src/tcp.c"
          ],
          "candidate": [
            "src/tcp.c||src/tcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/tcp.c||src/tcp.c": [
          "File: src/tcp.c -> src/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "242:   goto error;",
          "243:  }",
          "244:  fd_set rfds;",
          "246:  int retval = 0;",
          "247:  int nfds = 0;",
          "272:  }",
          "274:  if (sock && FD_ISSET(sock->sd, &rfds)) {",
          "275:   conn->sd = accept(sock->sd, NULL, NULL);",
          "276:   NOTE (\"Using IPv4\");",
          "",
          "[Removed Lines]",
          "245:  struct timeval tv;",
          "248:  while (retval == 0) {",
          "249:   FD_ZERO(&rfds);",
          "250:   if (sock) {",
          "251:    FD_SET(sock->sd, &rfds);",
          "252:    nfds = sock->sd;",
          "253:   }",
          "254:   if (sock6) {",
          "255:    FD_SET(sock6->sd, &rfds);",
          "256:    if (sock6->sd > nfds)",
          "257:     nfds = sock6->sd;",
          "258:   }",
          "259:   if (nfds == 0) {",
          "260:    ERR(\"No valid TCP socket supplied.\");",
          "261:    goto error;",
          "262:   }",
          "263:   nfds += 1;",
          "265:   tv.tv_sec = 5;",
          "266:   tv.tv_usec = 0;",
          "267:   retval = select(nfds, &rfds, NULL, NULL, &tv);",
          "268:   if (retval == -1) {",
          "269:    ERR(\"Failed to open tcp connection\");",
          "270:    goto error;",
          "271:   }",
          "",
          "[Added Lines]",
          "247:  FD_ZERO(&rfds);",
          "248:  if (sock) {",
          "249:   FD_SET(sock->sd, &rfds);",
          "250:   nfds = sock->sd;",
          "251:  }",
          "252:  if (sock6) {",
          "253:   FD_SET(sock6->sd, &rfds);",
          "254:   if (sock6->sd > nfds)",
          "255:    nfds = sock6->sd;",
          "256:  }",
          "257:  if (nfds == 0) {",
          "258:   ERR(\"No valid TCP socket supplied.\");",
          "259:   goto error;",
          "260:  }",
          "261:  nfds += 1;",
          "262:  retval = select(nfds, &rfds, NULL, NULL, NULL);",
          "263:  if (retval < 1) {",
          "264:   ERR(\"Failed to open tcp connection\");",
          "265:   goto error;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
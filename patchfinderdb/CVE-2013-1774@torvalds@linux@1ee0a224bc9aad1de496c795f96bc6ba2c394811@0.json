{
  "cve_id": "CVE-2013-1774",
  "cve_desc": "The chase_port function in drivers/usb/serial/io_ti.c in the Linux kernel before 3.7.4 allows local users to cause a denial of service (NULL pointer dereference and system crash) via an attempted /dev/ttyUSB read or write operation on a disconnected Edgeport USB serial converter.",
  "repo": "torvalds/linux",
  "patch_hash": "1ee0a224bc9aad1de496c795f96bc6ba2c394811",
  "patch_info": {
    "commit_hash": "1ee0a224bc9aad1de496c795f96bc6ba2c394811",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811",
    "files": [
      "drivers/usb/serial/io_ti.c"
    ],
    "message": "USB: io_ti: Fix NULL dereference in chase_port()\n\nThe tty is NULL when the port is hanging up.\nchase_port() needs to check for this.\n\nThis patch is intended for stable series.\nThe behavior was observed and tested in Linux 3.2 and 3.7.1.\n\nJohan Hovold submitted a more elaborate patch for the mainline kernel.\n\n[   56.277883] usb 1-1: edge_bulk_in_callback - nonzero read bulk status received: -84\n[   56.278811] usb 1-1: USB disconnect, device number 3\n[   56.278856] usb 1-1: edge_bulk_in_callback - stopping read!\n[   56.279562] BUG: unable to handle kernel NULL pointer dereference at 00000000000001c8\n[   56.280536] IP: [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35\n[   56.281212] PGD 1dc1b067 PUD 1e0f7067 PMD 0\n[   56.282085] Oops: 0002 [#1] SMP\n[   56.282744] Modules linked in:\n[   56.283512] CPU 1\n[   56.283512] Pid: 25, comm: khubd Not tainted 3.7.1 #1 innotek GmbH VirtualBox/VirtualBox\n[   56.283512] RIP: 0010:[<ffffffff8144e62a>]  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35\n[   56.283512] RSP: 0018:ffff88001fa99ab0  EFLAGS: 00010046\n[   56.283512] RAX: 0000000000000046 RBX: 00000000000001c8 RCX: 0000000000640064\n[   56.283512] RDX: 0000000000010000 RSI: ffff88001fa99b20 RDI: 00000000000001c8\n[   56.283512] RBP: ffff88001fa99b20 R08: 0000000000000000 R09: 0000000000000000\n[   56.283512] R10: 0000000000000000 R11: ffffffff812fcb4c R12: ffff88001ddf53c0\n[   56.283512] R13: 0000000000000000 R14: 00000000000001c8 R15: ffff88001e19b9f4\n[   56.283512] FS:  0000000000000000(0000) GS:ffff88001fd00000(0000) knlGS:0000000000000000\n[   56.283512] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[   56.283512] CR2: 00000000000001c8 CR3: 000000001dc51000 CR4: 00000000000006e0\n[   56.283512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[   56.283512] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[   56.283512] Process khubd (pid: 25, threadinfo ffff88001fa98000, task ffff88001fa94f80)\n[   56.283512] Stack:\n[   56.283512]  0000000000000046 00000000000001c8 ffffffff810578ec ffffffff812fcb4c\n[   56.283512]  ffff88001e19b980 0000000000002710 ffffffff812ffe81 0000000000000001\n[   56.283512]  ffff88001fa94f80 0000000000000202 ffffffff00000001 0000000000000296\n[   56.283512] Call Trace:\n[   56.283512]  [<ffffffff810578ec>] ? add_wait_queue+0x12/0x3c\n[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28\n[   56.283512]  [<ffffffff812ffe81>] ? chase_port+0x84/0x2d6\n[   56.283512]  [<ffffffff81063f27>] ? try_to_wake_up+0x199/0x199\n[   56.283512]  [<ffffffff81263a5c>] ? tty_ldisc_hangup+0x222/0x298\n[   56.283512]  [<ffffffff81300171>] ? edge_close+0x64/0x129\n[   56.283512]  [<ffffffff810612f7>] ? __wake_up+0x35/0x46\n[   56.283512]  [<ffffffff8106135b>] ? should_resched+0x5/0x23\n[   56.283512]  [<ffffffff81264916>] ? tty_port_shutdown+0x39/0x44\n[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28\n[   56.283512]  [<ffffffff8125d38c>] ? __tty_hangup+0x307/0x351\n[   56.283512]  [<ffffffff812e6ddc>] ? usb_hcd_flush_endpoint+0xde/0xed\n[   56.283512]  [<ffffffff8144e625>] ? _raw_spin_lock_irqsave+0x14/0x35\n[   56.283512]  [<ffffffff812fd361>] ? usb_serial_disconnect+0x57/0xc2\n[   56.283512]  [<ffffffff812ea99b>] ? usb_unbind_interface+0x5c/0x131\n[   56.283512]  [<ffffffff8128d738>] ? __device_release_driver+0x7f/0xd5\n[   56.283512]  [<ffffffff8128d9cd>] ? device_release_driver+0x1a/0x25\n[   56.283512]  [<ffffffff8128d393>] ? bus_remove_device+0xd2/0xe7\n[   56.283512]  [<ffffffff8128b7a3>] ? device_del+0x119/0x167\n[   56.283512]  [<ffffffff812e8d9d>] ? usb_disable_device+0x6a/0x180\n[   56.283512]  [<ffffffff812e2ae0>] ? usb_disconnect+0x81/0xe6\n[   56.283512]  [<ffffffff812e4435>] ? hub_thread+0x577/0xe82\n[   56.283512]  [<ffffffff8144daa7>] ? __schedule+0x490/0x4be\n[   56.283512]  [<ffffffff8105798f>] ? abort_exclusive_wait+0x79/0x79\n[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f\n[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f\n[   56.283512]  [<ffffffff810570b4>] ? kthread+0x81/0x89\n[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c\n[   56.283512]  [<ffffffff8145387c>] ? ret_from_fork+0x7c/0xb0\n[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c\n[   56.283512] Code: 8b 7c 24 08 e8 17 0b c3 ff 48 8b 04 24 48 83 c4 10 c3 53 48 89 fb 41 50 e8 e0 0a c3 ff 48 89 04 24 e8 e7 0a c3 ff ba 00 00 01 00\n<f0> 0f c1 13 48 8b 04 24 89 d1 c1 ea 10 66 39 d1 74 07 f3 90 66\n[   56.283512] RIP  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35\n[   56.283512]  RSP <ffff88001fa99ab0>\n[   56.283512] CR2: 00000000000001c8\n[   56.283512] ---[ end trace 49714df27e1679ce ]---\n\nSigned-off-by: Wolfgang Frisch <wfpub@roembden.net>\nCc: Johan Hovold <jhovold@gmail.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/usb/serial/io_ti.c||drivers/usserial/io_ti.c"
    ]
  },
  "patch_diff": {
    "drivers/usb/serial/io_ti.c||drivers/usserial/io_ti.c": [
      "File: drivers/usb/serial/io_ti.c -> drivers/usserial/io_ti.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "530:  wait_queue_t wait;",
      "531:  unsigned long flags;",
      "533:  if (!timeout)",
      "534:   timeout = (HZ * EDGE_CLOSING_WAIT)/100;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "791eb564d218dabe0f9a2212916fe54240b97afb",
      "candidate_info": {
        "commit_hash": "791eb564d218dabe0f9a2212916fe54240b97afb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/791eb564d218dabe0f9a2212916fe54240b97afb",
        "files": [
          "drivers/firmware/efivars.c"
        ],
        "message": "efivarfs: Delete dentry from dcache in efivarfs_file_write()\n\nUnlike the unlink path that is called from the VFS layer, we need to\ncall d_delete() ourselves when a variable is deleted in\nefivarfs_file_write().\n\nFailure to do so means we can access a stale struct efivar_entry when\nreading/writing the file, which can result in the following oops,\n\n  [   59.978216] general protection fault: 0000 [#1] SMP\n  [   60.038660] CPU 9\n  [   60.040501] Pid: 1001, comm: cat Not tainted 3.7.0-2.fc19.x86_64 #1 IBM System x3550 M3 -[7944I21]-/69Y4438\n  [   60.050840] RIP: 0010:[<ffffffff810d5d1e>]  [<ffffffff810d5d1e>] __lock_acquire+0x5e/0x1bb0\n  [   60.059198] RSP: 0018:ffff880270595ce8  EFLAGS: 00010046\n  [   60.064500] RAX: 0000000000000046 RBX: 0000000000000002 RCX: 0000000000000000\n  [   60.071617] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 6b6b6b6b6b6b6b83\n  [   60.078735] RBP: ffff880270595dd8 R08: 0000000000000002 R09: 0000000000000000\n  [   60.085852] R10: 6b6b6b6b6b6b6b83 R11: 0000000000000000 R12: 0000000000000000\n  [   60.092971] R13: ffff88027170cd20 R14: 0000000000000000 R15: 0000000000000000\n  [   60.100091] FS:  00007fc0c8ff3740(0000) GS:ffff880277000000(0000) knlGS:0000000000000000\n  [   60.108164] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [   60.113899] CR2: 0000000001520000 CR3: 000000026d594000 CR4: 00000000000007e0\n  [   60.121016] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  [   60.128135] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n  [   60.135254] Process cat (pid: 1001, threadinfo ffff880270594000, task ffff88027170cd20)\n  [   60.143239] Stack:\n  [   60.145251]  ffff880270595cf8 ffffffff81021da3 ffff880270595d08 ffffffff81021e19\n  [   60.152714]  ffff880270595d38 ffffffff810acdb5 ffff880200000168 0000000000000086\n  [   60.160175]  ffff88027170d5e8 ffffffff810d25ed ffff880270595d58 ffffffff810ace7f\n  [   60.167638] Call Trace:\n  [   60.170088]  [<ffffffff81021da3>] ? native_sched_clock+0x13/0x80\n  [   60.176085]  [<ffffffff81021e19>] ? sched_clock+0x9/0x10\n  [   60.181389]  [<ffffffff810acdb5>] ? sched_clock_cpu+0xc5/0x120\n  [   60.187211]  [<ffffffff810d25ed>] ? trace_hardirqs_off+0xd/0x10\n  [   60.193121]  [<ffffffff810ace7f>] ? local_clock+0x6f/0x80\n  [   60.198513]  [<ffffffff810d2f6f>] ? lock_release_holdtime.part.26+0xf/0x180\n  [   60.205465]  [<ffffffff810d7b57>] ? lock_release_non_nested+0x2e7/0x320\n  [   60.212073]  [<ffffffff815638bb>] ? efivarfs_file_write+0x5b/0x280\n  [   60.218242]  [<ffffffff810d7f41>] lock_acquire+0xa1/0x1f0\n  [   60.223633]  [<ffffffff81563971>] ? efivarfs_file_write+0x111/0x280\n  [   60.229892]  [<ffffffff8118b47c>] ? might_fault+0x5c/0xb0\n  [   60.235287]  [<ffffffff816f1bf6>] _raw_spin_lock+0x46/0x80\n  [   60.240762]  [<ffffffff81563971>] ? efivarfs_file_write+0x111/0x280\n  [   60.247018]  [<ffffffff81563971>] efivarfs_file_write+0x111/0x280\n  [   60.253103]  [<ffffffff811d307f>] vfs_write+0xaf/0x190\n  [   60.258233]  [<ffffffff811d33d5>] sys_write+0x55/0xa0\n  [   60.263278]  [<ffffffff816fbd19>] system_call_fastpath+0x16/0x1b\n  [   60.269271] Code: 41 0f 45 d8 4c 89 75 f0 4c 89 7d f8 85 c0 0f 84 09 01 00 00 8b 05 a3 f9 ff 00 49 89 fa 41 89 f6 41 89 d3 85 c0 0f 84 12 01 00 00 <49> 8b 02 ba 01 00 00 00 48 3d a0 07 14 82 0f 44 da 41 83 fe 01\n  [   60.289431] RIP  [<ffffffff810d5d1e>] __lock_acquire+0x5e/0x1bb0\n  [   60.295444]  RSP <ffff880270595ce8>\n  [   60.298928] ---[ end trace 1bbfd41a2cf6a0d8 ]---\n\nCc: Josh Boyer <jwboyer@redhat.com>\nAcked-by: Jeremy Kerr <jeremy.kerr@canonical.com>\nCc: Lee, Chun-Yi <jlee@suse.com>\nCc: Andy Whitcroft <apw@canonical.com>\nReported-by: Lingzhu Xiang <lxiang@redhat.com>\nSigned-off-by: Matt Fleming <matt.fleming@intel.com>",
        "before_after_code_files": [
          "drivers/firmware/efivars.c||drivers/firmware/efivars.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/firmware/efivars.c||drivers/firmware/efivars.c": [
          "File: drivers/firmware/efivars.c -> drivers/firmware/efivars.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "793:   spin_unlock(&efivars->lock);",
          "794:   efivar_unregister(var);",
          "795:   drop_nlink(inode);",
          "796:   dput(file->f_dentry);",
          "798:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "796:   d_delete(file->f_dentry);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c1bf08ac26e92122faab9f6c32ea8aba94612dae",
      "candidate_info": {
        "commit_hash": "c1bf08ac26e92122faab9f6c32ea8aba94612dae",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c1bf08ac26e92122faab9f6c32ea8aba94612dae",
        "files": [
          "kernel/trace/ftrace.c"
        ],
        "message": "ftrace: Be first to run code modification on modules\n\nIf some other kernel subsystem has a module notifier, and adds a kprobe\nto a ftrace mcount point (now that kprobes work on ftrace points),\nwhen the ftrace notifier runs it will fail and disable ftrace, as well\nas kprobes that are attached to ftrace points.\n\nHere's the error:\n\n WARNING: at kernel/trace/ftrace.c:1618 ftrace_bug+0x239/0x280()\n Hardware name: Bochs\n Modules linked in: fat(+) stap_56d28a51b3fe546293ca0700b10bcb29__8059(F) nfsv4 auth_rpcgss nfs dns_resolver fscache xt_nat iptable_nat nf_conntrack_ipv4 nf_defrag_ipv4 nf_nat_ipv4 nf_nat nf_conntrack lockd sunrpc ppdev parport_pc parport microcode virtio_net i2c_piix4 drm_kms_helper ttm drm i2c_core [last unloaded: bid_shared]\n Pid: 8068, comm: modprobe Tainted: GF            3.7.0-0.rc8.git0.1.fc19.x86_64 #1\n Call Trace:\n  [<ffffffff8105e70f>] warn_slowpath_common+0x7f/0xc0\n  [<ffffffff81134106>] ? __probe_kernel_read+0x46/0x70\n  [<ffffffffa0180000>] ? 0xffffffffa017ffff\n  [<ffffffffa0180000>] ? 0xffffffffa017ffff\n  [<ffffffff8105e76a>] warn_slowpath_null+0x1a/0x20\n  [<ffffffff810fd189>] ftrace_bug+0x239/0x280\n  [<ffffffff810fd626>] ftrace_process_locs+0x376/0x520\n  [<ffffffff810fefb7>] ftrace_module_notify+0x47/0x50\n  [<ffffffff8163912d>] notifier_call_chain+0x4d/0x70\n  [<ffffffff810882f8>] __blocking_notifier_call_chain+0x58/0x80\n  [<ffffffff81088336>] blocking_notifier_call_chain+0x16/0x20\n  [<ffffffff810c2a23>] sys_init_module+0x73/0x220\n  [<ffffffff8163d719>] system_call_fastpath+0x16/0x1b\n ---[ end trace 9ef46351e53bbf80 ]---\n ftrace failed to modify [<ffffffffa0180000>] init_once+0x0/0x20 [fat]\n  actual: cc:bb:d2:4b:e1\n\nA kprobe was added to the init_once() function in the fat module on load.\nBut this happened before ftrace could have touched the code. As ftrace\ndidn't run yet, the kprobe system had no idea it was a ftrace point and\nsimply added a breakpoint to the code (0xcc in the cc:bb:d2:4b:e1).\n\nThen when ftrace went to modify the location from a call to mcount/fentry\ninto a nop, it didn't see a call op, but instead it saw the breakpoint op\nand not knowing what to do with it, ftrace shut itself down.\n\nThe solution is to simply give the ftrace module notifier the max priority.\nThis should have been done regardless, as the core code ftrace modification\nalso happens very early on in boot up. This makes the module modification\ncloser to core modification.\n\nLink: http://lkml.kernel.org/r/20130107140333.593683061@goodmis.org\n\nCc: stable@vger.kernel.org\nAcked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>\nReported-by: Frank Ch. Eigler <fche@redhat.com>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>",
        "before_after_code_files": [
          "kernel/trace/ftrace.c||kernel/trace/ftrace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/trace/ftrace.c||kernel/trace/ftrace.c": [
          "File: kernel/trace/ftrace.c -> kernel/trace/ftrace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3999: struct notifier_block ftrace_module_nb = {",
          "4000:  .notifier_call = ftrace_module_notify,",
          "4002: };",
          "4004: extern unsigned long __start_mcount_loc[];",
          "",
          "[Removed Lines]",
          "4001:  .priority = 0,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b8f2c21db390273c3eaf0e5308faeaeb1e233840",
      "candidate_info": {
        "commit_hash": "b8f2c21db390273c3eaf0e5308faeaeb1e233840",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b8f2c21db390273c3eaf0e5308faeaeb1e233840",
        "files": [
          "arch/x86/platform/efi/efi_64.c"
        ],
        "message": "efi, x86: Pass a proper identity mapping in efi_call_phys_prelog\n\nUpdate efi_call_phys_prelog to install an identity mapping of all available\nmemory.  This corrects a bug on very large systems with more then 512 GB in\nwhich bios would not be able to access addresses above not in the mapping.\n\nThe result is a crash that looks much like this.\n\nBUG: unable to handle kernel paging request at 000000effd870020\nIP: [<0000000078bce331>] 0x78bce330\nPGD 0\nOops: 0000 [#1] SMP\nModules linked in:\nCPU 0\nPid: 0, comm: swapper/0 Tainted: G        W    3.8.0-rc1-next-20121224-medusa_ntz+ #2 Intel Corp. Stoutland Platform\nRIP: 0010:[<0000000078bce331>]  [<0000000078bce331>] 0x78bce330\nRSP: 0000:ffffffff81601d28  EFLAGS: 00010006\nRAX: 0000000078b80e18 RBX: 0000000000000004 RCX: 0000000000000004\nRDX: 0000000078bcf958 RSI: 0000000000002400 RDI: 8000000000000000\nRBP: 0000000078bcf760 R08: 000000effd870000 R09: 0000000000000000\nR10: 0000000000000000 R11: 00000000000000c3 R12: 0000000000000030\nR13: 000000effd870000 R14: 0000000000000000 R15: ffff88effd870000\nFS:  0000000000000000(0000) GS:ffff88effe400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000effd870020 CR3: 000000000160c000 CR4: 00000000000006b0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess swapper/0 (pid: 0, threadinfo ffffffff81600000, task ffffffff81614400)\nStack:\n 0000000078b80d18 0000000000000004 0000000078bced7b ffff880078b81fff\n 0000000000000000 0000000000000082 0000000078bce3a8 0000000000002400\n 0000000060000202 0000000078b80da0 0000000078bce45d ffffffff8107cb5a\nCall Trace:\n [<ffffffff8107cb5a>] ? on_each_cpu+0x77/0x83\n [<ffffffff8102f4eb>] ? change_page_attr_set_clr+0x32f/0x3ed\n [<ffffffff81035946>] ? efi_call4+0x46/0x80\n [<ffffffff816c5abb>] ? efi_enter_virtual_mode+0x1f5/0x305\n [<ffffffff816aeb24>] ? start_kernel+0x34a/0x3d2\n [<ffffffff816ae5ed>] ? repair_env_string+0x60/0x60\n [<ffffffff816ae2be>] ? x86_64_start_reservations+0xba/0xc1\n [<ffffffff816ae120>] ? early_idt_handlers+0x120/0x120\n [<ffffffff816ae419>] ? x86_64_start_kernel+0x154/0x163\nCode:  Bad RIP value.\nRIP  [<0000000078bce331>] 0x78bce330\n RSP <ffffffff81601d28>\nCR2: 000000effd870020\n---[ end trace ead828934fef5eab ]---\n\nCc: stable@vger.kernel.org\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Ingo Molnar <mingo@redhat.com>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nSigned-off-by: Nathan Zimmer <nzimmer@sgi.com>\nSigned-off-by: Robin Holt <holt@sgi.com>\nSigned-off-by: Matt Fleming <matt.fleming@intel.com>",
        "before_after_code_files": [
          "arch/x86/platform/efi/efi_64.c||arch/x86/platform/efi/efi_64.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/platform/efi/efi_64.c||arch/x86/platform/efi/efi_64.c": [
          "File: arch/x86/platform/efi/efi_64.c -> arch/x86/platform/efi/efi_64.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #include <asm/cacheflush.h>",
          "39: #include <asm/fixmap.h>",
          "42: static unsigned long efi_flags __initdata;",
          "44: static void __init early_code_mapping_set_exec(int executable)",
          "",
          "[Removed Lines]",
          "41: static pgd_t save_pgd __initdata;",
          "",
          "[Added Lines]",
          "41: static pgd_t *save_pgd __initdata;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61: void __init efi_call_phys_prelog(void)",
          "62: {",
          "63:  unsigned long vaddress;",
          "65:  early_code_mapping_set_exec(1);",
          "66:  local_irq_save(efi_flags);",
          "70:  __flush_tlb_all();",
          "71: }",
          "",
          "[Removed Lines]",
          "67:  vaddress = (unsigned long)__va(0x0UL);",
          "68:  save_pgd = *pgd_offset_k(0x0UL);",
          "69:  set_pgd(pgd_offset_k(0x0UL), *pgd_offset_k(vaddress));",
          "",
          "[Added Lines]",
          "64:  int pgd;",
          "65:  int n_pgds;",
          "70:  n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);",
          "71:  save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);",
          "73:  for (pgd = 0; pgd < n_pgds; pgd++) {",
          "74:   save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);",
          "75:   vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);",
          "76:   set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));",
          "77:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:  __flush_tlb_all();",
          "80:  local_irq_restore(efi_flags);",
          "81:  early_code_mapping_set_exec(0);",
          "",
          "[Removed Lines]",
          "78:  set_pgd(pgd_offset_k(0x0UL), save_pgd);",
          "",
          "[Added Lines]",
          "86:  int pgd;",
          "87:  int n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT) , PGDIR_SIZE);",
          "88:  for (pgd = 0; pgd < n_pgds; pgd++)",
          "89:   set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);",
          "90:  kfree(save_pgd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6f8c2e7933679f54b6478945dc72e59ef9a3d5e0",
      "candidate_info": {
        "commit_hash": "6f8c2e7933679f54b6478945dc72e59ef9a3d5e0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6f8c2e7933679f54b6478945dc72e59ef9a3d5e0",
        "files": [
          "drivers/idle/intel_idle.c"
        ],
        "message": "intel_idle: Don't register CPU notifier if we are not running.\n\nThe 'intel_idle_probe' probes the CPU and sets the CPU notifier.\nBut if later on during the module initialization we fail (say\nin cpuidle_register_driver), we stop loading, but we neglect\nto unregister the CPU notifier.  This means that during CPU\nhotplug events the system will fail:\n\ncalling  intel_idle_init+0x0/0x326 @ 1\nintel_idle: MWAIT substates: 0x1120\nintel_idle: v0.4 model 0x2A\nintel_idle: lapic_timer_reliable_states 0xffffffff\nintel_idle: intel_idle yielding to none\ninitcall intel_idle_init+0x0/0x326 returned -19 after 14 usecs\n\n... some time later, offlining and onlining a CPU:\n\ncpu 3 spinlock event irq 62\nBUG: unable to ] __cpuidle_register_device+0x1c/0x120\nPGD 99b8b067 PUD 99b95067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: xen_evtchn nouveau mxm_wmi wmi radeon ttm i915 fbcon tileblit font atl1c bitblit softcursor drm_kms_helper video xen_blkfront xen_netfront fb_sys_fops sysimgblt sysfillrect syscopyarea xenfs xen_privcmd mperf\nCPU 0\nPid: 2302, comm: udevd Not tainted 3.8.0-rc3upstream-00249-g09ad159 #1 MSI MS-7680/H61M-P23 (MS-7680)\nRIP: e030:[<ffffffff814d956c>]  [<ffffffff814d956c>] __cpuidle_register_device+0x1c/0x120\nRSP: e02b:ffff88009dacfcb8  EFLAGS: 00010286\nRAX: 0000000000000000 RBX: ffff880105380000 RCX: 000000000000001c\nRDX: 0000000000000000 RSI: 0000000000000055 RDI: ffff880105380000\nRBP: ffff88009dacfce8 R08: ffffffff81a4f048 R09: 0000000000000008\nR10: 0000000000000008 R11: 0000000000000000 R12: ffff880105380000\nR13: 00000000ffffffdd R14: 0000000000000000 R15: ffffffff81a523d0\nFS:  00007f37bd83b7a0(0000) GS:ffff880105200000(0000) knlGS:0000000000000000\nCS:  e033 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000008 CR3: 00000000a09ea000 CR4: 0000000000042660\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess udevd (pid: 2302, threadinfo ffff88009dace000, task ffff88009afb47f0)\nStack:\n ffffffff8107f2d0 ffffffff810c2fb7 ffff88009dacfce8 00000000ffffffea\n ffff880105380000 00000000ffffffdd ffff88009dacfd08 ffffffff814d9882\n 0000000000000003 ffff880105380000 ffff88009dacfd28 ffffffff81340afd\nCall Trace:\n [<ffffffff8107f2d0>] ? collect_cpu_info_local+0x30/0x30\n [<ffffffff810c2fb7>] ? __might_sleep+0xe7/0x100\n [<ffffffff814d9882>] cpuidle_register_device+0x32/0x70\n [<ffffffff81340afd>] intel_idle_cpu_init+0xad/0x110\n [<ffffffff81340bc8>] cpu_hotplug_notify+0x68/0x80\n [<ffffffff8166023d>] notifier_call_chain+0x4d/0x70\n [<ffffffff810bc369>] __raw_notifier_call_chain+0x9/0x10\n [<ffffffff81094a4b>] __cpu_notify+0x1b/0x30\n [<ffffffff81652cf7>] _cpu_up+0x103/0x14b\n [<ffffffff81652e18>] cpu_up+0xd9/0xec\n [<ffffffff8164a254>] store_online+0x94/0xd0\n [<ffffffff814122fb>] dev_attr_store+0x1b/0x20\n [<ffffffff81216404>] sysfs_write_file+0xf4/0x170\n [<ffffffff811a1024>] vfs_write+0xb4/0x130\n [<ffffffff811a17ea>] sys_write+0x5a/0xa0\n [<ffffffff816643a9>] system_call_fastpath+0x16/0x1b\nCode: 03 18 00 c9 c3 66 2e 0f 1f 84 00 00 00 00 00 55 48 89 e5 48 83 ec 30 48 89 5d e8 4c 89 65 f0 48 89 fb 4c 89 6d f8 e8 84 08 00 00 <48> 8b 78 08 49 89 c4 e8 f8 7f c1 ff 89 c2 b8 ea ff ff ff 84 d2\nRIP  [<ffffffff814d956c>] __cpuidle_register_device+0x1c/0x120\n RSP <ffff88009dacfcb8>\n\nThis patch fixes that by moving the CPU notifier registration\nas the last item to be done by the module.\n\nSigned-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nReviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>\nCc: 3.6+ <stable@vger.kernel.org>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
        "before_after_code_files": [
          "drivers/idle/intel_idle.c||drivers/idle/intel_idle.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/idle/intel_idle.c||drivers/idle/intel_idle.c": [
          "File: drivers/idle/intel_idle.c -> drivers/idle/intel_idle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "448:  else",
          "449:   on_each_cpu(__setup_broadcast_timer, (void *)true, 1);",
          "453:  pr_debug(PREFIX \"v\" INTEL_IDLE_VERSION",
          "454:   \" model 0x%X\\n\", boot_cpu_data.x86_model);",
          "",
          "[Removed Lines]",
          "451:  register_cpu_notifier(&cpu_hotplug_notifier);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "612:    return retval;",
          "613:   }",
          "614:  }",
          "616:  return 0;",
          "617: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "613:  register_cpu_notifier(&cpu_hotplug_notifier);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "852e4a8152b427c3f318bb0e1b5e938d64dcdc32",
      "candidate_info": {
        "commit_hash": "852e4a8152b427c3f318bb0e1b5e938d64dcdc32",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/852e4a8152b427c3f318bb0e1b5e938d64dcdc32",
        "files": [
          "drivers/tty/tty_ldisc.c"
        ],
        "message": "tty: don't deadlock while flushing workqueue\n\nSince commit 89c8d91e31f2 (\"tty: localise the lock\") I see a dead lock\nin one of my dummy_hcd + g_nokia test cases. The first run was usually\nokay, the second often resulted in a splat by lockdep and the third was\nusually a dead lock.\nLockdep complained about tty->hangup_work and tty->legacy_mutex taken\nboth ways:\n| ======================================================\n| [ INFO: possible circular locking dependency detected ]\n| 3.7.0-rc6+ #204 Not tainted\n| -------------------------------------------------------\n| kworker/2:1/35 is trying to acquire lock:\n|  (&tty->legacy_mutex){+.+.+.}, at: [<c14051e6>] tty_lock_nested+0x36/0x80\n|\n| but task is already holding lock:\n|  ((&tty->hangup_work)){+.+...}, at: [<c104f6e4>] process_one_work+0x124/0x5e0\n|\n| which lock already depends on the new lock.\n|\n| the existing dependency chain (in reverse order) is:\n|\n| -> #2 ((&tty->hangup_work)){+.+...}:\n|        [<c107fe74>] lock_acquire+0x84/0x190\n|        [<c104d82d>] flush_work+0x3d/0x240\n|        [<c12e6986>] tty_ldisc_flush_works+0x16/0x30\n|        [<c12e7861>] tty_ldisc_release+0x21/0x70\n|        [<c12e0dfc>] tty_release+0x35c/0x470\n|        [<c1105e28>] __fput+0xd8/0x270\n|        [<c1105fcd>] ____fput+0xd/0x10\n|        [<c1051dd9>] task_work_run+0xb9/0xf0\n|        [<c1002a51>] do_notify_resume+0x51/0x80\n|        [<c140550a>] work_notifysig+0x35/0x3b\n|\n| -> #1 (&tty->legacy_mutex/1){+.+...}:\n|        [<c107fe74>] lock_acquire+0x84/0x190\n|        [<c140276c>] mutex_lock_nested+0x6c/0x2f0\n|        [<c14051e6>] tty_lock_nested+0x36/0x80\n|        [<c1405279>] tty_lock_pair+0x29/0x70\n|        [<c12e0bb8>] tty_release+0x118/0x470\n|        [<c1105e28>] __fput+0xd8/0x270\n|        [<c1105fcd>] ____fput+0xd/0x10\n|        [<c1051dd9>] task_work_run+0xb9/0xf0\n|        [<c1002a51>] do_notify_resume+0x51/0x80\n|        [<c140550a>] work_notifysig+0x35/0x3b\n|\n| -> #0 (&tty->legacy_mutex){+.+.+.}:\n|        [<c107f3c9>] __lock_acquire+0x1189/0x16a0\n|        [<c107fe74>] lock_acquire+0x84/0x190\n|        [<c140276c>] mutex_lock_nested+0x6c/0x2f0\n|        [<c14051e6>] tty_lock_nested+0x36/0x80\n|        [<c140523f>] tty_lock+0xf/0x20\n|        [<c12df8e4>] __tty_hangup+0x54/0x410\n|        [<c12dfcb2>] do_tty_hangup+0x12/0x20\n|        [<c104f763>] process_one_work+0x1a3/0x5e0\n|        [<c104fec9>] worker_thread+0x119/0x3a0\n|        [<c1055084>] kthread+0x94/0xa0\n|        [<c140ca37>] ret_from_kernel_thread+0x1b/0x28\n|\n|other info that might help us debug this:\n|\n|Chain exists of:\n|  &tty->legacy_mutex --> &tty->legacy_mutex/1 --> (&tty->hangup_work)\n|\n| Possible unsafe locking scenario:\n|\n|       CPU0                    CPU1\n|       ----                    ----\n|  lock((&tty->hangup_work));\n|                               lock(&tty->legacy_mutex/1);\n|                               lock((&tty->hangup_work));\n|  lock(&tty->legacy_mutex);\n|\n| *** DEADLOCK ***\n\nBefore the path mentioned tty_ldisc_release() look like this:\n\n|\ttty_ldisc_halt(tty);\n|\ttty_ldisc_flush_works(tty);\n|\ttty_lock();\n\nAs it can be seen, it first flushes the workqueue and then grabs the\ntty_lock. Now we grab the lock first:\n\n|\ttty_lock_pair(tty, o_tty);\n|\ttty_ldisc_halt(tty);\n|\ttty_ldisc_flush_works(tty);\n\nso lockdep's complaint seems valid.\n\nThe earlier version of this patch took the ldisc_mutex since the other\nuser of tty_ldisc_flush_works() (tty_set_ldisc()) did this.\nPeter Hurley then said that it is should not be requried. Since it\nwasn't done earlier, I dropped this part.\nThe code under tty_ldisc_kill() was executed earlier with the tty lock\ntaken so it is taken again.\n\nI was able to reproduce the deadlock on v3.8-rc1, this patch fixes the\nproblem in my testcase. I didn't notice any problems so far.\n\nCc: Alan Cox <alan@linux.intel.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nSigned-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/tty/tty_ldisc.c||drivers/tty/tty_ldisc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/tty/tty_ldisc.c||drivers/tty/tty_ldisc.c": [
          "File: drivers/tty/tty_ldisc.c -> drivers/tty/tty_ldisc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "940:  tty_ldisc_halt(tty);",
          "943:   tty_ldisc_halt(o_tty);",
          "944:   tty_ldisc_flush_works(o_tty);",
          "948:  tty_ldisc_kill(tty);",
          "950:  if (o_tty)",
          "951:   tty_ldisc_kill(o_tty);",
          "",
          "[Removed Lines]",
          "939:  tty_lock_pair(tty, o_tty);",
          "941:  tty_ldisc_flush_works(tty);",
          "942:  if (o_tty) {",
          "945:  }",
          "",
          "[Added Lines]",
          "940:  if (o_tty)",
          "943:  tty_ldisc_flush_works(tty);",
          "944:  if (o_tty)",
          "947:  tty_lock_pair(tty, o_tty);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
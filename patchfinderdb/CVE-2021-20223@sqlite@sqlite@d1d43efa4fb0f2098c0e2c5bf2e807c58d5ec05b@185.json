{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4e8e533bf7ee9afd7f6a4d8899b891bbdbf9ac53",
      "candidate_info": {
        "commit_hash": "4e8e533bf7ee9afd7f6a4d8899b891bbdbf9ac53",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4e8e533bf7ee9afd7f6a4d8899b891bbdbf9ac53",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "test/gencol1.test"
        ],
        "message": "Restore generated column loop detection logic that was incorrectly removed from the previous check-in [9e07b48934e9a972].  This fixes ticket [299b50ba812d8e54]\n\nFossilOrigin-Name: 104a2beb57037f9353ffa77096aae0eb64e4682e667f31623bfd3d064dd8d881",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "test/gencol1.test||test/gencol1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9e07b48934e9a972dcf62e3538b3b21ffa044c553feba0441675ac0bbe13bcb2",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3645:           iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;",
          "3646: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "3647:           if( pCol->colFlags & COLFLAG_GENERATED ){",
          "3649:             return iSrc;",
          "3650:           }else",
          "",
          "[Removed Lines]",
          "3648:             sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);",
          "",
          "[Added Lines]",
          "3648:             if( pCol->colFlags & COLFLAG_BUSY ){",
          "3649:               sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",",
          "3650:                               pCol->zName);",
          "3651:               return 0;",
          "3652:             }",
          "3653:             pCol->colFlags |= COLFLAG_BUSY;",
          "3654:             if( pCol->colFlags & COLFLAG_NOTAVAIL ){",
          "3655:               sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);",
          "3656:             }",
          "3657:             pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);",
          "",
          "---------------"
        ],
        "test/gencol1.test||test/gencol1.test": [
          "File: test/gencol1.test -> test/gencol1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "233:   INSERT INTO t0 VALUES (0),(99);",
          "234:   SELECT * FROM t0;",
          "235: } {1 1 0 1 1 99}",
          "237: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "236: do_catchsql_test gencol1-8.20 {",
          "237:   DROP TABLE IF EXISTS t0;",
          "238:   CREATE TABLE t0(",
          "239:     c0,",
          "240:     c1 AS(c0 + c2),",
          "241:     c2 AS(c1) CHECK(c2)",
          "242:   );",
          "243:   UPDATE t0 SET c0 = NULL;",
          "244: } {1 {generated column loop on \"c2\"}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2b06b0769ed38e408b4d28406db44cda44bdbbcd",
      "candidate_info": {
        "commit_hash": "2b06b0769ed38e408b4d28406db44cda44bdbbcd",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/2b06b0769ed38e408b4d28406db44cda44bdbbcd",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/main.c",
          "src/os_unix.c",
          "src/prepare.c",
          "test/busy2.test"
        ],
        "message": "Ensure that the busy-handler count is reset at the end of each sqlite3_file_control() and sqlite3_prepare() (and _v2() and _v3()).\n\nFossilOrigin-Name: 5dd05940617fb05ee2faf212b15afc3a8e9695318eccb76761b37359fea681d1",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/main.c||src/main.c",
          "src/os_unix.c||src/os_unix.c",
          "src/prepare.c||src/prepare.c",
          "test/busy2.test||test/busy2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: a711e8cd2c7b64e06241736ecef478ac64ddbe7b58e0933b6febba63f7fb06e1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3852:       }",
          "3853:       rc = SQLITE_OK;",
          "3854:     }else{",
          "3855:       rc = sqlite3OsFileControl(fd, op, pArg);",
          "3856:     }",
          "3857:     sqlite3BtreeLeave(pBtree);",
          "3858:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3855:       int nSave = db->busyHandler.nBusy;",
          "3857:       db->busyHandler.nBusy = nSave;",
          "",
          "---------------"
        ],
        "src/os_unix.c||src/os_unix.c": [
          "File: src/os_unix.c -> src/os_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2145:   }",
          "2146:   sqlite3_mutex_leave(pInode->pLockMutex);",
          "2147:   releaseInodeInfo(pFile);",
          "2148:   rc = closeUnixFile(id);",
          "2149:   unixLeaveMutex();",
          "2150:   return rc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2148:   assert( pFile->pShm==0 );",
          "",
          "---------------"
        ],
        "src/prepare.c||src/prepare.c": [
          "File: src/prepare.c -> src/prepare.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "746:   sqlite3BtreeLeaveAll(db);",
          "747:   rc = sqlite3ApiExit(db, rc);",
          "748:   assert( (rc&db->errMask)==rc );",
          "749:   sqlite3_mutex_leave(db->mutex);",
          "750:   return rc;",
          "751: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "749:   db->busyHandler.nBusy = 0;",
          "",
          "---------------"
        ],
        "test/busy2.test||test/busy2.test": [
          "File: test/busy2.test -> test/busy2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:   }",
          "132: }",
          "134: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134: #-------------------------------------------------------------------------",
          "135: # Check that even if the busy-handler fails (returns zero) within a",
          "136: # call to sqlite3_prepare() (or _v2(), or _v3()), it is still invoked",
          "137: # the next time an SQLITE_BUSY is encountered.",
          "138: #",
          "140: do_multiclient_test tn {",
          "141:   code1 {",
          "142:     set ::busy_called 0",
          "143:     proc busy {args} {",
          "144:       if {$::busy_called} { return 1 }",
          "145:       set ::busy_called 1",
          "146:       return 0",
          "147:     }",
          "148:     db busy busy",
          "149:   }",
          "151:   do_test 3.$tn.1 {",
          "152:     sql2 {",
          "153:       CREATE TABLE t1(x);",
          "154:       BEGIN EXCLUSIVE;",
          "155:         INSERT INTO t1 VALUES('x');",
          "156:     }",
          "157:   } {}",
          "159:   do_test 3.$tn.2 {",
          "160:     set ::busy_called 0",
          "161:     list [catch { sql1 { SELECT * FROM t1 } } msg] $msg $::busy_called",
          "162:   } {1 {database is locked} 1}",
          "164:   do_test 3.$tn.3 {",
          "165:     set ::busy_called 0",
          "166:     list [catch { sql1 { SELECT * FROM t1 } } msg] $msg $::busy_called",
          "167:   } {1 {database is locked} 1}",
          "168: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "24d35e409c900adba4f5528e70c6c7e5e748cfd0",
      "candidate_info": {
        "commit_hash": "24d35e409c900adba4f5528e70c6c7e5e748cfd0",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/24d35e409c900adba4f5528e70c6c7e5e748cfd0",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c",
          "src/build.c",
          "src/expr.c",
          "src/global.c",
          "src/insert.c",
          "src/main.c",
          "src/malloc.c",
          "src/resolve.c",
          "src/select.c",
          "src/sqliteInt.h",
          "src/status.c",
          "src/treeview.c",
          "src/trigger.c",
          "src/update.c"
        ],
        "message": "Add the two-size lookaside memory allocator.  Also, reduce the per-entry size of the ExprList object.\n\nFossilOrigin-Name: 51665bf0f975fb248964a4be205a4f3285d3f3f8cc697977d264efefbbe20dd8",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c",
          "src/build.c||src/build.c",
          "src/expr.c||src/expr.c",
          "src/global.c||src/global.c",
          "src/insert.c||src/insert.c",
          "src/main.c||src/main.c",
          "src/malloc.c||src/malloc.c",
          "src/resolve.c||src/resolve.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/status.c||src/status.c",
          "src/treeview.c||src/treeview.c",
          "src/trigger.c||src/trigger.c",
          "src/update.c||src/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7405e982257611803792617f5d8142c54f9831b4a030f4de8607888c525e6289",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "766:   if( ALWAYS(p->pEList) ){",
          "767:     ExprList *pList = p->pEList;",
          "768:     for(i=0; i<pList->nExpr; i++){",
          "771:       }",
          "772:     }",
          "773:   }",
          "",
          "[Removed Lines]",
          "769:       if( pList->a[i].zName ){",
          "770:         sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zName);",
          "",
          "[Added Lines]",
          "769:       if( pList->a[i].zEName && pList->a[i].eEName==ENAME_NAME ){",
          "770:         sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zEName);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "811:     sWalker.xExprCallback = renameUnmapExprCb;",
          "812:     sqlite3WalkExprList(&sWalker, pEList);",
          "813:     for(i=0; i<pEList->nExpr; i++){",
          "815:     }",
          "816:   }",
          "817: }",
          "",
          "[Removed Lines]",
          "814:       sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zName);",
          "",
          "[Added Lines]",
          "814:       if( ALWAYS(pEList->a[i].eEName==ENAME_NAME) ){",
          "815:         sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zEName);",
          "816:       }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "949:   if( pEList ){",
          "950:     int i;",
          "951:     for(i=0; i<pEList->nExpr; i++){",
          "954:         renameTokenFind(pParse, pCtx, (void*)zName);",
          "955:       }",
          "956:     }",
          "",
          "[Removed Lines]",
          "952:       char *zName = pEList->a[i].zName;",
          "953:       if( 0==sqlite3_stricmp(zName, zOld) ){",
          "",
          "[Added Lines]",
          "954:       char *zName = pEList->a[i].zEName;",
          "955:       if( ALWAYS(pEList->a[i].eEName==ENAME_NAME)",
          "956:        && ALWAYS(zName!=0)",
          "957:        && 0==sqlite3_stricmp(zName, zOld)",
          "958:       ){",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3107:   nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;",
          "3108:   if( pToCol ){",
          "3109:     for(i=0; i<pToCol->nExpr; i++){",
          "3111:     }",
          "3112:   }",
          "3113:   pFKey = sqlite3DbMallocZero(db, nByte );",
          "",
          "[Removed Lines]",
          "3110:       nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;",
          "",
          "[Added Lines]",
          "3110:       nByte += sqlite3Strlen30(pToCol->a[i].zEName) + 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3132:     for(i=0; i<nCol; i++){",
          "3133:       int j;",
          "3134:       for(j=0; j<p->nCol; j++){",
          "3136:           pFKey->aCol[i].iFrom = j;",
          "3137:           break;",
          "3138:         }",
          "",
          "[Removed Lines]",
          "3135:         if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName)==0 ){",
          "",
          "[Added Lines]",
          "3135:         if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zEName)==0 ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3140:       if( j>=p->nCol ){",
          "3141:         sqlite3ErrorMsg(pParse,",
          "3142:           \"unknown column \\\"%s\\\" in foreign key definition\",",
          "3144:         goto fk_end;",
          "3145:       }",
          "3146:       if( IN_RENAME_OBJECT ){",
          "3148:       }",
          "3149:     }",
          "3150:   }",
          "3151:   if( pToCol ){",
          "3152:     for(i=0; i<nCol; i++){",
          "3154:       pFKey->aCol[i].zCol = z;",
          "3155:       if( IN_RENAME_OBJECT ){",
          "3157:       }",
          "3159:       z[n] = 0;",
          "3160:       z += n+1;",
          "3161:     }",
          "",
          "[Removed Lines]",
          "3143:           pFromCol->a[i].zName);",
          "3147:         sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zName);",
          "3153:       int n = sqlite3Strlen30(pToCol->a[i].zName);",
          "3156:         sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zName);",
          "3158:       memcpy(z, pToCol->a[i].zName, n);",
          "",
          "[Added Lines]",
          "3143:           pFromCol->a[i].zEName);",
          "3147:         sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zEName);",
          "3153:       int n = sqlite3Strlen30(pToCol->a[i].zEName);",
          "3156:         sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zEName);",
          "3158:       memcpy(z, pToCol->a[i].zEName, n);",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1440:         pNewExpr->pLeft = pPriorSelectCol;",
          "1441:       }",
          "1442:     }",
          "1445:     pItem->sortFlags = pOldItem->sortFlags;",
          "1446:     pItem->done = 0;",
          "1447:     pItem->bNulls = pOldItem->bNulls;",
          "1449:     pItem->bSorterRef = pOldItem->bSorterRef;",
          "1450:     pItem->u = pOldItem->u;",
          "1451:   }",
          "",
          "[Removed Lines]",
          "1443:     pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);",
          "1444:     pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);",
          "1448:     pItem->bSpanIsTab = pOldItem->bSpanIsTab;",
          "",
          "[Added Lines]",
          "1443:     pItem->zEName = sqlite3DbStrDup(db, pOldItem->zEName);",
          "1445:     pItem->eEName = pOldItem->eEName;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1612:     pList = pNew;",
          "1613:   }",
          "1614:   pItem = &pList->a[pList->nExpr++];",
          "1616:   assert( offsetof(struct ExprList_item,pExpr)==0 );",
          "1618:   pItem->pExpr = pExpr;",
          "1619:   return pList;",
          "",
          "[Removed Lines]",
          "1615:   assert( offsetof(struct ExprList_item,zName)==sizeof(pItem->pExpr) );",
          "1617:   memset(&pItem->zName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zName));",
          "",
          "[Added Lines]",
          "1614:   assert( offsetof(struct ExprList_item,zEName)==sizeof(pItem->pExpr) );",
          "1616:   memset(&pItem->zEName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zEName));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1671:     pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);",
          "1672:     if( pList ){",
          "1673:       assert( pList->nExpr==iFirst+i+1 );",
          "1675:       pColumns->a[i].zName = 0;",
          "1676:     }",
          "1677:   }",
          "",
          "[Removed Lines]",
          "1674:       pList->a[pList->nExpr-1].zName = pColumns->a[i].zName;",
          "",
          "[Added Lines]",
          "1673:       pList->a[pList->nExpr-1].zEName = pColumns->a[i].zName;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1749:     struct ExprList_item *pItem;",
          "1750:     assert( pList->nExpr>0 );",
          "1751:     pItem = &pList->a[pList->nExpr-1];",
          "1755:     if( IN_RENAME_OBJECT ){",
          "1757:     }",
          "1758:   }",
          "1759: }",
          "",
          "[Removed Lines]",
          "1752:     assert( pItem->zName==0 );",
          "1753:     pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);",
          "1754:     if( dequote ) sqlite3Dequote(pItem->zName);",
          "1756:       sqlite3RenameTokenMap(pParse, (void*)pItem->zName, pName);",
          "",
          "[Added Lines]",
          "1751:     assert( pItem->zEName==0 );",
          "1752:     assert( pItem->eEName==ENAME_NAME );",
          "1753:     pItem->zEName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);",
          "1754:     if( dequote ) sqlite3Dequote(pItem->zEName);",
          "1756:       sqlite3RenameTokenMap(pParse, (void*)pItem->zEName, pName);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1777:   if( pList ){",
          "1778:     struct ExprList_item *pItem = &pList->a[pList->nExpr-1];",
          "1779:     assert( pList->nExpr>0 );",
          "1782:   }",
          "1783: }",
          "",
          "[Removed Lines]",
          "1780:     sqlite3DbFree(db, pItem->zSpan);",
          "1781:     pItem->zSpan = sqlite3DbSpanDup(db, zStart, zEnd);",
          "",
          "[Added Lines]",
          "1780:     if( pItem->zEName==0 ){",
          "1781:       pItem->zEName = sqlite3DbSpanDup(db, zStart, zEnd);",
          "1782:       pItem->eEName = ENAME_SPAN;",
          "1783:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1808:   assert( pList->nExpr>0 );",
          "1809:   do{",
          "1810:     sqlite3ExprDelete(db, pItem->pExpr);",
          "1813:     pItem++;",
          "1814:   }while( --i>0 );",
          "1815:   sqlite3DbFreeNN(db, pList);",
          "",
          "[Removed Lines]",
          "1811:     sqlite3DbFree(db, pItem->zName);",
          "1812:     sqlite3DbFree(db, pItem->zSpan);",
          "",
          "[Added Lines]",
          "1813:     sqlite3DbFree(db, pItem->zEName);",
          "",
          "---------------"
        ],
        "src/global.c||src/global.c": [
          "File: src/global.c -> src/global.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "194: #ifndef SQLITE_DEFAULT_LOOKASIDE",
          "196: #endif",
          "",
          "[Removed Lines]",
          "195: # define SQLITE_DEFAULT_LOOKASIDE 1200,100",
          "",
          "[Added Lines]",
          "200: # ifdef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "202: # else",
          "204: # endif",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1673:       if( onError==OE_Ignore ){",
          "1674:         sqlite3VdbeGoto(v, ignoreDest);",
          "1675:       }else{",
          "1677:         if( zName==0 ) zName = pTab->zName;",
          "1679:         sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_CHECK,",
          "",
          "[Removed Lines]",
          "1676:         char *zName = pCheck->a[i].zName;",
          "",
          "[Added Lines]",
          "1676:         char *zName = pCheck->a[i].zEName;",
          "",
          "---------------"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "683: static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){",
          "684: #ifndef SQLITE_OMIT_LOOKASIDE",
          "685:   void *pStart;",
          "687:   if( sqlite3LookasideUsed(db,0)>0 ){",
          "688:     return SQLITE_BUSY;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "686:   sqlite3_int64 szAlloc = sz*(sqlite3_int64)cnt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "705:     pStart = 0;",
          "706:   }else if( pBuf==0 ){",
          "707:     sqlite3BeginBenignMalloc();",
          "709:     sqlite3EndBenignMalloc();",
          "711:   }else{",
          "712:     pStart = pBuf;",
          "713:   }",
          "714:   db->lookaside.pStart = pStart;",
          "715:   db->lookaside.pInit = 0;",
          "716:   db->lookaside.pFree = 0;",
          "",
          "[Removed Lines]",
          "710:     if( pStart ) cnt = sqlite3MallocSize(pStart)/sz;",
          "",
          "[Added Lines]",
          "713:     if( pStart ) szAlloc = sqlite3MallocSize(pStart);",
          "717: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "718:   if( sz>=LOOKASIDE_SMALL*3 ){",
          "719:     nBig = szAlloc/(3*LOOKASIDE_SMALL+sz);",
          "720:     nSm = (szAlloc - sz*nBig)/LOOKASIDE_SMALL;",
          "721:   }else if( sz>=LOOKASIDE_SMALL*2 ){",
          "722:     nBig = szAlloc/(LOOKASIDE_SMALL+sz);",
          "723:     nSm = (szAlloc - sz*nBig)/LOOKASIDE_SMALL;",
          "724:   }else",
          "726:   if( sz>0 ){",
          "727:     nBig = szAlloc/sz;",
          "728:     nSm = 0;",
          "729:   }else{",
          "730:     nBig = nSm = 0;",
          "731:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "720:     int i;",
          "721:     LookasideSlot *p;",
          "722:     assert( sz > (int)sizeof(LookasideSlot*) );",
          "724:     p = (LookasideSlot*)pStart;",
          "726:       p->pNext = db->lookaside.pInit;",
          "727:       db->lookaside.pInit = p;",
          "728:       p = (LookasideSlot*)&((u8*)p)[sz];",
          "729:     }",
          "730:     db->lookaside.pEnd = p;",
          "731:     db->lookaside.bDisable = 0;",
          "732:     db->lookaside.bMalloced = pBuf==0 ?1:0;",
          "733:   }else{",
          "734:     db->lookaside.pStart = db;",
          "735:     db->lookaside.pEnd = db;",
          "736:     db->lookaside.bDisable = 1;",
          "737:     db->lookaside.sz = 0;",
          "738:     db->lookaside.bMalloced = 0;",
          "739:     db->lookaside.nSlot = 0;",
          "740:   }",
          "742:   return SQLITE_OK;",
          "743: }",
          "",
          "[Removed Lines]",
          "723:     db->lookaside.nSlot = cnt;",
          "725:     for(i=cnt-1; i>=0; i--){",
          "",
          "[Added Lines]",
          "742:     for(i=0; i<nBig; i++){",
          "747: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "748:     db->lookaside.pSmallInit = 0;",
          "749:     db->lookaside.pSmallFree = 0;",
          "750:     db->lookaside.pMiddle = p;",
          "751:     for(i=0; i<nSm; i++){",
          "752:       p->pNext = db->lookaside.pSmallInit;",
          "753:       db->lookaside.pSmallInit = p;",
          "754:       p = (LookasideSlot*)&((u8*)p)[LOOKASIDE_SMALL];",
          "755:     }",
          "757:     assert( ((uptr)p)<=szAlloc + (uptr)pStart );",
          "761:     db->lookaside.nSlot = nBig+nSm;",
          "764: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "765:     db->lookaside.pSmallInit = 0;",
          "766:     db->lookaside.pSmallFree = 0;",
          "767:     db->lookaside.pMiddle = db;",
          "775:   assert( sqlite3LookasideUsed(db,0)==0 );",
          "",
          "---------------"
        ],
        "src/malloc.c||src/malloc.c": [
          "File: src/malloc.c -> src/malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "332:   assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );",
          "333:   return sqlite3GlobalConfig.m.xSize(p);",
          "334: }",
          "335: int sqlite3DbMallocSize(sqlite3 *db, void *p){",
          "336:   assert( p!=0 );",
          "338: #ifdef SQLITE_DEBUG",
          "339:     if( db==0 ){",
          "340:       assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );",
          "341:       assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );",
          "",
          "[Removed Lines]",
          "337:   if( db==0 || !isLookaside(db,p) ){",
          "",
          "[Added Lines]",
          "335: static int lookasideMallocSize(sqlite3 *db, void *p){",
          "336: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "337:   return p<db->lookaside.pMiddle ? db->lookaside.szTrue : LOOKASIDE_SMALL;",
          "338: #else",
          "339:   return db->lookaside.szTrue;",
          "340: #endif",
          "341: }",
          "345:   if( db==0 || !isLookaside(db,p) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "343:       assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );",
          "344:       assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );",
          "345:     }",
          "346: #endif",
          "351:   }",
          "352: }",
          "353: sqlite3_uint64 sqlite3_msize(void *p){",
          "354:   assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );",
          "",
          "[Removed Lines]",
          "347:     return sqlite3GlobalConfig.m.xSize(p);",
          "348:   }else{",
          "349:     assert( sqlite3_mutex_held(db->mutex) );",
          "350:     return db->lookaside.szTrue;",
          "",
          "[Added Lines]",
          "353:   }",
          "355:   if( db ){",
          "356:     if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){",
          "357: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "358:       if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){",
          "359:         assert( sqlite3_mutex_held(db->mutex) );",
          "360:         return LOOKASIDE_SMALL;",
          "361:       }",
          "362: #endif",
          "363:       if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){",
          "364:         assert( sqlite3_mutex_held(db->mutex) );",
          "365:         return db->lookaside.szTrue;",
          "366:       }",
          "367:     }",
          "369:   return sqlite3GlobalConfig.m.xSize(p);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "395:       measureAllocationSize(db, p);",
          "396:       return;",
          "397:     }",
          "400: #ifdef SQLITE_DEBUG",
          "403: #endif",
          "407:     }",
          "408:   }",
          "409:   assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );",
          "",
          "[Removed Lines]",
          "398:     if( isLookaside(db, p) ){",
          "399:       LookasideSlot *pBuf = (LookasideSlot*)p;",
          "402:       memset(p, 0xaa, db->lookaside.szTrue);",
          "404:       pBuf->pNext = db->lookaside.pFree;",
          "405:       db->lookaside.pFree = pBuf;",
          "406:       return;",
          "",
          "[Added Lines]",
          "416:     if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){",
          "417: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "418:       if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){",
          "419:         LookasideSlot *pBuf = (LookasideSlot*)p;",
          "423:         pBuf->pNext = db->lookaside.pSmallFree;",
          "424:         db->lookaside.pSmallFree = pBuf;",
          "425:         return;",
          "426:       }",
          "428:       if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){",
          "429:         LookasideSlot *pBuf = (LookasideSlot*)p;",
          "430: #ifdef SQLITE_DEBUG",
          "432: #endif",
          "433:         pBuf->pNext = db->lookaside.pFree;",
          "434:         db->lookaside.pFree = pBuf;",
          "435:         return;",
          "436:       }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "560:   assert( sqlite3_mutex_held(db->mutex) );",
          "561:   assert( db->pnBytesFreed==0 );",
          "562:   if( n>db->lookaside.sz ){",
          "565:     }",
          "568:     db->lookaside.pFree = pBuf->pNext;",
          "569:     db->lookaside.anStat[0]++;",
          "570:     return (void*)pBuf;",
          "",
          "[Removed Lines]",
          "563:     if( db->lookaside.bDisable ){",
          "564:       return db->mallocFailed ? 0 : dbMallocRawFinish(db, n);",
          "566:     db->lookaside.anStat[1]++;",
          "567:   }else if( (pBuf = db->lookaside.pFree)!=0 ){",
          "",
          "[Added Lines]",
          "593:     if( !db->lookaside.bDisable ){",
          "594:       db->lookaside.anStat[1]++;",
          "595:     }else if( db->mallocFailed ){",
          "596:       return 0;",
          "597:     }",
          "598:     return dbMallocRawFinish(db, n);",
          "599:   }",
          "600: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "601:   if( n<=LOOKASIDE_SMALL ){",
          "602:     if( (pBuf = db->lookaside.pSmallFree)!=0 ){",
          "603:       db->lookaside.pSmallFree = pBuf->pNext;",
          "604:       db->lookaside.anStat[0]++;",
          "605:       return (void*)pBuf;",
          "606:     }else if( (pBuf = db->lookaside.pSmallInit)!=0 ){",
          "607:       db->lookaside.pSmallInit = pBuf->pNext;",
          "608:       db->lookaside.anStat[0]++;",
          "609:       return (void*)pBuf;",
          "611:   }",
          "612: #endif",
          "613:   if( (pBuf = db->lookaside.pFree)!=0 ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "597:   assert( db!=0 );",
          "598:   if( p==0 ) return sqlite3DbMallocRawNN(db, n);",
          "599:   assert( sqlite3_mutex_held(db->mutex) );",
          "601:   return dbReallocFinish(db, p, n);",
          "602: }",
          "603: static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){",
          "",
          "[Removed Lines]",
          "600:   if( isLookaside(db,p) && n<=db->lookaside.szTrue ) return p;",
          "",
          "[Added Lines]",
          "646:   if( ((uptr)p)<(uptr)db->lookaside.pEnd ){",
          "647: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "648:     if( ((uptr)p)>=(uptr)db->lookaside.pMiddle ){",
          "649:       if( n<=LOOKASIDE_SMALL ) return p;",
          "650:     }else",
          "651: #endif",
          "652:     if( ((uptr)p)>=(uptr)db->lookaside.pStart ){",
          "653:       if( n<=db->lookaside.szTrue ) return p;",
          "654:     }",
          "655:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "608:     if( isLookaside(db, p) ){",
          "609:       pNew = sqlite3DbMallocRawNN(db, n);",
          "610:       if( pNew ){",
          "612:         sqlite3DbFree(db, p);",
          "613:       }",
          "614:     }else{",
          "",
          "[Removed Lines]",
          "611:         memcpy(pNew, p, db->lookaside.szTrue);",
          "",
          "[Added Lines]",
          "666:         memcpy(pNew, p, lookasideMallocSize(db, p));",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "137:   const char *zCol,",
          "138:   const char *zTab,",
          "139:   const char *zDb",
          "140: ){",
          "141:   int n;",
          "142:   for(n=0; ALWAYS(zSpan[n]) && zSpan[n]!='.'; n++){}",
          "143:   if( zDb && (sqlite3StrNICmp(zSpan, zDb, n)!=0 || zDb[n]!=0) ){",
          "144:     return 0;",
          "",
          "[Removed Lines]",
          "135: int sqlite3MatchSpanName(",
          "136:   const char *zSpan,",
          "",
          "[Added Lines]",
          "135: int sqlite3MatchEName(",
          "136:   const struct ExprList_item *pItem,",
          "142:   const char *zSpan;",
          "143:   if( NEVER(pItem->eEName!=ENAME_TAB) ) return 0;",
          "144:   zSpan = pItem->zEName;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "267:           int hit = 0;",
          "268:           pEList = pItem->pSelect->pEList;",
          "269:           for(j=0; j<pEList->nExpr; j++){",
          "271:               cnt++;",
          "272:               cntTab = 2;",
          "273:               pMatch = pItem;",
          "",
          "[Removed Lines]",
          "270:             if( sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb) ){",
          "",
          "[Added Lines]",
          "273:             if( sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb) ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:       pEList = pNC->uNC.pEList;",
          "449:       assert( pEList!=0 );",
          "450:       for(j=0; j<pEList->nExpr; j++){",
          "453:           Expr *pOrig;",
          "454:           assert( pExpr->pLeft==0 && pExpr->pRight==0 );",
          "455:           assert( pExpr->x.pList==0 );",
          "",
          "[Removed Lines]",
          "451:         char *zAs = pEList->a[j].zName;",
          "452:         if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){",
          "",
          "[Added Lines]",
          "454:         char *zAs = pEList->a[j].zEName;",
          "455:         if( pEList->a[j].eEName==ENAME_NAME",
          "456:          && ALWAYS(zAs!=0)",
          "457:          && sqlite3StrICmp(zAs, zCol)==0",
          "458:         ){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1117:   if( pE->op==TK_ID ){",
          "1118:     char *zCol = pE->u.zToken;",
          "1119:     for(i=0; i<pEList->nExpr; i++){",
          "1122:         return i+1;",
          "1123:       }",
          "1124:     }",
          "",
          "[Removed Lines]",
          "1120:       char *zAs = pEList->a[i].zName;",
          "1121:       if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){",
          "",
          "[Added Lines]",
          "1126:       char *zAs = pEList->a[i].zEName;",
          "1127:       if( pEList->a[i].eEName==ENAME_NAME",
          "1128:        && ALWAYS(zAs!=0)",
          "1129:        && sqlite3StrICmp(zAs, zCol)==0",
          "1130:       ){",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "939:   if( srcTab>=0 ){",
          "940:     for(i=0; i<nResultCol; i++){",
          "941:       sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i);",
          "943:     }",
          "944:   }else if( eDest!=SRT_Exists ){",
          "945: #ifdef SQLITE_ENABLE_SORTER_REFERENCES",
          "",
          "[Removed Lines]",
          "942:       VdbeComment((v, \"%s\", p->pEList->a[i].zName));",
          "",
          "[Added Lines]",
          "942:       VdbeComment((v, \"%s\", p->pEList->a[i].zEName));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1560:         iRead = iCol--;",
          "1561:       }",
          "1562:       sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iRead, regRow+i);",
          "1564:     }",
          "1565:   }",
          "1566:   switch( eDest ){",
          "",
          "[Removed Lines]",
          "1563:       VdbeComment((v, \"%s\", aOutEx[i].zName?aOutEx[i].zName : aOutEx[i].zSpan));",
          "",
          "[Added Lines]",
          "1563:       VdbeComment((v, \"%s\", aOutEx[i].zEName));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1894:     assert( p!=0 );",
          "1900:       sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);",
          "1901:     }else if( srcName && p->op==TK_COLUMN ){",
          "1902:       char *zCol;",
          "",
          "[Removed Lines]",
          "1897:     if( pEList->a[i].zName ){",
          "1899:       char *zName = pEList->a[i].zName;",
          "",
          "[Added Lines]",
          "1897:     if( pEList->a[i].zEName && pEList->a[i].eEName==ENAME_NAME ){",
          "1899:       char *zName = pEList->a[i].zEName;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1918:         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);",
          "1919:       }",
          "1920:     }else{",
          "1922:       z = z==0 ? sqlite3MPrintf(db, \"column%d\", i+1) : sqlite3DbStrDup(db, z);",
          "1923:       sqlite3VdbeSetColName(v, i, COLNAME_NAME, z, SQLITE_DYNAMIC);",
          "1924:     }",
          "",
          "[Removed Lines]",
          "1921:       const char *z = pEList->a[i].zSpan;",
          "",
          "[Added Lines]",
          "1921:       const char *z = pEList->a[i].zEName;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1980:   for(i=0, pCol=aCol; i<nCol && !db->mallocFailed; i++, pCol++){",
          "1985:     }else{",
          "1986:       Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);",
          "",
          "[Removed Lines]",
          "1983:     if( (zName = pEList->a[i].zName)!=0 ){",
          "",
          "[Added Lines]",
          "1983:     if( (zName = pEList->a[i].zEName)!=0 && pEList->a[i].eEName==ENAME_NAME ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2000:         zName = pColExpr->u.zToken;",
          "2001:       }else{",
          "2004:       }",
          "2005:     }",
          "2006:     if( zName ){",
          "",
          "[Removed Lines]",
          "2003:         zName = pEList->a[i].zSpan;",
          "",
          "[Added Lines]",
          "2003:         zName = pEList->a[i].zEName;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5032:         pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);",
          "5033:         if( pNew ){",
          "5038:         }",
          "5039:         a[k].pExpr = 0;",
          "5040:       }else{",
          "",
          "[Removed Lines]",
          "5034:           pNew->a[pNew->nExpr-1].zName = a[k].zName;",
          "5035:           pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;",
          "5036:           a[k].zName = 0;",
          "5037:           a[k].zSpan = 0;",
          "",
          "[Added Lines]",
          "5034:           pNew->a[pNew->nExpr-1].zEName = a[k].zEName;",
          "5035:           pNew->a[pNew->nExpr-1].eEName = a[k].eEName;",
          "5036:           a[k].zEName = 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5074:             assert( zName );",
          "5075:             if( zTName && pSub",
          "5077:             ){",
          "5078:               continue;",
          "5079:             }",
          "",
          "[Removed Lines]",
          "5076:              && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0",
          "",
          "[Added Lines]",
          "5075:              && sqlite3MatchEName(&pSub->pEList->a[j], 0, zTName, 0)==0",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5126:             sqlite3ExprListSetName(pParse, pNew, &sColname, 0);",
          "5127:             if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){",
          "5128:               struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];",
          "5129:               if( pSub ){",
          "5132:               }else{",
          "5134:                                            zSchemaName, zTabName, zColname);",
          "5136:               }",
          "5138:             }",
          "5139:             sqlite3DbFree(db, zToFree);",
          "5140:           }",
          "",
          "[Removed Lines]",
          "5130:                 pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);",
          "5131:                 testcase( pX->zSpan==0 );",
          "5133:                 pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",",
          "5135:                 testcase( pX->zSpan==0 );",
          "5137:               pX->bSpanIsTab = 1;",
          "",
          "[Added Lines]",
          "5128:               sqlite3DbFree(db, pX->zEName);",
          "5130:                 pX->zEName = sqlite3DbStrDup(db, pSub->pEList->a[j].zEName);",
          "5131:                 testcase( pX->zEName==0 );",
          "5133:                 pX->zEName = sqlite3MPrintf(db, \"%s.%s.%s\",",
          "5135:                 testcase( pX->zEName==0 );",
          "5137:               pX->eEName = ENAME_TAB;",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1312: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1329: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "1332:   void *pMiddle;          /* First byte past end of full-size buffers and",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1318: #define EnableLookaside   db->lookaside.bDisable--;\\",
          "1319:    db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1347: #ifdef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "1348: #  define LOOKASIDE_SMALL           0",
          "1349: #else",
          "1350: #  define LOOKASIDE_SMALL         128",
          "1351: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4461: int sqlite3CodeSubselect(Parse*, Expr*);",
          "4462: void sqlite3SelectPrep(Parse*, Select*, NameContext*);",
          "4463: void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);",
          "4465: int sqlite3ResolveExprNames(NameContext*, Expr*);",
          "4466: int sqlite3ResolveExprListNames(NameContext*, ExprList*);",
          "4467: void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);",
          "",
          "[Removed Lines]",
          "4464: int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);",
          "",
          "[Added Lines]",
          "4508: int sqlite3MatchEName(",
          "4509:   const struct ExprList_item*,",
          "4510:   const char*,",
          "4511:   const char*,",
          "4512:   const char*",
          "4513: );",
          "",
          "---------------"
        ],
        "src/status.c||src/status.c": [
          "File: src/status.c -> src/status.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: int sqlite3LookasideUsed(sqlite3 *db, int *pHighwater){",
          "189:   u32 nInit = countLookasideSlots(db->lookaside.pInit);",
          "190:   u32 nFree = countLookasideSlots(db->lookaside.pFree);",
          "191:   if( pHighwater ) *pHighwater = db->lookaside.nSlot - nInit;",
          "192:   return db->lookaside.nSlot - (nInit+nFree);",
          "193: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "192:   nInit += countLookasideSlots(db->lookaside.pSmallInit);",
          "193:   nFree += countLookasideSlots(db->lookaside.pSmallFree);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:           db->lookaside.pInit = db->lookaside.pFree;",
          "221:           db->lookaside.pFree = 0;",
          "222:         }",
          "223:       }",
          "224:       break;",
          "225:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227: #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE",
          "228:         p = db->lookaside.pSmallFree;",
          "229:         if( p ){",
          "230:           while( p->pNext ) p = p->pNext;",
          "231:           p->pNext = db->lookaside.pSmallInit;",
          "232:           db->lookaside.pSmallInit = db->lookaside.pSmallFree;",
          "233:           db->lookaside.pSmallFree = 0;",
          "234:         }",
          "235: #endif",
          "",
          "---------------"
        ],
        "src/treeview.c||src/treeview.c": [
          "File: src/treeview.c -> src/treeview.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:         char cSep = '(';",
          "107:         int j;",
          "108:         for(j=0; j<pCte->pCols->nExpr; j++){",
          "110:           cSep = ',';",
          "111:         }",
          "112:         sqlite3_str_appendf(&x, \")\");",
          "",
          "[Removed Lines]",
          "109:           sqlite3_str_appendf(&x, \"%c%s\", cSep, pCte->pCols->a[j].zName);",
          "",
          "[Added Lines]",
          "109:           sqlite3_str_appendf(&x, \"%c%s\", cSep, pCte->pCols->a[j].zEName);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "728:     sqlite3TreeViewLine(pView, \"%s\", zLabel);",
          "729:     for(i=0; i<pList->nExpr; i++){",
          "730:       int j = pList->a[i].u.x.iOrderByCol;",
          "732:       int moreToFollow = i<pList->nExpr - 1;",
          "733:       if( j || zName ){",
          "734:         sqlite3TreeViewPush(pView, moreToFollow);",
          "",
          "[Removed Lines]",
          "731:       char *zName = pList->a[i].zName;",
          "",
          "[Added Lines]",
          "731:       char *zName = pList->a[i].zEName;",
          "",
          "---------------"
        ],
        "src/trigger.c||src/trigger.c": [
          "File: src/trigger.c -> src/trigger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "688:   int e;",
          "689:   if( pIdList==0 || NEVER(pEList==0) ) return 1;",
          "690:   for(e=0; e<pEList->nExpr; e++){",
          "692:   }",
          "693:   return 0;",
          "694: }",
          "",
          "[Removed Lines]",
          "691:     if( sqlite3IdListIndex(pIdList, pEList->a[e].zName)>=0 ) return 1;",
          "",
          "[Added Lines]",
          "691:     if( sqlite3IdListIndex(pIdList, pEList->a[e].zEName)>=0 ) return 1;",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "306:       goto update_cleanup;",
          "307:     }",
          "308:     for(j=0; j<pTab->nCol; j++){",
          "310:         if( j==pTab->iPKey ){",
          "311:           chngRowid = 1;",
          "312:           pRowidExpr = pChanges->a[i].pExpr;",
          "",
          "[Removed Lines]",
          "309:       if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zName)==0 ){",
          "",
          "[Added Lines]",
          "309:       if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zEName)==0 ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "328:       }",
          "329:     }",
          "330:     if( j>=pTab->nCol ){",
          "332:         j = -1;",
          "333:         chngRowid = 1;",
          "334:         pRowidExpr = pChanges->a[i].pExpr;",
          "335:       }else{",
          "337:         pParse->checkSchema = 1;",
          "338:         goto update_cleanup;",
          "339:       }",
          "",
          "[Removed Lines]",
          "331:       if( pPk==0 && sqlite3IsRowid(pChanges->a[i].zName) ){",
          "336:         sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zName);",
          "",
          "[Added Lines]",
          "331:       if( pPk==0 && sqlite3IsRowid(pChanges->a[i].zEName) ){",
          "336:         sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zEName);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5c193464510c43ef55f806adb8c5807c294a6b8a",
      "candidate_info": {
        "commit_hash": "5c193464510c43ef55f806adb8c5807c294a6b8a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/5c193464510c43ef55f806adb8c5807c294a6b8a",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/analyzeG.test"
        ],
        "message": "Add new test file analyzeG.test, containing a test for the change on this branch.\n\nFossilOrigin-Name: 243ab1852a2291595527ea1f26e78ad83eda285ae28f876bc1c703677f495cfa",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/analyzeG.test||test/analyzeG.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1babd6ec5d60e2c34aa1c0285ead768a88004218468e97262411973fe3487022",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/analyzeG.test||test/analyzeG.test": [
          "File: test/analyzeG.test -> test/analyzeG.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020-02-23",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # Tests for functionality related to ANALYZE.",
          "12: #",
          "14: set testdir [file dirname $argv0]",
          "15: source $testdir/tester.tcl",
          "17: set testprefix analyzeG",
          "19: proc do_scan_order_test {tn sql expect} {",
          "20:   uplevel [list do_test $tn [subst -nocommands {",
          "21:     set res \"\"",
          "22:     db eval \"explain query plan $sql\" {",
          "23:       lappend res [set detail]",
          "24:     }",
          "25:     set res",
          "26:   }] [list {*}$expect]]",
          "27: }",
          "29: #-------------------------------------------------------------------------",
          "30: # Test cases 1.* seek to verify that even if an index is not used, its",
          "31: # stat4 data may be used by the planner to estimate the number of",
          "32: # rows that match an unindexed constraint on the same column.",
          "33: #",
          "34: do_execsql_test 1.0 {",
          "35:   PRAGMA automatic_index = 0;",
          "36:   CREATE TABLE t1(a, x);",
          "37:   CREATE TABLE t2(b, y);",
          "38:   WITH s(i) AS (",
          "39:     SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<100",
          "40:   )",
          "41:   INSERT INTO t1 SELECT (i%50), NULL FROM s;",
          "42:   WITH s(i) AS (",
          "43:     SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<100",
          "44:   )",
          "45:   INSERT INTO t2 SELECT (CASE WHEN i<95 THEN 44 ELSE i END), NULL FROM s;",
          "46: }",
          "48: # Join tables t1 and t2. Both contain 100 rows. (a=44) matches 2 rows",
          "49: # in \"t1\", (b=44) matches 95 rows in table \"t2\". But the planner doesn't",
          "50: # know this, so it has no preference as to which order the tables are",
          "51: # scanned in. In practice this means that tables are scanned in the order",
          "52: # they are specified in in the FROM clause.",
          "53: do_scan_order_test 1.1.1 {",
          "54:   SELECT * FROM t1, t2 WHERE a=44 AND b=44;",
          "55: } {",
          "56:   {SCAN TABLE t1} {SCAN TABLE t2}",
          "57: }",
          "58: do_scan_order_test 1.1.2 {",
          "59:   SELECT * FROM t2, t1 WHERE a=44 AND b=44",
          "60: } {",
          "61:   {SCAN TABLE t2} {SCAN TABLE t1}",
          "62: }",
          "64: do_execsql_test 1.2 {",
          "65:   CREATE INDEX t2b ON t2(b);",
          "66:   ANALYZE;",
          "67: }",
          "69: # Now, with the ANALYZE data, the planner knows that (b=44) matches a",
          "70: # large number of rows. So it elects to scan table \"t1\" first, regardless",
          "71: # of the order in which the tables are specified in the FROM clause.",
          "72: do_scan_order_test 1.3.1 {",
          "73:   SELECT * FROM t1, t2 WHERE a=44 AND b=44;",
          "74: } {",
          "75:   {SCAN TABLE t1} {SCAN TABLE t2}",
          "76: }",
          "77: do_scan_order_test 1.3.2 {",
          "78:   SELECT * FROM t2, t1 WHERE a=44 AND b=44",
          "79: } {",
          "80:   {SCAN TABLE t1} {SCAN TABLE t2}",
          "81: }",
          "84: finish_test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "892edb69c4f1071b682d88d13be45f7faa980f63",
      "candidate_info": {
        "commit_hash": "892edb69c4f1071b682d88d13be45f7faa980f63",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/892edb69c4f1071b682d88d13be45f7faa980f63",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/main.c",
          "src/malloc.c",
          "src/sqliteInt.h",
          "src/tokenize.c",
          "src/vdbe.c",
          "src/vdbeapi.c",
          "src/vdbeaux.c",
          "src/wal.c"
        ],
        "message": "Use __atomic_load_n() and __atomic_store_n() for a few more things where they are available.\n\nFossilOrigin-Name: a49f8ec552bede7da731e0571ccf49de1a30e7be3a5673150436c8b411ba6ffc",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/main.c||src/main.c",
          "src/malloc.c||src/malloc.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/tokenize.c||src/tokenize.c",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbeapi.c||src/vdbeapi.c",
          "src/vdbeaux.c||src/vdbeaux.c",
          "src/wal.c||src/wal.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: fbd9378727141848ba2f5a8eee3076ecbd315e4a87b264c6d890103d56b2e4bc",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "9533:   while( rc==SQLITE_OK && !db->u1.isInterrupted ){",
          "",
          "[Added Lines]",
          "9533:   while( rc==SQLITE_OK && !AtomicLoad(&db->u1.isInterrupted) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9656:     checkAppendMsg(pCheck, \"2nd reference to page %d\", iPage);",
          "9657:     return 1;",
          "9658:   }",
          "9660:   setPageReferenced(pCheck, iPage);",
          "9661:   return 0;",
          "9662: }",
          "",
          "[Removed Lines]",
          "9659:   if( pCheck->db->u1.isInterrupted ) return 1;",
          "",
          "[Added Lines]",
          "9659:   if( AtomicLoad(&pCheck->db->u1.isInterrupted) ) return 1;",
          "",
          "---------------"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1733:     return;",
          "1734:   }",
          "1735: #endif",
          "1737: }",
          "",
          "[Removed Lines]",
          "1736:   db->u1.isInterrupted = 1;",
          "",
          "[Added Lines]",
          "1736:   AtomicStore(&db->u1.isInterrupted, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2357:   if( db->nVdbeActive==0 ){",
          "2359:   }",
          "2361:   sqlite3_mutex_leave(db->mutex);",
          "",
          "[Removed Lines]",
          "2358:     db->u1.isInterrupted = 0;",
          "",
          "[Added Lines]",
          "2358:     AtomicStore(&db->u1.isInterrupted, 0);",
          "",
          "---------------"
        ],
        "src/malloc.c||src/malloc.c": [
          "File: src/malloc.c -> src/malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "760:   if( db->mallocFailed==0 && db->bBenignMalloc==0 ){",
          "761:     db->mallocFailed = 1;",
          "762:     if( db->nVdbeExec>0 ){",
          "764:     }",
          "765:     DisableLookaside;",
          "766:     if( db->pParse ){",
          "",
          "[Removed Lines]",
          "763:       db->u1.isInterrupted = 1;",
          "",
          "[Added Lines]",
          "763:       AtomicStore(&db->u1.isInterrupted, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "779: void sqlite3OomClear(sqlite3 *db){",
          "780:   if( db->mallocFailed && db->nVdbeExec==0 ){",
          "781:     db->mallocFailed = 0;",
          "783:     assert( db->lookaside.bDisable>0 );",
          "784:     EnableLookaside;",
          "785:   }",
          "",
          "[Removed Lines]",
          "782:     db->u1.isInterrupted = 0;",
          "",
          "[Added Lines]",
          "782:     AtomicStore(&db->u1.isInterrupted, 0);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "187: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: #ifndef __has_feature",
          "195: #endif",
          "196: #if GCC_VERSION>=4007000 || __has_feature(c_atomic)",
          "197: # define AtomicLoad(PTR)       __atomic_load_n((PTR),__ATOMIC_RELAXED)",
          "198: # define AtomicStore(PTR,VAL)  __atomic_store_n((PTR),(VAL),__ATOMIC_RELAXED)",
          "199: #else",
          "200: # define AtomicLoad(PTR)       (*(PTR))",
          "201: # define AtomicStore(PTR,VAL)  (*(PTR) = (VAL))",
          "202: #endif",
          "",
          "---------------"
        ],
        "src/tokenize.c||src/tokenize.c": [
          "File: src/tokenize.c -> src/tokenize.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "568:   assert( zSql!=0 );",
          "569:   mxSqlLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];",
          "570:   if( db->nVdbeActive==0 ){",
          "572:   }",
          "573:   pParse->rc = SQLITE_OK;",
          "574:   pParse->zTail = zSql;",
          "",
          "[Removed Lines]",
          "571:     db->u1.isInterrupted = 0;",
          "",
          "[Added Lines]",
          "571:     AtomicStore(&db->u1.isInterrupted, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "613:     if( tokenType>=TK_SPACE ){",
          "614:       assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );",
          "617:         pParse->rc = SQLITE_INTERRUPT;",
          "618:         break;",
          "619:       }",
          "",
          "[Removed Lines]",
          "616:       if( db->u1.isInterrupted ){",
          "",
          "[Added Lines]",
          "616:       if( AtomicLoad(&db->u1.isInterrupted) ){",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "707:   assert( p->explain==0 );",
          "708:   p->pResultSet = 0;",
          "709:   db->busyHandler.nBusy = 0;",
          "711:   sqlite3VdbeIOTraceSql(p);",
          "712: #ifdef SQLITE_DEBUG",
          "713:   sqlite3BeginBenignMalloc();",
          "",
          "[Removed Lines]",
          "710:   if( db->u1.isInterrupted ) goto abort_due_to_interrupt;",
          "",
          "[Added Lines]",
          "710:   if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "893: check_for_interrupt:",
          "895: #ifndef SQLITE_OMIT_PROGRESS_CALLBACK",
          "",
          "[Removed Lines]",
          "894:   if( db->u1.isInterrupted ) goto abort_due_to_interrupt;",
          "",
          "[Added Lines]",
          "894:   if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "8001: abort_due_to_interrupt:",
          "8003:   rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;",
          "8004:   p->rc = rc;",
          "8005:   sqlite3VdbeError(p, \"%s\", sqlite3ErrStr(rc));",
          "",
          "[Removed Lines]",
          "8002:   assert( db->u1.isInterrupted );",
          "",
          "[Added Lines]",
          "8002:   assert( AtomicLoad(&db->u1.isInterrupted) );",
          "",
          "---------------"
        ],
        "src/vdbeapi.c||src/vdbeapi.c": [
          "File: src/vdbeapi.c -> src/vdbeapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "665:     if( db->nVdbeActive==0 ){",
          "667:     }",
          "669:     assert( db->nVdbeWrite>0 || db->autoCommit==0",
          "",
          "[Removed Lines]",
          "666:       db->u1.isInterrupted = 0;",
          "",
          "[Added Lines]",
          "666:       AtomicStore(&db->u1.isInterrupted, 0);",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2093:   }",
          "2095:   if( rc==SQLITE_OK ){",
          "2097:       p->rc = SQLITE_INTERRUPT;",
          "2098:       rc = SQLITE_ERROR;",
          "2099:       sqlite3VdbeError(p, sqlite3ErrStr(p->rc));",
          "",
          "[Removed Lines]",
          "2096:     if( db->u1.isInterrupted ){",
          "",
          "[Added Lines]",
          "2096:     if( AtomicLoad(&db->u1.isInterrupted) ){",
          "",
          "---------------"
        ],
        "src/wal.c||src/wal.c": [
          "File: src/wal.c -> src/wal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "258: # define WALTRACE(X)",
          "259: #endif",
          "",
          "[Removed Lines]",
          "265: #if GCC_VERSION>=5004000",
          "266: # define AtomicLoad(PTR)       __atomic_load_n((PTR),__ATOMIC_RELAXED)",
          "267: # define AtomicStore(PTR,VAL)  __atomic_store_n((PTR),(VAL),__ATOMIC_RELAXED)",
          "268: #else",
          "269: # define AtomicLoad(PTR)       (*(PTR))",
          "270: # define AtomicStore(PTR,VAL)  (*(PTR) = (VAL))",
          "271: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1891:       while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){",
          "1892:         i64 iOffset;",
          "1893:         assert( walFramePgno(pWal, iFrame)==iDbpage );",
          "1895:           rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;",
          "1896:           break;",
          "1897:         }",
          "",
          "[Removed Lines]",
          "1894:         if( db->u1.isInterrupted ){",
          "",
          "[Added Lines]",
          "1882:         if( AtomicLoad(&db->u1.isInterrupted) ){",
          "",
          "---------------"
        ]
      }
    }
  ]
}
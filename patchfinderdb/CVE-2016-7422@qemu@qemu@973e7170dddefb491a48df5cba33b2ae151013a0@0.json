{
  "cve_id": "CVE-2016-7422",
  "cve_desc": "The virtqueue_map_desc function in hw/virtio/virtio.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (NULL pointer dereference and QEMU process crash) via a large I/O descriptor buffer length value.",
  "repo": "qemu/qemu",
  "patch_hash": "973e7170dddefb491a48df5cba33b2ae151013a0",
  "patch_info": {
    "commit_hash": "973e7170dddefb491a48df5cba33b2ae151013a0",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/973e7170dddefb491a48df5cba33b2ae151013a0",
    "files": [
      "hw/virtio/virtio.c"
    ],
    "message": "virtio: add check for descriptor's mapped address\n\nvirtio back end uses set of buffers to facilitate I/O operations.\nIf its size is too large, 'cpu_physical_memory_map' could return\na null address. This would result in a null dereference while\nun-mapping descriptors. Add check to avoid it.\n\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Laszlo Ersek <lersek@redhat.com>",
    "before_after_code_files": [
      "hw/virtio/virtio.c||hw/virtio/virtio.c"
    ]
  },
  "patch_diff": {
    "hw/virtio/virtio.c||hw/virtio/virtio.c": [
      "File: hw/virtio/virtio.c -> hw/virtio/virtio.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "495:         }",
      "497:         iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);",
      "498:         iov[num_sg].iov_len = len;",
      "499:         addr[num_sg] = pa;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "498:         if (!iov[num_sg].iov_base) {",
      "499:             error_report(\"virtio: bogus descriptor or out of resources\");",
      "500:             exit(1);",
      "501:         }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ec55da192403e4a1e05f767c8762273d43ea7da4",
      "candidate_info": {
        "commit_hash": "ec55da192403e4a1e05f767c8762273d43ea7da4",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/ec55da192403e4a1e05f767c8762273d43ea7da4",
        "files": [
          "hw/virtio/virtio.c"
        ],
        "message": "virtio: handle virtqueue_map_desc() errors\n\nErrors can occur during virtqueue_pop(), especially in\nvirtqueue_map_desc().  In order to handle this we must unmap iov[]\nbefore returning NULL.  The caller will consider the virtqueue empty and\nthe virtio_error() call will have marked the device broken.\n\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>",
        "before_after_code_files": [
          "hw/virtio/virtio.c||hw/virtio/virtio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/virtio/virtio.c||hw/virtio/virtio.c"
          ],
          "candidate": [
            "hw/virtio/virtio.c||hw/virtio/virtio.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/virtio/virtio.c||hw/virtio/virtio.c": [
          "File: hw/virtio/virtio.c -> hw/virtio/virtio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "484:     return in_bytes <= in_total && out_bytes <= out_total;",
          "485: }",
          "488:                                unsigned int max_num_sg, bool is_write,",
          "489:                                hwaddr pa, size_t sz)",
          "490: {",
          "491:     unsigned num_sg = *p_num_sg;",
          "492:     assert(num_sg <= max_num_sg);",
          "494:     if (!sz) {",
          "497:     }",
          "499:     while (sz) {",
          "500:         hwaddr len = sz;",
          "502:         if (num_sg == max_num_sg) {",
          "505:         }",
          "507:         iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);",
          "508:         if (!iov[num_sg].iov_base) {",
          "511:         }",
          "513:         iov[num_sg].iov_len = len;",
          "",
          "[Removed Lines]",
          "487: static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,",
          "495:         error_report(\"virtio: zero sized buffers are not allowed\");",
          "496:         exit(1);",
          "503:             error_report(\"virtio: too many write descriptors in indirect table\");",
          "504:             exit(1);",
          "509:             error_report(\"virtio: bogus descriptor or out of resources\");",
          "510:             exit(1);",
          "",
          "[Added Lines]",
          "487: static bool virtqueue_map_desc(VirtIODevice *vdev, unsigned int *p_num_sg,",
          "488:                                hwaddr *addr, struct iovec *iov,",
          "492:     bool ok = false;",
          "497:         virtio_error(vdev, \"virtio: zero sized buffers are not allowed\");",
          "498:         goto out;",
          "505:             virtio_error(vdev, \"virtio: too many write descriptors in \"",
          "506:                                \"indirect table\");",
          "507:             goto out;",
          "512:             virtio_error(vdev, \"virtio: bogus descriptor or out of resources\");",
          "513:             goto out;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "517:         pa += len;",
          "518:         num_sg++;",
          "519:     }",
          "521: }",
          "523: static void virtqueue_map_iovec(struct iovec *sg, hwaddr *addr,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "523:     ok = true;",
          "525: out:",
          "527:     return ok;",
          "528: }",
          "534: static void virtqueue_undo_map_desc(unsigned int out_num, unsigned int in_num,",
          "535:                                     struct iovec *iov)",
          "536: {",
          "537:     unsigned int i;",
          "539:     for (i = 0; i < out_num + in_num; i++) {",
          "540:         int is_write = i >= out_num;",
          "542:         cpu_physical_memory_unmap(iov->iov_base, iov->iov_len, is_write, 0);",
          "543:         iov++;",
          "544:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "609:     max = vq->vring.num;",
          "611:     if (vq->inuse >= vq->vring.num) {",
          "614:     }",
          "616:     i = head = virtqueue_get_head(vq, vq->last_avail_idx++);",
          "",
          "[Removed Lines]",
          "612:         error_report(\"Virtqueue size exceeded\");",
          "613:         exit(1);",
          "",
          "[Added Lines]",
          "636:         virtio_error(vdev, \"Virtqueue size exceeded\");",
          "637:         return NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "621:     vring_desc_read(vdev, &desc, desc_pa, i);",
          "622:     if (desc.flags & VRING_DESC_F_INDIRECT) {",
          "623:         if (desc.len % sizeof(VRingDesc)) {",
          "626:         }",
          "",
          "[Removed Lines]",
          "624:             error_report(\"Invalid size for indirect buffer table\");",
          "625:             exit(1);",
          "",
          "[Added Lines]",
          "648:             virtio_error(vdev, \"Invalid size for indirect buffer table\");",
          "649:             return NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "636:     do {",
          "637:         if (desc.flags & VRING_DESC_F_WRITE) {",
          "640:         } else {",
          "641:             if (in_num) {",
          "644:             }",
          "647:         }",
          "650:         if ((in_num + out_num) > max) {",
          "653:         }",
          "654:     } while ((i = virtqueue_read_next_desc(vdev, &desc, desc_pa, max)) != max);",
          "",
          "[Removed Lines]",
          "638:             virtqueue_map_desc(&in_num, addr + out_num, iov + out_num,",
          "639:                                VIRTQUEUE_MAX_SIZE - out_num, true, desc.addr, desc.len);",
          "642:                 error_report(\"Incorrect order for descriptors\");",
          "643:                 exit(1);",
          "645:             virtqueue_map_desc(&out_num, addr, iov,",
          "646:                                VIRTQUEUE_MAX_SIZE, false, desc.addr, desc.len);",
          "651:             error_report(\"Looped descriptor\");",
          "652:             exit(1);",
          "",
          "[Added Lines]",
          "661:         bool map_ok;",
          "664:             map_ok = virtqueue_map_desc(vdev, &in_num, addr + out_num,",
          "665:                                         iov + out_num,",
          "666:                                         VIRTQUEUE_MAX_SIZE - out_num, true,",
          "667:                                         desc.addr, desc.len);",
          "670:                 virtio_error(vdev, \"Incorrect order for descriptors\");",
          "671:                 goto err_undo_map;",
          "673:             map_ok = virtqueue_map_desc(vdev, &out_num, addr, iov,",
          "674:                                         VIRTQUEUE_MAX_SIZE, false,",
          "675:                                         desc.addr, desc.len);",
          "676:         }",
          "677:         if (!map_ok) {",
          "678:             goto err_undo_map;",
          "683:             virtio_error(vdev, \"Looped descriptor\");",
          "684:             goto err_undo_map;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "670:     trace_virtqueue_pop(vq, elem, elem->in_num, elem->out_num);",
          "671:     return elem;",
          "672: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "705: err_undo_map:",
          "706:     virtqueue_undo_map_desc(out_num, in_num, iov);",
          "707:     return NULL;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-18202",
  "cve_desc": "The __oom_reap_task_mm function in mm/oom_kill.c in the Linux kernel before 4.14.4 mishandles gather operations, which allows attackers to cause a denial of service (TLB entry leak or use-after-free) or possibly have unspecified other impact by triggering a copy_to_user call within a certain time window.",
  "repo": "torvalds/linux",
  "patch_hash": "687cb0884a714ff484d038e9190edc874edcf146",
  "patch_info": {
    "commit_hash": "687cb0884a714ff484d038e9190edc874edcf146",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146",
    "files": [
      "mm/oom_kill.c"
    ],
    "message": "mm, oom_reaper: gather each vma to prevent leaking TLB entry\n\ntlb_gather_mmu(&tlb, mm, 0, -1) means gathering the whole virtual memory\nspace.  In this case, tlb->fullmm is true.  Some archs like arm64\ndoesn't flush TLB when tlb->fullmm is true:\n\n  commit 5a7862e83000 (\"arm64: tlbflush: avoid flushing when fullmm == 1\").\n\nWhich causes leaking of tlb entries.\n\nWill clarifies his patch:\n \"Basically, we tag each address space with an ASID (PCID on x86) which\n  is resident in the TLB. This means we can elide TLB invalidation when\n  pulling down a full mm because we won't ever assign that ASID to\n  another mm without doing TLB invalidation elsewhere (which actually\n  just nukes the whole TLB).\n\n  I think that means that we could potentially not fault on a kernel\n  uaccess, because we could hit in the TLB\"\n\nThere could be a window between complete_signal() sending IPI to other\ncores and all threads sharing this mm are really kicked off from cores.\nIn this window, the oom reaper may calls tlb_flush_mmu_tlbonly() to\nflush TLB then frees pages.  However, due to the above problem, the TLB\nentries are not really flushed on arm64.  Other threads are possible to\naccess these pages through TLB entries.  Moreover, a copy_to_user() can\nalso write to these pages without generating page fault, causes\nuse-after-free bugs.\n\nThis patch gathers each vma instead of gathering full vm space.  In this\ncase tlb->fullmm is not true.  The behavior of oom reaper become similar\nto munmapping before do_exit, which should be safe for all archs.\n\nLink: http://lkml.kernel.org/r/20171107095453.179940-1-wangnan0@huawei.com\nFixes: aac453635549 (\"mm, oom: introduce oom reaper\")\nSigned-off-by: Wang Nan <wangnan0@huawei.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nAcked-by: David Rientjes <rientjes@google.com>\nCc: Minchan Kim <minchan@kernel.org>\nCc: Will Deacon <will.deacon@arm.com>\nCc: Bob Liu <liubo95@huawei.com>\nCc: Ingo Molnar <mingo@kernel.org>\nCc: Roman Gushchin <guro@fb.com>\nCc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/oom_kill.c||mm/oom_kill.c"
    ]
  },
  "patch_diff": {
    "mm/oom_kill.c||mm/oom_kill.c": [
      "File: mm/oom_kill.c -> mm/oom_kill.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "551:  set_bit(MMF_UNSTABLE, &mm->flags);",
      "554:  for (vma = mm->mmap ; vma; vma = vma->vm_next) {",
      "555:   if (!can_madv_dontneed_vma(vma))",
      "556:    continue;",
      "",
      "[Removed Lines]",
      "553:  tlb_gather_mmu(&tlb, mm, 0, -1);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "569:    unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,",
      "570:       NULL);",
      "571:  }",
      "573:  pr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
      "574:    task_pid_nr(tsk), tsk->comm,",
      "575:    K(get_mm_counter(mm, MM_ANONPAGES)),",
      "",
      "[Removed Lines]",
      "568:   if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))",
      "572:  tlb_finish_mmu(&tlb, 0, -1);",
      "",
      "[Added Lines]",
      "567:   if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {",
      "568:    tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);",
      "571:    tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);",
      "572:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "93065ac753e4443840a057bfef4be71ec766fde9",
      "candidate_info": {
        "commit_hash": "93065ac753e4443840a057bfef4be71ec766fde9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/93065ac753e4443840a057bfef4be71ec766fde9",
        "files": [
          "arch/x86/kvm/x86.c",
          "drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c",
          "drivers/gpu/drm/i915/i915_gem_userptr.c",
          "drivers/gpu/drm/radeon/radeon_mn.c",
          "drivers/infiniband/core/umem_odp.c",
          "drivers/infiniband/hw/hfi1/mmu_rb.c",
          "drivers/infiniband/hw/mlx5/odp.c",
          "drivers/misc/mic/scif/scif_dma.c",
          "drivers/misc/sgi-gru/grutlbpurge.c",
          "drivers/xen/gntdev.c",
          "include/linux/kvm_host.h",
          "include/linux/mmu_notifier.h",
          "include/linux/oom.h",
          "include/rdma/ib_umem_odp.h",
          "mm/hmm.c",
          "mm/mmap.c",
          "mm/mmu_notifier.c",
          "mm/oom_kill.c",
          "virt/kvm/kvm_main.c"
        ],
        "message": "mm, oom: distinguish blockable mode for mmu notifiers\n\nThere are several blockable mmu notifiers which might sleep in\nmmu_notifier_invalidate_range_start and that is a problem for the\noom_reaper because it needs to guarantee a forward progress so it cannot\ndepend on any sleepable locks.\n\nCurrently we simply back off and mark an oom victim with blockable mmu\nnotifiers as done after a short sleep.  That can result in selecting a new\noom victim prematurely because the previous one still hasn't torn its\nmemory down yet.\n\nWe can do much better though.  Even if mmu notifiers use sleepable locks\nthere is no reason to automatically assume those locks are held.  Moreover\nmajority of notifiers only care about a portion of the address space and\nthere is absolutely zero reason to fail when we are unmapping an unrelated\nrange.  Many notifiers do really block and wait for HW which is harder to\nhandle and we have to bail out though.\n\nThis patch handles the low hanging fruit.\n__mmu_notifier_invalidate_range_start gets a blockable flag and callbacks\nare not allowed to sleep if the flag is set to false.  This is achieved by\nusing trylock instead of the sleepable lock for most callbacks and\ncontinue as long as we do not block down the call chain.\n\nI think we can improve that even further because there is a common pattern\nto do a range lookup first and then do something about that.  The first\npart can be done without a sleeping lock in most cases AFAICS.\n\nThe oom_reaper end then simply retries if there is at least one notifier\nwhich couldn't make any progress in !blockable mode.  A retry loop is\nalready implemented to wait for the mmap_sem and this is basically the\nsame thing.\n\nThe simplest way for driver developers to test this code path is to wrap\nuserspace code which uses these notifiers into a memcg and set the hard\nlimit to hit the oom.  This can be done e.g.  after the test faults in all\nthe mmu notifier managed memory and set the hard limit to something really\nsmall.  Then we are looking for a proper process tear down.\n\n[akpm@linux-foundation.org: coding style fixes]\n[akpm@linux-foundation.org: minor code simplification]\nLink: http://lkml.kernel.org/r/20180716115058.5559-1-mhocko@kernel.org\nSigned-off-by: Michal Hocko <mhocko@suse.com>\nAcked-by: Christian K\u00f6nig <christian.koenig@amd.com> # AMD notifiers\nAcked-by: Leon Romanovsky <leonro@mellanox.com> # mlx and umem_odp\nReported-by: David Rientjes <rientjes@google.com>\nCc: \"David (ChunMing) Zhou\" <David1.Zhou@amd.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nCc: Alex Deucher <alexander.deucher@amd.com>\nCc: David Airlie <airlied@linux.ie>\nCc: Jani Nikula <jani.nikula@linux.intel.com>\nCc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>\nCc: Rodrigo Vivi <rodrigo.vivi@intel.com>\nCc: Doug Ledford <dledford@redhat.com>\nCc: Jason Gunthorpe <jgg@ziepe.ca>\nCc: Mike Marciniszyn <mike.marciniszyn@intel.com>\nCc: Dennis Dalessandro <dennis.dalessandro@intel.com>\nCc: Sudeep Dutt <sudeep.dutt@intel.com>\nCc: Ashutosh Dixit <ashutosh.dixit@intel.com>\nCc: Dimitri Sivanich <sivanich@sgi.com>\nCc: Boris Ostrovsky <boris.ostrovsky@oracle.com>\nCc: Juergen Gross <jgross@suse.com>\nCc: \"J\u00e9r\u00f4me Glisse\" <jglisse@redhat.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: Felix Kuehling <felix.kuehling@amd.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c",
          "drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c||drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c",
          "drivers/gpu/drm/i915/i915_gem_userptr.c||drivers/gpu/drm/i915/i915_gem_userptr.c",
          "drivers/gpu/drm/radeon/radeon_mn.c||drivers/gpu/drm/radeon/radeon_mn.c",
          "drivers/infiniband/core/umem_odp.c||drivers/infiniband/core/umem_odp.c",
          "drivers/infiniband/hw/hfi1/mmu_rb.c||drivers/infiniband/hw/hfi1/mmu_rb.c",
          "drivers/infiniband/hw/mlx5/odp.c||drivers/infiniband/hw/mlx5/odp.c",
          "drivers/misc/mic/scif/scif_dma.c||drivers/misc/mic/scif/scif_dma.c",
          "drivers/misc/sgi-gru/grutlbpurge.c||drivers/misc/sgi-gru/grutlbpurge.c",
          "drivers/xen/gntdev.c||drivers/xen/gntdev.c",
          "include/linux/kvm_host.h||include/linux/kvm_host.h",
          "include/linux/mmu_notifier.h||include/linux/mmu_notifier.h",
          "include/linux/oom.h||include/linux/oom.h",
          "include/rdma/ib_umem_odp.h||include/rdma/ib_umem_odp.h",
          "mm/hmm.c||mm/hmm.c",
          "mm/mmap.c||mm/mmap.c",
          "mm/mmu_notifier.c||mm/mmu_notifier.c",
          "mm/oom_kill.c||mm/oom_kill.c",
          "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ],
          "candidate": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c": [
          "File: arch/x86/kvm/x86.c -> arch/x86/kvm/x86.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7305:  kvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);",
          "7306: }",
          "7310: {",
          "7311:  unsigned long apic_address;",
          "",
          "[Removed Lines]",
          "7308: void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,",
          "7309:   unsigned long start, unsigned long end)",
          "",
          "[Added Lines]",
          "7308: int kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,",
          "7309:   unsigned long start, unsigned long end,",
          "7310:   bool blockable)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7317:  apic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);",
          "7318:  if (start <= apic_address && apic_address < end)",
          "7319:   kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);",
          "7320: }",
          "7322: void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7322:  return 0;",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c||drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c": [
          "File: drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c -> drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "182: {",
          "184:  if (atomic_inc_return(&amn->recursion) == 1)",
          "185:   down_read_non_owner(&amn->lock);",
          "186:  mutex_unlock(&amn->read_lock);",
          "187: }",
          "",
          "[Removed Lines]",
          "181: static void amdgpu_mn_read_lock(struct amdgpu_mn *amn)",
          "183:  mutex_lock(&amn->read_lock);",
          "",
          "[Added Lines]",
          "181: static int amdgpu_mn_read_lock(struct amdgpu_mn *amn, bool blockable)",
          "183:  if (blockable)",
          "184:   mutex_lock(&amn->read_lock);",
          "185:  else if (!mutex_trylock(&amn->read_lock))",
          "186:   return -EAGAIN;",
          "192:  return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "243:        struct mm_struct *mm,",
          "244:        unsigned long start,",
          "246: {",
          "247:  struct amdgpu_mn *amn = container_of(mn, struct amdgpu_mn, mn);",
          "248:  struct interval_tree_node *it;",
          "",
          "[Removed Lines]",
          "242: static void amdgpu_mn_invalidate_range_start_gfx(struct mmu_notifier *mn,",
          "245:        unsigned long end)",
          "",
          "[Added Lines]",
          "248: static int amdgpu_mn_invalidate_range_start_gfx(struct mmu_notifier *mn,",
          "251:        unsigned long end,",
          "252:        bool blockable)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "251:  end -= 1;",
          "255:  it = interval_tree_iter_first(&amn->objects, start, end);",
          "256:  while (it) {",
          "257:   struct amdgpu_mn_node *node;",
          "259:   node = container_of(it, struct amdgpu_mn_node, it);",
          "260:   it = interval_tree_iter_next(it, start, end);",
          "262:   amdgpu_mn_invalidate_node(node, start, end);",
          "263:  }",
          "264: }",
          "",
          "[Removed Lines]",
          "253:  amdgpu_mn_read_lock(amn);",
          "",
          "[Added Lines]",
          "263:  if (amdgpu_mn_read_lock(amn, blockable))",
          "264:   return -EAGAIN;",
          "270:   if (!blockable) {",
          "271:    amdgpu_mn_read_unlock(amn);",
          "272:    return -EAGAIN;",
          "273:   }",
          "281:  return 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "279:        struct mm_struct *mm,",
          "280:        unsigned long start,",
          "282: {",
          "283:  struct amdgpu_mn *amn = container_of(mn, struct amdgpu_mn, mn);",
          "284:  struct interval_tree_node *it;",
          "",
          "[Removed Lines]",
          "278: static void amdgpu_mn_invalidate_range_start_hsa(struct mmu_notifier *mn,",
          "281:        unsigned long end)",
          "",
          "[Added Lines]",
          "296: static int amdgpu_mn_invalidate_range_start_hsa(struct mmu_notifier *mn,",
          "299:        unsigned long end,",
          "300:        bool blockable)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "287:  end -= 1;",
          "291:  it = interval_tree_iter_first(&amn->objects, start, end);",
          "292:  while (it) {",
          "293:   struct amdgpu_mn_node *node;",
          "294:   struct amdgpu_bo *bo;",
          "296:   node = container_of(it, struct amdgpu_mn_node, it);",
          "297:   it = interval_tree_iter_next(it, start, end);",
          "",
          "[Removed Lines]",
          "289:  amdgpu_mn_read_lock(amn);",
          "",
          "[Added Lines]",
          "308:  if (amdgpu_mn_read_lock(amn, blockable))",
          "309:   return -EAGAIN;",
          "316:   if (!blockable) {",
          "317:    amdgpu_mn_read_unlock(amn);",
          "318:    return -EAGAIN;",
          "319:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "304:     amdgpu_amdkfd_evict_userptr(mem, mm);",
          "305:   }",
          "306:  }",
          "307: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "333:  return 0;",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/i915_gem_userptr.c||drivers/gpu/drm/i915/i915_gem_userptr.c": [
          "File: drivers/gpu/drm/i915/i915_gem_userptr.c -> drivers/gpu/drm/i915/i915_gem_userptr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:  mo->attached = false;",
          "113: }",
          "116:              struct mm_struct *mm,",
          "117:              unsigned long start,",
          "119: {",
          "120:  struct i915_mmu_notifier *mn =",
          "121:   container_of(_mn, struct i915_mmu_notifier, mn);",
          "",
          "[Removed Lines]",
          "115: static void i915_gem_userptr_mn_invalidate_range_start(struct mmu_notifier *_mn,",
          "118:              unsigned long end)",
          "",
          "[Added Lines]",
          "115: static int i915_gem_userptr_mn_invalidate_range_start(struct mmu_notifier *_mn,",
          "118:              unsigned long end,",
          "119:              bool blockable)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "124:  LIST_HEAD(cancelled);",
          "126:  if (RB_EMPTY_ROOT(&mn->objects.rb_root))",
          "130:  end--;",
          "",
          "[Removed Lines]",
          "127:   return;",
          "",
          "[Added Lines]",
          "128:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "132:  spin_lock(&mn->lock);",
          "133:  it = interval_tree_iter_first(&mn->objects, start, end);",
          "134:  while (it) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136:   if (!blockable) {",
          "137:    spin_unlock(&mn->lock);",
          "138:    return -EAGAIN;",
          "139:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "155:  if (!list_empty(&cancelled))",
          "156:   flush_workqueue(mn->wq);",
          "157: }",
          "159: static const struct mmu_notifier_ops i915_gem_userptr_notifier = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:  return 0;",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/radeon/radeon_mn.c||drivers/gpu/drm/radeon/radeon_mn.c": [
          "File: drivers/gpu/drm/radeon/radeon_mn.c -> drivers/gpu/drm/radeon/radeon_mn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:           struct mm_struct *mm,",
          "123:           unsigned long start,",
          "125: {",
          "126:  struct radeon_mn *rmn = container_of(mn, struct radeon_mn, mn);",
          "127:  struct ttm_operation_ctx ctx = { false, false };",
          "128:  struct interval_tree_node *it;",
          "131:  end -= 1;",
          "135:  it = interval_tree_iter_first(&rmn->objects, start, end);",
          "136:  while (it) {",
          "",
          "[Removed Lines]",
          "121: static void radeon_mn_invalidate_range_start(struct mmu_notifier *mn,",
          "124:           unsigned long end)",
          "133:  mutex_lock(&rmn->lock);",
          "",
          "[Added Lines]",
          "121: static int radeon_mn_invalidate_range_start(struct mmu_notifier *mn,",
          "124:           unsigned long end,",
          "125:           bool blockable)",
          "130:  int ret = 0;",
          "138:  if (blockable)",
          "139:   mutex_lock(&rmn->lock);",
          "140:  else if (!mutex_trylock(&rmn->lock))",
          "141:   return -EAGAIN;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:   struct radeon_bo *bo;",
          "139:   long r;",
          "141:   node = container_of(it, struct radeon_mn_node, it);",
          "142:   it = interval_tree_iter_next(it, start, end);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "149:   if (!blockable) {",
          "150:    ret = -EAGAIN;",
          "151:    goto out_unlock;",
          "152:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:   }",
          "167:  }",
          "169:  mutex_unlock(&rmn->lock);",
          "170: }",
          "172: static const struct mmu_notifier_ops radeon_mn_ops = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: out_unlock:",
          "185:  return ret;",
          "",
          "---------------"
        ],
        "drivers/infiniband/core/umem_odp.c||drivers/infiniband/core/umem_odp.c": [
          "File: drivers/infiniband/core/umem_odp.c -> drivers/infiniband/core/umem_odp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "186:  rbt_ib_umem_for_each_in_range(&context->umem_tree, 0,",
          "187:           ULLONG_MAX,",
          "188:           ib_umem_notifier_release_trampoline,",
          "189:           NULL);",
          "190:  up_read(&context->umem_rwsem);",
          "191: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "189:           true,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:  return 0;",
          "208: }",
          "211:           struct mm_struct *mm,",
          "212:           unsigned long start,",
          "214: {",
          "215:  struct ib_ucontext *context = container_of(mn, struct ib_ucontext, mn);",
          "217:  if (!context->invalidate_range)",
          "220:  ib_ucontext_notifier_start_account(context);",
          "223:           end,",
          "225:  up_read(&context->umem_rwsem);",
          "226: }",
          "228: static int invalidate_range_end_trampoline(struct ib_umem *item, u64 start,",
          "",
          "[Removed Lines]",
          "210: static void ib_umem_notifier_invalidate_range_start(struct mmu_notifier *mn,",
          "213:           unsigned long end)",
          "218:   return;",
          "221:  down_read(&context->umem_rwsem);",
          "222:  rbt_ib_umem_for_each_in_range(&context->umem_tree, start,",
          "224:           invalidate_range_start_trampoline, NULL);",
          "",
          "[Added Lines]",
          "211: static int ib_umem_notifier_invalidate_range_start(struct mmu_notifier *mn,",
          "214:           unsigned long end,",
          "215:           bool blockable)",
          "218:  int ret;",
          "221:   return 0;",
          "223:  if (blockable)",
          "224:   down_read(&context->umem_rwsem);",
          "225:  else if (!down_read_trylock(&context->umem_rwsem))",
          "226:   return -EAGAIN;",
          "229:  ret = rbt_ib_umem_for_each_in_range(&context->umem_tree, start,",
          "231:           invalidate_range_start_trampoline,",
          "232:           blockable, NULL);",
          "235:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242:  if (!context->invalidate_range)",
          "243:   return;",
          "245:  down_read(&context->umem_rwsem);",
          "246:  rbt_ib_umem_for_each_in_range(&context->umem_tree, start,",
          "247:           end,",
          "249:  up_read(&context->umem_rwsem);",
          "250:  ib_ucontext_notifier_end_account(context);",
          "251: }",
          "",
          "[Removed Lines]",
          "248:           invalidate_range_end_trampoline, NULL);",
          "",
          "[Added Lines]",
          "263:           invalidate_range_end_trampoline, true, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "798: int rbt_ib_umem_for_each_in_range(struct rb_root_cached *root,",
          "799:       u64 start, u64 last,",
          "800:       umem_call_back cb,",
          "801:       void *cookie)",
          "802: {",
          "803:  int ret_val = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "816:       bool blockable,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "810:  for (node = rbt_ib_umem_iter_first(root, start, last - 1);",
          "811:    node; node = next) {",
          "812:   next = rbt_ib_umem_iter_next(node, start, last - 1);",
          "813:   umem = container_of(node, struct ib_umem_odp, interval_tree);",
          "814:   ret_val = cb(umem->umem, start, last, cookie) || ret_val;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "829:   if (!blockable)",
          "830:    return -EAGAIN;",
          "",
          "---------------"
        ],
        "drivers/infiniband/hw/hfi1/mmu_rb.c||drivers/infiniband/hw/hfi1/mmu_rb.c": [
          "File: drivers/infiniband/hw/hfi1/mmu_rb.c -> drivers/infiniband/hw/hfi1/mmu_rb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: static unsigned long mmu_node_start(struct mmu_rb_node *);",
          "69: static unsigned long mmu_node_last(struct mmu_rb_node *);",
          "71:          struct mm_struct *,",
          "73: static struct mmu_rb_node *__mmu_rb_search(struct mmu_rb_handler *,",
          "74:         unsigned long, unsigned long);",
          "75: static void do_remove(struct mmu_rb_handler *handler,",
          "",
          "[Removed Lines]",
          "70: static void mmu_notifier_range_start(struct mmu_notifier *,",
          "72:          unsigned long, unsigned long);",
          "",
          "[Added Lines]",
          "70: static int mmu_notifier_range_start(struct mmu_notifier *,",
          "72:          unsigned long, unsigned long, bool);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "284:  handler->ops->remove(handler->ops_arg, node);",
          "285: }",
          "288:          struct mm_struct *mm,",
          "289:          unsigned long start,",
          "291: {",
          "292:  struct mmu_rb_handler *handler =",
          "293:   container_of(mn, struct mmu_rb_handler, mn);",
          "",
          "[Removed Lines]",
          "287: static void mmu_notifier_range_start(struct mmu_notifier *mn,",
          "290:          unsigned long end)",
          "",
          "[Added Lines]",
          "287: static int mmu_notifier_range_start(struct mmu_notifier *mn,",
          "290:          unsigned long end,",
          "291:          bool blockable)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "314:  if (added)",
          "315:   queue_work(handler->wq, &handler->del_work);",
          "316: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "318:  return 0;",
          "",
          "---------------"
        ],
        "drivers/infiniband/hw/mlx5/odp.c||drivers/infiniband/hw/mlx5/odp.c": [
          "File: drivers/infiniband/hw/mlx5/odp.c -> drivers/infiniband/hw/mlx5/odp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "489:  down_read(&ctx->umem_rwsem);",
          "490:  rbt_ib_umem_for_each_in_range(&ctx->umem_tree, 0, ULLONG_MAX,",
          "492:  up_read(&ctx->umem_rwsem);",
          "494:  wait_event(imr->q_leaf_free, !atomic_read(&imr->num_leaf_free));",
          "",
          "[Removed Lines]",
          "491:           mr_leaf_free, imr);",
          "",
          "[Added Lines]",
          "491:           mr_leaf_free, true, imr);",
          "",
          "---------------"
        ],
        "drivers/misc/mic/scif/scif_dma.c||drivers/misc/mic/scif/scif_dma.c": [
          "File: drivers/misc/mic/scif/scif_dma.c -> drivers/misc/mic/scif/scif_dma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "200:  schedule_work(&scif_info.misc_work);",
          "201: }",
          "204:            struct mm_struct *mm,",
          "205:            unsigned long start,",
          "207: {",
          "208:  struct scif_mmu_notif *mmn;",
          "210:  mmn = container_of(mn, struct scif_mmu_notif, ep_mmu_notifier);",
          "211:  scif_rma_destroy_tcw(mmn, start, end - start);",
          "212: }",
          "214: static void scif_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,",
          "",
          "[Removed Lines]",
          "203: static void scif_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,",
          "206:            unsigned long end)",
          "",
          "[Added Lines]",
          "203: static int scif_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,",
          "206:            unsigned long end,",
          "207:            bool blockable)",
          "214:  return 0;",
          "",
          "---------------"
        ],
        "drivers/misc/sgi-gru/grutlbpurge.c||drivers/misc/sgi-gru/grutlbpurge.c": [
          "File: drivers/misc/sgi-gru/grutlbpurge.c -> drivers/misc/sgi-gru/grutlbpurge.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:            struct mm_struct *mm,",
          "225: {",
          "226:  struct gru_mm_struct *gms = container_of(mn, struct gru_mm_struct,",
          "227:        ms_notifier);",
          "",
          "[Removed Lines]",
          "222: static void gru_invalidate_range_start(struct mmu_notifier *mn,",
          "224:            unsigned long start, unsigned long end)",
          "",
          "[Added Lines]",
          "222: static int gru_invalidate_range_start(struct mmu_notifier *mn,",
          "224:            unsigned long start, unsigned long end,",
          "225:            bool blockable)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231:  gru_dbg(grudev, \"gms %p, start 0x%lx, end 0x%lx, act %d\\n\", gms,",
          "232:   start, end, atomic_read(&gms->ms_range_active));",
          "233:  gru_flush_tlb_range(gms, start, end - start);",
          "234: }",
          "236: static void gru_invalidate_range_end(struct mmu_notifier *mn,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "236:  return 0;",
          "",
          "---------------"
        ],
        "drivers/xen/gntdev.c||drivers/xen/gntdev.c": [
          "File: drivers/xen/gntdev.c -> drivers/xen/gntdev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "482: static void unmap_if_in_range(struct gntdev_grant_map *map,",
          "483:          unsigned long start, unsigned long end)",
          "484: {",
          "485:  unsigned long mstart, mend;",
          "486:  int err;",
          "494:  mstart = max(start, map->vma->vm_start);",
          "495:  mend   = min(end,   map->vma->vm_end);",
          "496:  pr_debug(\"map %d+%d (%lx %lx), range %lx %lx, mrange %lx %lx\\n\",",
          "",
          "[Removed Lines]",
          "488:  if (!map->vma)",
          "489:   return;",
          "490:  if (map->vma->vm_start >= end)",
          "491:   return;",
          "492:  if (map->vma->vm_end <= start)",
          "493:   return;",
          "",
          "[Added Lines]",
          "482: static bool in_range(struct gntdev_grant_map *map,",
          "483:          unsigned long start, unsigned long end)",
          "484: {",
          "485:  if (!map->vma)",
          "486:   return false;",
          "487:  if (map->vma->vm_start >= end)",
          "488:   return false;",
          "489:  if (map->vma->vm_end <= start)",
          "490:   return false;",
          "492:  return true;",
          "493: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "503:  WARN_ON(err);",
          "504: }",
          "507:     struct mm_struct *mm,",
          "509: {",
          "510:  struct gntdev_priv *priv = container_of(mn, struct gntdev_priv, mn);",
          "511:  struct gntdev_grant_map *map;",
          "514:  list_for_each_entry(map, &priv->maps, next) {",
          "515:   unmap_if_in_range(map, start, end);",
          "516:  }",
          "517:  list_for_each_entry(map, &priv->freeable_maps, next) {",
          "518:   unmap_if_in_range(map, start, end);",
          "519:  }",
          "520:  mutex_unlock(&priv->lock);",
          "521: }",
          "523: static void mn_release(struct mmu_notifier *mn,",
          "",
          "[Removed Lines]",
          "506: static void mn_invl_range_start(struct mmu_notifier *mn,",
          "508:     unsigned long start, unsigned long end)",
          "513:  mutex_lock(&priv->lock);",
          "",
          "[Added Lines]",
          "513: static int mn_invl_range_start(struct mmu_notifier *mn,",
          "515:     unsigned long start, unsigned long end,",
          "516:     bool blockable)",
          "520:  int ret = 0;",
          "523:  if (blockable)",
          "524:   mutex_lock(&priv->lock);",
          "525:  else if (!mutex_trylock(&priv->lock))",
          "526:   return -EAGAIN;",
          "529:   if (in_range(map, start, end)) {",
          "530:    ret = -EAGAIN;",
          "531:    goto out_unlock;",
          "532:   }",
          "536:   if (in_range(map, start, end)) {",
          "537:    ret = -EAGAIN;",
          "538:    goto out_unlock;",
          "539:   }",
          "543: out_unlock:",
          "546:  return ret;",
          "",
          "---------------"
        ],
        "include/linux/kvm_host.h||include/linux/kvm_host.h": [
          "File: include/linux/kvm_host.h -> include/linux/kvm_host.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1289: }",
          "1295: #ifdef CONFIG_HAVE_KVM_VCPU_RUN_PID_CHANGE",
          "1296: int kvm_arch_vcpu_run_pid_change(struct kvm_vcpu *vcpu);",
          "",
          "[Removed Lines]",
          "1292: void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,",
          "1293:   unsigned long start, unsigned long end);",
          "",
          "[Added Lines]",
          "1292: int kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,",
          "1293:   unsigned long start, unsigned long end, bool blockable);",
          "",
          "---------------"
        ],
        "include/linux/mmu_notifier.h||include/linux/mmu_notifier.h": [
          "File: include/linux/mmu_notifier.h -> include/linux/mmu_notifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:            struct mm_struct *mm,",
          "161:  void (*invalidate_range_end)(struct mmu_notifier *mn,",
          "162:          struct mm_struct *mm,",
          "163:          unsigned long start, unsigned long end);",
          "",
          "[Removed Lines]",
          "158:  void (*invalidate_range_start)(struct mmu_notifier *mn,",
          "160:            unsigned long start, unsigned long end);",
          "",
          "[Added Lines]",
          "159:  int (*invalidate_range_start)(struct mmu_notifier *mn,",
          "161:            unsigned long start, unsigned long end,",
          "162:            bool blockable);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "229:          unsigned long address);",
          "230: extern void __mmu_notifier_change_pte(struct mm_struct *mm,",
          "231:           unsigned long address, pte_t pte);",
          "234: extern void __mmu_notifier_invalidate_range_end(struct mm_struct *mm,",
          "235:       unsigned long start, unsigned long end,",
          "236:       bool only_end);",
          "",
          "[Removed Lines]",
          "232: extern void __mmu_notifier_invalidate_range_start(struct mm_struct *mm,",
          "233:       unsigned long start, unsigned long end);",
          "",
          "[Added Lines]",
          "234: extern int __mmu_notifier_invalidate_range_start(struct mm_struct *mm,",
          "235:       unsigned long start, unsigned long end,",
          "236:       bool blockable);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "281:       unsigned long start, unsigned long end)",
          "282: {",
          "283:  if (mm_has_notifiers(mm))",
          "285: }",
          "287: static inline void mmu_notifier_invalidate_range_end(struct mm_struct *mm,",
          "",
          "[Removed Lines]",
          "284:   __mmu_notifier_invalidate_range_start(mm, start, end);",
          "",
          "[Added Lines]",
          "287:   __mmu_notifier_invalidate_range_start(mm, start, end, true);",
          "288: }",
          "290: static inline int mmu_notifier_invalidate_range_start_nonblock(struct mm_struct *mm,",
          "291:       unsigned long start, unsigned long end)",
          "292: {",
          "293:  if (mm_has_notifiers(mm))",
          "294:   return __mmu_notifier_invalidate_range_start(mm, start, end, false);",
          "295:  return 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "461: {",
          "462: }",
          "464: static inline void mmu_notifier_invalidate_range_end(struct mm_struct *mm,",
          "465:       unsigned long start, unsigned long end)",
          "466: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "475: static inline int mmu_notifier_invalidate_range_start_nonblock(struct mm_struct *mm,",
          "476:       unsigned long start, unsigned long end)",
          "477: {",
          "478:  return 0;",
          "479: }",
          "",
          "---------------"
        ],
        "include/linux/oom.h||include/linux/oom.h": [
          "File: include/linux/oom.h -> include/linux/oom.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:  return 0;",
          "96: }",
          "100: extern unsigned long oom_badness(struct task_struct *p,",
          "101:   struct mem_cgroup *memcg, const nodemask_t *nodemask,",
          "",
          "[Removed Lines]",
          "98: void __oom_reap_task_mm(struct mm_struct *mm);",
          "",
          "[Added Lines]",
          "98: bool __oom_reap_task_mm(struct mm_struct *mm);",
          "",
          "---------------"
        ],
        "include/rdma/ib_umem_odp.h||include/rdma/ib_umem_odp.h": [
          "File: include/rdma/ib_umem_odp.h -> include/rdma/ib_umem_odp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "120: int rbt_ib_umem_for_each_in_range(struct rb_root_cached *root,",
          "121:       u64 start, u64 end,",
          "",
          "[Removed Lines]",
          "122:       umem_call_back cb, void *cookie);",
          "",
          "[Added Lines]",
          "122:       umem_call_back cb,",
          "123:       bool blockable, void *cookie);",
          "",
          "---------------"
        ],
        "mm/hmm.c||mm/hmm.c": [
          "File: mm/hmm.c -> mm/hmm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "177:  up_write(&hmm->mirrors_sem);",
          "178: }",
          "181:            struct mm_struct *mm,",
          "182:            unsigned long start,",
          "184: {",
          "185:  struct hmm *hmm = mm->hmm;",
          "187:  VM_BUG_ON(!hmm);",
          "189:  atomic_inc(&hmm->sequence);",
          "190: }",
          "192: static void hmm_invalidate_range_end(struct mmu_notifier *mn,",
          "",
          "[Removed Lines]",
          "180: static void hmm_invalidate_range_start(struct mmu_notifier *mn,",
          "183:            unsigned long end)",
          "",
          "[Added Lines]",
          "180: static int hmm_invalidate_range_start(struct mmu_notifier *mn,",
          "183:            unsigned long end,",
          "184:            bool blockable)",
          "192:  return 0;",
          "",
          "---------------"
        ],
        "mm/mmap.c||mm/mmap.c": [
          "File: mm/mmap.c -> mm/mmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3066:   mutex_lock(&oom_lock);",
          "3068:   mutex_unlock(&oom_lock);",
          "3070:   set_bit(MMF_OOM_SKIP, &mm->flags);",
          "",
          "[Removed Lines]",
          "3067:   __oom_reap_task_mm(mm);",
          "",
          "[Added Lines]",
          "3067:   (void)__oom_reap_task_mm(mm);",
          "",
          "---------------"
        ],
        "mm/mmu_notifier.c||mm/mmu_notifier.c": [
          "File: mm/mmu_notifier.c -> mm/mmu_notifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:  srcu_read_unlock(&srcu, id);",
          "175: }",
          "179: {",
          "180:  struct mmu_notifier *mn;",
          "181:  int id;",
          "183:  id = srcu_read_lock(&srcu);",
          "184:  hlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {",
          "187:  }",
          "188:  srcu_read_unlock(&srcu, id);",
          "189: }",
          "190: EXPORT_SYMBOL_GPL(__mmu_notifier_invalidate_range_start);",
          "",
          "[Removed Lines]",
          "177: void __mmu_notifier_invalidate_range_start(struct mm_struct *mm,",
          "178:       unsigned long start, unsigned long end)",
          "185:   if (mn->ops->invalidate_range_start)",
          "186:    mn->ops->invalidate_range_start(mn, mm, start, end);",
          "",
          "[Added Lines]",
          "177: int __mmu_notifier_invalidate_range_start(struct mm_struct *mm,",
          "178:       unsigned long start, unsigned long end,",
          "179:       bool blockable)",
          "182:  int ret = 0;",
          "187:   if (mn->ops->invalidate_range_start) {",
          "188:    int _ret = mn->ops->invalidate_range_start(mn, mm, start, end, blockable);",
          "189:    if (_ret) {",
          "190:     pr_info(\"%pS callback failed with %d in %sblockable context.\\n\",",
          "191:       mn->ops->invalidate_range_start, _ret,",
          "192:       !blockable ? \"non-\" : \"\");",
          "193:     ret = _ret;",
          "194:    }",
          "195:   }",
          "199:  return ret;",
          "",
          "---------------"
        ],
        "mm/oom_kill.c||mm/oom_kill.c": [
          "File: mm/oom_kill.c -> mm/oom_kill.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "487: static struct task_struct *oom_reaper_list;",
          "488: static DEFINE_SPINLOCK(oom_reaper_lock);",
          "491: {",
          "492:  struct vm_area_struct *vma;",
          "",
          "[Removed Lines]",
          "490: void __oom_reap_task_mm(struct mm_struct *mm)",
          "",
          "[Added Lines]",
          "490: bool __oom_reap_task_mm(struct mm_struct *mm)",
          "493:  bool ret = true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "519:    struct mmu_gather tlb;",
          "521:    tlb_gather_mmu(&tlb, mm, start, end);",
          "523:    unmap_page_range(&tlb, vma, start, end, NULL);",
          "524:    mmu_notifier_invalidate_range_end(mm, start, end);",
          "525:    tlb_finish_mmu(&tlb, start, end);",
          "526:   }",
          "527:  }",
          "528: }",
          "530: static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)",
          "",
          "[Removed Lines]",
          "522:    mmu_notifier_invalidate_range_start(mm, start, end);",
          "",
          "[Added Lines]",
          "523:    if (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {",
          "524:     ret = false;",
          "525:     continue;",
          "526:    }",
          "533:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "553:   goto unlock_oom;",
          "554:  }",
          "",
          "[Removed Lines]",
          "562:  if (mm_has_blockable_invalidate_notifiers(mm)) {",
          "563:   up_read(&mm->mmap_sem);",
          "564:   schedule_timeout_idle(HZ);",
          "565:   goto unlock_oom;",
          "566:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "580:  trace_start_task_reaping(tsk->pid);",
          "584:  pr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
          "585:    task_pid_nr(tsk), tsk->comm,",
          "",
          "[Removed Lines]",
          "582:  __oom_reap_task_mm(mm);",
          "",
          "[Added Lines]",
          "577:  if (!__oom_reap_task_mm(mm)) {",
          "578:   up_read(&mm->mmap_sem);",
          "579:   ret = false;",
          "580:   goto unlock_oom;",
          "581:  }",
          "",
          "---------------"
        ],
        "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c": [
          "File: virt/kvm/kvm_main.c -> virt/kvm/kvm_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "140: static unsigned long long kvm_createvm_count;",
          "141: static unsigned long long kvm_active_vms;",
          "145: {",
          "146: }",
          "148: bool kvm_is_reserved_pfn(kvm_pfn_t pfn)",
          "",
          "[Removed Lines]",
          "143: __weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,",
          "144:   unsigned long start, unsigned long end)",
          "",
          "[Added Lines]",
          "143: __weak int kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,",
          "144:   unsigned long start, unsigned long end, bool blockable)",
          "146:  return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "360:  srcu_read_unlock(&kvm->srcu, idx);",
          "361: }",
          "364:           struct mm_struct *mm,",
          "365:           unsigned long start,",
          "367: {",
          "368:  struct kvm *kvm = mmu_notifier_to_kvm(mn);",
          "369:  int need_tlb_flush = 0, idx;",
          "371:  idx = srcu_read_lock(&kvm->srcu);",
          "372:  spin_lock(&kvm->mmu_lock);",
          "",
          "[Removed Lines]",
          "363: static void kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,",
          "366:           unsigned long end)",
          "",
          "[Added Lines]",
          "364: static int kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,",
          "367:           unsigned long end,",
          "368:           bool blockable)",
          "372:  int ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "385:  spin_unlock(&kvm->mmu_lock);",
          "389:  srcu_read_unlock(&kvm->srcu, idx);",
          "390: }",
          "392: static void kvm_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,",
          "",
          "[Removed Lines]",
          "387:  kvm_arch_mmu_notifier_invalidate_range(kvm, start, end);",
          "",
          "[Added Lines]",
          "390:  ret = kvm_arch_mmu_notifier_invalidate_range(kvm, start, end, blockable);",
          "394:  return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "27ae357fa82be5ab73b2ef8d39dcb8ca2563483a",
      "candidate_info": {
        "commit_hash": "27ae357fa82be5ab73b2ef8d39dcb8ca2563483a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a",
        "files": [
          "include/linux/oom.h",
          "mm/mmap.c",
          "mm/oom_kill.c"
        ],
        "message": "mm, oom: fix concurrent munlock and oom reaper unmap, v3\n\nSince exit_mmap() is done without the protection of mm->mmap_sem, it is\npossible for the oom reaper to concurrently operate on an mm until\nMMF_OOM_SKIP is set.\n\nThis allows munlock_vma_pages_all() to concurrently run while the oom\nreaper is operating on a vma.  Since munlock_vma_pages_range() depends\non clearing VM_LOCKED from vm_flags before actually doing the munlock to\ndetermine if any other vmas are locking the same memory, the check for\nVM_LOCKED in the oom reaper is racy.\n\nThis is especially noticeable on architectures such as powerpc where\nclearing a huge pmd requires serialize_against_pte_lookup().  If the pmd\nis zapped by the oom reaper during follow_page_mask() after the check\nfor pmd_none() is bypassed, this ends up deferencing a NULL ptl or a\nkernel oops.\n\nFix this by manually freeing all possible memory from the mm before\ndoing the munlock and then setting MMF_OOM_SKIP.  The oom reaper can not\nrun on the mm anymore so the munlock is safe to do in exit_mmap().  It\nalso matches the logic that the oom reaper currently uses for\ndetermining when to set MMF_OOM_SKIP itself, so there's no new risk of\nexcessive oom killing.\n\nThis issue fixes CVE-2018-1000200.\n\nLink: http://lkml.kernel.org/r/alpine.DEB.2.21.1804241526320.238665@chino.kir.corp.google.com\nFixes: 212925802454 (\"mm: oom: let oom_reap_task and exit_mmap run concurrently\")\nSigned-off-by: David Rientjes <rientjes@google.com>\nSuggested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\t[4.14+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/oom.h||include/linux/oom.h",
          "mm/mmap.c||mm/mmap.c",
          "mm/oom_kill.c||mm/oom_kill.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ],
          "candidate": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/oom.h||include/linux/oom.h": [
          "File: include/linux/oom.h -> include/linux/oom.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:  return 0;",
          "96: }",
          "98: extern unsigned long oom_badness(struct task_struct *p,",
          "99:   struct mem_cgroup *memcg, const nodemask_t *nodemask,",
          "100:   unsigned long totalpages);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98: void __oom_reap_task_mm(struct mm_struct *mm);",
          "",
          "---------------"
        ],
        "mm/mmap.c||mm/mmap.c": [
          "File: mm/mmap.c -> mm/mmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3025:  mmu_notifier_release(mm);",
          "3027:  if (mm->locked_vm) {",
          "3028:   vma = mm->mmap;",
          "3029:   while (vma) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3027:  if (unlikely(mm_is_oom_victim(mm))) {",
          "3044:   mutex_lock(&oom_lock);",
          "3045:   __oom_reap_task_mm(mm);",
          "3046:   mutex_unlock(&oom_lock);",
          "3048:   set_bit(MMF_OOM_SKIP, &mm->flags);",
          "3049:   down_write(&mm->mmap_sem);",
          "3050:   up_write(&mm->mmap_sem);",
          "3051:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3047:  unmap_vmas(&tlb, vma, 0, -1);",
          "3066:  free_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);",
          "3067:  tlb_finish_mmu(&tlb, 0, -1);",
          "",
          "[Removed Lines]",
          "3049:  if (unlikely(mm_is_oom_victim(mm))) {",
          "3062:   set_bit(MMF_OOM_SKIP, &mm->flags);",
          "3063:   down_write(&mm->mmap_sem);",
          "3064:   up_write(&mm->mmap_sem);",
          "3065:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mm/oom_kill.c||mm/oom_kill.c": [
          "File: mm/oom_kill.c -> mm/oom_kill.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "480: static struct task_struct *oom_reaper_list;",
          "481: static DEFINE_SPINLOCK(oom_reaper_lock);",
          "484: {",
          "486:  struct vm_area_struct *vma;",
          "487:  bool ret = true;",
          "",
          "[Removed Lines]",
          "483: static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)",
          "485:  struct mmu_gather tlb;",
          "",
          "[Added Lines]",
          "482: void __oom_reap_task_mm(struct mm_struct *mm)",
          "492:  set_bit(MMF_UNSTABLE, &mm->flags);",
          "494:  for (vma = mm->mmap ; vma; vma = vma->vm_next) {",
          "495:   if (!can_madv_dontneed_vma(vma))",
          "496:    continue;",
          "508:   if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {",
          "509:    const unsigned long start = vma->vm_start;",
          "510:    const unsigned long end = vma->vm_end;",
          "511:    struct mmu_gather tlb;",
          "513:    tlb_gather_mmu(&tlb, mm, start, end);",
          "514:    mmu_notifier_invalidate_range_start(mm, start, end);",
          "515:    unmap_page_range(&tlb, vma, start, end, NULL);",
          "516:    mmu_notifier_invalidate_range_end(mm, start, end);",
          "517:    tlb_finish_mmu(&tlb, start, end);",
          "518:   }",
          "519:  }",
          "520: }",
          "522: static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)",
          "523: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "535:  trace_start_task_reaping(tsk->pid);",
          "570:  pr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
          "571:    task_pid_nr(tsk), tsk->comm,",
          "572:    K(get_mm_counter(mm, MM_ANONPAGES)),",
          "",
          "[Removed Lines]",
          "543:  set_bit(MMF_UNSTABLE, &mm->flags);",
          "545:  for (vma = mm->mmap ; vma; vma = vma->vm_next) {",
          "546:   if (!can_madv_dontneed_vma(vma))",
          "547:    continue;",
          "559:   if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {",
          "560:    const unsigned long start = vma->vm_start;",
          "561:    const unsigned long end = vma->vm_end;",
          "563:    tlb_gather_mmu(&tlb, mm, start, end);",
          "564:    mmu_notifier_invalidate_range_start(mm, start, end);",
          "565:    unmap_page_range(&tlb, vma, start, end, NULL);",
          "566:    mmu_notifier_invalidate_range_end(mm, start, end);",
          "567:    tlb_finish_mmu(&tlb, start, end);",
          "568:   }",
          "569:  }",
          "",
          "[Added Lines]",
          "574:  __oom_reap_task_mm(mm);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "587:  struct mm_struct *mm = tsk->signal->oom_mm;",
          "591:   schedule_timeout_idle(HZ/10);",
          "593:  if (attempts <= MAX_OOM_REAP_RETRIES ||",
          "594:      test_bit(MMF_OOM_SKIP, &mm->flags))",
          "595:   goto done;",
          "598:  pr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",",
          "599:   task_pid_nr(tsk), tsk->comm);",
          "600:  debug_show_all_locks();",
          "",
          "[Removed Lines]",
          "590:  while (attempts++ < MAX_OOM_REAP_RETRIES && !__oom_reap_task_mm(tsk, mm))",
          "",
          "[Added Lines]",
          "596:  while (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "431f42fdfdb36f06f43c711fc59be9b814d8fb22",
      "candidate_info": {
        "commit_hash": "431f42fdfdb36f06f43c711fc59be9b814d8fb22",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22",
        "files": [
          "mm/oom_kill.c"
        ],
        "message": "mm/oom_kill.c: clean up oom_reap_task_mm()\n\nAndrew has noticed some inconsistencies in oom_reap_task_mm.  Notably\n\n - Undocumented return value.\n\n - comment \"failed to reap part...\" is misleading - sounds like it's\n   referring to something which happened in the past, is in fact\n   referring to something which might happen in the future.\n\n - fails to call trace_finish_task_reaping() in one case\n\n - code duplication.\n\n - Increases mmap_sem hold time a little by moving\n   trace_finish_task_reaping() inside the locked region.  So sue me ;)\n\n - Sharing the finish: path means that the trace event won't\n   distinguish between the two sources of finishing.\n\nAdd a short explanation for the return value and fix the rest by\nreorganizing the function a bit to have unified function exit paths.\n\nLink: http://lkml.kernel.org/r/20180724141747.GP28386@dhcp22.suse.cz\nSuggested-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Michal Hocko <mhocko@suse.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>\nCc: David Rientjes <rientjes@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/oom_kill.c||mm/oom_kill.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ],
          "candidate": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/oom_kill.c||mm/oom_kill.c": [
          "File: mm/oom_kill.c -> mm/oom_kill.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "534:  return ret;",
          "535: }",
          "537: static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)",
          "538: {",
          "539:  if (!down_read_trylock(&mm->mmap_sem)) {",
          "540:   trace_skip_task_reaping(tsk->pid);",
          "541:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "545:  bool ret = true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "550:  if (test_bit(MMF_OOM_SKIP, &mm->flags)) {",
          "552:   trace_skip_task_reaping(tsk->pid);",
          "554:  }",
          "556:  trace_start_task_reaping(tsk->pid);",
          "564:  pr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
          "565:    task_pid_nr(tsk), tsk->comm,",
          "566:    K(get_mm_counter(mm, MM_ANONPAGES)),",
          "567:    K(get_mm_counter(mm, MM_FILEPAGES)),",
          "568:    K(get_mm_counter(mm, MM_SHMEMPAGES)));",
          "569:  up_read(&mm->mmap_sem);",
          "573: }",
          "575: #define MAX_OOM_REAP_RETRIES 10",
          "",
          "[Removed Lines]",
          "551:   up_read(&mm->mmap_sem);",
          "553:   return true;",
          "559:  if (!__oom_reap_task_mm(mm)) {",
          "560:   up_read(&mm->mmap_sem);",
          "561:   return false;",
          "562:  }",
          "571:  trace_finish_task_reaping(tsk->pid);",
          "572:  return true;",
          "",
          "[Added Lines]",
          "560:   goto out_unlock;",
          "566:  ret = __oom_reap_task_mm(mm);",
          "567:  if (!ret)",
          "568:   goto out_finish;",
          "575: out_finish:",
          "576:  trace_finish_task_reaping(tsk->pid);",
          "577: out_unlock:",
          "580:  return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af5679fbc669f31f7ebd0d473bca76c24c07de30",
      "candidate_info": {
        "commit_hash": "af5679fbc669f31f7ebd0d473bca76c24c07de30",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30",
        "files": [
          "mm/mmap.c",
          "mm/oom_kill.c"
        ],
        "message": "mm, oom: remove oom_lock from oom_reaper\n\noom_reaper used to rely on the oom_lock since e2fe14564d33 (\"oom_reaper:\nclose race with exiting task\").  We do not really need the lock anymore\nthough.  212925802454 (\"mm: oom: let oom_reap_task and exit_mmap run\nconcurrently\") has removed serialization with the exit path based on the\nmm reference count and so we do not really rely on the oom_lock anymore.\n\nTetsuo was arguing that at least MMF_OOM_SKIP should be set under the lock\nto prevent from races when the page allocator didn't manage to get the\nfreed (reaped) memory in __alloc_pages_may_oom but it sees the flag later\non and move on to another victim.  Although this is possible in principle\nlet's wait for it to actually happen in real life before we make the\nlocking more complex again.\n\nTherefore remove the oom_lock for oom_reaper paths (both exit_mmap and\noom_reap_task_mm).  The reaper serializes with exit_mmap by mmap_sem +\nMMF_OOM_SKIP flag.  There is no synchronization with out_of_memory path\nnow.\n\n[mhocko@kernel.org: oom_reap_task_mm should return false when __oom_reap_task_mm did]\n  Link: http://lkml.kernel.org/r/20180724141747.GP28386@dhcp22.suse.cz\nLink: http://lkml.kernel.org/r/20180719075922.13784-1-mhocko@kernel.org\nSigned-off-by: Michal Hocko <mhocko@suse.com>\nSuggested-by: David Rientjes <rientjes@google.com>\nAcked-by: David Rientjes <rientjes@google.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/mmap.c||mm/mmap.c",
          "mm/oom_kill.c||mm/oom_kill.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ],
          "candidate": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/mmap.c||mm/mmap.c": [
          "File: mm/mmap.c -> mm/mmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3067:   (void)__oom_reap_task_mm(mm);",
          "3070:   set_bit(MMF_OOM_SKIP, &mm->flags);",
          "3071:   down_write(&mm->mmap_sem);",
          "",
          "[Removed Lines]",
          "3066:   mutex_lock(&oom_lock);",
          "3068:   mutex_unlock(&oom_lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mm/oom_kill.c||mm/oom_kill.c": [
          "File: mm/oom_kill.c -> mm/oom_kill.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "536: static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)",
          "537: {",
          "556:  if (!down_read_trylock(&mm->mmap_sem)) {",
          "558:   trace_skip_task_reaping(tsk->pid);",
          "560:  }",
          "",
          "[Removed Lines]",
          "538:  bool ret = true;",
          "554:  mutex_lock(&oom_lock);",
          "557:   ret = false;",
          "559:   goto unlock_oom;",
          "",
          "[Added Lines]",
          "540:   return false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "568:  if (test_bit(MMF_OOM_SKIP, &mm->flags)) {",
          "569:   up_read(&mm->mmap_sem);",
          "570:   trace_skip_task_reaping(tsk->pid);",
          "572:  }",
          "574:  trace_start_task_reaping(tsk->pid);",
          "",
          "[Removed Lines]",
          "571:   goto unlock_oom;",
          "",
          "[Added Lines]",
          "552:   return true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "577:  if (!__oom_reap_task_mm(mm)) {",
          "578:   up_read(&mm->mmap_sem);",
          "581:  }",
          "583:  pr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
          "",
          "[Removed Lines]",
          "579:   ret = false;",
          "580:   goto unlock_oom;",
          "",
          "[Added Lines]",
          "560:   return false;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "588:  up_read(&mm->mmap_sem);",
          "590:  trace_finish_task_reaping(tsk->pid);",
          "594: }",
          "596: #define MAX_OOM_REAP_RETRIES 10",
          "",
          "[Removed Lines]",
          "591: unlock_oom:",
          "592:  mutex_unlock(&oom_lock);",
          "593:  return ret;",
          "",
          "[Added Lines]",
          "571:  return true;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f340ff820345b179b697f66ec6743c70416bf93f",
      "candidate_info": {
        "commit_hash": "f340ff820345b179b697f66ec6743c70416bf93f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f340ff820345b179b697f66ec6743c70416bf93f",
        "files": [
          "mm/oom_kill.c"
        ],
        "message": "mm, oom: avoid reaping only for mm's with blockable invalidate callbacks\n\nThis uses the new annotation to determine if an mm has mmu notifiers\nwith blockable invalidate range callbacks to avoid oom reaping.\nOtherwise, the callbacks are used around unmap_page_range().\n\nLink: http://lkml.kernel.org/r/alpine.DEB.2.10.1712141330120.74052@chino.kir.corp.google.com\nSigned-off-by: David Rientjes <rientjes@google.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nCc: Christian K\u00f6nig <christian.koenig@amd.com>\nCc: Dimitri Sivanich <sivanich@hpe.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Oded Gabbay <oded.gabbay@gmail.com>\nCc: Alex Deucher <alexander.deucher@amd.com>\nCc: David Airlie <airlied@linux.ie>\nCc: Joerg Roedel <joro@8bytes.org>\nCc: Doug Ledford <dledford@redhat.com>\nCc: Jani Nikula <jani.nikula@linux.intel.com>\nCc: Mike Marciniszyn <mike.marciniszyn@intel.com>\nCc: Sean Hefty <sean.hefty@intel.com>\nCc: Boris Ostrovsky <boris.ostrovsky@oracle.com>\nCc: J\u00e9r\u00f4me Glisse <jglisse@redhat.com>\nCc: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/oom_kill.c||mm/oom_kill.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ],
          "candidate": [
            "mm/oom_kill.c||mm/oom_kill.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/oom_kill.c||mm/oom_kill.c": [
          "File: mm/oom_kill.c -> mm/oom_kill.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "514:  }",
          "526:   up_read(&mm->mmap_sem);",
          "527:   schedule_timeout_idle(HZ);",
          "528:   goto unlock_oom;",
          "",
          "[Removed Lines]",
          "525:  if (mm_has_notifiers(mm)) {",
          "",
          "[Added Lines]",
          "522:  if (mm_has_blockable_invalidate_notifiers(mm)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "567:   if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {",
          "572:   }",
          "573:  }",
          "574:  pr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
          "",
          "[Removed Lines]",
          "568:    tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);",
          "569:    unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,",
          "570:       NULL);",
          "571:    tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);",
          "",
          "[Added Lines]",
          "565:    const unsigned long start = vma->vm_start;",
          "566:    const unsigned long end = vma->vm_end;",
          "568:    tlb_gather_mmu(&tlb, mm, start, end);",
          "569:    mmu_notifier_invalidate_range_start(mm, start, end);",
          "570:    unmap_page_range(&tlb, vma, start, end, NULL);",
          "571:    mmu_notifier_invalidate_range_end(mm, start, end);",
          "572:    tlb_finish_mmu(&tlb, start, end);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-4247",
  "cve_desc": "Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length.",
  "repo": "torvalds/linux",
  "patch_hash": "1fc29bacedeabb278080e31bb9c1ecb49f143c3b",
  "patch_info": {
    "commit_hash": "1fc29bacedeabb278080e31bb9c1ecb49f143c3b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b",
    "files": [
      "fs/cifs/connect.c"
    ],
    "message": "cifs: fix off-by-one bug in build_unc_path_to_root\n\ncommit 839db3d10a (cifs: fix up handling of prefixpath= option) changed\nthe code such that the vol->prepath no longer contained a leading\ndelimiter and then fixed up the places that accessed that field to\naccount for that change.\n\nOne spot in build_unc_path_to_root was missed however. When doing the\npointer addition on pos, that patch failed to account for the fact that\nwe had already incremented \"pos\" by one when adding the length of the\nprepath. This caused a buffer overrun by one byte.\n\nThis patch fixes the problem by correcting the handling of \"pos\".\n\nCc: <stable@vger.kernel.org> # v3.8+\nReported-by: Marcus Moeller <marcus.moeller@gmx.ch>\nReported-by: Ken Fallon <ken.fallon@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>",
    "before_after_code_files": [
      "fs/cifs/connect.c||fs/cifs/connect.c"
    ]
  },
  "patch_diff": {
    "fs/cifs/connect.c||fs/cifs/connect.c": [
      "File: fs/cifs/connect.c -> fs/cifs/connect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3279:  pos = full_path + unc_len;",
      "3281:  if (pplen) {",
      "3284:   pos += pplen;",
      "3285:  }",
      "",
      "[Removed Lines]",
      "3283:   strncpy(pos, vol->prepath, pplen);",
      "",
      "[Added Lines]",
      "3283:   strncpy(pos + 1, vol->prepath, pplen);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "839db3d10a5ba792d6533b8bb3380f52ac877344",
      "candidate_info": {
        "commit_hash": "839db3d10a5ba792d6533b8bb3380f52ac877344",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/839db3d10a5ba792d6533b8bb3380f52ac877344",
        "files": [
          "fs/cifs/connect.c",
          "fs/cifs/dir.c"
        ],
        "message": "cifs: fix up handling of prefixpath= option\n\nCurrently the code takes care to ensure that the prefixpath has a\nleading '/' delimiter. What if someone passes us a prefixpath with a\nleading '\\\\' instead? The code doesn't properly handle that currently\nAFAICS.\n\nLet's just change the code to skip over any leading delimiter character\nwhen copying the prepath. Then, fix up the users of the prepath option\nto prefix it with the correct delimiter when they use it.\n\nAlso, there's no need to limit the length of the prefixpath to 1k. If\nthe server can handle it, why bother forbidding it?\n\nPavel Shilovsky <piastry@etersoft.ru>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>",
        "before_after_code_files": [
          "fs/cifs/connect.c||fs/cifs/connect.c",
          "fs/cifs/dir.c||fs/cifs/dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ],
          "candidate": [
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/cifs/connect.c||fs/cifs/connect.c": [
          "File: fs/cifs/connect.c -> fs/cifs/connect.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1612:    }",
          "1613:    break;",
          "1614:   case Opt_prefixpath:",
          "1640:    break;",
          "1641:   case Opt_iocharset:",
          "1642:    string = match_strdup(args);",
          "",
          "[Removed Lines]",
          "1615:    string = match_strdup(args);",
          "1616:    if (string == NULL)",
          "1617:     goto out_nomem;",
          "1619:    temp_len = strnlen(string, 1024);",
          "1620:    if (string[0] != '/')",
          "1622:    if (temp_len > 1024) {",
          "1623:     printk(KERN_WARNING \"CIFS: prefix too long\\n\");",
          "1624:     goto cifs_parse_mount_err;",
          "1625:    }",
          "1627:    vol->prepath = kmalloc(temp_len+1, GFP_KERNEL);",
          "1628:    if (vol->prepath == NULL) {",
          "1629:     printk(KERN_WARNING \"CIFS: no memory \"",
          "1630:           \"for path prefix\\n\");",
          "1631:     goto cifs_parse_mount_err;",
          "1632:    }",
          "1634:    if (string[0] != '/') {",
          "1635:     vol->prepath[0] = '/';",
          "1636:     strcpy(vol->prepath+1, string);",
          "1637:    } else",
          "1638:     strcpy(vol->prepath, string);",
          "",
          "[Added Lines]",
          "1616:    if (*args[0].from == '/' || *args[0].from == '\\\\')",
          "1617:     args[0].from++;",
          "1619:    kfree(vol->prepath);",
          "1620:    vol->prepath = match_strdup(args);",
          "1621:    if (vol->prepath == NULL)",
          "1622:     goto out_nomem;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3236:   const struct cifs_sb_info *cifs_sb)",
          "3237: {",
          "3238:  char *full_path, *pos;",
          "3240:  unsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);",
          "3242:  full_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "3239:  unsigned int pplen = vol->prepath ? strlen(vol->prepath) : 0;",
          "",
          "[Added Lines]",
          "3222:  unsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;",
          "",
          "---------------"
        ],
        "fs/cifs/dir.c||fs/cifs/dir.c": [
          "File: fs/cifs/dir.c -> fs/cifs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: cifs_build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,",
          "49:    struct cifs_tcon *tcon)",
          "50: {",
          "52:  int dfsplen;",
          "53:  char *full_path = NULL;",
          "",
          "[Removed Lines]",
          "51:  int pplen = vol->prepath ? strlen(vol->prepath) : 0;",
          "",
          "[Added Lines]",
          "51:  int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:  if (dfsplen)",
          "71:   strncpy(full_path, tcon->treeName, dfsplen);",
          "73:  convert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));",
          "75:  return full_path;",
          "",
          "[Removed Lines]",
          "72:  strncpy(full_path + dfsplen, vol->prepath, pplen);",
          "",
          "[Added Lines]",
          "72:  full_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);",
          "73:  strncpy(full_path + dfsplen + 1, vol->prepath, pplen);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
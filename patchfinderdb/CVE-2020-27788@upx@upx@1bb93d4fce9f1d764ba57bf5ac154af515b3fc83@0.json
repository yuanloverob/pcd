{
  "cve_id": "CVE-2020-27788",
  "cve_desc": "An out-of-bounds read access vulnerability was discovered in UPX in PackLinuxElf64::canPack() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service.",
  "repo": "upx/upx",
  "patch_hash": "1bb93d4fce9f1d764ba57bf5ac154af515b3fc83",
  "patch_info": {
    "commit_hash": "1bb93d4fce9f1d764ba57bf5ac154af515b3fc83",
    "repo": "upx/upx",
    "commit_url": "https://github.com/upx/upx/commit/1bb93d4fce9f1d764ba57bf5ac154af515b3fc83",
    "files": [
      "src/p_lx_elf.cpp"
    ],
    "message": "Detect bad e_shstrtab better.\n\nhttps://github.com/upx/upx/issues/332\n\tmodified:   p_lx_elf.cpp",
    "before_after_code_files": [
      "src/p_lx_elf.cpp||src/p_lx_elf.cpp"
    ]
  },
  "patch_diff": {
    "src/p_lx_elf.cpp||src/p_lx_elf.cpp": [
      "File: src/p_lx_elf.cpp -> src/p_lx_elf.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "2039:             if (sec_strndx) {",
      "2040:                 unsigned const sh_name = get_te32(&sec_strndx->sh_name);",
      "2041:                 if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)",
      "2043:                 || (sh_name",
      "2044:                   && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))",
      "2045:                 ) {",
      "2047:                 }",
      "2048:             }",
      "2049:         }",
      "",
      "[Removed Lines]",
      "2042:                 || (u32_t)file_size <= sh_name  // FIXME: weak",
      "2046:                     throwCantPack(\"bad e_shstrndx\");",
      "",
      "[Added Lines]",
      "2042:                 || (u32_t)file_size <= (sizeof(\".shstrtab\")",
      "2043:                     + sh_name + (shstrtab - (const char *)&file_image[0]))",
      "2047:                     throwCantPack(\"bad e_shstrtab\");",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2388:             if (sec_strndx) {",
      "2389:                 unsigned const sh_name = get_te32(&sec_strndx->sh_name);",
      "2390:                 if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)",
      "2392:                 || (sh_name",
      "2393:                   && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))",
      "2394:                 ) {",
      "2396:                 }",
      "2397:             }",
      "2398:         }",
      "",
      "[Removed Lines]",
      "2391:                 || (u32_t)file_size <= sh_name  // FIXME: weak",
      "2395:                     throwCantPack(\"bad e_shstrndx\");",
      "",
      "[Added Lines]",
      "2392:                 || (u32_t)file_size <= (sizeof(\".shstrtab\")",
      "2393:                     + sh_name + (shstrtab - (const char *)&file_image[0]))",
      "2397:                     throwCantPack(\"bad e_shstrtab\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d60fef753fe2810ecc5a25ef2973d50785860403",
      "candidate_info": {
        "commit_hash": "d60fef753fe2810ecc5a25ef2973d50785860403",
        "repo": "upx/upx",
        "commit_url": "https://github.com/upx/upx/commit/d60fef753fe2810ecc5a25ef2973d50785860403",
        "files": [
          "src/p_lx_elf.cpp",
          "src/p_lx_elf.h"
        ],
        "message": "check_pt_load(); u32_t, u64_t; (off_t) is not unsigned!\n\nhttps://github.com/upx/upx/issues/247\n\tmodified:   p_lx_elf.cpp\n\tmodified:   p_lx_elf.h",
        "before_after_code_files": [
          "src/p_lx_elf.cpp||src/p_lx_elf.cpp",
          "src/p_lx_elf.h||src/p_lx_elf.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/p_lx_elf.cpp||src/p_lx_elf.cpp"
          ],
          "candidate": [
            "src/p_lx_elf.cpp||src/p_lx_elf.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/p_lx_elf.cpp||src/p_lx_elf.cpp": [
          "File: src/p_lx_elf.cpp -> src/p_lx_elf.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "120:     if (mb.getVoidPtr() == NULL) {",
          "121:         mb.alloc(size);",
          "122:     } else {",
          "124:     }",
          "125: }",
          "",
          "[Removed Lines]",
          "123:         assert(size <= (off_t) mb.getSize());",
          "",
          "[Added Lines]",
          "123:         assert((u32_t)size <= mb.getSize());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "300:         if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {",
          "301:             dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);",
          "302:             invert_pt_dynamic(dynseg);",
          "304:         }",
          "306:         dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);",
          "",
          "[Removed Lines]",
          "303:             break;",
          "",
          "[Added Lines]",
          "303:         }",
          "304:         else if (PT_LOAD32==get_te32(&phdr->p_type)) {",
          "305:             check_pt_load(phdr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "772:         if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {",
          "773:             dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);",
          "774:             invert_pt_dynamic(dynseg);",
          "776:         }",
          "778:         dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);",
          "",
          "[Removed Lines]",
          "775:             break;",
          "",
          "[Added Lines]",
          "777:         }",
          "778:         else if (PT_LOAD64==get_te32(&phdr->p_type)) {",
          "779:             check_pt_load(phdr);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1580:     unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];",
          "1581:     if (z_str) {",
          "1582:         strtab_end = get_te32(&dynp0[-1+ z_str].d_val);",
          "1584:             char msg[50]; snprintf(msg, sizeof(msg),",
          "1585:                 \"bad DT_STRSZ %#x\", strtab_end);",
          "1586:             throwCantPack(msg);",
          "",
          "[Removed Lines]",
          "1583:         if (file_size <= (off_t)strtab_end) { // FIXME: weak",
          "",
          "[Added Lines]",
          "1587:         if ((u32_t)file_size <= strtab_end) { // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1694:     int j = e_shnum;",
          "1695:     for (; 0 <=--j; ++shdr) {",
          "1696:         unsigned const sh_name = get_te32(&shdr->sh_name);",
          "1698:             char msg[50]; snprintf(msg, sizeof(msg),",
          "1699:                 \"bad Elf32_Shdr[%d].sh_name %#x\",",
          "1700:                 -1+ e_shnum -j, sh_name);",
          "",
          "[Removed Lines]",
          "1697:         if (file_size <= (off_t)sh_name) {  // FIXME: weak",
          "",
          "[Added Lines]",
          "1701:         if ((u32_t)file_size <= sh_name) {  // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1718:     int j = e_shnum;",
          "1719:     for (; 0 <=--j; ++shdr) {",
          "1720:         unsigned const sh_name = get_te32(&shdr->sh_name);",
          "1722:             char msg[50]; snprintf(msg, sizeof(msg),",
          "1723:                 \"bad Elf64_Shdr[%d].sh_name %#x\",",
          "1724:                 -1+ e_shnum -j, sh_name);",
          "",
          "[Removed Lines]",
          "1721:         if (file_size <= (off_t)sh_name) {  // FIXME: weak",
          "",
          "[Added Lines]",
          "1725:         if ((u32_t)file_size <= sh_name) {  // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1977:                 }",
          "1978:                 sec_strndx = &shdri[e_shstrndx];",
          "1979:                 unsigned const sh_offset = get_te32(&sec_strndx->sh_offset);",
          "1981:                     char msg[50]; snprintf(msg, sizeof(msg),",
          "1982:                         \"bad .e_shstrndx->sh_offset %#x\", sh_offset);",
          "1983:                     throwCantPack(msg);",
          "",
          "[Removed Lines]",
          "1980:                 if (file_size <= (off_t)sh_offset) {",
          "",
          "[Added Lines]",
          "1984:                 if ((u32_t)file_size <= sh_offset) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1997:             if (sec_strndx) {",
          "1998:                 unsigned const sh_name = get_te32(&sec_strndx->sh_name);",
          "1999:                 if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)",
          "2001:                 || (sh_name",
          "2002:                   && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))",
          "2003:                 ) {",
          "",
          "[Removed Lines]",
          "2000:                 || file_size <= (off_t)sh_name  // FIXME: weak",
          "",
          "[Added Lines]",
          "2004:                 || (u32_t)file_size <= sh_name  // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2011:         if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {",
          "2012:             dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);",
          "2013:             invert_pt_dynamic(dynseg);",
          "2015:         }",
          "2017:         dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);",
          "",
          "[Removed Lines]",
          "2014:             break;",
          "",
          "[Added Lines]",
          "2018:         }",
          "2019:         else if (PT_LOAD32==get_te32(&phdr->p_type)) {",
          "2020:             check_pt_load(phdr);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2067:                     ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init",
          "2068:                         &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {",
          "2069:                         user_init_off = get_te32(&shdr->sh_offset);",
          "2071:                             char msg[70]; snprintf(msg, sizeof(msg),",
          "2072:                                 \"bad Elf32_Shdr[%d].sh_offset %#x\",",
          "2073:                                 -1+ e_shnum - j, user_init_off);",
          "",
          "[Removed Lines]",
          "2070:                         if (file_size <= (off_t)user_init_off) {",
          "",
          "[Added Lines]",
          "2076:                         if ((u32_t)file_size <= user_init_off) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2264:                 }",
          "2265:                 sec_strndx = &shdri[e_shstrndx];",
          "2266:                 upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset);",
          "2268:                     char msg[50]; snprintf(msg, sizeof(msg),",
          "2269:                         \"bad .e_shstrndx->sh_offset %#lx\", (long unsigned)sh_offset);",
          "2270:                     throwCantPack(msg);",
          "",
          "[Removed Lines]",
          "2267:                 if (file_size <= (off_t)sh_offset) {",
          "",
          "[Added Lines]",
          "2273:                 if ((u64_t)file_size <= sh_offset) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2284:             if (sec_strndx) {",
          "2285:                 unsigned const sh_name = get_te32(&sec_strndx->sh_name);",
          "2286:                 if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)",
          "2288:                 || (sh_name",
          "2289:                   && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))",
          "2290:                 ) {",
          "",
          "[Removed Lines]",
          "2287:                 || file_size <= (off_t)sh_name  // FIXME: weak",
          "",
          "[Added Lines]",
          "2293:                 || (u32_t)file_size <= sh_name  // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2298:         if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {",
          "2299:             dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);",
          "2300:             invert_pt_dynamic(dynseg);",
          "2302:         }",
          "2304:         dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);",
          "",
          "[Removed Lines]",
          "2301:             break;",
          "",
          "[Added Lines]",
          "2307:         }",
          "2308:         else if (PT_LOAD64==get_te32(&phdr->p_type)) {",
          "2309:             check_pt_load(phdr);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2345:                     ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init",
          "2346:                         &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {",
          "2347:                         user_init_off = get_te64(&shdr->sh_offset);",
          "2349:                             char msg[70]; snprintf(msg, sizeof(msg),",
          "2350:                                 \"bad Elf64_Shdr[%d].sh_offset %#x\",",
          "2351:                                 -1+ e_shnum - j, user_init_off);",
          "",
          "[Removed Lines]",
          "2348:                         if (file_size <= (off_t)user_init_off) {",
          "",
          "[Added Lines]",
          "2356:                         if ((u64_t)file_size <= user_init_off) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3688:         }",
          "3689:         x.offset = get_te32(&phdri[k].p_offset);",
          "3690:         x.size   = get_te32(&phdri[k].p_filesz);",
          "3692:             if (0 == nx) { // 1st PT_LOAD32 must cover Ehdr at 0==p_offset",
          "3693:                 unsigned const delta = hdr_u_len;",
          "3694:                 if (ft.id < 0x40) {",
          "",
          "[Removed Lines]",
          "3691:         if (!is_shlib || (off_t)hdr_u_len < x.size) {",
          "",
          "[Added Lines]",
          "3699:         if (!is_shlib || hdr_u_len < (u32_t)x.size) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3721:         total_in += find_LOAD_gap(phdri, k, e_phnum);",
          "3722:     }",
          "3725:         throwEOFException();",
          "3727:     return 0;  // omit end-of-compression bhdr for now",
          "",
          "[Removed Lines]",
          "3724:     if ((off_t)total_in != file_size)",
          "",
          "[Added Lines]",
          "3732:     if (total_in != (u32_t)file_size)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3812:         }",
          "3813:         x.offset = get_te64(&phdri[k].p_offset);",
          "3814:         x.size   = get_te64(&phdri[k].p_filesz);",
          "3816:             if (0 == nx) { // 1st PT_LOAD64 must cover Ehdr at 0==p_offset",
          "3817:                 unsigned const delta = hdr_u_len;",
          "3818:                 if (ft.id < 0x40) {",
          "",
          "[Removed Lines]",
          "3815:         if (!is_shlib || (off_t)hdr_u_len < x.size) {",
          "",
          "[Added Lines]",
          "3823:         if (!is_shlib || hdr_u_len < (u64_t)x.size) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3845:         total_in += find_LOAD_gap(phdri, k, e_phnum);",
          "3846:     }",
          "3849:         throwEOFException();",
          "3851:     return 0;  // omit end-of-compression bhdr for now",
          "",
          "[Removed Lines]",
          "3848:     if ((off_t)total_in != file_size)",
          "",
          "[Added Lines]",
          "3856:     if (total_in != (u32_t)file_size)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "4193:     p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));",
          "4194:     unsigned orig_file_size = get_te32(&hbuf.p_filesize);",
          "4195:     blocksize = get_te32(&hbuf.p_blocksize);",
          "4197:         || !mem_size_valid(1, blocksize, OVERHEAD))",
          "4198:         throwCantUnpack(\"p_info corrupted\");",
          "",
          "[Removed Lines]",
          "4196:     if (file_size > (off_t)orig_file_size || blocksize > orig_file_size",
          "",
          "[Added Lines]",
          "4204:     if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4659:         unsigned const t = addr - get_te32(&phdr->p_vaddr);",
          "4660:         if (t < get_te32(&phdr->p_filesz)) {",
          "4661:             unsigned const p_offset = get_te32(&phdr->p_offset);",
          "4663:                 char msg[40]; snprintf(msg, sizeof(msg),",
          "4664:                     \"bad Elf32_Phdr[%d].p_offset %x\",",
          "4665:                     -1+ e_phnum - j, p_offset);",
          "",
          "[Removed Lines]",
          "4662:             if (file_size <= (off_t)p_offset) { // FIXME: weak",
          "",
          "[Added Lines]",
          "4670:             if ((u32_t)file_size <= p_offset) { // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4671:     return 0;",
          "4672: }",
          "4674: Elf32_Dyn const *",
          "4675: PackLinuxElf32::elf_has_dynamic(unsigned int key) const",
          "4676: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4682: u32_t  // returns .p_offset",
          "4683: PackLinuxElf32::check_pt_load(Elf32_Phdr const *const phdr)",
          "4684: {",
          "4685:     u32_t filesz = get_te32(&phdr->p_filesz);",
          "4686:     u32_t offset = get_te32(&phdr->p_offset), offend = filesz + offset;",
          "4687:     u32_t vaddr  = get_te32(&phdr->p_vaddr);",
          "4688:     u32_t paddr  = get_te32(&phdr->p_paddr);",
          "4689:     u32_t align  = get_te32(&phdr->p_align);",
          "4691:     if ((-1+ align) & (paddr ^ vaddr)",
          "4692:     ||  (u32_t)file_size <= (u32_t)offset",
          "4693:     ||  (u32_t)file_size <  (u32_t)offend",
          "4694:     ||  (u32_t)file_size <= (u32_t)filesz) {",
          "4695:         char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_LOAD phdr[%u]\",",
          "4696:             (unsigned)(phdr - phdri));",
          "4697:         throwCantPack(msg);",
          "4698:     }",
          "4699:     return offset;",
          "4700: }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4689:     unsigned vaddr = get_te32(&phdr->p_vaddr);",
          "4690:     unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);",
          "4691:     unsigned align = get_te32(&phdr->p_align);",
          "4693:     ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)",
          "4694:     ||  (-1+ align) & (t ^ vaddr)",
          "4695:     ||  filesz < sizeof(Elf32_Dyn)",
          "",
          "[Removed Lines]",
          "4692:     if (s < t || file_size < (off_t)s",
          "",
          "[Added Lines]",
          "4720:     if (s < t || file_size < (u32_t)s",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "4740:         upx_uint64_t const t = addr - get_te64(&phdr->p_vaddr);",
          "4741:         if (t < get_te64(&phdr->p_filesz)) {",
          "4742:             upx_uint64_t const p_offset = get_te64(&phdr->p_offset);",
          "4744:                 char msg[40]; snprintf(msg, sizeof(msg),",
          "4745:                     \"bad Elf64_Phdr[%d].p_offset %#lx\",",
          "4746:                     -1+ e_phnum - j, (long unsigned)p_offset);",
          "",
          "[Removed Lines]",
          "4743:             if (file_size <= (off_t)p_offset) { // FIXME: weak",
          "",
          "[Added Lines]",
          "4771:             if ((u64_t)file_size <= p_offset) { // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4752:     return 0;",
          "4753: }",
          "4755: Elf64_Dyn const *",
          "4756: PackLinuxElf64::elf_has_dynamic(unsigned int key) const",
          "4757: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4783: u64_t  // returns .p_offset",
          "4784: PackLinuxElf64::check_pt_load(Elf64_Phdr const *const phdr)",
          "4785: {",
          "4786:     u64_t filesz = get_te64(&phdr->p_filesz);",
          "4787:     u64_t offset = get_te64(&phdr->p_offset), offend = filesz + offset;",
          "4788:     u64_t vaddr  = get_te64(&phdr->p_vaddr);",
          "4789:     u64_t paddr  = get_te64(&phdr->p_paddr);",
          "4790:     u64_t align  = get_te64(&phdr->p_align);",
          "4792:     if ((-1+ align) & (paddr ^ vaddr)",
          "4793:     ||  (u64_t)file_size <= (u64_t)offset",
          "4794:     ||  (u64_t)file_size <  (u64_t)offend",
          "4795:     ||  (u64_t)file_size <= (u64_t)filesz) {",
          "4796:         char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_LOAD phdr[%u]\",",
          "4797:             (unsigned)(phdr - phdri));",
          "4798:         throwCantPack(msg);",
          "4799:     }",
          "4800:     return offset;",
          "4801: }",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "4815:     unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];",
          "4816:     if (z_str) {",
          "4817:         strtab_end = get_te64(&dynp0[-1+ z_str].d_val);",
          "4819:             char msg[50]; snprintf(msg, sizeof(msg),",
          "4820:                 \"bad DT_STRSZ %#x\", strtab_end);",
          "4821:             throwCantPack(msg);",
          "",
          "[Removed Lines]",
          "4818:         if (file_size <= (off_t)strtab_end) { // FIXME: weak",
          "",
          "[Added Lines]",
          "4866:         if ((u64_t)file_size <= strtab_end) { // FIXME: weak",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "5080:     p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));",
          "5081:     unsigned orig_file_size = get_te32(&hbuf.p_filesize);",
          "5082:     blocksize = get_te32(&hbuf.p_blocksize);",
          "5084:         || !mem_size_valid(1, blocksize, OVERHEAD))",
          "5085:         throwCantUnpack(\"p_info corrupted\");",
          "",
          "[Removed Lines]",
          "5083:     if (file_size > (off_t)orig_file_size || blocksize > orig_file_size",
          "",
          "[Added Lines]",
          "5131:     if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size",
          "",
          "---------------"
        ],
        "src/p_lx_elf.h||src/p_lx_elf.h": [
          "File: src/p_lx_elf.h -> src/p_lx_elf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #ifndef __UPX_P_LX_ELF_H  //{",
          "34: #define __UPX_P_LX_ELF_H 1",
          "37: class PackLinuxElf : public PackUnix",
          "38: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: typedef upx_uint32_t u32_t;  // easier to type; more narrow",
          "37: typedef upx_uint64_t u64_t;  // easier to type; more narrow",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "156:     Elf32_Phdr const *elf_find_ptype(unsigned type, Elf32_Phdr const *phdr0, unsigned phnum);",
          "157:     Elf32_Shdr const *elf_find_section_name(char const *) const;",
          "158:     Elf32_Shdr const *elf_find_section_type(unsigned) const;",
          "159:     unsigned check_pt_dynamic(Elf32_Phdr const *);",
          "160:     void invert_pt_dynamic(Elf32_Dyn const *);",
          "161:     void const *elf_find_dynamic(unsigned) const;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:     unsigned check_pt_load(Elf32_Phdr const *);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "292:     Elf64_Phdr const *elf_find_ptype(unsigned type, Elf64_Phdr const *phdr0, unsigned phnum);",
          "293:     Elf64_Shdr const *elf_find_section_name(char const *) const;",
          "294:     Elf64_Shdr const *elf_find_section_type(unsigned) const;",
          "295:     upx_uint64_t check_pt_dynamic(Elf64_Phdr const *);",
          "296:     void invert_pt_dynamic(Elf64_Dyn const *);",
          "297:     void const *elf_find_dynamic(unsigned) const;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "298:     upx_uint64_t check_pt_load(Elf64_Phdr const *);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
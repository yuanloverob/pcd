{
  "cve_id": "CVE-2017-7705",
  "cve_desc": "In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the RPC over RDMA dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-rpcrdma.c by correctly checking for going beyond the maximum offset.",
  "repo": "wireshark/wireshark",
  "patch_hash": "280f2feeaf95fcf50f028162b49be1bf6866c918",
  "patch_info": {
    "commit_hash": "280f2feeaf95fcf50f028162b49be1bf6866c918",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/280f2feeaf95fcf50f028162b49be1bf6866c918",
    "files": [
      "epan/dissectors/packet-rpcrdma.c"
    ],
    "message": "RPC-over-RDMA: protect against a variable overflow\n\nBug: 13558\nChange-Id: I0cb379df1a6c40a3c4a84f18c631d9239550c3ab\nReviewed-on: https://code.wireshark.org/review/20941\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
      "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "168: static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)",
      "169: {",
      "170:     guint32 value_follows;",
      "173:     while (1) {",
      "174:         value_follows = tvb_get_ntohl(tvb, offset);",
      "",
      "[Removed Lines]",
      "171:     guint start = offset;",
      "",
      "[Added Lines]",
      "171:     guint chunk_size, start = offset;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "178:         if (!value_follows)",
      "179:             break;",
      "183:             return 0;",
      "184:     }",
      "186:     return offset - start;",
      "",
      "[Removed Lines]",
      "181:         offset += get_write_chunk_size(tvb, offset);",
      "182:         if (offset > max_offset)",
      "",
      "[Added Lines]",
      "181:         chunk_size = get_write_chunk_size(tvb, offset);",
      "182:         if ((offset + chunk_size) < offset ||",
      "183:             (offset + chunk_size) > max_offset)",
      "185:         offset += chunk_size;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "189: static guint get_write_list_chunk_count(tvbuff_t *tvb, guint offset)",
      "190: {",
      "191:     guint32 value_follows;",
      "194:     num_chunks = 0;",
      "195:     while (1) {",
      "",
      "[Removed Lines]",
      "192:     guint num_chunks;",
      "",
      "[Added Lines]",
      "194:     guint num_chunks, chunk_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "199:             break;",
      "201:         num_chunks++;",
      "203:     }",
      "205:    return num_chunks;",
      "",
      "[Removed Lines]",
      "202:         offset += get_write_chunk_size(tvb, offset);",
      "",
      "[Added Lines]",
      "204:         chunk_size = get_write_chunk_size(tvb, offset);",
      "205:         if ((offset + chunk_size) < offset)",
      "206:             break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2462f9e8103b23c2728cc5aa84995e0b2f363f12",
      "candidate_info": {
        "commit_hash": "2462f9e8103b23c2728cc5aa84995e0b2f363f12",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/2462f9e8103b23c2728cc5aa84995e0b2f363f12",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "packet-rpcrdma: Fix protocol frame pre-detection\n\nThe current mechanism of detecting RPC-over-RDMA is broken because\nit treats the Read list as a counted array (it's a list); and treats\nthe Write list and Reply chunk identically (one is a list, one is\nalways a single chunk).\n\nWhile we're here, refactor pre-detection helper functions so they\ncan be used during frame dissection as well.\n\nBug: 13196\nChange-Id: I76e210c8d2a9464fed00e7199072d37f4ebbebf2\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-on: https://code.wireshark.org/review/19025\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:     {0, NULL}",
          "131: };",
          "133: static guint parse_list(tvbuff_t *tvb, guint offset, proto_tree *tree,",
          "134:         int hf_item, const char* msg, gboolean have_position)",
          "135: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: static guint get_read_list_size(tvbuff_t *tvb, guint max_offset, guint offset)",
          "134: {",
          "135:     guint32 value_follows;",
          "136:     guint start = offset;",
          "138:     while (1) {",
          "139:         value_follows = tvb_get_ntohl(tvb, offset);",
          "140:         offset += 4;",
          "141:         if (offset > max_offset)",
          "142:             return 0;",
          "143:         if (!value_follows)",
          "144:             break;",
          "146:         offset += 20;",
          "147:         if (offset > max_offset)",
          "148:             return 0;",
          "149:     }",
          "151:     return offset - start;",
          "152: }",
          "154: static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)",
          "155: {",
          "156:     guint32 value_follows, segment_count;",
          "157:     guint start = offset;",
          "159:     while (1) {",
          "160:         value_follows = tvb_get_ntohl(tvb, offset);",
          "161:         offset += 4;",
          "162:         if (offset > max_offset)",
          "163:             return 0;",
          "164:         if (!value_follows)",
          "165:             break;",
          "167:         segment_count = tvb_get_ntohl(tvb, offset);",
          "168:         offset += 4;",
          "169:         if (offset > max_offset)",
          "170:             return 0;",
          "171:         offset += (segment_count * 16);",
          "172:         if (offset > max_offset)",
          "173:             return 0;",
          "174:     }",
          "176:     return offset - start;",
          "177: }",
          "179: static guint get_reply_chunk_size(tvbuff_t *tvb, guint max_offset, guint offset)",
          "180: {",
          "181:     guint32 value_follows, segment_count;",
          "182:     guint start = offset;",
          "184:     value_follows = tvb_get_ntohl(tvb, offset);",
          "185:     offset += 4;",
          "186:     if (offset > max_offset)",
          "187:         return 0;",
          "189:     if (value_follows) {",
          "190:         segment_count = tvb_get_ntohl(tvb, offset);",
          "191:         offset += segment_count * 16 + 4;",
          "192:         if (offset > max_offset)",
          "193:             return 0;",
          "194:     }",
          "196:     return offset - start;",
          "197: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "178:     return offset;",
          "179: }",
          "183: {",
          "220: }",
          "",
          "[Removed Lines]",
          "181: static gboolean",
          "182: get_chunk_len(tvbuff_t *tvb, guint offset, guint len, guint num_position_bytes, guint *res)",
          "184:     guint32 arr_len, i, val, temp;",
          "186:     if (offset + 4 > len)",
          "187:         return FALSE;",
          "189:     arr_len = tvb_get_ntohl(tvb, offset);",
          "190:     offset += 4;",
          "192:     for (i = 0; i < arr_len; i++) {",
          "193:         if (offset + 4 > len)",
          "194:             return FALSE;",
          "195:         val = tvb_get_ntohl(tvb, offset);",
          "196:         offset += 4;",
          "199:         temp = offset + val * (16 + num_position_bytes);",
          "200:         if ((temp > len) || (temp < offset))",
          "201:             return FALSE;",
          "202:         offset = temp;",
          "203:     }",
          "204:     DISSECTOR_ASSERT(offset <= len);",
          "207:     return TRUE;",
          "208: }",
          "210: static gboolean",
          "211: get_chunks_len(tvbuff_t *tvb, guint offset, guint len, guint *res)",
          "212: {",
          "213:     if (!get_chunk_len(tvb, offset, len, 4, res))",
          "214:         return FALSE;",
          "216:     if (!get_chunk_len(tvb, *res, len, 0, res))",
          "217:         return FALSE;",
          "219:     return get_chunk_len(tvb, *res, len, 0, res);",
          "",
          "[Added Lines]",
          "247: static guint get_chunk_lists_size(tvbuff_t *tvb, guint max_offset, guint offset)",
          "249:     guint size, start = offset;",
          "251:     size = get_read_list_size(tvb, max_offset, offset);",
          "252:     if (!size)",
          "253:         return 0;",
          "254:     offset += size;",
          "256:     size = get_write_list_size(tvb, max_offset, offset);",
          "257:     if (!size)",
          "258:         return 0;",
          "259:     offset += size;",
          "261:     size = get_reply_chunk_size(tvb, max_offset, offset);",
          "262:     if (!size)",
          "263:         return 0;",
          "264:     offset += size;",
          "266:     return offset - start;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "229: static gboolean",
          "230: packet_is_rpcordma(tvbuff_t *tvb)",
          "231: {",
          "233:     guint32 xid_rpc;",
          "234:     guint32 xid = tvb_get_ntohl(tvb, 0);",
          "235:     guint32 msg_type = tvb_get_ntohl(tvb, 12);",
          "",
          "[Removed Lines]",
          "232:     guint len = tvb_reported_length(tvb);",
          "",
          "[Added Lines]",
          "279:     guint size, len = tvb_reported_length(tvb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "239:     case RDMA_MSG:",
          "240:         if (len < MIN_RPCRDMA_MSG_SZ)",
          "241:             return FALSE;",
          "243:             return FALSE;",
          "245:         if (offset + 4 > len)",
          "246:             return FALSE;",
          "",
          "[Removed Lines]",
          "242:         if (!get_chunks_len(tvb, MIN_RPCRDMA_HDR_SZ, len, &offset))",
          "",
          "[Added Lines]",
          "289:         offset = MIN_RPCRDMA_HDR_SZ;",
          "290:         size = get_chunk_lists_size(tvb, len, offset);",
          "291:         if (!size)",
          "293:         offset += size;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "252:     case RDMA_MSGP:",
          "253:         if (len < MIN_RPCRDMA_MSGP_SZ)",
          "254:             return FALSE;",
          "256:             return FALSE;",
          "258:         if (offset + 4 > len)",
          "259:             return FALSE;",
          "",
          "[Removed Lines]",
          "255:         if (!get_chunks_len(tvb, MIN_RPCRDMA_HDR_SZ + 8, len, &offset))",
          "",
          "[Added Lines]",
          "305:         offset = MIN_RPCRDMA_HDR_SZ + 8;",
          "306:         size = get_chunk_lists_size(tvb, len, offset);",
          "307:         if (!size)",
          "309:         offset += size;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-0160",
  "cve_desc": "The (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.",
  "repo": "openssl/openssl",
  "patch_hash": "731f431497f463f3a2a97236fe0187b11c44aead",
  "patch_info": {
    "commit_hash": "731f431497f463f3a2a97236fe0187b11c44aead",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/731f431497f463f3a2a97236fe0187b11c44aead",
    "files": [
      "CHANGES",
      "ssl/d1_both.c",
      "ssl/t1_lib.c"
    ],
    "message": "Add heartbeat extension bounds check.\n\nA missing bounds check in the handling of the TLS heartbeat extension\ncan be used to reveal up to 64k of memory to a connected client or\nserver.\n\nThanks for Neel Mehta of Google Security for discovering this bug and to\nAdam Langley <agl@chromium.org> and Bodo Moeller <bmoeller@acm.org> for\npreparing the fix (CVE-2014-0160)\n(cherry picked from commit 96db9023b881d7cd9f379b0c154650d6c108e9a3)",
    "before_after_code_files": [
      "ssl/d1_both.c||ssl/d1_both.c",
      "ssl/t1_lib.c||ssl/t1_lib.c"
    ]
  },
  "patch_diff": {
    "ssl/d1_both.c||ssl/d1_both.c": [
      "File: ssl/d1_both.c -> ssl/d1_both.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1330:  unsigned int payload;",
      "1338:  if (s->msg_callback)",
      "1339:   s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
      "1340:    &s->s3->rrec.data[0], s->s3->rrec.length,",
      "1341:    s, s->msg_callback_arg);",
      "1343:  if (hbtype == TLS1_HB_REQUEST)",
      "1344:   {",
      "1345:   unsigned char *buffer, *bp;",
      "1346:   int r;",
      "1353:   bp = buffer;",
      "",
      "[Removed Lines]",
      "1334:  hbtype = *p++;",
      "1335:  n2s(p, payload);",
      "1336:  pl = p;",
      "1352:   buffer = OPENSSL_malloc(1 + 2 + payload + padding);",
      "",
      "[Added Lines]",
      "1339:  if (1 + 2 + 16 > s->s3->rrec.length)",
      "1341:  hbtype = *p++;",
      "1342:  n2s(p, payload);",
      "1343:  if (1 + 2 + payload + 16 > s->s3->rrec.length)",
      "1345:  pl = p;",
      "1350:   unsigned int write_length = 1 /* heartbeat type */ +",
      "1351:          2 /* heartbeat length */ +",
      "1352:          payload + padding;",
      "1355:   if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)",
      "1356:    return 0;",
      "1362:   buffer = OPENSSL_malloc(write_length);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1361:   RAND_pseudo_bytes(bp, padding);",
      "1365:   if (r >= 0 && s->msg_callback)",
      "1366:    s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,",
      "1368:     s, s->msg_callback_arg);",
      "1370:   OPENSSL_free(buffer);",
      "",
      "[Removed Lines]",
      "1363:   r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);",
      "1367:     buffer, 3 + payload + padding,",
      "",
      "[Added Lines]",
      "1373:   r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);",
      "1377:     buffer, write_length,",
      "",
      "---------------"
    ],
    "ssl/t1_lib.c||ssl/t1_lib.c": [
      "File: ssl/t1_lib.c -> ssl/t1_lib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3969:  unsigned int payload;",
      "3977:  if (s->msg_callback)",
      "3978:   s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
      "3979:    &s->s3->rrec.data[0], s->s3->rrec.length,",
      "3980:    s, s->msg_callback_arg);",
      "3982:  if (hbtype == TLS1_HB_REQUEST)",
      "3983:   {",
      "3984:   unsigned char *buffer, *bp;",
      "",
      "[Removed Lines]",
      "3973:  hbtype = *p++;",
      "3974:  n2s(p, payload);",
      "3975:  pl = p;",
      "",
      "[Added Lines]",
      "3978:  if (1 + 2 + 16 > s->s3->rrec.length)",
      "3980:  hbtype = *p++;",
      "3981:  n2s(p, payload);",
      "3982:  if (1 + 2 + payload + 16 > s->s3->rrec.length)",
      "3984:  pl = p;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7e840163c06c7692b796a93e3fa85a93136adbb2",
      "candidate_info": {
        "commit_hash": "7e840163c06c7692b796a93e3fa85a93136adbb2",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/7e840163c06c7692b796a93e3fa85a93136adbb2",
        "files": [
          "CHANGES",
          "ssl/d1_both.c",
          "ssl/t1_lib.c"
        ],
        "message": "Add heartbeat extension bounds check.\n\nA missing bounds check in the handling of the TLS heartbeat extension\ncan be used to reveal up to 64k of memory to a connected client or\nserver.\n\nThanks for Neel Mehta of Google Security for discovering this bug and to\nAdam Langley <agl@chromium.org> and Bodo Moeller <bmoeller@acm.org> for\npreparing the fix (CVE-2014-0160)\n(cherry picked from commit 96db9023b881d7cd9f379b0c154650d6c108e9a3)",
        "before_after_code_files": [
          "ssl/d1_both.c||ssl/d1_both.c",
          "ssl/t1_lib.c||ssl/t1_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_both.c||ssl/d1_both.c": [
          "File: ssl/d1_both.c -> ssl/d1_both.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1330:  unsigned int payload;",
          "1338:  if (s->msg_callback)",
          "1339:   s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "1340:    &s->s3->rrec.data[0], s->s3->rrec.length,",
          "1341:    s, s->msg_callback_arg);",
          "1343:  if (hbtype == TLS1_HB_REQUEST)",
          "1344:   {",
          "1345:   unsigned char *buffer, *bp;",
          "1346:   int r;",
          "1353:   bp = buffer;",
          "",
          "[Removed Lines]",
          "1334:  hbtype = *p++;",
          "1335:  n2s(p, payload);",
          "1336:  pl = p;",
          "1352:   buffer = OPENSSL_malloc(1 + 2 + payload + padding);",
          "",
          "[Added Lines]",
          "1339:  if (1 + 2 + 16 > s->s3->rrec.length)",
          "1341:  hbtype = *p++;",
          "1342:  n2s(p, payload);",
          "1343:  if (1 + 2 + payload + 16 > s->s3->rrec.length)",
          "1345:  pl = p;",
          "1350:   unsigned int write_length = 1 /* heartbeat type */ +",
          "1351:          2 /* heartbeat length */ +",
          "1352:          payload + padding;",
          "1355:   if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)",
          "1356:    return 0;",
          "1362:   buffer = OPENSSL_malloc(write_length);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1361:   RAND_pseudo_bytes(bp, padding);",
          "1365:   if (r >= 0 && s->msg_callback)",
          "1366:    s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,",
          "1368:     s, s->msg_callback_arg);",
          "1370:   OPENSSL_free(buffer);",
          "",
          "[Removed Lines]",
          "1363:   r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);",
          "1367:     buffer, 3 + payload + padding,",
          "",
          "[Added Lines]",
          "1373:   r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);",
          "1377:     buffer, write_length,",
          "",
          "---------------"
        ],
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3801:  unsigned int payload;",
          "3809:  if (s->msg_callback)",
          "3810:   s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "3811:    &s->s3->rrec.data[0], s->s3->rrec.length,",
          "3812:    s, s->msg_callback_arg);",
          "3814:  if (hbtype == TLS1_HB_REQUEST)",
          "3815:   {",
          "3816:   unsigned char *buffer, *bp;",
          "",
          "[Removed Lines]",
          "3805:  hbtype = *p++;",
          "3806:  n2s(p, payload);",
          "3807:  pl = p;",
          "",
          "[Added Lines]",
          "3810:  if (1 + 2 + 16 > s->s3->rrec.length)",
          "3812:  hbtype = *p++;",
          "3813:  n2s(p, payload);",
          "3814:  if (1 + 2 + payload + 16 > s->s3->rrec.length)",
          "3816:  pl = p;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "96db9023b881d7cd9f379b0c154650d6c108e9a3",
      "candidate_info": {
        "commit_hash": "96db9023b881d7cd9f379b0c154650d6c108e9a3",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/96db9023b881d7cd9f379b0c154650d6c108e9a3",
        "files": [
          "CHANGES",
          "ssl/d1_both.c",
          "ssl/t1_lib.c"
        ],
        "message": "Add heartbeat extension bounds check.\n\nA missing bounds check in the handling of the TLS heartbeat extension\ncan be used to reveal up to 64k of memory to a connected client or\nserver.\n\nThanks for Neel Mehta of Google Security for discovering this bug and to\nAdam Langley <agl@chromium.org> and Bodo Moeller <bmoeller@acm.org> for\npreparing the fix (CVE-2014-0160)",
        "before_after_code_files": [
          "ssl/d1_both.c||ssl/d1_both.c",
          "ssl/t1_lib.c||ssl/t1_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_both.c||ssl/d1_both.c": [
          "File: ssl/d1_both.c -> ssl/d1_both.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1459:  unsigned int payload;",
          "1467:  if (s->msg_callback)",
          "1468:   s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "1469:    &s->s3->rrec.data[0], s->s3->rrec.length,",
          "1470:    s, s->msg_callback_arg);",
          "1472:  if (hbtype == TLS1_HB_REQUEST)",
          "1473:   {",
          "1474:   unsigned char *buffer, *bp;",
          "1475:   int r;",
          "1482:   bp = buffer;",
          "",
          "[Removed Lines]",
          "1463:  hbtype = *p++;",
          "1464:  n2s(p, payload);",
          "1465:  pl = p;",
          "1481:   buffer = OPENSSL_malloc(1 + 2 + payload + padding);",
          "",
          "[Added Lines]",
          "1468:  if (1 + 2 + 16 > s->s3->rrec.length)",
          "1470:  hbtype = *p++;",
          "1471:  n2s(p, payload);",
          "1472:  if (1 + 2 + payload + 16 > s->s3->rrec.length)",
          "1474:  pl = p;",
          "1479:   unsigned int write_length = 1 /* heartbeat type */ +",
          "1480:          2 /* heartbeat length */ +",
          "1481:          payload + padding;",
          "1484:   if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)",
          "1485:    return 0;",
          "1491:   buffer = OPENSSL_malloc(write_length);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1490:   RAND_pseudo_bytes(bp, padding);",
          "1494:   if (r >= 0 && s->msg_callback)",
          "1495:    s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,",
          "1497:     s, s->msg_callback_arg);",
          "1499:   OPENSSL_free(buffer);",
          "",
          "[Removed Lines]",
          "1492:   r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);",
          "1496:     buffer, 3 + payload + padding,",
          "",
          "[Added Lines]",
          "1502:   r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);",
          "1506:     buffer, write_length,",
          "",
          "---------------"
        ],
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2588:  unsigned int payload;",
          "2596:  if (s->msg_callback)",
          "2597:   s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "2598:    &s->s3->rrec.data[0], s->s3->rrec.length,",
          "2599:    s, s->msg_callback_arg);",
          "2601:  if (hbtype == TLS1_HB_REQUEST)",
          "2602:   {",
          "2603:   unsigned char *buffer, *bp;",
          "",
          "[Removed Lines]",
          "2592:  hbtype = *p++;",
          "2593:  n2s(p, payload);",
          "2594:  pl = p;",
          "",
          "[Added Lines]",
          "2597:  if (1 + 2 + 16 > s->s3->rrec.length)",
          "2599:  hbtype = *p++;",
          "2600:  n2s(p, payload);",
          "2601:  if (1 + 2 + payload + 16 > s->s3->rrec.length)",
          "2603:  pl = p;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af4c6e348e4bad6303e7d214cdcf2536487aabe4",
      "candidate_info": {
        "commit_hash": "af4c6e348e4bad6303e7d214cdcf2536487aabe4",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/af4c6e348e4bad6303e7d214cdcf2536487aabe4",
        "files": [
          "ssl/d1_both.c"
        ],
        "message": "RT3301: Discard too-long heartbeat requests\n\nReviewed-by: Tim Hudson <tjh@openssl.org>",
        "before_after_code_files": [
          "ssl/d1_both.c||ssl/d1_both.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/d1_both.c||ssl/d1_both.c"
          ],
          "candidate": [
            "ssl/d1_both.c||ssl/d1_both.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_both.c||ssl/d1_both.c": [
          "File: ssl/d1_both.c -> ssl/d1_both.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1364:  if (1 + 2 + 16 > s->s3->rrec.length)",
          "1366:  hbtype = *p++;",
          "1367:  n2s(p, payload);",
          "1368:  if (1 + 2 + payload + 16 > s->s3->rrec.length)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1366:  if (s->s3->rrec.length > SSL3_RT_MAX_PLAIN_LENGTH)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2c60ed0452919ea9a67886685e2fa5c8b9330620",
      "candidate_info": {
        "commit_hash": "2c60ed0452919ea9a67886685e2fa5c8b9330620",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/2c60ed0452919ea9a67886685e2fa5c8b9330620",
        "files": [
          "ssl/d1_both.c",
          "ssl/heartbeat_test.c",
          "ssl/record/d1_pkt.c",
          "ssl/record/s3_pkt.c",
          "ssl/ssl_locl.h",
          "ssl/t1_lib.c"
        ],
        "message": "Removed dependency on rrec from heartbeat processing\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "ssl/d1_both.c||ssl/d1_both.c",
          "ssl/heartbeat_test.c||ssl/heartbeat_test.c",
          "ssl/record/d1_pkt.c||ssl/record/d1_pkt.c",
          "ssl/record/s3_pkt.c||ssl/record/s3_pkt.c",
          "ssl/ssl_locl.h||ssl/ssl_locl.h",
          "ssl/t1_lib.c||ssl/t1_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_both.c||ssl/d1_both.c": [
          "File: ssl/d1_both.c -> ssl/d1_both.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1347: }",
          "1349: #ifndef OPENSSL_NO_HEARTBEATS",
          "1351: {",
          "1353:     unsigned short hbtype;",
          "1354:     unsigned int payload;",
          "1361:     if (s->msg_callback)",
          "1362:         s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "",
          "[Removed Lines]",
          "1350: int dtls1_process_heartbeat(SSL *s)",
          "1352:     unsigned char *p, *pl;",
          "1356:     unsigned int length;",
          "1358:     p = SSL3_RECORD_get_data(RECORD_LAYER_get_rrec(&s->rlayer));",
          "1359:     length = SSL3_RECORD_get_length(RECORD_LAYER_get_rrec(&s->rlayer));",
          "",
          "[Added Lines]",
          "1350: int dtls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length)",
          "1352:     unsigned char *pl;",
          "",
          "---------------"
        ],
        "ssl/heartbeat_test.c||ssl/heartbeat_test.c": [
          "File: ssl/heartbeat_test.c -> ssl/heartbeat_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:     SSL_CTX *ctx;",
          "61:     SSL *s;",
          "62:     const char *test_case_name;",
          "64:     unsigned char *payload;",
          "65:     int sent_payload_len;",
          "66:     int expected_return_value;",
          "",
          "[Removed Lines]",
          "63:     int (*process_heartbeat) (SSL *s);",
          "",
          "[Added Lines]",
          "63:     int (*process_heartbeat) (SSL *s, unsigned char *p, unsigned int length);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "117:  fail:",
          "118:     if (!setup_ok) {",
          "",
          "[Removed Lines]",
          "115:     memset(fixture.s->s3->wbuf.buf, 0, fixture.s->s3->wbuf.len);",
          "",
          "[Added Lines]",
          "115:     memset(fixture.s->rlayer.wbuf.buf, 0, fixture.s->rlayer.wbuf.len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "202:     unsigned const char *p;",
          "203:     int actual_payload_len;",
          "208:     s2n(fixture.sent_payload_len, payload);",
          "",
          "[Removed Lines]",
          "205:     s->s3->rrec.data = payload;",
          "206:     s->s3->rrec.length = strlen((const char *)payload);",
          "",
          "[Added Lines]",
          "205:     s->rlayer.rrec.data = payload;",
          "206:     s->rlayer.rrec.length = strlen((const char *)payload);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "214:     memcpy((char *)sent_buf, (const char *)payload, sizeof(sent_buf));",
          "218:     if (return_value != fixture.expected_return_value) {",
          "219:         printf(\"%s failed: expected return value %d, received %d\\n\",",
          "",
          "[Removed Lines]",
          "216:     return_value = fixture.process_heartbeat(s);",
          "",
          "[Added Lines]",
          "216:     return_value = fixture.process_heartbeat(s, s->rlayer.rrec.data,",
          "217:         s->rlayer.rrec.length);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "230:     actual_payload_len = 0;",
          "231:     n2s(p, actual_payload_len);",
          "",
          "[Removed Lines]",
          "228:     p = &(s->s3->",
          "229:           wbuf.buf[fixture.return_payload_offset + s->s3->wbuf.offset]);",
          "",
          "[Added Lines]",
          "229:     p = &(s->rlayer.",
          "230:           wbuf.buf[fixture.return_payload_offset + s->rlayer.wbuf.offset]);",
          "",
          "---------------"
        ],
        "ssl/record/d1_pkt.c||ssl/record/d1_pkt.c": [
          "File: ssl/record/d1_pkt.c -> ssl/record/d1_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "585: #ifndef OPENSSL_NO_HEARTBEATS",
          "586:         else if (rr->type == TLS1_RT_HEARTBEAT) {",
          "589:                 return -1;",
          "590:             }",
          "593:             rr->length = 0;",
          "594:             s->rwstate = SSL_READING;",
          "",
          "[Removed Lines]",
          "588:             if(dtls1_process_heartbeat(s) < 0) {",
          "",
          "[Added Lines]",
          "588:             if(dtls1_process_heartbeat(s, SSL3_RECORD_get_data(&s->rlayer.rrec),",
          "589:                     SSL3_RECORD_get_length(&s->rlayer.rrec)) < 0) {",
          "",
          "---------------"
        ],
        "ssl/record/s3_pkt.c||ssl/record/s3_pkt.c": [
          "File: ssl/record/s3_pkt.c -> ssl/record/s3_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1054: #ifndef OPENSSL_NO_HEARTBEATS",
          "1055:         else if (rr->type == TLS1_RT_HEARTBEAT) {",
          "1058:                 return -1;",
          "1059:             }",
          "",
          "[Removed Lines]",
          "1057:             if(tls1_process_heartbeat(s) < 0) {",
          "",
          "[Added Lines]",
          "1057:             if(tls1_process_heartbeat(s, SSL3_RECORD_get_data(&s->rlayer.rrec),",
          "1058:                     SSL3_RECORD_get_length(&s->rlayer.rrec)) < 0) {",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1979: struct openssl_ssl_test_functions {",
          "1980:     int (*p_ssl_init_wbio_buffer) (SSL *s, int push);",
          "1981:     int (*p_ssl3_setup_buffers) (SSL *s);",
          "1984: };",
          "1986: # ifndef OPENSSL_UNIT_TEST",
          "",
          "[Removed Lines]",
          "1982:     int (*p_tls1_process_heartbeat) (SSL *s);",
          "1983:     int (*p_dtls1_process_heartbeat) (SSL *s);",
          "",
          "[Added Lines]",
          "1982:     int (*p_tls1_process_heartbeat) (SSL *s,",
          "1983:         unsigned char *p, unsigned int length);",
          "1984:     int (*p_dtls1_process_heartbeat) (SSL *s,",
          "1985:         unsigned char *p, unsigned int length);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2267: #   ifndef OPENSSL_NO_HEARTBEATS",
          "2268: __owur int tls1_heartbeat(SSL *s);",
          "2269: __owur int dtls1_heartbeat(SSL *s);",
          "2272: #   endif",
          "2274: __owur int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,",
          "",
          "[Removed Lines]",
          "2270: __owur int tls1_process_heartbeat(SSL *s);",
          "2271: __owur int dtls1_process_heartbeat(SSL *s);",
          "",
          "[Added Lines]",
          "2272: __owur int tls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length);",
          "2273: __owur int dtls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length);",
          "",
          "---------------"
        ],
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3592: }",
          "3594: # ifndef OPENSSL_NO_HEARTBEATS",
          "3596: {",
          "3598:     unsigned short hbtype;",
          "3599:     unsigned int payload;",
          "3606:     if (s->msg_callback)",
          "3607:         s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "",
          "[Removed Lines]",
          "3595: int tls1_process_heartbeat(SSL *s)",
          "3597:     unsigned char *p, *pl;",
          "3601:     unsigned int length;",
          "3603:     p = SSL3_RECORD_get_data(RECORD_LAYER_get_rrec(&s->rlayer));",
          "3604:     length = SSL3_RECORD_get_length(RECORD_LAYER_get_rrec(&s->rlayer));",
          "",
          "[Added Lines]",
          "3595: int tls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length)",
          "3597:     unsigned char *pl;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "258f8721a5d2c3ec5fd433e89112885139be1db3",
      "candidate_info": {
        "commit_hash": "258f8721a5d2c3ec5fd433e89112885139be1db3",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/258f8721a5d2c3ec5fd433e89112885139be1db3",
        "files": [
          "ssl/Makefile",
          "ssl/d1_both.c",
          "ssl/d1_pkt.c",
          "ssl/record/rec_layer.h",
          "ssl/record/ssl3_record.c",
          "ssl/record/ssl3_record.h",
          "ssl/s3_enc.c",
          "ssl/s3_lib.c",
          "ssl/s3_pkt.c",
          "ssl/ssl_locl.h",
          "ssl/t1_enc.c",
          "ssl/t1_lib.c"
        ],
        "message": "Encapsulate s->s3->rrec\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "ssl/d1_both.c||ssl/d1_both.c",
          "ssl/d1_pkt.c||ssl/d1_pkt.c",
          "ssl/record/rec_layer.h||ssl/record/rec_layer.h",
          "ssl/record/ssl3_record.c||ssl/record/ssl3_record.c",
          "ssl/record/ssl3_record.h||ssl/record/ssl3_record.h",
          "ssl/s3_enc.c||ssl/s3_enc.c",
          "ssl/s3_lib.c||ssl/s3_lib.c",
          "ssl/s3_pkt.c||ssl/s3_pkt.c",
          "ssl/ssl_locl.h||ssl/ssl_locl.h",
          "ssl/t1_enc.c||ssl/t1_enc.c",
          "ssl/t1_lib.c||ssl/t1_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/d1_both.c||ssl/d1_both.c",
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_both.c||ssl/d1_both.c": [
          "File: ssl/d1_both.c -> ssl/d1_both.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1349: #ifndef OPENSSL_NO_HEARTBEATS",
          "1350: int dtls1_process_heartbeat(SSL *s)",
          "1351: {",
          "1353:     unsigned short hbtype;",
          "1354:     unsigned int payload;",
          "1357:     if (s->msg_callback)",
          "1358:         s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "1368:     hbtype = *p++;",
          "1369:     n2s(p, payload);",
          "1372:     pl = p;",
          "",
          "[Removed Lines]",
          "1352:     unsigned char *p = &s->s3->rrec.data[0], *pl;",
          "1359:                         &s->s3->rrec.data[0], s->s3->rrec.length,",
          "1360:                         s, s->msg_callback_arg);",
          "1363:     if (1 + 2 + 16 > s->s3->rrec.length)",
          "1365:     if (s->s3->rrec.length > SSL3_RT_MAX_PLAIN_LENGTH)",
          "1370:     if (1 + 2 + payload + 16 > s->s3->rrec.length)",
          "",
          "[Added Lines]",
          "1352:     unsigned char *p, *pl;",
          "1356:     unsigned int length;",
          "1358:     p = SSL3_RECORD_get_data(RECORD_LAYER_get_rrec(&s->rlayer));",
          "1359:     length = SSL3_RECORD_get_length(RECORD_LAYER_get_rrec(&s->rlayer));",
          "1363:                         p, length, s, s->msg_callback_arg);",
          "1366:     if (1 + 2 + 16 > length)",
          "1368:     if (length > SSL3_RT_MAX_PLAIN_LENGTH)",
          "1373:     if (1 + 2 + payload + 16 > length)",
          "",
          "---------------"
        ],
        "ssl/d1_pkt.c||ssl/d1_pkt.c": [
          "File: ssl/d1_pkt.c -> ssl/d1_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "204:     s->packet_length = rdata->packet_length;",
          "205:     memcpy(RECORD_LAYER_get_rbuf(&s->rlayer), &(rdata->rbuf),",
          "206:         sizeof(SSL3_BUFFER));",
          "210:     memcpy(&(s->s3->read_sequence[2]), &(rdata->packet[5]), 6);",
          "",
          "[Removed Lines]",
          "207:     memcpy(&(s->s3->rrec), &(rdata->rrec), sizeof(SSL3_RECORD));",
          "",
          "[Added Lines]",
          "207:     memcpy(RECORD_LAYER_get_rrec(&s->rlayer), &(rdata->rrec),",
          "208:         sizeof(SSL3_RECORD));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "238:     rdata->packet_length = s->packet_length;",
          "239:     memcpy(&(rdata->rbuf), RECORD_LAYER_get_rbuf(&s->rlayer),",
          "240:         sizeof(SSL3_BUFFER));",
          "243:     item->data = rdata;",
          "",
          "[Removed Lines]",
          "241:     memcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));",
          "",
          "[Added Lines]",
          "242:     memcpy(&(rdata->rrec), RECORD_LAYER_get_rrec(&s->rlayer),",
          "243:         sizeof(SSL3_RECORD));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "255:     s->packet = NULL;",
          "256:     s->packet_length = 0;",
          "257:     memset(RECORD_LAYER_get_rbuf(&s->rlayer), 0, sizeof(SSL3_BUFFER));",
          "260:     if (!ssl3_setup_buffers(s)) {",
          "261:         SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);",
          "",
          "[Removed Lines]",
          "258:     memset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));",
          "",
          "[Added Lines]",
          "260:     memset(RECORD_LAYER_get_rrec(&s->rlayer), 0, sizeof(SSL3_RECORD));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "328:             if (!dtls1_process_record(s))",
          "329:                 return (0);",
          "330:             if (dtls1_buffer_record(s, &(s->d1->processed_rcds),",
          "332:                 return -1;",
          "333:         }",
          "334:     }",
          "",
          "[Removed Lines]",
          "331:                                     s->s3->rrec.seq_num) < 0)",
          "",
          "[Added Lines]",
          "333:                 SSL3_RECORD_get_seq_num(RECORD_LAYER_get_rrec(&s->rlayer))) < 0)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "352:     unsigned int mac_size;",
          "353:     unsigned char md[EVP_MAX_MD_SIZE];",
          "356:     sess = s->session;",
          "",
          "[Removed Lines]",
          "355:     rr = &(s->s3->rrec);",
          "",
          "[Added Lines]",
          "357:     rr = RECORD_LAYER_get_rrec(&s->rlayer);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "527:     DTLS1_BITMAP *bitmap;",
          "528:     unsigned int is_next_epoch;",
          "",
          "[Removed Lines]",
          "530:     rr = &(s->s3->rrec);",
          "",
          "[Added Lines]",
          "532:     rr = RECORD_LAYER_get_rrec(&s->rlayer);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "783:     rr = &(s->s3->rrec);",
          "",
          "[Added Lines]",
          "785:     rr = RECORD_LAYER_get_rrec(&s->rlayer);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1630:     cmp = satsub64be(seq, bitmap->max_seq_num);",
          "1631:     if (cmp > 0) {",
          "1634:     }",
          "1635:     shift = -cmp;",
          "",
          "[Removed Lines]",
          "1632:         memcpy(s->s3->rrec.seq_num, seq, 8);",
          "",
          "[Added Lines]",
          "1634:         SSL3_RECORD_set_seq_num(RECORD_LAYER_get_rrec(&s->rlayer), seq);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1638:     else if (bitmap->map & (1UL << shift))",
          "1642:     return 1;",
          "1643: }",
          "",
          "[Removed Lines]",
          "1641:     memcpy(s->s3->rrec.seq_num, seq, 8);",
          "",
          "[Added Lines]",
          "1643:     SSL3_RECORD_set_seq_num(RECORD_LAYER_get_rrec(&s->rlayer), seq);",
          "",
          "---------------"
        ],
        "ssl/record/rec_layer.h||ssl/record/rec_layer.h": [
          "File: ssl/record/rec_layer.h -> ssl/record/rec_layer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "130: #define RECORD_LAYER_get_read_ahead(rl)         ((rl)->read_ahead)",
          "131: #define RECORD_LAYER_get_rbuf(rl)               (&(rl)->rbuf)",
          "132: #define RECORD_LAYER_get_wbuf(rl)               (&(rl)->wbuf)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: #define RECORD_LAYER_get_rrec(rl)               (&(rl)->s->s3->rrec)",
          "",
          "---------------"
        ],
        "ssl/record/ssl3_record.c||ssl/record/ssl3_record.c": [
          "File: ssl/record/ssl3_record.c -> ssl/record/ssl3_record.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112: #include \"../ssl_locl.h\"",
          "114: void SSL3_RECORD_clear(SSL3_RECORD *r)",
          "115: {",
          "116:     memset(r->seq_num, 0, sizeof(r->seq_num));",
          "117: }",
          "119: void SSL3_RECORD_release(SSL3_RECORD *r)",
          "120: {",
          "121:     if (r->comp != NULL)",
          "122:         OPENSSL_free(r->comp);",
          "123:     r->comp = NULL;",
          "124: }",
          "126: int SSL3_RECORD_setup(SSL3_RECORD *r, size_t len)",
          "127: {",
          "128:     if (r->comp == NULL)",
          "129:         r->comp = (unsigned char *) OPENSSL_malloc(len);",
          "130:     if (r->comp == NULL)",
          "131:         return 0;",
          "132:     return 1;",
          "133: }",
          "135: void SSL3_RECORD_set_seq_num(SSL3_RECORD *r, const unsigned char *seq_num)",
          "136: {",
          "137:     memcpy(r->seq_num, seq_num, 8);",
          "138: }",
          "",
          "---------------"
        ],
        "ssl/record/ssl3_record.h||ssl/record/ssl3_record.h": [
          "File: ssl/record/ssl3_record.h -> ssl/record/ssl3_record.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112: typedef struct ssl3_record_st {",
          "152: } SSL3_RECORD;",
          "154: #define SSL3_RECORD_get_type(r)                 ((r)->type)",
          "155: #define SSL3_RECORD_get_length(r)               ((r)->length)",
          "156: #define SSL3_RECORD_get_data(r)                 ((r)->data)",
          "157: #define SSL3_RECORD_get_seq_num(r)              ((r)->seq_num)",
          "159: void SSL3_RECORD_clear(SSL3_RECORD *r);",
          "160: void SSL3_RECORD_release(SSL3_RECORD *r);",
          "161: int SSL3_RECORD_setup(SSL3_RECORD *r, size_t len);",
          "162: void SSL3_RECORD_set_seq_num(SSL3_RECORD *r, const unsigned char *seq_num);",
          "",
          "---------------"
        ],
        "ssl/s3_enc.c||ssl/s3_enc.c": [
          "File: ssl/s3_enc.c -> ssl/s3_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "270:                        SSL_R_COMPRESSION_LIBRARY_ERROR);",
          "271:                 goto err2;",
          "272:             }",
          "277:                 goto err;",
          "278:         }",
          "279: #endif",
          "",
          "[Removed Lines]",
          "273:             if (s->s3->rrec.comp == NULL)",
          "274:                 s->s3->rrec.comp = (unsigned char *)",
          "275:                     OPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);",
          "276:             if (s->s3->rrec.comp == NULL)",
          "",
          "[Added Lines]",
          "273:             if(!SSL3_RECORD_setup(RECORD_LAYER_get_rrec(&s->rlayer),",
          "274:                 SSL3_RT_MAX_PLAIN_LENGTH))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "509:             enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);",
          "510:     } else {",
          "511:         ds = s->enc_read_ctx;",
          "513:         if (s->enc_read_ctx == NULL)",
          "514:             enc = NULL;",
          "515:         else",
          "",
          "[Removed Lines]",
          "512:         rec = &(s->s3->rrec);",
          "",
          "[Added Lines]",
          "510:         rec = RECORD_LAYER_get_rrec(&s->rlayer);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "732:         seq = &(ssl->s3->write_sequence[0]);",
          "733:         hash = ssl->write_hash;",
          "734:     } else {",
          "736:         mac_sec = &(ssl->s3->read_mac_secret[0]);",
          "737:         seq = &(ssl->s3->read_sequence[0]);",
          "738:         hash = ssl->read_hash;",
          "",
          "[Removed Lines]",
          "735:         rec = &(ssl->s3->rrec);",
          "",
          "[Added Lines]",
          "733:         rec = RECORD_LAYER_get_rrec(&ssl->rlayer);",
          "",
          "---------------"
        ],
        "ssl/s3_lib.c||ssl/s3_lib.c": [
          "File: ssl/s3_lib.c -> ssl/s3_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3083:     if (s->rstate == SSL_ST_READ_BODY)",
          "3084:         return 0;",
          "3088: }",
          "3090: int ssl3_set_handshake_header(SSL *s, int htype, unsigned long len)",
          "",
          "[Removed Lines]",
          "3086:     return (s->s3->rrec.type ==",
          "3087:             SSL3_RT_APPLICATION_DATA) ? s->s3->rrec.length : 0;",
          "",
          "[Added Lines]",
          "3086:     return (SSL3_RECORD_get_type(RECORD_LAYER_get_rrec(&s->rlayer))",
          "3087:            == SSL3_RT_APPLICATION_DATA)",
          "3088:            ? SSL3_RECORD_get_length(RECORD_LAYER_get_rrec(&s->rlayer)) : 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3110:     if ((s3 = OPENSSL_malloc(sizeof *s3)) == NULL)",
          "3111:         goto err;",
          "3112:     memset(s3, 0, sizeof *s3);",
          "3116:     s->s3 = s3;",
          "3118: #ifndef OPENSSL_NO_SRP",
          "3119:     if(!SSL_SRP_CTX_init(s))",
          "3120:           goto err;",
          "",
          "[Removed Lines]",
          "3113:     memset(s3->rrec.seq_num, 0, sizeof(s3->rrec.seq_num));",
          "3114:     memset(s3->wrec.seq_num, 0, sizeof(s3->wrec.seq_num));",
          "",
          "[Added Lines]",
          "3115:     SSL3_RECORD_clear(RECORD_LAYER_get_rrec(&s->rlayer));",
          "3116:     memset(s3->wrec.seq_num, 0, sizeof(s3->wrec.seq_num));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3131:         return;",
          "3133:     ssl3_cleanup_key_block(s);",
          "3136: #ifndef OPENSSL_NO_DH",
          "3137:     DH_free(s->s3->tmp.dh);",
          "3138: #endif",
          "",
          "[Removed Lines]",
          "3134:     if (s->s3->rrec.comp != NULL)",
          "3135:         OPENSSL_free(s->s3->rrec.comp);",
          "",
          "[Added Lines]",
          "3134:     SSL3_RECORD_release(RECORD_LAYER_get_rrec(&s->rlayer));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3166:     if (s->s3->tmp.ca_names != NULL)",
          "3167:         sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);",
          "3173: #ifndef OPENSSL_NO_DH",
          "3174:     DH_free(s->s3->tmp.dh);",
          "3175:     s->s3->tmp.dh = NULL;",
          "",
          "[Removed Lines]",
          "3169:     if (s->s3->rrec.comp != NULL) {",
          "3170:         OPENSSL_free(s->s3->rrec.comp);",
          "3171:         s->s3->rrec.comp = NULL;",
          "3172:     }",
          "",
          "[Added Lines]",
          "3168:     SSL3_RECORD_release(RECORD_LAYER_get_rrec(&s->rlayer));",
          "",
          "---------------"
        ],
        "ssl/s3_pkt.c||ssl/s3_pkt.c": [
          "File: ssl/s3_pkt.c -> ssl/s3_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "316:     size_t extra;",
          "317:     unsigned empty_record_count = 0;",
          "320:     sess = s->session;",
          "322:     if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)",
          "",
          "[Removed Lines]",
          "319:     rr = &(s->s3->rrec);",
          "",
          "[Added Lines]",
          "319:     rr = RECORD_LAYER_get_rrec(&s->rlayer);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "600:     int i;",
          "601:     SSL3_RECORD *rr;",
          "604:     i = COMP_expand_block(ssl->expand, rr->comp,",
          "605:                           SSL3_RT_MAX_PLAIN_LENGTH, rr->data,",
          "606:                           (int)rr->length);",
          "",
          "[Removed Lines]",
          "603:     rr = &(ssl->s3->rrec);",
          "",
          "[Added Lines]",
          "603:     rr = RECORD_LAYER_get_rrec(&ssl->rlayer);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1241:     if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY)) {",
          "",
          "[Removed Lines]",
          "1238:     rr = &(s->s3->rrec);",
          "",
          "[Added Lines]",
          "1238:     rr = RECORD_LAYER_get_rrec(&s->rlayer);",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "166: # include <openssl/symhacks.h>",
          "168: #include \"record/ssl3_buffer.h\"",
          "169: #include \"record/rec_layer.h\"",
          "171: # ifdef OPENSSL_BUILD_SHLIBSSL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "169: #include \"record/ssl3_record.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1223:     RECORD_LAYER rlayer;",
          "1224: };",
          "1268: typedef struct ssl3_state_st {",
          "1269:     long flags;",
          "",
          "[Removed Lines]",
          "1226: typedef struct ssl3_record_st {",
          "1266: } SSL3_RECORD;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ssl/t1_enc.c||ssl/t1_enc.c": [
          "File: ssl/t1_enc.c -> ssl/t1_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "396:                        SSL_R_COMPRESSION_LIBRARY_ERROR);",
          "397:                 goto err2;",
          "398:             }",
          "403:                 goto err;",
          "404:         }",
          "405: #endif",
          "",
          "[Removed Lines]",
          "399:             if (s->s3->rrec.comp == NULL)",
          "400:                 s->s3->rrec.comp = (unsigned char *)",
          "401:                     OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);",
          "402:             if (s->s3->rrec.comp == NULL)",
          "",
          "[Added Lines]",
          "399:             if (SSL3_RECORD_setup(RECORD_LAYER_get_rrec(&s->rlayer),",
          "400:                 SSL3_RT_MAX_ENCRYPTED_LENGTH))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "782:             OPENSSL_assert(n >= 0);",
          "783:         }",
          "784:         ds = s->enc_read_ctx;",
          "786:         if (s->enc_read_ctx == NULL)",
          "787:             enc = NULL;",
          "788:         else",
          "",
          "[Removed Lines]",
          "785:         rec = &(s->s3->rrec);",
          "",
          "[Added Lines]",
          "783:         rec = RECORD_LAYER_get_rrec(&s->rlayer);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "977:         seq = &(ssl->s3->write_sequence[0]);",
          "978:         hash = ssl->write_hash;",
          "979:     } else {",
          "981:         seq = &(ssl->s3->read_sequence[0]);",
          "982:         hash = ssl->read_hash;",
          "983:     }",
          "",
          "[Removed Lines]",
          "980:         rec = &(ssl->s3->rrec);",
          "",
          "[Added Lines]",
          "978:         rec = RECORD_LAYER_get_rrec(&ssl->rlayer);",
          "",
          "---------------"
        ],
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3594: # ifndef OPENSSL_NO_HEARTBEATS",
          "3595: int tls1_process_heartbeat(SSL *s)",
          "3596: {",
          "3598:     unsigned short hbtype;",
          "3599:     unsigned int payload;",
          "3602:     if (s->msg_callback)",
          "3603:         s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,",
          "3605:                         s, s->msg_callback_arg);",
          "3610:     hbtype = *p++;",
          "3611:     n2s(p, payload);",
          "3614:     pl = p;",
          "",
          "[Removed Lines]",
          "3597:     unsigned char *p = &s->s3->rrec.data[0], *pl;",
          "3604:                         &s->s3->rrec.data[0], s->s3->rrec.length,",
          "3608:     if (1 + 2 + 16 > s->s3->rrec.length)",
          "3612:     if (1 + 2 + payload + 16 > s->s3->rrec.length)",
          "",
          "[Added Lines]",
          "3597:     unsigned char *p, *pl;",
          "3601:     unsigned int length;",
          "3603:     p = SSL3_RECORD_get_data(RECORD_LAYER_get_rrec(&s->rlayer));",
          "3604:     length = SSL3_RECORD_get_length(RECORD_LAYER_get_rrec(&s->rlayer));",
          "3608:                         p, length,",
          "3612:     if (1 + 2 + 16 > length)",
          "3616:     if (1 + 2 + payload + 16 > length)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19924",
  "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
  "repo": "sqlite/sqlite",
  "patch_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
  "patch_info": {
    "commit_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/vdbeaux.c",
      "src/window.c"
    ],
    "message": "When an error occurs while rewriting the parser tree for window functions in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/vdbeaux.c||src/vdbeaux.c",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "376:   int addr;",
      "377:   CollSeq *p4;",
      "379:   if( isCommuted ){",
      "380:     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);",
      "381:   }else{",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:   if( pParse->nErr ) return 0;",
      "",
      "---------------"
    ],
    "src/vdbeaux.c||src/vdbeaux.c": [
      "File: src/vdbeaux.c -> src/vdbeaux.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1304: static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){",
      "1305:   assert( p->nOp>0 || p->aOp==0 );",
      "1307:   if( p->nOp ){",
      "1308:     assert( p->aOp );",
      "1309:     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
      "",
      "[Removed Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );",
      "",
      "[Added Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
      "1307:           || p->pParse->nErr>0 );",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "935:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
      "936:     if( pTab==0 ){",
      "938:     }",
      "940:     p->pSrc = 0;",
      "",
      "[Removed Lines]",
      "937:       return SQLITE_NOMEM;",
      "",
      "[Added Lines]",
      "937:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1039:     sqlite3DbFree(db, pTab);",
      "1040:   }",
      "1042:   return rc;",
      "1043: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1042:   if( rc && pParse->nErr==0 ){",
      "1043:     assert( pParse->db->mallocFailed );",
      "1044:     return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
      "1045:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b9bcf7ca600ab8a94018adc2eac4115441a09d89",
      "candidate_info": {
        "commit_hash": "b9bcf7ca600ab8a94018adc2eac4115441a09d89",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b9bcf7ca600ab8a94018adc2eac4115441a09d89",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c",
          "src/analyze.c",
          "src/build.c",
          "src/expr.c",
          "src/insert.c",
          "src/sqliteInt.h",
          "src/upsert.c",
          "src/vdbeapi.c",
          "src/where.c",
          "src/wherecode.c"
        ],
        "message": "Refactor names of column index transformation functions, for clarity. Get generated columns working with ALTER TABLE RENAME COLUMN.\n\nFossilOrigin-Name: 27ab41c9102e7801ff829488fc123a8040da008bef373d6704efbe2f93e1da90",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c",
          "src/analyze.c||src/analyze.c",
          "src/build.c||src/build.c",
          "src/expr.c||src/expr.c",
          "src/insert.c||src/insert.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/upsert.c||src/upsert.c",
          "src/vdbeapi.c||src/vdbeapi.c",
          "src/where.c||src/where.c",
          "src/wherecode.c||src/wherecode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 86074da0fd2949e231898ef0bc672d90fd89cefa49fb0eb50ff398fbdd91d1ad",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1334:           sqlite3WalkExprList(&sWalker, pIdx->aColExpr);",
          "1335:         }",
          "1336:       }",
          "1338:       for(pFKey=sParse.pNewTable->pFKey; pFKey; pFKey=pFKey->pNextFrom){",
          "1339:         for(i=0; i<pFKey->nCol; i++){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1337: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "1338:       for(i=0; i<sParse.pNewTable->nCol; i++){",
          "1339:         sqlite3WalkExpr(&sWalker, sParse.pNewTable->aCol[i].pDflt);",
          "1340:       }",
          "1341: #endif",
          "",
          "---------------"
        ],
        "src/analyze.c||src/analyze.c": [
          "File: src/analyze.c -> src/analyze.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1182:       int j, k, regKey;",
          "1183:       regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);",
          "1184:       for(j=0; j<pPk->nKeyCol; j++){",
          "1186:         assert( k>=0 && k<pIdx->nColumn );",
          "1187:         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);",
          "1188:         VdbeComment((v, \"%s\", pTab->aCol[pPk->aiColumn[j]].zName));",
          "",
          "[Removed Lines]",
          "1185:         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "[Added Lines]",
          "1185:         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "877: }",
          "884:   int i;",
          "885:   for(i=0; i<pIdx->nColumn; i++){",
          "886:     if( iCol==pIdx->aiColumn[i] ) return i;",
          "",
          "[Removed Lines]",
          "883: i16 sqlite3ColumnOfIndex(Index *pIdx, i16 iCol){",
          "",
          "[Added Lines]",
          "885: i16 sqlite3TableColumnToIndex(Index *pIdx, i16 iCol){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "889: }",
          "891: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "906:   if( pTab->tabFlags & TF_HasVirtual ){",
          "907:     int i;",
          "908:     for(i=0; i<=iCol; i++){",
          "",
          "[Removed Lines]",
          "905: i16 sqlite3ColumnOfStorage(Table *pTab, i16 iCol){",
          "",
          "[Added Lines]",
          "907: i16 sqlite3StorageColumnToTable(Table *pTab, i16 iCol){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "928:   int i;",
          "929:   i16 n;",
          "930:   assert( iCol<pTab->nCol );",
          "",
          "[Removed Lines]",
          "927: i16 sqlite3ColumnOfTable(Table *pTab, i16 iCol){",
          "",
          "[Added Lines]",
          "929: i16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1577:   u8 eType = COLFLAG_VIRTUAL;",
          "1578:   Table *pTab = pParse->pNewTable;",
          "1579:   Column *pCol;",
          "1583:   if( pTab==0 ) goto generated_done;",
          "1584:   pCol = &(pTab->aCol[pTab->nCol-1]);",
          "1585:   if( pCol->pDflt ) goto generated_error;",
          "1586:   if( pType ){",
          "1587:     if( pType->n==7 && sqlite3StrNICmp(\"virtual\",pType->z,7)==0 ){",
          "",
          "[Removed Lines]",
          "1580:   if( IN_RENAME_OBJECT ){",
          "1581:     sqlite3RenameExprUnmap(pParse, pExpr);",
          "1582:   }",
          "",
          "[Added Lines]",
          "1584:   if( IN_DECLARE_VTAB ){",
          "1585:     sqlite3ErrorMsg(pParse, \"virtual tables cannot use computed columns\");",
          "1586:     goto generated_done;",
          "1587:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1597:   assert( TF_HasVirtual==COLFLAG_VIRTUAL );",
          "1598:   assert( TF_HasStored==COLFLAG_STORED );",
          "1599:   pTab->tabFlags |= eType;",
          "1601:   goto generated_done;",
          "1603: generated_error:",
          "",
          "[Removed Lines]",
          "1600:   pCol->pDflt = sqlite3ExprDup(pParse->db, pExpr, 0);",
          "",
          "[Added Lines]",
          "1603:   pCol->pDflt = pExpr;",
          "1604:   pExpr = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3653:   assert( HasRowid(pTab)",
          "3655:   recomputeColumnsNotIndexed(pIndex);",
          "3656:   if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){",
          "3657:     pIndex->isCovering = 1;",
          "3658:     for(j=0; j<pTab->nCol; j++){",
          "3659:       if( j==pTab->iPKey ) continue;",
          "3661:       pIndex->isCovering = 0;",
          "3662:       break;",
          "3663:     }",
          "",
          "[Removed Lines]",
          "3654:       || pTab->iPKey<0 || sqlite3ColumnOfIndex(pIndex, pTab->iPKey)>=0 );",
          "3660:       if( sqlite3ColumnOfIndex(pIndex,j)>=0 ) continue;",
          "",
          "[Added Lines]",
          "3658:       || pTab->iPKey<0 || sqlite3TableColumnToIndex(pIndex, pTab->iPKey)>=0 );",
          "3664:       if( sqlite3TableColumnToIndex(pIndex,j)>=0 ) continue;",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3410:       return;",
          "3411: #endif",
          "3412:     }else if( !HasRowid(pTab) ){",
          "3414:       op = OP_Column;",
          "3415:     }else{",
          "3417:       op = OP_Column;",
          "3418:     }",
          "3419:     sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);",
          "",
          "[Removed Lines]",
          "3413:       x = sqlite3ColumnOfIndex(sqlite3PrimaryKeyIndex(pTab), iCol);",
          "3416:       x = sqlite3ColumnOfTable(pTab,iCol);",
          "",
          "[Added Lines]",
          "3413:       x = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), iCol);",
          "3416:       x = sqlite3TableColumnToStorage(pTab,iCol);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3591:             return -1-pParse->iSelfTab;",
          "3592:           }",
          "3593:           pCol = pTab->aCol + pExpr->iColumn;",
          "3595: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "3596:           if( pCol->colFlags & COLFLAG_GENERATED ){",
          "3597:             if( pCol->colFlags & COLFLAG_BUSY ){",
          "",
          "[Removed Lines]",
          "3594:           iSrc = sqlite3ColumnOfTable(pTab, pExpr->iColumn) - pParse->iSelfTab;",
          "",
          "[Added Lines]",
          "3594:           iSrc = sqlite3TableColumnToStorage(pTab, pExpr->iColumn)",
          "3595:                       - pParse->iSelfTab;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5320: static int exprIdxCover(Walker *pWalker, Expr *pExpr){",
          "5321:   if( pExpr->op==TK_COLUMN",
          "5322:    && pExpr->iTable==pWalker->u.pIdxCover->iCur",
          "5324:   ){",
          "5325:     pWalker->eCode = 1;",
          "5326:     return WRC_Abort;",
          "",
          "[Removed Lines]",
          "5323:    && sqlite3ColumnOfIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0",
          "",
          "[Added Lines]",
          "5324:    && sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1055:       int k;",
          "1056:       u32 colFlags;",
          "1057:       assert( i>=nHidden );",
          "1059:       if( i==pTab->iPKey ){",
          "",
          "[Removed Lines]",
          "1058:       assert( iRegStore==sqlite3ColumnOfTable(pTab,i)+regRowid+1 );",
          "",
          "[Added Lines]",
          "1058:       assert( iRegStore==sqlite3TableColumnToStorage(pTab,i)+regRowid+1 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1464:       pParse->iSelfTab = 0;",
          "1465:       if( onError==OE_Replace ) onError = OE_Abort;",
          "1466:     }else{",
          "1468:     }",
          "1469:     switch( onError ){",
          "1470:       case OE_Replace: {",
          "",
          "[Removed Lines]",
          "1467:       iReg = sqlite3ColumnOfTable(pTab, i) + regNewData + 1;",
          "",
          "[Added Lines]",
          "1467:       iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1782:         VdbeComment((v, \"%s column %d\", pIdx->zName, i));",
          "1783: #endif",
          "1784:       }else{",
          "1786:         sqlite3VdbeAddOp2(v, OP_SCopy, x, regIdx+i);",
          "1787:         VdbeComment((v, \"%s\", pTab->aCol[iField].zName));",
          "1788:       }",
          "",
          "[Removed Lines]",
          "1785:         x = sqlite3ColumnOfTable(pTab, iField) + regNewData + 1;",
          "",
          "[Added Lines]",
          "1785:         x = sqlite3TableColumnToStorage(pTab, iField) + regNewData + 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1873:         if( pIdx!=pPk ){",
          "1874:           for(i=0; i<pPk->nKeyCol; i++){",
          "1875:             assert( pPk->aiColumn[i]>=0 );",
          "1877:             sqlite3VdbeAddOp3(v, OP_Column, iThisCur, x, regR+i);",
          "1878:             VdbeComment((v, \"%s.%s\", pTab->zName,",
          "1879:                          pTab->aCol[pPk->aiColumn[i]].zName));",
          "",
          "[Removed Lines]",
          "1876:             x = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "[Added Lines]",
          "1876:             x = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3952: Table *sqlite3ResultSetOfSelect(Parse*,Select*,char);",
          "3953: void sqlite3OpenMasterTable(Parse *, int);",
          "3954: Index *sqlite3PrimaryKeyIndex(Table*);",
          "3956: #ifdef SQLITE_OMIT_GENERATED_COLUMNS",
          "3959: #else",
          "3962: #endif",
          "3963: void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);",
          "3964: #if SQLITE_ENABLE_HIDDEN_COLUMNS",
          "",
          "[Removed Lines]",
          "3955: i16 sqlite3ColumnOfIndex(Index*, i16);",
          "3960:   i16 sqlite3ColumnOfTable(Table*, i16);",
          "3961:   i16 sqlite3ColumnOfStorage(Table*, i16);",
          "",
          "[Added Lines]",
          "3968: i16 sqlite3TableColumnToIndex(Index*, i16);",
          "3973:   i16 sqlite3TableColumnToStorage(Table*, i16);",
          "3974:   i16 sqlite3StorageColumnToTable(Table*, i16);",
          "",
          "---------------"
        ],
        "src/upsert.c||src/upsert.c": [
          "File: src/upsert.c -> src/upsert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "226:       for(i=0; i<nPk; i++){",
          "227:         int k;",
          "228:         assert( pPk->aiColumn[i]>=0 );",
          "230:         sqlite3VdbeAddOp3(v, OP_Column, iCur, k, iPk+i);",
          "231:         VdbeComment((v, \"%s.%s\", pIdx->zName,",
          "232:                     pTab->aCol[pPk->aiColumn[i]].zName));",
          "",
          "[Removed Lines]",
          "229:         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "[Added Lines]",
          "229:         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);",
          "",
          "---------------"
        ],
        "src/vdbeapi.c||src/vdbeapi.c": [
          "File: src/vdbeapi.c -> src/vdbeapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1831:     goto preupdate_old_out;",
          "1832:   }",
          "1833:   if( p->pPk ){",
          "1835:   }",
          "1836:   if( iIdx>=p->pCsr->nField || iIdx<0 ){",
          "1837:     rc = SQLITE_RANGE;",
          "",
          "[Removed Lines]",
          "1834:     iIdx = sqlite3ColumnOfIndex(p->pPk, iIdx);",
          "",
          "[Added Lines]",
          "1834:     iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1921:     goto preupdate_new_out;",
          "1922:   }",
          "1923:   if( p->pPk && p->op!=SQLITE_UPDATE ){",
          "1925:   }",
          "1926:   if( iIdx>=p->pCsr->nField || iIdx<0 ){",
          "1927:     rc = SQLITE_RANGE;",
          "",
          "[Removed Lines]",
          "1924:     iIdx = sqlite3ColumnOfIndex(p->pPk, iIdx);",
          "",
          "[Added Lines]",
          "1924:     iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5379:             x = pPk->aiColumn[x];",
          "5380:             assert( x>=0 );",
          "5381:           }else{",
          "5383:           }",
          "5385:           if( x>=0 ){",
          "5386:             pOp->p2 = x;",
          "5387:             pOp->p1 = pLevel->iIdxCur;",
          "",
          "[Removed Lines]",
          "5382:             x = sqlite3ColumnOfStorage(pTab,x);",
          "5384:           x = sqlite3ColumnOfIndex(pIdx, x);",
          "",
          "[Added Lines]",
          "5382:             x = sqlite3StorageColumnToTable(pTab,x);",
          "5384:           x = sqlite3TableColumnToIndex(pIdx, x);",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "823:   assert( pHint->pIdx!=0 );",
          "824:   if( pExpr->op==TK_COLUMN",
          "825:    && pExpr->iTable==pHint->iTabCur",
          "827:   ){",
          "828:     pWalker->eCode = 1;",
          "829:   }",
          "",
          "[Removed Lines]",
          "826:    && sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn)<0",
          "",
          "[Added Lines]",
          "826:    && sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn)<0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "891:       pExpr->iTable = reg;",
          "892:     }else if( pHint->pIdx!=0 ){",
          "893:       pExpr->iTable = pHint->iIdxCur;",
          "895:       assert( pExpr->iColumn>=0 );",
          "896:     }",
          "897:   }else if( pExpr->op==TK_AGG_FUNCTION ){",
          "",
          "[Removed Lines]",
          "894:       pExpr->iColumn = sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn);",
          "",
          "[Added Lines]",
          "894:       pExpr->iColumn = sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1826:       Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);",
          "1827:       iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);",
          "1828:       for(j=0; j<pPk->nKeyCol; j++){",
          "1830:         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, iRowidReg+j);",
          "1831:       }",
          "1832:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iCur, addrCont,",
          "",
          "[Removed Lines]",
          "1829:         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "[Added Lines]",
          "1829:         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd717a4d2e5797027b8203a6f68af24be78e4f93",
      "candidate_info": {
        "commit_hash": "bd717a4d2e5797027b8203a6f68af24be78e4f93",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/bd717a4d2e5797027b8203a6f68af24be78e4f93",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "test/nulls1.test"
        ],
        "message": "Improve vdbe branch coverage of NULLS LAST code.\n\nFossilOrigin-Name: e8e9f77d52974f6ba0a536d05837b280a996745deb3a2169bb29379f10e49df4",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "test/nulls1.test||test/nulls1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 96ff2ba9c4bb71d5f7c6f359986a76a5364b7ac3e1a612441543a9eabecf31df",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5216:       VdbeCoverageIf(v, pLevel->op==OP_VNext);",
          "5217:       if( pLevel->regBignull ){",
          "5218:         sqlite3VdbeResolveLabel(v, pLevel->addrBignull);",
          "5220:         VdbeCoverage(v);",
          "5221:       }",
          "5222: #ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT",
          "",
          "[Removed Lines]",
          "5219:         sqlite3VdbeAddOp2(v, OP_IfNotZero, pLevel->regBignull, pLevel->p2-1);",
          "",
          "[Added Lines]",
          "5219:         sqlite3VdbeAddOp2(v, OP_DecrJumpZero, pLevel->regBignull, pLevel->p2-1);",
          "",
          "---------------"
        ],
        "test/nulls1.test||test/nulls1.test": [
          "File: test/nulls1.test -> test/nulls1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "236:   `--SEARCH TABLE t5 USING COVERING INDEX t5ab (a=?)",
          "237: }",
          "240: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "239: #-------------------------------------------------------------------------",
          "240: do_execsql_test 7.0 {",
          "241:   CREATE TABLE t71(a, b, c);",
          "242:   CREATE INDEX t71abc ON t71(a, b, c);",
          "244:   SELECT * FROM t71 WHERE a=1 AND b=2 ORDER BY c NULLS LAST;",
          "245:   SELECT * FROM t71 WHERE a=1 AND b=2 ORDER BY c DESC NULLS FIRST;",
          "247:   SELECT * FROM t71 ORDER BY a NULLS LAST;",
          "248:   SELECT * FROM t71 ORDER BY a DESC NULLS FIRST;",
          "249: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "23d3f5d661ecdcef03843d6a27667f2adc3c6661",
      "candidate_info": {
        "commit_hash": "23d3f5d661ecdcef03843d6a27667f2adc3c6661",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/23d3f5d661ecdcef03843d6a27667f2adc3c6661",
        "files": [
          "ext/fts3/fts3_write.c",
          "manifest",
          "manifest.uuid",
          "test/fts4merge5.test",
          "test/permutations.test"
        ],
        "message": "Fix a long-standing problem in fts4 incrmental merge.\n\nFossilOrigin-Name: 67da31e24ebb49c4cac81c9e7cfca37ca422555fd0fdb01d8f180890783c84ff",
        "before_after_code_files": [
          "ext/fts3/fts3_write.c||ext/fts3/fts3_write.c",
          "manifest.uuid||manifest.uuid",
          "test/fts4merge5.test||test/fts4merge5.test",
          "test/permutations.test||test/permutations.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts3/fts3_write.c||ext/fts3/fts3_write.c": [
          "File: ext/fts3/fts3_write.c -> ext/fts3/fts3_write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4296:         NodeReader reader;",
          "4297:         pNode = &pWriter->aNodeWriter[i];",
          "4301:           while( reader.aNode && rc==SQLITE_OK ) rc = nodeReaderNext(&reader);",
          "4302:           blobGrowBuffer(&pNode->key, reader.term.n, &rc);",
          "4303:           if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "4299:         rc = nodeReaderInit(&reader, pNode->block.a, pNode->block.n);",
          "4300:         if( reader.aNode ){",
          "",
          "[Added Lines]",
          "4299:         if( pNode->block.a){",
          "4300:           rc = nodeReaderInit(&reader, pNode->block.a, pNode->block.n);",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9f4035f91a9f914797c67afbf19139b2cd25aea48595f7254fe5d18cd693d972",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/fts4merge5.test||test/fts4merge5.test": [
          "File: test/fts4merge5.test -> test/fts4merge5.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 October 02",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #*************************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this script is testing the FTS4 module.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix fts4merge5",
          "19: # If SQLITE_ENABLE_FTS3 is defined, omit this file.",
          "20: ifcapable !fts3 {",
          "21:   finish_test",
          "22:   return",
          "23: }",
          "25: source $testdir/genesis.tcl",
          "27: do_execsql_test 1.1 {",
          "28:   CREATE TABLE t1(docid, words);",
          "29: }",
          "30: fts_kjv_genesis",
          "32: do_execsql_test 1.2 {",
          "33:   CREATE VIRTUAL TABLE x1 USING fts3;",
          "34:   INSERT INTO x1(x1) VALUES('nodesize=64');",
          "35:   INSERT INTO x1(x1) VALUES('maxpending=64');",
          "36: }",
          "38: do_execsql_test 1.3 {",
          "39:   INSERT INTO x1(docid, content) SELECT * FROM t1;",
          "40: }",
          "42: for {set tn 1} {1} {incr tn} {",
          "43:   set tc1 [db total_changes]",
          "44:   do_execsql_test 1.4.$tn.1 {",
          "45:     INSERT INTO x1(x1) VALUES('merge=1,2');",
          "46:   }",
          "47:   set tc2 [db total_changes]",
          "49:   if {($tc2 - $tc1)<2} break",
          "51:   do_execsql_test 1.4.$tn.1 {",
          "52:     INSERT INTO x1(x1) VALUES('integrity-check');",
          "53:   }",
          "54: }",
          "58: finish_test",
          "",
          "---------------"
        ],
        "test/permutations.test||test/permutations.test": [
          "File: test/permutations.test -> test/permutations.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:   walcrash2.test e_fkey.test backup.test",
          "128:   fts4merge.test fts4merge2.test fts4merge4.test fts4check.test",
          "129:   fts3cov.test fts3snippet.test fts3corrupt2.test fts3an.test",
          "130:   fts3defer.test fts4langid.test fts3sort.test fts5unicode.test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129:   fts4merge5.test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5f913ecb62200fc735c9222e6a24c0453ecaa8a1",
      "candidate_info": {
        "commit_hash": "5f913ecb62200fc735c9222e6a24c0453ecaa8a1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/5f913ecb62200fc735c9222e6a24c0453ecaa8a1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/sqliteInt.h",
          "src/where.c",
          "test/fts3fuzz001.test"
        ],
        "message": "Use the new SQLITE_IDXTYPE_IPK values (3) on Index.idxType to indicate the fake INTEGER PRIMARY KEY index used during query planning.\n\nFossilOrigin-Name: e22d2f905fe840bea51b536ebedc9b637190ea0a37f16559668d99a61e971411",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/where.c||src/where.c",
          "test/fts3fuzz001.test||test/fts3fuzz001.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 666cf8f6b39ae1f72e82b45e9cacba23caf61370ca0c695b3b14452accbb1a0d",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2210:   rc = whereLoopXfer(db, p, pTemplate);",
          "2211:   if( (p->wsFlags & WHERE_VIRTUALTABLE)==0 ){",
          "2212:     Index *pIndex = p->u.btree.pIndex;",
          "2214:       p->u.btree.pIndex = 0;",
          "2215:     }",
          "2216:   }",
          "",
          "[Removed Lines]",
          "2213:     if( pIndex && pIndex->tnum==0 ){",
          "",
          "[Added Lines]",
          "2213:     if( pIndex && pIndex->idxType==SQLITE_IDXTYPE_IPK ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2878:     sPk.onError = OE_Replace;",
          "2879:     sPk.pTable = pTab;",
          "2880:     sPk.szIdxRow = pTab->szTabRow;",
          "2881:     aiRowEstPk[0] = pTab->nRowLogEst;",
          "2882:     aiRowEstPk[1] = 0;",
          "2883:     pFirst = pSrc->pTab->pIndex;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2881:     sPk.idxType = SQLITE_IDXTYPE_IPK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2968:     b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor);",
          "2970:     assert( (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || b==0 );",
          "2973:       pNew->wsFlags = WHERE_IPK;",
          "",
          "[Removed Lines]",
          "2971:     if( pProbe->tnum<=0 ){",
          "",
          "[Added Lines]",
          "2972:     if( pProbe->idxType==SQLITE_IDXTYPE_IPK ){",
          "",
          "---------------"
        ],
        "test/fts3fuzz001.test||test/fts3fuzz001.test": [
          "File: test/fts3fuzz001.test -> test/fts3fuzz001.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "102:   catchsql {",
          "103:     INSERT INTO t1(t1) VALUES('optimize');",
          "104:   }",
          "106: do_test fts3fuzz001-121 {",
          "107:   catchsql {",
          "108:     INSERT INTO t1(t1) VALUES('integrity-check');",
          "",
          "[Removed Lines]",
          "105: } {0 {}}",
          "",
          "[Added Lines]",
          "105: } {1 {database disk image is malformed}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "57e141bc28db0ac6fee77e24fadb437758060830",
      "candidate_info": {
        "commit_hash": "57e141bc28db0ac6fee77e24fadb437758060830",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/57e141bc28db0ac6fee77e24fadb437758060830",
        "files": [
          "manifest",
          "manifest.uuid",
          "tool/dbtotxt.c"
        ],
        "message": "Fix the filename normalization in the dbtotxt utility program.\n\nFossilOrigin-Name: 29a00a05dd40ff59be340969e1aca4fee41e092f2faa1cea85a3448265a83c2c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "tool/dbtotxt.c||tool/dbtotxt.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b0a49d5e6df116bb5eacb60a0bb0f482760aec38bd417d4250d9e57d43bdbb13",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/dbtotxt.c||tool/dbtotxt.c": [
          "File: tool/dbtotxt.c -> tool/dbtotxt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:   }",
          "113:   zBaseName = zInputFile;",
          "114:   for(i=0; zInputFile[i]; i++){",
          "116:   }",
          "117:   printf(\"| size %d pagesize %d filename %s\\n\",(int)szFile,pgsz,zBaseName);",
          "118:   for(i=0; i<szFile; i+=16){",
          "",
          "[Removed Lines]",
          "115:     if( zInputFile[i]=='/' && zInputFile[i+1]!=0 ) zBaseName = zInputFile+1;",
          "",
          "[Added Lines]",
          "115:     if( zInputFile[i]=='/' && zInputFile[i+1]!=0 ) zBaseName = zInputFile+i+1;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
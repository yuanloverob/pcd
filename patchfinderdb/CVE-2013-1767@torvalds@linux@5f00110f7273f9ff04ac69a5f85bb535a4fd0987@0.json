{
  "cve_id": "CVE-2013-1767",
  "cve_desc": "Use-after-free vulnerability in the shmem_remount_fs function in mm/shmem.c in the Linux kernel before 3.7.10 allows local users to gain privileges or cause a denial of service (system crash) by remounting a tmpfs filesystem without specifying a required mpol (aka mempolicy) mount option.",
  "repo": "torvalds/linux",
  "patch_hash": "5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
  "patch_info": {
    "commit_hash": "5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
    "files": [
      "mm/shmem.c"
    ],
    "message": "tmpfs: fix use-after-free of mempolicy object\n\nThe tmpfs remount logic preserves filesystem mempolicy if the mpol=M\noption is not specified in the remount request.  A new policy can be\nspecified if mpol=M is given.\n\nBefore this patch remounting an mpol bound tmpfs without specifying\nmpol= mount option in the remount request would set the filesystem's\nmempolicy object to a freed mempolicy object.\n\nTo reproduce the problem boot a DEBUG_PAGEALLOC kernel and run:\n    # mkdir /tmp/x\n\n    # mount -t tmpfs -o size=100M,mpol=interleave nodev /tmp/x\n\n    # grep /tmp/x /proc/mounts\n    nodev /tmp/x tmpfs rw,relatime,size=102400k,mpol=interleave:0-3 0 0\n\n    # mount -o remount,size=200M nodev /tmp/x\n\n    # grep /tmp/x /proc/mounts\n    nodev /tmp/x tmpfs rw,relatime,size=204800k,mpol=??? 0 0\n        # note ? garbage in mpol=... output above\n\n    # dd if=/dev/zero of=/tmp/x/f count=1\n        # panic here\n\nPanic:\n    BUG: unable to handle kernel NULL pointer dereference at           (null)\n    IP: [<          (null)>]           (null)\n    [...]\n    Oops: 0010 [#1] SMP DEBUG_PAGEALLOC\n    Call Trace:\n      mpol_shared_policy_init+0xa5/0x160\n      shmem_get_inode+0x209/0x270\n      shmem_mknod+0x3e/0xf0\n      shmem_create+0x18/0x20\n      vfs_create+0xb5/0x130\n      do_last+0x9a1/0xea0\n      path_openat+0xb3/0x4d0\n      do_filp_open+0x42/0xa0\n      do_sys_open+0xfe/0x1e0\n      compat_sys_open+0x1b/0x20\n      cstar_dispatch+0x7/0x1f\n\nNon-debug kernels will not crash immediately because referencing the\ndangling mpol will not cause a fault.  Instead the filesystem will\nreference a freed mempolicy object, which will cause unpredictable\nbehavior.\n\nThe problem boils down to a dropped mpol reference below if\nshmem_parse_options() does not allocate a new mpol:\n\n    config = *sbinfo\n    shmem_parse_options(data, &config, true)\n    mpol_put(sbinfo->mpol)\n    sbinfo->mpol = config.mpol  /* BUG: saves unreferenced mpol */\n\nThis patch avoids the crash by not releasing the mempolicy if\nshmem_parse_options() doesn't create a new mpol.\n\nHow far back does this issue go? I see it in both 2.6.36 and 3.3.  I did\nnot look back further.\n\nSigned-off-by: Greg Thelen <gthelen@google.com>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/shmem.c||mm/shmem.c"
    ]
  },
  "patch_diff": {
    "mm/shmem.c||mm/shmem.c": [
      "File: mm/shmem.c -> mm/shmem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2486:  unsigned long inodes;",
      "2487:  int error = -EINVAL;",
      "2489:  if (shmem_parse_options(data, &config, true))",
      "2490:   return error;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2489:  config.mpol = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2510:  sbinfo->max_inodes  = config.max_inodes;",
      "2511:  sbinfo->free_inodes = config.max_inodes - inodes;",
      "2515: out:",
      "2516:  spin_unlock(&sbinfo->stat_lock);",
      "2517:  return error;",
      "",
      "[Removed Lines]",
      "2513:  mpol_put(sbinfo->mpol);",
      "",
      "[Added Lines]",
      "2517:  if (config.mpol) {",
      "2518:   mpol_put(sbinfo->mpol);",
      "2520:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7f7d6c282e9d9b1721fdcdeac71383b7b0b60700",
      "candidate_info": {
        "commit_hash": "7f7d6c282e9d9b1721fdcdeac71383b7b0b60700",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7f7d6c282e9d9b1721fdcdeac71383b7b0b60700",
        "files": [
          "drivers/net/ethernet/freescale/fec.c"
        ],
        "message": "net: fec: Ensure that initialization is done prior to request_irq()\n\nCurrently request_irq() is called prior to fec_enet_init() and fec_ptp_init(),\nwhich causes the following crash on a mx53qsb:\n\nUnable to handle kernel NULL pointer dereference at virtual address 00000002\npgd = 80004000\n[00000002] *pgd=00000000\nInternal error: Oops: 5 [#1] SMP ARM\nModules linked in:\nCPU: 0    Not tainted  (3.8.0-rc7-next-20130215+ #346)\nPC is at fec_enet_interrupt+0xd0/0x348\nLR is at fec_enet_interrupt+0xb8/0x348\npc : [<80372b7c>]    lr : [<80372b64>]    psr: 60000193\nsp : df855c20  ip : df855c20  fp : df855c74\nr10: 00000516  r9 : 1c000000  r8 : 00000000\nr7 : 00000000  r6 : 00000000  r5 : 00000000  r4 : df9b7800\nr3 : df9b7df4  r2 : 00000000  r1 : 00000000  r0 : df9b7d34\n\nEnsure that such initialization functions are called prior to requesting the\ninterrupts, so that all necessary the data structures are in place when the\nirqs occur.\n\nSigned-off-by: Fabio Estevam <fabio.estevam@freescale.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/freescale/fec.c||drivers/net/ethernet/freescale/fec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/freescale/fec.c||drivers/net/ethernet/freescale/fec.c": [
          "File: drivers/net/ethernet/freescale/fec.c -> drivers/net/ethernet/freescale/fec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1782:   fep->phy_interface = ret;",
          "1783:  }",
          "1785:  for (i = 0; i < FEC_IRQ_NUM; i++) {",
          "1786:   irq = platform_get_irq(pdev, i);",
          "1787:   if (irq < 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1785:  fep->bufdesc_ex =",
          "1786:   pdev->id_entry->driver_data & FEC_QUIRK_HAS_BUFDESC_EX;",
          "1787:  if (fep->bufdesc_ex)",
          "1788:   fec_ptp_init(ndev, pdev);",
          "1790:  ret = fec_enet_init(ndev);",
          "1791:  if (ret)",
          "1792:   goto failed_init;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1819:  }",
          "1821:  fep->clk_ptp = devm_clk_get(&pdev->dev, \"ptp\");",
          "1824:  if (IS_ERR(fep->clk_ptp)) {",
          "1825:   ret = PTR_ERR(fep->clk_ptp);",
          "1826:   fep->bufdesc_ex = 0;",
          "",
          "[Removed Lines]",
          "1822:  fep->bufdesc_ex =",
          "1823:   pdev->id_entry->driver_data & FEC_QUIRK_HAS_BUFDESC_EX;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1844:  fec_reset_phy(pdev);",
          "1853:  ret = fec_enet_mii_init(pdev);",
          "1854:  if (ret)",
          "1855:   goto failed_mii_init;",
          "",
          "[Removed Lines]",
          "1846:  if (fep->bufdesc_ex)",
          "1847:   fec_ptp_init(ndev, pdev);",
          "1849:  ret = fec_enet_init(ndev);",
          "1850:  if (ret)",
          "1851:   goto failed_init;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1866: failed_register:",
          "1867:  fec_enet_mii_remove(fep);",
          "1868: failed_mii_init:",
          "1870: failed_regulator:",
          "1871:  clk_disable_unprepare(fep->clk_ahb);",
          "1872:  clk_disable_unprepare(fep->clk_ipg);",
          "",
          "[Removed Lines]",
          "1869: failed_init:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1881:  }",
          "1882: failed_irq:",
          "1883:  iounmap(fep->hwp);",
          "1884: failed_ioremap:",
          "1885:  free_netdev(ndev);",
          "1886: failed_alloc_etherdev:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1883: failed_init:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1900:  unregister_netdev(ndev);",
          "1901:  fec_enet_mii_remove(fep);",
          "1907:  del_timer_sync(&fep->time_keep);",
          "1908:  clk_disable_unprepare(fep->clk_ptp);",
          "1909:  if (fep->ptp_clock)",
          "1910:   ptp_clock_unregister(fep->ptp_clock);",
          "1911:  clk_disable_unprepare(fep->clk_ahb);",
          "1912:  clk_disable_unprepare(fep->clk_ipg);",
          "1913:  iounmap(fep->hwp);",
          "1914:  free_netdev(ndev);",
          "",
          "[Removed Lines]",
          "1902:  for (i = 0; i < FEC_IRQ_NUM; i++) {",
          "1903:   int irq = platform_get_irq(pdev, i);",
          "1904:   if (irq > 0)",
          "1905:    free_irq(irq, ndev);",
          "1906:  }",
          "",
          "[Added Lines]",
          "1908:  for (i = 0; i < FEC_IRQ_NUM; i++) {",
          "1909:   int irq = platform_get_irq(pdev, i);",
          "1910:   if (irq > 0)",
          "1911:    free_irq(irq, ndev);",
          "1912:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df05c1b85a88888b92725ef27ba70086f38fb083",
      "candidate_info": {
        "commit_hash": "df05c1b85a88888b92725ef27ba70086f38fb083",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/df05c1b85a88888b92725ef27ba70086f38fb083",
        "files": [
          "fs/jbd2/transaction.c"
        ],
        "message": "jbd2: fix ERR_PTR dereference in jbd2__journal_start\n\nIf start_this_handle() failed handle will be initialized\nto ERR_PTR() and can not be dereferenced.\n\npaging request at fffffffffffffff6\nIP: [<ffffffff813c073f>] jbd2__journal_start+0x18f/0x290\nPGD 200e067 PUD 200f067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: cpufreq_ondemand acpi_cpufreq freq_table mperf coretemp kvm_intel kvm crc32c_intel ghash_clmulni_intel microcode sg xhci_hcd button sd_mod crc_t10dif aesni_intel ablk_helper cryptd lrw aes_x86_64 xts gf128mul ahci libahci pata_acpi ata_generic dm_mirror dm_region_hash dm_log dm_mod\nCPU 0 journal commit I/O error\n\nPid: 2694, comm: fio Not tainted 3.8.0-rc3+ #79                  /DQ67SW\nRIP: 0010:[<ffffffff813c073f>]  [<ffffffff813c073f>] jbd2__journal_start+0x18f/0x290\nRSP: 0018:ffff880233b8ba58  EFLAGS: 00010292\nRAX: 00000000ffffffe2 RBX: ffffffffffffffe2 RCX: 0000000000000006\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff82128f48\nRBP: ffff880233b8ba98 R08: 0000000000000000 R09: ffff88021440a6e0\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/jbd2/transaction.c||fs/jbd2/transaction.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/jbd2/transaction.c||fs/jbd2/transaction.c": [
          "File: fs/jbd2/transaction.c -> fs/jbd2/transaction.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "382:  if (err < 0) {",
          "383:   jbd2_free_handle(handle);",
          "384:   current->journal_info = NULL;",
          "386:  }",
          "387:  handle->h_type = type;",
          "388:  handle->h_line_no = line_no;",
          "",
          "[Removed Lines]",
          "385:   handle = ERR_PTR(err);",
          "",
          "[Added Lines]",
          "385:   return ERR_PTR(err);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "16245bdc9d3e22d1460341a655c8b5288953bc14",
      "candidate_info": {
        "commit_hash": "16245bdc9d3e22d1460341a655c8b5288953bc14",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/16245bdc9d3e22d1460341a655c8b5288953bc14",
        "files": [
          "drivers/md/dm.c"
        ],
        "message": "dm: do not replace bioset for request based dm\n\nThis patch fixes a regression introduced in v3.8, which causes oops\nlike this when dm-multipath is used:\n\ngeneral protection fault: 0000 [#1] SMP\nRIP: 0010:[<ffffffff810fe754>]  [<ffffffff810fe754>] mempool_free+0x24/0xb0\nCall Trace:\n  <IRQ>\n  [<ffffffff81187417>] bio_put+0x97/0xc0\n  [<ffffffffa02247a5>] end_clone_bio+0x35/0x90 [dm_mod]\n  [<ffffffff81185efd>] bio_endio+0x1d/0x30\n  [<ffffffff811f03a3>] req_bio_endio.isra.51+0xa3/0xe0\n  [<ffffffff811f2f68>] blk_update_request+0x118/0x520\n  [<ffffffff811f3397>] blk_update_bidi_request+0x27/0xa0\n  [<ffffffff811f343c>] blk_end_bidi_request+0x2c/0x80\n  [<ffffffff811f34d0>] blk_end_request+0x10/0x20\n  [<ffffffffa000b32b>] scsi_io_completion+0xfb/0x6c0 [scsi_mod]\n  [<ffffffffa000107d>] scsi_finish_command+0xbd/0x120 [scsi_mod]\n  [<ffffffffa000b12f>] scsi_softirq_done+0x13f/0x160 [scsi_mod]\n  [<ffffffff811f9fd0>] blk_done_softirq+0x80/0xa0\n  [<ffffffff81044551>] __do_softirq+0xf1/0x250\n  [<ffffffff8142ee8c>] call_softirq+0x1c/0x30\n  [<ffffffff8100420d>] do_softirq+0x8d/0xc0\n  [<ffffffff81044885>] irq_exit+0xd5/0xe0\n  [<ffffffff8142f3e3>] do_IRQ+0x63/0xe0\n  [<ffffffff814257af>] common_interrupt+0x6f/0x6f\n  <EOI>\n  [<ffffffffa021737c>] srp_queuecommand+0x8c/0xcb0 [ib_srp]\n  [<ffffffffa0002f18>] scsi_dispatch_cmd+0x148/0x310 [scsi_mod]\n  [<ffffffffa000a38e>] scsi_request_fn+0x31e/0x520 [scsi_mod]\n  [<ffffffff811f1e57>] __blk_run_queue+0x37/0x50\n  [<ffffffff811f1f69>] blk_delay_work+0x29/0x40\n  [<ffffffff81059003>] process_one_work+0x1c3/0x5c0\n  [<ffffffff8105b22e>] worker_thread+0x15e/0x440\n  [<ffffffff8106164b>] kthread+0xdb/0xe0\n  [<ffffffff8142db9c>] ret_from_fork+0x7c/0xb0\n\nThe regression was introduced by the change\nc0820cf5 \"dm: introduce per_bio_data\", where dm started to replace\nbioset during table replacement.\nFor bio-based dm, it is good because clone bios do not exist during the\ntable replacement.\nFor request-based dm, however, (not-yet-mapped) clone bios may stay in\nrequest queue and survive during the table replacement.\nSo freeing the old bioset could cause the oops in bio_put().\n\nSince the size of front_pad may change only with bio-based dm,\nit is not necessary to replace bioset for request-based dm.\n\nReported-by: Bart Van Assche <bvanassche@acm.org>\nTested-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>\nAcked-by: Mikulas Patocka <mpatocka@redhat.com>\nAcked-by: Mike Snitzer <snitzer@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Alasdair G Kergon <agk@redhat.com>",
        "before_after_code_files": [
          "drivers/md/dm.c||drivers/md/dm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/md/dm.c||drivers/md/dm.c": [
          "File: drivers/md/dm.c -> drivers/md/dm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1947: {",
          "1948:  struct dm_md_mempools *p = dm_table_get_md_mempools(t);",
          "1959:   goto out;",
          "1960:  }",
          "",
          "[Removed Lines]",
          "1950:  if (md->io_pool && (md->tio_pool || dm_table_get_type(t) == DM_TYPE_BIO_BASED) && md->bs) {",
          "1956:   bioset_free(md->bs);",
          "1957:   md->bs = p->bs;",
          "1958:   p->bs = NULL;",
          "",
          "[Added Lines]",
          "1950:  if (md->io_pool && md->bs) {",
          "1952:   if (dm_table_get_type(t) == DM_TYPE_BIO_BASED) {",
          "1957:    bioset_free(md->bs);",
          "1958:    md->bs = p->bs;",
          "1959:    p->bs = NULL;",
          "1960:   } else if (dm_table_get_type(t) == DM_TYPE_REQUEST_BASED) {",
          "1961:    BUG_ON(!md->tio_pool);",
          "1970:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5370019dc2d2c2ff90e95d181468071362934f3a",
      "candidate_info": {
        "commit_hash": "5370019dc2d2c2ff90e95d181468071362934f3a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5370019dc2d2c2ff90e95d181468071362934f3a",
        "files": [
          "drivers/block/loop.c"
        ],
        "message": "loopdev: fix a deadlock\n\nbd_mutex and lo_ctl_mutex can be held in different order.\n\nPath #1:\n\nblkdev_open\n blkdev_get\n  __blkdev_get (hold bd_mutex)\n   lo_open (hold lo_ctl_mutex)\n\nPath #2:\n\nblkdev_ioctl\n lo_ioctl (hold lo_ctl_mutex)\n  lo_set_capacity (hold bd_mutex)\n\nLockdep does not report it, because path #2 actually holds a subclass of\nlo_ctl_mutex.  This subclass seems creep into the code by mistake.  The\npatch author actually just mentioned it in the changelog, see commit\nf028f3b2 (\"loop: fix circular locking in loop_clr_fd()\"), also see:\n\n\thttp://marc.info/?l=linux-kernel&m=123806169129727&w=2\n\nPath #2 hold bd_mutex to call bd_set_size(), I've protected it\nwith i_mutex in a previous patch, so drop bd_mutex at this site.\n\nSigned-off-by: Guo Chao <yan@linux.vnet.ibm.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: Guo Chao <yan@linux.vnet.ibm.com>\nCc: M. Hindess <hindessm@uk.ibm.com>\nCc: Nikanth Karthikesan <knikanth@suse.de>\nCc: Jens Axboe <axboe@kernel.dk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/block/loop.c||drivers/block/loop.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/block/loop.c||drivers/block/loop.c": [
          "File: drivers/block/loop.c -> drivers/block/loop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1286:  sz = sec;",
          "1287:  sz <<= 9;",
          "1289:  bd_set_size(bdev, sz);",
          "1291:  kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, KOBJ_CHANGE);",
          "1294:  out:",
          "1295:  return err;",
          "",
          "[Removed Lines]",
          "1288:  mutex_lock(&bdev->bd_mutex);",
          "1292:  mutex_unlock(&bdev->bd_mutex);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20e6926dcbafa1b361f1c29d967688be14b6ca4b",
      "candidate_info": {
        "commit_hash": "20e6926dcbafa1b361f1c29d967688be14b6ca4b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/20e6926dcbafa1b361f1c29d967688be14b6ca4b",
        "files": [
          "Documentation/kernel-parameters.txt",
          "arch/x86/kernel/setup.c",
          "arch/x86/mm/numa.c",
          "arch/x86/mm/srat.c",
          "drivers/acpi/numa.c",
          "include/linux/acpi.h",
          "include/linux/memblock.h",
          "include/linux/mm.h",
          "mm/memblock.c",
          "mm/page_alloc.c"
        ],
        "message": "x86, ACPI, mm: Revert movablemem_map support\n\nTim found:\n\n  WARNING: at arch/x86/kernel/smpboot.c:324 topology_sane.isra.2+0x6f/0x80()\n  Hardware name: S2600CP\n  sched: CPU #1's llc-sibling CPU #0 is not on the same node! [node: 1 != 0]. Ignoring dependency.\n  smpboot: Booting Node   1, Processors  #1\n  Modules linked in:\n  Pid: 0, comm: swapper/1 Not tainted 3.9.0-0-generic #1\n  Call Trace:\n    set_cpu_sibling_map+0x279/0x449\n    start_secondary+0x11d/0x1e5\n\nDon Morris reproduced on a HP z620 workstation, and bisected it to\ncommit e8d195525809 (\"acpi, memory-hotplug: parse SRAT before memblock\nis ready\")\n\nIt turns out movable_map has some problems, and it breaks several things\n\n1. numa_init is called several times, NOT just for srat. so those\n\tnodes_clear(numa_nodes_parsed)\n\tmemset(&numa_meminfo, 0, sizeof(numa_meminfo))\n   can not be just removed.  Need to consider sequence is: numaq, srat, amd, dummy.\n   and make fall back path working.\n\n2. simply split acpi_numa_init to early_parse_srat.\n   a. that early_parse_srat is NOT called for ia64, so you break ia64.\n   b.  for (i = 0; i < MAX_LOCAL_APIC; i++)\n\t     set_apicid_to_node(i, NUMA_NO_NODE)\n     still left in numa_init. So it will just clear result from early_parse_srat.\n     it should be moved before that....\n   c.  it breaks ACPI_TABLE_OVERIDE...as the acpi table scan is moved\n       early before override from INITRD is settled.\n\n3. that patch TITLE is total misleading, there is NO x86 in the title,\n   but it changes critical x86 code. It caused x86 guys did not\n   pay attention to find the problem early. Those patches really should\n   be routed via tip/x86/mm.\n\n4. after that commit, following range can not use movable ram:\n  a. real_mode code.... well..funny, legacy Node0 [0,1M) could be hot-removed?\n  b. initrd... it will be freed after booting, so it could be on movable...\n  c. crashkernel for kdump...: looks like we can not put kdump kernel above 4G\n\tanymore.\n  d. init_mem_mapping: can not put page table high anymore.\n  e. initmem_init: vmemmap can not be high local node anymore. That is\n     not good.\n\nIf node is hotplugable, the mem related range like page table and\nvmemmap could be on the that node without problem and should be on that\nnode.\n\nWe have workaround patch that could fix some problems, but some can not\nbe fixed.\n\nSo just remove that offending commit and related ones including:\n\n f7210e6c4ac7 (\"mm/memblock.c: use CONFIG_HAVE_MEMBLOCK_NODE_MAP to\n    protect movablecore_map in memblock_overlaps_region().\")\n\n 01a178a94e8e (\"acpi, memory-hotplug: support getting hotplug info from\n    SRAT\")\n\n 27168d38fa20 (\"acpi, memory-hotplug: extend movablemem_map ranges to\n    the end of node\")\n\n e8d195525809 (\"acpi, memory-hotplug: parse SRAT before memblock is\n    ready\")\n\n fb06bc8e5f42 (\"page_alloc: bootmem limit with movablecore_map\")\n\n 42f47e27e761 (\"page_alloc: make movablemem_map have higher priority\")\n\n 6981ec31146c (\"page_alloc: introduce zone_movable_limit[] to keep\n    movable limit for nodes\")\n\n 34b71f1e04fc (\"page_alloc: add movable_memmap kernel parameter\")\n\n 4d59a75125d5 (\"x86: get pg_data_t's memory from other node\")\n\nLater we should have patches that will make sure kernel put page table\nand vmemmap on local node ram instead of push them down to node0.  Also\nneed to find way to put other kernel used ram to local node ram.\n\nReported-by: Tim Gardner <tim.gardner@canonical.com>\nReported-by: Don Morris <don.morris@hp.com>\nBisected-by: Don Morris <don.morris@hp.com>\nTested-by: Don Morris <don.morris@hp.com>\nSigned-off-by: Yinghai Lu <yinghai@kernel.org>\nCc: Tony Luck <tony.luck@intel.com>\nCc: Thomas Renninger <trenn@suse.de>\nCc: Tejun Heo <tj@kernel.org>\nCc: Tang Chen <tangchen@cn.fujitsu.com>\nCc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "arch/x86/kernel/setup.c||arch/x86/kernel/setup.c",
          "arch/x86/mm/numa.c||arch/x86/mm/numa.c",
          "arch/x86/mm/srat.c||arch/x86/mm/srat.c",
          "drivers/acpi/numa.c||drivers/acpi/numa.c",
          "include/linux/acpi.h||include/linux/acpi.h",
          "include/linux/memblock.h||include/linux/memblock.h",
          "include/linux/mm.h||include/linux/mm.h",
          "mm/memblock.c||mm/memblock.c",
          "mm/page_alloc.c||mm/page_alloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/kernel/setup.c||arch/x86/kernel/setup.c": [
          "File: arch/x86/kernel/setup.c -> arch/x86/kernel/setup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1056:  setup_bios_corruption_check();",
          "1057: #endif",
          "1068: #ifdef CONFIG_X86_32",
          "1069:  printk(KERN_DEBUG \"initial memory mapped: [mem 0x00000000-%#010lx]\\n\",",
          "1070:    (max_pfn_mapped<<PAGE_SHIFT) - 1);",
          "",
          "[Removed Lines]",
          "1064:  acpi_boot_table_init();",
          "1065:  early_acpi_boot_init();",
          "1066:  early_parse_srat();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1113:  initmem_init();",
          "1114:  memblock_find_dma_reserve();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1104:  acpi_boot_table_init();",
          "1106:  early_acpi_boot_init();",
          "",
          "---------------"
        ],
        "arch/x86/mm/numa.c||arch/x86/mm/numa.c": [
          "File: arch/x86/mm/numa.c -> arch/x86/mm/numa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:  if (!nd_pa) {",
          "218:   return;",
          "219:  }",
          "220:  nd = __va(nd_pa);",
          "",
          "[Removed Lines]",
          "215:  nd_pa = memblock_alloc_try_nid(nd_size, SMP_CACHE_BYTES, nid);",
          "217:   pr_err(\"Cannot find %zu bytes in any node\\n\", nd_size);",
          "",
          "[Added Lines]",
          "215:  nd_pa = memblock_alloc_nid(nd_size, SMP_CACHE_BYTES, nid);",
          "217:   pr_err(\"Cannot find %zu bytes in node %d\\n\",",
          "218:          nd_size, nid);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "559:  for (i = 0; i < MAX_LOCAL_APIC; i++)",
          "560:   set_apicid_to_node(i, NUMA_NO_NODE);",
          "566:  nodes_clear(node_possible_map);",
          "567:  nodes_clear(node_online_map);",
          "568:  WARN_ON(memblock_set_node(0, ULLONG_MAX, MAX_NUMNODES));",
          "569:  numa_reset_distance();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:  nodes_clear(numa_nodes_parsed);",
          "566:  memset(&numa_meminfo, 0, sizeof(numa_meminfo));",
          "",
          "---------------"
        ],
        "arch/x86/mm/srat.c||arch/x86/mm/srat.c": [
          "File: arch/x86/mm/srat.c -> arch/x86/mm/srat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: static inline int save_add_info(void) {return 0;}",
          "142: #endif",
          "259: int __init",
          "260: acpi_numa_memory_affinity_init(struct acpi_srat_mem_affinity *ma)",
          "261: {",
          "262:  u64 start, end;",
          "264:  int node, pxm;",
          "266:  if (srat_disabled())",
          "",
          "[Removed Lines]",
          "144: #ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP",
          "145: static void __init",
          "146: handle_movablemem(int node, u64 start, u64 end, u32 hotpluggable)",
          "147: {",
          "148:  int overlap, i;",
          "149:  unsigned long start_pfn, end_pfn;",
          "151:  start_pfn = PFN_DOWN(start);",
          "152:  end_pfn = PFN_UP(end);",
          "173:  if (hotpluggable && movablemem_map.acpi) {",
          "175:   struct memblock_type *rgn = &memblock.reserved;",
          "177:   for (i = 0; i < rgn->cnt; i++) {",
          "178:    if (end <= rgn->regions[i].base ||",
          "179:        start >= rgn->regions[i].base +",
          "180:        rgn->regions[i].size)",
          "181:     continue;",
          "187:    node_set(node, movablemem_map.numa_nodes_kernel);",
          "189:    goto out;",
          "190:   }",
          "196:   if (node_isset(node, movablemem_map.numa_nodes_kernel))",
          "197:    goto out;",
          "199:   insert_movablemem_map(start_pfn, end_pfn);",
          "205:   node_set(node, movablemem_map.numa_nodes_hotplug);",
          "206:   goto out;",
          "207:  }",
          "222:  overlap = movablemem_map_overlap(start_pfn, end_pfn);",
          "223:  if (overlap >= 0) {",
          "230:   start_pfn = max(start_pfn,",
          "231:        movablemem_map.map[overlap].start_pfn);",
          "232:   insert_movablemem_map(start_pfn, end_pfn);",
          "239:   node_set(node, movablemem_map.numa_nodes_hotplug);",
          "240:  } else {",
          "241:   if (node_isset(node, movablemem_map.numa_nodes_hotplug))",
          "246:    insert_movablemem_map(start_pfn, end_pfn);",
          "247:  }",
          "248: out:",
          "249:  return;",
          "250: }",
          "252: static inline void",
          "253: handle_movablemem(int node, u64 start, u64 end, u32 hotpluggable)",
          "254: {",
          "255: }",
          "263:  u32 hotpluggable;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "269:   goto out_err_bad_srat;",
          "270:  if ((ma->flags & ACPI_SRAT_MEM_ENABLED) == 0)",
          "271:   goto out_err;",
          "274:   goto out_err;",
          "276:  start = ma->base_address;",
          "",
          "[Removed Lines]",
          "272:  hotpluggable = ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE;",
          "273:  if (hotpluggable && !save_add_info())",
          "",
          "[Added Lines]",
          "157:  if ((ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) && !save_add_info())",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "291:  node_set(node, numa_nodes_parsed);",
          "294:         node, pxm,",
          "300:  return 0;",
          "301: out_err_bad_srat:",
          "",
          "[Removed Lines]",
          "293:  printk(KERN_INFO \"SRAT: Node %u PXM %u [mem %#010Lx-%#010Lx] %s\\n\",",
          "295:         (unsigned long long) start, (unsigned long long) end - 1,",
          "296:         hotpluggable ? \"Hot Pluggable\": \"\");",
          "298:  handle_movablemem(node, start, end, hotpluggable);",
          "",
          "[Added Lines]",
          "177:  printk(KERN_INFO \"SRAT: Node %u PXM %u [mem %#010Lx-%#010Lx]\\n\",",
          "179:         (unsigned long long) start, (unsigned long long) end - 1);",
          "",
          "---------------"
        ],
        "drivers/acpi/numa.c||drivers/acpi/numa.c": [
          "File: drivers/acpi/numa.c -> drivers/acpi/numa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:          handler, max_entries);",
          "283: }",
          "288: {",
          "",
          "[Removed Lines]",
          "285: static int srat_mem_cnt;",
          "287: void __init early_parse_srat(void)",
          "",
          "[Added Lines]",
          "285: int __init acpi_numa_init(void)",
          "287:  int cnt = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "296:  if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {",
          "297:   acpi_table_parse_srat(ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY,",
          "299:   acpi_table_parse_srat(ACPI_SRAT_TYPE_CPU_AFFINITY,",
          "304:  }",
          "310:  acpi_table_parse(ACPI_SIG_SLIT, acpi_parse_slit);",
          "312:  acpi_numa_arch_fixup();",
          "316:  else if (!parsed_numa_memblks)",
          "317:   return -ENOENT;",
          "318:  return 0;",
          "",
          "[Removed Lines]",
          "298:           acpi_parse_x2apic_affinity, 0);",
          "300:           acpi_parse_processor_affinity, 0);",
          "301:   srat_mem_cnt = acpi_table_parse_srat(ACPI_SRAT_TYPE_MEMORY_AFFINITY,",
          "302:            acpi_parse_memory_affinity,",
          "303:            NR_NODE_MEMBLKS);",
          "305: }",
          "307: int __init acpi_numa_init(void)",
          "308: {",
          "314:  if (srat_mem_cnt < 0)",
          "315:   return srat_mem_cnt;",
          "",
          "[Added Lines]",
          "298:          acpi_parse_x2apic_affinity, 0);",
          "300:          acpi_parse_processor_affinity, 0);",
          "301:   cnt = acpi_table_parse_srat(ACPI_SRAT_TYPE_MEMORY_AFFINITY,",
          "302:          acpi_parse_memory_affinity,",
          "303:          NR_NODE_MEMBLKS);",
          "311:  if (cnt < 0)",
          "312:   return cnt;",
          "",
          "---------------"
        ],
        "include/linux/acpi.h||include/linux/acpi.h": [
          "File: include/linux/acpi.h -> include/linux/acpi.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "496: #ifdef CONFIG_ACPI",
          "497: void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,",
          "498:           u32 pm1a_ctrl,  u32 pm1b_ctrl));",
          "",
          "[Removed Lines]",
          "488: #ifdef CONFIG_ACPI_NUMA",
          "489: void __init early_parse_srat(void);",
          "490: #else",
          "491: static inline void early_parse_srat(void)",
          "492: {",
          "493: }",
          "494: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/memblock.h||include/linux/memblock.h": [
          "File: include/linux/memblock.h -> include/linux/memblock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: extern struct memblock memblock;",
          "44: extern int memblock_debug;",
          "47: #define memblock_dbg(fmt, ...) \\",
          "48:  if (memblock_debug) printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)",
          "",
          "[Removed Lines]",
          "45: extern struct movablemem_map movablemem_map;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/mm.h||include/linux/mm.h": [
          "File: include/linux/mm.h -> include/linux/mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1333:       unsigned long max_low_pfn);",
          "1334: extern void sparse_memory_present_with_active_regions(int nid);",
          "1356: #if !defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) && \\",
          "",
          "[Removed Lines]",
          "1336: #define MOVABLEMEM_MAP_MAX MAX_NUMNODES",
          "1337: struct movablemem_entry {",
          "1340: };",
          "1342: struct movablemem_map {",
          "1344:  int nr_map;",
          "1345:  struct movablemem_entry map[MOVABLEMEM_MAP_MAX];",
          "1348: };",
          "1350: extern void __init insert_movablemem_map(unsigned long start_pfn,",
          "1351:       unsigned long end_pfn);",
          "1352: extern int __init movablemem_map_overlap(unsigned long start_pfn,",
          "1353:       unsigned long end_pfn);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mm/memblock.c||mm/memblock.c": [
          "File: mm/memblock.c -> mm/memblock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147: phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t start,",
          "148:      phys_addr_t end, phys_addr_t size,",
          "149:      phys_addr_t align, int nid)",
          "",
          "[Removed Lines]",
          "101: #ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP",
          "102: phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t start,",
          "103:      phys_addr_t end, phys_addr_t size,",
          "104:      phys_addr_t align, int nid)",
          "105: {",
          "106:  phys_addr_t this_start, this_end, cand;",
          "107:  u64 i;",
          "108:  int curr = movablemem_map.nr_map - 1;",
          "111:  if (end == MEMBLOCK_ALLOC_ACCESSIBLE)",
          "112:   end = memblock.current_limit;",
          "115:  start = max_t(phys_addr_t, start, PAGE_SIZE);",
          "116:  end = max(start, end);",
          "118:  for_each_free_mem_range_reverse(i, nid, &this_start, &this_end, NULL) {",
          "119:   this_start = clamp(this_start, start, end);",
          "120:   this_end = clamp(this_end, start, end);",
          "122: restart:",
          "123:   if (this_end <= this_start || this_end < size)",
          "124:    continue;",
          "126:   for (; curr >= 0; curr--) {",
          "127:    if ((movablemem_map.map[curr].start_pfn << PAGE_SHIFT)",
          "128:        < this_end)",
          "129:     break;",
          "130:   }",
          "132:   cand = round_down(this_end - size, align);",
          "133:   if (curr >= 0 &&",
          "134:       cand < movablemem_map.map[curr].end_pfn << PAGE_SHIFT) {",
          "135:    this_end = movablemem_map.map[curr].start_pfn",
          "136:        << PAGE_SHIFT;",
          "137:    goto restart;",
          "138:   }",
          "140:   if (cand >= this_start)",
          "141:    return cand;",
          "142:  }",
          "144:  return 0;",
          "145: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mm/page_alloc.c||mm/page_alloc.c": [
          "File: mm/page_alloc.c -> mm/page_alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202: static unsigned long __meminitdata dma_reserve;",
          "204: #ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP",
          "211: static unsigned long __meminitdata arch_zone_lowest_possible_pfn[MAX_NR_ZONES];",
          "212: static unsigned long __meminitdata arch_zone_highest_possible_pfn[MAX_NR_ZONES];",
          "213: static unsigned long __initdata required_kernelcore;",
          "214: static unsigned long __initdata required_movablecore;",
          "215: static unsigned long __meminitdata zone_movable_pfn[MAX_NUMNODES];",
          "219: int movable_zone;",
          "",
          "[Removed Lines]",
          "206: struct movablemem_map movablemem_map = {",
          "207:  .acpi = false,",
          "208:  .nr_map = 0,",
          "209: };",
          "216: static unsigned long __meminitdata zone_movable_limit[MAX_NUMNODES];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4412:  return __absent_pages_in_range(nid, zone_start_pfn, zone_end_pfn);",
          "4413: }",
          "4487: static inline unsigned long __meminit zone_spanned_pages_in_node(int nid,",
          "4488:      unsigned long zone_type,",
          "",
          "[Removed Lines]",
          "4425: static void __meminit sanitize_zone_movable_limit(void)",
          "4426: {",
          "4427:  int map_pos = 0, i, nid;",
          "4428:  unsigned long start_pfn, end_pfn;",
          "4430:  if (!movablemem_map.nr_map)",
          "4431:   return;",
          "4434:  for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
          "4439:   if (zone_movable_limit[nid])",
          "4440:    continue;",
          "4442: #ifdef CONFIG_ZONE_DMA",
          "4444:   if (start_pfn < arch_zone_highest_possible_pfn[ZONE_DMA])",
          "4445:    start_pfn = arch_zone_highest_possible_pfn[ZONE_DMA];",
          "4446: #endif",
          "4448: #ifdef CONFIG_ZONE_DMA32",
          "4450:   if (start_pfn < arch_zone_highest_possible_pfn[ZONE_DMA32])",
          "4451:    start_pfn = arch_zone_highest_possible_pfn[ZONE_DMA32];",
          "4452: #endif",
          "4454: #ifdef CONFIG_HIGHMEM",
          "4456:   if (zone_movable_is_highmem() &&",
          "4457:       start_pfn < arch_zone_lowest_possible_pfn[ZONE_HIGHMEM])",
          "4458:    start_pfn = arch_zone_lowest_possible_pfn[ZONE_HIGHMEM];",
          "4459: #endif",
          "4461:   if (start_pfn >= end_pfn)",
          "4462:    continue;",
          "4464:   while (map_pos < movablemem_map.nr_map) {",
          "4465:    if (end_pfn <= movablemem_map.map[map_pos].start_pfn)",
          "4466:     break;",
          "4468:    if (start_pfn >= movablemem_map.map[map_pos].end_pfn) {",
          "4469:     map_pos++;",
          "4470:     continue;",
          "4471:    }",
          "4478:    zone_movable_limit[nid] = max(start_pfn,",
          "4479:      movablemem_map.map[map_pos].start_pfn);",
          "4481:    break;",
          "4482:   }",
          "4483:  }",
          "4484: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4941:   required_kernelcore = max(required_kernelcore, corepages);",
          "4942:  }",
          "4953:   goto out;",
          "4957:  usable_startpfn = arch_zone_lowest_possible_pfn[movable_zone];",
          "4959: restart:",
          "",
          "[Removed Lines]",
          "4949:  if (!required_kernelcore) {",
          "4950:   if (movablemem_map.nr_map)",
          "4951:    memcpy(zone_movable_pfn, zone_movable_limit,",
          "4952:     sizeof(zone_movable_pfn));",
          "4954:  }",
          "",
          "[Added Lines]",
          "4868:  if (!required_kernelcore)",
          "4872:  find_usable_zone_for_movable();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4981:   for_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {",
          "4982:    unsigned long size_pages;",
          "4988:    start_pfn = max(start_pfn, zone_movable_pfn[nid]);",
          "4989:    if (start_pfn >= end_pfn)",
          "4990:     continue;",
          "5003:    if (start_pfn < usable_startpfn) {",
          "5004:     unsigned long kernel_pages;",
          "",
          "[Removed Lines]",
          "4992:    if (zone_movable_limit[nid]) {",
          "4993:     end_pfn = min(end_pfn, zone_movable_limit[nid]);",
          "4995:     if (start_pfn >= end_pfn) {",
          "4996:      zone_movable_pfn[nid] =",
          "4997:        zone_movable_limit[nid];",
          "4998:      break;",
          "4999:     }",
          "5000:    }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5058:  if (usable_nodes && required_kernelcore > usable_nodes)",
          "5059:   goto restart;",
          "5063:  for (nid = 0; nid < MAX_NUMNODES; nid++)",
          "5064:   zone_movable_pfn[nid] =",
          "5065:    roundup(zone_movable_pfn[nid], MAX_ORDER_NR_PAGES);",
          "5068:  node_states[N_MEMORY] = saved_node_state;",
          "5069: }",
          "",
          "[Removed Lines]",
          "5061: out:",
          "",
          "[Added Lines]",
          "4968: out:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5128:  memset(zone_movable_pfn, 0, sizeof(zone_movable_pfn));",
          "5131:  find_zone_movable_pfns_for_nodes();",
          "",
          "[Removed Lines]",
          "5129:  find_usable_zone_for_movable();",
          "5130:  sanitize_zone_movable_limit();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5211: early_param(\"kernelcore\", cmdline_parse_kernelcore);",
          "5212: early_param(\"movablecore\", cmdline_parse_movablecore);",
          "",
          "[Removed Lines]",
          "5225: int __init movablemem_map_overlap(unsigned long start_pfn,",
          "5226:        unsigned long end_pfn)",
          "5227: {",
          "5228:  int overlap;",
          "5230:  if (!movablemem_map.nr_map)",
          "5231:   return -1;",
          "5233:  for (overlap = 0; overlap < movablemem_map.nr_map; overlap++)",
          "5234:   if (start_pfn < movablemem_map.map[overlap].end_pfn)",
          "5235:    break;",
          "5237:  if (overlap == movablemem_map.nr_map ||",
          "5238:      end_pfn <= movablemem_map.map[overlap].start_pfn)",
          "5239:   return -1;",
          "5241:  return overlap;",
          "5242: }",
          "5252: void __init insert_movablemem_map(unsigned long start_pfn,",
          "5253:       unsigned long end_pfn)",
          "5254: {",
          "5255:  int pos, overlap;",
          "5261:  for (pos = 0; pos < movablemem_map.nr_map; pos++)",
          "5262:   if (start_pfn <= movablemem_map.map[pos].end_pfn)",
          "5263:    break;",
          "5266:  if (pos == movablemem_map.nr_map ||",
          "5267:      end_pfn < movablemem_map.map[pos].start_pfn) {",
          "5272:   if (pos < movablemem_map.nr_map)",
          "5273:    memmove(&movablemem_map.map[pos+1],",
          "5274:     &movablemem_map.map[pos],",
          "5275:     sizeof(struct movablemem_entry) *",
          "5276:     (movablemem_map.nr_map - pos));",
          "5277:   movablemem_map.map[pos].start_pfn = start_pfn;",
          "5278:   movablemem_map.map[pos].end_pfn = end_pfn;",
          "5279:   movablemem_map.nr_map++;",
          "5280:   return;",
          "5281:  }",
          "5284:  for (overlap = pos + 1; overlap < movablemem_map.nr_map; overlap++)",
          "5285:   if (end_pfn < movablemem_map.map[overlap].start_pfn)",
          "5286:    break;",
          "5292:  overlap--;",
          "5293:  movablemem_map.map[pos].start_pfn = min(start_pfn,",
          "5294:      movablemem_map.map[pos].start_pfn);",
          "5295:  movablemem_map.map[pos].end_pfn = max(end_pfn,",
          "5296:      movablemem_map.map[overlap].end_pfn);",
          "5298:  if (pos != overlap && overlap + 1 != movablemem_map.nr_map)",
          "5299:   memmove(&movablemem_map.map[pos+1],",
          "5300:    &movablemem_map.map[overlap+1],",
          "5301:    sizeof(struct movablemem_entry) *",
          "5302:    (movablemem_map.nr_map - overlap - 1));",
          "5304:  movablemem_map.nr_map -= overlap - pos;",
          "5305: }",
          "5315: static void __init movablemem_map_add_region(u64 start, u64 size)",
          "5316: {",
          "5317:  unsigned long start_pfn, end_pfn;",
          "5320:  if (start + size <= start)",
          "5321:   return;",
          "5323:  if (movablemem_map.nr_map >= ARRAY_SIZE(movablemem_map.map)) {",
          "5324:   pr_err(\"movablemem_map: too many entries;\"",
          "5325:    \" ignoring [mem %#010llx-%#010llx]\\n\",",
          "5326:    (unsigned long long) start,",
          "5327:    (unsigned long long) (start + size - 1));",
          "5328:   return;",
          "5329:  }",
          "5331:  start_pfn = PFN_DOWN(start);",
          "5332:  end_pfn = PFN_UP(start + size);",
          "5333:  insert_movablemem_map(start_pfn, end_pfn);",
          "5334: }",
          "5345: static int __init cmdline_parse_movablemem_map(char *p)",
          "5346: {",
          "5347:  char *oldp;",
          "5348:  u64 start_at, mem_size;",
          "5350:  if (!p)",
          "5351:   goto err;",
          "5353:  if (!strcmp(p, \"acpi\"))",
          "5354:   movablemem_map.acpi = true;",
          "5360:  if (movablemem_map.acpi) {",
          "5361:   if (movablemem_map.nr_map) {",
          "5362:    memset(movablemem_map.map, 0,",
          "5363:     sizeof(struct movablemem_entry)",
          "5365:    movablemem_map.nr_map = 0;",
          "5366:   }",
          "5367:   return 0;",
          "5368:  }",
          "5370:  oldp = p;",
          "5371:  mem_size = memparse(p, &p);",
          "5372:  if (p == oldp)",
          "5373:   goto err;",
          "5375:  if (*p == '@') {",
          "5376:   oldp = ++p;",
          "5377:   start_at = memparse(p, &p);",
          "5378:   if (p == oldp || *p != '\\0')",
          "5379:    goto err;",
          "5381:   movablemem_map_add_region(start_at, mem_size);",
          "5382:   return 0;",
          "5383:  }",
          "5384: err:",
          "5385:  return -EINVAL;",
          "5386: }",
          "5387: early_param(\"movablemem_map\", cmdline_parse_movablemem_map);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
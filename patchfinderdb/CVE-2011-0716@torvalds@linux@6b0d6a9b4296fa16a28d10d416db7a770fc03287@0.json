{
  "cve_id": "CVE-2011-0716",
  "cve_desc": "The br_multicast_add_group function in net/bridge/br_multicast.c in the Linux kernel before 2.6.38, when a certain Ethernet bridge configuration is used, allows local users to cause a denial of service (memory corruption and system crash) by sending IGMP packets to a local interface.",
  "repo": "torvalds/linux",
  "patch_hash": "6b0d6a9b4296fa16a28d10d416db7a770fc03287",
  "patch_info": {
    "commit_hash": "6b0d6a9b4296fa16a28d10d416db7a770fc03287",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287",
    "files": [
      "net/bridge/br_multicast.c"
    ],
    "message": "bridge: Fix mglist corruption that leads to memory corruption\n\nThe list mp->mglist is used to indicate whether a multicast group\nis active on the bridge interface itself as opposed to one of the\nconstituent interfaces in the bridge.\n\nUnfortunately the operation that adds the mp->mglist node to the\nlist neglected to check whether it has already been added.  This\nleads to list corruption in the form of nodes pointing to itself.\n\nNormally this would be quite obvious as it would cause an infinite\nloop when walking the list.  However, as this list is never actually\nwalked (which means that we don't really need it, I'll get rid of\nit in a subsequent patch), this instead is hidden until we perform\na delete operation on the affected nodes.\n\nAs the same node may now be pointed to by more than one node, the\ndelete operations can then cause modification of freed memory.\n\nThis was observed in practice to cause corruption in 512-byte slabs,\nmost commonly leading to crashes in jbd2.\n\nThanks to Josef Bacik for pointing me in the right direction.\n\nReported-by: Ian Page Hands <ihands@redhat.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
    ]
  },
  "patch_diff": {
    "net/bridge/br_multicast.c||net/bridge/br_multicast.c": [
      "File: net/bridge/br_multicast.c -> net/bridge/br_multicast.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "719:   goto err;",
      "721:  if (!port) {",
      "723:   mod_timer(&mp->timer, now + br->multicast_membership_interval);",
      "724:   goto out;",
      "725:  }",
      "",
      "[Removed Lines]",
      "722:   hlist_add_head(&mp->mglist, &br->mglist);",
      "",
      "[Added Lines]",
      "722:   if (hlist_unhashed(&mp->mglist))",
      "723:    hlist_add_head(&mp->mglist, &br->mglist);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8a870178c0ad1bae9994c99bd01eb10c9903e616",
      "candidate_info": {
        "commit_hash": "8a870178c0ad1bae9994c99bd01eb10c9903e616",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8a870178c0ad1bae9994c99bd01eb10c9903e616",
        "files": [
          "net/bridge/br_input.c",
          "net/bridge/br_multicast.c",
          "net/bridge/br_private.h"
        ],
        "message": "bridge: Replace mp->mglist hlist with a bool\n\nAs it turns out we never need to walk through the list of multicast\ngroups subscribed by the bridge interface itself (the only time we'd\nwant to do that is when we shut down the bridge, in which case we\nsimply walk through all multicast groups), we don't really need to\nkeep an hlist for mp->mglist.\n\nThis means that we can replace it with just a single bit to indicate\nwhether the bridge interface is subscribed to a group.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/bridge/br_input.c||net/bridge/br_input.c",
          "net/bridge/br_multicast.c||net/bridge/br_multicast.c",
          "net/bridge/br_private.h||net/bridge/br_private.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ],
          "candidate": [
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bridge/br_input.c||net/bridge/br_input.c": [
          "File: net/bridge/br_input.c -> net/bridge/br_input.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:  if (is_multicast_ether_addr(dest)) {",
          "81:   mdst = br_mdb_get(br, skb);",
          "82:   if (mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) {",
          "84:        br_multicast_is_router(br))",
          "85:     skb2 = skb;",
          "86:    br_multicast_forward(mdst, skb, skb2);",
          "",
          "[Removed Lines]",
          "83:    if ((mdst && !hlist_unhashed(&mdst->mglist)) ||",
          "",
          "[Added Lines]",
          "83:    if ((mdst && mdst->mglist) ||",
          "",
          "---------------"
        ],
        "net/bridge/br_multicast.c||net/bridge/br_multicast.c": [
          "File: net/bridge/br_multicast.c -> net/bridge/br_multicast.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:  if (!netif_running(br->dev) || timer_pending(&mp->timer))",
          "233:   goto out;",
          "238:  if (mp->ports)",
          "239:   goto out;",
          "",
          "[Removed Lines]",
          "235:  if (!hlist_unhashed(&mp->mglist))",
          "236:   hlist_del_init(&mp->mglist);",
          "",
          "[Added Lines]",
          "235:  mp->mglist = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "276:   del_timer(&p->query_timer);",
          "277:   call_rcu_bh(&p->rcu, br_multicast_free_pg);",
          "280:       netif_running(br->dev))",
          "281:    mod_timer(&mp->timer, jiffies);",
          "",
          "[Removed Lines]",
          "279:   if (!mp->ports && hlist_unhashed(&mp->mglist) &&",
          "",
          "[Added Lines]",
          "278:   if (!mp->ports && !mp->mglist &&",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "528:  struct net_bridge *br = mp->br;",
          "530:  spin_lock(&br->multicast_lock);",
          "532:      mp->queries_sent >= br->multicast_last_member_count)",
          "533:   goto out;",
          "",
          "[Removed Lines]",
          "531:  if (!netif_running(br->dev) || hlist_unhashed(&mp->mglist) ||",
          "",
          "[Added Lines]",
          "530:  if (!netif_running(br->dev) || !mp->mglist ||",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "719:   goto err;",
          "721:  if (!port) {",
          "724:   mod_timer(&mp->timer, now + br->multicast_membership_interval);",
          "725:   goto out;",
          "726:  }",
          "",
          "[Removed Lines]",
          "722:   if (hlist_unhashed(&mp->mglist))",
          "723:    hlist_add_head(&mp->mglist, &br->mglist);",
          "",
          "[Added Lines]",
          "721:   mp->mglist = true;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1167:  max_delay *= br->multicast_last_member_count;",
          "1170:      (timer_pending(&mp->timer) ?",
          "1171:       time_after(mp->timer.expires, now + max_delay) :",
          "1172:       try_to_del_timer_sync(&mp->timer) >= 0))",
          "",
          "[Removed Lines]",
          "1169:  if (!hlist_unhashed(&mp->mglist) &&",
          "",
          "[Added Lines]",
          "1167:  if (mp->mglist &&",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1237:   goto out;",
          "1239:  max_delay *= br->multicast_last_member_count;",
          "1241:      (timer_pending(&mp->timer) ?",
          "1242:       time_after(mp->timer.expires, now + max_delay) :",
          "1243:       try_to_del_timer_sync(&mp->timer) >= 0))",
          "",
          "[Removed Lines]",
          "1240:  if (!hlist_unhashed(&mp->mglist) &&",
          "",
          "[Added Lines]",
          "1238:  if (mp->mglist &&",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1284:        br->multicast_last_member_interval;",
          "1286:  if (!port) {",
          "1288:       (timer_pending(&mp->timer) ?",
          "1289:        time_after(mp->timer.expires, time) :",
          "1290:        try_to_del_timer_sync(&mp->timer) >= 0)) {",
          "",
          "[Removed Lines]",
          "1287:   if (!hlist_unhashed(&mp->mglist) &&",
          "",
          "[Added Lines]",
          "1285:   if (mp->mglist &&",
          "",
          "---------------"
        ],
        "net/bridge/br_private.h||net/bridge/br_private.h": [
          "File: net/bridge/br_private.h -> net/bridge/br_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "84: struct net_bridge_mdb_entry",
          "85: {",
          "86:  struct hlist_node  hlist[2];",
          "88:  struct net_bridge  *br;",
          "89:  struct net_bridge_port_group __rcu *ports;",
          "90:  struct rcu_head   rcu;",
          "91:  struct timer_list  timer;",
          "92:  struct timer_list  query_timer;",
          "93:  struct br_ip   addr;",
          "94:  u32    queries_sent;",
          "95: };",
          "",
          "[Removed Lines]",
          "87:  struct hlist_node  mglist;",
          "",
          "[Added Lines]",
          "93:  bool    mglist;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "238:  spinlock_t   multicast_lock;",
          "239:  struct net_bridge_mdb_htable __rcu *mdb;",
          "240:  struct hlist_head  router_list;",
          "243:  struct timer_list  multicast_router_timer;",
          "244:  struct timer_list  multicast_querier_timer;",
          "",
          "[Removed Lines]",
          "241:  struct hlist_head  mglist;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eb1d16414339a6e113d89e2cca2556005d7ce919",
      "candidate_info": {
        "commit_hash": "eb1d16414339a6e113d89e2cca2556005d7ce919",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/eb1d16414339a6e113d89e2cca2556005d7ce919",
        "files": [
          "net/bridge/Kconfig",
          "net/bridge/Makefile",
          "net/bridge/br_multicast.c",
          "net/bridge/br_private.h"
        ],
        "message": "bridge: Add core IGMP snooping support\n\nThis patch adds the core functionality of IGMP snooping support\nwithout actually hooking it up.  So this patch should be a no-op\nas far as the bridge's external behaviour is concerned.\n\nAll the new code and data is controlled by the Kconfig option\nBRIDGE_IGMP_SNOOPING.  A run-time toggle is also available.\n\nThe multicast switching is done using an hash table that is\nlockless on the read-side through RCU.  On the write-side the\nnew multicast_lock is used for all operations.  The hash table\nsupports dynamic growth/rehashing.\n\nThe hash table will be rehashed if any chain length exceeds a\npreset limit.  If rehashing does not reduce the maximum chain\nlength then snooping will be disabled.\n\nThese features may be added in future (in no particular order):\n\n* IGMPv3 source support\n* Non-querier router detection\n* IPv6\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/bridge/br_multicast.c||net/bridge/br_multicast.c",
          "net/bridge/br_private.h||net/bridge/br_private.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ],
          "candidate": [
            "net/bridge/br_multicast.c||net/bridge/br_multicast.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bridge/br_multicast.c||net/bridge/br_multicast.c": [
          "File: net/bridge/br_multicast.c -> net/bridge/br_multicast.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <linux/err.h>",
          "14: #include <linux/if_ether.h>",
          "15: #include <linux/igmp.h>",
          "16: #include <linux/jhash.h>",
          "17: #include <linux/kernel.h>",
          "18: #include <linux/netdevice.h>",
          "19: #include <linux/netfilter_bridge.h>",
          "20: #include <linux/random.h>",
          "21: #include <linux/rculist.h>",
          "22: #include <linux/skbuff.h>",
          "23: #include <linux/slab.h>",
          "24: #include <linux/timer.h>",
          "25: #include <net/ip.h>",
          "27: #include \"br_private.h\"",
          "29: static inline int br_ip_hash(struct net_bridge_mdb_htable *mdb, __be32 ip)",
          "30: {",
          "31:  return jhash_1word(mdb->secret, (u32)ip) & (mdb->max - 1);",
          "32: }",
          "34: static struct net_bridge_mdb_entry *__br_mdb_ip_get(",
          "35:  struct net_bridge_mdb_htable *mdb, __be32 dst, int hash)",
          "36: {",
          "37:  struct net_bridge_mdb_entry *mp;",
          "38:  struct hlist_node *p;",
          "40:  hlist_for_each_entry(mp, p, &mdb->mhash[hash], hlist[mdb->ver]) {",
          "41:   if (dst == mp->addr)",
          "42:    return mp;",
          "43:  }",
          "45:  return NULL;",
          "46: }",
          "48: static struct net_bridge_mdb_entry *br_mdb_ip_get(",
          "49:  struct net_bridge_mdb_htable *mdb, __be32 dst)",
          "50: {",
          "51:  return __br_mdb_ip_get(mdb, dst, br_ip_hash(mdb, dst));",
          "52: }",
          "54: struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,",
          "55:      struct sk_buff *skb)",
          "56: {",
          "57:  struct net_bridge_mdb_htable *mdb = br->mdb;",
          "59:  if (!mdb || br->multicast_disabled)",
          "60:   return NULL;",
          "62:  switch (skb->protocol) {",
          "63:  case htons(ETH_P_IP):",
          "64:   if (BR_INPUT_SKB_CB(skb)->igmp)",
          "65:    break;",
          "66:   return br_mdb_ip_get(mdb, ip_hdr(skb)->daddr);",
          "67:  }",
          "69:  return NULL;",
          "70: }",
          "72: static void br_mdb_free(struct rcu_head *head)",
          "73: {",
          "74:  struct net_bridge_mdb_htable *mdb =",
          "75:   container_of(head, struct net_bridge_mdb_htable, rcu);",
          "76:  struct net_bridge_mdb_htable *old = mdb->old;",
          "78:  mdb->old = NULL;",
          "79:  kfree(old->mhash);",
          "80:  kfree(old);",
          "81: }",
          "83: static int br_mdb_copy(struct net_bridge_mdb_htable *new,",
          "84:          struct net_bridge_mdb_htable *old,",
          "85:          int elasticity)",
          "86: {",
          "87:  struct net_bridge_mdb_entry *mp;",
          "88:  struct hlist_node *p;",
          "89:  int maxlen;",
          "90:  int len;",
          "91:  int i;",
          "93:  for (i = 0; i < old->max; i++)",
          "94:   hlist_for_each_entry(mp, p, &old->mhash[i], hlist[old->ver])",
          "95:    hlist_add_head(&mp->hlist[new->ver],",
          "96:            &new->mhash[br_ip_hash(new, mp->addr)]);",
          "98:  if (!elasticity)",
          "99:   return 0;",
          "101:  maxlen = 0;",
          "102:  for (i = 0; i < new->max; i++) {",
          "103:   len = 0;",
          "104:   hlist_for_each_entry(mp, p, &new->mhash[i], hlist[new->ver])",
          "105:    len++;",
          "106:   if (len > maxlen)",
          "107:    maxlen = len;",
          "108:  }",
          "110:  return maxlen > elasticity ? -EINVAL : 0;",
          "111: }",
          "113: static void br_multicast_free_pg(struct rcu_head *head)",
          "114: {",
          "115:  struct net_bridge_port_group *p =",
          "116:   container_of(head, struct net_bridge_port_group, rcu);",
          "118:  kfree(p);",
          "119: }",
          "121: static void br_multicast_free_group(struct rcu_head *head)",
          "122: {",
          "123:  struct net_bridge_mdb_entry *mp =",
          "124:   container_of(head, struct net_bridge_mdb_entry, rcu);",
          "126:  kfree(mp);",
          "127: }",
          "129: static void br_multicast_group_expired(unsigned long data)",
          "130: {",
          "131:  struct net_bridge_mdb_entry *mp = (void *)data;",
          "132:  struct net_bridge *br = mp->br;",
          "133:  struct net_bridge_mdb_htable *mdb;",
          "135:  spin_lock(&br->multicast_lock);",
          "136:  if (!netif_running(br->dev) || timer_pending(&mp->timer))",
          "137:   goto out;",
          "139:  if (!hlist_unhashed(&mp->mglist))",
          "140:   hlist_del_init(&mp->mglist);",
          "142:  if (mp->ports)",
          "143:   goto out;",
          "145:  mdb = br->mdb;",
          "146:  hlist_del_rcu(&mp->hlist[mdb->ver]);",
          "147:  mdb->size--;",
          "149:  del_timer(&mp->query_timer);",
          "150:  call_rcu_bh(&mp->rcu, br_multicast_free_group);",
          "152: out:",
          "153:  spin_unlock(&br->multicast_lock);",
          "154: }",
          "156: static void br_multicast_del_pg(struct net_bridge *br,",
          "157:     struct net_bridge_port_group *pg)",
          "158: {",
          "159:  struct net_bridge_mdb_htable *mdb = br->mdb;",
          "160:  struct net_bridge_mdb_entry *mp;",
          "161:  struct net_bridge_port_group *p;",
          "162:  struct net_bridge_port_group **pp;",
          "164:  mp = br_mdb_ip_get(mdb, pg->addr);",
          "165:  if (WARN_ON(!mp))",
          "166:   return;",
          "168:  for (pp = &mp->ports; (p = *pp); pp = &p->next) {",
          "169:   if (p != pg)",
          "170:    continue;",
          "173:   hlist_del_init(&p->mglist);",
          "174:   del_timer(&p->timer);",
          "175:   del_timer(&p->query_timer);",
          "176:   call_rcu_bh(&p->rcu, br_multicast_free_pg);",
          "178:   if (!mp->ports && hlist_unhashed(&mp->mglist) &&",
          "179:       netif_running(br->dev))",
          "180:    mod_timer(&mp->timer, jiffies);",
          "182:   return;",
          "183:  }",
          "185:  WARN_ON(1);",
          "186: }",
          "188: static void br_multicast_port_group_expired(unsigned long data)",
          "189: {",
          "190:  struct net_bridge_port_group *pg = (void *)data;",
          "191:  struct net_bridge *br = pg->port->br;",
          "193:  spin_lock(&br->multicast_lock);",
          "194:  if (!netif_running(br->dev) || timer_pending(&pg->timer) ||",
          "195:      hlist_unhashed(&pg->mglist))",
          "196:   goto out;",
          "198:  br_multicast_del_pg(br, pg);",
          "200: out:",
          "201:  spin_unlock(&br->multicast_lock);",
          "202: }",
          "204: static int br_mdb_rehash(struct net_bridge_mdb_htable **mdbp, int max,",
          "205:     int elasticity)",
          "206: {",
          "207:  struct net_bridge_mdb_htable *old = *mdbp;",
          "208:  struct net_bridge_mdb_htable *mdb;",
          "209:  int err;",
          "211:  mdb = kmalloc(sizeof(*mdb), GFP_ATOMIC);",
          "212:  if (!mdb)",
          "213:   return -ENOMEM;",
          "215:  mdb->max = max;",
          "216:  mdb->old = old;",
          "218:  mdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);",
          "219:  if (!mdb->mhash) {",
          "220:   kfree(mdb);",
          "221:   return -ENOMEM;",
          "222:  }",
          "224:  mdb->size = old ? old->size : 0;",
          "225:  mdb->ver = old ? old->ver ^ 1 : 0;",
          "227:  if (!old || elasticity)",
          "228:   get_random_bytes(&mdb->secret, sizeof(mdb->secret));",
          "229:  else",
          "230:   mdb->secret = old->secret;",
          "232:  if (!old)",
          "233:   goto out;",
          "235:  err = br_mdb_copy(mdb, old, elasticity);",
          "236:  if (err) {",
          "237:   kfree(mdb->mhash);",
          "238:   kfree(mdb);",
          "239:   return err;",
          "240:  }",
          "242:  call_rcu_bh(&mdb->rcu, br_mdb_free);",
          "244: out:",
          "245:  rcu_assign_pointer(*mdbp, mdb);",
          "247:  return 0;",
          "248: }",
          "250: static struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,",
          "251:       __be32 group)",
          "252: {",
          "253:  struct sk_buff *skb;",
          "254:  struct igmphdr *ih;",
          "255:  struct ethhdr *eth;",
          "256:  struct iphdr *iph;",
          "258:  skb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +",
          "259:        sizeof(*ih) + 4);",
          "260:  if (!skb)",
          "261:   goto out;",
          "263:  skb->protocol = htons(ETH_P_IP);",
          "265:  skb_reset_mac_header(skb);",
          "266:  eth = eth_hdr(skb);",
          "268:  memcpy(eth->h_source, br->dev->dev_addr, 6);",
          "269:  eth->h_dest[0] = 1;",
          "270:  eth->h_dest[1] = 0;",
          "271:  eth->h_dest[2] = 0x5e;",
          "272:  eth->h_dest[3] = 0;",
          "273:  eth->h_dest[4] = 0;",
          "274:  eth->h_dest[5] = 1;",
          "275:  eth->h_proto = htons(ETH_P_IP);",
          "276:  skb_put(skb, sizeof(*eth));",
          "278:  skb_set_network_header(skb, skb->len);",
          "279:  iph = ip_hdr(skb);",
          "281:  iph->version = 4;",
          "282:  iph->ihl = 6;",
          "283:  iph->tos = 0xc0;",
          "284:  iph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);",
          "285:  iph->id = 0;",
          "286:  iph->frag_off = htons(IP_DF);",
          "287:  iph->ttl = 1;",
          "288:  iph->protocol = IPPROTO_IGMP;",
          "289:  iph->saddr = 0;",
          "290:  iph->daddr = htonl(INADDR_ALLHOSTS_GROUP);",
          "291:  ((u8 *)&iph[1])[0] = IPOPT_RA;",
          "292:  ((u8 *)&iph[1])[1] = 4;",
          "293:  ((u8 *)&iph[1])[2] = 0;",
          "294:  ((u8 *)&iph[1])[3] = 0;",
          "295:  ip_send_check(iph);",
          "296:  skb_put(skb, 24);",
          "298:  skb_set_transport_header(skb, skb->len);",
          "299:  ih = igmp_hdr(skb);",
          "300:  ih->type = IGMP_HOST_MEMBERSHIP_QUERY;",
          "301:  ih->code = (group ? br->multicast_last_member_interval :",
          "302:        br->multicast_query_response_interval) /",
          "303:      (HZ / IGMP_TIMER_SCALE);",
          "304:  ih->group = group;",
          "305:  ih->csum = 0;",
          "306:  ih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));",
          "307:  skb_put(skb, sizeof(*ih));",
          "309:  __skb_pull(skb, sizeof(*eth));",
          "311: out:",
          "312:  return skb;",
          "313: }",
          "315: static void br_multicast_send_group_query(struct net_bridge_mdb_entry *mp)",
          "316: {",
          "317:  struct net_bridge *br = mp->br;",
          "318:  struct sk_buff *skb;",
          "320:  skb = br_multicast_alloc_query(br, mp->addr);",
          "321:  if (!skb)",
          "322:   goto timer;",
          "324:  netif_rx(skb);",
          "326: timer:",
          "327:  if (++mp->queries_sent < br->multicast_last_member_count)",
          "328:   mod_timer(&mp->query_timer,",
          "329:      jiffies + br->multicast_last_member_interval);",
          "330: }",
          "332: static void br_multicast_group_query_expired(unsigned long data)",
          "333: {",
          "334:  struct net_bridge_mdb_entry *mp = (void *)data;",
          "335:  struct net_bridge *br = mp->br;",
          "337:  spin_lock(&br->multicast_lock);",
          "338:  if (!netif_running(br->dev) || hlist_unhashed(&mp->mglist) ||",
          "339:      mp->queries_sent >= br->multicast_last_member_count)",
          "340:   goto out;",
          "342:  br_multicast_send_group_query(mp);",
          "344: out:",
          "345:  spin_unlock(&br->multicast_lock);",
          "346: }",
          "348: static void br_multicast_send_port_group_query(struct net_bridge_port_group *pg)",
          "349: {",
          "350:  struct net_bridge_port *port = pg->port;",
          "351:  struct net_bridge *br = port->br;",
          "352:  struct sk_buff *skb;",
          "354:  skb = br_multicast_alloc_query(br, pg->addr);",
          "355:  if (!skb)",
          "356:   goto timer;",
          "358:  br_deliver(port, skb);",
          "360: timer:",
          "361:  if (++pg->queries_sent < br->multicast_last_member_count)",
          "362:   mod_timer(&pg->query_timer,",
          "363:      jiffies + br->multicast_last_member_interval);",
          "364: }",
          "366: static void br_multicast_port_group_query_expired(unsigned long data)",
          "367: {",
          "368:  struct net_bridge_port_group *pg = (void *)data;",
          "369:  struct net_bridge_port *port = pg->port;",
          "370:  struct net_bridge *br = port->br;",
          "372:  spin_lock(&br->multicast_lock);",
          "373:  if (!netif_running(br->dev) || hlist_unhashed(&pg->mglist) ||",
          "374:      pg->queries_sent >= br->multicast_last_member_count)",
          "375:   goto out;",
          "377:  br_multicast_send_port_group_query(pg);",
          "379: out:",
          "380:  spin_unlock(&br->multicast_lock);",
          "381: }",
          "383: static struct net_bridge_mdb_entry *br_multicast_get_group(",
          "384:  struct net_bridge *br, struct net_bridge_port *port, __be32 group,",
          "385:  int hash)",
          "386: {",
          "387:  struct net_bridge_mdb_htable *mdb = br->mdb;",
          "388:  struct net_bridge_mdb_entry *mp;",
          "389:  struct hlist_node *p;",
          "390:  unsigned count = 0;",
          "391:  unsigned max;",
          "392:  int elasticity;",
          "393:  int err;",
          "395:  hlist_for_each_entry(mp, p, &mdb->mhash[hash], hlist[mdb->ver]) {",
          "396:   count++;",
          "397:   if (unlikely(group == mp->addr)) {",
          "398:    return mp;",
          "399:   }",
          "400:  }",
          "402:  elasticity = 0;",
          "403:  max = mdb->max;",
          "405:  if (unlikely(count > br->hash_elasticity && count)) {",
          "406:   if (net_ratelimit())",
          "407:    printk(KERN_INFO \"%s: Multicast hash table \"",
          "408:           \"chain limit reached: %s\\n\",",
          "409:           br->dev->name, port ? port->dev->name :",
          "410:            br->dev->name);",
          "412:   elasticity = br->hash_elasticity;",
          "413:  }",
          "415:  if (mdb->size >= max) {",
          "416:   max *= 2;",
          "417:   if (unlikely(max >= br->hash_max)) {",
          "418:    printk(KERN_WARNING \"%s: Multicast hash table maximum \"",
          "419:           \"reached, disabling snooping: %s, %d\\n\",",
          "420:           br->dev->name, port ? port->dev->name :",
          "421:            br->dev->name,",
          "422:           max);",
          "423:    err = -E2BIG;",
          "424: disable:",
          "425:    br->multicast_disabled = 1;",
          "426:    goto err;",
          "427:   }",
          "428:  }",
          "430:  if (max > mdb->max || elasticity) {",
          "431:   if (mdb->old) {",
          "432:    if (net_ratelimit())",
          "433:     printk(KERN_INFO \"%s: Multicast hash table \"",
          "434:            \"on fire: %s\\n\",",
          "435:            br->dev->name, port ? port->dev->name :",
          "436:             br->dev->name);",
          "437:    err = -EEXIST;",
          "438:    goto err;",
          "439:   }",
          "441:   err = br_mdb_rehash(&br->mdb, max, elasticity);",
          "442:   if (err) {",
          "443:    printk(KERN_WARNING \"%s: Cannot rehash multicast \"",
          "444:           \"hash table, disabling snooping: \"",
          "445:           \"%s, %d, %d\\n\",",
          "446:           br->dev->name, port ? port->dev->name :",
          "447:            br->dev->name,",
          "448:           mdb->size, err);",
          "449:    goto disable;",
          "450:   }",
          "452:   err = -EAGAIN;",
          "453:   goto err;",
          "454:  }",
          "456:  return NULL;",
          "458: err:",
          "459:  mp = ERR_PTR(err);",
          "460:  return mp;",
          "461: }",
          "463: static struct net_bridge_mdb_entry *br_multicast_new_group(",
          "464:  struct net_bridge *br, struct net_bridge_port *port, __be32 group)",
          "465: {",
          "466:  struct net_bridge_mdb_htable *mdb = br->mdb;",
          "467:  struct net_bridge_mdb_entry *mp;",
          "468:  int hash;",
          "470:  if (!mdb) {",
          "471:   if (br_mdb_rehash(&br->mdb, BR_HASH_SIZE, 0))",
          "472:    return NULL;",
          "473:   goto rehash;",
          "474:  }",
          "476:  hash = br_ip_hash(mdb, group);",
          "477:  mp = br_multicast_get_group(br, port, group, hash);",
          "478:  switch (PTR_ERR(mp)) {",
          "479:  case 0:",
          "480:   break;",
          "482:  case -EAGAIN:",
          "483: rehash:",
          "484:   mdb = br->mdb;",
          "485:   hash = br_ip_hash(mdb, group);",
          "486:   break;",
          "488:  default:",
          "489:   goto out;",
          "490:  }",
          "492:  mp = kzalloc(sizeof(*mp), GFP_ATOMIC);",
          "493:  if (unlikely(!mp))",
          "494:   goto out;",
          "496:  mp->br = br;",
          "497:  mp->addr = group;",
          "498:  setup_timer(&mp->timer, br_multicast_group_expired,",
          "499:       (unsigned long)mp);",
          "500:  setup_timer(&mp->query_timer, br_multicast_group_query_expired,",
          "501:       (unsigned long)mp);",
          "503:  hlist_add_head_rcu(&mp->hlist[mdb->ver], &mdb->mhash[hash]);",
          "504:  mdb->size++;",
          "506: out:",
          "507:  return mp;",
          "508: }",
          "510: static int br_multicast_add_group(struct net_bridge *br,",
          "511:       struct net_bridge_port *port, __be32 group)",
          "512: {",
          "513:  struct net_bridge_mdb_entry *mp;",
          "514:  struct net_bridge_port_group *p;",
          "515:  struct net_bridge_port_group **pp;",
          "516:  unsigned long now = jiffies;",
          "517:  int err;",
          "519:  if (ipv4_is_local_multicast(group))",
          "520:   return 0;",
          "522:  spin_lock(&br->multicast_lock);",
          "523:  if (!netif_running(br->dev) ||",
          "524:      (port && port->state == BR_STATE_DISABLED))",
          "525:   goto out;",
          "527:  mp = br_multicast_new_group(br, port, group);",
          "528:  err = PTR_ERR(mp);",
          "529:  if (unlikely(IS_ERR(mp) || !mp))",
          "530:   goto err;",
          "532:  if (!port) {",
          "533:   hlist_add_head(&mp->mglist, &br->mglist);",
          "534:   mod_timer(&mp->timer, now + br->multicast_membership_interval);",
          "535:   goto out;",
          "536:  }",
          "538:  for (pp = &mp->ports; (p = *pp); pp = &p->next) {",
          "539:   if (p->port == port)",
          "540:    goto found;",
          "541:   if ((unsigned long)p->port < (unsigned long)port)",
          "542:    break;",
          "543:  }",
          "545:  p = kzalloc(sizeof(*p), GFP_ATOMIC);",
          "546:  err = -ENOMEM;",
          "547:  if (unlikely(!p))",
          "548:   goto err;",
          "550:  p->addr = group;",
          "551:  p->port = port;",
          "552:  p->next = *pp;",
          "553:  hlist_add_head(&p->mglist, &port->mglist);",
          "554:  setup_timer(&p->timer, br_multicast_port_group_expired,",
          "555:       (unsigned long)p);",
          "556:  setup_timer(&p->query_timer, br_multicast_port_group_query_expired,",
          "557:       (unsigned long)p);",
          "559:  rcu_assign_pointer(*pp, p);",
          "561: found:",
          "562:  mod_timer(&p->timer, now + br->multicast_membership_interval);",
          "563: out:",
          "564:  err = 0;",
          "566: err:",
          "567:  spin_unlock(&br->multicast_lock);",
          "568:  return err;",
          "569: }",
          "571: static void br_multicast_router_expired(unsigned long data)",
          "572: {",
          "573:  struct net_bridge_port *port = (void *)data;",
          "574:  struct net_bridge *br = port->br;",
          "576:  spin_lock(&br->multicast_lock);",
          "577:  if (port->multicast_router != 1 ||",
          "578:      timer_pending(&port->multicast_router_timer) ||",
          "579:      hlist_unhashed(&port->rlist))",
          "580:   goto out;",
          "582:  hlist_del_init_rcu(&port->rlist);",
          "584: out:",
          "585:  spin_unlock(&br->multicast_lock);",
          "586: }",
          "588: static void br_multicast_local_router_expired(unsigned long data)",
          "589: {",
          "590: }",
          "592: static void br_multicast_send_query(struct net_bridge *br,",
          "593:         struct net_bridge_port *port, u32 sent)",
          "594: {",
          "595:  unsigned long time;",
          "596:  struct sk_buff *skb;",
          "598:  if (!netif_running(br->dev) || br->multicast_disabled ||",
          "599:      timer_pending(&br->multicast_querier_timer))",
          "600:   return;",
          "602:  skb = br_multicast_alloc_query(br, 0);",
          "603:  if (!skb)",
          "604:   goto timer;",
          "606:  if (port) {",
          "607:   __skb_push(skb, sizeof(struct ethhdr));",
          "608:   skb->dev = port->dev;",
          "609:   NF_HOOK(PF_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,",
          "610:    dev_queue_xmit);",
          "611:  } else",
          "612:   netif_rx(skb);",
          "614: timer:",
          "615:  time = jiffies;",
          "616:  time += sent < br->multicast_startup_query_count ?",
          "617:   br->multicast_startup_query_interval :",
          "618:   br->multicast_query_interval;",
          "619:  mod_timer(port ? &port->multicast_query_timer :",
          "620:     &br->multicast_query_timer, time);",
          "621: }",
          "623: static void br_multicast_port_query_expired(unsigned long data)",
          "624: {",
          "625:  struct net_bridge_port *port = (void *)data;",
          "626:  struct net_bridge *br = port->br;",
          "628:  spin_lock(&br->multicast_lock);",
          "629:  if (port && (port->state == BR_STATE_DISABLED ||",
          "630:        port->state == BR_STATE_BLOCKING))",
          "631:   goto out;",
          "633:  if (port->multicast_startup_queries_sent <",
          "634:      br->multicast_startup_query_count)",
          "635:   port->multicast_startup_queries_sent++;",
          "637:  br_multicast_send_query(port->br, port,",
          "638:     port->multicast_startup_queries_sent);",
          "640: out:",
          "641:  spin_unlock(&br->multicast_lock);",
          "642: }",
          "644: void br_multicast_add_port(struct net_bridge_port *port)",
          "645: {",
          "646:  port->multicast_router = 1;",
          "648:  setup_timer(&port->multicast_router_timer, br_multicast_router_expired,",
          "649:       (unsigned long)port);",
          "650:  setup_timer(&port->multicast_query_timer,",
          "651:       br_multicast_port_query_expired, (unsigned long)port);",
          "652: }",
          "654: void br_multicast_del_port(struct net_bridge_port *port)",
          "655: {",
          "656:  del_timer_sync(&port->multicast_router_timer);",
          "657: }",
          "659: void br_multicast_enable_port(struct net_bridge_port *port)",
          "660: {",
          "661:  struct net_bridge *br = port->br;",
          "663:  spin_lock(&br->multicast_lock);",
          "664:  if (br->multicast_disabled || !netif_running(br->dev))",
          "665:   goto out;",
          "667:  port->multicast_startup_queries_sent = 0;",
          "669:  if (try_to_del_timer_sync(&port->multicast_query_timer) >= 0 ||",
          "670:      del_timer(&port->multicast_query_timer))",
          "671:   mod_timer(&port->multicast_query_timer, jiffies);",
          "673: out:",
          "674:  spin_unlock(&br->multicast_lock);",
          "675: }",
          "677: void br_multicast_disable_port(struct net_bridge_port *port)",
          "678: {",
          "679:  struct net_bridge *br = port->br;",
          "680:  struct net_bridge_port_group *pg;",
          "681:  struct hlist_node *p, *n;",
          "683:  spin_lock(&br->multicast_lock);",
          "684:  hlist_for_each_entry_safe(pg, p, n, &port->mglist, mglist)",
          "685:   br_multicast_del_pg(br, pg);",
          "687:  if (!hlist_unhashed(&port->rlist))",
          "688:   hlist_del_init_rcu(&port->rlist);",
          "689:  del_timer(&port->multicast_router_timer);",
          "690:  del_timer(&port->multicast_query_timer);",
          "691:  spin_unlock(&br->multicast_lock);",
          "692: }",
          "694: static int br_multicast_igmp3_report(struct net_bridge *br,",
          "695:          struct net_bridge_port *port,",
          "696:          struct sk_buff *skb)",
          "697: {",
          "698:  struct igmpv3_report *ih;",
          "699:  struct igmpv3_grec *grec;",
          "700:  int i;",
          "701:  int len;",
          "702:  int num;",
          "703:  int type;",
          "704:  int err = 0;",
          "705:  __be32 group;",
          "707:  if (!pskb_may_pull(skb, sizeof(*ih)))",
          "708:   return -EINVAL;",
          "710:  ih = igmpv3_report_hdr(skb);",
          "711:  num = ntohs(ih->ngrec);",
          "712:  len = sizeof(*ih);",
          "714:  for (i = 0; i < num; i++) {",
          "715:   len += sizeof(*grec);",
          "716:   if (!pskb_may_pull(skb, len))",
          "717:    return -EINVAL;",
          "719:   grec = (void *)(skb->data + len);",
          "720:   group = grec->grec_mca;",
          "721:   type = grec->grec_type;",
          "723:   len += grec->grec_nsrcs * 4;",
          "724:   if (!pskb_may_pull(skb, len))",
          "725:    return -EINVAL;",
          "728:   switch (type) {",
          "729:   case IGMPV3_MODE_IS_INCLUDE:",
          "730:   case IGMPV3_MODE_IS_EXCLUDE:",
          "731:   case IGMPV3_CHANGE_TO_INCLUDE:",
          "732:   case IGMPV3_CHANGE_TO_EXCLUDE:",
          "733:   case IGMPV3_ALLOW_NEW_SOURCES:",
          "734:   case IGMPV3_BLOCK_OLD_SOURCES:",
          "735:    break;",
          "737:   default:",
          "738:    continue;",
          "739:   }",
          "741:   err = br_multicast_add_group(br, port, group);",
          "742:   if (err)",
          "743:    break;",
          "744:  }",
          "746:  return err;",
          "747: }",
          "749: static void br_multicast_mark_router(struct net_bridge *br,",
          "750:          struct net_bridge_port *port)",
          "751: {",
          "752:  unsigned long now = jiffies;",
          "753:  struct hlist_node *p;",
          "754:  struct hlist_node **h;",
          "756:  if (!port) {",
          "757:   if (br->multicast_router == 1)",
          "758:    mod_timer(&br->multicast_router_timer,",
          "759:       now + br->multicast_querier_interval);",
          "760:   return;",
          "761:  }",
          "763:  if (port->multicast_router != 1)",
          "764:   return;",
          "766:  if (!hlist_unhashed(&port->rlist))",
          "767:   goto timer;",
          "769:  for (h = &br->router_list.first;",
          "770:       (p = *h) &&",
          "771:       (unsigned long)container_of(p, struct net_bridge_port, rlist) >",
          "772:       (unsigned long)port;",
          "773:       h = &p->next)",
          "774:   ;",
          "776:  port->rlist.pprev = h;",
          "777:  port->rlist.next = p;",
          "778:  rcu_assign_pointer(*h, &port->rlist);",
          "779:  if (p)",
          "780:   p->pprev = &port->rlist.next;",
          "782: timer:",
          "783:  mod_timer(&port->multicast_router_timer,",
          "784:     now + br->multicast_querier_interval);",
          "785: }",
          "787: static void br_multicast_query_received(struct net_bridge *br,",
          "788:      struct net_bridge_port *port,",
          "789:      __be32 saddr)",
          "790: {",
          "791:  if (saddr)",
          "792:   mod_timer(&br->multicast_querier_timer,",
          "793:      jiffies + br->multicast_querier_interval);",
          "794:  else if (timer_pending(&br->multicast_querier_timer))",
          "795:   return;",
          "797:  br_multicast_mark_router(br, port);",
          "798: }",
          "800: static int br_multicast_query(struct net_bridge *br,",
          "801:          struct net_bridge_port *port,",
          "802:          struct sk_buff *skb)",
          "803: {",
          "804:  struct iphdr *iph = ip_hdr(skb);",
          "805:  struct igmphdr *ih = igmp_hdr(skb);",
          "806:  struct net_bridge_mdb_entry *mp;",
          "807:  struct igmpv3_query *ih3;",
          "808:  struct net_bridge_port_group *p;",
          "809:  struct net_bridge_port_group **pp;",
          "810:  unsigned long max_delay;",
          "811:  unsigned long now = jiffies;",
          "812:  __be32 group;",
          "814:  spin_lock(&br->multicast_lock);",
          "815:  if (!netif_running(br->dev) ||",
          "816:      (port && port->state == BR_STATE_DISABLED))",
          "817:   goto out;",
          "819:  br_multicast_query_received(br, port, iph->saddr);",
          "821:  group = ih->group;",
          "823:  if (skb->len == sizeof(*ih)) {",
          "824:   max_delay = ih->code * (HZ / IGMP_TIMER_SCALE);",
          "826:   if (!max_delay) {",
          "827:    max_delay = 10 * HZ;",
          "828:    group = 0;",
          "829:   }",
          "830:  } else {",
          "831:   if (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))",
          "832:    return -EINVAL;",
          "834:   ih3 = igmpv3_query_hdr(skb);",
          "835:   if (ih3->nsrcs)",
          "836:    return 0;",
          "838:   max_delay = ih3->code ? 1 :",
          "839:        IGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE);",
          "840:  }",
          "842:  if (!group)",
          "843:   goto out;",
          "845:  mp = br_mdb_ip_get(br->mdb, group);",
          "846:  if (!mp)",
          "847:   goto out;",
          "849:  max_delay *= br->multicast_last_member_count;",
          "851:  if (!hlist_unhashed(&mp->mglist) &&",
          "852:      (timer_pending(&mp->timer) ?",
          "853:       time_after(mp->timer.expires, now + max_delay) :",
          "854:       try_to_del_timer_sync(&mp->timer) >= 0))",
          "855:   mod_timer(&mp->timer, now + max_delay);",
          "857:  for (pp = &mp->ports; (p = *pp); pp = &p->next) {",
          "858:   if (timer_pending(&p->timer) ?",
          "859:       time_after(p->timer.expires, now + max_delay) :",
          "860:       try_to_del_timer_sync(&p->timer) >= 0)",
          "861:    mod_timer(&mp->timer, now + max_delay);",
          "862:  }",
          "864: out:",
          "865:  spin_unlock(&br->multicast_lock);",
          "866:  return 0;",
          "867: }",
          "869: static void br_multicast_leave_group(struct net_bridge *br,",
          "870:          struct net_bridge_port *port,",
          "871:          __be32 group)",
          "872: {",
          "873:  struct net_bridge_mdb_htable *mdb;",
          "874:  struct net_bridge_mdb_entry *mp;",
          "875:  struct net_bridge_port_group *p;",
          "876:  unsigned long now;",
          "877:  unsigned long time;",
          "879:  if (ipv4_is_local_multicast(group))",
          "880:   return;",
          "882:  spin_lock(&br->multicast_lock);",
          "883:  if (!netif_running(br->dev) ||",
          "884:      (port && port->state == BR_STATE_DISABLED) ||",
          "885:      timer_pending(&br->multicast_querier_timer))",
          "886:   goto out;",
          "888:  mdb = br->mdb;",
          "889:  mp = br_mdb_ip_get(mdb, group);",
          "890:  if (!mp)",
          "891:   goto out;",
          "893:  now = jiffies;",
          "894:  time = now + br->multicast_last_member_count *",
          "895:        br->multicast_last_member_interval;",
          "897:  if (!port) {",
          "898:   if (!hlist_unhashed(&mp->mglist) &&",
          "899:       (timer_pending(&mp->timer) ?",
          "900:        time_after(mp->timer.expires, time) :",
          "901:        try_to_del_timer_sync(&mp->timer) >= 0)) {",
          "902:    mod_timer(&mp->timer, time);",
          "904:    mp->queries_sent = 0;",
          "905:    mod_timer(&mp->query_timer, now);",
          "906:   }",
          "908:   goto out;",
          "909:  }",
          "911:  for (p = mp->ports; p; p = p->next) {",
          "912:   if (p->port != port)",
          "913:    continue;",
          "915:   if (!hlist_unhashed(&p->mglist) &&",
          "916:       (timer_pending(&p->timer) ?",
          "917:        time_after(p->timer.expires, time) :",
          "918:        try_to_del_timer_sync(&p->timer) >= 0)) {",
          "919:    mod_timer(&p->timer, time);",
          "921:    p->queries_sent = 0;",
          "922:    mod_timer(&p->query_timer, now);",
          "923:   }",
          "925:   break;",
          "926:  }",
          "928: out:",
          "929:  spin_unlock(&br->multicast_lock);",
          "930: }",
          "932: static int br_multicast_ipv4_rcv(struct net_bridge *br,",
          "933:      struct net_bridge_port *port,",
          "934:      struct sk_buff *skb)",
          "935: {",
          "936:  struct sk_buff *skb2 = skb;",
          "937:  struct iphdr *iph;",
          "938:  struct igmphdr *ih;",
          "939:  unsigned len;",
          "940:  unsigned offset;",
          "941:  int err;",
          "943:  BR_INPUT_SKB_CB(skb)->igmp = 0;",
          "944:  BR_INPUT_SKB_CB(skb)->mrouters_only = 0;",
          "947:  if (!pskb_may_pull(skb, sizeof(*iph)))",
          "948:   return -EINVAL;",
          "950:  iph = ip_hdr(skb);",
          "952:  if (iph->ihl < 5 || iph->version != 4)",
          "953:   return -EINVAL;",
          "955:  if (!pskb_may_pull(skb, ip_hdrlen(skb)))",
          "956:   return -EINVAL;",
          "958:  iph = ip_hdr(skb);",
          "960:  if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))",
          "961:   return -EINVAL;",
          "963:  if (iph->protocol != IPPROTO_IGMP)",
          "964:   return 0;",
          "966:  len = ntohs(iph->tot_len);",
          "967:  if (skb->len < len || len < ip_hdrlen(skb))",
          "968:   return -EINVAL;",
          "970:  if (skb->len > len) {",
          "971:   skb2 = skb_clone(skb, GFP_ATOMIC);",
          "972:   if (!skb2)",
          "973:    return -ENOMEM;",
          "975:   err = pskb_trim_rcsum(skb2, len);",
          "976:   if (err)",
          "977:    return err;",
          "978:  }",
          "980:  len -= ip_hdrlen(skb2);",
          "981:  offset = skb_network_offset(skb2) + ip_hdrlen(skb2);",
          "982:  __skb_pull(skb2, offset);",
          "983:  skb_reset_transport_header(skb2);",
          "985:  err = -EINVAL;",
          "986:  if (!pskb_may_pull(skb2, sizeof(*ih)))",
          "987:   goto out;",
          "989:  iph = ip_hdr(skb2);",
          "991:  switch (skb2->ip_summed) {",
          "992:  case CHECKSUM_COMPLETE:",
          "993:   if (!csum_fold(skb2->csum))",
          "994:    break;",
          "996:  case CHECKSUM_NONE:",
          "997:   skb2->csum = 0;",
          "998:   if (skb_checksum_complete(skb2))",
          "999:    return -EINVAL;",
          "1000:  }",
          "1002:  err = 0;",
          "1004:  BR_INPUT_SKB_CB(skb)->igmp = 1;",
          "1005:  ih = igmp_hdr(skb2);",
          "1007:  switch (ih->type) {",
          "1008:  case IGMP_HOST_MEMBERSHIP_REPORT:",
          "1009:  case IGMPV2_HOST_MEMBERSHIP_REPORT:",
          "1010:   BR_INPUT_SKB_CB(skb2)->mrouters_only = 1;",
          "1011:   err = br_multicast_add_group(br, port, ih->group);",
          "1012:   break;",
          "1013:  case IGMPV3_HOST_MEMBERSHIP_REPORT:",
          "1014:   err = br_multicast_igmp3_report(br, port, skb2);",
          "1015:   break;",
          "1016:  case IGMP_HOST_MEMBERSHIP_QUERY:",
          "1017:   err = br_multicast_query(br, port, skb2);",
          "1018:   break;",
          "1019:  case IGMP_HOST_LEAVE_MESSAGE:",
          "1020:   br_multicast_leave_group(br, port, ih->group);",
          "1021:   break;",
          "1022:  }",
          "1024: out:",
          "1025:  __skb_push(skb2, offset);",
          "1026:  if (skb2 != skb)",
          "1027:   kfree_skb(skb2);",
          "1028:  return err;",
          "1029: }",
          "1031: int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,",
          "1032:        struct sk_buff *skb)",
          "1033: {",
          "1034:  if (br->multicast_disabled)",
          "1035:   return 0;",
          "1037:  switch (skb->protocol) {",
          "1038:  case htons(ETH_P_IP):",
          "1039:   return br_multicast_ipv4_rcv(br, port, skb);",
          "1040:  }",
          "1042:  return 0;",
          "1043: }",
          "1045: static void br_multicast_query_expired(unsigned long data)",
          "1046: {",
          "1047:  struct net_bridge *br = (void *)data;",
          "1049:  spin_lock(&br->multicast_lock);",
          "1050:  if (br->multicast_startup_queries_sent <",
          "1051:      br->multicast_startup_query_count)",
          "1052:   br->multicast_startup_queries_sent++;",
          "1054:  br_multicast_send_query(br, NULL, br->multicast_startup_queries_sent);",
          "1056:  spin_unlock(&br->multicast_lock);",
          "1057: }",
          "1059: void br_multicast_init(struct net_bridge *br)",
          "1060: {",
          "1061:  br->hash_elasticity = 4;",
          "1062:  br->hash_max = 512;",
          "1064:  br->multicast_router = 1;",
          "1065:  br->multicast_last_member_count = 2;",
          "1066:  br->multicast_startup_query_count = 2;",
          "1068:  br->multicast_last_member_interval = HZ;",
          "1069:  br->multicast_query_response_interval = 10 * HZ;",
          "1070:  br->multicast_startup_query_interval = 125 * HZ / 4;",
          "1071:  br->multicast_query_interval = 125 * HZ;",
          "1072:  br->multicast_querier_interval = 255 * HZ;",
          "1073:  br->multicast_membership_interval = 260 * HZ;",
          "1075:  spin_lock_init(&br->multicast_lock);",
          "1076:  setup_timer(&br->multicast_router_timer,",
          "1077:       br_multicast_local_router_expired, 0);",
          "1078:  setup_timer(&br->multicast_querier_timer,",
          "1079:       br_multicast_local_router_expired, 0);",
          "1080:  setup_timer(&br->multicast_query_timer, br_multicast_query_expired,",
          "1081:       (unsigned long)br);",
          "1082: }",
          "1084: void br_multicast_open(struct net_bridge *br)",
          "1085: {",
          "1086:  br->multicast_startup_queries_sent = 0;",
          "1088:  if (br->multicast_disabled)",
          "1089:   return;",
          "1091:  mod_timer(&br->multicast_query_timer, jiffies);",
          "1092: }",
          "1094: void br_multicast_stop(struct net_bridge *br)",
          "1095: {",
          "1096:  struct net_bridge_mdb_htable *mdb;",
          "1097:  struct net_bridge_mdb_entry *mp;",
          "1098:  struct hlist_node *p, *n;",
          "1099:  u32 ver;",
          "1100:  int i;",
          "1102:  del_timer_sync(&br->multicast_router_timer);",
          "1103:  del_timer_sync(&br->multicast_querier_timer);",
          "1104:  del_timer_sync(&br->multicast_query_timer);",
          "1106:  spin_lock_bh(&br->multicast_lock);",
          "1107:  mdb = br->mdb;",
          "1108:  if (!mdb)",
          "1109:   goto out;",
          "1111:  br->mdb = NULL;",
          "1113:  ver = mdb->ver;",
          "1114:  for (i = 0; i < mdb->max; i++) {",
          "1115:   hlist_for_each_entry_safe(mp, p, n, &mdb->mhash[i],",
          "1116:        hlist[ver]) {",
          "1117:    del_timer(&mp->timer);",
          "1118:    del_timer(&mp->query_timer);",
          "1119:    call_rcu_bh(&mp->rcu, br_multicast_free_group);",
          "1120:   }",
          "1121:  }",
          "1123:  if (mdb->old) {",
          "1124:   spin_unlock_bh(&br->multicast_lock);",
          "1125:   synchronize_rcu_bh();",
          "1126:   spin_lock_bh(&br->multicast_lock);",
          "1127:   WARN_ON(mdb->old);",
          "1128:  }",
          "1130:  mdb->old = mdb;",
          "1131:  call_rcu_bh(&mdb->rcu, br_mdb_free);",
          "1133: out:",
          "1134:  spin_unlock_bh(&br->multicast_lock);",
          "1135: }",
          "",
          "---------------"
        ],
        "net/bridge/br_private.h||net/bridge/br_private.h": [
          "File: net/bridge/br_private.h -> net/bridge/br_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:  unsigned char   is_static;",
          "58: };",
          "60: struct net_bridge_port",
          "61: {",
          "62:  struct net_bridge  *br;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60: struct net_bridge_port_group {",
          "61:  struct net_bridge_port  *port;",
          "62:  struct net_bridge_port_group *next;",
          "63:  struct hlist_node  mglist;",
          "64:  struct rcu_head   rcu;",
          "65:  struct timer_list  timer;",
          "66:  struct timer_list  query_timer;",
          "67:  __be32    addr;",
          "68:  u32    queries_sent;",
          "69: };",
          "71: struct net_bridge_mdb_entry",
          "72: {",
          "73:  struct hlist_node  hlist[2];",
          "74:  struct hlist_node  mglist;",
          "75:  struct net_bridge  *br;",
          "76:  struct net_bridge_port_group *ports;",
          "77:  struct rcu_head   rcu;",
          "78:  struct timer_list  timer;",
          "79:  struct timer_list  query_timer;",
          "80:  __be32    addr;",
          "81:  u32    queries_sent;",
          "82: };",
          "84: struct net_bridge_mdb_htable",
          "85: {",
          "86:  struct hlist_head  *mhash;",
          "87:  struct rcu_head   rcu;",
          "88:  struct net_bridge_mdb_htable *old;",
          "89:  u32    size;",
          "90:  u32    max;",
          "91:  u32    secret;",
          "92:  u32    ver;",
          "93: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:  unsigned long    flags;",
          "86: #define BR_HAIRPIN_MODE  0x00000001",
          "87: };",
          "89: struct net_bridge",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "123: #ifdef CONFIG_BRIDGE_IGMP_SNOOPING",
          "124:  u32    multicast_startup_queries_sent;",
          "125:  unsigned char   multicast_router;",
          "126:  struct timer_list  multicast_router_timer;",
          "127:  struct timer_list  multicast_query_timer;",
          "128:  struct hlist_head  mglist;",
          "129:  struct hlist_node  rlist;",
          "130: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "124:  unsigned char   topology_change;",
          "125:  unsigned char   topology_change_detected;",
          "127:  struct timer_list  hello_timer;",
          "128:  struct timer_list  tcn_timer;",
          "129:  struct timer_list  topology_change_timer;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171: #ifdef CONFIG_BRIDGE_IGMP_SNOOPING",
          "172:  unsigned char   multicast_router;",
          "174:  u8    multicast_disabled:1;",
          "176:  u32    hash_elasticity;",
          "177:  u32    hash_max;",
          "179:  u32    multicast_last_member_count;",
          "180:  u32    multicast_startup_queries_sent;",
          "181:  u32    multicast_startup_query_count;",
          "183:  unsigned long   multicast_last_member_interval;",
          "184:  unsigned long   multicast_membership_interval;",
          "185:  unsigned long   multicast_querier_interval;",
          "186:  unsigned long   multicast_query_interval;",
          "187:  unsigned long   multicast_query_response_interval;",
          "188:  unsigned long   multicast_startup_query_interval;",
          "190:  spinlock_t   multicast_lock;",
          "191:  struct net_bridge_mdb_htable *mdb;",
          "192:  struct hlist_head  router_list;",
          "193:  struct hlist_head  mglist;",
          "195:  struct timer_list  multicast_router_timer;",
          "196:  struct timer_list  multicast_querier_timer;",
          "197:  struct timer_list  multicast_query_timer;",
          "198: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "134: struct br_input_skb_cb {",
          "135:  struct net_device *brdev;",
          "136: };",
          "138: #define BR_INPUT_SKB_CB(__skb) ((struct br_input_skb_cb *)(__skb)->cb)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209:  int igmp;",
          "210:  int mrouters_only;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "204: extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);",
          "205: extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *arg);",
          "208: #ifdef CONFIG_BRIDGE_NETFILTER",
          "209: extern int br_netfilter_init(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283: #ifdef CONFIG_BRIDGE_IGMP_SNOOPING",
          "284: extern int br_multicast_rcv(struct net_bridge *br,",
          "285:        struct net_bridge_port *port,",
          "286:        struct sk_buff *skb);",
          "287: extern struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,",
          "288:             struct sk_buff *skb);",
          "289: extern void br_multicast_add_port(struct net_bridge_port *port);",
          "290: extern void br_multicast_del_port(struct net_bridge_port *port);",
          "291: extern void br_multicast_enable_port(struct net_bridge_port *port);",
          "292: extern void br_multicast_disable_port(struct net_bridge_port *port);",
          "293: extern void br_multicast_init(struct net_bridge *br);",
          "294: extern void br_multicast_open(struct net_bridge *br);",
          "295: extern void br_multicast_stop(struct net_bridge *br);",
          "296: #else",
          "297: static inline int br_multicast_rcv(struct net_bridge *br,",
          "298:        struct net_bridge_port *port,",
          "299:        struct sk_buff *skb)",
          "300: {",
          "301:  return 0;",
          "302: }",
          "304: static inline struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,",
          "305:             struct sk_buff *skb)",
          "306: {",
          "307:  return NULL;",
          "308: }",
          "310: static inline void br_multicast_add_port(struct net_bridge_port *port)",
          "311: {",
          "312: }",
          "314: static inline void br_multicast_del_port(struct net_bridge_port *port)",
          "315: {",
          "316: }",
          "318: static inline void br_multicast_enable_port(struct net_bridge_port *port)",
          "319: {",
          "320: }",
          "322: static inline void br_multicast_disable_port(struct net_bridge_port *port)",
          "323: {",
          "324: }",
          "326: static inline void br_multicast_init(struct net_bridge *br)",
          "327: {",
          "328: }",
          "330: static inline void br_multicast_open(struct net_bridge *br)",
          "331: {",
          "332: }",
          "334: static inline void br_multicast_stop(struct net_bridge *br)",
          "335: {",
          "336: }",
          "337: #endif",
          "339: static inline bool br_multicast_is_router(struct net_bridge *br)",
          "340: {",
          "341:  return br->multicast_router == 2 ||",
          "342:         (br->multicast_router == 1 &&",
          "343:   timer_pending(&br->multicast_router_timer));",
          "344: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
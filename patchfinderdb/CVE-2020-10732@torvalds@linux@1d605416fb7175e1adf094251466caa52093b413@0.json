{
  "cve_id": "CVE-2020-10732",
  "cve_desc": "A flaw was found in the Linux kernel's implementation of Userspace core dumps. This flaw allows an attacker with a local account to crash a trivial program and exfiltrate private kernel data.",
  "repo": "torvalds/linux",
  "patch_hash": "1d605416fb7175e1adf094251466caa52093b413",
  "patch_info": {
    "commit_hash": "1d605416fb7175e1adf094251466caa52093b413",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1d605416fb7175e1adf094251466caa52093b413",
    "files": [
      "fs/binfmt_elf.c"
    ],
    "message": "fs/binfmt_elf.c: allocate initialized memory in fill_thread_core_info()\n\nKMSAN reported uninitialized data being written to disk when dumping\ncore.  As a result, several kilobytes of kmalloc memory may be written\nto the core file and then read by a non-privileged user.\n\nReported-by: sam <sunhaoyl@outlook.com>\nSigned-off-by: Alexander Potapenko <glider@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nAcked-by: Kees Cook <keescook@chromium.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: <stable@vger.kernel.org>\nLink: http://lkml.kernel.org/r/20200419100848.63472-1-glider@google.com\nLink: https://github.com/google/kmsan/issues/76\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "fs/binfmt_elf.c||fs/binfmt_elf.c"
    ]
  },
  "patch_diff": {
    "fs/binfmt_elf.c||fs/binfmt_elf.c": [
      "File: fs/binfmt_elf.c -> fs/binfmt_elf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1733:       (!regset->active || regset->active(t->task, regset) > 0)) {",
      "1734:    int ret;",
      "1735:    size_t size = regset_size(t->task, regset);",
      "1737:    if (unlikely(!data))",
      "1738:     return 0;",
      "1739:    ret = regset->get(t->task, regset,",
      "",
      "[Removed Lines]",
      "1736:    void *data = kmalloc(size, GFP_KERNEL);",
      "",
      "[Added Lines]",
      "1736:    void *data = kzalloc(size, GFP_KERNEL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b4e9c9549f62329d2412f899635fddc5212b9cd4",
      "candidate_info": {
        "commit_hash": "b4e9c9549f62329d2412f899635fddc5212b9cd4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b4e9c9549f62329d2412f899635fddc5212b9cd4",
        "files": [
          "fs/binfmt_elf.c",
          "include/linux/regset.h",
          "kernel/Makefile",
          "kernel/regset.c"
        ],
        "message": "introduction of regset ->get() wrappers, switching ELF coredumps to those\n\nTwo new helpers: given a process and regset, dump into a buffer.\nregset_get() takes a buffer and size, regset_get_alloc() takes size\nand allocates a buffer.\n\nReturn value in both cases is the amount of data actually dumped in\ncase of success or -E...  on error.\n\nIn both cases the size is capped by regset->n * regset->size, so\n->get() is called with offset 0 and size no more than what regset\nexpects.\n\nbinfmt_elf.c callers of ->get() are switched to using those; the other\ncaller (copy_regset_to_user()) will need some preparations to switch.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/binfmt_elf.c||fs/binfmt_elf.c",
          "include/linux/regset.h||include/linux/regset.h",
          "kernel/regset.c||kernel/regset.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/binfmt_elf.c||fs/binfmt_elf.c"
          ],
          "candidate": [
            "fs/binfmt_elf.c||fs/binfmt_elf.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/binfmt_elf.c||fs/binfmt_elf.c": [
          "File: fs/binfmt_elf.c -> fs/binfmt_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1821:      long signr, size_t *total)",
          "1822: {",
          "1823:  unsigned int i;",
          "",
          "[Removed Lines]",
          "1824:  unsigned int regset0_size = regset_size(t->task, &view->regsets[0]);",
          "",
          "[Added Lines]",
          "1824:  int regset0_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1832:  fill_prstatus(&t->prstatus, t->task, signr);",
          "1836:  fill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,",
          "1837:     PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);",
          "",
          "[Removed Lines]",
          "1833:  (void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,",
          "1834:         &t->prstatus.pr_reg, NULL);",
          "",
          "[Added Lines]",
          "1833:  regset0_size = regset_get(t->task, &view->regsets[0],",
          "1834:      sizeof(t->prstatus.pr_reg), &t->prstatus.pr_reg);",
          "1835:  if (regset0_size < 0)",
          "1836:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1847:  for (i = 1; i < view->n; ++i) {",
          "1848:   const struct user_regset *regset = &view->regsets[i];",
          "1849:   do_thread_regset_writeback(t->task, regset);",
          "1875:  }",
          "1877:  return 1;",
          "",
          "[Removed Lines]",
          "1850:   if (regset->core_note_type && regset->get &&",
          "1851:       (!regset->active || regset->active(t->task, regset) > 0)) {",
          "1852:    int ret;",
          "1853:    size_t size = regset_size(t->task, regset);",
          "1854:    void *data = kzalloc(size, GFP_KERNEL);",
          "1855:    if (unlikely(!data))",
          "1856:     return 0;",
          "1857:    ret = regset->get(t->task, regset,",
          "1858:        0, size, data, NULL);",
          "1859:    if (unlikely(ret))",
          "1860:     kfree(data);",
          "1861:    else {",
          "1862:     if (regset->core_note_type != NT_PRFPREG)",
          "1863:      fill_note(&t->notes[i], \"LINUX\",",
          "1864:         regset->core_note_type,",
          "1865:         size, data);",
          "1866:     else {",
          "1867:      SET_PR_FPVALID(&t->prstatus,",
          "1868:        1, regset0_size);",
          "1869:      fill_note(&t->notes[i], \"CORE\",",
          "1870:         NT_PRFPREG, size, data);",
          "1871:     }",
          "1873:    }",
          "1874:   }",
          "",
          "[Added Lines]",
          "1851:   int note_type = regset->core_note_type;",
          "1852:   bool is_fpreg = note_type == NT_PRFPREG;",
          "1853:   void *data;",
          "1854:   int ret;",
          "1857:   if (!note_type) // not for coredumps",
          "1858:    continue;",
          "1859:   if (regset->active && regset->active(t->task, regset) <= 0)",
          "1860:    continue;",
          "1862:   ret = regset_get_alloc(t->task, regset, ~0U, &data);",
          "1863:   if (ret < 0)",
          "1864:    continue;",
          "1866:   if (is_fpreg)",
          "1867:    SET_PR_FPVALID(&t->prstatus, 1, regset0_size);",
          "1869:   fill_note(&t->notes[i], is_fpreg ? \"CORE\" : \"LINUX\",",
          "1870:      note_type, ret, data);",
          "",
          "---------------"
        ],
        "include/linux/regset.h||include/linux/regset.h": [
          "File: include/linux/regset.h -> include/linux/regset.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "353:  return 0;",
          "354: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "356: extern int regset_get(struct task_struct *target,",
          "357:         const struct user_regset *regset,",
          "358:         unsigned int size, void *data);",
          "360: extern int regset_get_alloc(struct task_struct *target,",
          "361:        const struct user_regset *regset,",
          "362:        unsigned int size,",
          "363:        void **data);",
          "",
          "---------------"
        ],
        "kernel/regset.c||kernel/regset.c": [
          "File: kernel/regset.c -> kernel/regset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include <linux/export.h>",
          "3: #include <linux/slab.h>",
          "4: #include <linux/regset.h>",
          "6: static int __regset_get(struct task_struct *target,",
          "7:    const struct user_regset *regset,",
          "8:    unsigned int size,",
          "9:    void **data)",
          "10: {",
          "11:  void *p = *data, *to_free = NULL;",
          "12:  int res;",
          "14:  if (!regset->get)",
          "15:   return -EOPNOTSUPP;",
          "16:  if (size > regset->n * regset->size)",
          "17:   size = regset->n * regset->size;",
          "18:  if (!p) {",
          "19:   to_free = p = kzalloc(size, GFP_KERNEL);",
          "20:   if (!p)",
          "21:    return -ENOMEM;",
          "22:  }",
          "23:  res = regset->get(target, regset, 0, size, p, NULL);",
          "24:  if (unlikely(res < 0)) {",
          "25:   kfree(to_free);",
          "26:   return res;",
          "27:  }",
          "29:  if (regset->get_size) { // arm64-only kludge, will go away",
          "30:   unsigned max_size = regset->get_size(target, regset);",
          "31:   if (size > max_size)",
          "32:    size = max_size;",
          "33:  }",
          "34:  return size;",
          "35: }",
          "37: int regset_get(struct task_struct *target,",
          "38:         const struct user_regset *regset,",
          "39:         unsigned int size,",
          "40:         void *data)",
          "41: {",
          "42:  return __regset_get(target, regset, size, &data);",
          "43: }",
          "44: EXPORT_SYMBOL(regset_get);",
          "46: int regset_get_alloc(struct task_struct *target,",
          "47:        const struct user_regset *regset,",
          "48:        unsigned int size,",
          "49:        void **data)",
          "50: {",
          "52:  return __regset_get(target, regset, size, data);",
          "53: }",
          "54: EXPORT_SYMBOL(regset_get_alloc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8a00dd0012f383fc0c39b169b694dc15236cec7c",
      "candidate_info": {
        "commit_hash": "8a00dd0012f383fc0c39b169b694dc15236cec7c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8a00dd0012f383fc0c39b169b694dc15236cec7c",
        "files": [
          "arch/x86/include/asm/compat.h",
          "fs/binfmt_elf.c",
          "fs/compat_binfmt_elf.c"
        ],
        "message": "binfmt_elf: partially sanitize PRSTATUS_SIZE and SET_PR_FPVALID\n\nOn 64bit architectures that support 32bit processes there are\ntwo possible layouts for NT_PRSTATUS note in ELF coredumps.\nFor one thing, several fields are 64bit for native processes\nand 32bit for compat ones (pr_sigpend, etc.).  For another,\nthe register dump is obviously different - the size and number\nof registers are not going to be the same for 32bit and 64bit\nvariants of processor.\n\nUsually that's handled by having two structures - elf_prstatus\nfor native layout and compat_elf_prstatus for 32bit one.\n32bit processes are handled by fs/compat_binfmt_elf.c, which\ndefines a macro called 'elf_prstatus' that expands to compat_elf_prstatus.\nThen it includes fs/binfmt_elf.c, which makes all references to\nstruct elf_prstatus to be textually replaced with struct\ncompat_elf_prstatus.  Ugly and somewhat brittle, but it works.\n\nHowever, amd64 is worse - there are _three_ possible layouts.\nOne for native 64bit processes, another for i386 (32bit) processes\nand yet another for x32 (32bit address space with full 64bit\nregisters).\n\nBoth i386 and x32 processes are handled by fs/compat_binfmt_elf.c,\nwith usual compat_binfmt_elf.c trickery.  However, the layouts\nfor i386 and x32 are not identical - they have the common beginning,\nbut the register dump part (pr_reg) is bigger on x32.  Worse, pr_reg\nis not the last field - it's followed by int pr_fpvalid, so that\nfield ends up at different offsets for i386 and x32 layouts.\n\nFortunately, there's not much code that cares about any of that -\nit's all encapsulated in fill_thread_core_info().  Since x32\nvariant is bigger, we define compat_elf_prstatus to match that\nlayout.  That way i386 processes have enough space to fit\ntheir layout into.\n\nMoreover, since these layouts are identical prior to pr_reg,\nwe don't need to distinguish x32 and i386 cases when we are\nsetting the fields prior to pr_reg.\n\nFilling pr_reg itself is done by calling ->get() method of\nappropriate regset, and that method knows what layout (and size)\nto use.\n\nWe do need to distinguish x32 and i386 cases only for two\nthings: setting ->pr_fpvalid (offset differs for x32 and\ni386) and choosing the right size for our note.\n\nThe way it's done is Not Nice, for the lack of more accurate\nprintable description.  There are two macros (PRSTATUS_SIZE and\nSET_PR_FPVALID), that default essentially to sizeof(struct elf_prstatus)\nand (S)->pr_fpvalid = 1.  On x86 asm/compat.h provides its own\nvariants.\n\nUnfortunately, quite a few things go wrong there:\n\t* PRSTATUS_SIZE doesn't use the normal test for process\nbeing an x32 one; it compares the size reported by regset with\nthe size of pr_reg.\n\t* it hardcodes the sizes of x32 and i386 variants (296 and 144\nresp.), so if some change in includes leads to asm/compat.h pulled\nin by fs/binfmt_elf.c we are in trouble - it will end up using\nthe size of x32 variant for 64bit processes.\n\t* it's in the wrong place; asm/compat.h couldn't define\nthe structure for i386 layout, since it lacks quite a few types\nneeded for it.  Hardcoded sizes are largely due to that.\n\nThe proper fix would be to have an explicitly defined i386 variant\nof structure and have PRSTATUS_SIZE/SET_PR_FPVALID check for\nTIF_X32 to choose the variant that should be used.  Unfortunately,\nthat requires some manipulations of headers; we'll do that later\nin the series, but for now let's go with the minimal variant -\nrename PRSTATUS_SIZE in asm/compat.h to COMPAT_PRSTATUS_SIZE,\nhave fs/compat_binfmt_elf.c define PRSTATUS_SIZE to COMPAT_PRSTATUS_SIZE\nand use the normal TIF_X32 check in that macro.  The size of i386 variant\nis kept hardcoded for now.  Similar story for SET_PR_FPVALID.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "arch/x86/include/asm/compat.h||arch/x86/include/asm/compat.h",
          "fs/binfmt_elf.c||fs/binfmt_elf.c",
          "fs/compat_binfmt_elf.c||fs/compat_binfmt_elf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/binfmt_elf.c||fs/binfmt_elf.c"
          ],
          "candidate": [
            "fs/binfmt_elf.c||fs/binfmt_elf.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/include/asm/compat.h||arch/x86/include/asm/compat.h": [
          "File: arch/x86/include/asm/compat.h -> arch/x86/include/asm/compat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "165: typedef struct user_regs_struct compat_elf_gregset_t;",
          "173: #ifdef CONFIG_X86_X32_ABI",
          "174: #define COMPAT_USE_64BIT_TIME \\",
          "",
          "[Removed Lines]",
          "168: #define PRSTATUS_SIZE(S, R) (R != sizeof(S.pr_reg) ? 144 : 296)",
          "169: #define SET_PR_FPVALID(S, V, R) \\",
          "170:   do { *(int *) (((void *) &((S)->pr_reg)) + R) = (V); } \\",
          "171:   while (0)",
          "",
          "[Added Lines]",
          "168: #define COMPAT_PRSTATUS_SIZE (user_64bit_mode(task_pt_regs(current)) \\",
          "169:  ? sizeof(struct compat_elf_prstatus) \\",
          "170:  : 144)",
          "171: #define COMPAT_SET_PR_FPVALID(S) \\",
          "172:  (*(user_64bit_mode(task_pt_regs(current)) \\",
          "173:         ? &(S)->pr_fpvalid \\",
          "174:                : (int *)((void *)(S) + 140)) = 1)",
          "",
          "---------------"
        ],
        "fs/binfmt_elf.c||fs/binfmt_elf.c": [
          "File: fs/binfmt_elf.c -> fs/binfmt_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1717: }",
          "1719: #ifndef PRSTATUS_SIZE",
          "1721: #endif",
          "1723: #ifndef SET_PR_FPVALID",
          "1725: #endif",
          "1727: static int fill_thread_core_info(struct elf_thread_core_info *t,",
          "",
          "[Removed Lines]",
          "1720: #define PRSTATUS_SIZE(S, R) sizeof(S)",
          "1724: #define SET_PR_FPVALID(S, V, R) ((S)->pr_fpvalid = (V))",
          "",
          "[Added Lines]",
          "1720: #define PRSTATUS_SIZE sizeof(struct elf_prstatus)",
          "1724: #define SET_PR_FPVALID(S) ((S)->pr_fpvalid = 1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1729:      long signr, size_t *total)",
          "1730: {",
          "1731:  unsigned int i;",
          "",
          "[Removed Lines]",
          "1732:  int regset0_size;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1740:  fill_prstatus(&t->prstatus, t->task, signr);",
          "1742:      sizeof(t->prstatus.pr_reg), &t->prstatus.pr_reg);",
          "1746:  fill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,",
          "1750:  do_thread_regset_writeback(t->task, &view->regsets[0]);",
          "",
          "[Removed Lines]",
          "1741:  regset0_size = regset_get(t->task, &view->regsets[0],",
          "1743:  if (regset0_size < 0)",
          "1744:   return 0;",
          "1747:     PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);",
          "",
          "[Added Lines]",
          "1740:  regset_get(t->task, &view->regsets[0],",
          "1744:     PRSTATUS_SIZE, &t->prstatus);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1772:    continue;",
          "1774:   if (is_fpreg)",
          "1777:   fill_note(&t->notes[i], is_fpreg ? \"CORE\" : \"LINUX\",",
          "1778:      note_type, ret, data);",
          "",
          "[Removed Lines]",
          "1775:    SET_PR_FPVALID(&t->prstatus, 1, regset0_size);",
          "",
          "[Added Lines]",
          "1772:    SET_PR_FPVALID(&t->prstatus);",
          "",
          "---------------"
        ],
        "fs/compat_binfmt_elf.c||fs/compat_binfmt_elf.c": [
          "File: fs/compat_binfmt_elf.c -> fs/compat_binfmt_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95: #define ELF_EXEC_PAGESIZE COMPAT_ELF_EXEC_PAGESIZE",
          "96: #endif",
          "98: #ifdef COMPAT_ELF_PLAT_INIT",
          "99: #undef ELF_PLAT_INIT",
          "100: #define ELF_PLAT_INIT  COMPAT_ELF_PLAT_INIT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98: #ifdef COMPAT_PRSTATUS_SIZE",
          "99: #define PRSTATUS_SIZE COMPAT_PRSTATUS_SIZE",
          "100: #endif",
          "102: #ifdef COMPAT_SET_PR_FPVALID",
          "103: #define SET_PR_FPVALID(S) COMPAT_SET_PR_FPVALID(S)",
          "104: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
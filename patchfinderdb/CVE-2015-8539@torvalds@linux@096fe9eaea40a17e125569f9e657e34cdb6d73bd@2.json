{
  "cve_id": "CVE-2015-8539",
  "cve_desc": "The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",
  "repo": "torvalds/linux",
  "patch_hash": "096fe9eaea40a17e125569f9e657e34cdb6d73bd",
  "patch_info": {
    "commit_hash": "096fe9eaea40a17e125569f9e657e34cdb6d73bd",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd",
    "files": [
      "security/keys/encrypted-keys/encrypted.c",
      "security/keys/trusted.c",
      "security/keys/user_defined.c"
    ],
    "message": "KEYS: Fix handling of stored error in a negatively instantiated user key\n\nIf a user key gets negatively instantiated, an error code is cached in the\npayload area.  A negatively instantiated key may be then be positively\ninstantiated by updating it with valid data.  However, the ->update key\ntype method must be aware that the error code may be there.\n\nThe following may be used to trigger the bug in the user key type:\n\n    keyctl request2 user user \"\" @u\n    keyctl add user user \"a\" @u\n\nwhich manifests itself as:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tPGD 7cc30067 PUD 0\n\tOops: 0002 [#1] SMP\n\tModules linked in:\n\tCPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49\n\tHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n\ttask: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000\n\tRIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280\n\t [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tRSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246\n\tRAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001\n\tRDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82\n\tRBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000\n\tR10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82\n\tR13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700\n\tFS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000\n\tCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n\tCR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0\n\tStack:\n\t ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82\n\t ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5\n\t ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620\n\tCall Trace:\n\t [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136\n\t [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129\n\t [<     inline     >] __key_update security/keys/key.c:730\n\t [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908\n\t [<     inline     >] SYSC_add_key security/keys/keyctl.c:125\n\t [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60\n\t [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185\n\nNote the error code (-ENOKEY) in EDX.\n\nA similar bug can be tripped by:\n\n    keyctl request2 trusted user \"\" @u\n    keyctl add trusted user \"a\" @u\n\nThis should also affect encrypted keys - but that has to be correctly\nparameterised or it will fail with EINVAL before getting to the bit that\nwill crashes.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "before_after_code_files": [
      "security/keys/encrypted-keys/encrypted.c||security/keys/encrypted-keys/encrypted.c",
      "security/keys/trusted.c||security/keys/trusted.c",
      "security/keys/user_defined.c||security/keys/user_defined.c"
    ]
  },
  "patch_diff": {
    "security/keys/encrypted-keys/encrypted.c||security/keys/encrypted-keys/encrypted.c": [
      "File: security/keys/encrypted-keys/encrypted.c -> security/keys/encrypted-keys/encrypted.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "845:  size_t datalen = prep->datalen;",
      "846:  int ret = 0;",
      "848:  if (datalen <= 0 || datalen > 32767 || !prep->data)",
      "849:   return -EINVAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "848:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
      "849:   return -ENOKEY;",
      "",
      "---------------"
    ],
    "security/keys/trusted.c||security/keys/trusted.c": [
      "File: security/keys/trusted.c -> security/keys/trusted.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1008: static int trusted_update(struct key *key, struct key_preparsed_payload *prep)",
      "1009: {",
      "1011:  struct trusted_key_payload *new_p;",
      "1012:  struct trusted_key_options *new_o;",
      "1013:  size_t datalen = prep->datalen;",
      "1014:  char *datablob;",
      "1015:  int ret = 0;",
      "1017:  if (!p->migratable)",
      "1018:   return -EPERM;",
      "1019:  if (datalen <= 0 || datalen > 32767 || !prep->data)",
      "",
      "[Removed Lines]",
      "1010:  struct trusted_key_payload *p = key->payload.data[0];",
      "",
      "[Added Lines]",
      "1010:  struct trusted_key_payload *p;",
      "1017:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
      "1018:   return -ENOKEY;",
      "1019:  p = key->payload.data[0];",
      "",
      "---------------"
    ],
    "security/keys/user_defined.c||security/keys/user_defined.c": [
      "File: security/keys/user_defined.c -> security/keys/user_defined.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "121:  if (ret == 0) {",
      "124:   rcu_assign_keypointer(key, upayload);",
      "125:   key->expiry = 0;",
      "126:  }",
      "",
      "[Removed Lines]",
      "123:   zap = key->payload.data[0];",
      "",
      "[Added Lines]",
      "123:   if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
      "124:    zap = key->payload.data[0];",
      "125:   else",
      "126:    zap = NULL;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "19cd80a214821f4b558560ebd76bfb2c38b4f3d8",
      "candidate_info": {
        "commit_hash": "19cd80a214821f4b558560ebd76bfb2c38b4f3d8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/19cd80a214821f4b558560ebd76bfb2c38b4f3d8",
        "files": [
          "drivers/usb/class/usblp.c"
        ],
        "message": "usblp: do not set TASK_INTERRUPTIBLE before lock\n\nIt is not permitted to set task state before lock. usblp_wwait sets\nthe state to TASK_INTERRUPTIBLE and calls mutex_lock_interruptible.\nUpon return from that function, the state will be TASK_RUNNING again.\n\nThis is clearly a bug and a warning is generated with LOCKDEP too:\nWARNING: CPU: 1 PID: 5109 at kernel/sched/core.c:7404 __might_sleep+0x7d/0x90()\ndo not call blocking ops when !TASK_RUNNING; state=1 set at [<ffffffffa0c588d0>] usblp_wwait+0xa0/0x310 [usblp]\nModules linked in: ...\nCPU: 1 PID: 5109 Comm: captmon Tainted: G        W       4.2.5-0.gef2823b-default #1\nHardware name: LENOVO 23252SG/23252SG, BIOS G2ET33WW (1.13 ) 07/24/2012\n ffffffff81a4edce ffff880236ec7ba8 ffffffff81716651 0000000000000000\n ffff880236ec7bf8 ffff880236ec7be8 ffffffff8106e146 0000000000000282\n ffffffff81a50119 000000000000028b 0000000000000000 ffff8802dab7c508\nCall Trace:\n...\n [<ffffffff8106e1c6>] warn_slowpath_fmt+0x46/0x50\n [<ffffffff8109a8bd>] __might_sleep+0x7d/0x90\n [<ffffffff8171b20f>] mutex_lock_interruptible_nested+0x2f/0x4b0\n [<ffffffffa0c588fc>] usblp_wwait+0xcc/0x310 [usblp]\n [<ffffffffa0c58bb2>] usblp_write+0x72/0x350 [usblp]\n [<ffffffff8121ed98>] __vfs_write+0x28/0xf0\n...\n\nCommit 7f477358e2384c54b190cc3b6ce28277050a041b (usblp: Implement the\nENOSPC convention) moved the set prior locking. So move it back after\nthe lock.\n\nSigned-off-by: Jiri Slaby <jslaby@suse.cz>\nFixes: 7f477358e2 (\"usblp: Implement the ENOSPC convention\")\nAcked-By: Pete Zaitcev <zaitcev@yahoo.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/usb/class/usblp.c||drivers/usb/class/usblp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/class/usblp.c||drivers/usb/class/usblp.c": [
          "File: drivers/usb/class/usblp.c -> drivers/usb/class/usblp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "885:  add_wait_queue(&usblp->wwait, &waita);",
          "886:  for (;;) {",
          "888:   if (mutex_lock_interruptible(&usblp->mut)) {",
          "889:    rc = -EINTR;",
          "890:    break;",
          "891:   }",
          "892:   rc = usblp_wtest(usblp, nonblock);",
          "893:   mutex_unlock(&usblp->mut);",
          "894:   if (rc <= 0)",
          "",
          "[Removed Lines]",
          "887:   set_current_state(TASK_INTERRUPTIBLE);",
          "",
          "[Added Lines]",
          "891:   set_current_state(TASK_INTERRUPTIBLE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f74875dc36135ebae82a8e005f4b7f52289d2c40",
      "candidate_info": {
        "commit_hash": "f74875dc36135ebae82a8e005f4b7f52289d2c40",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f74875dc36135ebae82a8e005f4b7f52289d2c40",
        "files": [
          "drivers/usb/dwc2/platform.c"
        ],
        "message": "usb: dwc2: fix kernel oops during driver probe\n\nThis patch make sure that all necessary members of dwc2_hsotg\nare initialized before the irq handler is requested. So\nthe kernel oops triggered by dwc2_handle_common_intr has\nbeen fixed.\n\n  dwc2 20980000.usb: Configuration mismatch. Forcing host mode\n  dwc2 20980000.usb: no platform data or transceiver defined\n  Unable to handle kernel paging request at virtual address cc860040\n  pgd = c0004000\n  [cc860040] *pgd=0b41e811, *pte=00000000, *ppte=00000000\n  Internal error: Oops: 7 [#1] ARM\n  CPU: 0 PID: 1 Comm: swapper Not tainted 4.3.0-rc3+ #19\n  Hardware name: BCM2835\n  task: cb494000 ti: cb4d0000 task.ti: cb4d0000\n  PC is at dwc2_is_controller_alive+0x18/0x34\n  LR is at dwc2_handle_common_intr+0x24/0xb60\n\nAcked-by: John Youn <johnyoun@synopsys.com>\nTested-by: Marek Szyprowski <m.szyprowski@samsung.com>\nSigned-off-by: Stefan Wahren <stefan.wahren@i2se.com>\nSigned-off-by: Felipe Balbi <balbi@ti.com>",
        "before_after_code_files": [
          "drivers/usb/dwc2/platform.c||drivers/usb/dwc2/platform.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/dwc2/platform.c||drivers/usb/dwc2/platform.c": [
          "File: drivers/usb/dwc2/platform.c -> drivers/usb/dwc2/platform.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "367:  if (retval)",
          "368:   return retval;",
          "384:  res = platform_get_resource(dev, IORESOURCE_MEM, 0);",
          "385:  hsotg->regs = devm_ioremap_resource(&dev->dev, res);",
          "386:  if (IS_ERR(hsotg->regs))",
          "",
          "[Removed Lines]",
          "370:  irq = platform_get_irq(dev, 0);",
          "371:  if (irq < 0) {",
          "372:   dev_err(&dev->dev, \"missing IRQ resource\\n\");",
          "373:   return irq;",
          "374:  }",
          "376:  dev_dbg(hsotg->dev, \"registering common handler for irq%d\\n\",",
          "377:   irq);",
          "378:  retval = devm_request_irq(hsotg->dev, irq,",
          "379:       dwc2_handle_common_intr, IRQF_SHARED,",
          "380:       dev_name(hsotg->dev), hsotg);",
          "381:  if (retval)",
          "382:   return retval;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "416:  dwc2_set_all_params(hsotg->core_params, -1);",
          "418:  retval = dwc2_lowlevel_hw_enable(hsotg);",
          "419:  if (retval)",
          "420:   return retval;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "404:  irq = platform_get_irq(dev, 0);",
          "405:  if (irq < 0) {",
          "406:   dev_err(&dev->dev, \"missing IRQ resource\\n\");",
          "407:   return irq;",
          "408:  }",
          "410:  dev_dbg(hsotg->dev, \"registering common handler for irq%d\\n\",",
          "411:   irq);",
          "412:  retval = devm_request_irq(hsotg->dev, irq,",
          "413:       dwc2_handle_common_intr, IRQF_SHARED,",
          "414:       dev_name(hsotg->dev), hsotg);",
          "415:  if (retval)",
          "416:   return retval;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f109f7cc37108cba7243bc832988525b0d85909",
      "candidate_info": {
        "commit_hash": "7f109f7cc37108cba7243bc832988525b0d85909",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7f109f7cc37108cba7243bc832988525b0d85909",
        "files": [
          "drivers/net/vrf.c"
        ],
        "message": "vrf: fix double free and memory corruption on register_netdevice failure\n\nWhen vrf's ->newlink is called, if register_netdevice() fails then it\ndoes free_netdev(), but that's also done by rtnl_newlink() so a second\nfree happens and memory gets corrupted, to reproduce execute the\nfollowing line a couple of times (1 - 5 usually is enough):\n$ for i in `seq 1 5`; do ip link add vrf: type vrf table 1; done;\nThis works because we fail in register_netdevice() because of the wrong\nname \"vrf:\".\n\nAnd here's a trace of one crash:\n[   28.792157] ------------[ cut here ]------------\n[   28.792407] kernel BUG at fs/namei.c:246!\n[   28.792608] invalid opcode: 0000 [#1] SMP\n[   28.793240] Modules linked in: vrf nfsd auth_rpcgss oid_registry\nnfs_acl nfs lockd grace sunrpc crct10dif_pclmul crc32_pclmul\ncrc32c_intel qxl drm_kms_helper ttm drm aesni_intel aes_x86_64 psmouse\nglue_helper lrw evdev gf128mul i2c_piix4 ablk_helper cryptd ppdev\nparport_pc parport serio_raw pcspkr virtio_balloon virtio_console\ni2c_core acpi_cpufreq button 9pnet_virtio 9p 9pnet fscache ipv6 autofs4\next4 crc16 mbcache jbd2 virtio_blk virtio_net sg sr_mod cdrom\nata_generic ehci_pci uhci_hcd ehci_hcd e1000 usbcore usb_common ata_piix\nlibata virtio_pci virtio_ring virtio scsi_mod floppy\n[   28.796016] CPU: 0 PID: 1148 Comm: ld-linux-x86-64 Not tainted\n4.4.0-rc1+ #24\n[   28.796016] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),\nBIOS 1.8.1-20150318_183358- 04/01/2014\n[   28.796016] task: ffff8800352561c0 ti: ffff88003592c000 task.ti:\nffff88003592c000\n[   28.796016] RIP: 0010:[<ffffffff812187b3>]  [<ffffffff812187b3>]\nputname+0x43/0x60\n[   28.796016] RSP: 0018:ffff88003592fe88  EFLAGS: 00010246\n[   28.796016] RAX: 0000000000000000 RBX: ffff8800352561c0 RCX:\n0000000000000001\n[   28.796016] RDX: 0000000000000000 RSI: 0000000000000000 RDI:\nffff88003784f000\n[   28.796016] RBP: ffff88003592ff08 R08: 0000000000000001 R09:\n0000000000000000\n[   28.796016] R10: 0000000000000000 R11: 0000000000000001 R12:\n0000000000000000\n[   28.796016] R13: 000000000000047c R14: ffff88003784f000 R15:\nffff8800358c4a00\n[   28.796016] FS:  0000000000000000(0000) GS:ffff88003fc00000(0000)\nknlGS:0000000000000000\n[   28.796016] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   28.796016] CR2: 00007ffd583bc2d9 CR3: 0000000035a99000 CR4:\n00000000000406f0\n[   28.796016] Stack:\n[   28.796016]  ffffffff8121045d ffffffff812102d3 ffff8800352561c0\nffff880035a91660\n[   28.796016]  ffff8800008a9880 0000000000000000 ffffffff81a49940\n00ffffff81218684\n[   28.796016]  ffff8800352561c0 000000000000047c 0000000000000000\nffff880035b36d80\n[   28.796016] Call Trace:\n[   28.796016]  [<ffffffff8121045d>] ?\ndo_execveat_common.isra.34+0x74d/0x930\n[   28.796016]  [<ffffffff812102d3>] ?\ndo_execveat_common.isra.34+0x5c3/0x930\n[   28.796016]  [<ffffffff8121066c>] do_execve+0x2c/0x30\n[   28.796016]  [<ffffffff810939a0>]\ncall_usermodehelper_exec_async+0xf0/0x140\n[   28.796016]  [<ffffffff810938b0>] ? umh_complete+0x40/0x40\n[   28.796016]  [<ffffffff815cb1af>] ret_from_fork+0x3f/0x70\n[   28.796016] Code: 48 8d 47 1c 48 89 e5 53 48 8b 37 48 89 fb 48 39 c6\n74 1a 48 8b 3d 7e e9 8f 00 e8 49 fa fc ff 48 89 df e8 f1 01 fd ff 5b 5d\nf3 c3 <0f> 0b 48 89 fe 48 8b 3d 61 e9 8f 00 e8 2c fa fc ff 5b 5d eb e9\n[   28.796016] RIP  [<ffffffff812187b3>] putname+0x43/0x60\n[   28.796016]  RSP <ffff88003592fe88>\n\nFixes: 193125dbd8eb (\"net: Introduce VRF device driver\")\nSigned-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>\nAcked-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/vrf.c||drivers/net/vrf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/vrf.c||drivers/net/vrf.c": [
          "File: drivers/net/vrf.c -> drivers/net/vrf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "907:          struct nlattr *tb[], struct nlattr *data[])",
          "908: {",
          "909:  struct net_vrf *vrf = netdev_priv(dev);",
          "912:  if (!data || !data[IFLA_VRF_TABLE])",
          "913:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "910:  int err;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "917:  dev->priv_flags |= IFF_L3MDEV_MASTER;",
          "928: }",
          "930: static size_t vrf_nl_getsize(const struct net_device *dev)",
          "",
          "[Removed Lines]",
          "919:  err = register_netdevice(dev);",
          "920:  if (err < 0)",
          "921:   goto out_fail;",
          "923:  return 0;",
          "925: out_fail:",
          "926:  free_netdev(dev);",
          "927:  return err;",
          "",
          "[Added Lines]",
          "918:  return register_netdevice(dev);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "898de7d0f298e53568891f0ec3547b14fe8bb5d5",
      "candidate_info": {
        "commit_hash": "898de7d0f298e53568891f0ec3547b14fe8bb5d5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/898de7d0f298e53568891f0ec3547b14fe8bb5d5",
        "files": [
          "security/keys/user_defined.c"
        ],
        "message": "KEYS: user_update should use copy of payload made during preparsing\n\nThe payload preparsing routine for user keys makes a copy of the payload\nprovided by the caller and stashes it in the key_preparsed_payload struct for\n->instantiate() or ->update() to use.  However, ->update() takes another copy\nof this to attach to the keyring.  ->update() should be using this directly\nand clearing the pointer in the preparse data.\n\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "security/keys/user_defined.c||security/keys/user_defined.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "security/keys/user_defined.c||security/keys/user_defined.c"
          ],
          "candidate": [
            "security/keys/user_defined.c||security/keys/user_defined.c"
          ]
        }
      },
      "candidate_diff": {
        "security/keys/user_defined.c||security/keys/user_defined.c": [
          "File: security/keys/user_defined.c -> security/keys/user_defined.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97: int user_update(struct key *key, struct key_preparsed_payload *prep)",
          "98: {",
          "101:  int ret;",
          "131:  if (zap)",
          "132:   kfree_rcu(zap, rcu);",
          "135:  return ret;",
          "136: }",
          "138: EXPORT_SYMBOL_GPL(user_update);",
          "",
          "[Removed Lines]",
          "99:  struct user_key_payload *upayload, *zap;",
          "100:  size_t datalen = prep->datalen;",
          "103:  ret = -EINVAL;",
          "104:  if (datalen <= 0 || datalen > 32767 || !prep->data)",
          "105:   goto error;",
          "108:  ret = -ENOMEM;",
          "109:  upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);",
          "110:  if (!upayload)",
          "111:   goto error;",
          "113:  upayload->datalen = datalen;",
          "114:  memcpy(upayload->data, prep->data, datalen);",
          "117:  zap = upayload;",
          "119:  ret = key_payload_reserve(key, datalen);",
          "121:  if (ret == 0) {",
          "123:   if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
          "124:    zap = key->payload.data[0];",
          "125:   else",
          "126:    zap = NULL;",
          "127:   rcu_assign_keypointer(key, upayload);",
          "128:   key->expiry = 0;",
          "129:  }",
          "134: error:",
          "",
          "[Added Lines]",
          "99:  struct user_key_payload *zap = NULL;",
          "103:  ret = key_payload_reserve(key, prep->datalen);",
          "104:  if (ret < 0)",
          "105:   return ret;",
          "108:  key->expiry = prep->expiry;",
          "109:  if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
          "110:   zap = rcu_dereference_key(key);",
          "111:  rcu_assign_keypointer(key, prep->payload.data[0]);",
          "112:  prep->payload.data[0] = NULL;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
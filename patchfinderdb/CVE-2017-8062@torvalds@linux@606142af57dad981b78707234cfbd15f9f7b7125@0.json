{
  "cve_id": "CVE-2017-8062",
  "cve_desc": "drivers/media/usb/dvb-usb/dw2102.c in the Linux kernel 4.9.x and 4.10.x before 4.10.4 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",
  "repo": "torvalds/linux",
  "patch_hash": "606142af57dad981b78707234cfbd15f9f7b7125",
  "patch_info": {
    "commit_hash": "606142af57dad981b78707234cfbd15f9f7b7125",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125",
    "files": [
      "drivers/media/usb/dvb-usb/dw2102.c"
    ],
    "message": "[media] dw2102: don't do DMA on stack\n\nOn Kernel 4.9, WARNINGs about doing DMA on stack are hit at\nthe dw2102 driver: one in su3000_power_ctrl() and the other in tt_s2_4600_frontend_attach().\n\nBoth were due to the use of buffers on the stack as parameters to\ndvb_usb_generic_rw() and the resulting attempt to do DMA with them.\n\nThe device was non-functional as a result.\n\nSo, switch this driver over to use a buffer within the device state\nstructure, as has been done with other DVB-USB drivers.\n\nTested with TechnoTrend TT-connect S2-4600.\n\n[mchehab@osg.samsung.com: fixed a warning at su3000_i2c_transfer() that\n state var were dereferenced before check 'd']\nSigned-off-by: Jonathan McDowell <noodles@earth.li>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>",
    "before_after_code_files": [
      "drivers/media/usb/dvb-usb/dw2102.c||drivers/media/usb/dvb-usb/dw2102.c"
    ]
  },
  "patch_diff": {
    "drivers/media/usb/dvb-usb/dw2102.c||drivers/media/usb/dvb-usb/dw2102.c": [
      "File: drivers/media/usb/dvb-usb/dw2102.c -> drivers/media/usb/dvb-usb/dw2102.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "68: struct dw2102_state {",
      "69:  u8 initialized;",
      "70:  u8 last_lock;",
      "71:  struct i2c_client *i2c_client_demod;",
      "72:  struct i2c_client *i2c_client_tuner;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "71:  u8 data[MAX_XFER_SIZE + 4];",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "661:         int num)",
      "662: {",
      "663:  struct dvb_usb_device *d = i2c_get_adapdata(adap);",
      "666:  if (!d)",
      "667:   return -ENODEV;",
      "668:  if (mutex_lock_interruptible(&d->i2c_mutex) < 0)",
      "669:   return -EAGAIN;",
      "671:  switch (num) {",
      "672:  case 1:",
      "673:   switch (msg[0].addr) {",
      "674:   case SU3000_STREAM_CTRL:",
      "679:     err(\"i2c transfer failed.\");",
      "680:    break;",
      "681:   case DW2102_RC_QUERY:",
      "684:     err(\"i2c transfer failed.\");",
      "687:    break;",
      "688:   default:",
      "698:     err(\"i2c transfer failed.\");",
      "700:   }",
      "701:   break;",
      "702:  case 2:",
      "712:    err(\"i2c transfer failed.\");",
      "715:   break;",
      "716:  default:",
      "717:   warn(\"more than 2 i2c messages at a time is not handled yet.\");",
      "718:   break;",
      "719:  }",
      "720:  mutex_unlock(&d->i2c_mutex);",
      "721:  return num;",
      "722: }",
      "",
      "[Removed Lines]",
      "664:  u8 obuf[0x40], ibuf[0x40];",
      "675:    obuf[0] = msg[0].buf[0] + 0x36;",
      "676:    obuf[1] = 3;",
      "677:    obuf[2] = 0;",
      "678:    if (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)",
      "682:    obuf[0] = 0x10;",
      "683:    if (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)",
      "685:    msg[0].buf[1] = ibuf[0];",
      "686:    msg[0].buf[0] = ibuf[1];",
      "690:    obuf[0] = 0x08;",
      "691:    obuf[1] = msg[0].addr;",
      "692:    obuf[2] = msg[0].len;",
      "694:    memcpy(&obuf[3], msg[0].buf, msg[0].len);",
      "696:    if (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,",
      "697:       ibuf, 1, 0) < 0)",
      "704:   obuf[0] = 0x09;",
      "705:   obuf[1] = msg[0].len;",
      "706:   obuf[2] = msg[1].len;",
      "707:   obuf[3] = msg[0].addr;",
      "708:   memcpy(&obuf[4], msg[0].buf, msg[0].len);",
      "710:   if (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,",
      "711:      ibuf, msg[1].len + 1, 0) < 0)",
      "714:   memcpy(msg[1].buf, &ibuf[1], msg[1].len);",
      "",
      "[Added Lines]",
      "665:  struct dw2102_state *state;",
      "670:  state = d->priv;",
      "674:  if (mutex_lock_interruptible(&d->data_mutex) < 0) {",
      "675:   mutex_unlock(&d->i2c_mutex);",
      "676:   return -EAGAIN;",
      "677:  }",
      "683:    state->data[0] = msg[0].buf[0] + 0x36;",
      "684:    state->data[1] = 3;",
      "685:    state->data[2] = 0;",
      "686:    if (dvb_usb_generic_rw(d, state->data, 3,",
      "687:      state->data, 0, 0) < 0)",
      "691:    state->data[0] = 0x10;",
      "692:    if (dvb_usb_generic_rw(d, state->data, 1,",
      "693:      state->data, 2, 0) < 0)",
      "695:    msg[0].buf[1] = state->data[0];",
      "696:    msg[0].buf[0] = state->data[1];",
      "700:    state->data[0] = 0x08;",
      "701:    state->data[1] = msg[0].addr;",
      "702:    state->data[2] = msg[0].len;",
      "704:    memcpy(&state->data[3], msg[0].buf, msg[0].len);",
      "706:    if (dvb_usb_generic_rw(d, state->data, msg[0].len + 3,",
      "707:       state->data, 1, 0) < 0)",
      "714:   state->data[0] = 0x09;",
      "715:   state->data[1] = msg[0].len;",
      "716:   state->data[2] = msg[1].len;",
      "717:   state->data[3] = msg[0].addr;",
      "718:   memcpy(&state->data[4], msg[0].buf, msg[0].len);",
      "720:   if (dvb_usb_generic_rw(d, state->data, msg[0].len + 4,",
      "721:      state->data, msg[1].len + 1, 0) < 0)",
      "724:   memcpy(msg[1].buf, &state->data[1], msg[1].len);",
      "730:  mutex_unlock(&d->data_mutex);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "844: static int su3000_power_ctrl(struct dvb_usb_device *d, int i)",
      "845: {",
      "846:  struct dw2102_state *state = (struct dw2102_state *)d->priv;",
      "849:  info(\"%s: %d, initialized %d\", __func__, i, state->initialized);",
      "851:  if (i && !state->initialized) {",
      "852:   state->initialized = 1;",
      "855:  }",
      "858: }",
      "860: static int su3000_read_mac_address(struct dvb_usb_device *d, u8 mac[6])",
      "",
      "[Removed Lines]",
      "847:  u8 obuf[] = {0xde, 0};",
      "854:   return dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);",
      "857:  return 0;",
      "",
      "[Added Lines]",
      "858:  int ret = 0;",
      "863:   mutex_lock(&d->data_mutex);",
      "865:   state->data[0] = 0xde;",
      "866:   state->data[1] = 0;",
      "870:   ret = dvb_usb_generic_rw(d, state->data, 2, NULL, 0, 0);",
      "871:   mutex_unlock(&d->data_mutex);",
      "874:  return ret;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1309:  return 0;",
      "1310: }",
      "1313: {",
      "1318:   err(\"command 0x0e transfer failed.\");",
      "1325:   err(\"command 0x0e transfer failed.\");",
      "1326:  msleep(300);",
      "1333:   err(\"command 0x0e transfer failed.\");",
      "1340:   err(\"command 0x0e transfer failed.\");",
      "1345:   err(\"command 0x51 transfer failed.\");",
      "1350:   return -EIO;",
      "1353:     &dw2104_ts2020_config,",
      "1355:   info(\"Attached DS3000/TS2020!\");",
      "1356:   return 0;",
      "1357:  }",
      "",
      "[Removed Lines]",
      "1312: static int su3000_frontend_attach(struct dvb_usb_adapter *d)",
      "1314:  u8 obuf[3] = { 0xe, 0x80, 0 };",
      "1315:  u8 ibuf[] = { 0 };",
      "1317:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1320:  obuf[0] = 0xe;",
      "1321:  obuf[1] = 0x02;",
      "1322:  obuf[2] = 1;",
      "1324:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1328:  obuf[0] = 0xe;",
      "1329:  obuf[1] = 0x83;",
      "1330:  obuf[2] = 0;",
      "1332:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1335:  obuf[0] = 0xe;",
      "1336:  obuf[1] = 0x83;",
      "1337:  obuf[2] = 1;",
      "1339:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1342:  obuf[0] = 0x51;",
      "1344:  if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)",
      "1347:  d->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,",
      "1348:      &d->dev->i2c_adap);",
      "1349:  if (d->fe_adap[0].fe == NULL)",
      "1352:  if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,",
      "1354:     &d->dev->i2c_adap)) {",
      "",
      "[Added Lines]",
      "1329: static int su3000_frontend_attach(struct dvb_usb_adapter *adap)",
      "1331:  struct dvb_usb_device *d = adap->dev;",
      "1332:  struct dw2102_state *state = d->priv;",
      "1334:  mutex_lock(&d->data_mutex);",
      "1336:  state->data[0] = 0xe;",
      "1337:  state->data[1] = 0x80;",
      "1338:  state->data[2] = 0;",
      "1340:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1343:  state->data[0] = 0xe;",
      "1344:  state->data[1] = 0x02;",
      "1345:  state->data[2] = 1;",
      "1347:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1351:  state->data[0] = 0xe;",
      "1352:  state->data[1] = 0x83;",
      "1353:  state->data[2] = 0;",
      "1355:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1358:  state->data[0] = 0xe;",
      "1359:  state->data[1] = 0x83;",
      "1360:  state->data[2] = 1;",
      "1362:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1365:  state->data[0] = 0x51;",
      "1367:  if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)",
      "1370:  mutex_unlock(&d->data_mutex);",
      "1372:  adap->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,",
      "1373:      &d->i2c_adap);",
      "1374:  if (adap->fe_adap[0].fe == NULL)",
      "1377:  if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,",
      "1379:     &d->i2c_adap)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1360:  return -EIO;",
      "1361: }",
      "1364: {",
      "1369:   err(\"command 0x0e transfer failed.\");",
      "1376:   err(\"command 0x0e transfer failed.\");",
      "1383:   err(\"command 0x0e transfer failed.\");",
      "1385:  msleep(50);",
      "1392:   err(\"command 0x0e transfer failed.\");",
      "1397:   err(\"command 0x51 transfer failed.\");",
      "1404:    info(\"Attached TDA18271HD/CXD2820R!\");",
      "1405:    return 0;",
      "1406:   }",
      "",
      "[Removed Lines]",
      "1363: static int t220_frontend_attach(struct dvb_usb_adapter *d)",
      "1365:  u8 obuf[3] = { 0xe, 0x87, 0 };",
      "1366:  u8 ibuf[] = { 0 };",
      "1368:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1371:  obuf[0] = 0xe;",
      "1372:  obuf[1] = 0x86;",
      "1373:  obuf[2] = 1;",
      "1375:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1378:  obuf[0] = 0xe;",
      "1379:  obuf[1] = 0x80;",
      "1380:  obuf[2] = 0;",
      "1382:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1387:  obuf[0] = 0xe;",
      "1388:  obuf[1] = 0x80;",
      "1389:  obuf[2] = 1;",
      "1391:  if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)",
      "1394:  obuf[0] = 0x51;",
      "1396:  if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)",
      "1399:  d->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,",
      "1400:      &d->dev->i2c_adap, NULL);",
      "1401:  if (d->fe_adap[0].fe != NULL) {",
      "1402:   if (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,",
      "1403:      &d->dev->i2c_adap, &tda18271_config)) {",
      "",
      "[Added Lines]",
      "1388: static int t220_frontend_attach(struct dvb_usb_adapter *adap)",
      "1390:  struct dvb_usb_device *d = adap->dev;",
      "1391:  struct dw2102_state *state = d->priv;",
      "1393:  mutex_lock(&d->data_mutex);",
      "1395:  state->data[0] = 0xe;",
      "1396:  state->data[1] = 0x87;",
      "1397:  state->data[2] = 0x0;",
      "1399:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1402:  state->data[0] = 0xe;",
      "1403:  state->data[1] = 0x86;",
      "1404:  state->data[2] = 1;",
      "1406:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1409:  state->data[0] = 0xe;",
      "1410:  state->data[1] = 0x80;",
      "1411:  state->data[2] = 0;",
      "1413:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1418:  state->data[0] = 0xe;",
      "1419:  state->data[1] = 0x80;",
      "1420:  state->data[2] = 1;",
      "1422:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1425:  state->data[0] = 0x51;",
      "1427:  if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)",
      "1430:  mutex_unlock(&d->data_mutex);",
      "1432:  adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,",
      "1433:      &d->i2c_adap, NULL);",
      "1434:  if (adap->fe_adap[0].fe != NULL) {",
      "1435:   if (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,",
      "1436:      &d->i2c_adap, &tda18271_config)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1410:  return -EIO;",
      "1411: }",
      "1414: {",
      "1419:   err(\"command 0x51 transfer failed.\");",
      "1425:   return -EIO;",
      "1428:     &dw2104_ts2020_config,",
      "1430:   info(\"Attached RS2000/TS2020!\");",
      "1431:   return 0;",
      "1432:  }",
      "",
      "[Removed Lines]",
      "1413: static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)",
      "1415:  u8 obuf[] = { 0x51 };",
      "1416:  u8 ibuf[] = { 0 };",
      "1418:  if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)",
      "1421:  d->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,",
      "1422:      &d->dev->i2c_adap);",
      "1424:  if (d->fe_adap[0].fe == NULL)",
      "1427:  if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,",
      "1429:     &d->dev->i2c_adap)) {",
      "",
      "[Added Lines]",
      "1446: static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)",
      "1448:  struct dvb_usb_device *d = adap->dev;",
      "1449:  struct dw2102_state *state = d->priv;",
      "1451:  mutex_lock(&d->data_mutex);",
      "1453:  state->data[0] = 0x51;",
      "1455:  if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)",
      "1458:  mutex_unlock(&d->data_mutex);",
      "1460:  adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,",
      "1461:      &s421_m88rs2000_config,",
      "1462:      &d->i2c_adap);",
      "1464:  if (adap->fe_adap[0].fe == NULL)",
      "1467:  if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,",
      "1469:     &d->i2c_adap)) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1439: {",
      "1440:  struct dvb_usb_device *d = adap->dev;",
      "1441:  struct dw2102_state *state = d->priv;",
      "1444:  struct i2c_adapter *i2c_adapter;",
      "1445:  struct i2c_client *client;",
      "1446:  struct i2c_board_info board_info;",
      "1447:  struct m88ds3103_platform_data m88ds3103_pdata = {};",
      "1448:  struct ts2020_config ts2020_config = {};",
      "1451:   err(\"command 0x0e transfer failed.\");",
      "1458:   err(\"command 0x0e transfer failed.\");",
      "1459:  msleep(300);",
      "1466:   err(\"command 0x0e transfer failed.\");",
      "1473:   err(\"command 0x0e transfer failed.\");",
      "1478:   err(\"command 0x51 transfer failed.\");",
      "1481:  m88ds3103_pdata.clk = 27000000;",
      "1482:  m88ds3103_pdata.i2c_wr_max = 33;",
      "",
      "[Removed Lines]",
      "1442:  u8 obuf[3] = { 0xe, 0x80, 0 };",
      "1443:  u8 ibuf[] = { 0 };",
      "1450:  if (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
      "1453:  obuf[0] = 0xe;",
      "1454:  obuf[1] = 0x02;",
      "1455:  obuf[2] = 1;",
      "1457:  if (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
      "1461:  obuf[0] = 0xe;",
      "1462:  obuf[1] = 0x83;",
      "1463:  obuf[2] = 0;",
      "1465:  if (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
      "1468:  obuf[0] = 0xe;",
      "1469:  obuf[1] = 0x83;",
      "1470:  obuf[2] = 1;",
      "1472:  if (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
      "1475:  obuf[0] = 0x51;",
      "1477:  if (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)",
      "",
      "[Added Lines]",
      "1488:  mutex_lock(&d->data_mutex);",
      "1490:  state->data[0] = 0xe;",
      "1491:  state->data[1] = 0x80;",
      "1492:  state->data[2] = 0x0;",
      "1494:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1497:  state->data[0] = 0xe;",
      "1498:  state->data[1] = 0x02;",
      "1499:  state->data[2] = 1;",
      "1501:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1505:  state->data[0] = 0xe;",
      "1506:  state->data[1] = 0x83;",
      "1507:  state->data[2] = 0;",
      "1509:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1512:  state->data[0] = 0xe;",
      "1513:  state->data[1] = 0x83;",
      "1514:  state->data[2] = 1;",
      "1516:  if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
      "1519:  state->data[0] = 0x51;",
      "1521:  if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)",
      "1524:  mutex_unlock(&d->data_mutex);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0385443fec6b56b4b22f1940ab8607a074a5c17a",
      "candidate_info": {
        "commit_hash": "0385443fec6b56b4b22f1940ab8607a074a5c17a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0385443fec6b56b4b22f1940ab8607a074a5c17a",
        "files": [
          "drivers/media/usb/dvb-usb/dw2102.c"
        ],
        "message": "[media] Remove spurious blank lines in dw2101 kernel messages\n\nThe DW2102 DVB-S/S2 driver uses the info() logging function from\ndvb-usb.h. This function already appends a newline to the provided log\nmessage, causing the dmesg output from DW2102 to include blank lines.\nFix this by removing the newline in the calls to info().\n\nSigned-off-by: Jonathan McDowell <noodles@earth.li>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>",
        "before_after_code_files": [
          "drivers/media/usb/dvb-usb/dw2102.c||drivers/media/usb/dvb-usb/dw2102.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/media/usb/dvb-usb/dw2102.c||drivers/media/usb/dvb-usb/dw2102.c"
          ],
          "candidate": [
            "drivers/media/usb/dvb-usb/dw2102.c||drivers/media/usb/dvb-usb/dw2102.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/media/usb/dvb-usb/dw2102.c||drivers/media/usb/dvb-usb/dw2102.c": [
          "File: drivers/media/usb/dvb-usb/dw2102.c -> drivers/media/usb/dvb-usb/dw2102.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "847:  struct dw2102_state *state = (struct dw2102_state *)d->priv;",
          "848:  u8 obuf[] = {0xde, 0};",
          "852:  if (i && !state->initialized) {",
          "853:   state->initialized = 1;",
          "",
          "[Removed Lines]",
          "850:  info(\"%s: %d, initialized %d\\n\", __func__, i, state->initialized);",
          "",
          "[Added Lines]",
          "850:  info(\"%s: %d, initialized %d\", __func__, i, state->initialized);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "894:      struct dvb_usb_device_description **desc,",
          "895:      int *cold)",
          "896: {",
          "900:  return 0;",
          "",
          "[Removed Lines]",
          "897:  info(\"%s\\n\", __func__);",
          "",
          "[Added Lines]",
          "897:  info(\"%s\", __func__);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1132:     tuner_ops->set_bandwidth = stb6100_set_bandw;",
          "1133:     tuner_ops->get_bandwidth = stb6100_get_bandw;",
          "1134:     d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1136:     return 0;",
          "1137:    }",
          "1138:   }",
          "",
          "[Removed Lines]",
          "1135:     info(\"Attached STV0900+STB6100!\\n\");",
          "",
          "[Added Lines]",
          "1135:     info(\"Attached STV0900+STB6100!\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1146:      &dw2104_stv6110_config,",
          "1147:      &d->dev->i2c_adap)) {",
          "1148:     d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1150:     return 0;",
          "1151:    }",
          "1152:   }",
          "",
          "[Removed Lines]",
          "1149:     info(\"Attached STV0900+STV6110A!\\n\");",
          "",
          "[Added Lines]",
          "1149:     info(\"Attached STV0900+STV6110A!\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1157:     &d->dev->i2c_adap);",
          "1158:   if (d->fe_adap[0].fe != NULL) {",
          "1159:    d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1161:    return 0;",
          "1162:   }",
          "1163:  }",
          "",
          "[Removed Lines]",
          "1160:    info(\"Attached cx24116!\\n\");",
          "",
          "[Added Lines]",
          "1160:    info(\"Attached cx24116!\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1168:   dvb_attach(ts2020_attach, d->fe_adap[0].fe,",
          "1169:    &dw2104_ts2020_config, &d->dev->i2c_adap);",
          "1170:   d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1172:   return 0;",
          "1173:  }",
          "",
          "[Removed Lines]",
          "1171:   info(\"Attached DS3000!\\n\");",
          "",
          "[Added Lines]",
          "1171:   info(\"Attached DS3000!\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1187:      &d->dev->i2c_adap);",
          "1188:   if (d->fe_adap[0].fe != NULL) {",
          "1189:    d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1191:    return 0;",
          "1192:   }",
          "1193:  }",
          "",
          "[Removed Lines]",
          "1190:    info(\"Attached si21xx!\\n\");",
          "",
          "[Added Lines]",
          "1190:    info(\"Attached si21xx!\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1199:    if (dvb_attach(stb6000_attach, d->fe_adap[0].fe, 0x61,",
          "1200:      &d->dev->i2c_adap)) {",
          "1201:     d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1203:     return 0;",
          "1204:    }",
          "1205:   }",
          "",
          "[Removed Lines]",
          "1202:     info(\"Attached stv0288!\\n\");",
          "",
          "[Added Lines]",
          "1202:     info(\"Attached stv0288!\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1211:      &d->dev->i2c_adap);",
          "1212:   if (d->fe_adap[0].fe != NULL) {",
          "1213:    d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1215:    return 0;",
          "1216:   }",
          "1217:  }",
          "",
          "[Removed Lines]",
          "1214:    info(\"Attached stv0299!\\n\");",
          "",
          "[Added Lines]",
          "1214:    info(\"Attached stv0299!\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1223:  d->fe_adap[0].fe = dvb_attach(tda10023_attach, &dw3101_tda10023_config,",
          "1224:     &d->dev->i2c_adap, 0x48);",
          "1225:  if (d->fe_adap[0].fe != NULL) {",
          "1227:   return 0;",
          "1228:  }",
          "1229:  return -EIO;",
          "",
          "[Removed Lines]",
          "1226:   info(\"Attached tda10023!\\n\");",
          "",
          "[Added Lines]",
          "1226:   info(\"Attached tda10023!\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1237:   if (dvb_attach(zl10039_attach, d->fe_adap[0].fe, 0x60,",
          "1238:     &d->dev->i2c_adap)) {",
          "1239:    d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;",
          "1241:    return 0;",
          "1242:   }",
          "1243:  }",
          "",
          "[Removed Lines]",
          "1240:    info(\"Attached zl100313+zl10039!\\n\");",
          "",
          "[Added Lines]",
          "1240:    info(\"Attached zl100313+zl10039!\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1263:  dw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);",
          "1267:  return 0;",
          "",
          "[Removed Lines]",
          "1265:  info(\"Attached stv0288+stb6000!\\n\");",
          "",
          "[Added Lines]",
          "1265:  info(\"Attached stv0288+stb6000!\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1288:  dw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);",
          "1292:  return 0;",
          "1293: }",
          "",
          "[Removed Lines]",
          "1290:  info(\"Attached ds3000+ts2020!\\n\");",
          "",
          "[Added Lines]",
          "1290:  info(\"Attached ds3000+ts2020!\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1306:  dw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);",
          "1310:  return 0;",
          "1311: }",
          "",
          "[Removed Lines]",
          "1308:  info(\"Attached STV0900+STB6100A!\\n\");",
          "",
          "[Added Lines]",
          "1308:  info(\"Attached STV0900+STB6100A!\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1353:  if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,",
          "1354:     &dw2104_ts2020_config,",
          "1355:     &d->dev->i2c_adap)) {",
          "1357:   return 0;",
          "1358:  }",
          "1361:  return -EIO;",
          "1362: }",
          "",
          "[Removed Lines]",
          "1356:   info(\"Attached DS3000/TS2020!\\n\");",
          "1360:  info(\"Failed to attach DS3000/TS2020!\\n\");",
          "",
          "[Added Lines]",
          "1356:   info(\"Attached DS3000/TS2020!\");",
          "1360:  info(\"Failed to attach DS3000/TS2020!\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1402:  if (d->fe_adap[0].fe != NULL) {",
          "1403:   if (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,",
          "1404:      &d->dev->i2c_adap, &tda18271_config)) {",
          "1406:    return 0;",
          "1407:   }",
          "1408:  }",
          "1411:  return -EIO;",
          "1412: }",
          "",
          "[Removed Lines]",
          "1405:    info(\"Attached TDA18271HD/CXD2820R!\\n\");",
          "1410:  info(\"Failed to attach TDA18271HD/CXD2820R!\\n\");",
          "",
          "[Added Lines]",
          "1405:    info(\"Attached TDA18271HD/CXD2820R!\");",
          "1410:  info(\"Failed to attach TDA18271HD/CXD2820R!\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1428:  if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,",
          "1429:     &dw2104_ts2020_config,",
          "1430:     &d->dev->i2c_adap)) {",
          "1432:   return 0;",
          "1433:  }",
          "1436:  return -EIO;",
          "1437: }",
          "",
          "[Removed Lines]",
          "1431:   info(\"Attached RS2000/TS2020!\\n\");",
          "1435:  info(\"Failed to attach RS2000/TS2020!\\n\");",
          "",
          "[Added Lines]",
          "1431:   info(\"Attached RS2000/TS2020!\");",
          "1435:  info(\"Failed to attach RS2000/TS2020!\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
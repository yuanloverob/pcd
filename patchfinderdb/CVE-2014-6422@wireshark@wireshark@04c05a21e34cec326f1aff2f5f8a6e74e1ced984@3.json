{
  "cve_id": "CVE-2014-6422",
  "cve_desc": "The SDP dissector in Wireshark 1.10.x before 1.10.10 creates duplicate hashtables for a media channel, which allows remote attackers to cause a denial of service (application crash) via a crafted packet to the RTP dissector.",
  "repo": "wireshark/wireshark",
  "patch_hash": "04c05a21e34cec326f1aff2f5f8a6e74e1ced984",
  "patch_info": {
    "commit_hash": "04c05a21e34cec326f1aff2f5f8a6e74e1ced984",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/04c05a21e34cec326f1aff2f5f8a6e74e1ced984",
    "files": [
      "asn1/h245/packet-h245-template.c",
      "epan/dissectors/packet-ansi_a.c",
      "epan/dissectors/packet-applemidi.c",
      "epan/dissectors/packet-h245.c",
      "epan/dissectors/packet-rtp.c",
      "epan/dissectors/packet-rtp.h",
      "epan/dissectors/packet-sdp.c",
      "ui/gtk/voip_calls.c"
    ],
    "message": "Fix Bug 9920 Buildbot crash due to SDP/RTP mismatch\n\nFor details see comments in Bug 9920.\n\nThe executive summary:\nBug 9920 is a crash caused by a couple of issues:\n\n1) The memory ownership model for the rtp_dyn_payload hashtable is split: SDP\ncreates the rtp_dyn_payload hashtable, but RTP can free it. Since there isn't\n*one* pointer to the hashtable, RTP freeing it means SDP has a dangling\npointer.\n\n2) Either the SDP dissector shouldn't be creating two separate, unique\nhashtables for multiple media channels of the same addr:port, or RTP shouldn't\nbe free'ing the previous one.\n\nChange-Id: I436e67de6882f84aa82dcbdfe60bf313fe4fd99c\nReviewed-on: https://code.wireshark.org/review/918\nReviewed-by: Hadriel Kaplan <hadrielk@yahoo.com>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "asn1/h245/packet-h245-template.c||asn1/h245/packet-h245-template.c",
      "epan/dissectors/packet-ansi_a.c||epan/dissectors/packet-ansi_a.c",
      "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c",
      "epan/dissectors/packet-h245.c||epan/dissectors/packet-h245.c",
      "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
      "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h",
      "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c",
      "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c"
    ]
  },
  "patch_diff": {
    "asn1/h245/packet-h245-template.c||asn1/h245/packet-h245-template.c": [
      "File: asn1/h245/packet-h245-template.c -> asn1/h245/packet-h245-template.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "342: static void h245_setup_channels(packet_info *pinfo, channel_info_t *upcoming_channel_lcl)",
      "343: {",
      "346:  struct srtp_info *dummy_srtp_info = NULL;",
      "348:  if (!upcoming_channel_lcl) return;",
      "",
      "[Removed Lines]",
      "344:  gint *key;",
      "345:  GHashTable *rtp_dyn_payload = NULL;",
      "",
      "[Added Lines]",
      "344:  rtp_dyn_payload_t *rtp_dyn_payload = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "361:  if (upcoming_channel_lcl->rfc2198 > 0) {",
      "369:  }",
      "371:  if (upcoming_channel_lcl->srtp_flag) {",
      "",
      "[Removed Lines]",
      "362:   encoding_name_and_rate_t *encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "363:   rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
      "364:   encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), \"red\");",
      "365:   encoding_name_and_rate->sample_rate = 8000;",
      "366:   key = wmem_new(wmem_file_scope(), gint);",
      "368:   g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
      "",
      "[Added Lines]",
      "361:   rtp_dyn_payload = rtp_dyn_payload_new();",
      "362:   rtp_dyn_payload_insert(rtp_dyn_payload, upcoming_channel_lcl->rfc2198, \"red\", 8000);",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-ansi_a.c||epan/dissectors/packet-ansi_a.c": [
      "File: epan/dissectors/packet-ansi_a.c -> epan/dissectors/packet-ansi_a.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6905:     gboolean                            first_assigned_found;",
      "6906:     gboolean                            rtp_dyn_payload_used;",
      "6907:     guint8                              rtp_payload_type;",
      "6913:     rtp_dyn_payload_used = FALSE;",
      "6915:     first_assigned_found = FALSE;",
      "",
      "[Removed Lines]",
      "6908:     GHashTable                          *rtp_dyn_payload;",
      "6909:     gint                                *key;",
      "6910:     encoding_name_and_rate_t            *encoding_name_and_rate;",
      "6912:     rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
      "",
      "[Added Lines]",
      "6908:     rtp_dyn_payload_t                  *rtp_dyn_payload;",
      "6910:     rtp_dyn_payload = rtp_dyn_payload_new();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "7066:         if (format_assigned &&",
      "7067:             (first_assigned_found == FALSE))",
      "7068:         {",
      "7077:             rtp_dyn_payload_used = TRUE;",
      "7079:             first_assigned_found = TRUE;",
      "",
      "[Removed Lines]",
      "7069:             key  = wmem_new(wmem_file_scope(), gint);",
      "7072:             encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "7073:             encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), mime_type);",
      "7074:             encoding_name_and_rate->sample_rate = sample_rate;",
      "7076:             g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
      "",
      "[Added Lines]",
      "7067:             rtp_dyn_payload_insert(rtp_dyn_payload, rtp_payload_type, mime_type, sample_rate);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "7084:         if (in_band_format_assigned)",
      "7085:         {",
      "7094:             rtp_dyn_payload_used = TRUE;",
      "7095:         }",
      "",
      "[Removed Lines]",
      "7086:             key  = (gint *) wmem_alloc(wmem_file_scope(), sizeof(gint));",
      "7089:             encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "7090:             encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), \"telephone-event\");",
      "7091:             encoding_name_and_rate->sample_rate = sample_rate;",
      "7093:             g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
      "",
      "[Added Lines]",
      "7077:             rtp_dyn_payload_insert(rtp_dyn_payload, rtp_payload_type, \"telephone-event\", sample_rate);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "7100:     if (rtp_dyn_payload_used == FALSE)",
      "7101:     {",
      "7103:     }",
      "7105:     EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);",
      "",
      "[Removed Lines]",
      "7102:         rtp_free_hash_dyn_payload(rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "7086:         rtp_dyn_payload_free(rtp_dyn_payload);",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c": [
      "File: epan/dissectors/packet-applemidi.c -> epan/dissectors/packet-applemidi.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "285:  guint16   command;",
      "286:  conversation_t *p_conv;",
      "292:  if ( tvb_length( tvb ) < 4)",
      "",
      "[Removed Lines]",
      "288:  encoding_name_and_rate_t *encoding_name_and_rate = NULL;",
      "289:  GHashTable *rtp_dyn_payload = NULL;",
      "290:  gint *key;",
      "",
      "[Added Lines]",
      "288:  rtp_dyn_payload_t *rtp_dyn_payload = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "309:         rtp_add_address( pinfo, &pinfo->src, pinfo->srcport, 0, APPLEMIDI_DISSECTOR_SHORTNAME,",
      "310:     pinfo->fd->num, FALSE, rtp_dyn_payload);",
      "",
      "[Removed Lines]",
      "302:  encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "303:  rtp_dyn_payload = g_hash_table_new( g_int_hash, g_int_equal );",
      "304:  encoding_name_and_rate->encoding_name = wmem_strdup( wmem_file_scope(), \"rtp-midi\" );",
      "305:  encoding_name_and_rate->sample_rate = 10000;",
      "306:  key = wmem_new(wmem_file_scope(), gint);",
      "308:  g_hash_table_insert( rtp_dyn_payload, key, encoding_name_and_rate );",
      "",
      "[Added Lines]",
      "300:  rtp_dyn_payload = rtp_dyn_payload_new();",
      "301:  rtp_dyn_payload_insert(rtp_dyn_payload, 97, \"rtp-midi\", 10000);",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-h245.c||epan/dissectors/packet-h245.c": [
      "File: epan/dissectors/packet-h245.c -> epan/dissectors/packet-h245.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "473: static void h245_setup_channels(packet_info *pinfo, channel_info_t *upcoming_channel_lcl)",
      "474: {",
      "477:  struct srtp_info *dummy_srtp_info = NULL;",
      "479:  if (!upcoming_channel_lcl) return;",
      "",
      "[Removed Lines]",
      "475:  gint *key;",
      "476:  GHashTable *rtp_dyn_payload = NULL;",
      "",
      "[Added Lines]",
      "475:  rtp_dyn_payload_t *rtp_dyn_payload = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "492:  if (upcoming_channel_lcl->rfc2198 > 0) {",
      "500:  }",
      "502:  if (upcoming_channel_lcl->srtp_flag) {",
      "",
      "[Removed Lines]",
      "493:   encoding_name_and_rate_t *encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "494:   rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
      "495:   encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), \"red\");",
      "496:   encoding_name_and_rate->sample_rate = 8000;",
      "497:   key = wmem_new(wmem_file_scope(), gint);",
      "499:   g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
      "",
      "[Added Lines]",
      "492:   rtp_dyn_payload = rtp_dyn_payload_new();",
      "493:   rtp_dyn_payload_insert(rtp_dyn_payload, upcoming_channel_lcl->rfc2198, \"red\", 8000);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1932: static int ett_h245 = -1;",
      "",
      "[Removed Lines]",
      "1929: #line 392 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "[Added Lines]",
      "1923: #line 386 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2427: static gint ett_h245_MobileMultilinkReconfigurationIndication = -1;",
      "2433: static int dissect_h245_MultimediaSystemControlMessage(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_);",
      "",
      "[Removed Lines]",
      "2430: #line 397 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "[Added Lines]",
      "2424: #line 391 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "14499: static void",
      "14500: dissect_h245(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree)",
      "",
      "[Removed Lines]",
      "14497: #line 406 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "[Added Lines]",
      "14491: #line 400 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "20188:         NULL, HFILL }},",
      "20192:   };",
      "",
      "[Removed Lines]",
      "20191: #line 487 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "[Added Lines]",
      "20185: #line 481 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "20691:     &ett_h245_MobileMultilinkReconfigurationIndication,",
      "20695:   };",
      "20696:   module_t *h245_module;",
      "",
      "[Removed Lines]",
      "20694: #line 494 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "[Added Lines]",
      "20688: #line 488 \"../../asn1/h245/packet-h245-template.c\"",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
      "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "102:     wmem_tree_t *multisegment_pdus;",
      "103: } rtp_private_conv_info;",
      "105: static reassembly_table rtp_reassembly_table;",
      "107: static int hf_rtp_fragments = -1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "105: typedef struct {",
      "106:     char *encoding_name;",
      "107:     int   sample_rate;",
      "108: } encoding_name_and_rate_t;",
      "110: struct _rtp_dyn_payload_t",
      "111: {",
      "112:     GHashTable *table;",
      "113:     size_t ref_count;",
      "114: };",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "809: #ifdef DEBUG_CONVERSATION",
      "811: static void",
      "814:     encoding_name_and_rate_t *encoding = (encoding_name_and_rate_t*) value;",
      "817:     if (encoding) {",
      "818:         DPRINT2((\"encoding_name=%s\",",
      "819:                 encoding->encoding_name ? encoding->encoding_name : \"NULL\"));",
      "",
      "[Removed Lines]",
      "812: rtp_dyn_payload_table_foreach_func (gpointer key, gpointer value, gpointer user_data _U_) {",
      "813:     gint* pt = (gint*) key;",
      "816:     DPRINT2((\"pt=%d\",*pt));",
      "",
      "[Added Lines]",
      "823: rtp_dyn_payload_table_foreach_func(gpointer key, gpointer value, gpointer user_data _U_) {",
      "824:     guint pt = GPOINTER_TO_UINT(key);",
      "827:     DPRINT2((\"pt=%d\",pt));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "822:         DPRINT2((\"encoding=NULL\"));",
      "823:     }",
      "824: }",
      "826:     DPRINT2((\"rtp_dyn_payload hash table contents:\"));",
      "827:     DINDENT();",
      "838:     DENDENT();",
      "839: }",
      "",
      "[Removed Lines]",
      "825: static void rtp_dump_dyn_payload(GHashTable *rtp_dyn_payload) {",
      "828:     if (!rtp_dyn_payload) {",
      "829:         DPRINT2((\"null rtp_dyn_payload\"));",
      "830:         DENDENT();",
      "831:         return;",
      "832:     }",
      "833:     if (g_hash_table_size(rtp_dyn_payload) == 0) {",
      "834:         DPRINT2((\"rtp_dyn_payload is empty\"));",
      "835:     } else {",
      "836:         g_hash_table_foreach(rtp_dyn_payload, rtp_dyn_payload_table_foreach_func, NULL);",
      "837:     }",
      "",
      "[Added Lines]",
      "837: void",
      "838: rtp_dump_dyn_payload(rtp_dyn_payload_t *rtp_dyn_payload) {",
      "841:         if (!rtp_dyn_payload) {",
      "842:             DPRINT2((\"null pointer to rtp_dyn_payload\"));",
      "843:             DENDENT();",
      "844:             return;",
      "845:         }",
      "846:         DPRINT2((\"ref_count=%\" G_GSIZE_FORMAT, rtp_dyn_payload->ref_count));",
      "847:         if (!rtp_dyn_payload->table) {",
      "848:             DPRINT2((\"null rtp_dyn_payload table\"));",
      "849:             DENDENT();",
      "850:             return;",
      "851:         }",
      "852:         if (g_hash_table_size(rtp_dyn_payload->table) == 0) {",
      "853:             DPRINT2((\"rtp_dyn_payload has no entries\"));",
      "854:         } else {",
      "855:             g_hash_table_foreach(rtp_dyn_payload->table, rtp_dyn_payload_table_foreach_func, NULL);",
      "856:         }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "847:                   &addresses_reassembly_table_functions);",
      "848: }",
      "850: void",
      "852: {",
      "856: }",
      "859: void",
      "860: bluetooth_add_address(packet_info *pinfo, address *addr,",
      "",
      "[Removed Lines]",
      "851: rtp_free_hash_dyn_payload(GHashTable *rtp_dyn_payload)",
      "853:     if (rtp_dyn_payload == NULL) return;",
      "854:     g_hash_table_destroy(rtp_dyn_payload);",
      "855:     rtp_dyn_payload = NULL;",
      "",
      "[Added Lines]",
      "870:    This is necessary because we need to g_hash_table_destroy() them, either individually or",
      "871:    all at once at the end of the wmem file scope. Since rtp_dyn_payload_free() removes them",
      "872:    individually, we need to remove those then; and when the file scope is over, we have a",
      "873:    single registered callback walk this GHashTable and destroy each member as well as this",
      "874:    GHashTable.",
      "876: static GHashTable *rtp_dyn_payloads = NULL;",
      "880: static void",
      "881: rtp_dyn_payload_value_destroy(gpointer data)",
      "882: {",
      "883:     encoding_name_and_rate_t *encoding_name_and_rate_pt = (encoding_name_and_rate_t*) data;",
      "884:     wmem_free(wmem_file_scope(), encoding_name_and_rate_pt->encoding_name);",
      "885:     wmem_free(wmem_file_scope(), encoding_name_and_rate_pt);",
      "886: }",
      "889: static gboolean",
      "890: rtp_dyn_payloads_table_steal_func(gpointer key _U_, gpointer value, gpointer user_data _U_)",
      "891: {",
      "892:     rtp_dyn_payload_t *rtp_dyn_payload = (rtp_dyn_payload_t *)value;",
      "894: #ifdef DEBUG_CONVERSATION",
      "895:     DPRINT((\"about to steal_all and destroy the following:\"));",
      "896:     DINDENT();",
      "897:     rtp_dump_dyn_payload(rtp_dyn_payload);",
      "898:     DENDENT();",
      "899: #endif",
      "901:     if (rtp_dyn_payload->ref_count == 0) {",
      "903:         g_error(\"rtp_dyn_payload cannot be free'd because it should already have been!\\n\");",
      "904:     }",
      "905:     else if (rtp_dyn_payload->table) {",
      "908:         g_hash_table_steal_all(rtp_dyn_payload->table);",
      "909:         g_hash_table_destroy(rtp_dyn_payload->table);",
      "910:     }",
      "912:     return TRUE;",
      "913: }",
      "916:    which are pointed to by the single rtp_dyn_payloads GHashTable above.",
      "918: static gboolean",
      "919: wmem_rtp_dyn_payload_destroy_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event _U_,",
      "920:         void *user_data _U_)",
      "921: {",
      "922:     g_assert(rtp_dyn_payloads);",
      "924:     DPRINT((\"destroying %u remaining rtp_dyn_payload_t's\", g_hash_table_size(rtp_dyn_payloads)));",
      "928:     g_hash_table_foreach_steal(rtp_dyn_payloads, rtp_dyn_payloads_table_steal_func, NULL);",
      "929:     g_hash_table_destroy(rtp_dyn_payloads);",
      "930:     rtp_dyn_payloads = NULL;",
      "933:     return FALSE;",
      "934: }",
      "937:    but those are called both at init and cleanup times, and the cleanup time is before",
      "938:    wmem scope is exited, so we ignore this if rtp_dyn_payloads is not NULL.",
      "940: static void",
      "941: rtp_dyn_payloads_init(void)",
      "942: {",
      "943:     if (rtp_dyn_payloads == NULL) {",
      "944:         rtp_dyn_payloads = g_hash_table_new(NULL, NULL);",
      "945:         wmem_register_callback(wmem_file_scope(), wmem_rtp_dyn_payload_destroy_cb, NULL);",
      "946:     }",
      "947: }",
      "950: rtp_dyn_payload_t* rtp_dyn_payload_new(void)",
      "951: {",
      "953:     rtp_dyn_payload_t * rtp_dyn_payload = wmem_new(wmem_file_scope(), rtp_dyn_payload_t);",
      "954:     rtp_dyn_payload->table = g_hash_table_new_full(NULL, NULL, NULL, rtp_dyn_payload_value_destroy);",
      "955:     rtp_dyn_payload->ref_count = 1;",
      "958:     g_hash_table_insert(rtp_dyn_payloads, rtp_dyn_payload, rtp_dyn_payload);",
      "960:     return rtp_dyn_payload;",
      "961: }",
      "963: static rtp_dyn_payload_t*",
      "964: rtp_dyn_payload_ref(rtp_dyn_payload_t *rtp_dyn_payload)",
      "965: {",
      "966:     if (rtp_dyn_payload) {",
      "967:         rtp_dyn_payload->ref_count++;",
      "968:     }",
      "969:     return rtp_dyn_payload;",
      "970: }",
      "973:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
      "976: rtp_dyn_payload_insert(rtp_dyn_payload_t *rtp_dyn_payload,",
      "977:                        const guint8 pt,",
      "978:                        const gchar* encoding_name,",
      "979:                        const int sample_rate)",
      "980: {",
      "981:     if (rtp_dyn_payload && rtp_dyn_payload->table) {",
      "982:         encoding_name_and_rate_t *encoding_name_and_rate_pt =",
      "983:                     wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "984:         encoding_name_and_rate_pt->encoding_name = wmem_strdup(wmem_file_scope(), encoding_name);",
      "985:         encoding_name_and_rate_pt->sample_rate = sample_rate;",
      "986:         g_hash_table_insert(rtp_dyn_payload->table, GUINT_TO_POINTER(pt), encoding_name_and_rate_pt);",
      "987:     }",
      "988: }",
      "991:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
      "993: void",
      "994: rtp_dyn_payload_replace(rtp_dyn_payload_t *rtp_dyn_payload,",
      "995:                         const guint8 pt,",
      "996:                         const gchar* encoding_name,",
      "997:                         const int sample_rate)",
      "998: {",
      "999:     if (rtp_dyn_payload && rtp_dyn_payload->table) {",
      "1000:         encoding_name_and_rate_t *encoding_name_and_rate_pt =",
      "1001:                     wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "1002:         encoding_name_and_rate_pt->encoding_name = wmem_strdup(wmem_file_scope(), encoding_name);",
      "1003:         encoding_name_and_rate_pt->sample_rate = sample_rate;",
      "1004:         g_hash_table_replace(rtp_dyn_payload->table, GUINT_TO_POINTER(pt), encoding_name_and_rate_pt);",
      "1005:     }",
      "1006: }",
      "1009: gboolean",
      "1010: rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt)",
      "1012:     return (rtp_dyn_payload && rtp_dyn_payload->table &&",
      "1013:             g_hash_table_remove(rtp_dyn_payload->table, GUINT_TO_POINTER(pt)));",
      "1014: }",
      "1017: const gchar*",
      "1018: rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt)",
      "1019: {",
      "1020:     encoding_name_and_rate_t *encoding_name_and_rate_pt;",
      "1022:     if (!rtp_dyn_payload || !rtp_dyn_payload->table) return NULL;",
      "1024:     encoding_name_and_rate_pt = (encoding_name_and_rate_t*)g_hash_table_lookup(rtp_dyn_payload->table,",
      "1025:                                                                                GUINT_TO_POINTER(pt));",
      "1027:     return (encoding_name_and_rate_pt ? encoding_name_and_rate_pt->encoding_name : NULL);",
      "1028: }",
      "1031:    successful, else FALSE. The encoding string pointed to is only valid until the entry is",
      "1033: gboolean",
      "1034: rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt,",
      "1035:                          const gchar **encoding_name, int *sample_rate)",
      "1036: {",
      "1037:     encoding_name_and_rate_t *encoding_name_and_rate_pt;",
      "1041:     if (!rtp_dyn_payload || !rtp_dyn_payload->table) return FALSE;",
      "1043:     encoding_name_and_rate_pt = (encoding_name_and_rate_t*)g_hash_table_lookup(rtp_dyn_payload->table,",
      "1044:                                                                                GUINT_TO_POINTER(pt));",
      "1046:     if (encoding_name_and_rate_pt) {",
      "1049:     }",
      "1051:     return (encoding_name_and_rate_pt != NULL);",
      "1056: void",
      "1057: rtp_dyn_payload_free(rtp_dyn_payload_t *rtp_dyn_payload)",
      "1058: {",
      "1059:     if (!rtp_dyn_payload) return;",
      "1061:     if (rtp_dyn_payload->ref_count > 0)",
      "1062:         --(rtp_dyn_payload->ref_count);",
      "1064:     if (rtp_dyn_payload->ref_count == 0) {",
      "1066: #ifdef DEBUG_CONVERSATION",
      "1067:         DPRINT((\"free'ing the following rtp_dyn_payload:\"));",
      "1068:         DINDENT();",
      "1069:         rtp_dump_dyn_payload(rtp_dyn_payload);",
      "1070:         DENDENT();",
      "1071: #endif",
      "1074:         g_assert(rtp_dyn_payloads);",
      "1075:         if (!g_hash_table_remove(rtp_dyn_payloads, rtp_dyn_payload)) {",
      "1076:             g_error(\"rtp_dyn_payload not found in rtp_dyn_payloads table to remove!\");",
      "1077:         }",
      "1081:         if (rtp_dyn_payload->table)",
      "1082:             g_hash_table_destroy(rtp_dyn_payload->table);",
      "1085:         wmem_free(wmem_file_scope(), rtp_dyn_payload);",
      "1086:     }",
      "1087: }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "933:     g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
      "934:     p_conv_data->frame_number = setup_frame_number;",
      "",
      "[Removed Lines]",
      "931:     rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "1161:     rtp_dyn_payload_free(p_conv_data->rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "941: void",
      "942: srtp_add_address(packet_info *pinfo, address *addr, int port, int other_port,",
      "943:          const gchar *setup_method, guint32 setup_frame_number,",
      "945:          struct srtp_info *srtp_info)",
      "946: {",
      "947:     address null_addr;",
      "",
      "[Removed Lines]",
      "944:          gboolean is_video _U_, GHashTable *rtp_dyn_payload,",
      "",
      "[Added Lines]",
      "1174:          gboolean is_video _U_, rtp_dyn_payload_t *rtp_dyn_payload,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1028:     g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
      "1029:     p_conv_data->frame_number = setup_frame_number;",
      "1030:     p_conv_data->is_video = is_video;",
      "1032:     p_conv_data->srtp_info = srtp_info;",
      "1033:     p_conv_data->bta2dp_info = NULL;",
      "1034:     p_conv_data->btvdp_info = NULL;",
      "",
      "[Removed Lines]",
      "1025:     if (p_conv_data->rtp_dyn_payload != rtp_dyn_payload)",
      "1026:         rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
      "1031:     p_conv_data->rtp_dyn_payload = rtp_dyn_payload;",
      "",
      "[Added Lines]",
      "1255:     if (p_conv_data->rtp_dyn_payload != rtp_dyn_payload) {",
      "1256:         rtp_dyn_payload_free(p_conv_data->rtp_dyn_payload);",
      "1257:         p_conv_data->rtp_dyn_payload = rtp_dyn_payload_ref(rtp_dyn_payload);",
      "1258:     } else {",
      "1259:         DPRINT((\"passed-in rtp_dyn_payload is the same as in the conversation\"));",
      "1260:     }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1038: void",
      "1039: rtp_add_address(packet_info *pinfo, address *addr, int port, int other_port,",
      "1040:         const gchar *setup_method, guint32 setup_frame_number,",
      "1042: {",
      "1043:     srtp_add_address(pinfo, addr, port, other_port, setup_method, setup_frame_number, is_video, rtp_dyn_payload, NULL);",
      "1044: }",
      "",
      "[Removed Lines]",
      "1041:         gboolean is_video , GHashTable *rtp_dyn_payload)",
      "",
      "[Added Lines]",
      "1274:         gboolean is_video , rtp_dyn_payload_t *rtp_dyn_payload)",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1163:             payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {",
      "1165:         if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
      "1173:                 found_match = dissector_try_string(rtp_dyn_pt_dissector_table,",
      "1174:                                    payload_type_str, newtvb, pinfo, tree, NULL);",
      "",
      "[Removed Lines]",
      "1166:             gchar *payload_type_str = NULL;",
      "1167:             encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
      "1168:             encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
      "1169:             if (encoding_name_and_rate_pt) {",
      "1170:                 payload_type_str = encoding_name_and_rate_pt->encoding_name;",
      "1171:             }",
      "1172:             if (payload_type_str){",
      "",
      "[Added Lines]",
      "1399:             const gchar *payload_type_str = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, payload_type);",
      "1400:             if (payload_type_str) {",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1452:     rfc2198_hdr *hdr_last, *hdr_new;",
      "1453:     rfc2198_hdr *hdr_chain = NULL;",
      "1454:     struct _rtp_conversation_info *p_conv_data= NULL;",
      "1458:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
      "",
      "[Removed Lines]",
      "1455:     gchar *payload_type_str;",
      "",
      "[Added Lines]",
      "1683:     const gchar *payload_type_str;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1478:         if ((hdr_new->pt > 95) && (hdr_new->pt < 128)) {",
      "1479:             if (p_conv_data && p_conv_data->rtp_dyn_payload){",
      "1485:             }",
      "1486:         }",
      "",
      "[Removed Lines]",
      "1480:                 encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
      "1481:                 encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &hdr_new->pt);",
      "1482:                 if (encoding_name_and_rate_pt) {",
      "1483:                     payload_type_str = encoding_name_and_rate_pt->encoding_name;",
      "1484:                 }",
      "",
      "[Added Lines]",
      "1708:                 payload_type_str = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, hdr_new->pt);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1645:     unsigned int csrc_count;",
      "1646:     gboolean    marker_set;",
      "1647:     unsigned int payload_type;",
      "1649:     gboolean    is_srtp = FALSE;",
      "1650:     unsigned int i            = 0;",
      "1651:     unsigned int hdr_extension_len= 0;",
      "",
      "[Removed Lines]",
      "1648:     gchar *payload_type_str = NULL;",
      "",
      "[Added Lines]",
      "1872:     const gchar *payload_type_str = NULL;",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1828:     if ( (payload_type>95) && (payload_type<128) ) {",
      "1832: #ifdef DEBUG_CONVERSATION",
      "1833:             rtp_dump_dyn_payload(p_conv_data->rtp_dyn_payload);",
      "1834: #endif",
      "1835:             DPRINT((\"looking up conversation data for dyn_pt=%d\", payload_type));",
      "1843:                 DPRINT((\"found conversation data for dyn_pt=%d, enc_name=%s\",",
      "1847:             }",
      "1848:         }",
      "1849:     }",
      "",
      "[Removed Lines]",
      "1829:         if (p_conv_data && p_conv_data->rtp_dyn_payload){",
      "1830:             encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
      "1837:             encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
      "1839:             DPRINT((\"did %sfind conversation data for dyn_pt=%d\",",
      "1840:                     encoding_name_and_rate_pt?\"\":\"not \", payload_type));",
      "1842:             if (encoding_name_and_rate_pt) {",
      "1844:                         payload_type,encoding_name_and_rate_pt->encoding_name));",
      "1845:                 rtp_info->info_payload_type_str = payload_type_str = encoding_name_and_rate_pt->encoding_name;",
      "1846:                 rtp_info->info_payload_rate = encoding_name_and_rate_pt->sample_rate;",
      "",
      "[Added Lines]",
      "2053:         if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
      "2054:             int sample_rate = 0;",
      "2061:             if (rtp_dyn_payload_get_full(p_conv_data->rtp_dyn_payload, payload_type,",
      "2062:                                         &payload_type_str, &sample_rate)) {",
      "2064:                         payload_type, payload_type_str));",
      "2065:                 rtp_info->info_payload_type_str = payload_type_str;",
      "2066:                 rtp_info->info_payload_rate     = sample_rate;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3338:                                     &rtp_rfc2198_pt);",
      "3340:     register_init_routine(rtp_fragment_init);",
      "3341: }",
      "3343: void",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3564:     register_init_routine(rtp_dyn_payloads_init);",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h": [
      "File: epan/dissectors/packet-rtp.h -> epan/dissectors/packet-rtp.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "100: #endif",
      "101: };",
      "104: #define MAX_RTP_SETUP_METHOD_SIZE 7",
      "105: struct _rtp_conversation_info",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "104: typedef struct _rtp_dyn_payload_t rtp_dyn_payload_t;",
      "107:    dynamic payload information. Internally, RTP creates the GHashTable with a wmem file scope",
      "108:    and increments the ref_count when it saves the info to conversations later. The calling",
      "109:    dissector (SDP, H.245, etc.) uses these functions as an interface. If the calling dissector",
      "110:    is done with the rtp_dyn_payload_t* for good, it should call rtp_dyn_payload_free() which",
      "111:    will decrement the ref_count and free's it if the ref_count is 0. In the worst case, it",
      "112:    will get free'd when the wmem file scope is over.",
      "114:    This was changed because there were too many bugs with SDP's handling of memory ownership",
      "115:    of the GHashTable, with RTP freeing things SDP didn't think were free'ed. And also because",
      "116:    the GHashTables never got free'd in many cases by several dissectors.",
      "120: WS_DLL_PUBLIC",
      "121: rtp_dyn_payload_t* rtp_dyn_payload_new(void);",
      "124:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
      "126: WS_DLL_PUBLIC",
      "127: void rtp_dyn_payload_insert(rtp_dyn_payload_t *rtp_dyn_payload,",
      "128:        const guint8 pt,",
      "129:        const gchar* encoding_name,",
      "130:        const int sample_rate);",
      "133:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
      "135: WS_DLL_PUBLIC",
      "136: void rtp_dyn_payload_replace(rtp_dyn_payload_t *rtp_dyn_payload,",
      "137:        const guint8 pt,",
      "138:        const gchar* encoding_name,",
      "139:        const int sample_rate);",
      "142: WS_DLL_PUBLIC",
      "143: gboolean rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt);",
      "146:    until the entry is replaced, removed, or the hash table is destroyed, so duplicate it if",
      "148: WS_DLL_PUBLIC",
      "149: const gchar* rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt);",
      "152:    successful, else FALSE. The encoding string pointed to is only valid until the entry is",
      "154: WS_DLL_PUBLIC",
      "155: gboolean rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt,",
      "156:           const gchar **encoding_name, int *sample_rate);",
      "160: WS_DLL_PUBLIC",
      "161: void rtp_dyn_payload_free(rtp_dyn_payload_t *rtp_dyn_payload);",
      "164: #ifdef DEBUG_CONVERSATION",
      "166: void rtp_dump_dyn_payload(rtp_dyn_payload_t *rtp_dyn_payload);",
      "167: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "121:  btvdp_codec_info_t *btvdp_info;",
      "122: };",
      "130: WS_DLL_PUBLIC",
      "131: void rtp_add_address(packet_info *pinfo,",
      "",
      "[Removed Lines]",
      "124: typedef struct {",
      "125:  char *encoding_name;",
      "126:  int   sample_rate;",
      "127: } encoding_name_and_rate_t;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "134:                      const gchar *setup_method,",
      "135:                      guint32 setup_frame_number,",
      "136:       gboolean is_video,",
      "140: WS_DLL_PUBLIC",
      "",
      "[Removed Lines]",
      "137:                      GHashTable *rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "198:                      rtp_dyn_payload_t *rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "144:                      const gchar *setup_method,",
      "145:                      guint32 setup_frame_number,",
      "146:       gboolean is_video,",
      "148:                      struct srtp_info *srtp_info);",
      "",
      "[Removed Lines]",
      "147:                      GHashTable *rtp_dyn_payload,",
      "",
      "[Added Lines]",
      "208:                      rtp_dyn_payload_t *rtp_dyn_payload,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "152: bluetooth_add_address(packet_info *pinfo, address *addr,",
      "153:          const gchar *setup_method, guint32 setup_frame_number,",
      "154:          gboolean is_video, void *data);",
      "",
      "[Removed Lines]",
      "157: WS_DLL_PUBLIC",
      "158: void rtp_free_hash_dyn_payload(GHashTable *rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c": [
      "File: epan/dissectors/packet-sdp.c -> epan/dissectors/packet-sdp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "41: #include <epan/addr_resolv.h>",
      "43: #include \"packet-sdp.h\"",
      "44: #include \"packet-rtp.h\"",
      "46: #include \"packet-rtcp.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "47: #include \"conversation_debug.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "52: #include \"packet-h264.h\"",
      "53: #include \"packet-mp4ves.h\"",
      "59: void proto_register_sdp(void);",
      "60: void proto_reg_handoff_sdp(void);",
      "",
      "[Removed Lines]",
      "57: #include \"conversation_debug.h\"",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "208: typedef struct {",
      "209:     gint32 pt[SDP_MAX_RTP_PAYLOAD_TYPES];",
      "210:     gint8 pt_count;",
      "212:     gboolean set_rtp;",
      "213: } transport_media_pt_t;",
      "",
      "[Removed Lines]",
      "211:     GHashTable *rtp_dyn_payload;",
      "",
      "[Added Lines]",
      "212:     rtp_dyn_payload_t *rtp_dyn_payload;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "256: #ifdef DEBUG_CONVERSATION",
      "275: static void sdp_dump_transport_media(const transport_media_pt_t* media) {",
      "276:     int i;",
      "277:     int count;",
      "",
      "[Removed Lines]",
      "258: static void",
      "259: rtp_dyn_payload_table_foreach_func (gpointer key, gpointer value, gpointer user_data _U_) {",
      "260:     gint* pt = (gint*) key;",
      "261:     encoding_name_and_rate_t *encoding = (encoding_name_and_rate_t*) value;",
      "263:     DPRINT2((\"pt=%d\",*pt));",
      "264:     DINDENT();",
      "265:         if (encoding) {",
      "266:             DPRINT2((\"encoding_name=%s\",",
      "267:                     encoding->encoding_name ? encoding->encoding_name : \"NULL\"));",
      "268:             DPRINT2((\"sample_rate=%d\", encoding->sample_rate));",
      "269:         } else {",
      "270:             DPRINT2((\"encoding=NULL\"));",
      "271:         }",
      "272:     DENDENT();",
      "273: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "291:         DENDENT();",
      "292:         DPRINT2((\"rtp_dyn_payload hashtable=%s\", media->rtp_dyn_payload ? \"YES\" : \"NO\"));",
      "293:         if (media->rtp_dyn_payload) {",
      "302:         }",
      "303:         DPRINT2((\"set_rtp=%s\", media->set_rtp ? \"TRUE\" : \"FALSE\"));",
      "304:     DENDENT();",
      "",
      "[Removed Lines]",
      "294:             DPRINT2((\"rtp_dyn_payload hash table contents:\"));",
      "295:             DINDENT();",
      "296:                 if (g_hash_table_size(media->rtp_dyn_payload) == 0) {",
      "297:                     DPRINT2((\"rtp_dyn_payload is empty\"));",
      "298:                 } else {",
      "299:                     g_hash_table_foreach(media->rtp_dyn_payload, rtp_dyn_payload_table_foreach_func, NULL);",
      "300:                 }",
      "301:             DENDENT();",
      "",
      "[Added Lines]",
      "277:             rtp_dump_dyn_payload(media->rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1290:     guint8     *payload_type;",
      "1291:     guint8     *attribute_value;",
      "1293:     guint8      pt;",
      "1294:     gint        sdp_media_attrbute_code;",
      "1295:     const char *msrp_res           = \"msrp://\";",
      "",
      "[Removed Lines]",
      "1292:     gint       *key;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1297:     gboolean    has_more_pars      = TRUE;",
      "1298:     tvbuff_t   *h245_tvb;",
      "1299:     guint8      master_key_length  = 0, master_salt_length = 0;",
      "1302:     offset = 0;",
      "",
      "[Removed Lines]",
      "1300:     encoding_name_and_rate_t *encoding_name_and_rate;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1365:             }",
      "1370:             transport_info->encoding_name[pt] = (char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);",
      "1372:             next_offset =  next_offset + 1;",
      "",
      "[Removed Lines]",
      "1367:             key  = wmem_new(wmem_file_scope(), gint);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1400:             if (transport_info->media_count < 0) {",
      "1401:                 for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
      "1415:                 }",
      "1416:                 return;",
      "1426:             break;",
      "1427:         case SDP_FMTP:",
      "1428:             if (sdp_media_attribute_tree) {",
      "",
      "[Removed Lines]",
      "1402:                     encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "1403:                     encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
      "1404:                     encoding_name_and_rate->sample_rate = transport_info->sample_rate[pt];",
      "1405:                     if (n == 0) {",
      "1406:                         g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
      "1407:                                             key, encoding_name_and_rate);",
      "1409:                         gint *key2;",
      "1410:                         key2  = wmem_new(wmem_file_scope(), gint);",
      "1412:                         g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
      "1413:                                             key2, encoding_name_and_rate);",
      "1414:                     }",
      "1418:             } else",
      "1420:                 encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
      "1422:             encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
      "1423:             encoding_name_and_rate->sample_rate   = transport_info->sample_rate[pt];",
      "1424:             g_hash_table_insert(transport_info->media[ transport_info->media_count ].rtp_dyn_payload,",
      "1425:                                   key, encoding_name_and_rate);",
      "",
      "[Added Lines]",
      "1373:                     rtp_dyn_payload_insert(transport_info->media[n].rtp_dyn_payload,",
      "1374:                                            pt,",
      "1375:                                            transport_info->encoding_name[pt],",
      "1376:                                            transport_info->sample_rate[pt]);",
      "1380:             }",
      "1382:             rtp_dyn_payload_insert(transport_info->media[ transport_info->media_count ].rtp_dyn_payload,",
      "1383:                                   pt, transport_info->encoding_name[pt], transport_info->sample_rate[pt]);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1917:             transport_info->encoding_name[n] = (char*)UNKNOWN_ENCODING;",
      "1918:         }",
      "1919:         for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
      "1922:             transport_info->media[n].set_rtp = FALSE;",
      "1923:         }",
      "",
      "[Removed Lines]",
      "1920:             transport_info->media[n].rtp_dyn_payload =",
      "1921:                 g_hash_table_new(g_int_hash, g_int_equal);",
      "",
      "[Added Lines]",
      "1878:             transport_info->media[n].rtp_dyn_payload = rtp_dyn_payload_new();",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1955:         (transport_info->sdp_status == SDP_EXCHANGE_OFFER)) {",
      "1956:         for (n = start_transport_info_count; n < SDP_MAX_RTP_CHANNELS; n++) {",
      "1957:             if (!transport_info->media[n].rtp_dyn_payload)",
      "1959:         }",
      "1960:     }",
      "",
      "[Removed Lines]",
      "1958:                 transport_info->media[n].rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
      "",
      "[Added Lines]",
      "1915:                 transport_info->media[n].rtp_dyn_payload = rtp_dyn_payload_new();",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "2161:             if (!transport_info->media[n].set_rtp)",
      "2162:             {",
      "2164:                         \"channel=%d, media_port=%d\",",
      "2165:                         n, transport_info->media_port[n]));",
      "2167:                 transport_info->media[n].rtp_dyn_payload = NULL;",
      "2168:             }",
      "",
      "[Removed Lines]",
      "2163:                 DPRINT((\"set_rtp is not set, calling rtp_free_hash_dyn_payload, \"",
      "2166:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "2120:                 DPRINT((\"set_rtp is not set, calling rtp_dyn_payload_free, \"",
      "2123:                 rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "2176:             {",
      "2177:                 if (!transport_info->media[n].set_rtp)",
      "2178:                 {",
      "2180:                             \"channel=%d, media_port=%d\",",
      "2181:                             n, transport_info->media_port[n]));",
      "2183:                     transport_info->media[n].rtp_dyn_payload = NULL;",
      "2184:                 }",
      "2185:             }",
      "",
      "[Removed Lines]",
      "2179:                     DPRINT((\"media_count == -1, calling rtp_free_hash_dyn_payload, \"",
      "2182:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "2136:                     DPRINT((\"media_count == -1, calling rtp_dyn_payload_free, \"",
      "2139:                     rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "2190:             {",
      "2191:                 if (!transport_info->media[n].set_rtp)",
      "2192:                 {",
      "2194:                             \"channel=%d, media_port=%d\",",
      "2195:                             n, transport_info->media_port[n]));",
      "2197:                     transport_info->media[n].rtp_dyn_payload = NULL;",
      "2198:                 }",
      "2199:             }",
      "",
      "[Removed Lines]",
      "2193:                     DPRINT((\"media_count != -1, calling rtp_free_hash_dyn_payload, \"",
      "2196:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "2150:                     DPRINT((\"media_count != -1, calling rtp_dyn_payload_free, \"",
      "2153:                     rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "2208:         {",
      "2209:             if (!transport_info->media[n].set_rtp)",
      "2210:             {",
      "2212:                 transport_info->media[n].rtp_dyn_payload = NULL;",
      "2213:             }",
      "2214:         }",
      "",
      "[Removed Lines]",
      "2211:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "2168:                 rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "2281:         local_transport_info.encoding_name[n] = (char*)UNKNOWN_ENCODING;",
      "2282:     }",
      "2283:     for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
      "2286:         local_transport_info.media[n].set_rtp = FALSE;",
      "2287:     }",
      "",
      "[Removed Lines]",
      "2284:         local_transport_info.media[n].rtp_dyn_payload =",
      "2285:             g_hash_table_new(g_int_hash, g_int_equal);",
      "",
      "[Added Lines]",
      "2241:         local_transport_info.media[n].rtp_dyn_payload = rtp_dyn_payload_new();",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "2559:                         i, local_transport_info.media[n].pt[i]));",
      "2561:                 if ((local_transport_info.media[n].pt[i] >= 96) && (local_transport_info.media[n].pt[i] <= 127)) {",
      "2564:                         local_transport_info.media[n].rtp_dyn_payload,",
      "2567:                         if (strlen(sdp_pi->summary_str))",
      "2568:                             g_strlcat(sdp_pi->summary_str, \" \", 50);",
      "2570:                     } else {",
      "2571:                         char num_pt[10];",
      "2572:                         g_snprintf(num_pt, 10, \"%u\", local_transport_info.media[n].pt[i]);",
      "",
      "[Removed Lines]",
      "2562:                     encoding_name_and_rate_t *encoding_name_and_rate_pt =",
      "2563:                         (encoding_name_and_rate_t *)g_hash_table_lookup(",
      "2565:                         &local_transport_info.media[n].pt[i]);",
      "2566:                     if (encoding_name_and_rate_pt) {",
      "2569:                         g_strlcat(sdp_pi->summary_str, encoding_name_and_rate_pt->encoding_name, 50);",
      "",
      "[Added Lines]",
      "2518:                     const gchar *payload_type_str = rtp_dyn_payload_get_name(",
      "2520:                         local_transport_info.media[n].pt[i]);",
      "2521:                     if (payload_type_str) {",
      "2524:                         g_strlcat(sdp_pi->summary_str, payload_type_str, 50);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "2589:         if ((transport_info == &local_transport_info) &&",
      "2590:             !transport_info->media[n].set_rtp)",
      "2591:         {",
      "2593:             transport_info->media[n].rtp_dyn_payload = NULL;",
      "2594:         }",
      "",
      "[Removed Lines]",
      "2592:             rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "2547:             rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "2611:         {",
      "2612:             if (!transport_info->media[n].set_rtp)",
      "2613:             {",
      "2615:                 transport_info->media[n].rtp_dyn_payload = NULL;",
      "2616:             }",
      "2617:         }",
      "",
      "[Removed Lines]",
      "2614:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "2569:                 rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
      "",
      "---------------"
    ],
    "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c": [
      "File: ui/gtk/voip_calls.c -> ui/gtk/voip_calls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "564:    p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_get_id_by_filter_name(\"rtp\"), 0);",
      "565:    if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
      "570:     }",
      "571:    }",
      "572:   }",
      "",
      "[Removed Lines]",
      "566:     encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
      "567:     encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &strinfo->pt);",
      "568:     if (encoding_name_and_rate_pt) {",
      "569:      strinfo->pt_str = g_strdup(encoding_name_and_rate_pt->encoding_name);",
      "",
      "[Added Lines]",
      "566:     const gchar *encoding_name = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, strinfo->pt);",
      "567:     if (encoding_name) {",
      "568:      strinfo->pt_str = g_strdup(encoding_name);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a04f610989400f76beaa7709b0e7fa1bce2109a7",
      "candidate_info": {
        "commit_hash": "a04f610989400f76beaa7709b0e7fa1bce2109a7",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/a04f610989400f76beaa7709b0e7fa1bce2109a7",
        "files": [
          "epan/Makefile.common",
          "epan/conversation.c",
          "epan/conversation_debug.h",
          "epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-sdp.c",
          "epan/dissectors/packet-sip.c"
        ],
        "message": "Add debug printing functions for conversations, sip, sdp, rtp\n\nThere have been enough gnarly bus in sip/sdp/rtp that it needs\nto have good debug printing. Using a debugger isn't good enough\nbecause there's interaction across multiple frames and it's too\nhard to follow what's going on without real printed data history.\n\nChange-Id: Ifb5bb1fb580be81f988569ece79d238a9c030c34\nReviewed-on: https://code.wireshark.org/review/688\nReviewed-by: Hadriel Kaplan <hadrielk@yahoo.com>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/Makefile.common||epan/Makefile.common",
          "epan/conversation.c||epan/conversation.c",
          "epan/conversation_debug.h||epan/conversation_debug.h",
          "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c",
          "epan/dissectors/packet-sip.c||epan/dissectors/packet-sip.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/Makefile.common||epan/Makefile.common": [
          "File: epan/Makefile.common -> epan/Makefile.common",
          "--- Hunk 1 ---",
          "[Context before]",
          "163:  column-info.h  \\",
          "164:  column-utils.h  \\",
          "165:  conversation.h  \\",
          "166:  conv_id.h  \\",
          "167:  crc16-tvb.h  \\",
          "168:  crc32-tvb.h  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "166:  conversation_debug.h  \\",
          "",
          "---------------"
        ],
        "epan/conversation.c||epan/conversation.c": [
          "File: epan/conversation.c -> epan/conversation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"emem.h\"",
          "31: #include \"conversation.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #include \"conversation_debug.h\"",
          "37: #ifdef DEBUG_CONVERSATION",
          "38: int _debug_conversation_indent = 0;",
          "39: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "551:   conv->next = NULL;",
          "552:   conv->last = conv;",
          "553:   g_hash_table_insert(hashtable, conv->key_ptr, conv);",
          "554:  }",
          "555:  else {",
          "558:   chain_tail = chain_head->last;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "562:   DPRINT((\"created a new conversation chain\"));",
          "566:   DPRINT((\"there's an existing conversation chain\"));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "666:  conversation_t *conversation=NULL;",
          "667:  conversation_key *new_key;",
          "669:  if (options & NO_ADDR2) {",
          "670:   if (options & (NO_PORT2|NO_PORT2_FORCE)) {",
          "671:    hashtable = conversation_hashtable_no_addr2_or_port2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "679:  DPRINT((\"creating conversation for frame #%d: %s:%d -> %s:%d (ptype=%d)\",",
          "680:       setup_frame, ep_address_to_str(addr1), port1,",
          "681:       ep_address_to_str(addr2), port2, ptype));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "706:  new_index++;",
          "708:  conversation_insert_into_hashtable(hashtable, conversation);",
          "710:  return conversation;",
          "711: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "722:  DINDENT();",
          "724:  DENDENT();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "720:    DISSECTOR_ASSERT_HINT(!(conv->options & CONVERSATION_TEMPLATE),",
          "721:             \"Use the conversation_create_from_template function when the CONVERSATION_TEMPLATE bit is set in the options mask\");",
          "726:  if ((!(conv->options & NO_PORT2)) || (conv->options & NO_PORT2_FORCE))",
          "727:   return;",
          "729:  if (conv->options & NO_ADDR2) {",
          "730:   conversation_remove_from_hashtable(conversation_hashtable_no_addr2_or_port2, conv);",
          "731:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "739:  DPRINT((\"called for port=%d\", port));",
          "747:  DINDENT();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "738:  } else {",
          "739:   conversation_insert_into_hashtable(conversation_hashtable_exact, conv);",
          "740:  }",
          "741: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "760:  DENDENT();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "750:    DISSECTOR_ASSERT_HINT(!(conv->options & CONVERSATION_TEMPLATE),",
          "751:             \"Use the conversation_create_from_template function when the CONVERSATION_TEMPLATE bit is set in the options mask\");",
          "756:  if (!(conv->options & NO_ADDR2))",
          "757:   return;",
          "759:  if (conv->options & NO_PORT2) {",
          "760:   conversation_remove_from_hashtable(conversation_hashtable_no_addr2_or_port2, conv);",
          "761:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "773:  DPRINT((\"called for addr=%s\",ep_address_to_str(addr)));",
          "781:  DINDENT();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "768:  } else {",
          "769:   conversation_insert_into_hashtable(conversation_hashtable_exact, conv);",
          "770:  }",
          "771: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "794:  DENDENT();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "871:       conversation =",
          "872:          conversation_lookup_hashtable(conversation_hashtable_exact,",
          "873:          frame_num, addr_a, addr_b, ptype,",
          "874:          port_a, port_b);",
          "876:       if (conversation == NULL) {",
          "877:        conversation =",
          "878:    conversation_lookup_hashtable(conversation_hashtable_exact,",
          "879:    frame_num, addr_b, addr_a, ptype,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "895:       DPRINT((\"trying exact match\"));",
          "902:        DPRINT((\"trying opposite direction\"));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "888:             frame_num, addr_b, addr_a, ptype,",
          "889:             port_a, port_b);",
          "890:       }",
          "891:       if (conversation != NULL)",
          "892:          return conversation;",
          "893:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "917:    DPRINT((\"exact match %sfound\",conversation?\"\":\"not \"));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "909:       conversation =",
          "910:          conversation_lookup_hashtable(conversation_hashtable_no_addr2,",
          "911:          frame_num, addr_a, addr_b, ptype, port_a, port_b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "936:       DPRINT((\"trying wildcarded dest address\"));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "933:          if (!(conversation->options & NO_ADDR_B) && ptype != PT_UDP)",
          "934:          {",
          "935:             if(!(conversation->options & CONVERSATION_TEMPLATE))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "961:          DPRINT((\"wildcarded dest address match found\"));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "958:       if (!(options & NO_ADDR_B)) {",
          "959:          conversation =",
          "960:             conversation_lookup_hashtable(conversation_hashtable_no_addr2,",
          "961:             frame_num, addr_b, addr_a, ptype, port_b, port_a);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "988:          DPRINT((\"trying dest addr:port as source addr:port with wildcarded dest addr\"));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "971:             if (ptype != PT_UDP) {",
          "972:                if(!(conversation->options & CONVERSATION_TEMPLATE))",
          "973:                {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1001:          DPRINT((\"match found\"));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1001:       conversation =",
          "1002:          conversation_lookup_hashtable(conversation_hashtable_no_port2,",
          "1003:          frame_num, addr_a, addr_b, ptype, port_a, port_b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1032:       DPRINT((\"trying wildcarded dest port\"));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1024:          if (!(conversation->options & NO_PORT_B) && ptype != PT_UDP)",
          "1025:          {",
          "1026:             if(!(conversation->options & CONVERSATION_TEMPLATE))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1056:          DPRINT((\"match found\"));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1049:       if (!(options & NO_PORT_B)) {",
          "1050:          conversation =",
          "1051:             conversation_lookup_hashtable(conversation_hashtable_no_port2,",
          "1052:             frame_num, addr_b, addr_a, ptype, port_b, port_a);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1083:          DPRINT((\"trying dest addr:port as source addr:port and wildcarded dest port\"));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1062:             if (ptype != PT_UDP)",
          "1063:             {",
          "1064:                if(!(conversation->options & CONVERSATION_TEMPLATE))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1096:             DPRINT((\"match found\"));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1087:    conversation =",
          "1088:       conversation_lookup_hashtable(conversation_hashtable_no_addr2_or_port2,",
          "1089:       frame_num, addr_a, addr_b, ptype, port_a, port_b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1122:    DPRINT((\"trying wildcarding dest addr:port\"));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1104:       if (ptype != PT_UDP)",
          "1105:       {",
          "1106:          if(!(conversation->options & CONVERSATION_TEMPLATE))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1140:       DPRINT((\"match found\"));",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1131:    if (addr_a->type == AT_FC)",
          "1132:       conversation =",
          "1133:       conversation_lookup_hashtable(conversation_hashtable_no_addr2_or_port2,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1168:    DPRINT((\"trying dest addr:port as source addr:port and wildcarding dest addr:port\"));",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1149:       if (ptype != PT_UDP)",
          "1150:       {",
          "1151:          if(!(conversation->options & CONVERSATION_TEMPLATE))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1187:       DPRINT((\"match found\"));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1161:       return conversation;",
          "1162:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1203:    DPRINT((\"no matches found\"));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1288: {",
          "1289:  conversation_t *conv=NULL;",
          "1292:  if((conv = find_conversation(pinfo->fd->num, &pinfo->src, &pinfo->dst,",
          "1293:          pinfo->ptype, pinfo->srcport,",
          "1294:          pinfo->destport, 0)) != NULL) {",
          "1295:   if (pinfo->fd->num > conv->last_frame) {",
          "1296:    conv->last_frame = pinfo->fd->num;",
          "1297:   }",
          "1298:  } else {",
          "1300:   conv = conversation_new(pinfo->fd->num, &pinfo->src,",
          "1301:      &pinfo->dst, pinfo->ptype,",
          "1302:      pinfo->srcport, pinfo->destport, 0);",
          "1303:  }",
          "1305:  return conv;",
          "1306: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1332:  DPRINT((\"called for frame #%d: %s:%d -> %s:%d (ptype=%d)\",",
          "1333:   pinfo->fd->num, ep_address_to_str(&pinfo->src), pinfo->srcport,",
          "1334:   ep_address_to_str(&pinfo->dst), pinfo->destport, pinfo->ptype));",
          "1335:  DINDENT();",
          "1341:   DPRINT((\"found previous conversation for frame #%d (last_frame=%d)\",",
          "1342:     pinfo->fd->num, conv->last_frame));",
          "1348:   DPRINT((\"did not find previous conversation for frame #%d\",",
          "1349:     pinfo->fd->num));",
          "1350:   DINDENT();",
          "1354:   DENDENT();",
          "1357:  DENDENT();",
          "",
          "---------------"
        ],
        "epan/conversation_debug.h||epan/conversation_debug.h": [
          "File: epan/conversation_debug.h -> epan/conversation_debug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef _CONVERSATION_DEBUG_H",
          "10: #define _CONVERSATION_DEBUG_H",
          "12: #ifdef DEBUG_CONVERSATION",
          "14: #include <stdio.h>",
          "15: #include \"to_str.h\"",
          "19: #define DINDENT() _debug_conversation_indent += 4",
          "20: #define DENDENT() _debug_conversation_indent -= 4",
          "22: #define DPRINT(arg) \\",
          "23:           g_printerr(\"%*.*s%s: \", \\",
          "24:                      _debug_conversation_indent,_debug_conversation_indent,\" \", \\",
          "25:                      G_STRLOC); \\",
          "26:           g_printerr arg; \\",
          "27:           g_printerr(\"\\n\")",
          "29: #define DPRINT2(arg) \\",
          "30:           g_printerr(\"%*.*s\", \\",
          "31:                      _debug_conversation_indent,_debug_conversation_indent,\" \"); \\",
          "32:           g_printerr arg; \\",
          "33:           g_printerr(\"\\n\")",
          "40: #define DINDENT() (void)0",
          "41: #define DENDENT() (void)0",
          "42: #define DPRINT(arg) (void)0",
          "43: #define DPRINT2(arg) (void)0",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
          "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: #include <epan/wmem/wmem.h>",
          "71: #include <epan/strutil.h>",
          "76: typedef struct _rfc2198_hdr {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75: #include \"conversation_debug.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "801: };",
          "802: #endif",
          "805: static void",
          "806: rtp_fragment_init(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "809: #ifdef DEBUG_CONVERSATION",
          "811: static void",
          "812: rtp_dyn_payload_table_foreach_func (gpointer key, gpointer value, gpointer user_data _U_) {",
          "813:     gint* pt = (gint*) key;",
          "814:     encoding_name_and_rate_t *encoding = (encoding_name_and_rate_t*) value;",
          "816:     DPRINT2((\"pt=%d\",*pt));",
          "817:     if (encoding) {",
          "818:         DPRINT2((\"encoding_name=%s\",",
          "819:                 encoding->encoding_name ? encoding->encoding_name : \"NULL\"));",
          "820:         DPRINT2((\"sample_rate=%d\", encoding->sample_rate));",
          "821:     } else {",
          "822:         DPRINT2((\"encoding=NULL\"));",
          "823:     }",
          "824: }",
          "825: static void rtp_dump_dyn_payload(GHashTable *rtp_dyn_payload) {",
          "826:     DPRINT2((\"rtp_dyn_payload hash table contents:\"));",
          "827:     DINDENT();",
          "828:     if (!rtp_dyn_payload) {",
          "829:         DPRINT2((\"null rtp_dyn_payload\"));",
          "830:         DENDENT();",
          "831:         return;",
          "832:     }",
          "833:     if (g_hash_table_size(rtp_dyn_payload) == 0) {",
          "834:         DPRINT2((\"rtp_dyn_payload is empty\"));",
          "835:     } else {",
          "836:         g_hash_table_foreach(rtp_dyn_payload, rtp_dyn_payload_table_foreach_func, NULL);",
          "837:     }",
          "838:     DENDENT();",
          "839: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "920:         return;",
          "921:     }",
          "929:     SET_ADDRESS(&null_addr, AT_NONE, 0, NULL);",
          "",
          "[Removed Lines]",
          "923: #ifdef DEBUG",
          "924:     printf(\"#%u: %srtp_add_address(%s, %u, %u, %s, %u\\n\",",
          "925:         pinfo->fd->num, (srtp_info)?\"s\":\"\", ep_address_to_str(addr), port,",
          "926:         other_port, setup_method, setup_frame_number);",
          "927: #endif",
          "",
          "[Added Lines]",
          "961:     DPRINT((\"#%u: %srtp_add_address(%s, %u, %u, %s, %u)\",",
          "962:             pinfo->fd->num, (srtp_info)?\"s\":\"\", ep_address_to_str(addr), port,",
          "963:             other_port, setup_method, setup_frame_number));",
          "964:     DINDENT();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "935:     p_conv = find_conversation(setup_frame_number, addr, &null_addr, PT_UDP, port, other_port,",
          "936:                    NO_ADDR_B | (!other_port ? NO_PORT_B : 0));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "975:     DENDENT();",
          "976:     DPRINT((\"did %sfind conversation\", p_conv?\"\":\"NOT \"));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "958:     if (! p_conv_data) {",
          "960:         p_conv_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "961:         p_conv_data->rtp_dyn_payload = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "999:         DPRINT((\"creating new conversation data\"));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "966:         p_conv_data->extended_seqno = 0x10000;",
          "967:         p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);",
          "968:         p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());",
          "969:         conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);",
          "970:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1011:         DINDENT();",
          "1013:         DENDENT();",
          "1015: #ifdef DEBUG_CONVERSATION",
          "1016:     else {",
          "1017:         DPRINT((\"conversation already exists\"));",
          "1018:     }",
          "1019: #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1779:     if ( (payload_type>95) && (payload_type<128) ) {",
          "1780:         if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "1781:             encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1782:             encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
          "1783:             if (encoding_name_and_rate_pt) {",
          "1784:                 rtp_info->info_payload_type_str = payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1785:                 rtp_info->info_payload_rate = encoding_name_and_rate_pt->sample_rate;",
          "1786:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1832: #ifdef DEBUG_CONVERSATION",
          "1833:             rtp_dump_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "1834: #endif",
          "1835:             DPRINT((\"looking up conversation data for dyn_pt=%d\", payload_type));",
          "1839:             DPRINT((\"did %sfind conversation data for dyn_pt=%d\",",
          "1840:                     encoding_name_and_rate_pt?\"\":\"not \", payload_type));",
          "1843:                 DPRINT((\"found conversation data for dyn_pt=%d, enc_name=%s\",",
          "1844:                         payload_type,encoding_name_and_rate_pt->encoding_name));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c": [
          "File: epan/dissectors/packet-sdp.c -> epan/dissectors/packet-sdp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: #include \"packet-h264.h\"",
          "53: #include \"packet-mp4ves.h\"",
          "55: void proto_register_sdp(void);",
          "56: void proto_reg_handoff_sdp(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: #include \"conversation_debug.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248: } disposable_media_info_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "256: #ifdef DEBUG_CONVERSATION",
          "258: static void",
          "259: rtp_dyn_payload_table_foreach_func (gpointer key, gpointer value, gpointer user_data _U_) {",
          "260:     gint* pt = (gint*) key;",
          "261:     encoding_name_and_rate_t *encoding = (encoding_name_and_rate_t*) value;",
          "263:     DPRINT2((\"pt=%d\",*pt));",
          "264:     DINDENT();",
          "265:         if (encoding) {",
          "266:             DPRINT2((\"encoding_name=%s\",",
          "267:                     encoding->encoding_name ? encoding->encoding_name : \"NULL\"));",
          "268:             DPRINT2((\"sample_rate=%d\", encoding->sample_rate));",
          "269:         } else {",
          "270:             DPRINT2((\"encoding=NULL\"));",
          "271:         }",
          "272:     DENDENT();",
          "273: }",
          "275: static void sdp_dump_transport_media(const transport_media_pt_t* media) {",
          "276:     int i;",
          "277:     DPRINT2((\"transport_media contents:\"));",
          "278:     DINDENT();",
          "279:         if (!media) {",
          "280:             DPRINT2((\"null transport_media_pt_t*\"));",
          "281:             DENDENT();",
          "282:             return;",
          "283:         }",
          "284:         DPRINT2((\"pt_count=%hhu\",media->pt_count));",
          "285:         DINDENT();",
          "286:             for (i=0; i < media->pt_count; i++) {",
          "287:                 DPRINT2((\"pt=%d\", media->pt[i]));",
          "288:             }",
          "289:         DENDENT();",
          "290:         DPRINT2((\"rtp_dyn_payload hashtable=%s\", media->rtp_dyn_payload ? \"YES\" : \"NO\"));",
          "291:         if (media->rtp_dyn_payload) {",
          "292:             DPRINT2((\"rtp_dyn_payload hash table contents:\"));",
          "293:             DINDENT();",
          "294:                 if (g_hash_table_size(media->rtp_dyn_payload) == 0) {",
          "295:                     DPRINT2((\"rtp_dyn_payload is empty\"));",
          "296:                 } else {",
          "297:                     g_hash_table_foreach(media->rtp_dyn_payload, rtp_dyn_payload_table_foreach_func, NULL);",
          "298:                 }",
          "299:             DENDENT();",
          "300:         }",
          "301:         DPRINT2((\"set_rtp=%s\", media->set_rtp ? \"TRUE\" : \"FALSE\"));",
          "302:     DENDENT();",
          "303: }",
          "305: static const value_string sdp_exchange_type_vs[] = {",
          "306:     { SDP_EXCHANGE_OFFER,         \"SDP_EXCHANGE_OFFER\" },",
          "307:     { SDP_EXCHANGE_ANSWER_ACCEPT, \"SDP_EXCHANGE_ANSWER_ACCEPT\" },",
          "308:     { SDP_EXCHANGE_ANSWER_REJECT, \"SDP_EXCHANGE_ANSWER_REJECT\" },",
          "309:     { 0, NULL }",
          "310: };",
          "312: static void sdp_dump_transport_info(const transport_info_t* info) {",
          "313:     int i;",
          "314:     DPRINT2((\"transport_info contents:\"));",
          "315:     DINDENT();",
          "316:         if (!info) {",
          "317:             DPRINT2((\"null transport_info_t*\"));",
          "318:             DENDENT();",
          "319:             return;",
          "320:         }",
          "321:         DPRINT2((\"sdp_status=%s\",",
          "322:                  val_to_str(info->sdp_status, sdp_exchange_type_vs, \"SDP_EXCHANGE_UNKNOWN\")));",
          "323:         DPRINT2((\"payload type contents:\"));",
          "324:         DINDENT();",
          "325:             for (i=0; i < SDP_NO_OF_PT; i++) {",
          "327:                 if (info->encoding_name[i] &&",
          "328:                     strcmp(UNKNOWN_ENCODING,info->encoding_name[i]) != 0) {",
          "329:                     DPRINT2((\"payload type #%d:\",i));",
          "330:                     DINDENT();",
          "331:                         DPRINT2((\"encoding_name=%s\", info->encoding_name[i]));",
          "332:                         DPRINT2((\"sample_rate=%d\", info->sample_rate[i]));",
          "333:                     DENDENT();",
          "334:                 }",
          "335:             }",
          "336:         DENDENT();",
          "337:         DPRINT2((\"media_count=%hhd\", info->media_count));",
          "338:         DPRINT2((\"rtp channels:\"));",
          "339:         DINDENT();",
          "340:             for (i=0; i <= info->media_count; i++) {",
          "341:                 DPRINT2((\"channel #%d:\",i));",
          "342:                 DINDENT();",
          "343:                     DPRINT2((\"src_addr=%s\",",
          "344:                             address_to_str(wmem_packet_scope(), &(info->src_addr[i]))));",
          "345:                     DPRINT2((\"media_port=%d\", info->media_port[i]));",
          "346:                     DPRINT2((\"proto_bitmask=%x\", info->proto_bitmask[i]));",
          "347:                     sdp_dump_transport_media(&(info->media[i]));",
          "348:                 DENDENT();",
          "349:             }",
          "350:         DENDENT();",
          "351:         DPRINT2((\"encryption_algorithm=%u\", info->encryption_algorithm));",
          "352:         DPRINT2((\"auth_algorithm=%u\", info->auth_algorithm));",
          "353:         if (info->encryption_algorithm || info->auth_algorithm) {",
          "354:             DPRINT2((\"mki_len=%u\", info->mki_len));",
          "355:             if (info->auth_algorithm) {",
          "356:                 DPRINT2((\"auth_tag_len=%u\", info->auth_tag_len));",
          "357:             }",
          "358:         }",
          "359:     DENDENT();",
          "360: }",
          "362: static void sdp_dump_disposable_media_info(const disposable_media_info_t* info) {",
          "363:     int i;",
          "364:     DPRINT2((\"disposable_media_info contents:\"));",
          "365:     DINDENT();",
          "366:         if (!info) {",
          "367:             DPRINT2((\"null disposable_media_info_t*\"));",
          "368:             DENDENT();",
          "369:             return;",
          "370:         }",
          "371:         DPRINT2((\"connection_address=%s\",",
          "372:                 info->connection_address ? info->connection_address : \"NULL\"));",
          "373:         DPRINT2((\"connection_type=%s\",",
          "374:                 info->connection_type ? info->connection_type : \"NULL\"));",
          "375:         DPRINT2((\"media_count=%hhu\",info->media_count));",
          "376:         DINDENT();",
          "377:             for (i=0; i < info->media_count; i++) {",
          "378:                 DPRINT2((\"media #%d:\",i));",
          "379:                 DINDENT();",
          "380:                     DPRINT2((\"media_type=%s\", info->media_type[i] ? info->media_type[i] : \"NULL\"));",
          "381:                     DPRINT2((\"media_port=%s\", info->media_port[i] ? info->media_port[i] : \"NULL\"));",
          "382:                     DPRINT2((\"media_proto=%s\", info->media_proto[i] ? info->media_proto[i] : \"NULL\"));",
          "383:                 DENDENT();",
          "384:             }",
          "385:         DENDENT();",
          "386:         DPRINT2((\"msrp_transport_address_set=%s\",",
          "387:                 info->msrp_transport_address_set ? \"TRUE\" : \"FALSE\"));",
          "388:         if (info->msrp_transport_address_set) {",
          "389:             DINDENT();",
          "390:                 DPRINT2((\"msrp_ipaddr=%u.%u.%u.%u\",",
          "391:                         info->msrp_ipaddr[0],info->msrp_ipaddr[1],",
          "392:                         info->msrp_ipaddr[2],info->msrp_ipaddr[3]));",
          "393:                 DPRINT2((\"msrp_port_number=%hu\",info->msrp_port_number));",
          "394:             DENDENT();",
          "395:         }",
          "396:     DENDENT();",
          "397: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "352:     media_info->connection_type = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "355:     proto_tree_add_item(sdp_connection_info_tree,",
          "356:                         hf_connection_info_address_type, tvb, offset, tokenlen,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "505:     DPRINT((\"parsed connection line type=%s\", media_info->connection_type));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "371:         media_info->connection_address = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "372:     }",
          "374:     proto_tree_add_item(sdp_connection_info_tree,",
          "375:                         hf_connection_info_connection_address, tvb, offset,",
          "376:                         tokenlen, ENC_ASCII|ENC_NA);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "526:     DPRINT((\"parsed connection line address=%s\", media_info->connection_address));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "699:     media_info->media_type[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "701:     offset = next_offset + 1;",
          "703:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "855:     DPRINT((\"parsed media_type=%s, for media_count=%d\",",
          "856:             media_info->media_type[media_info->media_count],",
          "857:             media_info->media_count));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "712:         media_info->media_port[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "714:         proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,",
          "715:                             atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "716:         offset = next_offset + 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "872:         DPRINT((\"parsed media_port=%s, for media_count=%d\",",
          "873:                 media_info->media_port[media_info->media_count],",
          "874:                 media_info->media_count));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "729:         tokenlen = next_offset - offset;",
          "731:         media_info->media_port[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "733:         proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,",
          "734:                             atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "894:         DPRINT((\"parsed media_port=%s, for media_count=%d\",",
          "895:                 media_info->media_port[media_info->media_count],",
          "896:                 media_info->media_count));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "745:     media_info->media_proto[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "748:     proto_tree_add_item(sdp_media_tree, hf_media_proto, tvb, offset, tokenlen,",
          "749:                         ENC_ASCII|ENC_NA);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "912:     DPRINT((\"parsed media_proto=%s, for media_count=%d\",",
          "913:             media_info->media_proto[media_info->media_count],",
          "914:             media_info->media_count));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "766:                                   tokenlen, val_to_str_ext((guint32)strtoul((char*)media_format, NULL, 10), &rtp_payload_type_vals_ext, \"%u\"));",
          "767:             idx = transport_info->media[transport_info->media_count].pt_count;",
          "768:             transport_info->media[transport_info->media_count].pt[idx] = (gint32)strtol((char*)media_format, NULL, 10);",
          "770:                 transport_info->media[transport_info->media_count].pt_count++;",
          "771:         } else {",
          "772:             proto_tree_add_item(sdp_media_tree, hf_media_format, tvb, offset,",
          "",
          "[Removed Lines]",
          "769:             if (idx < (SDP_MAX_RTP_PAYLOAD_TYPES-1))",
          "",
          "[Added Lines]",
          "938:             DPRINT((\"parsed media codec pt=%d, for media_count=%d\",",
          "939:                     transport_info->media[transport_info->media_count].pt[idx],",
          "940:                     transport_info->media_count));",
          "941:            if (idx < (SDP_MAX_RTP_PAYLOAD_TYPES-1))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1592:         transport_index = n+start_transport_info_count;",
          "1593:         if (media_info->media_port[n] != NULL) {",
          "1594:             transport_info->media_port[transport_index] = (int)strtol(media_info->media_port[n], NULL, 10);",
          "1595:         }",
          "1597:         if (media_info->media_proto[n] != NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1767:             DPRINT((\"set transport_info media port number=%d, for transport_index=%d\",",
          "1768:                     transport_info->media_port[transport_index], transport_index));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1606:                 if (!strcmp(media_info->media_proto[n],\"RTP/AVP\")) {",
          "1607:                     transport_info->proto_bitmask[transport_index] |= SDP_RTP_PROTO;",
          "1608:                     proto_bitmask |= SDP_RTP_PROTO;",
          "1609:                 }",
          "1611:                 else if (!strcmp(media_info->media_proto[n],\"RTP/SAVP\")) {",
          "1612:                     transport_info->proto_bitmask[transport_index] |= SDP_SRTP_PROTO;",
          "1613:                     proto_bitmask |= SDP_SRTP_PROTO;",
          "1614:                 }",
          "1616:                 else if ((!strcmp(media_info->media_proto[n],\"UDPTL\")) ||",
          "1617:                     (!strcmp(media_info->media_proto[n],\"udptl\"))) {",
          "1618:                     transport_info->proto_bitmask[transport_index] |= SDP_T38_PROTO;",
          "1619:                     proto_bitmask |= SDP_T38_PROTO;",
          "1620:                 }",
          "1622:                 else if (!strcmp(media_info->media_proto[n],\"msrp/tcp\")) {",
          "1623:                     transport_info->proto_bitmask[transport_index] |= SDP_MSRP_PROTO;",
          "1624:                     proto_bitmask |= SDP_MSRP_PROTO;",
          "1625:                 }",
          "1627:                 else if ((!strcmp(media_info->media_proto[n],\"UDPSPRT\")) ||",
          "1628:                     (!strcmp(media_info->media_proto[n],\"udpsprt\"))) {",
          "1629:                     transport_info->proto_bitmask[transport_index] |= SDP_SPRT_PROTO;",
          "1630:                     proto_bitmask |= SDP_SPRT_PROTO;",
          "1631:                 }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1783:                     DPRINT((\"set SDP_RTP_PROTO bitmask=%x, for transport_index=%d\",",
          "1784:                             transport_info->proto_bitmask[transport_index], transport_index));",
          "1790:                     DPRINT((\"set SDP_SRTP_PROTO bitmask=%x, for transport_index=%d\",",
          "1791:                             transport_info->proto_bitmask[transport_index], transport_index));",
          "1798:                     DPRINT((\"set SDP_T38_PROTO bitmask=%x, for transport_index=%d\",",
          "1799:                             transport_info->proto_bitmask[transport_index], transport_index));",
          "1805:                     DPRINT((\"set SDP_MSRP_PROTO bitmask=%x, for transport_index=%d\",",
          "1806:                             transport_info->proto_bitmask[transport_index], transport_index));",
          "1813:                     DPRINT((\"set SDP_SPRT_PROTO bitmask=%x, for transport_index=%d\",",
          "1814:                             transport_info->proto_bitmask[transport_index], transport_index));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1640:                     if (start_transport_info_count > 0 && (proto_bitmask & transport_info->proto_bitmask[n])) {",
          "1641:                         transport_info->media_port[n] = 0;",
          "1642:                     }",
          "1643:                 }",
          "1644:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1826:                         DPRINT((\"disabled media_port=%d, for transport_index=%d\",",
          "1827:                                 n, transport_index));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1647:         if ((media_info->connection_address != NULL) &&",
          "1648:             (media_info->connection_type != NULL)) {",
          "1656:             }",
          "1666:         }",
          "",
          "[Removed Lines]",
          "1649:           if (strcmp(media_info->connection_type, \"IP4\") == 0) {",
          "1650:             transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 4);",
          "1651:             if (str_to_ip(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1653:               transport_info->proto_bitmask[transport_index] |= SDP_IPv4;",
          "1654:               transport_info->src_addr[transport_index].type = AT_IPv4;",
          "1655:               transport_info->src_addr[transport_index].len  = 4;",
          "1657:           } else if (strcmp(media_info->connection_type, \"IP6\") == 0) {",
          "1658:               transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 16);",
          "1659:               if (str_to_ip6(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1661:                 transport_info->proto_bitmask[transport_index] |= SDP_IPv6;",
          "1662:                 transport_info->src_addr[transport_index].type = AT_IPv6;",
          "1663:                 transport_info->src_addr[transport_index].len  = 16;",
          "1664:               }",
          "1665:           }",
          "",
          "[Added Lines]",
          "1835:             if (strcmp(media_info->connection_type, \"IP4\") == 0) {",
          "1836:                 transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 4);",
          "1837:                 if (str_to_ip(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1839:                     transport_info->proto_bitmask[transport_index] |= SDP_IPv4;",
          "1840:                     transport_info->src_addr[transport_index].type = AT_IPv4;",
          "1841:                     transport_info->src_addr[transport_index].len  = 4;",
          "1842:                     DPRINT((\"set SDP_IPv4 bitmask=%x, for transport_index=%d\",",
          "1843:                             transport_info->proto_bitmask[transport_index], transport_index));",
          "1844:                 }",
          "1845:             } else if (strcmp(media_info->connection_type, \"IP6\") == 0) {",
          "1846:                 transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 16);",
          "1847:                 if (str_to_ip6(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1849:                     transport_info->proto_bitmask[transport_index] |= SDP_IPv6;",
          "1850:                     transport_info->src_addr[transport_index].type = AT_IPv6;",
          "1851:                     transport_info->src_addr[transport_index].len  = 16;",
          "1852:                     DPRINT((\"set SDP_IPv6 bitmask=%x, for transport_index=%d\",",
          "1853:                             transport_info->proto_bitmask[transport_index], transport_index));",
          "1854:                 }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1679:         if ((media_info->media_type[transport_index] != NULL) &&",
          "1680:             (strcmp(media_info->media_type[transport_index], \"video\") == 0)) {",
          "1681:             transport_info->proto_bitmask[transport_index] |= SDP_VIDEO;",
          "1682:         }",
          "1683:     }",
          "1684: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1872:             DPRINT((\"set SDP_VIDEO bitmask=%x, for transport_index=%d\",",
          "1873:                     transport_info->proto_bitmask[transport_index], transport_index));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1700:     struct srtp_info *srtp_info = NULL;",
          "1706:     memset(&media_info, 0, sizeof(media_info));",
          "",
          "[Removed Lines]",
          "1703:     if (pinfo->fd->flags.visited)",
          "1704:       return;",
          "",
          "[Added Lines]",
          "1894:     DPRINT2((\"-------------------- setup_sdp_transport -------------------\"));",
          "1897:     if (pinfo->fd->flags.visited) {",
          "1898:         DPRINT((\"already visited\"));",
          "1899:         return;",
          "1900:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1723:         if (request_frame != 0)",
          "1724:             wmem_tree_insert32(sdp_transport_reqs, request_frame, (void *)transport_info);",
          "1725:     }",
          "1727:     if (exchange_type != SDP_EXCHANGE_OFFER)",
          "1728:         wmem_tree_insert32(sdp_transport_rsps, pinfo->fd->num, (void *)transport_info);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1922: #ifdef DEBUG_CONVERSATION",
          "1923:     else {",
          "1924:         DPRINT((\"found previous transport_info:\"));",
          "1925:         sdp_dump_transport_info(transport_info);",
          "1926:     }",
          "1927: #endif",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1737:     if (transport_info->media_count > 0)",
          "1738:         start_transport_info_count = transport_info->media_count;",
          "1741:        we free'd the unused media rtp_dyn_payload last time while processing",
          "1742:        the offer, so we need to re-create them this time in case we need them.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1942:     DPRINT((\"start_transport_info_count=%d\", start_transport_info_count));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1789:                     media_info.media_count++;",
          "1791:                 in_media_description = TRUE;",
          "1792:                 break;",
          "1793:             case 'a':",
          "1794:                 if (in_media_description) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1996:                 DPRINT((\"in media description, transport_info->media_count=%d, \"",
          "1997:                         \"media_info.media_count=%d\",",
          "1998:                         transport_info->media_count, media_info.media_count));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1805:         if (hf != hf_unknown)",
          "1806:         {",
          "1807:             call_sdp_subdissector(tvb_new_subset(tvb, offset + tokenoffset,",
          "1808:                                                    linelen - tokenoffset,",
          "1809:                                                    linelen - tokenoffset),",
          "1810:                                     pinfo,",
          "1811:                                     hf, NULL, linelen-tokenoffset, transport_info, &media_info);",
          "1812:         }",
          "1814:         offset = next_offset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2014:             DINDENT();",
          "2020:             DENDENT();",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1834:             media_info.media_count++;",
          "1835:     }",
          "1840:     convert_disposable_media(transport_info, &media_info, start_transport_info_count);",
          "1843:     if (!delay || ((exchange_type == SDP_EXCHANGE_ANSWER_ACCEPT) &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2046: #ifdef DEBUG_CONVERSATION",
          "2047:     sdp_dump_disposable_media_info(&media_info);",
          "2048: #endif",
          "2050:     DPRINT((\"calling convert_disposable_media(), transport_info->media_count=%d, \"",
          "2051:             \"media_info.media_count=%d, start_transport_info_count=%d\",",
          "2052:             transport_info->media_count, media_info.media_count, start_transport_info_count));",
          "2053:     DINDENT();",
          "2058:     DENDENT();",
          "2060: #ifdef DEBUG_CONVERSATION",
          "2061:     sdp_dump_transport_info(transport_info);",
          "2062: #endif",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1860:                         srtp_info->auth_tag_len         = transport_info->auth_tag_len;",
          "1862:                     }",
          "1865:                     srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", request_frame,",
          "1866:                                     (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "1867:                                      transport_info->media[n].rtp_dyn_payload, srtp_info);",
          "1868:                 } else {",
          "1869:                     rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", request_frame,",
          "1870:                                     (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "1871:                                     transport_info->media[n].rtp_dyn_payload);",
          "1873:                 transport_info->media[n].set_rtp = TRUE;",
          "1875:                 current_rtp_port = transport_info->media_port[n];",
          "1877:                 if (rtcp_handle) {",
          "1878:                     if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "1879:                         srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", request_frame, srtp_info);",
          "1881:                         rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", request_frame);",
          "1883:                 }",
          "1884:             }",
          "",
          "[Removed Lines]",
          "1872:                 }",
          "1880:                     } else {",
          "1882:                     }",
          "",
          "[Added Lines]",
          "2085:                     DPRINT((\"calling srtp_add_address, channel=%d, media_port=%d\",",
          "2086:                             n, transport_info->media_port[n]));",
          "2087:                     DINDENT();",
          "2093:                     DENDENT();",
          "2095:                     DPRINT((\"calling rtp_add_address, channel=%d, media_port=%d\",",
          "2096:                             n, transport_info->media_port[n]));",
          "2097:                     DINDENT();",
          "2101:                     DENDENT();",
          "2102:                  }",
          "2109:                         DPRINT((\"calling rtcp_add_address, channel=%d, media_port=%d\",",
          "2110:                                 n, transport_info->media_port[n]+1));",
          "2111:                         DINDENT();",
          "2113:                         DENDENT();",
          "2114:                      } else {",
          "2115:                         DPRINT((\"calling rtcp_add_address, channel=%d, media_port=%d\",",
          "2116:                                 n, transport_info->media_port[n]+1));",
          "2117:                         DINDENT();",
          "2119:                         DENDENT();",
          "2120:                      }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1917:             if (!transport_info->media[n].set_rtp)",
          "1918:             {",
          "1919:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1920:                 transport_info->media[n].rtp_dyn_payload = NULL;",
          "1921:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2157:                 DPRINT((\"set_rtp is not set, calling rtp_free_hash_dyn_payload, \"",
          "2158:                         \"channel=%d, media_port=%d\",",
          "2159:                         n, transport_info->media_port[n]));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1929:             {",
          "1930:                 if (!transport_info->media[n].set_rtp)",
          "1931:                 {",
          "1932:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1933:                     transport_info->media[n].rtp_dyn_payload = NULL;",
          "1934:                 }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2173:                     DPRINT((\"media_count == -1, calling rtp_free_hash_dyn_payload, \"",
          "2174:                             \"channel=%d, media_port=%d\",",
          "2175:                             n, transport_info->media_port[n]));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1940:             {",
          "1941:                 if (!transport_info->media[n].set_rtp)",
          "1942:                 {",
          "1943:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1944:                     transport_info->media[n].rtp_dyn_payload = NULL;",
          "1945:                 }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2187:                     DPRINT((\"media_count != -1, calling rtp_free_hash_dyn_payload, \"",
          "2188:                             \"channel=%d, media_port=%d\",",
          "2189:                             n, transport_info->media_port[n]));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1995:     sdp_packet_info  *sdp_pi;",
          "1996:     struct srtp_info *srtp_info = NULL;",
          "1999:     sdp_pi = wmem_new(wmem_packet_scope(), sdp_packet_info);",
          "2000:     sdp_pi->summary_str[0] = '\\0';",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2245:     DPRINT2((\"----------------------- dissect_sdp ------------------------\"));",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2011:     if (transport_info == NULL) {",
          "2012:       transport_info = &local_transport_info;",
          "2013:     }",
          "2016:     memset(&local_transport_info, 0, sizeof(local_transport_info));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2263: #ifdef DEBUG_CONVERSATION",
          "2264:     else {",
          "2265:         DPRINT((\"found previous transport_info:\"));",
          "2266:         sdp_dump_transport_info(transport_info);",
          "2267:     }",
          "2268: #endif",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2182:         convert_disposable_media(transport_info, &media_info, 0);",
          "2184:     for (n = 0; n < local_transport_info.media_count; n++)",
          "2185:     {",
          "",
          "[Removed Lines]",
          "2181:     if (transport_info == &local_transport_info)",
          "",
          "[Added Lines]",
          "2436:     if (transport_info == &local_transport_info) {",
          "2437:         DPRINT((\"no previous transport_info saved, calling convert_disposable_media()\"));",
          "2438:         DINDENT();",
          "2440:         DENDENT();",
          "2441: #ifdef DEBUG_CONVERSATION",
          "2442:         sdp_dump_transport_info(transport_info);",
          "2443: #endif",
          "2444:     }",
          "2445: #ifdef DEBUG_CONVERSATION",
          "2446:     else {",
          "2447:         DPRINT((\"not overwriting previous transport_info, local_transport_info contents:\"));",
          "2448:         sdp_dump_transport_info(&local_transport_info);",
          "2449:     }",
          "2450: #endif",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2203:                     srtp_info->mki_len              = transport_info->mki_len;",
          "2204:                     srtp_info->auth_tag_len         = transport_info->auth_tag_len;",
          "2205:                 }",
          "2206:                 srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,",
          "2207:                                 (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "2208:                                  transport_info->media[n].rtp_dyn_payload, srtp_info);",
          "2209:             } else {",
          "2210:                 rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,",
          "2211:                                 (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "2212:                                 transport_info->media[n].rtp_dyn_payload);",
          "2213:             }",
          "2214:             transport_info->media[n].set_rtp = TRUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2474:                 DPRINT((\"calling srtp_add_address for media_port=%d, for channel=%d\",",
          "2475:                         transport_info->media_port[n],n));",
          "2476:                 DINDENT();",
          "2480:                 DENDENT();",
          "2482:                 DPRINT((\"calling rtp_add_address for media_port=%d, for channel=%d\",",
          "2483:                         transport_info->media_port[n],n));",
          "2484:                 DINDENT();",
          "2488:                 DENDENT();",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2218:             if (rtcp_handle) {",
          "2219:                 if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "2220:                     srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num, srtp_info);",
          "2221:                 } else {",
          "2222:                     rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num);",
          "2223:                 }",
          "2224:             }",
          "2225:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2496:                     DPRINT((\"calling srtcp_add_address for media_port=%d, for channel=%d\",",
          "2497:                             transport_info->media_port[n],n));",
          "2498:                     DINDENT();",
          "2500:                     DENDENT();",
          "2502:                     DPRINT((\"calling rtcp_add_address for media_port=%d, for channel=%d\",",
          "2503:                             transport_info->media_port[n],n));",
          "2504:                     DINDENT();",
          "2506:                     DENDENT();",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2266:             for (i = 0; i < local_transport_info.media[n].pt_count; i++)",
          "2267:             {",
          "2269:                 if ((local_transport_info.media[n].pt[i] >= 96) && (local_transport_info.media[n].pt[i] <= 127)) {",
          "2270:                     encoding_name_and_rate_t *encoding_name_and_rate_pt =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2552:                 DPRINT((\"in for-loop for voip call analysis setting for media #%d, pt=%d\",",
          "2553:                         i, local_transport_info.media[n].pt[i]));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sip.c||epan/dissectors/packet-sip.c": [
          "File: epan/dissectors/packet-sip.c -> epan/dissectors/packet-sip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60: #define TCP_PORT_SIP 5060",
          "61: #define UDP_PORT_SIP 5060",
          "62: #define TLS_PORT_SIP 5061",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #include \"conversation_debug.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2415:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"SIP\");",
          "2417:     switch (line_type) {",
          "2419:     case REQUEST_LINE:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2421:     DPRINT2((\"------------------------------ dissect_sip_common ------------------------------\"));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2422:         col_add_fstr(pinfo->cinfo, COL_INFO, \"%s: %s\",",
          "2423:                      descr,",
          "2424:                      tvb_format_text(tvb, offset, linelen - SIP2_HDR_LEN - 1));",
          "2425:         break;",
          "2427:     case STATUS_LINE:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2431:         DPRINT((\"got %s: %s\", descr,",
          "2432:                 tvb_format_text(tvb, offset, linelen - SIP2_HDR_LEN - 1)));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2429:         col_add_fstr(pinfo->cinfo, COL_INFO, \"Status: %s\",",
          "2430:                      tvb_format_text(tvb, offset + SIP2_HDR_LEN + 1, linelen - SIP2_HDR_LEN - 1));",
          "2431:         stat_info->reason_phrase = tvb_get_string(wmem_packet_scope(), tvb, offset + SIP2_HDR_LEN + 5, linelen - (SIP2_HDR_LEN + 5));",
          "2432:         break;",
          "2434:     case OTHER_LINE:",
          "2436:         descr = \"Continuation\";",
          "2437:         col_set_str(pinfo->cinfo, COL_INFO, \"Continuation\");",
          "2438:         break;",
          "2439:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2440:         DPRINT((\"got Response: %s\",",
          "2441:                 tvb_format_text(tvb, offset + SIP2_HDR_LEN + 1, linelen - SIP2_HDR_LEN - 1)));",
          "2448:         DPRINT((\"got continuation\"));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3510:                 if (resend_for_packet == 0) {",
          "3511:                     if (line_type == REQUEST_LINE) {",
          "3512:                         setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_OFFER, pinfo->fd->num, sip_delay_sdp_changes);",
          "3513:                     } else if (line_type == STATUS_LINE) {",
          "3514:                         if (stat_info->response_code >= 400) {",
          "3516:                             setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_ANSWER_REJECT, request_for_response, sip_delay_sdp_changes);",
          "3517:                         }",
          "3518:                         else if ((stat_info->response_code >= 200) && (stat_info->response_code <= 299)) {",
          "3520:                             setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_ANSWER_ACCEPT, request_for_response, sip_delay_sdp_changes);",
          "3521:                         }",
          "3522:                     }",
          "3523:                 } else {",
          "3524:                     setup_sdp_transport_resend(pinfo->fd->num, resend_for_packet);",
          "3525:                 }",
          "3526:             }",
          "3530:             found_match = dissector_try_string(media_type_dissector_table,",
          "3531:                                                media_type_str_lower_case,",
          "3532:                                                next_tvb, pinfo,",
          "3533:                                                message_body_tree, NULL);",
          "3534:             if (!found_match &&",
          "3535:                 !strncmp(media_type_str_lower_case, \"multipart/\", sizeof(\"multipart/\")-1)) {",
          "3537:                 found_match = dissector_try_string(media_type_dissector_table,",
          "3538:                                                    \"multipart/\",",
          "3539:                                                    next_tvb, pinfo,",
          "3540:                                                    message_body_tree, NULL);",
          "3541:             }",
          "3542:             pinfo->private_data = save_private_data;",
          "3544:         }",
          "3545:         if ( found_match != TRUE )",
          "3546:         {",
          "3547:             if (!(dissector_try_heuristic(heur_subdissector_list,",
          "3548:                               next_tvb, pinfo, message_body_tree, NULL))) {",
          "3549:                 int tmp_offset = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3523:                         DPRINT((\"calling setup_sdp_transport() SDP_EXCHANGE_OFFER frame=%d\",",
          "3524:                                 pinfo->fd->num));",
          "3525:                         DINDENT();",
          "3527:                         DENDENT();",
          "3530:                             DPRINT((\"calling setup_sdp_transport() SDP_EXCHANGE_ANSWER_REJECT \"",
          "3531:                                     \"request_frame=%d, this=%d\",",
          "3532:                                     request_for_response, pinfo->fd->num));",
          "3533:                             DINDENT();",
          "3536:                             DENDENT();",
          "3539:                             DPRINT((\"calling setup_sdp_transport() SDP_EXCHANGE_ANSWER_ACCEPT \"",
          "3540:                                     \"request_frame=%d, this=%d\",",
          "3541:                                     request_for_response, pinfo->fd->num));",
          "3542:                             DINDENT();",
          "3545:                             DENDENT();",
          "3549:                     DPRINT((\"calling setup_sdp_transport() resend_for_packet \"",
          "3550:                             \"request_frame=%d, this=%d\",",
          "3551:                             request_for_response, pinfo->fd->num));",
          "3552:                     DINDENT();",
          "3554:                     DENDENT();",
          "3560:             DPRINT((\"calling dissector_try_string()\"));",
          "3561:             DINDENT();",
          "3566:             DENDENT();",
          "3567:             DPRINT((\"done calling dissector_try_string() with found_match=%s\",",
          "3568:                     found_match?\"TRUE\":\"FALSE\"));",
          "3572:                 DPRINT((\"calling dissector_try_string() for multipart\"));",
          "3573:                 DINDENT();",
          "3579:                 DENDENT();",
          "3580:                 DPRINT((\"done calling dissector_try_string() with found_match=%s\",",
          "3581:                         found_match?\"TRUE\":\"FALSE\"));",
          "3588:             DPRINT((\"calling dissector_try_heuristic() with found_match=%s\",",
          "3589:                     found_match?\"TRUE\":\"FALSE\"));",
          "3590:             DINDENT();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3558:                     tmp_offset = next_offset;",
          "3560:             }",
          "3561:         }",
          "3562:         offset += datalen;",
          "3563:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3605:             DENDENT();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eda485ea53c7ac77470f47e886b6513f28f0c20b",
      "candidate_info": {
        "commit_hash": "eda485ea53c7ac77470f47e886b6513f28f0c20b",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/eda485ea53c7ac77470f47e886b6513f28f0c20b",
        "files": [
          "epan/dissectors/packet-applemidi.c",
          "epan/dissectors/packet-gsm_abis_oml.c",
          "epan/dissectors/packet-netrom.c",
          "epan/dissectors/packet-pana.c",
          "epan/dissectors/packet-rsl.c",
          "epan/dissectors/packet-rtmpt.c"
        ],
        "message": "Cleanup:\n\nIncluding:\n  tvb_length...() ==> tvb_reported_length...()\n  Remove some dead initializers;\n  Localize some variables;\n  Whitespace.\n\nChange-Id: Ide9490f248d558bb7e3af96a1fc17d8f911de4ef\nReviewed-on: https://code.wireshark.org/review/6862\nReviewed-by: Bill Meier <wmeier@newsguy.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c",
          "epan/dissectors/packet-gsm_abis_oml.c||epan/dissectors/packet-gsm_abis_oml.c",
          "epan/dissectors/packet-netrom.c||epan/dissectors/packet-netrom.c",
          "epan/dissectors/packet-pana.c||epan/dissectors/packet-pana.c",
          "epan/dissectors/packet-rsl.c||epan/dissectors/packet-rsl.c",
          "epan/dissectors/packet-rtmpt.c||epan/dissectors/packet-rtmpt.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c"
          ],
          "candidate": [
            "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c": [
          "File: epan/dissectors/packet-applemidi.c -> epan/dissectors/packet-applemidi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116: static void",
          "117: dissect_applemidi_common( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 command ) {",
          "119:  guint16   seq_num;",
          "120:  guint8   count;",
          "121:  guint8  *name;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119:  proto_item *ti;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131:  col_add_fstr( pinfo->cinfo, COL_INFO, \"%s\", val_to_str( command, applemidi_commands, applemidi_unknown_command ) );",
          "213:      the transmission to a certain bitrate.  This is important if the peer is a gateway",
          "214:      to a hardware-device that only supports a certain speed.  Like the MIDI 1.0 DIN-cable",
          "230:  }",
          "231: }",
          "",
          "[Removed Lines]",
          "134:   proto_item *ti;",
          "135:   ti = proto_tree_add_item( tree, proto_applemidi, tvb, 0, -1, ENC_NA  );",
          "136:   applemidi_tree = proto_item_add_subtree( ti, ett_applemidi );",
          "138:   proto_tree_add_item( applemidi_tree, hf_applemidi_signature, tvb, offset, 2, ENC_BIG_ENDIAN  );",
          "139:   offset += 2;",
          "141:   proto_tree_add_item( applemidi_tree, hf_applemidi_command, tvb, offset, 2, ENC_BIG_ENDIAN  );",
          "142:   offset += 2;",
          "148:   if ( ( APPLEMIDI_COMMAND_INVITATION == command ) ||",
          "149:        ( APPLEMIDI_COMMAND_INVITATION_REJECTED == command ) ||",
          "150:        ( APLLEMIDI_COMMAND_INVITATION_ACCEPTED == command ) ||",
          "151:        ( APPLEMIDI_COMMAND_ENDSESSION == command ) ) {",
          "153:    proto_tree_add_item( applemidi_tree, hf_applemidi_protocol_version, tvb, offset, 4, ENC_BIG_ENDIAN  );",
          "154:    offset += 4;",
          "156:    proto_tree_add_item( applemidi_tree, hf_applemidi_token, tvb, offset, 4, ENC_BIG_ENDIAN  );",
          "157:    offset += 4;",
          "159:    proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN  );",
          "160:    offset += 4;",
          "162:    len = tvb_reported_length(tvb) - offset;",
          "165:    if ( len > 0 ) {",
          "166:     name = tvb_get_string_enc( wmem_packet_scope(), tvb, offset, len, ENC_UTF_8|ENC_NA );",
          "167:     string_size = (gint)( strlen( name ) + 1 );",
          "168:     proto_tree_add_item( applemidi_tree, hf_applemidi_name, tvb, offset, string_size, ENC_UTF_8|ENC_NA );",
          "169:     col_append_fstr( pinfo->cinfo, COL_INFO, \": peer = \\\"%s\\\"\", name );",
          "170:     offset += string_size;",
          "171:    }",
          "175:   } else if ( APPLEMIDI_COMMAND_SYNCHRONIZATION == command ) {",
          "176:    proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "177:    offset += 4;",
          "179:    count = tvb_get_guint8( tvb, offset );",
          "180:    proto_tree_add_item( applemidi_tree, hf_applemidi_count, tvb, offset, 1, ENC_BIG_ENDIAN );",
          "181:    col_append_fstr( pinfo->cinfo, COL_INFO, \": count = %u\", count );",
          "182:    offset += 1;",
          "184:    proto_tree_add_item( applemidi_tree, hf_applemidi_padding, tvb, offset, 3, ENC_BIG_ENDIAN );",
          "185:    offset += 3;",
          "187:    proto_tree_add_item( applemidi_tree, hf_applemidi_timestamp1, tvb, offset, 8, ENC_BIG_ENDIAN );",
          "188:    offset += 8;",
          "190:    proto_tree_add_item( applemidi_tree, hf_applemidi_timestamp2, tvb, offset, 8, ENC_BIG_ENDIAN );",
          "191:    offset += 8;",
          "193:    proto_tree_add_item( applemidi_tree, hf_applemidi_timestamp3, tvb, offset, 8, ENC_BIG_ENDIAN );",
          "194:    offset += 8;",
          "198:   } else if ( APPLEMIDI_COMMAND_RECEIVER_FEEDBACK == command ) {",
          "199:    proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "200:    offset += 4;",
          "202:    ti = proto_tree_add_item( applemidi_tree, hf_applemidi_sequence_num, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "206:    applemidi_tree_seq_num = proto_item_add_subtree( ti, ett_applemidi_seq_num );",
          "207:    seq_num = tvb_get_ntohs( tvb, offset );",
          "208:    proto_tree_add_uint( applemidi_tree_seq_num, hf_applemidi_rtp_sequence_num, tvb, offset, 2, seq_num );",
          "209:    offset += 4;",
          "211:    col_append_fstr( pinfo->cinfo, COL_INFO, \": seq = %u\", seq_num );",
          "216:   } else if ( APPLEMIDI_COMMAND_BITRATE_RECEIVE_LIMIT == command ) {",
          "217:    proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "218:    offset += 4;",
          "220:    proto_tree_add_item( applemidi_tree, hf_applemidi_rtp_bitrate_limit,",
          "221:           tvb, offset, 4, ENC_BIG_ENDIAN );",
          "222:    offset += 4;",
          "223:   }",
          "226:   len = tvb_length_remaining( tvb, offset );",
          "227:   if ( len > 0 ) {",
          "228:    proto_tree_add_item( applemidi_tree, hf_applemidi_unknown_data, tvb, offset, len, ENC_NA );",
          "229:   }",
          "",
          "[Added Lines]",
          "134:  ti = proto_tree_add_item( tree, proto_applemidi, tvb, 0, -1, ENC_NA  );",
          "135:  applemidi_tree = proto_item_add_subtree( ti, ett_applemidi );",
          "137:  proto_tree_add_item( applemidi_tree, hf_applemidi_signature, tvb, offset, 2, ENC_BIG_ENDIAN  );",
          "138:  offset += 2;",
          "140:  proto_tree_add_item( applemidi_tree, hf_applemidi_command, tvb, offset, 2, ENC_BIG_ENDIAN  );",
          "141:  offset += 2;",
          "147:  if ( ( APPLEMIDI_COMMAND_INVITATION == command ) ||",
          "148:       ( APPLEMIDI_COMMAND_INVITATION_REJECTED == command ) ||",
          "149:       ( APLLEMIDI_COMMAND_INVITATION_ACCEPTED == command ) ||",
          "150:       ( APPLEMIDI_COMMAND_ENDSESSION == command ) ) {",
          "152:   proto_tree_add_item( applemidi_tree, hf_applemidi_protocol_version, tvb, offset, 4, ENC_BIG_ENDIAN  );",
          "153:   offset += 4;",
          "155:   proto_tree_add_item( applemidi_tree, hf_applemidi_token, tvb, offset, 4, ENC_BIG_ENDIAN  );",
          "156:   offset += 4;",
          "158:   proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN  );",
          "159:   offset += 4;",
          "161:   len = tvb_reported_length(tvb) - offset;",
          "164:   if ( len > 0 ) {",
          "165:    name = tvb_get_string_enc( wmem_packet_scope(), tvb, offset, len, ENC_UTF_8|ENC_NA );",
          "166:    string_size = (gint)( strlen( name ) + 1 );",
          "167:    proto_tree_add_item( applemidi_tree, hf_applemidi_name, tvb, offset, string_size, ENC_UTF_8|ENC_NA );",
          "168:    col_append_fstr( pinfo->cinfo, COL_INFO, \": peer = \\\"%s\\\"\", name );",
          "169:    offset += string_size;",
          "170:   }",
          "174:  } else if ( APPLEMIDI_COMMAND_SYNCHRONIZATION == command ) {",
          "175:   proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "176:   offset += 4;",
          "178:   count = tvb_get_guint8( tvb, offset );",
          "179:   proto_tree_add_item( applemidi_tree, hf_applemidi_count, tvb, offset, 1, ENC_BIG_ENDIAN );",
          "180:   col_append_fstr( pinfo->cinfo, COL_INFO, \": count = %u\", count );",
          "181:   offset += 1;",
          "183:   proto_tree_add_item( applemidi_tree, hf_applemidi_padding, tvb, offset, 3, ENC_BIG_ENDIAN );",
          "184:   offset += 3;",
          "186:   proto_tree_add_item( applemidi_tree, hf_applemidi_timestamp1, tvb, offset, 8, ENC_BIG_ENDIAN );",
          "187:   offset += 8;",
          "189:   proto_tree_add_item( applemidi_tree, hf_applemidi_timestamp2, tvb, offset, 8, ENC_BIG_ENDIAN );",
          "190:   offset += 8;",
          "192:   proto_tree_add_item( applemidi_tree, hf_applemidi_timestamp3, tvb, offset, 8, ENC_BIG_ENDIAN );",
          "193:   offset += 8;",
          "197:  } else if ( APPLEMIDI_COMMAND_RECEIVER_FEEDBACK == command ) {",
          "198:   proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "199:   offset += 4;",
          "201:   ti = proto_tree_add_item( applemidi_tree, hf_applemidi_sequence_num, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "205:   applemidi_tree_seq_num = proto_item_add_subtree( ti, ett_applemidi_seq_num );",
          "206:   seq_num = tvb_get_ntohs( tvb, offset );",
          "207:   proto_tree_add_uint( applemidi_tree_seq_num, hf_applemidi_rtp_sequence_num, tvb, offset, 2, seq_num );",
          "208:   offset += 4;",
          "210:   col_append_fstr( pinfo->cinfo, COL_INFO, \": seq = %u\", seq_num );",
          "215:  } else if ( APPLEMIDI_COMMAND_BITRATE_RECEIVE_LIMIT == command ) {",
          "216:   proto_tree_add_item( applemidi_tree, hf_applemidi_ssrc, tvb, offset, 4, ENC_BIG_ENDIAN );",
          "217:   offset += 4;",
          "219:   proto_tree_add_item( applemidi_tree, hf_applemidi_rtp_bitrate_limit,",
          "220:          tvb, offset, 4, ENC_BIG_ENDIAN );",
          "221:   offset += 4;",
          "222:  }",
          "225:  len = tvb_reported_length_remaining( tvb, offset );",
          "226:  if ( len > 0 ) {",
          "227:   proto_tree_add_item( applemidi_tree, hf_applemidi_unknown_data, tvb, offset, len, ENC_NA );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "283:  guint16   command;",
          "284:  conversation_t *p_conv;",
          "291:  if ( !test_applemidi( tvb, &command, FALSE ) ) {",
          "",
          "[Removed Lines]",
          "286:  rtp_dyn_payload_t *rtp_dyn_payload = NULL;",
          "288:  if ( tvb_length( tvb ) < 4)",
          "",
          "[Added Lines]",
          "283:  rtp_dyn_payload_t *rtp_dyn_payload;",
          "285:  if ( tvb_captured_length( tvb ) < 4)",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-gsm_abis_oml.c||epan/dissectors/packet-gsm_abis_oml.c": [
          "File: epan/dissectors/packet-gsm_abis_oml.c -> epan/dissectors/packet-gsm_abis_oml.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1817: {",
          "1818:  proto_item *ti;",
          "1819:  proto_tree *oml_tree;",
          "1821:  int offset = 0;",
          "1823:  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"OML\");",
          "1825:  top_tree = tree;",
          "1869:   }",
          "1870:  }",
          "",
          "[Removed Lines]",
          "1827:   guint8 msg_disc = tvb_get_guint8(tvb, offset);",
          "1828:   guint8 len = tvb_get_guint8(tvb, offset+3);",
          "1830:   ti = proto_tree_add_item(tree, proto_abis_oml, tvb, 0, -1, ENC_NA);",
          "1831:   oml_tree = proto_item_add_subtree(ti, ett_oml);",
          "1833:   proto_tree_add_item(oml_tree, hf_oml_msg_disc, tvb, offset++,",
          "1834:         1, ENC_LITTLE_ENDIAN);",
          "1835:   proto_tree_add_item(oml_tree, hf_oml_placement, tvb, offset++,",
          "1836:         1, ENC_LITTLE_ENDIAN);",
          "1837:   proto_tree_add_item(oml_tree, hf_oml_sequence, tvb, offset++,",
          "1838:         1, ENC_LITTLE_ENDIAN);",
          "1839:   proto_tree_add_item(oml_tree, hf_oml_length, tvb, offset++,",
          "1840:         1, ENC_LITTLE_ENDIAN);",
          "1842:   if (global_oml_dialect == OML_DIALECT_ERICSSON) {",
          "1848:    tvbuff_t *subtvb;",
          "1849:    subtvb = tvb_new_subset_length(tvb, offset, len);",
          "1851:    if (sub_om2000)",
          "1852:     call_dissector(sub_om2000, subtvb, pinfo, tree);",
          "1853:   } else {",
          "1855:    switch (msg_disc) {",
          "1856:    case ABIS_OM_MDISC_FOM:",
          "1857:     offset = dissect_oml_fom(tvb, pinfo, oml_tree,",
          "1858:         offset, ti);",
          "1859:     break;",
          "1860:    case ABIS_OM_MDISC_MANUF:",
          "1861:     offset = dissect_oml_manuf(tvb, pinfo, oml_tree,",
          "1862:           offset, ti);",
          "1863:     break;",
          "1864:    case ABIS_OM_MDISC_MMI:",
          "1865:    case ABIS_OM_MDISC_TRAU:",
          "1866:    default:",
          "1867:     break;",
          "1868:    }",
          "",
          "[Added Lines]",
          "1822:  guint8     msg_disc = tvb_get_guint8(tvb, offset);",
          "1823:  guint8     len      = tvb_get_guint8(tvb, offset+3);",
          "1830:  ti = proto_tree_add_item(tree, proto_abis_oml, tvb, 0, -1, ENC_NA);",
          "1831:  oml_tree = proto_item_add_subtree(ti, ett_oml);",
          "1833:  proto_tree_add_item(oml_tree, hf_oml_msg_disc, tvb, offset++,",
          "1834:        1, ENC_LITTLE_ENDIAN);",
          "1835:  proto_tree_add_item(oml_tree, hf_oml_placement, tvb, offset++,",
          "1836:        1, ENC_LITTLE_ENDIAN);",
          "1837:  proto_tree_add_item(oml_tree, hf_oml_sequence, tvb, offset++,",
          "1838:        1, ENC_LITTLE_ENDIAN);",
          "1839:  proto_tree_add_item(oml_tree, hf_oml_length, tvb, offset++,",
          "1840:        1, ENC_LITTLE_ENDIAN);",
          "1842:  if (global_oml_dialect == OML_DIALECT_ERICSSON) {",
          "1848:   tvbuff_t *subtvb;",
          "1849:   subtvb = tvb_new_subset_length(tvb, offset, len);",
          "1851:   if (sub_om2000)",
          "1852:    call_dissector(sub_om2000, subtvb, pinfo, tree);",
          "1853:  } else {",
          "1855:   switch (msg_disc) {",
          "1856:   case ABIS_OM_MDISC_FOM:",
          "1857:    offset = dissect_oml_fom(tvb, pinfo, oml_tree,",
          "1858:        offset, ti);",
          "1859:    break;",
          "1860:   case ABIS_OM_MDISC_MANUF:",
          "1861:    offset = dissect_oml_manuf(tvb, pinfo, oml_tree,",
          "1862:          offset, ti);",
          "1863:    break;",
          "1864:   case ABIS_OM_MDISC_MMI:",
          "1865:   case ABIS_OM_MDISC_TRAU:",
          "1866:   default:",
          "1867:    break;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-netrom.c||epan/dissectors/packet-netrom.c": [
          "File: epan/dissectors/packet-netrom.c -> epan/dissectors/packet-netrom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: #define NETROM_PROTO_IP  0x0C",
          "75: static dissector_handle_t ip_handle;",
          "79: static int proto_netrom   = -1;",
          "",
          "[Removed Lines]",
          "76: static dissector_handle_t default_handle;",
          "",
          "[Added Lines]",
          "76: static dissector_handle_t data_handle;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "198:  guint8        op_code;",
          "199:  guint8        cct_index;",
          "200:  guint8        cct_id;",
          "203:  col_set_str( pinfo->cinfo, COL_PROTOCOL, \"NET/ROM\" );",
          "204:  col_clear( pinfo->cinfo, COL_INFO );",
          "",
          "[Removed Lines]",
          "201:  tvbuff_t     *next_tvb = NULL;",
          "",
          "[Added Lines]",
          "201:  tvbuff_t     *next_tvb;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "439:      if ( cct_index == NETROM_PROTO_IP && cct_id == NETROM_PROTO_IP )",
          "440:       call_dissector( ip_handle , next_tvb, pinfo, tree );",
          "441:      else",
          "444:      break;",
          "445:   case NETROM_INFO :",
          "446:   default   :",
          "448:      break;",
          "449:   }",
          "450: }",
          "",
          "[Removed Lines]",
          "442:       call_dissector( default_handle , next_tvb, pinfo, tree );",
          "447:      call_dissector( default_handle , next_tvb, pinfo, tree );",
          "",
          "[Added Lines]",
          "442:       call_dissector( data_handle , next_tvb, pinfo, tree );",
          "447:      call_dissector( data_handle , next_tvb, pinfo, tree );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "474:  next_tvb = tvb_new_subset_remaining(tvb, 7);",
          "477: }",
          "",
          "[Removed Lines]",
          "476:  call_dissector( default_handle , next_tvb, pinfo, tree );",
          "",
          "[Added Lines]",
          "476:  call_dissector( data_handle , next_tvb, pinfo, tree );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "626: {",
          "627:  dissector_add_uint( \"ax25.pid\", AX25_P_NETROM, create_dissector_handle( dissect_netrom, proto_netrom ) );",
          "632: }",
          "",
          "[Removed Lines]",
          "629:  ip_handle       = find_dissector( \"ip\" );",
          "630:  default_handle  = find_dissector( \"data\" );",
          "",
          "[Added Lines]",
          "629:  ip_handle   = find_dissector( \"ip\" );",
          "630:  data_handle = find_dissector( \"data\" );",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-pana.c||epan/dissectors/packet-pana.c": [
          "File: epan/dissectors/packet-pana.c -> epan/dissectors/packet-pana.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "461:                                                                               tvb, offset, avp_data_length,",
          "462:                                                                               ett_pana_avp, NULL, \"AVP Value (EAP packet)\");",
          "463:                                         eap_tvb = tvb_new_subset_length(tvb, offset, avp_data_length);",
          "467:                                         break;",
          "468:                                 }",
          "469:                                 case PANA_ENCAPSULATED: {",
          "",
          "[Removed Lines]",
          "464:                                         if (eap_handle != NULL) {",
          "465:                                                 call_dissector(eap_handle, eap_tvb, pinfo, avp_eap_tree);",
          "466:                                         }",
          "",
          "[Added Lines]",
          "464:                                         DISSECTOR_ASSERT_HINT(eap_handle, \"EAP Dissector not available\");",
          "465:                                         call_dissector(eap_handle, eap_tvb, pinfo, avp_eap_tree);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "652:         guint32 avp_length;",
          "658:         if(buffer_length < 12) {",
          "",
          "[Removed Lines]",
          "655:         buffer_length = tvb_length(tvb);",
          "",
          "[Added Lines]",
          "654:         buffer_length = tvb_captured_length(tvb);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rsl.c||epan/dissectors/packet-rsl.c": [
          "File: epan/dissectors/packet-rsl.c -> epan/dissectors/packet-rsl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "674:     guint8      ie_id;",
          "676:     if (is_mandatory == FALSE) {",
          "678:         if (ie_id != RSL_IE_CH_NO)",
          "679:             return offset;",
          "680:     }",
          "",
          "[Removed Lines]",
          "677:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "677:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "718:     guint8      ie_id;",
          "720:     if (is_mandatory == FALSE) {",
          "722:         if (ie_id != RSL_IE_LINK_ID)",
          "723:             return offset;",
          "724:     }",
          "729:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "730:     offset++;",
          "734:     if ((octet & 0x20) == 0x20) {",
          "",
          "[Removed Lines]",
          "721:         ie_id = tvb_get_guint8(tvb,offset);",
          "726:     ie_tree = proto_tree_add_subtree(tree, tvb,offset,2, ett_ie_link_id, NULL, \"Link Identifier IE \");",
          "732:     octet = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "721:         ie_id = tvb_get_guint8(tvb, offset);",
          "726:     ie_tree = proto_tree_add_subtree(tree, tvb, offset, 2, ett_ie_link_id, NULL, \"Link Identifier IE \");",
          "732:     octet = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "790:     guint       octet;",
          "792:     if (is_mandatory == FALSE) {",
          "794:         if (ie_id != RSL_IE_ACT_TYPE)",
          "795:             return offset;",
          "796:     }",
          "",
          "[Removed Lines]",
          "793:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "793:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "811:     proto_tree_add_item(ie_tree, hf_rsl_a3a2, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "812:     switch (octet) {",
          "813:     case 0:",
          "",
          "[Removed Lines]",
          "810:     octet = (tvb_get_guint8(tvb,offset) & 0x06) >> 1;",
          "",
          "[Added Lines]",
          "810:     octet = (tvb_get_guint8(tvb, offset) & 0x06) >> 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "871:     guint8      ie_id;",
          "873:     if (is_mandatory == FALSE) {",
          "875:         if (ie_id != RSL_IE_BS_POW)",
          "876:             return offset;",
          "877:     }",
          "",
          "[Removed Lines]",
          "874:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "874:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "910:     guint8      ie_id;",
          "912:     if (is_mandatory == FALSE) {",
          "914:         if (ie_id != RSL_IE_CH_ID)",
          "915:             return offset;",
          "916:     }",
          "",
          "[Removed Lines]",
          "913:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "913:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "937:     de_rr_ch_dsc(tvb, ie_tree, pinfo, offset+1, length, NULL, 0);",
          "938:     offset += 4;",
          "944:     return ie_offset + length;",
          "945: }",
          "",
          "[Removed Lines]",
          "936:     proto_tree_add_text(ie_tree, tvb,offset, 1, \"Channel Description Tag\");",
          "943:     proto_tree_add_text(ie_tree, tvb,offset,2,\"Mobile Allocation Tag+Length(0)\");",
          "",
          "[Added Lines]",
          "936:     proto_tree_add_text(ie_tree, tvb, offset, 1, \"Channel Description Tag\");",
          "943:     proto_tree_add_text(ie_tree, tvb, offset, 2, \"Mobile Allocation Tag+Length(0)\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1027:     guint8      octet;",
          "1029:     if (is_mandatory == FALSE) {",
          "1031:         if (ie_id != RSL_IE_CH_MODE)",
          "1032:             return offset;",
          "1033:     }",
          "",
          "[Removed Lines]",
          "1030:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1030:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1053:     offset++;",
          "1055:     proto_tree_add_item(ie_tree, hf_rsl_speech_or_data, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1057:     offset++;",
          "1059:     proto_tree_add_item(ie_tree, hf_rsl_ch_rate_and_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "1056:     octet = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1056:     octet = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1069:         proto_tree_add_item(ie_tree, hf_rsl_extension_bit, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1070:         proto_tree_add_item(ie_tree, hf_rsl_t_nt_bit, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1072:         if ((octet & 0x40) == 0x40) {",
          "",
          "[Removed Lines]",
          "1071:         octet = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1071:         octet = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1087:         break;",
          "1088:     default:",
          "1091:         break;",
          "1092:     }",
          "",
          "[Removed Lines]",
          "1086:         proto_tree_add_text(ie_tree, tvb,offset,1,\"0 No resources required(All other values are reserved)\");",
          "1090:         proto_tree_add_text(ie_tree, tvb,offset,1,\"Speech or data indicator != 1,2 or 3\");",
          "",
          "[Added Lines]",
          "1086:         proto_tree_add_text(ie_tree, tvb, offset, 1, \"0 No resources required(All other values are reserved)\");",
          "1090:         proto_tree_add_text(ie_tree, tvb, offset, 1, \"Speech or data indicator != 1,2 or 3\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1123:     guint8      ie_id;",
          "1125:     if (is_mandatory == FALSE) {",
          "1127:         if (ie_id != RSL_IE_ENC_INF)",
          "1128:             return offset;",
          "1129:     }",
          "",
          "[Removed Lines]",
          "1126:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1126:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1158:     guint8      ie_id;",
          "1160:     if (is_mandatory == FALSE) {",
          "1162:         if (ie_id != RSL_IE_FRAME_NO)",
          "1163:             return offset;",
          "1164:     }",
          "",
          "[Removed Lines]",
          "1161:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1161:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1188:     guint8      ie_id;",
          "1190:     if (is_mandatory == FALSE) {",
          "1192:         if (ie_id != RSL_IE_HO_REF)",
          "1193:             return offset;",
          "1194:     }",
          "",
          "[Removed Lines]",
          "1191:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1191:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1217:     guint8      ie_id;",
          "1219:     if (is_mandatory == FALSE) {",
          "1221:         if (ie_id != RSL_IE_L1_INF)",
          "1222:             return offset;",
          "1223:     }",
          "",
          "[Removed Lines]",
          "1220:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1220:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1266:     guint8      ie_id;",
          "1268:     if (is_mandatory == FALSE) {",
          "1270:         if (ie_id != RSL_IE_L3_INF)",
          "1271:             return offset;",
          "1272:     }",
          "",
          "[Removed Lines]",
          "1269:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1269:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1285:     if (type == L3_INF_CCCH)",
          "1286:     {",
          "1289:        next_tvb = tvb_new_subset_length(tvb, offset, length);",
          "1290:        call_dissector(gsm_a_ccch_handle, next_tvb, pinfo, top_tree);",
          "1291:     }",
          "1292:     else if (type == L3_INF_SACCH)",
          "1293:     {",
          "1296:        next_tvb = tvb_new_subset_length(tvb, offset, length);",
          "1297:        call_dissector(gsm_a_sacch_handle, next_tvb, pinfo, top_tree);",
          "1298:     }",
          "",
          "[Removed Lines]",
          "1288:        proto_tree_add_text(ie_tree, tvb,offset,length,\"Link Layer Service Data Unit (L3 Message)(CCCH)\");",
          "1295:        proto_tree_add_text(ie_tree, tvb,offset,length,\"Link Layer Service Data Unit (L3 Message)(SACCH)\");",
          "",
          "[Added Lines]",
          "1288:        proto_tree_add_text(ie_tree, tvb, offset, length, \"Link Layer Service Data Unit (L3 Message)(CCCH)\");",
          "1295:        proto_tree_add_text(ie_tree, tvb, offset, length, \"Link Layer Service Data Unit (L3 Message)(SACCH)\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1305:        next_tvb = tvb_new_subset_length(tvb, offset, length);",
          "1306:        call_dissector(gsm_a_dtap_handle, next_tvb, pinfo, top_tree);",
          "1307:     }",
          "",
          "[Removed Lines]",
          "1304:        proto_tree_add_text(ie_tree, tvb,offset,length,\"Link Layer Service Data Unit (L3 Message)\");",
          "",
          "[Added Lines]",
          "1304:        proto_tree_add_text(ie_tree, tvb, offset, length, \"Link Layer Service Data Unit (L3 Message)\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1323:     guint8      ie_id;",
          "1325:     if (is_mandatory == FALSE) {",
          "1327:         if (ie_id != RSL_IE_MS_ID)",
          "1328:             return offset;",
          "1329:     }",
          "",
          "[Removed Lines]",
          "1326:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1326:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1333:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1334:     offset++;",
          "1337:     proto_item_set_len(ti, length+2);",
          "1338:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1339:     offset++;",
          "",
          "[Removed Lines]",
          "1336:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1336:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1359:     guint8      ie_id;",
          "1361:     if (is_mandatory == FALSE) {",
          "1363:         if (ie_id != RSL_IE_MS_POW)",
          "1364:             return offset;",
          "1365:     }",
          "",
          "[Removed Lines]",
          "1362:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1362:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1390:     guint8      ie_id;",
          "1392:     if (is_mandatory == FALSE) {",
          "1394:         if (ie_id != RSL_IE_PAGING_GRP)",
          "1395:             return offset;",
          "1396:     }",
          "",
          "[Removed Lines]",
          "1393:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1393:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1420:     guint8      ie_id;",
          "1422:     if (is_mandatory == FALSE) {",
          "1424:         if (ie_id != RSL_IE_PAGING_LOAD)",
          "1425:             return offset;",
          "1426:     }",
          "",
          "[Removed Lines]",
          "1423:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1423:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1451:     guint8      ie_id;",
          "1453:     if (is_mandatory == FALSE) {",
          "1455:         if (ie_id != RSL_IE_PHY_CTX)",
          "1456:             return offset;",
          "1457:     }",
          "",
          "[Removed Lines]",
          "1454:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1454:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1462:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1463:     offset++;",
          "1466:     proto_item_set_len(ti, length+2);",
          "1467:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1468:     offset++;",
          "",
          "[Removed Lines]",
          "1465:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1465:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1488:     guint8      ie_id;",
          "1490:     if (is_mandatory == FALSE) {",
          "1492:         if (ie_id != RSL_IE_ACCESS_DELAY)",
          "1493:             return offset;",
          "1494:     }",
          "",
          "[Removed Lines]",
          "1491:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1491:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1517:     int         ie_offset;",
          "1519:     if (is_mandatory == FALSE) {",
          "1521:         if (ie_id != RSL_IE_RACH_LOAD)",
          "1522:             return offset;",
          "1523:     }",
          "",
          "[Removed Lines]",
          "1520:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1520:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1528:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1529:     offset++;",
          "1532:     proto_item_set_len(ti, length+2);",
          "1533:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1534:     offset++;",
          "",
          "[Removed Lines]",
          "1531:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1531:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1556:     if ( length > 0) {",
          "1558:     }",
          "1559:     offset = ie_offset + length;",
          "",
          "[Removed Lines]",
          "1557:         proto_tree_add_text(ie_tree, tvb, offset,length ,\"Supplementary Information\");",
          "",
          "[Added Lines]",
          "1557:         proto_tree_add_text(ie_tree, tvb, offset, length , \"Supplementary Information\");",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1571:     guint8      ie_id;",
          "1573:     if (is_mandatory == FALSE) {",
          "1575:         if (ie_id != RSL_IE_REQ_REF)",
          "1576:             return offset;",
          "1577:     }",
          "",
          "[Removed Lines]",
          "1574:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1574:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1607:     guint8      ie_id;",
          "1609:     if (is_mandatory == FALSE) {",
          "1611:         if (ie_id != RSL_IE_REL_MODE)",
          "1612:             return offset;",
          "1613:     }",
          "",
          "[Removed Lines]",
          "1610:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1610:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1661:     int         ie_offset;",
          "1663:     if (is_mandatory == FALSE) {",
          "1665:         if (ie_id != RSL_IE_RESOURCE_INF)",
          "1666:             return offset;",
          "1667:     }",
          "",
          "[Removed Lines]",
          "1664:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1664:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1673:     offset++;",
          "1677:     proto_item_set_len(ti, length+2);",
          "1679:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "1676:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1676:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1714:     guint8      ie_id;",
          "1716:     if (is_mandatory == FALSE) {",
          "1718:         if (ie_id != RSL_IE_RLM_CAUSE)",
          "1719:             return offset;",
          "1720:     }",
          "",
          "[Removed Lines]",
          "1717:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1717:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1725:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1726:     offset++;",
          "1729:     proto_item_set_len(ti, length+2);",
          "1731:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "1728:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1728:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1753:     guint8      ie_id;",
          "1755:     if (is_mandatory == FALSE) {",
          "1757:         if (ie_id != RSL_IE_STARTING_TIME)",
          "1758:             return offset;",
          "1759:     }",
          "",
          "[Removed Lines]",
          "1756:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1756:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1783:     guint8      ie_id;",
          "1785:     if (is_mandatory == FALSE) {",
          "1787:         if (ie_id != RSL_IE_TIMING_ADV)",
          "1788:             return offset;",
          "1789:     }",
          "",
          "[Removed Lines]",
          "1786:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1786:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1818:     guint8      ie_id;",
          "1820:     if (is_mandatory == FALSE) {",
          "1822:         if (ie_id != RSL_IE_UPLINK_MEAS)",
          "1823:             return offset;",
          "1824:     }",
          "",
          "[Removed Lines]",
          "1821:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1821:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1830:     offset++;",
          "1834:     proto_item_set_len(ti, length+2);",
          "1836:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "1833:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1833:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1891:     guint8      ie_id;",
          "1893:     if (is_mandatory == FALSE) {",
          "1895:         if (ie_id != RSL_IE_CAUSE)",
          "1896:             return offset;",
          "1897:     }",
          "",
          "[Removed Lines]",
          "1894:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1894:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1902:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1903:     offset++;",
          "1906:     proto_item_set_len(ti, length+2);",
          "1907:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1908:     offset++;",
          "1909:     ie_offset = offset;",
          "1913:     proto_tree_add_item(tree, hf_rsl_extension_bit, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1914:     proto_tree_add_item(tree, hf_rsl_class, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1915:     if ((octet & 0x80) == 0x80)",
          "",
          "[Removed Lines]",
          "1905:     length = tvb_get_guint8(tvb,offset);",
          "1912:     octet = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1905:     length = tvb_get_guint8(tvb, offset);",
          "1912:     octet = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1930:     guint8      ie_id;",
          "1932:     if (is_mandatory == FALSE) {",
          "1934:         if (ie_id != RSL_IE_MEAS_RES_NO)",
          "1935:             return offset;",
          "1936:     }",
          "",
          "[Removed Lines]",
          "1933:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1933:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1957:     guint8      ie_id;",
          "1959:     if (is_mandatory == FALSE) {",
          "1961:         if (ie_id != RSL_IE_MESSAGE_ID)",
          "1962:             return offset;",
          "1963:     }",
          "",
          "[Removed Lines]",
          "1960:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "1960:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2012:     guint8      ie_id;",
          "2014:     if (is_mandatory == FALSE) {",
          "2016:         if (ie_id != RSL_IE_SYS_INFO_TYPE) {",
          "2018:             return offset;",
          "",
          "[Removed Lines]",
          "2015:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2015:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2046:     guint8      ie_id;",
          "2048:     if (is_mandatory == FALSE) {",
          "2050:         if (ie_id != RSL_IE_FULL_IMM_ASS_INF)",
          "2051:             return offset;",
          "2052:     }",
          "",
          "[Removed Lines]",
          "2049:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2049:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2057:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2058:     offset++;",
          "2061:     proto_item_set_len(ti, length+2);",
          "2063:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "2060:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2060:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2071:     next_tvb = tvb_new_subset_length(tvb, offset, length);",
          "2072:     call_dissector(gsm_a_ccch_handle, next_tvb, pinfo, top_tree);",
          "",
          "[Removed Lines]",
          "2070:     proto_tree_add_text(ie_tree, tvb,offset,length,\"Full Immediate Assign Info field\");",
          "",
          "[Added Lines]",
          "2070:     proto_tree_add_text(ie_tree, tvb, offset, length, \"Full Immediate Assign Info field\");",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2093:     guint8      ie_id;",
          "2095:     if (is_mandatory == FALSE) {",
          "2097:         if (ie_id != RSL_IE_SMSCB_INF)",
          "2098:             return offset;",
          "2099:     }",
          "",
          "[Removed Lines]",
          "2096:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2096:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2104:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2105:     offset++;",
          "2108:     proto_item_set_len(ti, length+2);",
          "2110:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "2107:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2107:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2131:     guint8      ie_id;",
          "2133:     if (is_mandatory == FALSE) {",
          "2135:         if (ie_id != RSL_IE_FULL_MS_TIMING_OFFSET)",
          "2136:             return offset;",
          "2137:     }",
          "",
          "[Removed Lines]",
          "2134:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2134:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2167:     guint       length;",
          "2168:     guint8      ie_id;",
          "2169:     if (is_mandatory == FALSE) {",
          "2171:         if (ie_id != RSL_IE_ERR_MSG)",
          "2172:             return offset;",
          "2173:     }",
          "",
          "[Removed Lines]",
          "2170:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2170:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2178:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2179:     offset++;",
          "2182:     proto_item_set_len(ti, length+2);",
          "2184:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "2181:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2181:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2203:     guint8      ie_id;",
          "2205:     if (is_mandatory == FALSE) {",
          "2207:         if (ie_id != RSL_IE_FULL_BCCH_INF)",
          "2208:             return offset;",
          "2209:     }",
          "",
          "[Removed Lines]",
          "2206:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2206:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "2227:     next_tvb = tvb_new_subset_length(tvb, offset, length);",
          "2228:     call_dissector(gsm_a_ccch_handle, next_tvb, pinfo, top_tree);",
          "",
          "[Removed Lines]",
          "2226:     proto_tree_add_text(ie_tree, tvb,offset,length,\"Layer 3 message\");",
          "",
          "[Added Lines]",
          "2226:     proto_tree_add_text(ie_tree, tvb, offset, length, \"Layer 3 message\");",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "2250:     guint8      ie_id;",
          "2252:     if (is_mandatory == FALSE) {",
          "2254:         if (ie_id != RSL_IE_CH_NEEDED)",
          "2255:             return offset;",
          "2256:     }",
          "",
          "[Removed Lines]",
          "2253:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2253:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2278:     guint8      ie_id;",
          "2280:     if (is_mandatory == FALSE) {",
          "2282:         if (ie_id != RSL_IE_CB_CMD_TYPE)",
          "2283:             return offset;",
          "2284:     }",
          "",
          "[Removed Lines]",
          "2281:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2281:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2310:     int         ie_offset;",
          "2312:     if (is_mandatory == FALSE) {",
          "2314:         if (ie_id != RSL_IE_SMSCB_MESS)",
          "2315:             return offset;",
          "2316:     }",
          "",
          "[Removed Lines]",
          "2313:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2313:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "2320:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2321:     offset++;",
          "2324:     proto_item_set_len(ti, length+2);",
          "2325:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2326:     offset++;",
          "",
          "[Removed Lines]",
          "2323:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2323:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2356:     guint8      octet;",
          "2358:     if (is_mandatory == FALSE) {",
          "2360:         if (ie_id != RSL_IE_CBCH_LOAD_INF)",
          "2361:             return offset;",
          "2362:     }",
          "",
          "[Removed Lines]",
          "2359:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2359:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "2367:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2368:     offset++;",
          "2372:     proto_tree_add_item(ie_tree, hf_rsl_cbch_load_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2375:     item = proto_tree_add_item(ie_tree, hf_rsl_msg_slt_cnt, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2376:     if ((octet & 0x80) == 0x80) {",
          "2378:     }else{",
          "2380:     }",
          "2381:     offset++;",
          "",
          "[Removed Lines]",
          "2370:     octet = tvb_get_guint8(tvb,offset);",
          "2377:         proto_item_append_text(item,\"The amount of SMSCB messages (1 to 15) that are needed immediately by BTS\");",
          "2379:         proto_item_append_text(item,\"The amount of delay in message slots (1 to 15) that is needed immediately by BTS\");",
          "",
          "[Added Lines]",
          "2370:     octet = tvb_get_guint8(tvb, offset);",
          "2377:         proto_item_append_text(item, \"The amount of SMSCB messages (1 to 15) that are needed immediately by BTS\");",
          "2379:         proto_item_append_text(item, \"The amount of delay in message slots (1 to 15) that is needed immediately by BTS\");",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "2400:     guint8      ie_id;",
          "2402:     if (is_mandatory == FALSE) {",
          "2404:         if (ie_id != RSL_IE_SMSCB_CH_IND)",
          "2405:             return offset;",
          "2406:     }",
          "",
          "[Removed Lines]",
          "2403:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2403:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "2430:     guint8      ie_id;",
          "2432:     if (is_mandatory == FALSE) {",
          "2434:         if (ie_id != RSL_IE_GRP_CALL_REF)",
          "2435:             return offset;",
          "2436:     }",
          "",
          "[Removed Lines]",
          "2433:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2433:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "2440:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2441:     offset++;",
          "2444:     proto_item_set_len(ti, length+2);",
          "2445:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2446:     offset++;",
          "",
          "[Removed Lines]",
          "2443:     length = tvb_get_guint8(tvb,offset);",
          "2448:     proto_tree_add_text(ie_tree, tvb,offset,length,\"Descriptive group or broadcast call reference\");",
          "",
          "[Added Lines]",
          "2443:     length = tvb_get_guint8(tvb, offset);",
          "2448:     proto_tree_add_text(ie_tree, tvb, offset, length, \"Descriptive group or broadcast call reference\");",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2469:     guint8      ie_id;",
          "2471:     if (is_mandatory == FALSE) {",
          "2473:         if (ie_id != RSL_IE_CH_DESC)",
          "2474:             return offset;",
          "2475:     }",
          "",
          "[Removed Lines]",
          "2472:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2472:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2479:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2480:     offset++;",
          "2483:     proto_item_set_len(ti, length+2);",
          "2484:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2485:     offset++;",
          "",
          "[Removed Lines]",
          "2482:     length = tvb_get_guint8(tvb,offset);",
          "2487:     proto_tree_add_text(ie_tree, tvb,offset,length,\"Group Channel Description\");",
          "",
          "[Added Lines]",
          "2482:     length = tvb_get_guint8(tvb, offset);",
          "2487:     proto_tree_add_text(ie_tree, tvb, offset, length, \"Group Channel Description\");",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2507:     guint8      ie_id;",
          "2509:     if (is_mandatory == FALSE) {",
          "2511:         if (ie_id != RSL_IE_NCH_DRX_INF)",
          "2512:             return offset;",
          "2513:     }",
          "",
          "[Removed Lines]",
          "2510:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2510:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2543:     guint8      octet;",
          "2545:     if (is_mandatory == FALSE) {",
          "2547:         if (ie_id != RSL_IE_CMD_IND)",
          "2548:             return offset;",
          "2549:     }",
          "",
          "[Removed Lines]",
          "2546:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2546:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2565:     if ((octet & 0x80) == 0x80) {",
          "",
          "[Removed Lines]",
          "2564:     octet = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2564:     octet = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2597:     guint8      ie_id;",
          "2599:     if (is_mandatory == FALSE) {",
          "2601:         if (ie_id != RSL_IE_EMLPP_PRIO)",
          "2602:             return offset;",
          "2603:     }",
          "",
          "[Removed Lines]",
          "2600:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2600:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2629:     guint8      ie_id;",
          "2631:     if (is_mandatory == FALSE) {",
          "2633:         if (ie_id != RSL_IE_UIC)",
          "2634:             return offset;",
          "2635:     }",
          "",
          "[Removed Lines]",
          "2632:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2632:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2647:     offset++;",
          "2649:     return offset;",
          "",
          "[Removed Lines]",
          "2646:     proto_tree_add_text(ie_tree, tvb,offset,1,\"UIC\");",
          "",
          "[Added Lines]",
          "2646:     proto_tree_add_text(ie_tree, tvb, offset, 1, \"UIC\");",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2660:     guint8      ie_id;",
          "2662:     if (is_mandatory == FALSE) {",
          "2664:         if (ie_id != RSL_IE_MAIN_CH_REF)",
          "2665:             return offset;",
          "2666:     }",
          "",
          "[Removed Lines]",
          "2663:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2663:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2692:     guint8      ie_id;",
          "2694:     if (is_mandatory == FALSE) {",
          "2696:         if (ie_id != RSL_IE_MULTIRATE_CONF)",
          "2697:             return offset;",
          "2698:     }",
          "",
          "[Removed Lines]",
          "2695:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2695:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2702:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2703:     offset++;",
          "2706:     proto_item_set_len(ti, length+2);",
          "2707:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2708:     offset++;",
          "",
          "[Removed Lines]",
          "2705:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2705:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2728:     guint8      ie_id;",
          "2730:     if (is_mandatory == FALSE) {",
          "2732:         if (ie_id != RSL_IE_MULTIRATE_CNTRL)",
          "2733:             return offset;",
          "2734:     }",
          "",
          "[Removed Lines]",
          "2731:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2731:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2762:     guint8      ie_id;",
          "2764:     if (is_mandatory == FALSE) {",
          "2766:         if (ie_id != RSL_IE_SUP_CODEC_TYPES)",
          "2767:             return offset;",
          "2768:     }",
          "",
          "[Removed Lines]",
          "2765:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2765:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2772:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2773:     offset++;",
          "2776:     proto_item_set_len(ti, length+2);",
          "2777:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2778:     offset++;",
          "",
          "[Removed Lines]",
          "2775:     length = tvb_get_guint8(tvb,offset);",
          "2780:     proto_tree_add_text(tree, tvb,offset,length,\"Codec List\");",
          "",
          "[Added Lines]",
          "2775:     length = tvb_get_guint8(tvb, offset);",
          "2780:     proto_tree_add_text(tree, tvb, offset, length, \"Codec List\");",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2829:     guint8      ie_id;",
          "2831:     if (is_mandatory == FALSE) {",
          "2833:         if (ie_id != RSL_IE_CODEC_CONF)",
          "2834:             return offset;",
          "2835:     }",
          "",
          "[Removed Lines]",
          "2832:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2832:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2839:     proto_tree_add_item(ie_tree, hf_rsl_ie_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2840:     offset++;",
          "2843:     proto_item_set_len(ti, length+2);",
          "2844:     proto_tree_add_item(ie_tree, hf_rsl_ie_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2845:     offset++;",
          "",
          "[Removed Lines]",
          "2842:     length = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2842:     length = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "2869:     guint8      rtd;",
          "2871:     if (is_mandatory == FALSE) {",
          "2873:         if (ie_id != RSL_IE_RTD)",
          "2874:             return offset;",
          "2875:     }",
          "",
          "[Removed Lines]",
          "2872:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2872:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "2886:     rtd = (tvb_get_guint8(tvb,offset)>>1)*20;",
          "2887:     rtd_item = proto_tree_add_uint(tree, hf_rsl_rtd, tvb,offset,1,rtd);",
          "2888:     proto_item_append_text(rtd_item,\" ms\");",
          "",
          "[Added Lines]",
          "2886:     rtd = (tvb_get_guint8(tvb, offset)>>1)*20;",
          "2887:     rtd_item = proto_tree_add_uint(tree, hf_rsl_rtd, tvb, offset, 1, rtd);",
          "2888:     proto_item_append_text(rtd_item, \" ms\");",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "2912:     guint8      ie_id;",
          "2914:     if (is_mandatory == FALSE) {",
          "2916:         if (ie_id != RSL_IE_TFO_STATUS)",
          "2917:             return offset;",
          "2918:     }",
          "",
          "[Removed Lines]",
          "2915:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2915:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "2941:     guint8      ie_id;",
          "2943:     if (is_mandatory == FALSE) {",
          "2945:         if (ie_id != RSL_IE_LLP_APDU)",
          "2946:             return offset;",
          "2947:     }",
          "",
          "[Removed Lines]",
          "2944:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2944:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "2969:         \"Facility Information Element as defined in 3GPP TS 44.071\");",
          "2970:     return ie_offset + length;",
          "2971: }",
          "",
          "[Removed Lines]",
          "2968:     proto_tree_add_text(tree, tvb,offset,length,",
          "",
          "[Added Lines]",
          "2968:     proto_tree_add_text(tree, tvb, offset, length,",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "2986:     guint8      ie_id;",
          "2988:     if (is_mandatory == FALSE) {",
          "2990:         if (ie_id != RSL_IE_TFO_TRANSP_CONT)",
          "2991:             return offset;",
          "2992:     }",
          "",
          "[Removed Lines]",
          "2989:         ie_id = tvb_get_guint8(tvb,offset);",
          "",
          "[Added Lines]",
          "2989:         ie_id = tvb_get_guint8(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "3013:         \"Embedded message that contains the TFO configuration\");",
          "3014:     return ie_offset + length;",
          "3015: }",
          "",
          "[Removed Lines]",
          "3012:     proto_tree_add_text(tree, tvb,offset,length,",
          "",
          "[Added Lines]",
          "3012:     proto_tree_add_text(tree, tvb, offset, length,",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "3158:     guint8 msg_disc, msg_type, sys_info_type;",
          "3160:     msg_disc = tvb_get_guint8(tvb, offset++) >> 1;",
          "3162:     proto_tree_add_item(tree, hf_rsl_msg_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "3164:     if (msg_disc == RSL_MSGDISC_IPACCESS) {",
          "",
          "[Removed Lines]",
          "3161:     msg_type = tvb_get_guint8(tvb,offset) & 0x7f;",
          "",
          "[Added Lines]",
          "3161:     msg_type = tvb_get_guint8(tvb, offset) & 0x7f;",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "3218:         offset = dissect_rsl_ie_link_id(tvb, pinfo, tree, offset, TRUE);",
          "3221:             offset = dissect_rsl_ie_L3_inf(tvb, pinfo, tree, offset, FALSE, L3_INF_OTHER);",
          "3222:         break;",
          "",
          "[Removed Lines]",
          "3220:         if (tvb_length_remaining(tvb,offset) >1)",
          "",
          "[Added Lines]",
          "3220:         if (tvb_reported_length_remaining(tvb, offset) >1)",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "3251:         offset = dissect_rsl_ie_link_id(tvb, pinfo, tree, offset, TRUE);",
          "3254:             offset = dissect_rsl_ie_L3_inf(tvb, pinfo, tree, offset, FALSE, L3_INF_OTHER);",
          "3255:         break;",
          "",
          "[Removed Lines]",
          "3253:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3253:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "3262:         offset = dissect_rsl_ie_sys_info_type(tvb, pinfo, tree, offset, TRUE, &sys_info_type);",
          "3265:             offset = dissect_rsl_ie_full_bcch_inf(tvb, pinfo, tree, offset, TRUE);",
          "3268:             offset = dissect_rsl_ie_starting_time(tvb, pinfo, tree, offset, FALSE);",
          "3269:         break;",
          "",
          "[Removed Lines]",
          "3264:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3267:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3264:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3267:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "3276:         offset = dissect_rsl_ie_rach_load(tvb, pinfo, tree, offset, FALSE);",
          "3279:             offset = dissect_rsl_ie_paging_load(tvb, pinfo, tree, offset, FALSE);",
          "3280:         break;",
          "",
          "[Removed Lines]",
          "3278:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3278:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "3288:         offset = dissect_rsl_ie_access_delay(tvb, pinfo, tree, offset, TRUE);",
          "3291:             offset = dissect_rsl_ie_phy_ctx(tvb, pinfo, tree, offset, FALSE);",
          "3292:         break;",
          "",
          "[Removed Lines]",
          "3290:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3290:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "3306:         offset = dissect_rsl_ie_ms_id(tvb, pinfo, tree, offset, TRUE);",
          "3309:             offset = dissect_rsl_ie_ch_needed(tvb, pinfo, tree, offset, FALSE);",
          "3312:             offset = dissect_rsl_ie_emlpp_prio(tvb, pinfo, tree, offset, FALSE);",
          "3313:         break;",
          "",
          "[Removed Lines]",
          "3308:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3311:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3308:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3311:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "3326:         offset = dissect_rsl_ie_smscb_inf(tvb, pinfo, tree, offset, TRUE);",
          "3329:             offset = dissect_rsl_ie_smscb_ch_ind(tvb, pinfo, tree, offset, FALSE);",
          "3330:         break;",
          "",
          "[Removed Lines]",
          "3328:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3328:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "3340:         offset = dissect_rsl_ie_sys_info_type(tvb, pinfo, tree, offset, TRUE, &sys_info_type);",
          "3343:            offset = dissect_rsl_ie_L3_inf(tvb, pinfo, tree, offset, FALSE,",
          "3344:                                           (sys_info_type == 0x48) ? L3_INF_SACCH : L3_INF_OTHER);",
          "3347:             offset = dissect_rsl_ie_starting_time(tvb, pinfo, tree, offset, FALSE);",
          "3348:         break;",
          "",
          "[Removed Lines]",
          "3342:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3346:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3342:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3346:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "3355:         offset = dissect_rsl_ie_cause(tvb, pinfo, tree, offset, TRUE);",
          "3358:             offset = dissect_rsl_ie_message_id(tvb, pinfo, tree, offset, FALSE);",
          "3361:             offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3364:             offset = dissect_rsl_ie_link_id(tvb, pinfo, tree, offset, TRUE);",
          "3367:             offset = dissect_rsl_ie_err_msg(tvb, pinfo, tree, offset, TRUE);",
          "3368:         break;",
          "",
          "[Removed Lines]",
          "3357:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3360:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3363:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3366:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3357:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3360:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3363:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3366:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "3376:         offset = dissect_rsl_ie_smscb_mess(tvb, pinfo, tree, offset, TRUE);",
          "3379:             offset = dissect_rsl_ie_smscb_ch_ind(tvb, pinfo, tree, offset, FALSE);",
          "3380:         break;",
          "",
          "[Removed Lines]",
          "3378:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3378:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "3385:         offset = dissect_rsl_ie_cbch_load_inf(tvb, pinfo, tree, offset, TRUE);",
          "3388:             offset = dissect_rsl_ie_smscb_ch_ind(tvb, pinfo, tree, offset, FALSE);",
          "3389:         break;",
          "",
          "[Removed Lines]",
          "3387:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3387:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "3394:         offset = dissect_rsl_ie_cmd_ind(tvb, pinfo, tree, offset, TRUE);",
          "3397:             offset = dissect_rsl_ie_grp_call_ref(tvb, pinfo, tree, offset, FALSE);",
          "3400:             offset = dissect_rsl_ie_ch_desc(tvb, pinfo, tree, offset, FALSE);",
          "3403:             offset = dissect_rsl_ie_nch_drx(tvb, pinfo, tree, offset, FALSE);",
          "3404:         break;",
          "",
          "[Removed Lines]",
          "3396:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3399:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3402:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3396:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3399:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3402:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "3414:         offset = dissect_rsl_ie_ch_mode(tvb, pinfo, tree, offset, TRUE);",
          "3417:             offset = dissect_rsl_ie_ch_id(tvb, pinfo, tree, offset, FALSE);",
          "3420:             offset = dissect_rsl_ie_enc_inf(tvb, pinfo, tree, offset, FALSE);",
          "3423:             offset = dissect_rsl_ie_ho_ref(tvb, pinfo, tree, offset, FALSE);",
          "3426:             offset = dissect_rsl_ie_bs_power(tvb, pinfo, tree, offset, FALSE);",
          "3429:             offset = dissect_rsl_ie_ms_pow(tvb, pinfo, tree, offset, FALSE);",
          "3432:             offset = dissect_rsl_ie_timing_adv(tvb, pinfo, tree, offset, FALSE);",
          "3437:             offset = dissect_rsl_ie_phy_ctx(tvb, pinfo, tree, offset, FALSE);",
          "3441:             offset = dissect_rsl_ie_uic(tvb, pinfo, tree, offset, FALSE);",
          "3444:             offset = dissect_rsl_ie_main_ch_ref(tvb, pinfo, tree, offset, FALSE);",
          "3447:             offset = dissect_rsl_ie_multirate_conf(tvb, pinfo, tree, offset, FALSE);",
          "3450:             offset = dissect_rsl_ie_multirate_cntrl(tvb, pinfo, tree, offset, FALSE);",
          "3453:             offset = dissect_rsl_ie_sup_codec_types(tvb, pinfo, tree, offset, FALSE);",
          "3456:             offset = dissect_rsl_ie_tfo_transp_cont(tvb, pinfo, tree, offset, FALSE);",
          "3457:         break;",
          "",
          "[Removed Lines]",
          "3416:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3419:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3422:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3425:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3428:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3431:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3436:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3440:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3443:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3446:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3449:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3452:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3455:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3416:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3419:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3422:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3425:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3428:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3431:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3436:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3440:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3443:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3446:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3449:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3452:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3455:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "3499:         offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3502:             offset = dissect_rsl_ie_access_delay(tvb, pinfo, tree, offset, FALSE);",
          "3503:         break;",
          "",
          "[Removed Lines]",
          "3501:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3501:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "3513:         offset = dissect_rsl_ie_bs_power(tvb, pinfo, tree, offset, TRUE);",
          "3516:             offset = dissect_rsl_ie_l1_inf(tvb, pinfo, tree, offset, FALSE);",
          "3520:             if ( ( tvb_get_guint8(tvb, offset+3) & 0xFE ) == 0x10 ) {",
          "",
          "[Removed Lines]",
          "3515:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3518:         if (tvb_length_remaining(tvb,offset) > 0){",
          "",
          "[Added Lines]",
          "3515:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3518:         if (tvb_reported_length_remaining(tvb, offset) > 0){",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "3525:             }",
          "3526:         }",
          "3529:             offset = dissect_rsl_ie_ms_timing_offset(tvb, pinfo, tree, offset, FALSE);",
          "3530:         break;",
          "",
          "[Removed Lines]",
          "3528:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3528:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "3536:         offset = dissect_rsl_ie_ch_mode(tvb, pinfo, tree, offset, TRUE);",
          "3539:             offset = dissect_rsl_ie_enc_inf(tvb, pinfo, tree, offset, FALSE);",
          "3542:             offset = dissect_rsl_ie_main_ch_ref(tvb, pinfo, tree, offset, FALSE);",
          "3545:             offset = dissect_rsl_ie_multirate_conf(tvb, pinfo, tree, offset, FALSE);",
          "3548:             offset = dissect_rsl_ie_multirate_cntrl(tvb, pinfo, tree, offset, FALSE);",
          "3551:             offset = dissect_rsl_ie_sup_codec_types(tvb, pinfo, tree, offset, FALSE);",
          "3554:             offset = dissect_rsl_ie_tfo_transp_cont(tvb, pinfo, tree, offset, FALSE);",
          "3555:         break;",
          "",
          "[Removed Lines]",
          "3538:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3541:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3544:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3547:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3550:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3553:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3538:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3541:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3544:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3547:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3550:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3553:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "3582:         offset = dissect_rsl_ie_timing_adv(tvb, pinfo, tree, offset, TRUE);",
          "3585:             offset = dissect_rsl_ie_phy_ctx(tvb, pinfo, tree, offset, FALSE);",
          "3586:         break;",
          "",
          "[Removed Lines]",
          "3584:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3584:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "3595:         offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3598:             offset = dissect_rsl_ie_ms_pow(tvb, pinfo, tree, offset, FALSE);",
          "3600:         break;",
          "",
          "[Removed Lines]",
          "3597:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3597:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "3631:         offset = dissect_rsl_ie_sys_info_type(tvb, pinfo, tree, offset, TRUE, &sys_info_type);",
          "3634:             offset = dissect_rsl_ie_L3_inf(tvb, pinfo, tree, offset, FALSE,",
          "3635:                                            (sys_info_type == 0x48) ? L3_INF_SACCH : L3_INF_OTHER);",
          "3638:             offset = dissect_rsl_ie_starting_time(tvb, pinfo, tree, offset, FALSE);",
          "3639:         break;",
          "",
          "[Removed Lines]",
          "3633:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3637:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3633:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3637:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "3643:         offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3646:                 offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3647:         break;",
          "",
          "[Removed Lines]",
          "3645:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3645:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "3651:         offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3654:                 offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3655:         break;",
          "",
          "[Removed Lines]",
          "3653:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3653:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "3661:         offset = dissect_rsl_ie_codec_conf(tvb, pinfo, tree, offset, TRUE);",
          "3664:             offset = dissect_rsl_ie_sup_codec_types(tvb, pinfo, tree, offset, FALSE);",
          "3667:             offset = dissect_rsl_ie_tfo_transp_cont(tvb, pinfo, tree, offset, FALSE);",
          "3668:         break;",
          "",
          "[Removed Lines]",
          "3663:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3666:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3663:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3666:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "3683:         offset = dissect_rsl_ie_codec_conf(tvb, pinfo, tree, offset, TRUE);",
          "3686:             offset = dissect_rsl_ie_tfo_transp_cont(tvb, pinfo, tree, offset, FALSE);",
          "3687:         break;",
          "",
          "[Removed Lines]",
          "3685:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3685:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "3691:         offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3694:             offset = dissect_rsl_ie_multirate_conf(tvb, pinfo, tree, offset, FALSE);",
          "3695:         break;",
          "",
          "[Removed Lines]",
          "3693:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3693:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "3699:         offset = dissect_rsl_ie_ch_no(tvb, pinfo, tree, offset, TRUE);",
          "3702:             offset = dissect_rsl_ie_multirate_conf(tvb, pinfo, tree, offset, FALSE);",
          "3703:         break;",
          "",
          "[Removed Lines]",
          "3701:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3701:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "3730:         offset = dissect_rsl_ie_multirate_cntrl(tvb, pinfo, tree, offset, TRUE);",
          "3733:             offset = dissect_rsl_ie_sup_codec_types(tvb, pinfo, tree, offset, FALSE);",
          "3736:             offset = dissect_rsl_ie_tfo_transp_cont(tvb, pinfo, tree, offset, FALSE);",
          "3737:         break;",
          "",
          "[Removed Lines]",
          "3732:         if (tvb_length_remaining(tvb,offset) > 0)",
          "3735:         if (tvb_length_remaining(tvb,offset) > 0)",
          "",
          "[Added Lines]",
          "3732:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "3735:         if (tvb_reported_length_remaining(tvb, offset) > 0)",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "3808:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RSL\");",
          "3809:     col_clear(pinfo->cinfo, COL_INFO);",
          "3815:     top_tree = tree;",
          "3835:     return offset;",
          "3836: }",
          "",
          "[Removed Lines]",
          "3811:     msg_type = tvb_get_guint8(tvb,offset+1) & 0x7f;",
          "3813:     col_append_fstr(pinfo->cinfo, COL_INFO, \"%s \",val_to_str_ext(msg_type, &rsl_msg_type_vals_ext,\"unknown %u\"));",
          "3817:         ti = proto_tree_add_item(tree, proto_rsl, tvb, 0, -1, ENC_NA);",
          "3820:         if (!global_rsl_use_nano_bts) {",
          "3821:             guint8 msg_disc = tvb_get_guint8(tvb, offset) >> 1;",
          "3823:             if (msg_disc == RSL_MSGDISC_IPACCESS)",
          "3824:                 return 0;",
          "3825:         }",
          "3826:         rsl_tree = proto_item_add_subtree(ti, ett_rsl);",
          "3829:         proto_tree_add_item(rsl_tree, hf_rsl_msg_dsc, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "3830:         proto_tree_add_item(rsl_tree, hf_rsl_T_bit, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "3832:         offset = dissct_rsl_msg(tvb, pinfo, rsl_tree, offset);",
          "3834:     }",
          "",
          "[Added Lines]",
          "3811:     msg_type = tvb_get_guint8(tvb, offset+1) & 0x7f;",
          "3813:     col_append_fstr(pinfo->cinfo, COL_INFO, \"%s \", val_to_str_ext(msg_type, &rsl_msg_type_vals_ext, \"unknown %u\"));",
          "3816:     ti = proto_tree_add_item(tree, proto_rsl, tvb, 0, -1, ENC_NA);",
          "3819:     if (!global_rsl_use_nano_bts) {",
          "3820:         guint8 msg_disc = tvb_get_guint8(tvb, offset) >> 1;",
          "3822:         if (msg_disc == RSL_MSGDISC_IPACCESS)",
          "3823:             return 0;",
          "3824:     }",
          "3825:     rsl_tree = proto_item_add_subtree(ti, ett_rsl);",
          "3828:     proto_tree_add_item(rsl_tree, hf_rsl_msg_dsc, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "3829:     proto_tree_add_item(rsl_tree, hf_rsl_T_bit, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "3831:     offset = dissct_rsl_msg(tvb, pinfo, rsl_tree, offset);",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "4411:     proto_rsl = proto_register_protocol(\"Radio Signalling Link (RSL)\", \"RSL\", \"gsm_abis_rsl\");",
          "",
          "[Removed Lines]",
          "4344:     RSL_ATT_TLVDEF(RSL_IE_CH_NO,            TLV_TYPE_TV,            0);",
          "4345:     RSL_ATT_TLVDEF(RSL_IE_LINK_ID,          TLV_TYPE_TV,            0);",
          "4346:     RSL_ATT_TLVDEF(RSL_IE_ACT_TYPE,         TLV_TYPE_TV,            0);",
          "4347:     RSL_ATT_TLVDEF(RSL_IE_BS_POW,           TLV_TYPE_TV,            0);",
          "4348:     RSL_ATT_TLVDEF(RSL_IE_CH_ID,            TLV_TYPE_TLV,           0);",
          "4349:     RSL_ATT_TLVDEF(RSL_IE_CH_MODE,          TLV_TYPE_TLV,           0);",
          "4350:     RSL_ATT_TLVDEF(RSL_IE_ENC_INF,          TLV_TYPE_TLV,           0);",
          "4351:     RSL_ATT_TLVDEF(RSL_IE_FRAME_NO,         TLV_TYPE_FIXED,         2);",
          "4352:     RSL_ATT_TLVDEF(RSL_IE_HO_REF,           TLV_TYPE_TV,            0);",
          "4353:     RSL_ATT_TLVDEF(RSL_IE_L1_INF,           TLV_TYPE_FIXED,         2);",
          "4354:     RSL_ATT_TLVDEF(RSL_IE_L3_INF,           TLV_TYPE_TL16V,         0);",
          "4355:     RSL_ATT_TLVDEF(RSL_IE_MS_ID,            TLV_TYPE_TLV,           0);",
          "4356:     RSL_ATT_TLVDEF(RSL_IE_MS_POW,           TLV_TYPE_TV,            0);",
          "4357:     RSL_ATT_TLVDEF(RSL_IE_PAGING_GRP,       TLV_TYPE_TV,            0);",
          "4358:     RSL_ATT_TLVDEF(RSL_IE_PAGING_LOAD,      TLV_TYPE_FIXED,         2);",
          "4359:     RSL_ATT_TLVDEF(RSL_IE_PHY_CTX,          TLV_TYPE_TLV,           0);",
          "4360:     RSL_ATT_TLVDEF(RSL_IE_ACCESS_DELAY,     TLV_TYPE_TV,            0);",
          "4361:     RSL_ATT_TLVDEF(RSL_IE_RACH_LOAD,        TLV_TYPE_TLV,           0);",
          "4362:     RSL_ATT_TLVDEF(RSL_IE_REQ_REF,          TLV_TYPE_FIXED,         3);",
          "4363:     RSL_ATT_TLVDEF(RSL_IE_REL_MODE,         TLV_TYPE_TV,            0);",
          "4364:     RSL_ATT_TLVDEF(RSL_IE_RESOURCE_INF,     TLV_TYPE_TLV,           0);",
          "4365:     RSL_ATT_TLVDEF(RSL_IE_RLM_CAUSE,        TLV_TYPE_TLV,           0);",
          "4366:     RSL_ATT_TLVDEF(RSL_IE_STARTING_TIME,    TLV_TYPE_FIXED,         2);",
          "4367:     RSL_ATT_TLVDEF(RSL_IE_TIMING_ADV,       TLV_TYPE_TV,            0);",
          "4368:     RSL_ATT_TLVDEF(RSL_IE_UPLINK_MEAS,      TLV_TYPE_TLV,           0);",
          "4369:     RSL_ATT_TLVDEF(RSL_IE_CAUSE,            TLV_TYPE_TLV,           0);",
          "4370:     RSL_ATT_TLVDEF(RSL_IE_MEAS_RES_NO,      TLV_TYPE_TV,            0);",
          "4371:     RSL_ATT_TLVDEF(RSL_IE_MESSAGE_ID,       TLV_TYPE_TV,            0);",
          "4372:     RSL_ATT_TLVDEF(RSL_IE_SYS_INFO_TYPE,    TLV_TYPE_TV,            0);",
          "4373:     RSL_ATT_TLVDEF(RSL_IE_MS_POWER_PARAM,   TLV_TYPE_TLV,           0);",
          "4374:     RSL_ATT_TLVDEF(RSL_IE_BS_POWER_PARAM,   TLV_TYPE_TLV,           0);",
          "4375:     RSL_ATT_TLVDEF(RSL_IE_PREPROC_PARAM,    TLV_TYPE_TLV,           0);",
          "4376:     RSL_ATT_TLVDEF(RSL_IE_PREPROC_MEAS,     TLV_TYPE_TLV,           0);",
          "4377:     RSL_ATT_TLVDEF(RSL_IE_ERR_MSG,          TLV_TYPE_TLV,           0);",
          "4378:     RSL_ATT_TLVDEF(RSL_IE_FULL_BCCH_INF,    TLV_TYPE_TLV,           0);",
          "4379:     RSL_ATT_TLVDEF(RSL_IE_CH_NEEDED,        TLV_TYPE_TV,            0);",
          "4380:     RSL_ATT_TLVDEF(RSL_IE_CB_CMD_TYPE,      TLV_TYPE_TV,            0);",
          "4381:     RSL_ATT_TLVDEF(RSL_IE_SMSCB_MESS,       TLV_TYPE_TLV,           0);",
          "4382:     RSL_ATT_TLVDEF(RSL_IE_FULL_IMM_ASS_INF, TLV_TYPE_TLV,           0);",
          "4383:     RSL_ATT_TLVDEF(RSL_IE_CBCH_LOAD_INF,    TLV_TYPE_TV,            0);",
          "4384:     RSL_ATT_TLVDEF(RSL_IE_SMSCB_CH_IND,     TLV_TYPE_TV,            0);",
          "4385:     RSL_ATT_TLVDEF(RSL_IE_GRP_CALL_REF,     TLV_TYPE_TLV,           0);",
          "4386:     RSL_ATT_TLVDEF(RSL_IE_CH_DESC,          TLV_TYPE_TLV,           0);",
          "4387:     RSL_ATT_TLVDEF(RSL_IE_NCH_DRX_INF,      TLV_TYPE_TLV,           0);",
          "4388:     RSL_ATT_TLVDEF(RSL_IE_CMD_IND,          TLV_TYPE_TLV,           0);",
          "4389:     RSL_ATT_TLVDEF(RSL_IE_EMLPP_PRIO,       TLV_TYPE_TV,            0);",
          "4390:     RSL_ATT_TLVDEF(RSL_IE_UIC,              TLV_TYPE_TLV,           0);",
          "4391:     RSL_ATT_TLVDEF(RSL_IE_MAIN_CH_REF,      TLV_TYPE_TV,            0);",
          "4392:     RSL_ATT_TLVDEF(RSL_IE_MULTIRATE_CONF,   TLV_TYPE_TLV,           0);",
          "4393:     RSL_ATT_TLVDEF(RSL_IE_MULTIRATE_CNTRL,  TLV_TYPE_TV,            0);",
          "4394:     RSL_ATT_TLVDEF(RSL_IE_SUP_CODEC_TYPES,  TLV_TYPE_TLV,           0);",
          "4395:     RSL_ATT_TLVDEF(RSL_IE_CODEC_CONF,       TLV_TYPE_TLV,           0);",
          "4396:     RSL_ATT_TLVDEF(RSL_IE_RTD,              TLV_TYPE_TV,            0);",
          "4397:     RSL_ATT_TLVDEF(RSL_IE_TFO_STATUS,       TLV_TYPE_TV,            0);",
          "4398:     RSL_ATT_TLVDEF(RSL_IE_LLP_APDU,         TLV_TYPE_TLV,           0);",
          "4399:     RSL_ATT_TLVDEF(RSL_IE_IPAC_REMOTE_IP,   TLV_TYPE_FIXED,         4);",
          "4400:     RSL_ATT_TLVDEF(RSL_IE_IPAC_REMOTE_PORT, TLV_TYPE_FIXED,         2);",
          "4401:     RSL_ATT_TLVDEF(RSL_IE_IPAC_LOCAL_IP,    TLV_TYPE_FIXED,         4);",
          "4402:     RSL_ATT_TLVDEF(RSL_IE_IPAC_CONN_STAT,   TLV_TYPE_TLV,           0);",
          "4403:     RSL_ATT_TLVDEF(RSL_IE_IPAC_LOCAL_PORT,  TLV_TYPE_FIXED,         2);",
          "4404:     RSL_ATT_TLVDEF(RSL_IE_IPAC_SPEECH_MODE, TLV_TYPE_TV,            0);",
          "4405:     RSL_ATT_TLVDEF(RSL_IE_IPAC_CONN_ID,     TLV_TYPE_FIXED,         2);",
          "4406:     RSL_ATT_TLVDEF(RSL_IE_IPAC_RTP_PAYLOAD2,TLV_TYPE_TV,            0);",
          "4407:     RSL_ATT_TLVDEF(RSL_IE_IPAC_RTP_PAYLOAD, TLV_TYPE_TV,            0);",
          "4408:     RSL_ATT_TLVDEF(RSL_IE_IPAC_RTP_CSD_FMT, TLV_TYPE_TV,            0);",
          "",
          "[Added Lines]",
          "4342:     RSL_ATT_TLVDEF(RSL_IE_CH_NO,             TLV_TYPE_TV,            0);",
          "4343:     RSL_ATT_TLVDEF(RSL_IE_LINK_ID,           TLV_TYPE_TV,            0);",
          "4344:     RSL_ATT_TLVDEF(RSL_IE_ACT_TYPE,          TLV_TYPE_TV,            0);",
          "4345:     RSL_ATT_TLVDEF(RSL_IE_BS_POW,            TLV_TYPE_TV,            0);",
          "4346:     RSL_ATT_TLVDEF(RSL_IE_CH_ID,             TLV_TYPE_TLV,           0);",
          "4347:     RSL_ATT_TLVDEF(RSL_IE_CH_MODE,           TLV_TYPE_TLV,           0);",
          "4348:     RSL_ATT_TLVDEF(RSL_IE_ENC_INF,           TLV_TYPE_TLV,           0);",
          "4349:     RSL_ATT_TLVDEF(RSL_IE_FRAME_NO,          TLV_TYPE_FIXED,         2);",
          "4350:     RSL_ATT_TLVDEF(RSL_IE_HO_REF,            TLV_TYPE_TV,            0);",
          "4351:     RSL_ATT_TLVDEF(RSL_IE_L1_INF,            TLV_TYPE_FIXED,         2);",
          "4352:     RSL_ATT_TLVDEF(RSL_IE_L3_INF,            TLV_TYPE_TL16V,         0);",
          "4353:     RSL_ATT_TLVDEF(RSL_IE_MS_ID,             TLV_TYPE_TLV,           0);",
          "4354:     RSL_ATT_TLVDEF(RSL_IE_MS_POW,            TLV_TYPE_TV,            0);",
          "4355:     RSL_ATT_TLVDEF(RSL_IE_PAGING_GRP,        TLV_TYPE_TV,            0);",
          "4356:     RSL_ATT_TLVDEF(RSL_IE_PAGING_LOAD,       TLV_TYPE_FIXED,         2);",
          "4357:     RSL_ATT_TLVDEF(RSL_IE_PHY_CTX,           TLV_TYPE_TLV,           0);",
          "4358:     RSL_ATT_TLVDEF(RSL_IE_ACCESS_DELAY,      TLV_TYPE_TV,            0);",
          "4359:     RSL_ATT_TLVDEF(RSL_IE_RACH_LOAD,         TLV_TYPE_TLV,           0);",
          "4360:     RSL_ATT_TLVDEF(RSL_IE_REQ_REF,           TLV_TYPE_FIXED,         3);",
          "4361:     RSL_ATT_TLVDEF(RSL_IE_REL_MODE,          TLV_TYPE_TV,            0);",
          "4362:     RSL_ATT_TLVDEF(RSL_IE_RESOURCE_INF,      TLV_TYPE_TLV,           0);",
          "4363:     RSL_ATT_TLVDEF(RSL_IE_RLM_CAUSE,         TLV_TYPE_TLV,           0);",
          "4364:     RSL_ATT_TLVDEF(RSL_IE_STARTING_TIME,     TLV_TYPE_FIXED,         2);",
          "4365:     RSL_ATT_TLVDEF(RSL_IE_TIMING_ADV,        TLV_TYPE_TV,            0);",
          "4366:     RSL_ATT_TLVDEF(RSL_IE_UPLINK_MEAS,       TLV_TYPE_TLV,           0);",
          "4367:     RSL_ATT_TLVDEF(RSL_IE_CAUSE,             TLV_TYPE_TLV,           0);",
          "4368:     RSL_ATT_TLVDEF(RSL_IE_MEAS_RES_NO,       TLV_TYPE_TV,            0);",
          "4369:     RSL_ATT_TLVDEF(RSL_IE_MESSAGE_ID,        TLV_TYPE_TV,            0);",
          "4370:     RSL_ATT_TLVDEF(RSL_IE_SYS_INFO_TYPE,     TLV_TYPE_TV,            0);",
          "4371:     RSL_ATT_TLVDEF(RSL_IE_MS_POWER_PARAM,    TLV_TYPE_TLV,           0);",
          "4372:     RSL_ATT_TLVDEF(RSL_IE_BS_POWER_PARAM,    TLV_TYPE_TLV,           0);",
          "4373:     RSL_ATT_TLVDEF(RSL_IE_PREPROC_PARAM,     TLV_TYPE_TLV,           0);",
          "4374:     RSL_ATT_TLVDEF(RSL_IE_PREPROC_MEAS,      TLV_TYPE_TLV,           0);",
          "4375:     RSL_ATT_TLVDEF(RSL_IE_ERR_MSG,           TLV_TYPE_TLV,           0);",
          "4376:     RSL_ATT_TLVDEF(RSL_IE_FULL_BCCH_INF,     TLV_TYPE_TLV,           0);",
          "4377:     RSL_ATT_TLVDEF(RSL_IE_CH_NEEDED,         TLV_TYPE_TV,            0);",
          "4378:     RSL_ATT_TLVDEF(RSL_IE_CB_CMD_TYPE,       TLV_TYPE_TV,            0);",
          "4379:     RSL_ATT_TLVDEF(RSL_IE_SMSCB_MESS,        TLV_TYPE_TLV,           0);",
          "4380:     RSL_ATT_TLVDEF(RSL_IE_FULL_IMM_ASS_INF,  TLV_TYPE_TLV,           0);",
          "4381:     RSL_ATT_TLVDEF(RSL_IE_CBCH_LOAD_INF,     TLV_TYPE_TV,            0);",
          "4382:     RSL_ATT_TLVDEF(RSL_IE_SMSCB_CH_IND,      TLV_TYPE_TV,            0);",
          "4383:     RSL_ATT_TLVDEF(RSL_IE_GRP_CALL_REF,      TLV_TYPE_TLV,           0);",
          "4384:     RSL_ATT_TLVDEF(RSL_IE_CH_DESC,           TLV_TYPE_TLV,           0);",
          "4385:     RSL_ATT_TLVDEF(RSL_IE_NCH_DRX_INF,       TLV_TYPE_TLV,           0);",
          "4386:     RSL_ATT_TLVDEF(RSL_IE_CMD_IND,           TLV_TYPE_TLV,           0);",
          "4387:     RSL_ATT_TLVDEF(RSL_IE_EMLPP_PRIO,        TLV_TYPE_TV,            0);",
          "4388:     RSL_ATT_TLVDEF(RSL_IE_UIC,               TLV_TYPE_TLV,           0);",
          "4389:     RSL_ATT_TLVDEF(RSL_IE_MAIN_CH_REF,       TLV_TYPE_TV,            0);",
          "4390:     RSL_ATT_TLVDEF(RSL_IE_MULTIRATE_CONF,    TLV_TYPE_TLV,           0);",
          "4391:     RSL_ATT_TLVDEF(RSL_IE_MULTIRATE_CNTRL,   TLV_TYPE_TV,            0);",
          "4392:     RSL_ATT_TLVDEF(RSL_IE_SUP_CODEC_TYPES,   TLV_TYPE_TLV,           0);",
          "4393:     RSL_ATT_TLVDEF(RSL_IE_CODEC_CONF,        TLV_TYPE_TLV,           0);",
          "4394:     RSL_ATT_TLVDEF(RSL_IE_RTD,               TLV_TYPE_TV,            0);",
          "4395:     RSL_ATT_TLVDEF(RSL_IE_TFO_STATUS,        TLV_TYPE_TV,            0);",
          "4396:     RSL_ATT_TLVDEF(RSL_IE_LLP_APDU,          TLV_TYPE_TLV,           0);",
          "4397:     RSL_ATT_TLVDEF(RSL_IE_IPAC_REMOTE_IP,    TLV_TYPE_FIXED,         4);",
          "4398:     RSL_ATT_TLVDEF(RSL_IE_IPAC_REMOTE_PORT,  TLV_TYPE_FIXED,         2);",
          "4399:     RSL_ATT_TLVDEF(RSL_IE_IPAC_LOCAL_IP,     TLV_TYPE_FIXED,         4);",
          "4400:     RSL_ATT_TLVDEF(RSL_IE_IPAC_CONN_STAT,    TLV_TYPE_TLV,           0);",
          "4401:     RSL_ATT_TLVDEF(RSL_IE_IPAC_LOCAL_PORT,   TLV_TYPE_FIXED,         2);",
          "4402:     RSL_ATT_TLVDEF(RSL_IE_IPAC_SPEECH_MODE,  TLV_TYPE_TV,            0);",
          "4403:     RSL_ATT_TLVDEF(RSL_IE_IPAC_CONN_ID,      TLV_TYPE_FIXED,         2);",
          "4404:     RSL_ATT_TLVDEF(RSL_IE_IPAC_RTP_PAYLOAD2, TLV_TYPE_TV,            0);",
          "4405:     RSL_ATT_TLVDEF(RSL_IE_IPAC_RTP_PAYLOAD,  TLV_TYPE_TV,            0);",
          "4406:     RSL_ATT_TLVDEF(RSL_IE_IPAC_RTP_CSD_FMT,  TLV_TYPE_TV,            0);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtmpt.c||epan/dissectors/packet-rtmpt.c": [
          "File: epan/dissectors/packet-rtmpt.c -> epan/dissectors/packet-rtmpt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "561: rtmpt_get_amf_length(tvbuff_t *tvb, gint offset)",
          "562: {",
          "563:         guint8  iObjType;",
          "565:         guint32 depth   = 0;",
          "566:         gint    itemlen = 0;",
          "567:         gint    rv      = 0;",
          "",
          "[Removed Lines]",
          "564:         gint    remain  = tvb_length_remaining(tvb, offset);",
          "",
          "[Added Lines]",
          "564:         gint    remain  = tvb_reported_length_remaining(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "640: static gchar *",
          "641: rtmpt_get_amf_param(tvbuff_t *tvb, gint offset, gint param, const gchar *prop)",
          "642: {",
          "644:         guint32 itemlen;",
          "645:         guint32 iStringLength;",
          "",
          "[Removed Lines]",
          "643:         guint32 remain = tvb_length_remaining(tvb, offset);",
          "",
          "[Added Lines]",
          "643:         guint32 remain = tvb_reported_length_remaining(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "694: static guint32",
          "695: rtmpt_get_amf_txid(tvbuff_t *tvb, gint offset)",
          "696: {",
          "699:         if (remain > 0) {",
          "700:                 guint32 itemlen = rtmpt_get_amf_length(tvb, offset);",
          "",
          "[Removed Lines]",
          "697:         guint32 remain = tvb_length_remaining(tvb, offset);",
          "",
          "[Added Lines]",
          "697:         guint32 remain = tvb_reported_length_remaining(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "740:         } else if (tp->cmd == RTMPT_TYPE_UCM) {",
          "741:                 guint16 iUCM = -1;",
          "743:                 const gchar *sParam = \"\";",
          "745:                 if (tp->len < 2 || remain < 2)",
          "",
          "[Removed Lines]",
          "742:                 const gchar *sFunc = NULL;",
          "",
          "[Added Lines]",
          "742:                 const gchar *sFunc;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1115:                 break;",
          "1116:         }",
          "1117:         proto_item_set_end(ti, tvb, iValueOffset);",
          "",
          "[Removed Lines]",
          "1114:                 iValueOffset = tvb_length(tvb);",
          "",
          "[Added Lines]",
          "1114:                 iValueOffset = tvb_reported_length(tvb);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1550:                 break;",
          "1551:         }",
          "1552:         proto_item_set_end(ti, tvb, iValueOffset);",
          "",
          "[Removed Lines]",
          "1549:                 iValueOffset = tvb_length(tvb);",
          "",
          "[Added Lines]",
          "1549:                 iValueOffset = tvb_reported_length(tvb);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1627:         proto_tree *data_tree;",
          "1630:                 guint8 iTagType;",
          "1631:                 guint  iDataSize;",
          "",
          "[Removed Lines]",
          "1629:         while (tvb_length_remaining(tvb, offset) > 0) {",
          "",
          "[Added Lines]",
          "1629:         while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1667: static void",
          "1668: dissect_rtmpt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp)",
          "1669: {",
          "1673:         gint        offset         = 0;",
          "1675:         gchar      *sDesc          = NULL;",
          "",
          "[Removed Lines]",
          "1670:         proto_tree *rtmpt_tree     = NULL;",
          "1671:         proto_tree *rtmptroot_tree = NULL;",
          "1672:         proto_item *ti             = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1683:         RTMPT_DEBUG(\"Dissect: frame=%u visited=%d len=%d tree=%p\\n\",",
          "1684:                     pinfo->fd->num, pinfo->fd->flags.visited,",
          "1688:         col_clear(pinfo->cinfo, COL_INFO);",
          "1692:         if (tp->id <= RTMPT_ID_MAX) {",
          "1693:                 if (tp->fmt < 3",
          "1695:                     && tvb_get_ntoh24(tvb, offset+tp->bhlen) == 0xffffff) {",
          "1696:                         haveETS = TRUE;",
          "1697:                 }",
          "1699:                 iBodyOffset = offset + tp->bhlen + tp->mhlen;",
          "1702:                 if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE && tp->len >= 4 && iBodyRemain >= 4) {",
          "1703:                         guint32 newchunksize = tvb_get_ntohl(tvb, iBodyOffset);",
          "",
          "[Removed Lines]",
          "1685:                     tvb_length_remaining(tvb, offset), tree);",
          "1690:         if (tvb_length_remaining(tvb, offset) < 1) return;",
          "1694:                     && tvb_length_remaining(tvb, offset) >= tp->bhlen+3",
          "1700:                 iBodyRemain = tvb_length_remaining(tvb, iBodyOffset);",
          "",
          "[Added Lines]",
          "1682:                     tvb_reported_length_remaining(tvb, offset), tree);",
          "1687:         if (tvb_reported_length_remaining(tvb, offset) < 1) return;",
          "1691:                     && tvb_reported_length_remaining(tvb, offset) >= tp->bhlen+3",
          "1697:                 iBodyRemain = tvb_reported_length_remaining(tvb, iBodyOffset);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1743:         if (tree)",
          "1744:         {",
          "1745:                 ti = proto_tree_add_item(tree, proto_rtmpt, tvb, offset, -1, ENC_NA);",
          "1747:                 if (tp->id > RTMPT_ID_MAX) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1742:                 proto_tree *rtmpt_tree     = NULL;",
          "1743:                 proto_tree *rtmptroot_tree = NULL;",
          "1744:                 proto_item *ti;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1875:         rtmpt_packet_t *tp;",
          "1876:         tvbuff_t       *pktbuf;",
          "1879:         if (!remain)",
          "1880:                 return;",
          "",
          "[Removed Lines]",
          "1878:         remain = tvb_length(tvb);",
          "",
          "[Added Lines]",
          "1878:         remain = tvb_reported_length(tvb);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2304:                 conv->key_ptr->port2 == pinfo->destport) ? 0 : 1;",
          "2306:         dissect_rtmpt_common(tvb, pinfo, tree, rconv, cdir, tcpinfo->seq, tcpinfo->lastackseq);",
          "2308: }",
          "2310: static void",
          "",
          "[Removed Lines]",
          "2307:         return tvb_length(tvb);",
          "",
          "[Added Lines]",
          "2307:         return tvb_reported_length(tvb);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2319:         gint            remain;",
          "2321:         offset = 0;",
          "",
          "[Removed Lines]",
          "2322:         remain = tvb_length_remaining(tvb, 0);",
          "",
          "[Added Lines]",
          "2322:         remain = tvb_reported_length_remaining(tvb, 0);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2429: dissect_rtmpt_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "2430: {",
          "2431:         conversation_t *conversation;",
          "2433:         {",
          "2435:                    from the first server response packet and not from the client request packets before.",
          "",
          "[Removed Lines]",
          "2432:         if (tvb_length(tvb) >= 12)",
          "",
          "[Added Lines]",
          "2432:         if (tvb_reported_length(tvb) >= 12)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4960171c3a75078c5708aacbf9d1eb75e0e825bf",
      "candidate_info": {
        "commit_hash": "4960171c3a75078c5708aacbf9d1eb75e0e825bf",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/4960171c3a75078c5708aacbf9d1eb75e0e825bf",
        "files": [
          "ui/gtk/voip_calls.c",
          "ui/gtk/voip_calls.h"
        ],
        "message": "VoIP calls: Fixup whitespace.\n\nSet modelines and reindent to match the files in the top-level ui\ndirectory.\n\nChange-Id: I7ea221e76a4b0ad3b6bcf7a3c8b4645c16aecbba\nReviewed-on: https://code.wireshark.org/review/5325\nReviewed-by: Gerald Combs <gerald@wireshark.org>",
        "before_after_code_files": [
          "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c",
          "ui/gtk/voip_calls.h||ui/gtk/voip_calls.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c"
          ],
          "candidate": [
            "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c"
          ]
        }
      },
      "candidate_diff": {
        "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c": [
          "File: ui/gtk/voip_calls.c -> ui/gtk/voip_calls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "77: #define DUMP_PTR2(p) printf(\"==> %p\\n\",(void *)p)",
          "79: const char *voip_call_state_name[8]={",
          "88: };",
          "91: const char *voip_protocol_name[]={",
          "107: };",
          "",
          "[Removed Lines]",
          "80:  \"\",",
          "81:  \"CALL SETUP\",",
          "82:  \"RINGING\",",
          "83:  \"IN CALL\",",
          "84:  \"CANCELLED\",",
          "85:  \"COMPLETED\",",
          "86:  \"REJECTED\",",
          "87:  \"UNKNOWN\"",
          "92:  \"SIP\",",
          "93:  \"ISUP\",",
          "94:  \"H.323\",",
          "95:  \"MGCP\",",
          "96:  \"AC_ISDN\",",
          "97:  \"AC_CAS\",",
          "98:  \"T.38\",",
          "99:  \"H.248\",",
          "100:  \"SCCP\",",
          "101:  \"BSSMAP\",",
          "102:  \"RANAP\",",
          "103:  \"UNISTIM\",",
          "104:  \"SKINNY\",",
          "105:  \"IAX2\",",
          "106:  \"VoIP\"",
          "",
          "[Added Lines]",
          "80:     \"\",",
          "81:     \"CALL SETUP\",",
          "82:     \"RINGING\",",
          "83:     \"IN CALL\",",
          "84:     \"CANCELLED\",",
          "85:     \"COMPLETED\",",
          "86:     \"REJECTED\",",
          "87:     \"UNKNOWN\"",
          "92:     \"SIP\",",
          "93:     \"ISUP\",",
          "94:     \"H.323\",",
          "95:     \"MGCP\",",
          "96:     \"AC_ISDN\",",
          "97:     \"AC_CAS\",",
          "98:     \"T.38\",",
          "99:     \"H.248\",",
          "100:     \"SCCP\",",
          "101:     \"BSSMAP\",",
          "102:     \"RANAP\",",
          "103:     \"UNISTIM\",",
          "104:     \"SKINNY\",",
          "105:     \"IAX2\",",
          "106:     \"VoIP\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114: enum {",
          "136: };",
          "138: static inline void *",
          "139: tap_base_to_id(voip_calls_tapinfo_t* tap_base, int offset) {",
          "141: }",
          "143: static inline voip_calls_tapinfo_t *",
          "144: tap_id_to_base(void* tap_id, int offset) {",
          "146: }",
          "148: typedef struct {",
          "151: } graph_str;",
          "153: #define H245_MAX 6",
          "155: typedef struct {",
          "159: } h245_labels_t;",
          "161: static h245_labels_t h245_labels;",
          "164: typedef struct _voip_rtp_stream_info {",
          "183: } voip_rtp_stream_info_t;",
          "",
          "[Removed Lines]",
          "115:        tap_id_offset_actrace_,",
          "116:        tap_id_offset_h225_,",
          "117:        tap_id_offset_h245dg_,",
          "118:        tap_id_offset_h248_,",
          "119:        tap_id_offset_iax2_,",
          "120:        tap_id_offset_isup_,",
          "121:        tap_id_offset_m3ua_,",
          "122:        tap_id_offset_megaco_,",
          "123:        tap_id_offset_mgcp_,",
          "124:        tap_id_offset_mtp3_,",
          "125:        tap_id_offset_q931_,",
          "126:        tap_id_offset_rtp_,",
          "127:        tap_id_offset_rtp_event_,",
          "128:        tap_id_offset_sccp_,",
          "129:        tap_id_offset_sdp_,",
          "130:        tap_id_offset_sip_,",
          "131:        tap_id_offset_skinny_,",
          "132:        tap_id_offset_sua_,",
          "133:        tap_id_offset_t38_,",
          "134:        tap_id_offset_unistim_,",
          "135:        tap_id_offset_voip_",
          "140:  return GSIZE_TO_POINTER(GPOINTER_TO_SIZE(tap_base) + offset);",
          "145:  return (voip_calls_tapinfo_t *) GSIZE_TO_POINTER(GPOINTER_TO_SIZE(tap_id) - offset);",
          "149:  gchar *frame_label;",
          "150:  gchar *comment;",
          "156:  guint32 frame_num;",
          "157:  gint8 labels_count;",
          "158:  graph_str labels[H245_MAX];",
          "165:  address src_addr;",
          "166:  guint16 src_port;",
          "167:  address dest_addr;",
          "168:  guint16 dest_port;",
          "169:  guint32 ssrc;",
          "170:  guint32  pt;",
          "171:  gchar *pt_str;",
          "172:  gboolean is_srtp;",
          "173:  guint32 npackets;",
          "174:  gboolean end_stream;",
          "178:  frame_data *start_fd;",
          "179:  nstime_t start_rel_ts;",
          "180:  frame_data *stop_fd;",
          "181:  nstime_t stop_rel_ts;",
          "182:  gint32 rtp_event;",
          "",
          "[Added Lines]",
          "115:     tap_id_offset_actrace_,",
          "116:     tap_id_offset_h225_,",
          "117:     tap_id_offset_h245dg_,",
          "118:     tap_id_offset_h248_,",
          "119:     tap_id_offset_iax2_,",
          "120:     tap_id_offset_isup_,",
          "121:     tap_id_offset_m3ua_,",
          "122:     tap_id_offset_megaco_,",
          "123:     tap_id_offset_mgcp_,",
          "124:     tap_id_offset_mtp3_,",
          "125:     tap_id_offset_q931_,",
          "126:     tap_id_offset_rtp_,",
          "127:     tap_id_offset_rtp_event_,",
          "128:     tap_id_offset_sccp_,",
          "129:     tap_id_offset_sdp_,",
          "130:     tap_id_offset_sip_,",
          "131:     tap_id_offset_skinny_,",
          "132:     tap_id_offset_sua_,",
          "133:     tap_id_offset_t38_,",
          "134:     tap_id_offset_unistim_,",
          "135:     tap_id_offset_voip_",
          "140:     return GSIZE_TO_POINTER(GPOINTER_TO_SIZE(tap_base) + offset);",
          "145:     return (voip_calls_tapinfo_t *) GSIZE_TO_POINTER(GPOINTER_TO_SIZE(tap_id) - offset);",
          "149:     gchar *frame_label;",
          "150:     gchar *comment;",
          "156:     guint32 frame_num;",
          "157:     gint8 labels_count;",
          "158:     graph_str labels[H245_MAX];",
          "165:     address src_addr;",
          "166:     guint16 src_port;",
          "167:     address dest_addr;",
          "168:     guint16 dest_port;",
          "169:     guint32 ssrc;",
          "170:     guint32  pt;",
          "171:     gchar *pt_str;",
          "172:     gboolean is_srtp;",
          "173:     guint32 npackets;",
          "174:     gboolean end_stream;",
          "178:     frame_data *start_fd;",
          "179:     nstime_t start_rel_ts;",
          "180:     frame_data *stop_fd;",
          "181:     nstime_t stop_rel_ts;",
          "182:     gint32 rtp_event;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "193: void voip_calls_reset(voip_calls_tapinfo_t *tapinfo)",
          "194: {",
          "201: #ifdef HAVE_LIBPORTAUDIO",
          "204: #endif",
          "266: }",
          "269: void graph_analysis_data_init(void) {",
          "275: }",
          "",
          "[Removed Lines]",
          "195:  voip_calls_info_t *callsinfo;",
          "196:  voip_rtp_tapinfo_t *rtp_tapinfo = &the_tapinfo_rtp_struct;",
          "197:  voip_rtp_stream_info_t *strinfo;",
          "198:  seq_analysis_item_t *graph_item;",
          "199:  GList *list;",
          "203:  reset_rtp_player();",
          "207:  list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "208:  while (list)",
          "209:  {",
          "210:   callsinfo = (voip_calls_info_t *)list->data;",
          "211:   g_free(callsinfo->call_id);",
          "212:   g_free(callsinfo->from_identity);",
          "213:   g_free(callsinfo->to_identity);",
          "214:   g_free((void *)(callsinfo->initial_speaker.data));",
          "215:   g_free(callsinfo->protocol_name);",
          "216:   g_free(callsinfo->call_comment);",
          "218:   if (callsinfo->free_prot_info && callsinfo->prot_info)",
          "219:    callsinfo->free_prot_info(callsinfo->prot_info);",
          "221:   g_free(list->data);",
          "222:   list = g_list_next(list);",
          "223:  }",
          "224:  g_queue_clear(tapinfo->callsinfos);",
          "226:  if(NULL!=tapinfo->callsinfo_hashtable[SIP_HASH])",
          "227:   g_hash_table_remove_all (tapinfo->callsinfo_hashtable[SIP_HASH]);",
          "228:  tapinfo->ncalls = 0;",
          "229:  tapinfo->npackets = 0;",
          "230:  tapinfo->start_packets = 0;",
          "231:  tapinfo->completed_calls = 0;",
          "232:  tapinfo->rejected_calls = 0;",
          "235:  if(NULL!=tapinfo->graph_analysis->ht)",
          "236:   g_hash_table_remove_all(tapinfo->graph_analysis->ht);",
          "237:  list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "238:  while (list)",
          "239:  {",
          "240:   graph_item = (seq_analysis_item_t *)list->data;",
          "241:   g_free(graph_item->frame_label);",
          "242:   g_free(graph_item->comment);",
          "243:   g_free((void *)graph_item->src_addr.data);",
          "244:   g_free((void *)graph_item->dst_addr.data);",
          "245:   g_free(graph_item->time_str);",
          "246:   g_free(list->data);",
          "247:   list = g_list_next(list);",
          "248:  }",
          "249:  g_queue_clear(tapinfo->graph_analysis->items);",
          "250:  tapinfo->graph_analysis->nconv = 0;",
          "252:  ++(tapinfo->launch_count);",
          "255:  list = g_list_first(rtp_tapinfo->list);",
          "256:  while(list)",
          "257:  {",
          "258:   strinfo = (voip_rtp_stream_info_t *)list->data;",
          "259:   g_free(strinfo->pt_str);",
          "260:   list = g_list_next(list);",
          "261:  }",
          "262:  g_list_free(rtp_tapinfo->list);",
          "263:  rtp_tapinfo->list = NULL;",
          "265:  return;",
          "270:  voip_calls_tapinfo_t *voip_tapinfo = voip_calls_get_info();",
          "271:  voip_tapinfo->graph_analysis = (seq_analysis_info_t *)g_malloc(sizeof(seq_analysis_info_t));",
          "272:  voip_tapinfo->graph_analysis->nconv = 0;",
          "273:  voip_tapinfo->graph_analysis->items = g_queue_new();;",
          "274:  voip_tapinfo->graph_analysis->ht= g_hash_table_new(g_int_hash, g_int_equal);",
          "",
          "[Added Lines]",
          "195:     voip_calls_info_t *callsinfo;",
          "196:     voip_rtp_tapinfo_t *rtp_tapinfo = &the_tapinfo_rtp_struct;",
          "197:     voip_rtp_stream_info_t *strinfo;",
          "198:     seq_analysis_item_t *graph_item;",
          "199:     GList *list;",
          "203:     reset_rtp_player();",
          "207:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "208:     while (list)",
          "209:     {",
          "210:         callsinfo = (voip_calls_info_t *)list->data;",
          "211:         g_free(callsinfo->call_id);",
          "212:         g_free(callsinfo->from_identity);",
          "213:         g_free(callsinfo->to_identity);",
          "214:         g_free((void *)(callsinfo->initial_speaker.data));",
          "215:         g_free(callsinfo->protocol_name);",
          "216:         g_free(callsinfo->call_comment);",
          "218:         if (callsinfo->free_prot_info && callsinfo->prot_info)",
          "219:             callsinfo->free_prot_info(callsinfo->prot_info);",
          "221:         g_free(list->data);",
          "222:         list = g_list_next(list);",
          "223:     }",
          "224:     g_queue_clear(tapinfo->callsinfos);",
          "226:     if(NULL!=tapinfo->callsinfo_hashtable[SIP_HASH])",
          "227:         g_hash_table_remove_all (tapinfo->callsinfo_hashtable[SIP_HASH]);",
          "228:     tapinfo->ncalls = 0;",
          "229:     tapinfo->npackets = 0;",
          "230:     tapinfo->start_packets = 0;",
          "231:     tapinfo->completed_calls = 0;",
          "232:     tapinfo->rejected_calls = 0;",
          "235:     if(NULL!=tapinfo->graph_analysis->ht)",
          "236:         g_hash_table_remove_all(tapinfo->graph_analysis->ht);",
          "237:     list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "238:     while (list)",
          "239:     {",
          "240:         graph_item = (seq_analysis_item_t *)list->data;",
          "241:         g_free(graph_item->frame_label);",
          "242:         g_free(graph_item->comment);",
          "243:         g_free((void *)graph_item->src_addr.data);",
          "244:         g_free((void *)graph_item->dst_addr.data);",
          "245:         g_free(graph_item->time_str);",
          "246:         g_free(list->data);",
          "247:         list = g_list_next(list);",
          "248:     }",
          "249:     g_queue_clear(tapinfo->graph_analysis->items);",
          "250:     tapinfo->graph_analysis->nconv = 0;",
          "252:     ++(tapinfo->launch_count);",
          "255:     list = g_list_first(rtp_tapinfo->list);",
          "256:     while(list)",
          "257:     {",
          "258:         strinfo = (voip_rtp_stream_info_t *)list->data;",
          "259:         g_free(strinfo->pt_str);",
          "260:         list = g_list_next(list);",
          "261:     }",
          "262:     g_list_free(rtp_tapinfo->list);",
          "263:     rtp_tapinfo->list = NULL;",
          "265:     return;",
          "270:     voip_calls_tapinfo_t *voip_tapinfo = voip_calls_get_info();",
          "271:     voip_tapinfo->graph_analysis = (seq_analysis_info_t *)g_malloc(sizeof(seq_analysis_info_t));",
          "272:     voip_tapinfo->graph_analysis->nconv = 0;",
          "273:     voip_tapinfo->graph_analysis->items = g_queue_new();;",
          "274:     voip_tapinfo->graph_analysis->ht= g_hash_table_new(g_int_hash, g_int_equal);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "279: static void",
          "280: add_to_graph(voip_calls_tapinfo_t *tapinfo, packet_info *pinfo, epan_dissect_t *edt, const gchar *frame_label, const gchar *comment, guint16 call_num, address *src_addr, address *dst_addr, guint16 line_style)",
          "281: {",
          "312: }",
          "",
          "[Removed Lines]",
          "282:  seq_analysis_item_t *gai;",
          "283:  gchar time_str[COL_MAX_LEN];",
          "285:  gai = (seq_analysis_item_t *)g_malloc(sizeof(seq_analysis_item_t));",
          "286:  gai->fd = pinfo->fd;",
          "287:  COPY_ADDRESS(&(gai->src_addr),src_addr);",
          "288:  COPY_ADDRESS(&(gai->dst_addr),dst_addr);",
          "290:  gai->port_src=pinfo->srcport;",
          "291:  gai->port_dst=pinfo->destport;",
          "292:  if (frame_label != NULL)",
          "293:   gai->frame_label = g_strdup(frame_label);",
          "294:  else",
          "295:   gai->frame_label = g_strdup(\"\");",
          "297:  if (comment != NULL)",
          "298:   gai->comment = g_strdup(comment);",
          "299:  else",
          "300:   gai->comment = g_strdup(\"\");",
          "301:  gai->conv_num=call_num;",
          "302:  gai->line_style=line_style;",
          "303:  set_fd_time(edt->session, gai->fd, time_str);",
          "304:  gai->time_str = g_strdup(time_str);",
          "305:  gai->display=FALSE;",
          "307:  if(tapinfo->graph_analysis){",
          "308:   g_queue_push_tail(tapinfo->graph_analysis->items, gai);",
          "309:   g_hash_table_insert(tapinfo->graph_analysis->ht, &gai->fd->num, gai);",
          "310:  }",
          "",
          "[Added Lines]",
          "282:     seq_analysis_item_t *gai;",
          "283:     gchar time_str[COL_MAX_LEN];",
          "285:     gai = (seq_analysis_item_t *)g_malloc(sizeof(seq_analysis_item_t));",
          "286:     gai->fd = pinfo->fd;",
          "287:     COPY_ADDRESS(&(gai->src_addr),src_addr);",
          "288:     COPY_ADDRESS(&(gai->dst_addr),dst_addr);",
          "290:     gai->port_src=pinfo->srcport;",
          "291:     gai->port_dst=pinfo->destport;",
          "292:     if (frame_label != NULL)",
          "293:         gai->frame_label = g_strdup(frame_label);",
          "294:     else",
          "295:         gai->frame_label = g_strdup(\"\");",
          "297:     if (comment != NULL)",
          "298:         gai->comment = g_strdup(comment);",
          "299:     else",
          "300:         gai->comment = g_strdup(\"\");",
          "301:     gai->conv_num=call_num;",
          "302:     gai->line_style=line_style;",
          "303:     set_fd_time(edt->session, gai->fd, time_str);",
          "304:     gai->time_str = g_strdup(time_str);",
          "305:     gai->display=FALSE;",
          "307:     if(tapinfo->graph_analysis){",
          "308:         g_queue_push_tail(tapinfo->graph_analysis->items, gai);",
          "309:         g_hash_table_insert(tapinfo->graph_analysis->ht, &gai->fd->num, gai);",
          "310:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "317: static int append_to_frame_graph(voip_calls_tapinfo_t *tapinfo _U_, guint32 frame_num, const gchar *new_frame_label, const gchar *new_comment)",
          "318: {",
          "341: }",
          "",
          "[Removed Lines]",
          "319:  seq_analysis_item_t *gai=NULL;",
          "320:  gchar *frame_label = NULL;",
          "321:  gchar *comment = NULL;",
          "323:  if(tapinfo->graph_analysis && NULL!=tapinfo->graph_analysis->ht)",
          "324:   gai=(seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &frame_num);",
          "325:  if(gai) {",
          "326:   frame_label = gai->frame_label;",
          "327:   comment = gai->comment;",
          "329:   if (new_frame_label != NULL) {",
          "330:    gai->frame_label = g_strdup_printf(\"%s %s\", frame_label, new_frame_label);",
          "331:    g_free(frame_label);",
          "332:   }",
          "334:   if (new_comment != NULL) {",
          "335:    gai->comment = g_strdup_printf(\"%s %s\", comment, new_comment);",
          "336:    g_free(comment);",
          "337:   }",
          "338:  }",
          "340:  return gai? 1 : 0;",
          "",
          "[Added Lines]",
          "319:     seq_analysis_item_t *gai=NULL;",
          "320:     gchar *frame_label = NULL;",
          "321:     gchar *comment = NULL;",
          "323:     if(tapinfo->graph_analysis && NULL!=tapinfo->graph_analysis->ht)",
          "324:         gai=(seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &frame_num);",
          "325:     if(gai) {",
          "326:         frame_label = gai->frame_label;",
          "327:         comment = gai->comment;",
          "329:         if (new_frame_label != NULL) {",
          "330:             gai->frame_label = g_strdup_printf(\"%s %s\", frame_label, new_frame_label);",
          "331:             g_free(frame_label);",
          "332:         }",
          "334:         if (new_comment != NULL) {",
          "335:             gai->comment = g_strdup_printf(\"%s %s\", comment, new_comment);",
          "336:             g_free(comment);",
          "337:         }",
          "338:     }",
          "340:     return gai? 1 : 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "346: static int change_frame_graph(voip_calls_tapinfo_t *tapinfo _U_, guint32 frame_num, const gchar *new_frame_label, const gchar *new_comment)",
          "347: {",
          "371: }",
          "375: static guint change_call_num_graph(voip_calls_tapinfo_t *tapinfo _U_, guint16 call_num, guint16 new_call_num)",
          "376: {",
          "395: }",
          "399: static void insert_to_graph_t38(voip_calls_tapinfo_t *tapinfo, packet_info *pinfo, epan_dissect_t *edt, const gchar *frame_label, const gchar *comment, guint16 call_num, address *src_addr, address *dst_addr, guint16 line_style, guint32 frame_num)",
          "400: {",
          "451: }",
          "",
          "[Removed Lines]",
          "348:  seq_analysis_item_t *gai=NULL;",
          "349:  gchar *frame_label = NULL;",
          "350:  gchar *comment = NULL;",
          "353:  if(tapinfo->graph_analysis && NULL!=tapinfo->graph_analysis->ht)",
          "354:   gai=(seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &frame_num);",
          "355:  if(gai) {",
          "356:   frame_label = gai->frame_label;",
          "357:   comment = gai->comment;",
          "359:   if (new_frame_label != NULL) {",
          "360:    gai->frame_label = g_strdup(new_frame_label);",
          "361:    g_free(frame_label);",
          "362:   }",
          "364:   if (new_comment != NULL) {",
          "365:    gai->comment = g_strdup(new_comment);",
          "366:    g_free(comment);",
          "367:   }",
          "368:  }",
          "370:  return gai? 1 : 0;",
          "377:  seq_analysis_item_t *gai;",
          "378:  GList *list;",
          "379:  guint items_changed;",
          "381:  items_changed = 0;",
          "382:  if(tapinfo->graph_analysis){",
          "383:   list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "384:   while (list)",
          "385:   {",
          "386:    gai = (seq_analysis_item_t *)list->data;",
          "387:    if (gai->conv_num == call_num) {",
          "388:     gai->conv_num = new_call_num;",
          "389:     items_changed++;",
          "390:    }",
          "391:    list = g_list_next(list);",
          "392:   }",
          "393:  }",
          "394:  return items_changed;",
          "401:  seq_analysis_item_t *gai, *new_gai;",
          "402:  GList *list;",
          "403:  guint item_num;",
          "404:  gboolean inserted;",
          "405:  gchar time_str[COL_MAX_LEN];",
          "407:  new_gai = (seq_analysis_item_t *)g_malloc(sizeof(seq_analysis_item_t));",
          "408:  new_gai->fd = packet_list_get_row_data(frame_num);",
          "409:  COPY_ADDRESS(&(new_gai->src_addr),src_addr);",
          "410:  COPY_ADDRESS(&(new_gai->dst_addr),dst_addr);",
          "412:  new_gai->port_src=pinfo->srcport;",
          "413:  new_gai->port_dst=pinfo->destport;",
          "414:  if (frame_label != NULL)",
          "415:   new_gai->frame_label = g_strdup(frame_label);",
          "416:  else",
          "417:   new_gai->frame_label = g_strdup(\"\");",
          "419:  if (comment != NULL)",
          "420:   new_gai->comment = g_strdup(comment);",
          "421:  else",
          "422:   new_gai->comment = g_strdup(\"\");",
          "423:  new_gai->conv_num=call_num;",
          "424:  new_gai->line_style=line_style;",
          "425:  set_fd_time(edt->session, new_gai->fd, time_str);",
          "426:  new_gai->time_str = g_strdup(time_str);",
          "427:  new_gai->display=FALSE;",
          "429:  item_num = 0;",
          "430:  inserted = FALSE;",
          "431:  if(tapinfo->graph_analysis){",
          "432:  list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "433:   while (list)",
          "434:   {",
          "435:    gai = (seq_analysis_item_t *)list->data;",
          "436:    if (gai->fd->num > frame_num) {",
          "437:     g_queue_insert_before(tapinfo->graph_analysis->items, list, new_gai);",
          "438:     g_hash_table_insert(tapinfo->graph_analysis->ht, &new_gai->fd->num, new_gai);",
          "439:     inserted = TRUE;",
          "440:     break;",
          "441:    }",
          "442:    list = g_list_next(list);",
          "443:    item_num++;",
          "444:   }",
          "446:   if (!inserted) {",
          "447:    g_queue_push_tail(tapinfo->graph_analysis->items, new_gai);",
          "448:    g_hash_table_insert(tapinfo->graph_analysis->ht, &new_gai->fd->num, new_gai);",
          "449:   }",
          "450:  }",
          "",
          "[Added Lines]",
          "348:     seq_analysis_item_t *gai=NULL;",
          "349:     gchar *frame_label = NULL;",
          "350:     gchar *comment = NULL;",
          "352:     if(tapinfo->graph_analysis && NULL!=tapinfo->graph_analysis->ht)",
          "353:         gai=(seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &frame_num);",
          "354:     if(gai) {",
          "355:         frame_label = gai->frame_label;",
          "356:         comment = gai->comment;",
          "358:         if (new_frame_label != NULL) {",
          "359:             gai->frame_label = g_strdup(new_frame_label);",
          "360:             g_free(frame_label);",
          "361:         }",
          "363:         if (new_comment != NULL) {",
          "364:             gai->comment = g_strdup(new_comment);",
          "365:             g_free(comment);",
          "366:         }",
          "367:     }",
          "369:     return gai? 1 : 0;",
          "376:     seq_analysis_item_t *gai;",
          "377:     GList *list;",
          "378:     guint items_changed;",
          "380:     items_changed = 0;",
          "381:     if(tapinfo->graph_analysis){",
          "382:         list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "383:         while (list)",
          "384:         {",
          "385:             gai = (seq_analysis_item_t *)list->data;",
          "386:             if (gai->conv_num == call_num) {",
          "387:                 gai->conv_num = new_call_num;",
          "388:                 items_changed++;",
          "389:             }",
          "390:             list = g_list_next(list);",
          "391:         }",
          "392:     }",
          "393:     return items_changed;",
          "400:     seq_analysis_item_t *gai, *new_gai;",
          "401:     GList *list;",
          "402:     guint item_num;",
          "403:     gboolean inserted;",
          "404:     gchar time_str[COL_MAX_LEN];",
          "406:     new_gai = (seq_analysis_item_t *)g_malloc(sizeof(seq_analysis_item_t));",
          "407:     new_gai->fd = packet_list_get_row_data(frame_num);",
          "408:     COPY_ADDRESS(&(new_gai->src_addr),src_addr);",
          "409:     COPY_ADDRESS(&(new_gai->dst_addr),dst_addr);",
          "411:     new_gai->port_src=pinfo->srcport;",
          "412:     new_gai->port_dst=pinfo->destport;",
          "413:     if (frame_label != NULL)",
          "414:         new_gai->frame_label = g_strdup(frame_label);",
          "415:     else",
          "416:         new_gai->frame_label = g_strdup(\"\");",
          "418:     if (comment != NULL)",
          "419:         new_gai->comment = g_strdup(comment);",
          "420:     else",
          "421:         new_gai->comment = g_strdup(\"\");",
          "422:     new_gai->conv_num=call_num;",
          "423:     new_gai->line_style=line_style;",
          "424:     set_fd_time(edt->session, new_gai->fd, time_str);",
          "425:     new_gai->time_str = g_strdup(time_str);",
          "426:     new_gai->display=FALSE;",
          "428:     item_num = 0;",
          "429:     inserted = FALSE;",
          "430:     if(tapinfo->graph_analysis){",
          "431:         list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "432:         while (list)",
          "433:         {",
          "434:             gai = (seq_analysis_item_t *)list->data;",
          "435:             if (gai->fd->num > frame_num) {",
          "436:                 g_queue_insert_before(tapinfo->graph_analysis->items, list, new_gai);",
          "437:                 g_hash_table_insert(tapinfo->graph_analysis->ht, &new_gai->fd->num, new_gai);",
          "438:                 inserted = TRUE;",
          "439:                 break;",
          "440:             }",
          "441:             list = g_list_next(list);",
          "442:             item_num++;",
          "443:         }",
          "445:         if (!inserted) {",
          "446:             g_queue_push_tail(tapinfo->graph_analysis->items, new_gai);",
          "447:             g_hash_table_insert(tapinfo->graph_analysis->ht, &new_gai->fd->num, new_gai);",
          "448:         }",
          "449:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "464: static int",
          "465: rtp_event_packet(void *ptr _U_, packet_info *pinfo, epan_dissect_t *edt _U_, const void *rtp_event_info)",
          "466: {",
          "479: }",
          "482: void",
          "483: rtp_event_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "484: {",
          "500: }",
          "",
          "[Removed Lines]",
          "467:  const struct _rtp_event_info *pi = (const struct _rtp_event_info *)rtp_event_info;",
          "470:  if (pi->info_setup_frame_num == 0) {",
          "471:   return 0;",
          "472:  }",
          "474:  rtp_evt_frame_num = pinfo->fd->num;",
          "475:  rtp_evt = pi->info_rtp_evt;",
          "476:  rtp_evt_end = pi->info_end;",
          "478:  return 0;",
          "485:  GString *error_string;",
          "487:  error_string = register_tap_listener(\"rtpevent\", tap_base_to_id(tap_id_base, tap_id_offset_rtp_event_),",
          "488:   NULL,",
          "489:   0,",
          "490:   NULL,",
          "491:   rtp_event_packet,",
          "492:   NULL",
          "493:   );",
          "495:  if (error_string != NULL) {",
          "496:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "497:          \"%s\", error_string->str);",
          "498:   g_string_free(error_string, TRUE);",
          "499:  }",
          "",
          "[Added Lines]",
          "466:     const struct _rtp_event_info *pi = (const struct _rtp_event_info *)rtp_event_info;",
          "469:     if (pi->info_setup_frame_num == 0) {",
          "470:         return 0;",
          "471:     }",
          "473:     rtp_evt_frame_num = pinfo->fd->num;",
          "474:     rtp_evt = pi->info_rtp_evt;",
          "475:     rtp_evt_end = pi->info_end;",
          "477:     return 0;",
          "484:     GString *error_string;",
          "486:     error_string = register_tap_listener(\"rtpevent\", tap_base_to_id(tap_id_base, tap_id_offset_rtp_event_),",
          "487:             NULL,",
          "488:             0,",
          "489:             NULL,",
          "490:             rtp_event_packet,",
          "491:             NULL",
          "492:             );",
          "494:     if (error_string != NULL) {",
          "495:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "496:                 \"%s\", error_string->str);",
          "497:         g_string_free(error_string, TRUE);",
          "498:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "516: static void voip_rtp_reset(void *ptr _U_)",
          "517: {",
          "531: }",
          "",
          "[Removed Lines]",
          "518:  voip_rtp_tapinfo_t *tapinfo = &the_tapinfo_rtp_struct;",
          "519:  GList *list;",
          "521:  list = g_list_first(tapinfo->list);",
          "522:  while (list)",
          "523:  {",
          "524:   g_free(list->data);",
          "525:   list = g_list_next(list);",
          "526:  }",
          "527:  g_list_free(tapinfo->list);",
          "528:  tapinfo->list = NULL;",
          "529:  tapinfo->nstreams = 0;",
          "530:  return;",
          "",
          "[Added Lines]",
          "517:     voip_rtp_tapinfo_t *tapinfo = &the_tapinfo_rtp_struct;",
          "518:     GList *list;",
          "520:     list = g_list_first(tapinfo->list);",
          "521:     while (list)",
          "522:     {",
          "523:         g_free(list->data);",
          "524:         list = g_list_next(list);",
          "525:     }",
          "526:     g_list_free(tapinfo->list);",
          "527:     tapinfo->list = NULL;",
          "528:     tapinfo->nstreams = 0;",
          "529:     return;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "535: static int",
          "536: rtp_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt _U_, void const *RTPinfo)",
          "537: {",
          "553: #ifdef HAVE_LIBPORTAUDIO",
          "555: #endif",
          "629: }",
          "633: static void rtp_packet_draw(void *tap_offset_ptr)",
          "634: {",
          "695: }",
          "696: #if 0",
          "697: static void RTP_packet_draw(void *tap_offset_ptr)",
          "",
          "[Removed Lines]",
          "538:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);",
          "539:  voip_rtp_tapinfo_t *rtp_tapinfo = &the_tapinfo_rtp_struct;",
          "540:  voip_rtp_stream_info_t *tmp_listinfo;",
          "541:  voip_rtp_stream_info_t *strinfo = NULL;",
          "542:  GList *list;",
          "543:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "545:  const struct _rtp_info *pi = (const struct _rtp_info *)RTPinfo;",
          "548:  if (pi->info_setup_frame_num == 0) {",
          "549:   return 0;",
          "550:  }",
          "554:  add_rtp_packet(pi, pinfo);",
          "558:  list = g_list_first(rtp_tapinfo->list);",
          "559:  while (list)",
          "560:  {",
          "561:   tmp_listinfo=(voip_rtp_stream_info_t *)list->data;",
          "562:   if ( (tmp_listinfo->setup_frame_number == pi->info_setup_frame_num)",
          "563:    && (tmp_listinfo->ssrc == pi->info_sync_src) && (tmp_listinfo->end_stream == FALSE)) {",
          "566:    if ( tmp_listinfo->pt != pi->info_payload_type ) {",
          "567:     tmp_listinfo->end_stream = TRUE;",
          "568:    } else {",
          "569:     strinfo = (voip_rtp_stream_info_t*)(list->data);",
          "570:     break;",
          "571:    }",
          "572:   }",
          "573:   list = g_list_next(list);",
          "574:  }",
          "577:  if ((rtp_evt_frame_num == pinfo->fd->num) && !strinfo && (rtp_evt_end == TRUE)) {",
          "578:   return 0;",
          "579:  }",
          "582:  if (strinfo==NULL) {",
          "583:   strinfo = (voip_rtp_stream_info_t *)g_malloc(sizeof(voip_rtp_stream_info_t));",
          "584:   COPY_ADDRESS(&(strinfo->src_addr), &(pinfo->src));",
          "585:   strinfo->src_port = pinfo->srcport;",
          "586:   COPY_ADDRESS(&(strinfo->dest_addr), &(pinfo->dst));",
          "587:   strinfo->dest_port = pinfo->destport;",
          "588:   strinfo->ssrc = pi->info_sync_src;",
          "589:   strinfo->end_stream = FALSE;",
          "590:   strinfo->pt = pi->info_payload_type;",
          "591:   strinfo->pt_str = NULL;",
          "592:   strinfo->is_srtp = pi->info_is_srtp;",
          "594:   if ( (strinfo->pt >= PT_UNDF_96) && (strinfo->pt <= PT_UNDF_127) ) {",
          "596:    p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_get_id_by_filter_name(\"rtp\"), 0);",
          "597:    if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "598:     const gchar *encoding_name = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, strinfo->pt);",
          "599:     if (encoding_name) {",
          "600:      strinfo->pt_str = g_strdup(encoding_name);",
          "601:     }",
          "602:    }",
          "603:   }",
          "604:   if (!strinfo->pt_str) strinfo->pt_str = g_strdup(val_to_str_ext(strinfo->pt, &rtp_payload_type_short_vals_ext, \"%u\"));",
          "605:   strinfo->npackets = 0;",
          "606:   strinfo->start_fd = pinfo->fd;",
          "607:   strinfo->start_rel_ts = pinfo->rel_ts;",
          "608:   strinfo->setup_frame_number = pi->info_setup_frame_num;",
          "609:   strinfo->rtp_event = -1;",
          "610:   rtp_tapinfo->list = g_list_prepend(rtp_tapinfo->list, strinfo);",
          "611:  }",
          "614:  strinfo->npackets++;",
          "615:  strinfo->stop_fd = pinfo->fd;",
          "616:  strinfo->stop_rel_ts = pinfo->rel_ts;",
          "619:  if (rtp_evt_frame_num == pinfo->fd->num) {",
          "620:   strinfo->rtp_event = rtp_evt;",
          "621:   if (rtp_evt_end == TRUE) {",
          "622:    strinfo->end_stream = TRUE;",
          "623:   }",
          "624:  }",
          "626:  tapinfo->redraw = TRUE;",
          "628:  return 1;",
          "635:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);",
          "636:  voip_rtp_tapinfo_t *rtp_tapinfo = &the_tapinfo_rtp_struct;",
          "637:  GList *rtp_streams_list;",
          "638:  voip_rtp_stream_info_t *rtp_listinfo;",
          "640:  seq_analysis_item_t *gai = NULL;",
          "641:  seq_analysis_item_t *new_gai;",
          "642:  guint16 conv_num;",
          "643:  guint32 duration;",
          "644:  gchar time_str[COL_MAX_LEN];",
          "647:  rtp_streams_list = g_list_first(rtp_tapinfo->list);",
          "648:  while (rtp_streams_list)",
          "649:  {",
          "650:   rtp_listinfo = (voip_rtp_stream_info_t *)rtp_streams_list->data;",
          "654:   if(tapinfo->graph_analysis){",
          "655:    gai = (seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &rtp_listinfo->setup_frame_number);",
          "656:   }",
          "657:   if(gai != NULL) {",
          "659:    conv_num = gai->conv_num;",
          "661:    gai = (seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &rtp_listinfo->start_fd->num);",
          "662:    if(gai != NULL) {",
          "663:     duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_rel_ts) - nstime_to_msec(&rtp_listinfo->start_rel_ts));",
          "664:     g_free(gai->comment);",
          "665:     gai->comment = g_strdup_printf(\"%s Num packets:%u  Duration:%u.%03us SSRC:0x%X\",",
          "666:             (rtp_listinfo->is_srtp)?\"SRTP\":\"RTP\", rtp_listinfo->npackets,",
          "667:             duration/1000,(duration%1000), rtp_listinfo->ssrc);",
          "668:    }else {",
          "669:     new_gai = (seq_analysis_item_t *)g_malloc(sizeof(seq_analysis_item_t));",
          "670:     new_gai->fd = rtp_listinfo->start_fd;",
          "671:     COPY_ADDRESS(&(new_gai->src_addr),&(rtp_listinfo->src_addr));",
          "672:     COPY_ADDRESS(&(new_gai->dst_addr),&(rtp_listinfo->dest_addr));",
          "673:     new_gai->port_src = rtp_listinfo->src_port;",
          "674:     new_gai->port_dst = rtp_listinfo->dest_port;",
          "675:     duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_rel_ts) - nstime_to_msec(&rtp_listinfo->start_rel_ts));",
          "676:     new_gai->frame_label = g_strdup_printf(\"%s (%s) %s\",",
          "677:           (rtp_listinfo->is_srtp)?\"SRTP\":\"RTP\",",
          "678:           rtp_listinfo->pt_str,",
          "679:           (rtp_listinfo->rtp_event == -1)?",
          "680:               \"\":val_to_str_ext_const(rtp_listinfo->rtp_event, &rtp_event_type_values_ext, \"Unknown RTP Event\"));",
          "681:     new_gai->comment = g_strdup_printf(\"%s Num packets:%u  Duration:%u.%03us SSRC:0x%X\",",
          "682:              (rtp_listinfo->is_srtp)?\"SRTP\":\"RTP\", rtp_listinfo->npackets,",
          "683:              duration/1000,(duration%1000), rtp_listinfo->ssrc);",
          "684:     new_gai->conv_num = conv_num;",
          "685:     set_fd_time(tapinfo->session, new_gai->fd, time_str);",
          "686:     new_gai->time_str = g_strdup(time_str);",
          "687:     new_gai->display=FALSE;",
          "689:     g_queue_push_tail(tapinfo->graph_analysis->items, new_gai);",
          "690:     g_hash_table_insert(tapinfo->graph_analysis->ht, &rtp_listinfo->start_fd, new_gai);",
          "691:    }",
          "692:   }",
          "693:   rtp_streams_list = g_list_next(rtp_streams_list);",
          "",
          "[Added Lines]",
          "537:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);",
          "538:     voip_rtp_tapinfo_t *rtp_tapinfo = &the_tapinfo_rtp_struct;",
          "539:     voip_rtp_stream_info_t *tmp_listinfo;",
          "540:     voip_rtp_stream_info_t *strinfo = NULL;",
          "541:     GList *list;",
          "542:     struct _rtp_conversation_info *p_conv_data = NULL;",
          "544:     const struct _rtp_info *pi = (const struct _rtp_info *)RTPinfo;",
          "547:     if (pi->info_setup_frame_num == 0) {",
          "548:         return 0;",
          "549:     }",
          "553:     add_rtp_packet(pi, pinfo);",
          "557:     list = g_list_first(rtp_tapinfo->list);",
          "558:     while (list)",
          "559:     {",
          "560:         tmp_listinfo=(voip_rtp_stream_info_t *)list->data;",
          "561:         if ( (tmp_listinfo->setup_frame_number == pi->info_setup_frame_num)",
          "562:                 && (tmp_listinfo->ssrc == pi->info_sync_src) && (tmp_listinfo->end_stream == FALSE)) {",
          "565:             if ( tmp_listinfo->pt != pi->info_payload_type ) {",
          "566:                 tmp_listinfo->end_stream = TRUE;",
          "567:             } else {",
          "568:                 strinfo = (voip_rtp_stream_info_t*)(list->data);",
          "569:                 break;",
          "570:             }",
          "571:         }",
          "572:         list = g_list_next(list);",
          "573:     }",
          "576:     if ((rtp_evt_frame_num == pinfo->fd->num) && !strinfo && (rtp_evt_end == TRUE)) {",
          "577:         return 0;",
          "578:     }",
          "581:     if (strinfo==NULL) {",
          "582:         strinfo = (voip_rtp_stream_info_t *)g_malloc(sizeof(voip_rtp_stream_info_t));",
          "583:         COPY_ADDRESS(&(strinfo->src_addr), &(pinfo->src));",
          "584:         strinfo->src_port = pinfo->srcport;",
          "585:         COPY_ADDRESS(&(strinfo->dest_addr), &(pinfo->dst));",
          "586:         strinfo->dest_port = pinfo->destport;",
          "587:         strinfo->ssrc = pi->info_sync_src;",
          "588:         strinfo->end_stream = FALSE;",
          "589:         strinfo->pt = pi->info_payload_type;",
          "590:         strinfo->pt_str = NULL;",
          "591:         strinfo->is_srtp = pi->info_is_srtp;",
          "593:         if ( (strinfo->pt >= PT_UNDF_96) && (strinfo->pt <= PT_UNDF_127) ) {",
          "595:             p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_get_id_by_filter_name(\"rtp\"), 0);",
          "596:             if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "597:                 const gchar *encoding_name = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, strinfo->pt);",
          "598:                 if (encoding_name) {",
          "599:                     strinfo->pt_str = g_strdup(encoding_name);",
          "600:                 }",
          "601:             }",
          "602:         }",
          "603:         if (!strinfo->pt_str) strinfo->pt_str = g_strdup(val_to_str_ext(strinfo->pt, &rtp_payload_type_short_vals_ext, \"%u\"));",
          "604:         strinfo->npackets = 0;",
          "605:         strinfo->start_fd = pinfo->fd;",
          "606:         strinfo->start_rel_ts = pinfo->rel_ts;",
          "607:         strinfo->setup_frame_number = pi->info_setup_frame_num;",
          "608:         strinfo->rtp_event = -1;",
          "609:         rtp_tapinfo->list = g_list_prepend(rtp_tapinfo->list, strinfo);",
          "610:     }",
          "613:     strinfo->npackets++;",
          "614:     strinfo->stop_fd = pinfo->fd;",
          "615:     strinfo->stop_rel_ts = pinfo->rel_ts;",
          "618:     if (rtp_evt_frame_num == pinfo->fd->num) {",
          "619:         strinfo->rtp_event = rtp_evt;",
          "620:         if (rtp_evt_end == TRUE) {",
          "621:             strinfo->end_stream = TRUE;",
          "622:         }",
          "623:     }",
          "625:     tapinfo->redraw = TRUE;",
          "627:     return 1;",
          "634:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);",
          "635:     voip_rtp_tapinfo_t *rtp_tapinfo = &the_tapinfo_rtp_struct;",
          "636:     GList *rtp_streams_list;",
          "637:     voip_rtp_stream_info_t *rtp_listinfo;",
          "639:     seq_analysis_item_t *gai = NULL;",
          "640:     seq_analysis_item_t *new_gai;",
          "641:     guint16 conv_num;",
          "642:     guint32 duration;",
          "643:     gchar time_str[COL_MAX_LEN];",
          "646:     rtp_streams_list = g_list_first(rtp_tapinfo->list);",
          "647:     while (rtp_streams_list)",
          "648:     {",
          "649:         rtp_listinfo = (voip_rtp_stream_info_t *)rtp_streams_list->data;",
          "653:         if(tapinfo->graph_analysis){",
          "654:             gai = (seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &rtp_listinfo->setup_frame_number);",
          "655:         }",
          "656:         if(gai != NULL) {",
          "658:             conv_num = gai->conv_num;",
          "660:             gai = (seq_analysis_item_t *)g_hash_table_lookup(tapinfo->graph_analysis->ht, &rtp_listinfo->start_fd->num);",
          "661:             if (gai != NULL) {",
          "662:                 duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_rel_ts) - nstime_to_msec(&rtp_listinfo->start_rel_ts));",
          "663:                 g_free(gai->comment);",
          "664:                 gai->comment = g_strdup_printf(\"%s Num packets:%u  Duration:%u.%03us SSRC:0x%X\",",
          "665:                         (rtp_listinfo->is_srtp)?\"SRTP\":\"RTP\", rtp_listinfo->npackets,",
          "666:                         duration/1000,(duration%1000), rtp_listinfo->ssrc);",
          "667:             } else {",
          "668:                 new_gai = (seq_analysis_item_t *)g_malloc(sizeof(seq_analysis_item_t));",
          "669:                 new_gai->fd = rtp_listinfo->start_fd;",
          "670:                 COPY_ADDRESS(&(new_gai->src_addr),&(rtp_listinfo->src_addr));",
          "671:                 COPY_ADDRESS(&(new_gai->dst_addr),&(rtp_listinfo->dest_addr));",
          "672:                 new_gai->port_src = rtp_listinfo->src_port;",
          "673:                 new_gai->port_dst = rtp_listinfo->dest_port;",
          "674:                 duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_rel_ts) - nstime_to_msec(&rtp_listinfo->start_rel_ts));",
          "675:                 new_gai->frame_label = g_strdup_printf(\"%s (%s) %s\",",
          "676:                         (rtp_listinfo->is_srtp)?\"SRTP\":\"RTP\",",
          "677:                         rtp_listinfo->pt_str,",
          "678:                         (rtp_listinfo->rtp_event == -1)?",
          "679:                         \"\":val_to_str_ext_const(rtp_listinfo->rtp_event, &rtp_event_type_values_ext, \"Unknown RTP Event\"));",
          "680:                 new_gai->comment = g_strdup_printf(\"%s Num packets:%u  Duration:%u.%03us SSRC:0x%X\",",
          "681:                         (rtp_listinfo->is_srtp)?\"SRTP\":\"RTP\", rtp_listinfo->npackets,",
          "682:                         duration/1000,(duration%1000), rtp_listinfo->ssrc);",
          "683:                 new_gai->conv_num = conv_num;",
          "684:                 set_fd_time(tapinfo->session, new_gai->fd, time_str);",
          "685:                 new_gai->time_str = g_strdup(time_str);",
          "686:                 new_gai->display=FALSE;",
          "688:                 g_queue_push_tail(tapinfo->graph_analysis->items, new_gai);",
          "689:                 g_hash_table_insert(tapinfo->graph_analysis->ht, &rtp_listinfo->start_fd, new_gai);",
          "690:             }",
          "691:         }",
          "692:         rtp_streams_list = g_list_next(rtp_streams_list);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "781: void",
          "782: rtp_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "783: {",
          "797: }",
          "800: void",
          "801: remove_tap_listener_rtp(voip_calls_tapinfo_t *tap_id_base)",
          "802: {",
          "804: }",
          "",
          "[Removed Lines]",
          "784:  GString *error_string;",
          "786:  error_string = register_tap_listener(\"rtp\", tap_base_to_id(tap_id_base, tap_id_offset_rtp_), NULL,",
          "787:   0,",
          "788:   voip_rtp_reset,",
          "789:   rtp_packet,",
          "790:   rtp_packet_draw",
          "791:   );",
          "792:  if (error_string != NULL) {",
          "793:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "794:          \"%s\", error_string->str);",
          "795:   g_string_free(error_string, TRUE);",
          "796:  }",
          "803:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_rtp_));",
          "",
          "[Added Lines]",
          "783:     GString *error_string;",
          "785:     error_string = register_tap_listener(\"rtp\", tap_base_to_id(tap_id_base, tap_id_offset_rtp_), NULL,",
          "786:             0,",
          "787:             voip_rtp_reset,",
          "788:             rtp_packet,",
          "789:             rtp_packet_draw",
          "790:             );",
          "791:     if (error_string != NULL) {",
          "792:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "793:                 \"%s\", error_string->str);",
          "794:         g_string_free(error_string, TRUE);",
          "795:     }",
          "802:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_rtp_));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "812: static int",
          "813: t38_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *T38info)",
          "814: {",
          "958: }",
          "961: void",
          "962: t38_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "963: {",
          "977: }",
          "980: void",
          "981: remove_tap_listener_t38(voip_calls_tapinfo_t *tap_id_base)",
          "982: {",
          "984: }",
          "",
          "[Removed Lines]",
          "815:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_t38_);",
          "817:  voip_calls_info_t *callsinfo = NULL;",
          "818:  voip_calls_info_t *tmp_listinfo;",
          "819:  GList *voip_calls_graph_list = NULL;",
          "820:  GList *list;",
          "821:  gchar *frame_label = NULL;",
          "822:  gchar *comment = NULL;",
          "823:  seq_analysis_item_t *tmp_gai, *gai = NULL;",
          "824:  guint16 line_style = 2;",
          "825:  double duration;",
          "826:  int conv_num = -1;",
          "828:  const t38_packet_info *pi = (const t38_packet_info *)T38info;",
          "830:  if  (pi->setup_frame_number != 0) {",
          "832:   if(tapinfo->graph_analysis){",
          "833:    voip_calls_graph_list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "834:   }",
          "835:   while (voip_calls_graph_list)",
          "836:   {",
          "837:    tmp_gai = (seq_analysis_item_t *)voip_calls_graph_list->data;",
          "838:    if (pi->setup_frame_number == tmp_gai->fd->num) {",
          "839:     gai = tmp_gai;",
          "840:     break;",
          "841:    }",
          "842:    voip_calls_graph_list = g_list_next(voip_calls_graph_list);",
          "843:   }",
          "844:   if (gai) conv_num = (int) gai->conv_num;",
          "845:  }",
          "852:  if ( (pi->setup_frame_number == 0) || (gai == NULL) ) {",
          "854:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "855:   while (list)",
          "856:   {",
          "857:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "858:    if (tmp_listinfo->protocol == MEDIA_T38) {",
          "859:     callsinfo = (voip_calls_info_t*)(list->data);",
          "860:     break;",
          "861:    }",
          "862:    list = g_list_next (list);",
          "863:   }",
          "866:   if (callsinfo==NULL) {",
          "867:    callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "868:    callsinfo->call_active_state = VOIP_ACTIVE;",
          "869:    callsinfo->call_state = VOIP_UNKNOWN;",
          "870:    callsinfo->from_identity=g_strdup(\"T38 Media only\");",
          "871:    callsinfo->to_identity=g_strdup(\"T38 Media only\");",
          "872:    COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "873:    callsinfo->selected=FALSE;",
          "874:    callsinfo->start_fd = pinfo->fd;",
          "875:    callsinfo->start_rel_ts = pinfo->rel_ts;",
          "876:    callsinfo->protocol=MEDIA_T38;",
          "877:    callsinfo->prot_info=NULL;",
          "878:    callsinfo->free_prot_info = NULL;",
          "879:    callsinfo->npackets = 0;",
          "880:    callsinfo->call_num = tapinfo->ncalls++;",
          "881:    g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "882:   }",
          "883:   callsinfo->stop_fd = pinfo->fd;",
          "884:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "885:   ++(callsinfo->npackets);",
          "887:   ++(tapinfo->npackets);",
          "889:   conv_num = (int) callsinfo->call_num;",
          "890:  }",
          "893:  if (conv_num == -1) {",
          "894:   return 0;",
          "895:  }",
          "899:   frame_label = g_strdup(val_to_str(pi->t30ind_value, t38_T30_indicator_vals, \"Ukn (0x%02X)\") );",
          "900:   comment = g_strdup_printf(\"t38:t30 Ind:%s\",val_to_str(pi->t30ind_value, t38_T30_indicator_vals, \"Ukn (0x%02X)\") );",
          "901:   line_style = 1;",
          "903:   switch(pi->Data_Field_field_type_value) {",
          "905:     break;",
          "908:     frame_label = g_strdup_printf(\"%s %s\",",
          "909:              val_to_str_ext(pi->t30_Facsimile_Control & 0x7F,",
          "910:               &t30_facsimile_control_field_vals_short_ext,",
          "911:               \"Ukn (0x%02X)\"),",
          "912:              pi->desc);",
          "913:     comment      = g_strdup_printf(\"t38:%s:HDLC:%s\",",
          "914:               val_to_str(pi->data_value,",
          "915:            t38_T30_data_vals,",
          "916:            \"Ukn (0x%02X)\"),",
          "917:               val_to_str_ext(pi->t30_Facsimile_Control & 0x7F,",
          "918:                &t30_facsimile_control_field_vals_ext,",
          "919:                \"Ukn (0x%02X)\"));",
          "920:     break;",
          "923:     frame_label = g_strdup(pi->Data_Field_field_type_value == 3 ? \"fcs-BAD\" : \"fcs-BAD-sig-end\");",
          "924:     comment    = g_strdup_printf(\"WARNING: received t38:%s:HDLC:%s\",",
          "925:             val_to_str(pi->data_value,",
          "926:          t38_T30_data_vals,",
          "927:          \"Ukn (0x%02X)\"),",
          "928:             pi->Data_Field_field_type_value == 3 ? \"fcs-BAD\" : \"fcs-BAD-sig-end\");",
          "929:     break;",
          "931:     duration = nstime_to_sec(&pinfo->rel_ts) - pi->time_first_t4_data;",
          "932:     frame_label = g_strdup_printf(\"t4-non-ecm-data:%s\",",
          "933:              val_to_str(pi->data_value,",
          "934:           t38_T30_data_vals,",
          "935:           \"Ukn (0x%02X)\") );",
          "936:     comment     = g_strdup_printf(\"t38:t4-non-ecm-data:%s Duration: %.2fs %s\",",
          "937:              val_to_str(pi->data_value,",
          "938:           t38_T30_data_vals,",
          "939:           \"Ukn (0x%02X)\"),",
          "940:              duration, pi->desc_comment );",
          "941:     insert_to_graph_t38(tapinfo, pinfo, edt, frame_label, comment,",
          "942:           (guint16)conv_num, &(pinfo->src), &(pinfo->dst),",
          "943:           line_style, pi->frame_num_first_t4_data);",
          "944:     break;",
          "945:   }",
          "946:  }",
          "948:  if (frame_label && !(pi->Data_Field_field_type_value == 7 && pi->type_msg == 1)) {",
          "949:   add_to_graph(tapinfo, pinfo, edt, frame_label, comment, (guint16)conv_num, &(pinfo->src), &(pinfo->dst), line_style);",
          "950:  }",
          "952:  g_free(comment);",
          "953:  g_free(frame_label);",
          "955:  tapinfo->redraw = TRUE;",
          "964:  GString *error_string;",
          "966:  error_string = register_tap_listener(\"t38\", tap_base_to_id(tap_id_base, tap_id_offset_t38_), NULL,",
          "967:   0,",
          "968:   voip_calls_dlg_reset,",
          "969:   t38_packet,",
          "970:   voip_calls_dlg_draw",
          "971:   );",
          "972:  if (error_string != NULL) {",
          "973:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "974:          \"%s\", error_string->str);",
          "975:   g_string_free(error_string, TRUE);",
          "976:  }",
          "983:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_t38_));",
          "",
          "[Added Lines]",
          "814:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_t38_);",
          "816:     voip_calls_info_t *callsinfo = NULL;",
          "817:     voip_calls_info_t *tmp_listinfo;",
          "818:     GList *voip_calls_graph_list = NULL;",
          "819:     GList *list;",
          "820:     gchar *frame_label = NULL;",
          "821:     gchar *comment = NULL;",
          "822:     seq_analysis_item_t *tmp_gai, *gai = NULL;",
          "823:     guint16 line_style = 2;",
          "824:     double duration;",
          "825:     int conv_num = -1;",
          "827:     const t38_packet_info *pi = (const t38_packet_info *)T38info;",
          "829:     if  (pi->setup_frame_number != 0) {",
          "831:         if(tapinfo->graph_analysis){",
          "832:             voip_calls_graph_list = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "833:         }",
          "834:         while (voip_calls_graph_list)",
          "835:         {",
          "836:             tmp_gai = (seq_analysis_item_t *)voip_calls_graph_list->data;",
          "837:             if (pi->setup_frame_number == tmp_gai->fd->num) {",
          "838:                 gai = tmp_gai;",
          "839:                 break;",
          "840:             }",
          "841:             voip_calls_graph_list = g_list_next(voip_calls_graph_list);",
          "842:         }",
          "843:         if (gai) conv_num = (int) gai->conv_num;",
          "844:     }",
          "851:     if ( (pi->setup_frame_number == 0) || (gai == NULL) ) {",
          "853:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "854:         while (list)",
          "855:         {",
          "856:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "857:             if (tmp_listinfo->protocol == MEDIA_T38) {",
          "858:                 callsinfo = (voip_calls_info_t*)(list->data);",
          "859:                 break;",
          "860:             }",
          "861:             list = g_list_next (list);",
          "862:         }",
          "865:         if (callsinfo==NULL) {",
          "866:             callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "867:             callsinfo->call_active_state = VOIP_ACTIVE;",
          "868:             callsinfo->call_state = VOIP_UNKNOWN;",
          "869:             callsinfo->from_identity=g_strdup(\"T38 Media only\");",
          "870:             callsinfo->to_identity=g_strdup(\"T38 Media only\");",
          "871:             COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "872:             callsinfo->selected=FALSE;",
          "873:             callsinfo->start_fd = pinfo->fd;",
          "874:             callsinfo->start_rel_ts = pinfo->rel_ts;",
          "875:             callsinfo->protocol=MEDIA_T38;",
          "876:             callsinfo->prot_info=NULL;",
          "877:             callsinfo->free_prot_info = NULL;",
          "878:             callsinfo->npackets = 0;",
          "879:             callsinfo->call_num = tapinfo->ncalls++;",
          "880:             g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "881:         }",
          "882:         callsinfo->stop_fd = pinfo->fd;",
          "883:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "884:         ++(callsinfo->npackets);",
          "886:         ++(tapinfo->npackets);",
          "888:         conv_num = (int) callsinfo->call_num;",
          "889:     }",
          "892:     if (conv_num == -1) {",
          "893:         return 0;",
          "894:     }",
          "898:         frame_label = g_strdup(val_to_str(pi->t30ind_value, t38_T30_indicator_vals, \"Ukn (0x%02X)\") );",
          "899:         comment = g_strdup_printf(\"t38:t30 Ind:%s\",val_to_str(pi->t30ind_value, t38_T30_indicator_vals, \"Ukn (0x%02X)\") );",
          "900:         line_style = 1;",
          "902:         switch(pi->Data_Field_field_type_value) {",
          "904:                 break;",
          "907:                 frame_label = g_strdup_printf(\"%s %s\",",
          "908:                         val_to_str_ext(pi->t30_Facsimile_Control & 0x7F,",
          "909:                             &t30_facsimile_control_field_vals_short_ext,",
          "910:                             \"Ukn (0x%02X)\"),",
          "911:                         pi->desc);",
          "912:                 comment      = g_strdup_printf(\"t38:%s:HDLC:%s\",",
          "913:                         val_to_str(pi->data_value,",
          "914:                             t38_T30_data_vals,",
          "915:                             \"Ukn (0x%02X)\"),",
          "916:                         val_to_str_ext(pi->t30_Facsimile_Control & 0x7F,",
          "917:                             &t30_facsimile_control_field_vals_ext,",
          "918:                             \"Ukn (0x%02X)\"));",
          "919:                 break;",
          "922:                 frame_label = g_strdup(pi->Data_Field_field_type_value == 3 ? \"fcs-BAD\" : \"fcs-BAD-sig-end\");",
          "923:                 comment    = g_strdup_printf(\"WARNING: received t38:%s:HDLC:%s\",",
          "924:                         val_to_str(pi->data_value,",
          "925:                             t38_T30_data_vals,",
          "926:                             \"Ukn (0x%02X)\"),",
          "927:                         pi->Data_Field_field_type_value == 3 ? \"fcs-BAD\" : \"fcs-BAD-sig-end\");",
          "928:                 break;",
          "930:                 duration = nstime_to_sec(&pinfo->rel_ts) - pi->time_first_t4_data;",
          "931:                 frame_label = g_strdup_printf(\"t4-non-ecm-data:%s\",",
          "932:                         val_to_str(pi->data_value,",
          "933:                             t38_T30_data_vals,",
          "934:                             \"Ukn (0x%02X)\") );",
          "935:                 comment     = g_strdup_printf(\"t38:t4-non-ecm-data:%s Duration: %.2fs %s\",",
          "936:                         val_to_str(pi->data_value,",
          "937:                             t38_T30_data_vals,",
          "938:                             \"Ukn (0x%02X)\"),",
          "939:                         duration, pi->desc_comment );",
          "940:                 insert_to_graph_t38(tapinfo, pinfo, edt, frame_label, comment,",
          "941:                         (guint16)conv_num, &(pinfo->src), &(pinfo->dst),",
          "942:                         line_style, pi->frame_num_first_t4_data);",
          "943:                 break;",
          "944:         }",
          "945:     }",
          "947:     if (frame_label && !(pi->Data_Field_field_type_value == 7 && pi->type_msg == 1)) {",
          "948:         add_to_graph(tapinfo, pinfo, edt, frame_label, comment, (guint16)conv_num, &(pinfo->src), &(pinfo->dst), line_style);",
          "949:     }",
          "951:     g_free(comment);",
          "952:     g_free(frame_label);",
          "954:     tapinfo->redraw = TRUE;",
          "963:     GString *error_string;",
          "965:     error_string = register_tap_listener(\"t38\", tap_base_to_id(tap_id_base, tap_id_offset_t38_), NULL,",
          "966:             0,",
          "967:             voip_calls_dlg_reset,",
          "968:             t38_packet,",
          "969:             voip_calls_dlg_draw",
          "970:             );",
          "971:     if (error_string != NULL) {",
          "972:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "973:                 \"%s\", error_string->str);",
          "974:         g_string_free(error_string, TRUE);",
          "975:     }",
          "982:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_t38_));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "996: static void free_sip_info(gpointer p) {",
          "1001: }",
          "",
          "[Removed Lines]",
          "997:  sip_calls_info_t *si = (sip_calls_info_t *)p;",
          "999:  g_free(si->call_identifier);",
          "1000:  g_free(si);",
          "",
          "[Added Lines]",
          "996:     sip_calls_info_t *si = (sip_calls_info_t *)p;",
          "998:     g_free(si->call_identifier);",
          "999:     g_free(si);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1005: static int",
          "1006: sip_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt , const void *SIPinfo)",
          "1007: {",
          "1178: }",
          "1182: voip_calls_tapinfo_t* voip_calls_get_info(void)",
          "1183: {",
          "1193: }",
          "",
          "[Removed Lines]",
          "1008:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sip_);",
          "1012:  voip_calls_info_t *callsinfo = NULL;",
          "1013:  sip_calls_info_t *tmp_sipinfo = NULL;",
          "1014:  address tmp_src, tmp_dst;",
          "1015:  gchar *frame_label = NULL;",
          "1016:  gchar *comment = NULL;",
          "1017:  gchar *old_comment = NULL;",
          "1018:  gchar *key=NULL;",
          "1020:  const sip_info_value_t *pi = (const sip_info_value_t *)SIPinfo;",
          "1023:  if (pi->tap_call_id ==NULL) {",
          "1024:   return 0;",
          "1025:  }",
          "1026:  key=pi->tap_call_id;",
          "1028:  if(NULL==tapinfo->callsinfo_hashtable[SIP_HASH]) {",
          "1030:   tapinfo->callsinfo_hashtable[SIP_HASH]=g_hash_table_new_full(g_str_hash,",
          "1031:               g_str_equal,",
          "1034:  }",
          "1036:  callsinfo = (voip_calls_info_t *)g_hash_table_lookup(tapinfo->callsinfo_hashtable[SIP_HASH], key);",
          "1039:     Create a new flow entry for all messages which have a method in case of FLOW_ALL.",
          "1042:  if ((callsinfo==NULL) && (pi->request_method!=NULL)) {",
          "1046:   if (VoIPcalls_get_flow_show_option() == FLOW_ALL ||",
          "1047:       (VoIPcalls_get_flow_show_option() == FLOW_ONLY_INVITES &&",
          "1048:        strcmp(pi->request_method,\"INVITE\")==0)) {",
          "1049:    callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1050:    callsinfo->call_active_state = VOIP_ACTIVE;",
          "1051:    callsinfo->call_state = VOIP_CALL_SETUP;",
          "1052:    callsinfo->from_identity=g_strdup(pi->tap_from_addr);",
          "1053:    callsinfo->to_identity=g_strdup(pi->tap_to_addr);",
          "1054:    COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "1055:    callsinfo->selected=FALSE;",
          "1056:    callsinfo->start_fd=pinfo->fd;",
          "1057:    callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1058:    callsinfo->protocol=VOIP_SIP;",
          "1059:    callsinfo->prot_info=g_malloc(sizeof(sip_calls_info_t));",
          "1060:    callsinfo->free_prot_info = free_sip_info;",
          "1061:    callsinfo->call_id = g_strdup(pi->tap_call_id);",
          "1062:    tmp_sipinfo = (sip_calls_info_t *)callsinfo->prot_info;",
          "1063:    tmp_sipinfo->call_identifier = g_strdup(pi->tap_call_id);",
          "1064:    tmp_sipinfo->sip_state = SIP_INVITE_SENT;",
          "1065:    tmp_sipinfo->invite_cseq = pi->tap_cseq_number;",
          "1066:    callsinfo->npackets = 0;",
          "1067:    callsinfo->call_num = tapinfo->ncalls++;",
          "1070:    callsinfo->call_comment=g_strdup(pi->request_method);",
          "1072:    g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1074:    g_hash_table_insert(tapinfo->callsinfo_hashtable[SIP_HASH],",
          "1075:          tmp_sipinfo->call_identifier, callsinfo);",
          "1076:   }",
          "1077:  }",
          "1079:  if (callsinfo!=NULL) {",
          "1080:   tmp_sipinfo = (sip_calls_info_t *)callsinfo->prot_info;",
          "1084:   COPY_ADDRESS(&(tmp_src), &(pinfo->src));",
          "1085:   COPY_ADDRESS(&(tmp_dst), &(pinfo->dst));",
          "1087:   if (pi->request_method == NULL) {",
          "1088:    frame_label = g_strdup_printf(\"%u %s\", pi->response_code, pi->reason_phrase );",
          "1089:    comment = g_strdup_printf(\"SIP Status %u %s\", pi->response_code, pi->reason_phrase );",
          "1091:    if ((tmp_sipinfo && pi->tap_cseq_number == tmp_sipinfo->invite_cseq)&&(ADDRESSES_EQUAL(&tmp_dst,&(callsinfo->initial_speaker)))) {",
          "1092:     if ((pi->response_code > 199) && (pi->response_code<300) && (tmp_sipinfo->sip_state == SIP_INVITE_SENT)) {",
          "1093:      tmp_sipinfo->sip_state = SIP_200_REC;",
          "1094:     }",
          "1095:     else if ((pi->response_code>299)&&(tmp_sipinfo->sip_state == SIP_INVITE_SENT)) {",
          "1096:      callsinfo->call_state = VOIP_REJECTED;",
          "1097:      tapinfo->rejected_calls++;",
          "1098:     }",
          "1101:        Multiple code(+reason) may be appended, so skip over intermediate codes (100 trying, 183 ringing, e.t.c.)",
          "1103:     if (pi->response_code >= 200) {",
          "1104:      old_comment = callsinfo->call_comment;",
          "1105:      callsinfo->call_comment=g_strdup_printf(\"%s %u\",",
          "1106:           callsinfo->call_comment,",
          "1107:           pi->response_code/*, pi->reason_phrase*/);",
          "1109:      g_free(old_comment);",
          "1110:     }",
          "1112:    }",
          "1114:   }",
          "1115:   else {",
          "1116:    frame_label = g_strdup(pi->request_method);",
          "1118:    if ((strcmp(pi->request_method,\"INVITE\")==0)&&(ADDRESSES_EQUAL(&tmp_src,&(callsinfo->initial_speaker)))) {",
          "1119:     tmp_sipinfo->invite_cseq = pi->tap_cseq_number;",
          "1120:     callsinfo->call_state = VOIP_CALL_SETUP;",
          "1122:     comment = g_strdup_printf(\"SIP INVITE From: %s To:%s Call-ID:%s CSeq:%d\",",
          "1123:          callsinfo->from_identity, callsinfo->to_identity,",
          "1124:          callsinfo->call_id, pi->tap_cseq_number);",
          "1125:    }",
          "1126:    else if ((strcmp(pi->request_method,\"ACK\")==0)&&(pi->tap_cseq_number == tmp_sipinfo->invite_cseq)",
          "1127:     &&(ADDRESSES_EQUAL(&tmp_src,&(callsinfo->initial_speaker)))&&(tmp_sipinfo->sip_state==SIP_200_REC)",
          "1128:     &&(callsinfo->call_state == VOIP_CALL_SETUP)) {",
          "1129:     callsinfo->call_state = VOIP_IN_CALL;",
          "1130:     comment = g_strdup_printf(\"SIP Request INVITE ACK 200 CSeq:%d\", pi->tap_cseq_number);",
          "1131:    }",
          "1132:    else if (strcmp(pi->request_method,\"BYE\")==0) {",
          "1133:     callsinfo->call_state = VOIP_COMPLETED;",
          "1134:     tapinfo->completed_calls++;",
          "1135:     comment = g_strdup_printf(\"SIP Request BYE CSeq:%d\", pi->tap_cseq_number);",
          "1136:    }",
          "1137:    else if ((strcmp(pi->request_method,\"CANCEL\")==0)&&(pi->tap_cseq_number == tmp_sipinfo->invite_cseq)",
          "1138:     &&(ADDRESSES_EQUAL(&tmp_src,&(callsinfo->initial_speaker)))&&(callsinfo->call_state==VOIP_CALL_SETUP)) {",
          "1139:     callsinfo->call_state = VOIP_CANCELLED;",
          "1140:     tmp_sipinfo->sip_state = SIP_CANCEL_SENT;",
          "1141:     comment = g_strdup_printf(\"SIP Request CANCEL CSeq:%d\", pi->tap_cseq_number);",
          "1142:    } else {",
          "1144:     tmp_sipinfo->invite_cseq = pi->tap_cseq_number;",
          "1145:     callsinfo->call_state = VOIP_CALL_SETUP;",
          "1146:     comment = g_strdup_printf(\"SIP %s From: %s To:%s CSeq:%d\",",
          "1147:          pi->request_method,",
          "1148:          callsinfo->from_identity,",
          "1149:          callsinfo->to_identity, pi->tap_cseq_number);",
          "1150:    }",
          "1151:   }",
          "1153:   callsinfo->stop_fd = pinfo->fd;",
          "1154:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1155:   ++(callsinfo->npackets);",
          "1157:   ++(tapinfo->npackets);",
          "1160:   add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "1161:   g_free(comment);",
          "1162:   g_free(frame_label);",
          "1163:   g_free((void *)tmp_src.data);",
          "1164:   g_free((void *)tmp_dst.data);",
          "1167:   if ( (sdp_summary != NULL) && (sdp_frame_num == pinfo->fd->num) ) {",
          "1168:     append_to_frame_graph(tapinfo, pinfo->fd->num, sdp_summary, NULL);",
          "1169:     g_free(sdp_summary);",
          "1170:     sdp_summary = NULL;",
          "1171:   }",
          "1173:  }",
          "1175:  tapinfo->redraw = TRUE;",
          "1185:  static voip_calls_tapinfo_t the_tapinfo_struct =",
          "1186:    {0, NULL, {0}, 0, NULL, 0, 0, 0, 0, NULL, NULL, FALSE};",
          "1188:  if (!the_tapinfo_struct.callsinfos) {",
          "1190:   the_tapinfo_struct.callsinfos = g_queue_new();",
          "1191:  }",
          "1192:  return &the_tapinfo_struct;",
          "",
          "[Added Lines]",
          "1007:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sip_);",
          "1011:     voip_calls_info_t *callsinfo = NULL;",
          "1012:     sip_calls_info_t *tmp_sipinfo = NULL;",
          "1013:     address tmp_src, tmp_dst;",
          "1014:     gchar *frame_label = NULL;",
          "1015:     gchar *comment = NULL;",
          "1016:     gchar *old_comment = NULL;",
          "1017:     gchar *key=NULL;",
          "1019:     const sip_info_value_t *pi = (const sip_info_value_t *)SIPinfo;",
          "1022:     if (pi->tap_call_id ==NULL) {",
          "1023:         return 0;",
          "1024:     }",
          "1025:     key=pi->tap_call_id;",
          "1027:     if(NULL==tapinfo->callsinfo_hashtable[SIP_HASH]) {",
          "1029:         tapinfo->callsinfo_hashtable[SIP_HASH]=g_hash_table_new_full(g_str_hash,",
          "1030:                 g_str_equal,",
          "1033:     }",
          "1035:     callsinfo = (voip_calls_info_t *)g_hash_table_lookup(tapinfo->callsinfo_hashtable[SIP_HASH], key);",
          "1038:        Create a new flow entry for all messages which have a method in case of FLOW_ALL.",
          "1041:     if ((callsinfo==NULL) && (pi->request_method!=NULL)) {",
          "1045:         if (VoIPcalls_get_flow_show_option() == FLOW_ALL ||",
          "1046:                 (VoIPcalls_get_flow_show_option() == FLOW_ONLY_INVITES &&",
          "1047:                  strcmp(pi->request_method,\"INVITE\")==0)) {",
          "1048:             callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1049:             callsinfo->call_active_state = VOIP_ACTIVE;",
          "1050:             callsinfo->call_state = VOIP_CALL_SETUP;",
          "1051:             callsinfo->from_identity=g_strdup(pi->tap_from_addr);",
          "1052:             callsinfo->to_identity=g_strdup(pi->tap_to_addr);",
          "1053:             COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "1054:             callsinfo->selected=FALSE;",
          "1055:             callsinfo->start_fd=pinfo->fd;",
          "1056:             callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1057:             callsinfo->protocol=VOIP_SIP;",
          "1058:             callsinfo->prot_info=g_malloc(sizeof(sip_calls_info_t));",
          "1059:             callsinfo->free_prot_info = free_sip_info;",
          "1060:             callsinfo->call_id = g_strdup(pi->tap_call_id);",
          "1061:             tmp_sipinfo = (sip_calls_info_t *)callsinfo->prot_info;",
          "1062:             tmp_sipinfo->call_identifier = g_strdup(pi->tap_call_id);",
          "1063:             tmp_sipinfo->sip_state = SIP_INVITE_SENT;",
          "1064:             tmp_sipinfo->invite_cseq = pi->tap_cseq_number;",
          "1065:             callsinfo->npackets = 0;",
          "1066:             callsinfo->call_num = tapinfo->ncalls++;",
          "1069:             callsinfo->call_comment=g_strdup(pi->request_method);",
          "1071:             g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1073:             g_hash_table_insert(tapinfo->callsinfo_hashtable[SIP_HASH],",
          "1074:                     tmp_sipinfo->call_identifier, callsinfo);",
          "1075:         }",
          "1076:     }",
          "1078:     if (callsinfo!=NULL) {",
          "1079:         tmp_sipinfo = (sip_calls_info_t *)callsinfo->prot_info;",
          "1083:         COPY_ADDRESS(&(tmp_src), &(pinfo->src));",
          "1084:         COPY_ADDRESS(&(tmp_dst), &(pinfo->dst));",
          "1086:         if (pi->request_method == NULL) {",
          "1087:             frame_label = g_strdup_printf(\"%u %s\", pi->response_code, pi->reason_phrase );",
          "1088:             comment = g_strdup_printf(\"SIP Status %u %s\", pi->response_code, pi->reason_phrase );",
          "1090:             if ((tmp_sipinfo && pi->tap_cseq_number == tmp_sipinfo->invite_cseq)&&(ADDRESSES_EQUAL(&tmp_dst,&(callsinfo->initial_speaker)))) {",
          "1091:                 if ((pi->response_code > 199) && (pi->response_code<300) && (tmp_sipinfo->sip_state == SIP_INVITE_SENT)) {",
          "1092:                     tmp_sipinfo->sip_state = SIP_200_REC;",
          "1093:                 }",
          "1094:                 else if ((pi->response_code>299)&&(tmp_sipinfo->sip_state == SIP_INVITE_SENT)) {",
          "1095:                     callsinfo->call_state = VOIP_REJECTED;",
          "1096:                     tapinfo->rejected_calls++;",
          "1097:                 }",
          "1100:                    Multiple code(+reason) may be appended, so skip over intermediate codes (100 trying, 183 ringing, e.t.c.)",
          "1102:                 if (pi->response_code >= 200) {",
          "1103:                     old_comment = callsinfo->call_comment;",
          "1104:                     callsinfo->call_comment=g_strdup_printf(\"%s %u\",",
          "1105:                             callsinfo->call_comment,",
          "1106:                             pi->response_code/*, pi->reason_phrase*/);",
          "1108:                     g_free(old_comment);",
          "1109:                 }",
          "1111:             }",
          "1113:         }",
          "1114:         else {",
          "1115:             frame_label = g_strdup(pi->request_method);",
          "1117:             if ((strcmp(pi->request_method,\"INVITE\")==0)&&(ADDRESSES_EQUAL(&tmp_src,&(callsinfo->initial_speaker)))) {",
          "1118:                 tmp_sipinfo->invite_cseq = pi->tap_cseq_number;",
          "1119:                 callsinfo->call_state = VOIP_CALL_SETUP;",
          "1121:                 comment = g_strdup_printf(\"SIP INVITE From: %s To:%s Call-ID:%s CSeq:%d\",",
          "1122:                         callsinfo->from_identity, callsinfo->to_identity,",
          "1123:                         callsinfo->call_id, pi->tap_cseq_number);",
          "1124:             }",
          "1125:             else if ((strcmp(pi->request_method,\"ACK\")==0)&&(pi->tap_cseq_number == tmp_sipinfo->invite_cseq)",
          "1126:                     &&(ADDRESSES_EQUAL(&tmp_src,&(callsinfo->initial_speaker)))&&(tmp_sipinfo->sip_state==SIP_200_REC)",
          "1127:                     &&(callsinfo->call_state == VOIP_CALL_SETUP)) {",
          "1128:                 callsinfo->call_state = VOIP_IN_CALL;",
          "1129:                 comment = g_strdup_printf(\"SIP Request INVITE ACK 200 CSeq:%d\", pi->tap_cseq_number);",
          "1130:             }",
          "1131:             else if (strcmp(pi->request_method,\"BYE\")==0) {",
          "1132:                 callsinfo->call_state = VOIP_COMPLETED;",
          "1133:                 tapinfo->completed_calls++;",
          "1134:                 comment = g_strdup_printf(\"SIP Request BYE CSeq:%d\", pi->tap_cseq_number);",
          "1135:             }",
          "1136:             else if ((strcmp(pi->request_method,\"CANCEL\")==0)&&(pi->tap_cseq_number == tmp_sipinfo->invite_cseq)",
          "1137:                     &&(ADDRESSES_EQUAL(&tmp_src,&(callsinfo->initial_speaker)))&&(callsinfo->call_state==VOIP_CALL_SETUP)) {",
          "1138:                 callsinfo->call_state = VOIP_CANCELLED;",
          "1139:                 tmp_sipinfo->sip_state = SIP_CANCEL_SENT;",
          "1140:                 comment = g_strdup_printf(\"SIP Request CANCEL CSeq:%d\", pi->tap_cseq_number);",
          "1141:             } else {",
          "1143:                 tmp_sipinfo->invite_cseq = pi->tap_cseq_number;",
          "1144:                 callsinfo->call_state = VOIP_CALL_SETUP;",
          "1145:                 comment = g_strdup_printf(\"SIP %s From: %s To:%s CSeq:%d\",",
          "1146:                         pi->request_method,",
          "1147:                         callsinfo->from_identity,",
          "1148:                         callsinfo->to_identity, pi->tap_cseq_number);",
          "1149:             }",
          "1150:         }",
          "1152:         callsinfo->stop_fd = pinfo->fd;",
          "1153:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1154:         ++(callsinfo->npackets);",
          "1156:         ++(tapinfo->npackets);",
          "1159:         add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "1160:         g_free(comment);",
          "1161:         g_free(frame_label);",
          "1162:         g_free((void *)tmp_src.data);",
          "1163:         g_free((void *)tmp_dst.data);",
          "1166:         if ( (sdp_summary != NULL) && (sdp_frame_num == pinfo->fd->num) ) {",
          "1167:             append_to_frame_graph(tapinfo, pinfo->fd->num, sdp_summary, NULL);",
          "1168:             g_free(sdp_summary);",
          "1169:             sdp_summary = NULL;",
          "1170:         }",
          "1172:     }",
          "1174:     tapinfo->redraw = TRUE;",
          "1184:     static voip_calls_tapinfo_t the_tapinfo_struct =",
          "1185:         {0, NULL, {0}, 0, NULL, 0, 0, 0, 0, NULL, NULL, FALSE};",
          "1187:     if (!the_tapinfo_struct.callsinfos) {",
          "1189:         the_tapinfo_struct.callsinfos = g_queue_new();",
          "1190:     }",
          "1191:     return &the_tapinfo_struct;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1199: void",
          "1200: sip_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "1201: {",
          "1215: }",
          "1218: void",
          "1219: remove_tap_listener_sip_calls(voip_calls_tapinfo_t *tap_id_base)",
          "1220: {",
          "1222: }",
          "",
          "[Removed Lines]",
          "1202:  GString *error_string;",
          "1204:  error_string = register_tap_listener(\"sip\", tap_base_to_id(tap_id_base, tap_id_offset_sip_), NULL,",
          "1205:   0,",
          "1206:   voip_calls_dlg_reset,",
          "1207:   sip_calls_packet,",
          "1208:   voip_calls_dlg_draw",
          "1209:   );",
          "1210:  if (error_string != NULL) {",
          "1211:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1212:          \"%s\", error_string->str);",
          "1213:   g_string_free(error_string, TRUE);",
          "1214:  }",
          "1221:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sip_));",
          "",
          "[Added Lines]",
          "1201:     GString *error_string;",
          "1203:     error_string = register_tap_listener(\"sip\", tap_base_to_id(tap_id_base, tap_id_offset_sip_), NULL,",
          "1204:             0,",
          "1205:             voip_calls_dlg_reset,",
          "1206:             sip_calls_packet,",
          "1207:             voip_calls_dlg_draw",
          "1208:             );",
          "1209:     if (error_string != NULL) {",
          "1210:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1211:                 \"%s\", error_string->str);",
          "1212:         g_string_free(error_string, TRUE);",
          "1213:     }",
          "1220:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sip_));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1235: static int",
          "1236: isup_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *isup_info)",
          "1237: {",
          "1392: }",
          "",
          "[Removed Lines]",
          "1238:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_isup_);",
          "1239:  voip_calls_info_t *tmp_listinfo;",
          "1240:  voip_calls_info_t *callsinfo = NULL;",
          "1241:  isup_calls_info_t *tmp_isupinfo;",
          "1242:  gboolean found = FALSE;",
          "1243:  gboolean forward = FALSE;",
          "1244:  gboolean right_pair;",
          "1245:  GList *list;",
          "1246:  gchar *frame_label = NULL;",
          "1247:  gchar *comment = NULL;",
          "1249:  const isup_tap_rec_t *pi = (const isup_tap_rec_t *)isup_info;",
          "1252:  if (mtp3_frame_num != pinfo->fd->num) return 0;",
          "1255:  list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1256:  while (list)",
          "1257:  {",
          "1258:   right_pair = TRUE;",
          "1259:   tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1260:   if ((tmp_listinfo->protocol == VOIP_ISUP)&&(tmp_listinfo->call_active_state==VOIP_ACTIVE)) {",
          "1261:    tmp_isupinfo = (isup_calls_info_t *)tmp_listinfo->prot_info;",
          "1262:    if ((tmp_isupinfo->cic == pi->circuit_id)&&(tmp_isupinfo->ni == mtp3_ni)) {",
          "1263:     if ((tmp_isupinfo->opc == mtp3_opc)&&(tmp_isupinfo->dpc == mtp3_dpc)) {",
          "1264:       forward = TRUE;",
          "1265:     } else if ((tmp_isupinfo->dpc == mtp3_opc)&&(tmp_isupinfo->opc == mtp3_dpc)) {",
          "1266:       forward = FALSE;",
          "1267:     } else {",
          "1268:      right_pair = FALSE;",
          "1269:     }",
          "1271:      if (right_pair) {",
          "1274:      if (tmp_listinfo->call_state == VOIP_CALL_SETUP) {",
          "1275:       found = TRUE;",
          "1276:      } else if (pi->message_type != 1) {",
          "1277:       found = TRUE;",
          "1278:      } else {",
          "1279:       tmp_listinfo->call_active_state=VOIP_INACTIVE;",
          "1280:      }",
          "1281:     }",
          "1283:     if (found) {",
          "1284:      callsinfo = (voip_calls_info_t*)(list->data);",
          "1285:      break;",
          "1286:     }",
          "1287:    }",
          "1288:   }",
          "1289:   list = g_list_next (list);",
          "1290:  }",
          "1296:  if ((callsinfo==NULL) &&(pi->message_type==1)) {",
          "1297:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1298:   callsinfo->call_active_state = VOIP_ACTIVE;",
          "1299:   callsinfo->call_state = VOIP_UNKNOWN;",
          "1300:   COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "1301:   callsinfo->selected=FALSE;",
          "1302:   callsinfo->start_fd=pinfo->fd;",
          "1303:   callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1304:   callsinfo->protocol=VOIP_ISUP;",
          "1305:   if (pi->calling_number!=NULL) {",
          "1306:    callsinfo->from_identity=g_strdup(pi->calling_number);",
          "1307:   }",
          "1308:   if (pi->called_number!=NULL) {",
          "1309:    callsinfo->to_identity=g_strdup(pi->called_number);",
          "1310:   }",
          "1311:   callsinfo->prot_info=g_malloc(sizeof(isup_calls_info_t));",
          "1312:   callsinfo->free_prot_info = g_free;",
          "1313:   tmp_isupinfo=(isup_calls_info_t *)callsinfo->prot_info;",
          "1314:   tmp_isupinfo->opc = mtp3_opc;",
          "1315:   tmp_isupinfo->dpc = mtp3_dpc;",
          "1316:   tmp_isupinfo->ni = mtp3_ni;",
          "1317:   tmp_isupinfo->cic = pi->circuit_id;",
          "1318:   callsinfo->npackets = 0;",
          "1319:   callsinfo->call_num = tapinfo->ncalls++;",
          "1320:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1321:  }",
          "1324:  if (callsinfo!=NULL) {",
          "1325:   callsinfo->stop_fd = pinfo->fd;",
          "1326:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1327:   ++(callsinfo->npackets);",
          "1331:   frame_label = g_strdup(val_to_str_ext_const(pi->message_type, &isup_message_type_value_acro_ext, \"Unknown\"));",
          "1335:    if ((pi->calling_number!=NULL)&&(pi->called_number !=NULL)) {",
          "1336:     comment = g_strdup_printf(\"Call from %s to %s\",",
          "1337:      pi->calling_number, pi->called_number);",
          "1338:     }",
          "1340:    if (forward) {",
          "1341:     comment = g_strdup_printf(\"%i-%i -> %i-%i. Cic:%i\",",
          "1342:      mtp3_ni, mtp3_opc,",
          "1343:      mtp3_ni, mtp3_dpc, pi->circuit_id);",
          "1344:    } else {",
          "1345:     comment = g_strdup_printf(\"%i-%i -> %i-%i. Cic:%i\",",
          "1346:      mtp3_ni, mtp3_dpc,",
          "1347:      mtp3_ni, mtp3_opc, pi->circuit_id);",
          "1348:    }",
          "1349:   }",
          "1352:   switch(pi->message_type) {",
          "1354:     callsinfo->call_state=VOIP_CALL_SETUP;",
          "1355:     break;",
          "1358:     callsinfo->call_state=VOIP_IN_CALL;",
          "1359:     break;",
          "1361:     if (callsinfo->call_state==VOIP_CALL_SETUP) {",
          "1362:      if (forward) {",
          "1363:       callsinfo->call_state=VOIP_CANCELLED;",
          "1364:      }",
          "1365:      else {",
          "1366:       callsinfo->call_state=VOIP_REJECTED;",
          "1367:       tapinfo->rejected_calls++;",
          "1368:      }",
          "1369:     }",
          "1370:     else if (callsinfo->call_state == VOIP_IN_CALL) {",
          "1371:      callsinfo->call_state = VOIP_COMPLETED;",
          "1372:      tapinfo->completed_calls++;",
          "1373:     }",
          "1374:     comment = g_strdup_printf(\"Cause %i - %s\",",
          "1375:          pi->cause_value,",
          "1376:          val_to_str_ext_const(pi->cause_value, &q931_cause_code_vals_ext, \"(Unknown)\"));",
          "1377:     break;",
          "1378:   }",
          "1381:   ++(tapinfo->npackets);",
          "1384:   add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "1385:   g_free(comment);",
          "1386:   g_free(frame_label);",
          "1387:  }",
          "1389:  tapinfo->redraw = TRUE;",
          "",
          "[Added Lines]",
          "1237:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_isup_);",
          "1238:     voip_calls_info_t *tmp_listinfo;",
          "1239:     voip_calls_info_t *callsinfo = NULL;",
          "1240:     isup_calls_info_t *tmp_isupinfo;",
          "1241:     gboolean found = FALSE;",
          "1242:     gboolean forward = FALSE;",
          "1243:     gboolean right_pair;",
          "1244:     GList *list;",
          "1245:     gchar *frame_label = NULL;",
          "1246:     gchar *comment = NULL;",
          "1248:     const isup_tap_rec_t *pi = (const isup_tap_rec_t *)isup_info;",
          "1251:     if (mtp3_frame_num != pinfo->fd->num) return 0;",
          "1254:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1255:     while (list)",
          "1256:     {",
          "1257:         right_pair = TRUE;",
          "1258:         tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1259:         if ((tmp_listinfo->protocol == VOIP_ISUP)&&(tmp_listinfo->call_active_state==VOIP_ACTIVE)) {",
          "1260:             tmp_isupinfo = (isup_calls_info_t *)tmp_listinfo->prot_info;",
          "1261:             if ((tmp_isupinfo->cic == pi->circuit_id)&&(tmp_isupinfo->ni == mtp3_ni)) {",
          "1262:                 if ((tmp_isupinfo->opc == mtp3_opc)&&(tmp_isupinfo->dpc == mtp3_dpc)) {",
          "1263:                     forward = TRUE;",
          "1264:                 } else if ((tmp_isupinfo->dpc == mtp3_opc)&&(tmp_isupinfo->opc == mtp3_dpc)) {",
          "1265:                     forward = FALSE;",
          "1266:                 } else {",
          "1267:                     right_pair = FALSE;",
          "1268:                 }",
          "1270:                 if (right_pair) {",
          "1273:                     if (tmp_listinfo->call_state == VOIP_CALL_SETUP) {",
          "1274:                         found = TRUE;",
          "1275:                     } else if (pi->message_type != 1) {",
          "1276:                         found = TRUE;",
          "1277:                     } else {",
          "1278:                         tmp_listinfo->call_active_state=VOIP_INACTIVE;",
          "1279:                     }",
          "1280:                 }",
          "1282:                 if (found) {",
          "1283:                     callsinfo = (voip_calls_info_t*)(list->data);",
          "1284:                     break;",
          "1285:                 }",
          "1286:             }",
          "1287:         }",
          "1288:         list = g_list_next (list);",
          "1289:     }",
          "1294:     if ((callsinfo==NULL) &&(pi->message_type==1)) {",
          "1295:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1296:         callsinfo->call_active_state = VOIP_ACTIVE;",
          "1297:         callsinfo->call_state = VOIP_UNKNOWN;",
          "1298:         COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "1299:         callsinfo->selected=FALSE;",
          "1300:         callsinfo->start_fd=pinfo->fd;",
          "1301:         callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1302:         callsinfo->protocol=VOIP_ISUP;",
          "1303:         if (pi->calling_number!=NULL) {",
          "1304:             callsinfo->from_identity=g_strdup(pi->calling_number);",
          "1305:         }",
          "1306:         if (pi->called_number!=NULL) {",
          "1307:             callsinfo->to_identity=g_strdup(pi->called_number);",
          "1308:         }",
          "1309:         callsinfo->prot_info=g_malloc(sizeof(isup_calls_info_t));",
          "1310:         callsinfo->free_prot_info = g_free;",
          "1311:         tmp_isupinfo=(isup_calls_info_t *)callsinfo->prot_info;",
          "1312:         tmp_isupinfo->opc = mtp3_opc;",
          "1313:         tmp_isupinfo->dpc = mtp3_dpc;",
          "1314:         tmp_isupinfo->ni = mtp3_ni;",
          "1315:         tmp_isupinfo->cic = pi->circuit_id;",
          "1316:         callsinfo->npackets = 0;",
          "1317:         callsinfo->call_num = tapinfo->ncalls++;",
          "1318:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1319:     }",
          "1322:     if (callsinfo!=NULL) {",
          "1323:         callsinfo->stop_fd = pinfo->fd;",
          "1324:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1325:         ++(callsinfo->npackets);",
          "1329:         frame_label = g_strdup(val_to_str_ext_const(pi->message_type, &isup_message_type_value_acro_ext, \"Unknown\"));",
          "1333:             if ((pi->calling_number!=NULL)&&(pi->called_number !=NULL)) {",
          "1334:                 comment = g_strdup_printf(\"Call from %s to %s\",",
          "1335:                         pi->calling_number, pi->called_number);",
          "1336:             }",
          "1338:             if (forward) {",
          "1339:                 comment = g_strdup_printf(\"%i-%i -> %i-%i. Cic:%i\",",
          "1340:                         mtp3_ni, mtp3_opc,",
          "1341:                         mtp3_ni, mtp3_dpc, pi->circuit_id);",
          "1342:             } else {",
          "1343:                 comment = g_strdup_printf(\"%i-%i -> %i-%i. Cic:%i\",",
          "1344:                         mtp3_ni, mtp3_dpc,",
          "1345:                         mtp3_ni, mtp3_opc, pi->circuit_id);",
          "1346:             }",
          "1347:         }",
          "1350:         switch(pi->message_type) {",
          "1352:                 callsinfo->call_state=VOIP_CALL_SETUP;",
          "1353:                 break;",
          "1356:                 callsinfo->call_state=VOIP_IN_CALL;",
          "1357:                 break;",
          "1359:                 if (callsinfo->call_state==VOIP_CALL_SETUP) {",
          "1360:                     if (forward) {",
          "1361:                         callsinfo->call_state=VOIP_CANCELLED;",
          "1362:                     }",
          "1363:                     else {",
          "1364:                         callsinfo->call_state=VOIP_REJECTED;",
          "1365:                         tapinfo->rejected_calls++;",
          "1366:                     }",
          "1367:                 }",
          "1368:                 else if (callsinfo->call_state == VOIP_IN_CALL) {",
          "1369:                     callsinfo->call_state = VOIP_COMPLETED;",
          "1370:                     tapinfo->completed_calls++;",
          "1371:                 }",
          "1372:                 comment = g_strdup_printf(\"Cause %i - %s\",",
          "1373:                         pi->cause_value,",
          "1374:                         val_to_str_ext_const(pi->cause_value, &q931_cause_code_vals_ext, \"(Unknown)\"));",
          "1375:                 break;",
          "1376:         }",
          "1379:         ++(tapinfo->npackets);",
          "1382:         add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "1383:         g_free(comment);",
          "1384:         g_free(frame_label);",
          "1385:     }",
          "1387:     tapinfo->redraw = TRUE;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1396: void",
          "1397: isup_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "1398: {",
          "1414: }",
          "",
          "[Removed Lines]",
          "1399:  GString *error_string;",
          "1401:  error_string = register_tap_listener(\"isup\", tap_base_to_id(tap_id_base, tap_id_offset_isup_),",
          "1402:   NULL,",
          "1403:   0,",
          "1404:   voip_calls_dlg_reset,",
          "1405:   isup_calls_packet,",
          "1406:   voip_calls_dlg_draw",
          "1407:   );",
          "1409:  if (error_string != NULL) {",
          "1410:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1411:          \"%s\", error_string->str);",
          "1412:   g_string_free(error_string, TRUE);",
          "1413:  }",
          "",
          "[Added Lines]",
          "1397:     GString *error_string;",
          "1399:     error_string = register_tap_listener(\"isup\", tap_base_to_id(tap_id_base, tap_id_offset_isup_),",
          "1400:             NULL,",
          "1401:             0,",
          "1402:             voip_calls_dlg_reset,",
          "1403:             isup_calls_packet,",
          "1404:             voip_calls_dlg_draw",
          "1405:             );",
          "1407:     if (error_string != NULL) {",
          "1408:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1409:                 \"%s\", error_string->str);",
          "1410:         g_string_free(error_string, TRUE);",
          "1411:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1418: void",
          "1419: remove_tap_listener_isup_calls(voip_calls_tapinfo_t *tap_id_base)",
          "1420: {",
          "1422: }",
          "",
          "[Removed Lines]",
          "1421:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_isup_));",
          "",
          "[Added Lines]",
          "1419:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_isup_));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1432: static int",
          "1433: mtp3_calls_packet(void *ptr _U_, packet_info *pinfo, epan_dissect_t *edt _U_, const void *mtp3_info)",
          "1434: {",
          "1445: }",
          "",
          "[Removed Lines]",
          "1435:  const mtp3_tap_rec_t *pi = (const mtp3_tap_rec_t *)mtp3_info;",
          "1439:  mtp3_opc = pi->addr_opc.pc;",
          "1440:  mtp3_dpc = pi->addr_dpc.pc;",
          "1441:  mtp3_ni = pi->addr_opc.ni;",
          "1442:  mtp3_frame_num = pinfo->fd->num;",
          "1444:  return 0;",
          "",
          "[Added Lines]",
          "1433:     const mtp3_tap_rec_t *pi = (const mtp3_tap_rec_t *)mtp3_info;",
          "1437:     mtp3_opc = pi->addr_opc.pc;",
          "1438:     mtp3_dpc = pi->addr_dpc.pc;",
          "1439:     mtp3_ni = pi->addr_opc.ni;",
          "1440:     mtp3_frame_num = pinfo->fd->num;",
          "1442:     return 0;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1449: void",
          "1450: mtp3_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "1451: {",
          "1483: }",
          "",
          "[Removed Lines]",
          "1452:  GString *error_string;",
          "1455:  error_string = register_tap_listener(\"mtp3\", tap_base_to_id(tap_id_base, tap_id_offset_mtp3_),",
          "1456:   NULL,",
          "1457:   0,",
          "1458:   voip_calls_dlg_reset,",
          "1459:   mtp3_calls_packet,",
          "1460:   voip_calls_dlg_draw",
          "1461:   );",
          "1463:  if (error_string != NULL) {",
          "1464:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1465:          \"%s\", error_string->str);",
          "1466:   g_string_free(error_string, TRUE);",
          "1467:  }",
          "1469:  error_string = register_tap_listener(\"m3ua\", tap_base_to_id(tap_id_base, tap_id_offset_m3ua_),",
          "1470:   NULL,",
          "1471:   0,",
          "1472:   voip_calls_dlg_reset,",
          "1473:   mtp3_calls_packet,",
          "1474:   voip_calls_dlg_draw",
          "1475:   );",
          "1477:  if (error_string != NULL) {",
          "1478:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1479:          \"%s\", error_string->str);",
          "1480:   g_string_free(error_string, TRUE);",
          "1481:  }",
          "",
          "[Added Lines]",
          "1450:     GString *error_string;",
          "1452:     error_string = register_tap_listener(\"mtp3\", tap_base_to_id(tap_id_base, tap_id_offset_mtp3_),",
          "1453:             NULL,",
          "1454:             0,",
          "1455:             voip_calls_dlg_reset,",
          "1456:             mtp3_calls_packet,",
          "1457:             voip_calls_dlg_draw",
          "1458:             );",
          "1460:     if (error_string != NULL) {",
          "1461:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1462:                 \"%s\", error_string->str);",
          "1463:         g_string_free(error_string, TRUE);",
          "1464:     }",
          "1466:     error_string = register_tap_listener(\"m3ua\", tap_base_to_id(tap_id_base, tap_id_offset_m3ua_),",
          "1467:             NULL,",
          "1468:             0,",
          "1469:             voip_calls_dlg_reset,",
          "1470:             mtp3_calls_packet,",
          "1471:             voip_calls_dlg_draw",
          "1472:             );",
          "1474:     if (error_string != NULL) {",
          "1475:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1476:                 \"%s\", error_string->str);",
          "1477:         g_string_free(error_string, TRUE);",
          "1478:     }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1487: void",
          "1488: remove_tap_listener_mtp3_calls(voip_calls_tapinfo_t *tap_id_base)",
          "1489: {",
          "1492: }",
          "",
          "[Removed Lines]",
          "1490:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_mtp3_));",
          "1491:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_m3ua_));",
          "",
          "[Added Lines]",
          "1487:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_mtp3_));",
          "1488:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_m3ua_));",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1519: static int",
          "1520: q931_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *q931_info)",
          "1521: {",
          "1774: }",
          "",
          "[Removed Lines]",
          "1522:  GList *list,*list2;",
          "1523:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_q931_);",
          "1524:  h323_calls_info_t *tmp_h323info,*tmp2_h323info;",
          "1525:  actrace_isdn_calls_info_t *tmp_actrace_isdn_info;",
          "1526:  voip_calls_info_t *tmp_listinfo;",
          "1527:  voip_calls_info_t *callsinfo = NULL;",
          "1528:  h245_address_t *h245_add = NULL;",
          "1529:  gchar *comment;",
          "1531:  const q931_packet_info *pi = (const q931_packet_info *)q931_info;",
          "1534:  g_free(q931_calling_number);",
          "1535:  g_free(q931_called_number);",
          "1537:  if (pi->calling_number!=NULL)",
          "1538:   q931_calling_number = g_strdup(pi->calling_number);",
          "1539:  else",
          "1540:   q931_calling_number = g_strdup(\"\");",
          "1542:  if (pi->called_number!=NULL)",
          "1543:   q931_called_number = g_strdup(pi->called_number);",
          "1544:  else",
          "1545:   q931_called_number = g_strdup(\"\");",
          "1546:  q931_cause_value = pi->cause_value;",
          "1547:  q931_frame_num = pinfo->fd->num;",
          "1548:  q931_crv = pi->crv;",
          "1552:  if (h225_frame_num == q931_frame_num) {",
          "1553:   tmp_h323info = NULL;",
          "1554:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1555:   while (list)",
          "1556:   {",
          "1557:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1558:    if ( (tmp_listinfo->protocol == VOIP_H323) && (tmp_listinfo->call_num == h225_call_num) ) {",
          "1559:     tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1560:     callsinfo = (voip_calls_info_t*)(list->data);",
          "1563:     if (tmp_h323info->q931_crv == -1) {",
          "1564:      tmp_h323info->q931_crv = q931_crv;",
          "1565:     } else if (tmp_h323info->q931_crv != q931_crv) {",
          "1566:      tmp_h323info->q931_crv2 = q931_crv;",
          "1567:     }",
          "1568:     break;",
          "1569:    }",
          "1570:    list = g_list_next (list);",
          "1571:   }",
          "1573:   if (callsinfo != NULL) {",
          "1574:    comment = NULL;",
          "1575:    if (h225_cstype == H225_SETUP) {",
          "1577:     if (q931_calling_number != NULL) {",
          "1578:      g_free(callsinfo->from_identity);",
          "1579:      callsinfo->from_identity=g_strdup(q931_calling_number);",
          "1580:     }",
          "1581:     if (q931_called_number != NULL) {",
          "1582:      g_free(callsinfo->to_identity);",
          "1583:      callsinfo->to_identity=g_strdup(q931_called_number);",
          "1584:     }",
          "1588:      we should also check if the h225 signaling IP and port match the destination",
          "1590:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1591:     while (list)",
          "1592:     {",
          "1593:      tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1594:      if (tmp_listinfo->protocol == VOIP_H323) {",
          "1595:       tmp2_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1598:       if ( (strcmp(callsinfo->to_identity, tmp_listinfo->to_identity)==0)",
          "1599:         && (memcmp(&tmp2_h323info->guid, &guid_allzero, GUID_LEN) == 0) ) {",
          "1601:        callsinfo->npackets += change_call_num_graph(tapinfo, tmp_listinfo->call_num, callsinfo->call_num);",
          "1604:        g_free(tmp_listinfo->from_identity);",
          "1605:        g_free(tmp_listinfo->to_identity);",
          "1606:        DUMP_PTR2(tmp2_h323info->guid);",
          "1607:        g_free(tmp2_h323info->guid);",
          "1609:        list2 = g_list_first(tmp2_h323info->h245_list);",
          "1610:        while (list2)",
          "1611:        {",
          "1612:         h245_add=(h245_address_t *)list2->data;",
          "1613:         g_free((void *)h245_add->h245_address.data);",
          "1614:         g_free(list2->data);",
          "1615:         list2 = g_list_next(list2);",
          "1616:        }",
          "1617:        g_list_free(tmp_h323info->h245_list);",
          "1618:        tmp_h323info->h245_list = NULL;",
          "1619:        g_free(tmp_listinfo->prot_info);",
          "1620:        g_queue_unlink(tapinfo->callsinfos, list);",
          "1621:        break;",
          "1622:       }",
          "1623:      }",
          "1624:            list = g_list_next (list);",
          "1625:     }",
          "1627:     comment = g_strdup_printf(\"H225 From: %s To:%s  TunnH245:%s FS:%s\", callsinfo->from_identity, callsinfo->to_identity, (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "1628:          (h225_is_faststart==TRUE?\"on\":\"off\"));",
          "1629:    } else if (h225_cstype == H225_RELEASE_COMPLET) {",
          "1631:     if (q931_cause_value != 0xFF) {",
          "1632:      comment = g_strdup_printf(\"H225 Q931 Rel Cause (%i):%s\", q931_cause_value,",
          "1633:           val_to_str_ext_const(q931_cause_value, &q931_cause_code_vals_ext, \"<unknown>\"));",
          "1635:      comment = g_strdup(\"H225 No Q931 Rel Cause\");",
          "1636:     }",
          "1637:    }",
          "1639:    if (comment != NULL) {",
          "1640:     change_frame_graph(tapinfo, h225_frame_num, NULL, comment);",
          "1641:     g_free(comment);",
          "1642:    }",
          "1643:   }",
          "1646:   h225_frame_num = 0;",
          "1649:  } else if (h245_labels.frame_num == q931_frame_num) {",
          "1652:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1653:   while (list)",
          "1654:   {",
          "1655:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1656:    if (tmp_listinfo->protocol == VOIP_H323) {",
          "1657:     tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1658:     if ( ((tmp_h323info->q931_crv == q931_crv) || (tmp_h323info->q931_crv2 == q931_crv)) && (q931_crv!=-1)) {",
          "1660:      if (!append_to_frame_graph(tapinfo, q931_frame_num, NULL, NULL)) {",
          "1662:       add_to_graph(tapinfo, pinfo, edt, NULL, NULL, tmp_listinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "1663:       ++(tmp_listinfo->npackets);",
          "1665:       ++(tapinfo->npackets);",
          "1666:      }",
          "1669:      h245_add_to_graph(tapinfo, pinfo->fd->num);",
          "1670:      break;",
          "1671:     }",
          "1672:    }",
          "1673:    list = g_list_next (list);",
          "1674:   }",
          "1677:  } else {",
          "1678:   address pstn_add;",
          "1680:   comment = NULL;",
          "1681:   callsinfo = NULL;",
          "1682:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1683:   while (list)",
          "1684:   {",
          "1685:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1686:    if ( tmp_listinfo->protocol == VOIP_AC_ISDN ) {",
          "1687:     tmp_actrace_isdn_info = (actrace_isdn_calls_info_t *)tmp_listinfo->prot_info;",
          "1689:     if ( (tmp_actrace_isdn_info->crv == q931_crv) && (tmp_actrace_isdn_info->trunk == actrace_trunk) ) {",
          "1690:      callsinfo = (voip_calls_info_t*)(list->data);",
          "1691:      break;",
          "1692:     }",
          "1693:    }",
          "1694:    list = g_list_next (list);",
          "1695:   }",
          "1697:   SET_ADDRESS(&pstn_add, AT_STRINGZ, 5, g_strdup(\"PSTN\"));",
          "1700:   if (!callsinfo) {",
          "1701:    callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1702:    callsinfo->call_active_state = VOIP_ACTIVE;",
          "1703:    callsinfo->call_state = VOIP_CALL_SETUP;",
          "1704:    callsinfo->from_identity=g_strdup(q931_calling_number);",
          "1705:    callsinfo->to_identity=g_strdup(q931_called_number);",
          "1706:    COPY_ADDRESS(&(callsinfo->initial_speaker),actrace_direction?&pstn_add:&(pinfo->src));",
          "1707:    callsinfo->selected=FALSE;",
          "1708:    callsinfo->start_fd=pinfo->fd;",
          "1709:    callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1710:    callsinfo->protocol=VOIP_AC_ISDN;",
          "1711:    callsinfo->prot_info=g_malloc(sizeof(actrace_isdn_calls_info_t));",
          "1712:    callsinfo->free_prot_info = g_free;",
          "1713:    tmp_actrace_isdn_info=(actrace_isdn_calls_info_t *)callsinfo->prot_info;",
          "1714:    tmp_actrace_isdn_info->crv=q931_crv;",
          "1715:    tmp_actrace_isdn_info->trunk=actrace_trunk;",
          "1716:    callsinfo->npackets = 0;",
          "1717:    callsinfo->call_num = tapinfo->ncalls++;",
          "1718:    g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1719:   }",
          "1721:   callsinfo->stop_fd = pinfo->fd;",
          "1722:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1723:   ++(callsinfo->npackets);",
          "1725:   ++(tapinfo->npackets);",
          "1727:   switch(pi->message_type) {",
          "1728:   case Q931_SETUP:",
          "1729:    comment = g_strdup_printf(\"AC_ISDN trunk:%u Calling: %s  Called:%s\", actrace_trunk, q931_calling_number, q931_called_number);",
          "1730:    callsinfo->call_state=VOIP_CALL_SETUP;",
          "1731:    break;",
          "1732:   case Q931_CONNECT:",
          "1733:    callsinfo->call_state=VOIP_IN_CALL;",
          "1734:    break;",
          "1735:   case Q931_RELEASE_COMPLETE:",
          "1736:   case Q931_RELEASE:",
          "1737:   case Q931_DISCONNECT:",
          "1738:    if (callsinfo->call_state==VOIP_CALL_SETUP) {",
          "1740:      callsinfo->call_state=VOIP_CANCELLED;",
          "1741:     }",
          "1743:      callsinfo->call_state=VOIP_REJECTED;",
          "1744:      tapinfo->rejected_calls++;",
          "1745:     }",
          "1746:    } else if ( (callsinfo->call_state!=VOIP_CANCELLED) && (callsinfo->call_state!=VOIP_REJECTED) ) {",
          "1747:      callsinfo->call_state=VOIP_COMPLETED;",
          "1748:      tapinfo->completed_calls++;",
          "1749:    }",
          "1750:    if (q931_cause_value != 0xFF) {",
          "1751:     comment = g_strdup_printf(\"AC_ISDN trunk:%u Q931 Rel Cause (%i):%s\", actrace_trunk, q931_cause_value,",
          "1752:          val_to_str_ext_const(q931_cause_value, &q931_cause_code_vals_ext, \"<unknown>\"));",
          "1754:     comment = g_strdup(\"AC_ISDN No Q931 Rel Cause\");",
          "1755:    }",
          "1756:    break;",
          "1757:   }",
          "1759:   if (!comment)",
          "1760:    comment = g_strdup_printf(\"AC_ISDN  trunk:%u\", actrace_trunk );",
          "1762:   add_to_graph(tapinfo, pinfo, edt, val_to_str(pi->message_type, q931_message_type_vals, \"<unknown>\") , comment, callsinfo->call_num,",
          "1763:     actrace_direction?&pstn_add:&(pinfo->src),",
          "1764:     actrace_direction?&(pinfo->src):&pstn_add,",
          "1765:     1 );",
          "1767:   g_free(comment);",
          "1768:   g_free((char *)pstn_add.data);",
          "1769:  }",
          "1771:  tapinfo->redraw = TRUE;",
          "",
          "[Added Lines]",
          "1519:     GList *list,*list2;",
          "1520:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_q931_);",
          "1521:     h323_calls_info_t *tmp_h323info,*tmp2_h323info;",
          "1522:     actrace_isdn_calls_info_t *tmp_actrace_isdn_info;",
          "1523:     voip_calls_info_t *tmp_listinfo;",
          "1524:     voip_calls_info_t *callsinfo = NULL;",
          "1525:     h245_address_t *h245_add = NULL;",
          "1526:     gchar *comment;",
          "1528:     const q931_packet_info *pi = (const q931_packet_info *)q931_info;",
          "1531:     g_free(q931_calling_number);",
          "1532:     g_free(q931_called_number);",
          "1534:     if (pi->calling_number!=NULL)",
          "1535:         q931_calling_number = g_strdup(pi->calling_number);",
          "1536:     else",
          "1537:         q931_calling_number = g_strdup(\"\");",
          "1539:     if (pi->called_number!=NULL)",
          "1540:         q931_called_number = g_strdup(pi->called_number);",
          "1541:     else",
          "1542:         q931_called_number = g_strdup(\"\");",
          "1543:     q931_cause_value = pi->cause_value;",
          "1544:     q931_frame_num = pinfo->fd->num;",
          "1545:     q931_crv = pi->crv;",
          "1549:     if (h225_frame_num == q931_frame_num) {",
          "1550:         tmp_h323info = NULL;",
          "1551:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1552:         while (list)",
          "1553:         {",
          "1554:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1555:             if ( (tmp_listinfo->protocol == VOIP_H323) && (tmp_listinfo->call_num == h225_call_num) ) {",
          "1556:                 tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1557:                 callsinfo = (voip_calls_info_t*)(list->data);",
          "1560:                 if (tmp_h323info->q931_crv == -1) {",
          "1561:                     tmp_h323info->q931_crv = q931_crv;",
          "1562:                 } else if (tmp_h323info->q931_crv != q931_crv) {",
          "1563:                     tmp_h323info->q931_crv2 = q931_crv;",
          "1564:                 }",
          "1565:                 break;",
          "1566:             }",
          "1567:             list = g_list_next (list);",
          "1568:         }",
          "1570:         if (callsinfo != NULL) {",
          "1571:             comment = NULL;",
          "1572:             if (h225_cstype == H225_SETUP) {",
          "1574:                 if (q931_calling_number != NULL) {",
          "1575:                     g_free(callsinfo->from_identity);",
          "1576:                     callsinfo->from_identity=g_strdup(q931_calling_number);",
          "1577:                 }",
          "1578:                 if (q931_called_number != NULL) {",
          "1579:                     g_free(callsinfo->to_identity);",
          "1580:                     callsinfo->to_identity=g_strdup(q931_called_number);",
          "1581:                 }",
          "1585:                    we should also check if the h225 signaling IP and port match the destination",
          "1587:                 list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1588:                 while (list)",
          "1589:                 {",
          "1590:                     tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1591:                     if (tmp_listinfo->protocol == VOIP_H323) {",
          "1592:                         tmp2_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1595:                         if ( (strcmp(callsinfo->to_identity, tmp_listinfo->to_identity)==0)",
          "1596:                                 && (memcmp(&tmp2_h323info->guid, &guid_allzero, GUID_LEN) == 0) ) {",
          "1598:                             callsinfo->npackets += change_call_num_graph(tapinfo, tmp_listinfo->call_num, callsinfo->call_num);",
          "1601:                             g_free(tmp_listinfo->from_identity);",
          "1602:                             g_free(tmp_listinfo->to_identity);",
          "1603:                             DUMP_PTR2(tmp2_h323info->guid);",
          "1604:                             g_free(tmp2_h323info->guid);",
          "1606:                             list2 = g_list_first(tmp2_h323info->h245_list);",
          "1607:                             while (list2)",
          "1608:                             {",
          "1609:                                 h245_add=(h245_address_t *)list2->data;",
          "1610:                                 g_free((void *)h245_add->h245_address.data);",
          "1611:                                 g_free(list2->data);",
          "1612:                                 list2 = g_list_next(list2);",
          "1613:                             }",
          "1614:                             g_list_free(tmp_h323info->h245_list);",
          "1615:                             tmp_h323info->h245_list = NULL;",
          "1616:                             g_free(tmp_listinfo->prot_info);",
          "1617:                             g_queue_unlink(tapinfo->callsinfos, list);",
          "1618:                             break;",
          "1619:                         }",
          "1620:                     }",
          "1621:                     list = g_list_next (list);",
          "1622:                 }",
          "1624:                 comment = g_strdup_printf(\"H225 From: %s To:%s  TunnH245:%s FS:%s\", callsinfo->from_identity, callsinfo->to_identity, (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "1625:                         (h225_is_faststart==TRUE?\"on\":\"off\"));",
          "1626:             } else if (h225_cstype == H225_RELEASE_COMPLET) {",
          "1628:                 if (q931_cause_value != 0xFF) {",
          "1629:                     comment = g_strdup_printf(\"H225 Q931 Rel Cause (%i):%s\", q931_cause_value,",
          "1630:                             val_to_str_ext_const(q931_cause_value, &q931_cause_code_vals_ext, \"<unknown>\"));",
          "1632:                     comment = g_strdup(\"H225 No Q931 Rel Cause\");",
          "1633:                 }",
          "1634:             }",
          "1636:             if (comment != NULL) {",
          "1637:                 change_frame_graph(tapinfo, h225_frame_num, NULL, comment);",
          "1638:                 g_free(comment);",
          "1639:             }",
          "1640:         }",
          "1643:         h225_frame_num = 0;",
          "1646:     } else if (h245_labels.frame_num == q931_frame_num) {",
          "1649:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1650:         while (list)",
          "1651:         {",
          "1652:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1653:             if (tmp_listinfo->protocol == VOIP_H323) {",
          "1654:                 tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1655:                 if ( ((tmp_h323info->q931_crv == q931_crv) || (tmp_h323info->q931_crv2 == q931_crv)) && (q931_crv!=-1)) {",
          "1657:                     if (!append_to_frame_graph(tapinfo, q931_frame_num, NULL, NULL)) {",
          "1659:                         add_to_graph(tapinfo, pinfo, edt, NULL, NULL, tmp_listinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "1660:                         ++(tmp_listinfo->npackets);",
          "1662:                         ++(tapinfo->npackets);",
          "1663:                     }",
          "1666:                     h245_add_to_graph(tapinfo, pinfo->fd->num);",
          "1667:                     break;",
          "1668:                 }",
          "1669:             }",
          "1670:             list = g_list_next (list);",
          "1671:         }",
          "1674:     } else {",
          "1675:         address pstn_add;",
          "1677:         comment = NULL;",
          "1678:         callsinfo = NULL;",
          "1679:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1680:         while (list)",
          "1681:         {",
          "1682:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1683:             if ( tmp_listinfo->protocol == VOIP_AC_ISDN ) {",
          "1684:                 tmp_actrace_isdn_info = (actrace_isdn_calls_info_t *)tmp_listinfo->prot_info;",
          "1686:                 if ( (tmp_actrace_isdn_info->crv == q931_crv) && (tmp_actrace_isdn_info->trunk == actrace_trunk) ) {",
          "1687:                     callsinfo = (voip_calls_info_t*)(list->data);",
          "1688:                     break;",
          "1689:                 }",
          "1690:             }",
          "1691:             list = g_list_next (list);",
          "1692:         }",
          "1694:         SET_ADDRESS(&pstn_add, AT_STRINGZ, 5, g_strdup(\"PSTN\"));",
          "1697:         if (!callsinfo) {",
          "1698:             callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1699:             callsinfo->call_active_state = VOIP_ACTIVE;",
          "1700:             callsinfo->call_state = VOIP_CALL_SETUP;",
          "1701:             callsinfo->from_identity=g_strdup(q931_calling_number);",
          "1702:             callsinfo->to_identity=g_strdup(q931_called_number);",
          "1703:             COPY_ADDRESS(&(callsinfo->initial_speaker),actrace_direction?&pstn_add:&(pinfo->src));",
          "1704:             callsinfo->selected=FALSE;",
          "1705:             callsinfo->start_fd=pinfo->fd;",
          "1706:             callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1707:             callsinfo->protocol=VOIP_AC_ISDN;",
          "1708:             callsinfo->prot_info=g_malloc(sizeof(actrace_isdn_calls_info_t));",
          "1709:             callsinfo->free_prot_info = g_free;",
          "1710:             tmp_actrace_isdn_info=(actrace_isdn_calls_info_t *)callsinfo->prot_info;",
          "1711:             tmp_actrace_isdn_info->crv=q931_crv;",
          "1712:             tmp_actrace_isdn_info->trunk=actrace_trunk;",
          "1713:             callsinfo->npackets = 0;",
          "1714:             callsinfo->call_num = tapinfo->ncalls++;",
          "1715:             g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1716:         }",
          "1718:         callsinfo->stop_fd = pinfo->fd;",
          "1719:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1720:         ++(callsinfo->npackets);",
          "1722:         ++(tapinfo->npackets);",
          "1724:         switch(pi->message_type) {",
          "1725:             case Q931_SETUP:",
          "1726:                 comment = g_strdup_printf(\"AC_ISDN trunk:%u Calling: %s  Called:%s\", actrace_trunk, q931_calling_number, q931_called_number);",
          "1727:                 callsinfo->call_state=VOIP_CALL_SETUP;",
          "1728:                 break;",
          "1729:             case Q931_CONNECT:",
          "1730:                 callsinfo->call_state=VOIP_IN_CALL;",
          "1731:                 break;",
          "1732:             case Q931_RELEASE_COMPLETE:",
          "1733:             case Q931_RELEASE:",
          "1734:             case Q931_DISCONNECT:",
          "1735:                 if (callsinfo->call_state==VOIP_CALL_SETUP) {",
          "1737:                         callsinfo->call_state=VOIP_CANCELLED;",
          "1738:                     }",
          "1740:                         callsinfo->call_state=VOIP_REJECTED;",
          "1741:                         tapinfo->rejected_calls++;",
          "1742:                     }",
          "1743:                 } else if ( (callsinfo->call_state!=VOIP_CANCELLED) && (callsinfo->call_state!=VOIP_REJECTED) ) {",
          "1744:                     callsinfo->call_state=VOIP_COMPLETED;",
          "1745:                     tapinfo->completed_calls++;",
          "1746:                 }",
          "1747:                 if (q931_cause_value != 0xFF) {",
          "1748:                     comment = g_strdup_printf(\"AC_ISDN trunk:%u Q931 Rel Cause (%i):%s\", actrace_trunk, q931_cause_value,",
          "1749:                             val_to_str_ext_const(q931_cause_value, &q931_cause_code_vals_ext, \"<unknown>\"));",
          "1751:                     comment = g_strdup(\"AC_ISDN No Q931 Rel Cause\");",
          "1752:                 }",
          "1753:                 break;",
          "1754:         }",
          "1756:         if (!comment)",
          "1757:             comment = g_strdup_printf(\"AC_ISDN  trunk:%u\", actrace_trunk );",
          "1759:         add_to_graph(tapinfo, pinfo, edt, val_to_str(pi->message_type, q931_message_type_vals, \"<unknown>\") , comment, callsinfo->call_num,",
          "1760:                 actrace_direction?&pstn_add:&(pinfo->src),",
          "1761:                 actrace_direction?&(pinfo->src):&pstn_add,",
          "1762:                 1 );",
          "1764:         g_free(comment);",
          "1765:         g_free((char *)pstn_add.data);",
          "1766:     }",
          "1768:     tapinfo->redraw = TRUE;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1778: void",
          "1779: q931_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "1780: {",
          "1796: }",
          "",
          "[Removed Lines]",
          "1781:  GString *error_string;",
          "1783:  error_string = register_tap_listener(\"q931\", tap_base_to_id(tap_id_base, tap_id_offset_q931_),",
          "1784:   NULL,",
          "1785:   0,",
          "1786:   voip_calls_dlg_reset,",
          "1787:   q931_calls_packet,",
          "1788:   voip_calls_dlg_draw",
          "1789:   );",
          "1791:  if (error_string != NULL) {",
          "1792:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1793:          \"%s\", error_string->str);",
          "1794:   g_string_free(error_string, TRUE);",
          "1795:  }",
          "",
          "[Added Lines]",
          "1778:     GString *error_string;",
          "1780:     error_string = register_tap_listener(\"q931\", tap_base_to_id(tap_id_base, tap_id_offset_q931_),",
          "1781:             NULL,",
          "1782:             0,",
          "1783:             voip_calls_dlg_reset,",
          "1784:             q931_calls_packet,",
          "1785:             voip_calls_dlg_draw",
          "1786:             );",
          "1788:     if (error_string != NULL) {",
          "1789:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "1790:                 \"%s\", error_string->str);",
          "1791:         g_string_free(error_string, TRUE);",
          "1792:     }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1800: void",
          "1801: remove_tap_listener_q931_calls(voip_calls_tapinfo_t *tap_id_base)",
          "1802: {",
          "1804: }",
          "",
          "[Removed Lines]",
          "1803:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_q931_));",
          "",
          "[Added Lines]",
          "1800:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_q931_));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1810: static void add_h245_Address(h323_calls_info_t *h323info,  h245_address_t *h245_address)",
          "1811: {",
          "1813: }",
          "1816: static void free_h225_info(gpointer p) {",
          "1837: }",
          "1840: static int",
          "1841: h225_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *H225info)",
          "1842: {",
          "2055: }",
          "",
          "[Removed Lines]",
          "1812:  h323info->h245_list = g_list_prepend(h323info->h245_list, h245_address);",
          "1817:  h323_calls_info_t *tmp_h323info = (h323_calls_info_t *)p;",
          "1819:  DUMP_PTR2(tmp_h323info->guid);",
          "1820:  g_free(tmp_h323info->guid);",
          "1822:  if (tmp_h323info->h245_list) {",
          "1823:   GList *list2 = g_list_first(tmp_h323info->h245_list);",
          "1824:   while (list2)",
          "1825:   {",
          "1826:    h245_address_t *h245_add=(h245_address_t *)list2->data;",
          "1827:    g_free((void *)h245_add->h245_address.data);",
          "1828:    g_free(list2->data);",
          "1829:    list2 = g_list_next(list2);",
          "1830:   }",
          "1832:   g_list_free(tmp_h323info->h245_list);",
          "1834:  }",
          "1836:  g_free(p);",
          "1843:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h225_);",
          "1844:  voip_calls_info_t *tmp_listinfo;",
          "1845:  voip_calls_info_t *callsinfo = NULL;",
          "1846:  h323_calls_info_t *tmp_h323info = NULL;",
          "1847:  gchar *frame_label;",
          "1848:  gchar *comment;",
          "1849:  GList *list;",
          "1850:  h245_address_t *h245_add = NULL;",
          "1852:  const h225_packet_info *pi = (const h225_packet_info *)H225info;",
          "1856:  if ((memcmp(&pi->guid, &guid_allzero, GUID_LEN) == 0))",
          "1857:   if ( ((pi->msg_type == H225_RAS) && ((pi->msg_tag < 18) || (pi->msg_tag > 20))) || (pi->msg_type != H225_RAS) )",
          "1858:    return 0;",
          "1861:  if ( (pi->msg_type == H225_RAS) && ((pi->msg_tag == 19) || (pi->msg_tag == 20))) {",
          "1863:   if (!pi->request_available) return 0;",
          "1866:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1867:   while (list)",
          "1868:   {",
          "1869:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1870:    g_assert(tmp_listinfo != NULL);",
          "1871:    if (tmp_listinfo->protocol == VOIP_H323) {",
          "1872:     tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1873:     if (tmp_h323info->requestSeqNum == pi->requestSeqNum) {",
          "1874:      callsinfo = (voip_calls_info_t*)(list->data);",
          "1875:      break;",
          "1876:     }",
          "1877:    }",
          "1878:    list = g_list_next (list);",
          "1879:   }",
          "1880:  } else {",
          "1882:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1883:   while (list)",
          "1884:   {",
          "1885:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1886:    if (tmp_listinfo->protocol == VOIP_H323) {",
          "1887:     tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1888:     g_assert(tmp_h323info != NULL);",
          "1889:     if ( (memcmp(tmp_h323info->guid, &guid_allzero, GUID_LEN) != 0) && (memcmp(tmp_h323info->guid, &pi->guid,GUID_LEN)==0) ) {",
          "1890:      callsinfo = (voip_calls_info_t*)(list->data);",
          "1891:      break;",
          "1892:     }",
          "1893:    }",
          "1894:    list = g_list_next (list);",
          "1895:   }",
          "1896:  }",
          "1898:  h225_cstype = pi->cs_type;",
          "1899:  h225_is_faststart = pi->is_faststart;",
          "1902:  if (callsinfo==NULL) {",
          "1903:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1904:   callsinfo->call_active_state = VOIP_ACTIVE;",
          "1905:   callsinfo->call_state = VOIP_UNKNOWN;",
          "1906:   callsinfo->from_identity=g_strdup(\"\");",
          "1907:   callsinfo->to_identity=g_strdup(\"\");",
          "1908:   COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "1909:   callsinfo->selected=FALSE;",
          "1910:   callsinfo->start_fd=pinfo->fd;",
          "1911:   callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1912:   callsinfo->protocol=VOIP_H323;",
          "1913:   callsinfo->prot_info=g_malloc(sizeof(h323_calls_info_t));",
          "1914:   callsinfo->free_prot_info = free_h225_info;",
          "1916:   tmp_h323info = (h323_calls_info_t *)callsinfo->prot_info;",
          "1917:   g_assert(tmp_h323info != NULL);",
          "1918:   tmp_h323info->guid = (e_guid_t *)g_memdup(&pi->guid, sizeof pi->guid);",
          "1919:   DUMP_PTR1(tmp_h323info->guid);",
          "1921:   tmp_h323info->h225SetupAddr.type = AT_NONE;",
          "1922:   tmp_h323info->h225SetupAddr.len = 0;",
          "1923:   tmp_h323info->h245_list = NULL;",
          "1924:   tmp_h323info->is_faststart_Setup = FALSE;",
          "1925:   tmp_h323info->is_faststart_Proc = FALSE;",
          "1926:   tmp_h323info->is_h245Tunneling = FALSE;",
          "1927:   tmp_h323info->is_h245 = FALSE;",
          "1928:   tmp_h323info->q931_crv = -1;",
          "1929:   tmp_h323info->q931_crv2 = -1;",
          "1930:   tmp_h323info->requestSeqNum = 0;",
          "1931:   callsinfo->call_num = tapinfo->ncalls++;",
          "1932:   callsinfo->npackets = 0;",
          "1934:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1935:  }",
          "1937:  h225_frame_num = pinfo->fd->num;",
          "1938:  h225_call_num = callsinfo->call_num;",
          "1942:  callsinfo->stop_fd = pinfo->fd;",
          "1943:  callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1944:  ++(callsinfo->npackets);",
          "1946:  ++(tapinfo->npackets);",
          "1950:  g_assert(tmp_h323info != NULL);",
          "1953:  if (pi->msg_type == H225_CS) {",
          "1956:   if (pi->is_h245 == TRUE) {",
          "1957:    h245_add = (h245_address_t *)g_malloc(sizeof (h245_address_t));",
          "1958:    h245_add->h245_address.type=AT_IPv4;",
          "1959:    h245_add->h245_address.len=4;",
          "1960:    h245_add->h245_address.data = g_malloc(sizeof(pi->h245_address));",
          "1961:    memcpy((void *)(h245_add->h245_address.data), &(pi->h245_address), 4);",
          "1962:    h245_add->h245_port = pi->h245_port;",
          "1963:    add_h245_Address(tmp_h323info, h245_add);",
          "1964:   }",
          "1966:   if (pi->cs_type != H225_RELEASE_COMPLET) tmp_h323info->is_h245Tunneling = pi->is_h245Tunneling;",
          "1968:   frame_label = g_strdup(pi->frame_label);",
          "1970:   switch(pi->cs_type) {",
          "1971:   case H225_SETUP:",
          "1972:    tmp_h323info->is_faststart_Setup = pi->is_faststart;",
          "1975:    if (tmp_h323info->h225SetupAddr.type == AT_NONE)",
          "1976:     COPY_ADDRESS(&(tmp_h323info->h225SetupAddr), &(pinfo->src));",
          "1977:    callsinfo->call_state=VOIP_CALL_SETUP;",
          "1978:    comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "1979:            (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "1980:    break;",
          "1981:   case H225_CONNECT:",
          "1982:    callsinfo->call_state=VOIP_IN_CALL;",
          "1983:    if (pi->is_faststart == TRUE) tmp_h323info->is_faststart_Proc = TRUE;",
          "1984:     comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "1985:             (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "1986:    break;",
          "1987:   case H225_RELEASE_COMPLET:",
          "1988:    if (callsinfo->call_state==VOIP_CALL_SETUP) {",
          "1990:      callsinfo->call_state=VOIP_CANCELLED;",
          "1991:     }",
          "1993:      callsinfo->call_state=VOIP_REJECTED;",
          "1994:      tapinfo->rejected_calls++;",
          "1995:     }",
          "1996:    } else {",
          "1997:      callsinfo->call_state=VOIP_COMPLETED;",
          "1998:      tapinfo->completed_calls++;",
          "1999:    }",
          "2000:    comment = g_strdup(\"H225 No Q931 Rel Cause\");",
          "2001:    break;",
          "2002:   case H225_PROGRESS:",
          "2003:   case H225_ALERTING:",
          "2004:   case H225_CALL_PROCEDING:",
          "2005:    if (pi->is_faststart == TRUE) tmp_h323info->is_faststart_Proc = TRUE;",
          "2006:    comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "2007:            (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "2008:    break;",
          "2009:   default:",
          "2010:    comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "2011:            (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "2013:   }",
          "2014:  }",
          "2015:  else if (pi->msg_type == H225_RAS) {",
          "2016:   switch(pi->msg_tag) {",
          "2018:    if (!pi->is_duplicate) {",
          "2019:     g_free(callsinfo->to_identity);",
          "2020:     callsinfo->to_identity=g_strdup(pi->dialedDigits);",
          "2021:     tmp_h323info->requestSeqNum = pi->requestSeqNum;",
          "2022:    }",
          "2024:    if (strlen(pi->dialedDigits))",
          "2025:     comment = g_strdup_printf(\"H225 RAS dialedDigits: %s\", pi->dialedDigits);",
          "2026:    else",
          "2027:     comment = g_strdup(\"H225 RAS\");",
          "2028:    break;",
          "2029:   default:",
          "2030:    comment = g_strdup(\"H225 RAS\");",
          "2031:   }",
          "2032:   frame_label = g_strdup(val_to_str_const(pi->msg_tag, h225_RasMessage_vals, \"<unknown>\"));",
          "2033:  } else {",
          "2034:   frame_label = g_strdup(\"H225: Unknown\");",
          "2035:   comment = NULL;",
          "2036:  }",
          "2041:  if (!append_to_frame_graph(tapinfo, pinfo->fd->num, pi->frame_label, comment)) {",
          "2043:   add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2044:  }",
          "2047:  h245_add_to_graph(tapinfo, pinfo->fd->num);",
          "2049:  g_free(frame_label);",
          "2050:  g_free(comment);",
          "2052:  tapinfo->redraw = TRUE;",
          "",
          "[Added Lines]",
          "1809:     h323info->h245_list = g_list_prepend(h323info->h245_list, h245_address);",
          "1814:     h323_calls_info_t *tmp_h323info = (h323_calls_info_t *)p;",
          "1816:     DUMP_PTR2(tmp_h323info->guid);",
          "1817:     g_free(tmp_h323info->guid);",
          "1819:     if (tmp_h323info->h245_list) {",
          "1820:         GList *list2 = g_list_first(tmp_h323info->h245_list);",
          "1821:         while (list2)",
          "1822:         {",
          "1823:             h245_address_t *h245_add=(h245_address_t *)list2->data;",
          "1824:             g_free((void *)h245_add->h245_address.data);",
          "1825:             g_free(list2->data);",
          "1826:             list2 = g_list_next(list2);",
          "1827:         }",
          "1829:         g_list_free(tmp_h323info->h245_list);",
          "1831:     }",
          "1833:     g_free(p);",
          "1840:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h225_);",
          "1841:     voip_calls_info_t *tmp_listinfo;",
          "1842:     voip_calls_info_t *callsinfo = NULL;",
          "1843:     h323_calls_info_t *tmp_h323info = NULL;",
          "1844:     gchar *frame_label;",
          "1845:     gchar *comment;",
          "1846:     GList *list;",
          "1847:     h245_address_t *h245_add = NULL;",
          "1849:     const h225_packet_info *pi = (const h225_packet_info *)H225info;",
          "1853:     if ((memcmp(&pi->guid, &guid_allzero, GUID_LEN) == 0))",
          "1854:         if ( ((pi->msg_type == H225_RAS) && ((pi->msg_tag < 18) || (pi->msg_tag > 20))) || (pi->msg_type != H225_RAS) )",
          "1855:             return 0;",
          "1858:     if ( (pi->msg_type == H225_RAS) && ((pi->msg_tag == 19) || (pi->msg_tag == 20))) {",
          "1860:         if (!pi->request_available) return 0;",
          "1863:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1864:         while (list)",
          "1865:         {",
          "1866:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1867:             g_assert(tmp_listinfo != NULL);",
          "1868:             if (tmp_listinfo->protocol == VOIP_H323) {",
          "1869:                 tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1870:                 if (tmp_h323info->requestSeqNum == pi->requestSeqNum) {",
          "1871:                     callsinfo = (voip_calls_info_t*)(list->data);",
          "1872:                     break;",
          "1873:                 }",
          "1874:             }",
          "1875:             list = g_list_next (list);",
          "1876:         }",
          "1877:     } else {",
          "1879:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "1880:         while (list)",
          "1881:         {",
          "1882:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "1883:             if (tmp_listinfo->protocol == VOIP_H323) {",
          "1884:                 tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "1885:                 g_assert(tmp_h323info != NULL);",
          "1886:                 if ( (memcmp(tmp_h323info->guid, &guid_allzero, GUID_LEN) != 0) && (memcmp(tmp_h323info->guid, &pi->guid,GUID_LEN)==0) ) {",
          "1887:                     callsinfo = (voip_calls_info_t*)(list->data);",
          "1888:                     break;",
          "1889:                 }",
          "1890:             }",
          "1891:             list = g_list_next (list);",
          "1892:         }",
          "1893:     }",
          "1895:     h225_cstype = pi->cs_type;",
          "1896:     h225_is_faststart = pi->is_faststart;",
          "1899:     if (callsinfo==NULL) {",
          "1900:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "1901:         callsinfo->call_active_state = VOIP_ACTIVE;",
          "1902:         callsinfo->call_state = VOIP_UNKNOWN;",
          "1903:         callsinfo->from_identity=g_strdup(\"\");",
          "1904:         callsinfo->to_identity=g_strdup(\"\");",
          "1905:         COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "1906:         callsinfo->selected=FALSE;",
          "1907:         callsinfo->start_fd=pinfo->fd;",
          "1908:         callsinfo->start_rel_ts=pinfo->rel_ts;",
          "1909:         callsinfo->protocol=VOIP_H323;",
          "1910:         callsinfo->prot_info=g_malloc(sizeof(h323_calls_info_t));",
          "1911:         callsinfo->free_prot_info = free_h225_info;",
          "1913:         tmp_h323info = (h323_calls_info_t *)callsinfo->prot_info;",
          "1914:         g_assert(tmp_h323info != NULL);",
          "1915:         tmp_h323info->guid = (e_guid_t *)g_memdup(&pi->guid, sizeof pi->guid);",
          "1916:         DUMP_PTR1(tmp_h323info->guid);",
          "1918:         tmp_h323info->h225SetupAddr.type = AT_NONE;",
          "1919:         tmp_h323info->h225SetupAddr.len = 0;",
          "1920:         tmp_h323info->h245_list = NULL;",
          "1921:         tmp_h323info->is_faststart_Setup = FALSE;",
          "1922:         tmp_h323info->is_faststart_Proc = FALSE;",
          "1923:         tmp_h323info->is_h245Tunneling = FALSE;",
          "1924:         tmp_h323info->is_h245 = FALSE;",
          "1925:         tmp_h323info->q931_crv = -1;",
          "1926:         tmp_h323info->q931_crv2 = -1;",
          "1927:         tmp_h323info->requestSeqNum = 0;",
          "1928:         callsinfo->call_num = tapinfo->ncalls++;",
          "1929:         callsinfo->npackets = 0;",
          "1931:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "1932:     }",
          "1934:     h225_frame_num = pinfo->fd->num;",
          "1935:     h225_call_num = callsinfo->call_num;",
          "1939:     callsinfo->stop_fd = pinfo->fd;",
          "1940:     callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "1941:     ++(callsinfo->npackets);",
          "1943:     ++(tapinfo->npackets);",
          "1947:     g_assert(tmp_h323info != NULL);",
          "1950:     if (pi->msg_type == H225_CS) {",
          "1953:         if (pi->is_h245 == TRUE) {",
          "1954:             h245_add = (h245_address_t *)g_malloc(sizeof (h245_address_t));",
          "1955:             h245_add->h245_address.type=AT_IPv4;",
          "1956:             h245_add->h245_address.len=4;",
          "1957:             h245_add->h245_address.data = g_malloc(sizeof(pi->h245_address));",
          "1958:             memcpy((void *)(h245_add->h245_address.data), &(pi->h245_address), 4);",
          "1959:             h245_add->h245_port = pi->h245_port;",
          "1960:             add_h245_Address(tmp_h323info, h245_add);",
          "1961:         }",
          "1963:         if (pi->cs_type != H225_RELEASE_COMPLET) tmp_h323info->is_h245Tunneling = pi->is_h245Tunneling;",
          "1965:         frame_label = g_strdup(pi->frame_label);",
          "1967:         switch(pi->cs_type) {",
          "1968:             case H225_SETUP:",
          "1969:                 tmp_h323info->is_faststart_Setup = pi->is_faststart;",
          "1972:                 if (tmp_h323info->h225SetupAddr.type == AT_NONE)",
          "1973:                     COPY_ADDRESS(&(tmp_h323info->h225SetupAddr), &(pinfo->src));",
          "1974:                 callsinfo->call_state=VOIP_CALL_SETUP;",
          "1975:                 comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "1976:                         (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "1977:                 break;",
          "1978:             case H225_CONNECT:",
          "1979:                 callsinfo->call_state=VOIP_IN_CALL;",
          "1980:                 if (pi->is_faststart == TRUE) tmp_h323info->is_faststart_Proc = TRUE;",
          "1981:                 comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "1982:                         (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "1983:                 break;",
          "1984:             case H225_RELEASE_COMPLET:",
          "1985:                 if (callsinfo->call_state==VOIP_CALL_SETUP) {",
          "1987:                         callsinfo->call_state=VOIP_CANCELLED;",
          "1988:                     }",
          "1990:                         callsinfo->call_state=VOIP_REJECTED;",
          "1991:                         tapinfo->rejected_calls++;",
          "1992:                     }",
          "1993:                 } else {",
          "1994:                     callsinfo->call_state=VOIP_COMPLETED;",
          "1995:                     tapinfo->completed_calls++;",
          "1996:                 }",
          "1997:                 comment = g_strdup(\"H225 No Q931 Rel Cause\");",
          "1998:                 break;",
          "1999:             case H225_PROGRESS:",
          "2000:             case H225_ALERTING:",
          "2001:             case H225_CALL_PROCEDING:",
          "2002:                 if (pi->is_faststart == TRUE) tmp_h323info->is_faststart_Proc = TRUE;",
          "2003:                 comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "2004:                         (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "2005:                 break;",
          "2006:             default:",
          "2007:                 comment = g_strdup_printf(\"H225 TunnH245:%s FS:%s\", (tmp_h323info->is_h245Tunneling==TRUE?\"on\":\"off\"),",
          "2008:                         (pi->is_faststart==TRUE?\"on\":\"off\"));",
          "2010:         }",
          "2011:     }",
          "2012:     else if (pi->msg_type == H225_RAS) {",
          "2013:         switch(pi->msg_tag) {",
          "2015:                 if (!pi->is_duplicate) {",
          "2016:                     g_free(callsinfo->to_identity);",
          "2017:                     callsinfo->to_identity=g_strdup(pi->dialedDigits);",
          "2018:                     tmp_h323info->requestSeqNum = pi->requestSeqNum;",
          "2019:                 }",
          "2021:                 if (strlen(pi->dialedDigits))",
          "2022:                     comment = g_strdup_printf(\"H225 RAS dialedDigits: %s\", pi->dialedDigits);",
          "2023:                 else",
          "2024:                     comment = g_strdup(\"H225 RAS\");",
          "2025:                 break;",
          "2026:             default:",
          "2027:                 comment = g_strdup(\"H225 RAS\");",
          "2028:         }",
          "2029:         frame_label = g_strdup(val_to_str_const(pi->msg_tag, h225_RasMessage_vals, \"<unknown>\"));",
          "2030:     } else {",
          "2031:         frame_label = g_strdup(\"H225: Unknown\");",
          "2032:         comment = NULL;",
          "2033:     }",
          "2038:     if (!append_to_frame_graph(tapinfo, pinfo->fd->num, pi->frame_label, comment)) {",
          "2040:         add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2041:     }",
          "2044:     h245_add_to_graph(tapinfo, pinfo->fd->num);",
          "2046:     g_free(frame_label);",
          "2047:     g_free(comment);",
          "2049:     tapinfo->redraw = TRUE;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2061: void",
          "2062: h225_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "2063: {",
          "2078: }",
          "2081: void",
          "2082: remove_tap_listener_h225_calls(voip_calls_tapinfo_t *tap_id_base)",
          "2083: {",
          "2085: }",
          "2088: void",
          "2089: h245_add_to_graph(voip_calls_tapinfo_t *tapinfo, guint32 new_frame_num)",
          "2090: {",
          "2104: }",
          "2107: static void h245_free_labels(guint32 new_frame_num)",
          "2108: {",
          "2121: }",
          "2124: static void h245_add_label(guint32 new_frame_num, const gchar *frame_label, const gchar *comment)",
          "2125: {",
          "2135: }",
          "",
          "[Removed Lines]",
          "2064:  GString *error_string;",
          "2066:  error_string = register_tap_listener(\"h225\", tap_base_to_id(tap_id_base, tap_id_offset_h225_), NULL,",
          "2067:   0,",
          "2068:   voip_calls_dlg_reset,",
          "2069:         h225_calls_packet,",
          "2070:   voip_calls_dlg_draw",
          "2071:   );",
          "2073:  if (error_string != NULL) {",
          "2074:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2075:          \"%s\", error_string->str);",
          "2076:   g_string_free(error_string, TRUE);",
          "2077:  }",
          "2084:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_h225_));",
          "2091:  gint8 n;",
          "2093:  if (new_frame_num != h245_labels.frame_num) return;",
          "2095:  for (n=0; n<h245_labels.labels_count; n++) {",
          "2096:   append_to_frame_graph(tapinfo, new_frame_num, h245_labels.labels[n].frame_label, h245_labels.labels[n].comment);",
          "2097:   g_free(h245_labels.labels[n].frame_label);",
          "2098:   h245_labels.labels[n].frame_label = NULL;",
          "2099:   g_free(h245_labels.labels[n].comment);",
          "2100:   h245_labels.labels[n].comment = NULL;",
          "2101:  }",
          "2102:  h245_labels.frame_num = 0;",
          "2103:  h245_labels.labels_count = 0;",
          "2109:  gint8 n;",
          "2111:  if (new_frame_num == h245_labels.frame_num) return;",
          "2113:  for (n=0; n<h245_labels.labels_count; n++) {",
          "2114:   g_free(h245_labels.labels[n].frame_label);",
          "2115:   h245_labels.labels[n].frame_label = NULL;",
          "2116:   g_free(h245_labels.labels[n].comment);",
          "2117:   h245_labels.labels[n].comment = NULL;",
          "2118:  }",
          "2119:  h245_labels.frame_num = 0;",
          "2120:  h245_labels.labels_count = 0;",
          "2126:  h245_free_labels(new_frame_num);",
          "2128:  h245_labels.frame_num = new_frame_num;",
          "2129:  h245_labels.labels[h245_labels.labels_count].frame_label = g_strdup(frame_label);",
          "2130:  h245_labels.labels[h245_labels.labels_count].comment = g_strdup(comment);",
          "2132:  if (h245_labels.labels_count < (H245_MAX-1))",
          "2133:   h245_labels.labels_count++;",
          "",
          "[Added Lines]",
          "2061:     GString *error_string;",
          "2063:     error_string = register_tap_listener(\"h225\", tap_base_to_id(tap_id_base, tap_id_offset_h225_), NULL,",
          "2064:             0,",
          "2065:             voip_calls_dlg_reset,",
          "2066:             h225_calls_packet,",
          "2067:             voip_calls_dlg_draw",
          "2068:             );",
          "2070:     if (error_string != NULL) {",
          "2071:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2072:                 \"%s\", error_string->str);",
          "2073:         g_string_free(error_string, TRUE);",
          "2074:     }",
          "2081:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_h225_));",
          "2088:     gint8 n;",
          "2090:     if (new_frame_num != h245_labels.frame_num) return;",
          "2092:     for (n=0; n<h245_labels.labels_count; n++) {",
          "2093:         append_to_frame_graph(tapinfo, new_frame_num, h245_labels.labels[n].frame_label, h245_labels.labels[n].comment);",
          "2094:         g_free(h245_labels.labels[n].frame_label);",
          "2095:         h245_labels.labels[n].frame_label = NULL;",
          "2096:         g_free(h245_labels.labels[n].comment);",
          "2097:         h245_labels.labels[n].comment = NULL;",
          "2098:     }",
          "2099:     h245_labels.frame_num = 0;",
          "2100:     h245_labels.labels_count = 0;",
          "2106:     gint8 n;",
          "2108:     if (new_frame_num == h245_labels.frame_num) return;",
          "2110:     for (n=0; n<h245_labels.labels_count; n++) {",
          "2111:         g_free(h245_labels.labels[n].frame_label);",
          "2112:         h245_labels.labels[n].frame_label = NULL;",
          "2113:         g_free(h245_labels.labels[n].comment);",
          "2114:         h245_labels.labels[n].comment = NULL;",
          "2115:     }",
          "2116:     h245_labels.frame_num = 0;",
          "2117:     h245_labels.labels_count = 0;",
          "2123:     h245_free_labels(new_frame_num);",
          "2125:     h245_labels.frame_num = new_frame_num;",
          "2126:     h245_labels.labels[h245_labels.labels_count].frame_label = g_strdup(frame_label);",
          "2127:     h245_labels.labels[h245_labels.labels_count].comment = g_strdup(comment);",
          "2129:     if (h245_labels.labels_count < (H245_MAX-1))",
          "2130:         h245_labels.labels_count++;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2139: static int",
          "2140: h245dg_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *H245info)",
          "2141: {",
          "2202: }",
          "",
          "[Removed Lines]",
          "2142:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h245dg_);",
          "2143:  voip_calls_info_t *tmp_listinfo;",
          "2144:  voip_calls_info_t *callsinfo = NULL;",
          "2145:  h323_calls_info_t *tmp_h323info;",
          "2146:  GList *list;",
          "2147:  GList *list2;",
          "2148:  h245_address_t *h245_add = NULL;",
          "2150:  const h245_packet_info *pi = (const h245_packet_info *)H245info;",
          "2153:  list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2154:  while (list)",
          "2155:  {",
          "2156:   tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2157:   if (tmp_listinfo->protocol == VOIP_H323) {",
          "2158:    tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "2160:    list2 = g_list_first(tmp_h323info->h245_list);",
          "2161:    while (list2)",
          "2162:    {",
          "2163:     h245_add=(h245_address_t *)list2->data;",
          "2164:     if ( (ADDRESSES_EQUAL(&(h245_add->h245_address),&(pinfo->src)) && (h245_add->h245_port == pinfo->srcport))",
          "2165:      || (ADDRESSES_EQUAL(&(h245_add->h245_address),&(pinfo->dst)) && (h245_add->h245_port == pinfo->destport)) ) {",
          "2166:      callsinfo = (voip_calls_info_t*)(list->data);",
          "2168:      ++(callsinfo->npackets);",
          "2170:      ++(tapinfo->npackets);",
          "2172:      break;",
          "2173:     }",
          "2174:     list2 = g_list_next(list2);",
          "2175:    }",
          "2176:    if (callsinfo!=NULL) break;",
          "2177:   }",
          "2178:   list = g_list_next(list);",
          "2179:  }",
          "2182:  if (callsinfo!=NULL) {",
          "2183:   ++(callsinfo->npackets);",
          "2185:   ++(tapinfo->npackets);",
          "2187:   if (!append_to_frame_graph(tapinfo, pinfo->fd->num, pi->frame_label, pi->comment)) {",
          "2189:    add_to_graph(tapinfo, pinfo, edt, pi->frame_label, pi->comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2190:   }",
          "2191:  } else {",
          "2193:    tunnel OFF but we did not matched the h245 add, in this case nobady will set this label",
          "2196:   h245_add_label(pinfo->fd->num, (gchar *) pi->frame_label, (gchar *) pi->comment);",
          "2197:  }",
          "2199:  tapinfo->redraw = TRUE;",
          "",
          "[Added Lines]",
          "2139:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h245dg_);",
          "2140:     voip_calls_info_t *tmp_listinfo;",
          "2141:     voip_calls_info_t *callsinfo = NULL;",
          "2142:     h323_calls_info_t *tmp_h323info;",
          "2143:     GList *list;",
          "2144:     GList *list2;",
          "2145:     h245_address_t *h245_add = NULL;",
          "2147:     const h245_packet_info *pi = (const h245_packet_info *)H245info;",
          "2150:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2151:     while (list)",
          "2152:     {",
          "2153:         tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2154:         if (tmp_listinfo->protocol == VOIP_H323) {",
          "2155:             tmp_h323info = (h323_calls_info_t *)tmp_listinfo->prot_info;",
          "2157:             list2 = g_list_first(tmp_h323info->h245_list);",
          "2158:             while (list2)",
          "2159:             {",
          "2160:                 h245_add=(h245_address_t *)list2->data;",
          "2161:                 if ( (ADDRESSES_EQUAL(&(h245_add->h245_address),&(pinfo->src)) && (h245_add->h245_port == pinfo->srcport))",
          "2162:                         || (ADDRESSES_EQUAL(&(h245_add->h245_address),&(pinfo->dst)) && (h245_add->h245_port == pinfo->destport)) ) {",
          "2163:                     callsinfo = (voip_calls_info_t*)(list->data);",
          "2165:                     ++(callsinfo->npackets);",
          "2167:                     ++(tapinfo->npackets);",
          "2169:                     break;",
          "2170:                 }",
          "2171:                 list2 = g_list_next(list2);",
          "2172:             }",
          "2173:             if (callsinfo!=NULL) break;",
          "2174:         }",
          "2175:         list = g_list_next(list);",
          "2176:     }",
          "2179:     if (callsinfo!=NULL) {",
          "2180:         ++(callsinfo->npackets);",
          "2182:         ++(tapinfo->npackets);",
          "2184:         if (!append_to_frame_graph(tapinfo, pinfo->fd->num, pi->frame_label, pi->comment)) {",
          "2186:             add_to_graph(tapinfo, pinfo, edt, pi->frame_label, pi->comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2187:         }",
          "2188:     } else {",
          "2190:            tunnel OFF but we did not matched the h245 add, in this case nobady will set this label",
          "2193:         h245_add_label(pinfo->fd->num, (gchar *) pi->frame_label, (gchar *) pi->comment);",
          "2194:     }",
          "2196:     tapinfo->redraw = TRUE;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2208: void",
          "2209: h245dg_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "2210: {",
          "2225: }",
          "2228: void",
          "2229: remove_tap_listener_h245dg_calls(voip_calls_tapinfo_t *tap_id_base)",
          "2230: {",
          "2232: }",
          "",
          "[Removed Lines]",
          "2211:  GString *error_string;",
          "2213:  error_string = register_tap_listener(\"h245dg\", tap_base_to_id(tap_id_base, tap_id_offset_h245dg_), NULL,",
          "2214:   0,",
          "2215:   voip_calls_dlg_reset,",
          "2216:         h245dg_calls_packet,",
          "2217:   voip_calls_dlg_draw",
          "2218:   );",
          "2220:  if (error_string != NULL) {",
          "2221:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2222:          \"%s\", error_string->str);",
          "2223:   g_string_free(error_string, TRUE);",
          "2224:  }",
          "2231:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_h245dg_));",
          "",
          "[Added Lines]",
          "2208:     GString *error_string;",
          "2210:     error_string = register_tap_listener(\"h245dg\", tap_base_to_id(tap_id_base, tap_id_offset_h245dg_), NULL,",
          "2211:             0,",
          "2212:             voip_calls_dlg_reset,",
          "2213:             h245dg_calls_packet,",
          "2214:             voip_calls_dlg_draw",
          "2215:             );",
          "2217:     if (error_string != NULL) {",
          "2218:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2219:                 \"%s\", error_string->str);",
          "2220:         g_string_free(error_string, TRUE);",
          "2221:     }",
          "2228:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_h245dg_));",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2238: static int",
          "2239: sdp_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *SDPinfo)",
          "2240: {",
          "2257: }",
          "",
          "[Removed Lines]",
          "2241:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sdp_);",
          "2242:  const sdp_packet_info *pi = (const sdp_packet_info *)SDPinfo;",
          "2245:     MGCP/SIP packet, in those cases we assign the SPD summary to global lastSDPsummary",
          "2246:     to use it later",
          "2248:  g_free(sdp_summary);",
          "2249:  sdp_frame_num = pinfo->fd->num;",
          "2251:  sdp_summary = g_strdup_printf(\"SDP (%s)\", pi->summary_str);",
          "2252:  append_to_frame_graph(tapinfo, pinfo->fd->num, sdp_summary, NULL);",
          "2254:  tapinfo->redraw = TRUE;",
          "",
          "[Added Lines]",
          "2238:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sdp_);",
          "2239:     const sdp_packet_info *pi = (const sdp_packet_info *)SDPinfo;",
          "2242:        MGCP/SIP packet, in those cases we assign the SPD summary to global lastSDPsummary",
          "2243:        to use it later",
          "2245:     g_free(sdp_summary);",
          "2246:     sdp_frame_num = pinfo->fd->num;",
          "2248:     sdp_summary = g_strdup_printf(\"SDP (%s)\", pi->summary_str);",
          "2249:     append_to_frame_graph(tapinfo, pinfo->fd->num, sdp_summary, NULL);",
          "2251:     tapinfo->redraw = TRUE;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2263: void",
          "2264: sdp_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "2265: {",
          "2280: }",
          "2283: void",
          "2284: remove_tap_listener_sdp_calls(voip_calls_tapinfo_t *tap_id_base)",
          "2285: {",
          "2287: }",
          "",
          "[Removed Lines]",
          "2266:  GString *error_string;",
          "2268:  error_string = register_tap_listener(\"sdp\", tap_base_to_id(tap_id_base, tap_id_offset_sdp_), NULL,",
          "2269:   0,",
          "2270:   voip_calls_dlg_reset,",
          "2271:         sdp_calls_packet,",
          "2272:   voip_calls_dlg_draw",
          "2273:   );",
          "2275:  if (error_string != NULL) {",
          "2276:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2277:          \"%s\", error_string->str);",
          "2278:   g_string_free(error_string, TRUE);",
          "2279:  }",
          "2286:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sdp_));",
          "",
          "[Added Lines]",
          "2263:     GString *error_string;",
          "2265:     error_string = register_tap_listener(\"sdp\", tap_base_to_id(tap_id_base, tap_id_offset_sdp_), NULL,",
          "2266:             0,",
          "2267:             voip_calls_dlg_reset,",
          "2268:             sdp_calls_packet,",
          "2269:             voip_calls_dlg_draw",
          "2270:             );",
          "2272:     if (error_string != NULL) {",
          "2273:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2274:                 \"%s\", error_string->str);",
          "2275:         g_string_free(error_string, TRUE);",
          "2276:     }",
          "2283:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sdp_));",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2299: static gboolean isSignal(const gchar *signal_str_p, const gchar *signalStr)",
          "2300: {",
          "2321: }",
          "",
          "[Removed Lines]",
          "2301:  gint i;",
          "2302:  gchar **resultArray;",
          "2305:  if (signalStr == NULL) return FALSE;",
          "2308:  if ( (*signal_str_p == '\\0') &&  (*signalStr == '\\0') ) return TRUE;",
          "2311:  resultArray = g_strsplit(signalStr, \",\", 10);",
          "2313:  for (i = 0; resultArray[i]; i++) {",
          "2314:   g_strstrip(resultArray[i]);",
          "2315:   if (strcmp(resultArray[i], signal_str_p) == 0) return TRUE;",
          "2316:  }",
          "2318:  g_strfreev(resultArray);",
          "2320:  return FALSE;",
          "",
          "[Added Lines]",
          "2297:     gint i;",
          "2298:     gchar **resultArray;",
          "2301:     if (signalStr == NULL) return FALSE;",
          "2304:     if ( (*signal_str_p == '\\0') &&  (*signalStr == '\\0') ) return TRUE;",
          "2307:     resultArray = g_strsplit(signalStr, \",\", 10);",
          "2309:     for (i = 0; resultArray[i]; i++) {",
          "2310:         g_strstrip(resultArray[i]);",
          "2311:         if (strcmp(resultArray[i], signal_str_p) == 0) return TRUE;",
          "2312:     }",
          "2314:     g_strfreev(resultArray);",
          "2316:     return FALSE;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2327: static void mgcpCallerID(gchar *signalStr, gchar **callerId)",
          "2328: {",
          "2343: }",
          "",
          "[Removed Lines]",
          "2329:  gchar **arrayStr;",
          "2332:  if (signalStr == NULL) return;",
          "2334:  arrayStr = g_strsplit(signalStr, \"\\\"\", 3);",
          "2337:  if (g_strv_length(arrayStr) == 3 && strstr(arrayStr[0], \"ci(\")) {",
          "2339:   g_free(*callerId);",
          "2341:  }",
          "2342:  g_strfreev(arrayStr);",
          "",
          "[Added Lines]",
          "2325:     gchar **arrayStr;",
          "2328:     if (signalStr == NULL) return;",
          "2330:     arrayStr = g_strsplit(signalStr, \"\\\"\", 3);",
          "2333:     if (g_strv_length(arrayStr) == 3 && strstr(arrayStr[0], \"ci(\")) {",
          "2335:         g_free(*callerId);",
          "2337:     }",
          "2338:     g_strfreev(arrayStr);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2350: static void mgcpDialedDigits(gchar *signalStr, gchar **dialedDigits)",
          "2351: {",
          "2396: }",
          "",
          "[Removed Lines]",
          "2352:  gchar *tmpStr;",
          "2353:  gchar *resultStr;",
          "2354:  gint i,j;",
          "2357:  guint resultStrLen = 1;",
          "2360:  if (signalStr == NULL) return;",
          "2362:  tmpStr = g_strdup(signalStr);",
          "2364:  for ( i = 0 ; tmpStr[i] ; i++) {",
          "2365:   switch (tmpStr[i]) {",
          "2366:    case '0' : case '1' : case '2' : case '3' : case '4' :",
          "2367:    case '5' : case '6' : case '7' : case '8' : case '9' :",
          "2368:    case '#' : case '*' :",
          "2369:     resultStrLen++;",
          "2370:     break;",
          "2371:    default:",
          "2372:     tmpStr[i] = '?';",
          "2373:     break;",
          "2374:   }",
          "2375:  }",
          "2377:  if (resultStrLen == 1) {",
          "2378:   g_free(tmpStr);",
          "2379:   return;",
          "2380:  }",
          "2382:  resultStr = (gchar *)g_malloc(resultStrLen);",
          "2384:  for (i = 0, j = 0; tmpStr[i]; i++) {",
          "2385:   if (tmpStr[i] != '?')",
          "2386:    resultStr[j++] = tmpStr[i];",
          "2387:  }",
          "2388:  resultStr[j] = '\\0';",
          "2390:  g_free(*dialedDigits);",
          "2391:  g_free(tmpStr);",
          "2395:  return;",
          "",
          "[Added Lines]",
          "2348:     gchar *tmpStr;",
          "2349:     gchar *resultStr;",
          "2350:     gint i,j;",
          "2353:     guint resultStrLen = 1;",
          "2356:     if (signalStr == NULL) return;",
          "2358:     tmpStr = g_strdup(signalStr);",
          "2360:     for ( i = 0 ; tmpStr[i] ; i++) {",
          "2361:         switch (tmpStr[i]) {",
          "2362:             case '0' : case '1' : case '2' : case '3' : case '4' :",
          "2363:             case '5' : case '6' : case '7' : case '8' : case '9' :",
          "2364:             case '#' : case '*' :",
          "2365:                 resultStrLen++;",
          "2366:                 break;",
          "2367:             default:",
          "2368:                 tmpStr[i] = '?';",
          "2369:                 break;",
          "2370:         }",
          "2371:     }",
          "2373:     if (resultStrLen == 1) {",
          "2374:         g_free(tmpStr);",
          "2375:         return;",
          "2376:     }",
          "2378:     resultStr = (gchar *)g_malloc(resultStrLen);",
          "2380:     for (i = 0, j = 0; tmpStr[i]; i++) {",
          "2381:         if (tmpStr[i] != '?')",
          "2382:             resultStr[j++] = tmpStr[i];",
          "2383:     }",
          "2384:     resultStr[j] = '\\0';",
          "2386:     g_free(*dialedDigits);",
          "2387:     g_free(tmpStr);",
          "2391:     return;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2402: static int",
          "2403: mgcp_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *MGCPinfo)",
          "2404: {",
          "2622: }",
          "",
          "[Removed Lines]",
          "2405:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_mgcp_);",
          "2407:  voip_calls_info_t *tmp_listinfo;",
          "2408:  voip_calls_info_t *callsinfo = NULL;",
          "2409:  mgcp_calls_info_t *tmp_mgcpinfo = NULL;",
          "2410:  GList *list;",
          "2411:  GList *listGraph = NULL;",
          "2412:  gchar *frame_label = NULL;",
          "2413:  gchar *comment = NULL;",
          "2414:  seq_analysis_item_t *gai = NULL;",
          "2415:  gboolean newcall = FALSE;",
          "2417:  gdouble diff_time;",
          "2419:  const mgcp_info_t *pi = (const mgcp_info_t *)MGCPinfo;",
          "2422:  if ((pi->mgcp_type == MGCP_REQUEST) && !pi->is_duplicate ) {",
          "2424:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2425:   while (list)",
          "2426:   {",
          "2427:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2428:    if ((tmp_listinfo->protocol == VOIP_MGCP) && (tmp_listinfo->call_active_state == VOIP_ACTIVE)) {",
          "2429:     tmp_mgcpinfo = (mgcp_calls_info_t *)tmp_listinfo->prot_info;",
          "2430:     if (pi->endpointId != NULL) {",
          "2431:      if (g_ascii_strcasecmp(tmp_mgcpinfo->endpointId,pi->endpointId) == 0) {",
          "2433:          check first if it is an ended call. We can still match packets to this Endpoint 2 seconds",
          "2434:          after the call has been released",
          "2436:       diff_time = nstime_to_sec(&pinfo->rel_ts) - nstime_to_sec(&tmp_listinfo->stop_rel_ts);",
          "2437:       if ( ((tmp_listinfo->call_state == VOIP_CANCELLED) ||",
          "2438:            (tmp_listinfo->call_state == VOIP_COMPLETED)  ||",
          "2439:            (tmp_listinfo->call_state == VOIP_REJECTED)) &&",
          "2440:              (diff_time > 2) )",
          "2441:       {",
          "2442:        tmp_listinfo->call_active_state = VOIP_INACTIVE;",
          "2443:       } else {",
          "2444:        callsinfo = (voip_calls_info_t*)(list->data);",
          "2445:        break;",
          "2446:       }",
          "2447:      }",
          "2448:     }",
          "2449:    }",
          "2450:    list = g_list_next (list);",
          "2451:   }",
          "2454:   if (callsinfo == NULL) {",
          "2457:     fromEndpoint = TRUE;",
          "2458:     newcall = TRUE;",
          "2459:    } else if (strcmp(pi->code, \"CRCX\") == 0) {",
          "2461:     fromEndpoint = FALSE;",
          "2462:     newcall = TRUE;",
          "2463:    }",
          "2464:    if (!newcall) return 0;",
          "2465:   }",
          "2466:  } else if ( ((pi->mgcp_type == MGCP_RESPONSE) && pi->request_available) ||",
          "2467:    ((pi->mgcp_type == MGCP_REQUEST) && pi->is_duplicate) ) {",
          "2470:   if(tapinfo->graph_analysis){",
          "2471:    listGraph = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "2472:   }",
          "2473:   while (listGraph)",
          "2474:   {",
          "2475:    gai = (seq_analysis_item_t *)listGraph->data;",
          "2476:    if (gai->fd->num == pi->req_num) {",
          "2478:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2479:     while (list)",
          "2480:     {",
          "2481:      tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2482:      if (tmp_listinfo->protocol == VOIP_MGCP) {",
          "2483:       if (tmp_listinfo->call_num == gai->conv_num) {",
          "2484:        tmp_mgcpinfo = (mgcp_calls_info_t *)tmp_listinfo->prot_info;",
          "2485:        callsinfo = (voip_calls_info_t*)(list->data);",
          "2486:        break;",
          "2487:       }",
          "2488:      }",
          "2489:      list = g_list_next (list);",
          "2490:     }",
          "2491:     if (callsinfo != NULL) break;",
          "2492:    }",
          "2493:    listGraph = g_list_next(listGraph);",
          "2494:   }",
          "2496:   if (callsinfo == NULL) return 0;",
          "2497:  } else return 0;",
          "2500:  if (callsinfo==NULL) {",
          "2501:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2502:   callsinfo->call_active_state = VOIP_ACTIVE;",
          "2503:   callsinfo->call_state = VOIP_CALL_SETUP;",
          "2504:   if (fromEndpoint) {",
          "2505:    callsinfo->from_identity=g_strdup(pi->endpointId);",
          "2506:    callsinfo->to_identity=g_strdup(\"\");",
          "2507:   } else {",
          "2508:    callsinfo->from_identity=g_strdup(\"\");",
          "2509:    callsinfo->to_identity=g_strdup(pi->endpointId);",
          "2510:   }",
          "2511:   COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "2512:   callsinfo->selected=FALSE;",
          "2513:   callsinfo->start_fd=pinfo->fd;",
          "2514:   callsinfo->start_rel_ts=pinfo->rel_ts;",
          "2515:   callsinfo->protocol=VOIP_MGCP;",
          "2516:   callsinfo->prot_info=g_malloc(sizeof(mgcp_calls_info_t));",
          "2517:   callsinfo->free_prot_info = g_free;",
          "2518:   tmp_mgcpinfo=(mgcp_calls_info_t *)callsinfo->prot_info;",
          "2519:   tmp_mgcpinfo->endpointId = g_strdup(pi->endpointId);",
          "2520:   tmp_mgcpinfo->fromEndpoint = fromEndpoint;",
          "2521:   callsinfo->npackets = 0;",
          "2522:   callsinfo->call_num = tapinfo->ncalls++;",
          "2523:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2524:  }",
          "2526:  g_assert(tmp_mgcpinfo != NULL);",
          "2529:  switch (pi->mgcp_type)",
          "2530:  {",
          "2531:  case MGCP_REQUEST:",
          "2532:   if ( (strcmp(pi->code, \"NTFY\") == 0) && (pi->observedEvents != NULL) ) {",
          "2533:    frame_label = g_strdup_printf(\"%s ObsEvt:%s\",pi->code, pi->observedEvents);",
          "2535:    if (tmp_mgcpinfo->fromEndpoint) {",
          "2537:     if (callsinfo->to_identity[0] == '\\0') mgcpDialedDigits(pi->observedEvents, &(callsinfo->to_identity));",
          "2540:    } else if (isSignal(\"hd\", pi->observedEvents))",
          "2541:     callsinfo->call_state=VOIP_IN_CALL;",
          "2544:    if (isSignal(\"hu\", pi->observedEvents)) {",
          "2545:     if ((callsinfo->call_state == VOIP_CALL_SETUP) || (callsinfo->call_state == VOIP_RINGING)) {",
          "2546:      callsinfo->call_state = VOIP_CANCELLED;",
          "2547:     } else {",
          "2548:      callsinfo->call_state = VOIP_COMPLETED;",
          "2549:     }",
          "2550:    }",
          "2552:   } else if (strcmp(pi->code, \"RQNT\") == 0) {",
          "2554:    if ( tmp_mgcpinfo->fromEndpoint && isSignal(\"\", pi->signalReq) && (callsinfo->call_state == VOIP_RINGING) ) {",
          "2555:      callsinfo->call_state = VOIP_IN_CALL;",
          "2556:    }",
          "2559:    if ( isSignal(\"rg\", pi->signalReq) || isSignal(\"rt\", pi->signalReq) ) {",
          "2560:      callsinfo->call_state = VOIP_RINGING;",
          "2561:    }",
          "2564:    if ( (isSignal(\"ro\", pi->signalReq) || isSignal(\"bz\", pi->signalReq)) && ((callsinfo->call_state == VOIP_CALL_SETUP) || (callsinfo->call_state == VOIP_RINGING)) ) {",
          "2565:      callsinfo->call_state = VOIP_REJECTED;",
          "2566:    }",
          "2568:    if (pi->signalReq != NULL)",
          "2569:     frame_label = g_strdup_printf(\"%s%sSigReq:%s\",pi->code, (pi->hasDigitMap == TRUE)?\" DigitMap \":\"\", pi->signalReq);",
          "2570:    else",
          "2571:     frame_label = g_strdup_printf(\"%s%s\",pi->code, (pi->hasDigitMap == TRUE)?\" DigitMap \":\"\");",
          "2574:    if (!tmp_mgcpinfo->fromEndpoint) mgcpCallerID(pi->signalReq, &(callsinfo->from_identity));",
          "2576:   } else if (strcmp(pi->code, \"DLCX\") == 0) {",
          "2578:      if there is a DLCX in a call To an Endpoint and the call was not connected, we use",
          "2579:      the DLCX as the end of the call",
          "2581:    if (!tmp_mgcpinfo->fromEndpoint) {",
          "2582:     if ((callsinfo->call_state == VOIP_CALL_SETUP) || (callsinfo->call_state == VOIP_RINGING)) {",
          "2583:      callsinfo->call_state = VOIP_CANCELLED;",
          "2584:     }",
          "2585:    }",
          "2586:   }",
          "2588:   if (frame_label == NULL) frame_label = g_strdup(pi->code);",
          "2589:   break;",
          "2590:  case MGCP_RESPONSE:",
          "2591:   frame_label = g_strdup_printf(\"%u (%s)\",pi->rspcode, pi->code);",
          "2592:   break;",
          "2593:  case MGCP_OTHERS:",
          "2595:   break;",
          "2596:  }",
          "2599:  comment = g_strdup_printf(\"MGCP %s %s%s\", tmp_mgcpinfo->endpointId, (pi->mgcp_type == MGCP_REQUEST)?\"Request\":\"Response\", pi->is_duplicate?\" Duplicate\":\"\");",
          "2601:  callsinfo->stop_fd = pinfo->fd;",
          "2602:  callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2603:  ++(callsinfo->npackets);",
          "2605:  ++(tapinfo->npackets);",
          "2608:  add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2609:  g_free(comment);",
          "2610:  g_free(frame_label);",
          "2613:  if ( (sdp_summary != NULL) && (sdp_frame_num == pinfo->fd->num) ) {",
          "2614:    append_to_frame_graph(tapinfo, pinfo->fd->num, sdp_summary, NULL);",
          "2615:    g_free(sdp_summary);",
          "2616:    sdp_summary = NULL;",
          "2617:  }",
          "2619:  tapinfo->redraw = TRUE;",
          "",
          "[Added Lines]",
          "2401:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_mgcp_);",
          "2403:     voip_calls_info_t *tmp_listinfo;",
          "2404:     voip_calls_info_t *callsinfo = NULL;",
          "2405:     mgcp_calls_info_t *tmp_mgcpinfo = NULL;",
          "2406:     GList *list;",
          "2407:     GList *listGraph = NULL;",
          "2408:     gchar *frame_label = NULL;",
          "2409:     gchar *comment = NULL;",
          "2410:     seq_analysis_item_t *gai = NULL;",
          "2411:     gboolean newcall = FALSE;",
          "2413:     gdouble diff_time;",
          "2415:     const mgcp_info_t *pi = (const mgcp_info_t *)MGCPinfo;",
          "2418:     if ((pi->mgcp_type == MGCP_REQUEST) && !pi->is_duplicate ) {",
          "2420:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2421:         while (list)",
          "2422:         {",
          "2423:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2424:             if ((tmp_listinfo->protocol == VOIP_MGCP) && (tmp_listinfo->call_active_state == VOIP_ACTIVE)) {",
          "2425:                 tmp_mgcpinfo = (mgcp_calls_info_t *)tmp_listinfo->prot_info;",
          "2426:                 if (pi->endpointId != NULL) {",
          "2427:                     if (g_ascii_strcasecmp(tmp_mgcpinfo->endpointId,pi->endpointId) == 0) {",
          "2429:                            check first if it is an ended call. We can still match packets to this Endpoint 2 seconds",
          "2430:                            after the call has been released",
          "2432:                         diff_time = nstime_to_sec(&pinfo->rel_ts) - nstime_to_sec(&tmp_listinfo->stop_rel_ts);",
          "2433:                         if ( ((tmp_listinfo->call_state == VOIP_CANCELLED) ||",
          "2434:                                     (tmp_listinfo->call_state == VOIP_COMPLETED)  ||",
          "2435:                                     (tmp_listinfo->call_state == VOIP_REJECTED)) &&",
          "2436:                                 (diff_time > 2) )",
          "2437:                         {",
          "2438:                             tmp_listinfo->call_active_state = VOIP_INACTIVE;",
          "2439:                         } else {",
          "2440:                             callsinfo = (voip_calls_info_t*)(list->data);",
          "2441:                             break;",
          "2442:                         }",
          "2443:                     }",
          "2444:                 }",
          "2445:             }",
          "2446:             list = g_list_next (list);",
          "2447:         }",
          "2450:         if (callsinfo == NULL) {",
          "2453:                 fromEndpoint = TRUE;",
          "2454:                 newcall = TRUE;",
          "2455:             } else if (strcmp(pi->code, \"CRCX\") == 0) {",
          "2457:                 fromEndpoint = FALSE;",
          "2458:                 newcall = TRUE;",
          "2459:             }",
          "2460:             if (!newcall) return 0;",
          "2461:         }",
          "2462:     } else if ( ((pi->mgcp_type == MGCP_RESPONSE) && pi->request_available) ||",
          "2463:             ((pi->mgcp_type == MGCP_REQUEST) && pi->is_duplicate) ) {",
          "2466:         if(tapinfo->graph_analysis){",
          "2467:             listGraph = g_queue_peek_nth_link(tapinfo->graph_analysis->items, 0);",
          "2468:         }",
          "2469:         while (listGraph)",
          "2470:         {",
          "2471:             gai = (seq_analysis_item_t *)listGraph->data;",
          "2472:             if (gai->fd->num == pi->req_num) {",
          "2474:                 list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2475:                 while (list)",
          "2476:                 {",
          "2477:                     tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2478:                     if (tmp_listinfo->protocol == VOIP_MGCP) {",
          "2479:                         if (tmp_listinfo->call_num == gai->conv_num) {",
          "2480:                             tmp_mgcpinfo = (mgcp_calls_info_t *)tmp_listinfo->prot_info;",
          "2481:                             callsinfo = (voip_calls_info_t*)(list->data);",
          "2482:                             break;",
          "2483:                         }",
          "2484:                     }",
          "2485:                     list = g_list_next (list);",
          "2486:                 }",
          "2487:                 if (callsinfo != NULL) break;",
          "2488:             }",
          "2489:             listGraph = g_list_next(listGraph);",
          "2490:         }",
          "2492:         if (callsinfo == NULL) return 0;",
          "2493:     } else return 0;",
          "2496:     if (callsinfo==NULL) {",
          "2497:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2498:         callsinfo->call_active_state = VOIP_ACTIVE;",
          "2499:         callsinfo->call_state = VOIP_CALL_SETUP;",
          "2500:         if (fromEndpoint) {",
          "2501:             callsinfo->from_identity=g_strdup(pi->endpointId);",
          "2502:             callsinfo->to_identity=g_strdup(\"\");",
          "2503:         } else {",
          "2504:             callsinfo->from_identity=g_strdup(\"\");",
          "2505:             callsinfo->to_identity=g_strdup(pi->endpointId);",
          "2506:         }",
          "2507:         COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "2508:         callsinfo->selected=FALSE;",
          "2509:         callsinfo->start_fd=pinfo->fd;",
          "2510:         callsinfo->start_rel_ts=pinfo->rel_ts;",
          "2511:         callsinfo->protocol=VOIP_MGCP;",
          "2512:         callsinfo->prot_info=g_malloc(sizeof(mgcp_calls_info_t));",
          "2513:         callsinfo->free_prot_info = g_free;",
          "2514:         tmp_mgcpinfo=(mgcp_calls_info_t *)callsinfo->prot_info;",
          "2515:         tmp_mgcpinfo->endpointId = g_strdup(pi->endpointId);",
          "2516:         tmp_mgcpinfo->fromEndpoint = fromEndpoint;",
          "2517:         callsinfo->npackets = 0;",
          "2518:         callsinfo->call_num = tapinfo->ncalls++;",
          "2519:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2520:     }",
          "2522:     g_assert(tmp_mgcpinfo != NULL);",
          "2525:     switch (pi->mgcp_type)",
          "2526:     {",
          "2527:         case MGCP_REQUEST:",
          "2528:             if ( (strcmp(pi->code, \"NTFY\") == 0) && (pi->observedEvents != NULL) ) {",
          "2529:                 frame_label = g_strdup_printf(\"%s ObsEvt:%s\",pi->code, pi->observedEvents);",
          "2531:                 if (tmp_mgcpinfo->fromEndpoint) {",
          "2533:                     if (callsinfo->to_identity[0] == '\\0') mgcpDialedDigits(pi->observedEvents, &(callsinfo->to_identity));",
          "2536:                 } else if (isSignal(\"hd\", pi->observedEvents))",
          "2537:                     callsinfo->call_state=VOIP_IN_CALL;",
          "2540:                 if (isSignal(\"hu\", pi->observedEvents)) {",
          "2541:                     if ((callsinfo->call_state == VOIP_CALL_SETUP) || (callsinfo->call_state == VOIP_RINGING)) {",
          "2542:                         callsinfo->call_state = VOIP_CANCELLED;",
          "2543:                     } else {",
          "2544:                         callsinfo->call_state = VOIP_COMPLETED;",
          "2545:                     }",
          "2546:                 }",
          "2548:             } else if (strcmp(pi->code, \"RQNT\") == 0) {",
          "2550:                 if ( tmp_mgcpinfo->fromEndpoint && isSignal(\"\", pi->signalReq) && (callsinfo->call_state == VOIP_RINGING) ) {",
          "2551:                     callsinfo->call_state = VOIP_IN_CALL;",
          "2552:                 }",
          "2555:                 if ( isSignal(\"rg\", pi->signalReq) || isSignal(\"rt\", pi->signalReq) ) {",
          "2556:                     callsinfo->call_state = VOIP_RINGING;",
          "2557:                 }",
          "2560:                 if ( (isSignal(\"ro\", pi->signalReq) || isSignal(\"bz\", pi->signalReq)) && ((callsinfo->call_state == VOIP_CALL_SETUP) || (callsinfo->call_state == VOIP_RINGING)) ) {",
          "2561:                     callsinfo->call_state = VOIP_REJECTED;",
          "2562:                 }",
          "2564:                 if (pi->signalReq != NULL)",
          "2565:                     frame_label = g_strdup_printf(\"%s%sSigReq:%s\",pi->code, (pi->hasDigitMap == TRUE)?\" DigitMap \":\"\", pi->signalReq);",
          "2566:                 else",
          "2567:                     frame_label = g_strdup_printf(\"%s%s\",pi->code, (pi->hasDigitMap == TRUE)?\" DigitMap \":\"\");",
          "2570:                 if (!tmp_mgcpinfo->fromEndpoint) mgcpCallerID(pi->signalReq, &(callsinfo->from_identity));",
          "2572:             } else if (strcmp(pi->code, \"DLCX\") == 0) {",
          "2574:                    if there is a DLCX in a call To an Endpoint and the call was not connected, we use",
          "2575:                    the DLCX as the end of the call",
          "2577:                 if (!tmp_mgcpinfo->fromEndpoint) {",
          "2578:                     if ((callsinfo->call_state == VOIP_CALL_SETUP) || (callsinfo->call_state == VOIP_RINGING)) {",
          "2579:                         callsinfo->call_state = VOIP_CANCELLED;",
          "2580:                     }",
          "2581:                 }",
          "2582:             }",
          "2584:             if (frame_label == NULL) frame_label = g_strdup(pi->code);",
          "2585:             break;",
          "2586:         case MGCP_RESPONSE:",
          "2587:             frame_label = g_strdup_printf(\"%u (%s)\",pi->rspcode, pi->code);",
          "2588:             break;",
          "2589:         case MGCP_OTHERS:",
          "2591:             break;",
          "2592:     }",
          "2595:     comment = g_strdup_printf(\"MGCP %s %s%s\", tmp_mgcpinfo->endpointId, (pi->mgcp_type == MGCP_REQUEST)?\"Request\":\"Response\", pi->is_duplicate?\" Duplicate\":\"\");",
          "2597:     callsinfo->stop_fd = pinfo->fd;",
          "2598:     callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2599:     ++(callsinfo->npackets);",
          "2601:     ++(tapinfo->npackets);",
          "2604:     add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2605:     g_free(comment);",
          "2606:     g_free(frame_label);",
          "2609:     if ( (sdp_summary != NULL) && (sdp_frame_num == pinfo->fd->num) ) {",
          "2610:         append_to_frame_graph(tapinfo, pinfo->fd->num, sdp_summary, NULL);",
          "2611:         g_free(sdp_summary);",
          "2612:         sdp_summary = NULL;",
          "2613:     }",
          "2615:     tapinfo->redraw = TRUE;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2628: void",
          "2629: mgcp_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "2630: {",
          "2652: }",
          "2655: void",
          "2656: remove_tap_listener_mgcp_calls(voip_calls_tapinfo_t *tap_id_base)",
          "2657: {",
          "2659: }",
          "",
          "[Removed Lines]",
          "2631:  GString *error_string;",
          "2639:  error_string = register_tap_listener(\"mgcp\",",
          "2640:   tap_base_to_id(tap_id_base, tap_id_offset_mgcp_),",
          "2641:   NULL,",
          "2642:   TL_REQUIRES_PROTO_TREE,",
          "2643:   voip_calls_dlg_reset,",
          "2644:         mgcp_calls_packet,",
          "2645:   voip_calls_dlg_draw",
          "2646:   );",
          "2647:  if (error_string != NULL) {",
          "2648:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2649:          \"%s\", error_string->str);",
          "2650:   g_string_free(error_string, TRUE);",
          "2651:  }",
          "2658:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_mgcp_));",
          "",
          "[Added Lines]",
          "2627:     GString *error_string;",
          "2635:     error_string = register_tap_listener(\"mgcp\",",
          "2636:             tap_base_to_id(tap_id_base, tap_id_offset_mgcp_),",
          "2637:             NULL,",
          "2638:             TL_REQUIRES_PROTO_TREE,",
          "2639:             voip_calls_dlg_reset,",
          "2640:             mgcp_calls_packet,",
          "2641:             voip_calls_dlg_draw",
          "2642:             );",
          "2643:     if (error_string != NULL) {",
          "2644:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2645:                 \"%s\", error_string->str);",
          "2646:         g_string_free(error_string, TRUE);",
          "2647:     }",
          "2654:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_mgcp_));",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2667: static int",
          "2668: actrace_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *ACTRACEinfo)",
          "2669: {",
          "2745: }",
          "",
          "[Removed Lines]",
          "2670:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_actrace_);",
          "2671:  const actrace_info_t *pi = (const actrace_info_t *)ACTRACEinfo;",
          "2672:  GList *list;",
          "2673:  actrace_cas_calls_info_t *tmp_actrace_cas_info;",
          "2674:  voip_calls_info_t *tmp_listinfo;",
          "2675:  voip_calls_info_t *callsinfo = NULL;",
          "2677:  actrace_frame_num = pinfo->fd->num;",
          "2678:  actrace_trunk = pi->trunk;",
          "2679:  actrace_direction = pi->direction;",
          "2682:   address pstn_add;",
          "2683:   gchar *comment = NULL;",
          "2685:   callsinfo = NULL;",
          "2686:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2687:   while (list)",
          "2688:   {",
          "2689:    tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2690:    if ( tmp_listinfo->protocol == VOIP_AC_CAS ) {",
          "2691:     tmp_actrace_cas_info = (actrace_cas_calls_info_t *)tmp_listinfo->prot_info;",
          "2693:     if ( (tmp_actrace_cas_info->bchannel == pi->cas_bchannel) && (tmp_actrace_cas_info->trunk == actrace_trunk) ) {",
          "2694:      callsinfo = (voip_calls_info_t*)(list->data);",
          "2695:      break;",
          "2696:     }",
          "2697:    }",
          "2698:    list = g_list_next (list);",
          "2699:   }",
          "2701:   SET_ADDRESS(&pstn_add, AT_STRINGZ, 5, \"PSTN\");",
          "2704:   if (!callsinfo) {",
          "2705:    callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2706:    callsinfo->call_active_state = VOIP_ACTIVE;",
          "2707:    callsinfo->call_state = VOIP_CALL_SETUP;",
          "2708:    callsinfo->from_identity=g_strdup(\"N/A\");",
          "2709:    callsinfo->to_identity=g_strdup(\"N/A\");",
          "2710:    COPY_ADDRESS(&(callsinfo->initial_speaker),actrace_direction?&pstn_add:&(pinfo->src));",
          "2711:    callsinfo->selected=FALSE;",
          "2712:    callsinfo->start_fd=pinfo->fd;",
          "2713:    callsinfo->start_rel_ts=pinfo->rel_ts;",
          "2714:    callsinfo->protocol=VOIP_AC_CAS;",
          "2715:    callsinfo->prot_info=g_malloc(sizeof(actrace_cas_calls_info_t));",
          "2716:    callsinfo->free_prot_info = g_free;",
          "2718:    tmp_actrace_cas_info=(actrace_cas_calls_info_t *)callsinfo->prot_info;",
          "2719:    tmp_actrace_cas_info->bchannel=pi->cas_bchannel;",
          "2720:    tmp_actrace_cas_info->trunk=actrace_trunk;",
          "2721:    callsinfo->npackets = 0;",
          "2722:    callsinfo->call_num = tapinfo->ncalls++;",
          "2723:    g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2724:   }",
          "2726:   callsinfo->stop_fd = pinfo->fd;",
          "2727:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2728:   ++(callsinfo->npackets);",
          "2730:   ++(tapinfo->npackets);",
          "2732:   comment = g_strdup_printf(\"AC_CAS  trunk:%u\", actrace_trunk);",
          "2734:   add_to_graph(tapinfo, pinfo, edt, pi->cas_frame_label, comment, callsinfo->call_num,",
          "2735:     actrace_direction?&pstn_add:&(pinfo->src),",
          "2736:     actrace_direction?&(pinfo->src):&pstn_add,",
          "2737:     1 );",
          "2739:   g_free(comment);",
          "2740:  }",
          "2742:  tapinfo->redraw = TRUE;",
          "",
          "[Added Lines]",
          "2666:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_actrace_);",
          "2667:     const actrace_info_t *pi = (const actrace_info_t *)ACTRACEinfo;",
          "2668:     GList *list;",
          "2669:     actrace_cas_calls_info_t *tmp_actrace_cas_info;",
          "2670:     voip_calls_info_t *tmp_listinfo;",
          "2671:     voip_calls_info_t *callsinfo = NULL;",
          "2673:     actrace_frame_num = pinfo->fd->num;",
          "2674:     actrace_trunk = pi->trunk;",
          "2675:     actrace_direction = pi->direction;",
          "2678:         address pstn_add;",
          "2679:         gchar *comment = NULL;",
          "2681:         callsinfo = NULL;",
          "2682:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2683:         while (list)",
          "2684:         {",
          "2685:             tmp_listinfo=(voip_calls_info_t *)list->data;",
          "2686:             if ( tmp_listinfo->protocol == VOIP_AC_CAS ) {",
          "2687:                 tmp_actrace_cas_info = (actrace_cas_calls_info_t *)tmp_listinfo->prot_info;",
          "2689:                 if ( (tmp_actrace_cas_info->bchannel == pi->cas_bchannel) && (tmp_actrace_cas_info->trunk == actrace_trunk) ) {",
          "2690:                     callsinfo = (voip_calls_info_t*)(list->data);",
          "2691:                     break;",
          "2692:                 }",
          "2693:             }",
          "2694:             list = g_list_next (list);",
          "2695:         }",
          "2697:         SET_ADDRESS(&pstn_add, AT_STRINGZ, 5, \"PSTN\");",
          "2700:         if (!callsinfo) {",
          "2701:             callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2702:             callsinfo->call_active_state = VOIP_ACTIVE;",
          "2703:             callsinfo->call_state = VOIP_CALL_SETUP;",
          "2704:             callsinfo->from_identity=g_strdup(\"N/A\");",
          "2705:             callsinfo->to_identity=g_strdup(\"N/A\");",
          "2706:             COPY_ADDRESS(&(callsinfo->initial_speaker),actrace_direction?&pstn_add:&(pinfo->src));",
          "2707:             callsinfo->selected=FALSE;",
          "2708:             callsinfo->start_fd=pinfo->fd;",
          "2709:             callsinfo->start_rel_ts=pinfo->rel_ts;",
          "2710:             callsinfo->protocol=VOIP_AC_CAS;",
          "2711:             callsinfo->prot_info=g_malloc(sizeof(actrace_cas_calls_info_t));",
          "2712:             callsinfo->free_prot_info = g_free;",
          "2714:             tmp_actrace_cas_info=(actrace_cas_calls_info_t *)callsinfo->prot_info;",
          "2715:             tmp_actrace_cas_info->bchannel=pi->cas_bchannel;",
          "2716:             tmp_actrace_cas_info->trunk=actrace_trunk;",
          "2717:             callsinfo->npackets = 0;",
          "2718:             callsinfo->call_num = tapinfo->ncalls++;",
          "2719:             g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2720:         }",
          "2722:         callsinfo->stop_fd = pinfo->fd;",
          "2723:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2724:         ++(callsinfo->npackets);",
          "2726:         ++(tapinfo->npackets);",
          "2728:         comment = g_strdup_printf(\"AC_CAS  trunk:%u\", actrace_trunk);",
          "2730:         add_to_graph(tapinfo, pinfo, edt, pi->cas_frame_label, comment, callsinfo->call_num,",
          "2731:                 actrace_direction?&pstn_add:&(pinfo->src),",
          "2732:                 actrace_direction?&(pinfo->src):&pstn_add,",
          "2733:                 1 );",
          "2735:         g_free(comment);",
          "2736:     }",
          "2738:     tapinfo->redraw = TRUE;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2751: void",
          "2752: actrace_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "2753: {",
          "2768: }",
          "2771: void",
          "2772: remove_tap_listener_actrace_calls(voip_calls_tapinfo_t *tap_id_base)",
          "2773: {",
          "2775: }",
          "",
          "[Removed Lines]",
          "2754:  GString *error_string;",
          "2756:  error_string = register_tap_listener(\"actrace\", tap_base_to_id(tap_id_base, tap_id_offset_actrace_), NULL,",
          "2757:   0,",
          "2758:   voip_calls_dlg_reset,",
          "2759:   actrace_calls_packet,",
          "2760:   voip_calls_dlg_draw",
          "2761:   );",
          "2763:  if (error_string != NULL) {",
          "2764:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2765:          \"%s\", error_string->str);",
          "2766:   g_string_free(error_string, TRUE);",
          "2767:  }",
          "2774:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_actrace_));",
          "",
          "[Added Lines]",
          "2750:     GString *error_string;",
          "2752:     error_string = register_tap_listener(\"actrace\", tap_base_to_id(tap_id_base, tap_id_offset_actrace_), NULL,",
          "2753:             0,",
          "2754:             voip_calls_dlg_reset,",
          "2755:             actrace_calls_packet,",
          "2756:             voip_calls_dlg_draw",
          "2757:             );",
          "2759:     if (error_string != NULL) {",
          "2760:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2761:                 \"%s\", error_string->str);",
          "2762:         g_string_free(error_string, TRUE);",
          "2763:     }",
          "2770:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_actrace_));",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2787: static int",
          "2788: h248_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *prot_info) {",
          "2885: }",
          "2887: void h248_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "2888: {",
          "2916: }",
          "2918: void",
          "2919: remove_tap_listener_h248_calls(voip_calls_tapinfo_t *tap_id_base)",
          "2920: {",
          "2923: }",
          "",
          "[Removed Lines]",
          "2789:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h248_);",
          "2790:  const gcp_cmd_t *cmd = (const gcp_cmd_t *)prot_info;",
          "2791:  GList *list;",
          "2792:  voip_calls_info_t *callsinfo = NULL;",
          "2793:  address *mgw;",
          "2794:  address *mgc;",
          "2795:  gchar mgw_addr[128];",
          "2797:  if (cmd->ctx->id == NULL_CONTEXT || cmd->ctx->id == ALL_CONTEXTS ) {",
          "2798:   return 0;",
          "2799:  }",
          "2801:  if ( gcp_is_req(cmd->type) ) {",
          "2802:   mgw = &(pinfo->dst);",
          "2803:   mgc = &(pinfo->src);",
          "2804:  } else {",
          "2805:   mgc = &(pinfo->dst);",
          "2806:   mgw = &(pinfo->src);",
          "2807:  }",
          "2809:  address_to_str_buf(mgw, mgw_addr, 128);",
          "2812:  list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2813:  while (list)",
          "2814:  {",
          "2815:   voip_calls_info_t* tmp_listinfo = (voip_calls_info_t *)list->data;",
          "2817:   if (tmp_listinfo->protocol == TEL_H248) {",
          "2818:    if (tmp_listinfo->prot_info == cmd->ctx) {",
          "2819:     callsinfo = (voip_calls_info_t*)(list->data);",
          "2820:     break;",
          "2821:    }",
          "2822:   }",
          "2823:   list = g_list_next (list);",
          "2824:  }",
          "2826:  if (callsinfo==NULL) {",
          "2828:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2829:   callsinfo->call_state = VOIP_NO_STATE;",
          "2830:   callsinfo->call_active_state = VOIP_ACTIVE;",
          "2831:   callsinfo->from_identity = g_strdup_printf(\"%s : %.8x\", mgw_addr, cmd->ctx->id);",
          "2832:   callsinfo->to_identity = g_strdup(\"\");",
          "2833:   callsinfo->prot_info = cmd->ctx;",
          "2834:   callsinfo->free_prot_info = NULL;",
          "2836:   callsinfo->npackets = 1;",
          "2838:   COPY_ADDRESS(&(callsinfo->initial_speaker), mgc);",
          "2840:   callsinfo->protocol = TEL_H248;",
          "2841:   callsinfo->call_num = tapinfo->ncalls++;",
          "2842:   callsinfo->start_fd = pinfo->fd;",
          "2843:   callsinfo->start_rel_ts = pinfo->rel_ts;",
          "2844:   callsinfo->stop_fd = pinfo->fd;",
          "2845:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2847:   callsinfo->selected = FALSE;",
          "2849:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2851:  } else {",
          "2852:   GString *s = g_string_new(\"\");",
          "2853:   gcp_terms_t *ctx_term;",
          "2855:   g_free(callsinfo->from_identity);",
          "2856:   callsinfo->from_identity = g_strdup_printf(\"%s : %.8x\", mgw_addr, ((gcp_ctx_t*)callsinfo->prot_info)->id);",
          "2858:   g_free(callsinfo->to_identity);",
          "2860:   for (ctx_term = ((gcp_ctx_t*)callsinfo->prot_info)->terms.next;",
          "2861:     ctx_term;",
          "2862:     ctx_term = ctx_term->next ) {",
          "2863:    if ( ctx_term->term && ctx_term->term->str) {",
          "2864:     g_string_append_printf(s,\" %s\",ctx_term->term->str);",
          "2865:    }",
          "2866:   }",
          "2868:   callsinfo->to_identity = s->str;",
          "2869:   g_string_free(s,FALSE);",
          "2871:   callsinfo->stop_fd = pinfo->fd;",
          "2872:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2873:   ++(callsinfo->npackets);",
          "2874:  }",
          "2876:  add_to_graph(tapinfo, pinfo, edt, cmd->str ? cmd->str : \"unknown Msg\",",
          "2877:      ep_strdup_printf(\"TrxId = %u, CtxId = %.8x\",cmd->trx->id,cmd->ctx->id),",
          "2878:      callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2880:  ++(tapinfo->npackets);",
          "2882:  tapinfo->redraw = TRUE;",
          "2884:  return 1;",
          "2889:  GString *error_string;",
          "2891:  error_string = register_tap_listener(\"megaco\", tap_base_to_id(tap_id_base, tap_id_offset_megaco_),",
          "2892:   NULL,",
          "2893:   0,",
          "2894:   voip_calls_dlg_reset,",
          "2895:   h248_calls_packet,",
          "2896:   voip_calls_dlg_draw);",
          "2898:  if (error_string != NULL) {",
          "2899:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2900:          \"%s\", error_string->str);",
          "2901:   g_string_free(error_string, TRUE);",
          "2902:  }",
          "2904:  error_string = register_tap_listener(\"h248\", tap_base_to_id(tap_id_base, tap_id_offset_h248_),",
          "2905:   NULL,",
          "2906:   0,",
          "2907:   voip_calls_dlg_reset,",
          "2908:   h248_calls_packet,",
          "2909:   voip_calls_dlg_draw);",
          "2911:  if (error_string != NULL) {",
          "2912:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2913:          \"%s\", error_string->str);",
          "2914:   g_string_free(error_string, TRUE);",
          "2915:  }",
          "2921:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_h248_));",
          "2922:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_megaco_));",
          "",
          "[Added Lines]",
          "2785:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h248_);",
          "2786:     const gcp_cmd_t *cmd = (const gcp_cmd_t *)prot_info;",
          "2787:     GList *list;",
          "2788:     voip_calls_info_t *callsinfo = NULL;",
          "2789:     address *mgw;",
          "2790:     address *mgc;",
          "2791:     gchar mgw_addr[128];",
          "2793:     if (cmd->ctx->id == NULL_CONTEXT || cmd->ctx->id == ALL_CONTEXTS ) {",
          "2794:         return 0;",
          "2795:     }",
          "2797:     if ( gcp_is_req(cmd->type) ) {",
          "2798:         mgw = &(pinfo->dst);",
          "2799:         mgc = &(pinfo->src);",
          "2800:     } else {",
          "2801:         mgc = &(pinfo->dst);",
          "2802:         mgw = &(pinfo->src);",
          "2803:     }",
          "2805:     address_to_str_buf(mgw, mgw_addr, 128);",
          "2808:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "2809:     while (list)",
          "2810:     {",
          "2811:         voip_calls_info_t* tmp_listinfo = (voip_calls_info_t *)list->data;",
          "2813:         if (tmp_listinfo->protocol == TEL_H248) {",
          "2814:             if (tmp_listinfo->prot_info == cmd->ctx) {",
          "2815:                 callsinfo = (voip_calls_info_t*)(list->data);",
          "2816:                 break;",
          "2817:             }",
          "2818:         }",
          "2819:         list = g_list_next (list);",
          "2820:     }",
          "2822:     if (callsinfo==NULL) {",
          "2824:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2825:         callsinfo->call_state = VOIP_NO_STATE;",
          "2826:         callsinfo->call_active_state = VOIP_ACTIVE;",
          "2827:         callsinfo->from_identity = g_strdup_printf(\"%s : %.8x\", mgw_addr, cmd->ctx->id);",
          "2828:         callsinfo->to_identity = g_strdup(\"\");",
          "2829:         callsinfo->prot_info = cmd->ctx;",
          "2830:         callsinfo->free_prot_info = NULL;",
          "2832:         callsinfo->npackets = 1;",
          "2834:         COPY_ADDRESS(&(callsinfo->initial_speaker), mgc);",
          "2836:         callsinfo->protocol = TEL_H248;",
          "2837:         callsinfo->call_num = tapinfo->ncalls++;",
          "2838:         callsinfo->start_fd = pinfo->fd;",
          "2839:         callsinfo->start_rel_ts = pinfo->rel_ts;",
          "2840:         callsinfo->stop_fd = pinfo->fd;",
          "2841:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2843:         callsinfo->selected = FALSE;",
          "2845:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2847:     } else {",
          "2848:         GString *s = g_string_new(\"\");",
          "2849:         gcp_terms_t *ctx_term;",
          "2851:         g_free(callsinfo->from_identity);",
          "2852:         callsinfo->from_identity = g_strdup_printf(\"%s : %.8x\", mgw_addr, ((gcp_ctx_t*)callsinfo->prot_info)->id);",
          "2854:         g_free(callsinfo->to_identity);",
          "2856:         for (ctx_term = ((gcp_ctx_t*)callsinfo->prot_info)->terms.next;",
          "2857:                 ctx_term;",
          "2858:                 ctx_term = ctx_term->next ) {",
          "2859:             if ( ctx_term->term && ctx_term->term->str) {",
          "2860:                 g_string_append_printf(s,\" %s\",ctx_term->term->str);",
          "2861:             }",
          "2862:         }",
          "2864:         callsinfo->to_identity = s->str;",
          "2865:         g_string_free(s,FALSE);",
          "2867:         callsinfo->stop_fd = pinfo->fd;",
          "2868:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2869:         ++(callsinfo->npackets);",
          "2870:     }",
          "2872:     add_to_graph(tapinfo, pinfo, edt, cmd->str ? cmd->str : \"unknown Msg\",",
          "2873:             ep_strdup_printf(\"TrxId = %u, CtxId = %.8x\",cmd->trx->id,cmd->ctx->id),",
          "2874:             callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "2876:     ++(tapinfo->npackets);",
          "2878:     tapinfo->redraw = TRUE;",
          "2880:     return 1;",
          "2885:     GString *error_string;",
          "2887:     error_string = register_tap_listener(\"megaco\", tap_base_to_id(tap_id_base, tap_id_offset_megaco_),",
          "2888:             NULL,",
          "2889:             0,",
          "2890:             voip_calls_dlg_reset,",
          "2891:             h248_calls_packet,",
          "2892:             voip_calls_dlg_draw);",
          "2894:     if (error_string != NULL) {",
          "2895:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2896:                 \"%s\", error_string->str);",
          "2897:         g_string_free(error_string, TRUE);",
          "2898:     }",
          "2900:     error_string = register_tap_listener(\"h248\", tap_base_to_id(tap_id_base, tap_id_offset_h248_),",
          "2901:             NULL,",
          "2902:             0,",
          "2903:             voip_calls_dlg_reset,",
          "2904:             h248_calls_packet,",
          "2905:             voip_calls_dlg_draw);",
          "2907:     if (error_string != NULL) {",
          "2908:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "2909:                 \"%s\", error_string->str);",
          "2910:         g_string_free(error_string, TRUE);",
          "2911:     }",
          "2917:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_h248_));",
          "2918:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_megaco_));",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2930: static const voip_protocol sccp_proto_map[] = {",
          "2934: };",
          "2935: #define SP2VP(ap) ((ap) < SCCP_PLOAD_NUM_PLOADS ? sccp_proto_map[(ap)] : TEL_SCCP)",
          "2936: const value_string* sccp_payload_values;",
          "2938: static int",
          "2939: sccp_calls(voip_calls_tapinfo_t *tapinfo, packet_info *pinfo, epan_dissect_t *edt, const void *prot_info) {",
          "3039: }",
          "3041: static int sccp_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *prot_info) {",
          "3046: }",
          "3049: static int sua_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *prot_info) {",
          "3054: }",
          "3057: void sccp_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "3058: {",
          "3086: }",
          "3088: void",
          "3089: remove_tap_listener_sccp_calls(voip_calls_tapinfo_t *tap_id_base)",
          "3090: {",
          "3093: }",
          "",
          "[Removed Lines]",
          "2931:  TEL_SCCP,",
          "2932:  TEL_BSSMAP,",
          "2933:  TEL_RANAP",
          "2940:  const sccp_msg_info_t* msg = (const sccp_msg_info_t *)prot_info;",
          "2941:  sccp_assoc_info_t* assoc = msg->data.co.assoc;",
          "2942:  GList *list;",
          "2943:  voip_calls_info_t *callsinfo = NULL;",
          "2944:  const gchar *label = NULL;",
          "2945:  const gchar *comment = NULL;",
          "2948:  for(list = g_queue_peek_nth_link(tapinfo->callsinfos, 0) ; list ; list = g_list_next (list) ) {",
          "2949:   if ( ((voip_calls_info_t*)(list->data))->prot_info == assoc ) {",
          "2950:     callsinfo = (voip_calls_info_t*)(list->data);",
          "2951:     break;",
          "2952:   }",
          "2953:  }",
          "2955:  if (callsinfo==NULL) {",
          "2956:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2957:   callsinfo->call_state = VOIP_CALL_SETUP;",
          "2958:   callsinfo->call_active_state = VOIP_ACTIVE;",
          "2959:   if ( assoc->calling_party ) {",
          "2960:    callsinfo->from_identity =  g_strdup(assoc->calling_party);",
          "2961:   } else {",
          "2962:    callsinfo->from_identity =  g_strdup(\"Unknown\");",
          "2963:   }",
          "2965:   if ( assoc->called_party ) {",
          "2966:    callsinfo->to_identity =  g_strdup(assoc->called_party);",
          "2967:   } else {",
          "2968:    callsinfo->to_identity =  g_strdup(\"Unknown\");",
          "2969:   }",
          "2971:   callsinfo->prot_info = (void*)assoc;",
          "2972:   callsinfo->free_prot_info = NULL;",
          "2974:   callsinfo->npackets = 1;",
          "2976:   COPY_ADDRESS(&(callsinfo->initial_speaker), &(pinfo->src));",
          "2978:   callsinfo->protocol =   SP2VP(assoc->payload);",
          "2980:   callsinfo->start_fd = pinfo->fd;",
          "2981:   callsinfo->start_rel_ts = pinfo->rel_ts;",
          "2982:   callsinfo->stop_fd = pinfo->fd;",
          "2983:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2985:   callsinfo->selected = FALSE;",
          "2986:   callsinfo->call_num = tapinfo->ncalls++;",
          "2988:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2989:  } else {",
          "2991:   if ( assoc->calling_party ) {",
          "2992:    g_free(callsinfo->from_identity);",
          "2993:    callsinfo->from_identity =  g_strdup(assoc->calling_party);",
          "2994:   }",
          "2996:   if ( assoc->called_party ) {",
          "2997:    g_free(callsinfo->to_identity);",
          "2998:    callsinfo->to_identity =  g_strdup(assoc->called_party);",
          "2999:   }",
          "3001:   callsinfo->protocol =  SP2VP(assoc->payload);",
          "3003:   callsinfo->stop_fd = pinfo->fd;",
          "3004:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3005:   ++(callsinfo->npackets);",
          "3007:   switch (msg->type) {",
          "3008:    case SCCP_MSG_TYPE_CC:",
          "3009:     callsinfo->call_state = VOIP_IN_CALL;",
          "3010:     break;",
          "3011:    case SCCP_MSG_TYPE_RLC:",
          "3012:     callsinfo->call_state = VOIP_COMPLETED;",
          "3013:     callsinfo->call_active_state = VOIP_INACTIVE;",
          "3014:     break;",
          "3015:    default:",
          "3016:     break;",
          "3017:   }",
          "3018:  }",
          "3020:  if (msg->data.co.label) {",
          "3021:   label = msg->data.co.label;",
          "3022:  } else {",
          "3023:   label = val_to_str(msg->type, sccp_payload_values, \"Unknown(%d)\");",
          "3024:  }",
          "3026:  if (msg->data.co.comment) {",
          "3027:   comment = msg->data.co.comment;",
          "3028:  } else {",
          "3029:   comment = NULL;",
          "3030:  }",
          "3032:  add_to_graph(tapinfo, pinfo, edt, label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3034:  ++(tapinfo->npackets);",
          "3036:  tapinfo->redraw = TRUE;",
          "3038:  return 1;",
          "3042:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sccp_);",
          "3044:  sccp_payload_values = sccp_message_type_acro_values;",
          "3045:  return sccp_calls(tapinfo, pinfo, edt, prot_info);",
          "3050:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sccp_);",
          "3052:  sccp_payload_values = sua_co_class_type_acro_values;",
          "3053:  return sccp_calls(tapinfo, pinfo, edt, prot_info);",
          "3059:  GString *error_string;",
          "3061:  error_string = register_tap_listener(\"sccp\", tap_base_to_id(tap_id_base, tap_id_offset_sccp_),",
          "3062:   NULL,",
          "3063:   0,",
          "3064:   voip_calls_dlg_reset,",
          "3065:   sccp_calls_packet,",
          "3066:   voip_calls_dlg_draw);",
          "3068:  if (error_string != NULL) {",
          "3069:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3070:          \"%s\", error_string->str);",
          "3071:   g_string_free(error_string, TRUE);",
          "3072:  }",
          "3074:  error_string = register_tap_listener(\"sua\", tap_base_to_id(tap_id_base, tap_id_offset_sua_),",
          "3075:   NULL,",
          "3076:   0,",
          "3077:   voip_calls_dlg_reset,",
          "3078:   sua_calls_packet,",
          "3079:   voip_calls_dlg_draw);",
          "3081:  if (error_string != NULL) {",
          "3082:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3083:          \"%s\", error_string->str);",
          "3084:   g_string_free(error_string, TRUE);",
          "3085:  }",
          "3091:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sccp_));",
          "3092:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sua_));",
          "",
          "[Added Lines]",
          "2927:     TEL_SCCP,",
          "2928:     TEL_BSSMAP,",
          "2929:     TEL_RANAP",
          "2936:     const sccp_msg_info_t* msg = (const sccp_msg_info_t *)prot_info;",
          "2937:     sccp_assoc_info_t* assoc = msg->data.co.assoc;",
          "2938:     GList *list;",
          "2939:     voip_calls_info_t *callsinfo = NULL;",
          "2940:     const gchar *label = NULL;",
          "2941:     const gchar *comment = NULL;",
          "2944:     for(list = g_queue_peek_nth_link(tapinfo->callsinfos, 0) ; list ; list = g_list_next (list) ) {",
          "2945:         if ( ((voip_calls_info_t*)(list->data))->prot_info == assoc ) {",
          "2946:             callsinfo = (voip_calls_info_t*)(list->data);",
          "2947:             break;",
          "2948:         }",
          "2949:     }",
          "2951:     if (callsinfo==NULL) {",
          "2952:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "2953:         callsinfo->call_state = VOIP_CALL_SETUP;",
          "2954:         callsinfo->call_active_state = VOIP_ACTIVE;",
          "2955:         if ( assoc->calling_party ) {",
          "2956:             callsinfo->from_identity =  g_strdup(assoc->calling_party);",
          "2957:         } else {",
          "2958:             callsinfo->from_identity =  g_strdup(\"Unknown\");",
          "2959:         }",
          "2961:         if ( assoc->called_party ) {",
          "2962:             callsinfo->to_identity =  g_strdup(assoc->called_party);",
          "2963:         } else {",
          "2964:             callsinfo->to_identity =  g_strdup(\"Unknown\");",
          "2965:         }",
          "2967:         callsinfo->prot_info = (void*)assoc;",
          "2968:         callsinfo->free_prot_info = NULL;",
          "2970:         callsinfo->npackets = 1;",
          "2972:         COPY_ADDRESS(&(callsinfo->initial_speaker), &(pinfo->src));",
          "2974:         callsinfo->protocol =   SP2VP(assoc->payload);",
          "2976:         callsinfo->start_fd = pinfo->fd;",
          "2977:         callsinfo->start_rel_ts = pinfo->rel_ts;",
          "2978:         callsinfo->stop_fd = pinfo->fd;",
          "2979:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "2981:         callsinfo->selected = FALSE;",
          "2982:         callsinfo->call_num = tapinfo->ncalls++;",
          "2984:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "2985:     } else {",
          "2987:         if ( assoc->calling_party ) {",
          "2988:             g_free(callsinfo->from_identity);",
          "2989:             callsinfo->from_identity =  g_strdup(assoc->calling_party);",
          "2990:         }",
          "2992:         if ( assoc->called_party ) {",
          "2993:             g_free(callsinfo->to_identity);",
          "2994:             callsinfo->to_identity =  g_strdup(assoc->called_party);",
          "2995:         }",
          "2997:         callsinfo->protocol =  SP2VP(assoc->payload);",
          "2999:         callsinfo->stop_fd = pinfo->fd;",
          "3000:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3001:         ++(callsinfo->npackets);",
          "3003:         switch (msg->type) {",
          "3004:             case SCCP_MSG_TYPE_CC:",
          "3005:                 callsinfo->call_state = VOIP_IN_CALL;",
          "3006:                 break;",
          "3007:             case SCCP_MSG_TYPE_RLC:",
          "3008:                 callsinfo->call_state = VOIP_COMPLETED;",
          "3009:                 callsinfo->call_active_state = VOIP_INACTIVE;",
          "3010:                 break;",
          "3011:             default:",
          "3012:                 break;",
          "3013:         }",
          "3014:     }",
          "3016:     if (msg->data.co.label) {",
          "3017:         label = msg->data.co.label;",
          "3018:     } else {",
          "3019:         label = val_to_str(msg->type, sccp_payload_values, \"Unknown(%d)\");",
          "3020:     }",
          "3022:     if (msg->data.co.comment) {",
          "3023:         comment = msg->data.co.comment;",
          "3024:     } else {",
          "3025:         comment = NULL;",
          "3026:     }",
          "3028:     add_to_graph(tapinfo, pinfo, edt, label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3030:     ++(tapinfo->npackets);",
          "3032:     tapinfo->redraw = TRUE;",
          "3034:     return 1;",
          "3038:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sccp_);",
          "3040:     sccp_payload_values = sccp_message_type_acro_values;",
          "3041:     return sccp_calls(tapinfo, pinfo, edt, prot_info);",
          "3046:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sccp_);",
          "3048:     sccp_payload_values = sua_co_class_type_acro_values;",
          "3049:     return sccp_calls(tapinfo, pinfo, edt, prot_info);",
          "3055:     GString *error_string;",
          "3057:     error_string = register_tap_listener(\"sccp\", tap_base_to_id(tap_id_base, tap_id_offset_sccp_),",
          "3058:             NULL,",
          "3059:             0,",
          "3060:             voip_calls_dlg_reset,",
          "3061:             sccp_calls_packet,",
          "3062:             voip_calls_dlg_draw);",
          "3064:     if (error_string != NULL) {",
          "3065:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3066:                 \"%s\", error_string->str);",
          "3067:         g_string_free(error_string, TRUE);",
          "3068:     }",
          "3070:     error_string = register_tap_listener(\"sua\", tap_base_to_id(tap_id_base, tap_id_offset_sua_),",
          "3071:             NULL,",
          "3072:             0,",
          "3073:             voip_calls_dlg_reset,",
          "3074:             sua_calls_packet,",
          "3075:             voip_calls_dlg_draw);",
          "3077:     if (error_string != NULL) {",
          "3078:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3079:                 \"%s\", error_string->str);",
          "3080:         g_string_free(error_string, TRUE);",
          "3081:     }",
          "3087:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sccp_));",
          "3088:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_sua_));",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3100: static int",
          "3101: unistim_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *unistim_info)",
          "3102: {",
          "3562: }",
          "",
          "[Removed Lines]",
          "3103:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_unistim_);",
          "3104:  voip_calls_info_t *tmp_listinfo;",
          "3105:  voip_calls_info_t *callsinfo = NULL;",
          "3106:  unistim_info_t *tmp_unistim_info = NULL;",
          "3107:  GList *list = NULL;",
          "3108:  GString *g_tmp = NULL;",
          "3109:  const gchar *frame_label = NULL;",
          "3110:  gchar *comment = NULL;",
          "3113:  const unistim_info_t *pi = (const unistim_info_t *)unistim_info;",
          "3116:  g_tmp = g_string_new(NULL);",
          "3119:  list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3121:  while(list)",
          "3122:  {",
          "3123:   tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3125:   if(tmp_listinfo->protocol == VOIP_UNISTIM) {",
          "3127:    tmp_unistim_info = (unistim_info_t *)tmp_listinfo->prot_info;",
          "3130:    if(pi->termid != 0) {",
          "3131:     if(tmp_unistim_info->termid == pi->termid) {",
          "3133:      if(tmp_listinfo->call_state == VOIP_COMPLETED || tmp_listinfo->call_state == VOIP_UNKNOWN) {",
          "3135:      } else {",
          "3136:       callsinfo = (voip_calls_info_t*)(list->data);",
          "3137:       break;",
          "3138:      }",
          "3139:     }",
          "3140:    } else {",
          "3142:     if(ADDRESSES_EQUAL(&tmp_unistim_info->it_ip, &pinfo->dst) && ADDRESSES_EQUAL(&tmp_unistim_info->ni_ip,&pinfo->src) && (tmp_unistim_info->it_port == pinfo->destport)) {",
          "3143:      if(tmp_listinfo->call_state == VOIP_COMPLETED || tmp_listinfo->call_state == VOIP_UNKNOWN) {",
          "3145:      } else {",
          "3146:       callsinfo = (voip_calls_info_t*)(list->data);",
          "3147:       break;",
          "3148:      }",
          "3149:     }",
          "3150:     else if(ADDRESSES_EQUAL(&tmp_unistim_info->it_ip, &pinfo->src) && ADDRESSES_EQUAL(&tmp_unistim_info->ni_ip,&pinfo->dst) && (tmp_unistim_info->it_port == pinfo->srcport)) {",
          "3151:      if(tmp_listinfo->call_state == VOIP_COMPLETED || tmp_listinfo->call_state == VOIP_UNKNOWN) {",
          "3153:      } else {",
          "3154:       callsinfo = (voip_calls_info_t*)(list->data);",
          "3155:       break;",
          "3156:      }",
          "3157:     }",
          "3158:    }",
          "3159:   }",
          "3162:   list = g_list_next(list);",
          "3163:  }",
          "3165:  if(pi->payload_type == 2 || pi->payload_type == 1) {",
          "3167:   if(pi->key_state == 1 || pi->hook_state == 1) {",
          "3173:    if (callsinfo==NULL) {",
          "3175:     callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3176:     callsinfo->call_active_state = VOIP_ACTIVE;",
          "3177:     callsinfo->call_state = VOIP_CALL_SETUP;",
          "3178:     callsinfo->from_identity=g_strdup_printf(\"%x\",pi->termid);",
          "3179:     callsinfo->to_identity=g_strdup(\"UNKNOWN\");",
          "3180:     COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "3181:     callsinfo->selected=FALSE;",
          "3186:     callsinfo->start_fd=pinfo->fd;",
          "3187:     callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3189:     callsinfo->protocol=VOIP_UNISTIM;",
          "3190:     callsinfo->prot_info=g_malloc(sizeof(unistim_info_t));",
          "3192:     tmp_unistim_info = (unistim_info_t *)callsinfo->prot_info;",
          "3195:     tmp_unistim_info->rudp_type = 0;",
          "3196:     tmp_unistim_info->payload_type = 0;",
          "3197:     tmp_unistim_info->sequence = pi->sequence;",
          "3198:     tmp_unistim_info->termid = pi->termid;",
          "3199:     tmp_unistim_info->key_val = -1;",
          "3200:     tmp_unistim_info->key_state = -1;",
          "3201:     tmp_unistim_info->hook_state = -1;",
          "3202:     tmp_unistim_info->stream_connect = -1;",
          "3203:     tmp_unistim_info->trans_connect = -1;",
          "3204:     tmp_unistim_info->set_termid = -1;",
          "3205:     tmp_unistim_info->string_data = NULL;",
          "3206:     tmp_unistim_info->key_buffer = NULL;",
          "3208:     COPY_ADDRESS(&(tmp_unistim_info->it_ip),&(pi->it_ip));",
          "3209:     COPY_ADDRESS(&(tmp_unistim_info->ni_ip),&(pi->ni_ip));",
          "3210:     tmp_unistim_info->it_port = pi->it_port;",
          "3212:     callsinfo->free_prot_info = g_free;",
          "3213:     callsinfo->npackets = 0;",
          "3214:     callsinfo->call_num = tapinfo->ncalls++;",
          "3215:     g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3217:    } else {",
          "3220:     tmp_unistim_info = (unistim_info_t *)callsinfo->prot_info;",
          "3221:     tmp_unistim_info->sequence = pi->sequence;",
          "3222:    }",
          "3226:    callsinfo->stop_fd = pinfo->fd;",
          "3227:    callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3230:    ++(callsinfo->npackets);",
          "3233:    ++(tapinfo->npackets);",
          "3236:    if(pi->key_val >= 0 && pi->key_val <= 11) {",
          "3238:     if(tmp_unistim_info->key_buffer != NULL) {",
          "3241:      g_string_assign(g_tmp,tmp_unistim_info->key_buffer);",
          "3244:      if(pi->key_val == 10) {",
          "3245:       tmp_unistim_info->key_buffer = g_strdup_printf(\"%s*\",g_tmp->str);",
          "3246:      } else if(pi->key_val == 11) {",
          "3247:       tmp_unistim_info->key_buffer = g_strdup_printf(\"%s#\",g_tmp->str);",
          "3248:      } else {",
          "3249:       tmp_unistim_info->key_buffer = g_strdup_printf(\"%s%d\",g_tmp->str,pi->key_val);",
          "3250:      }",
          "3252:     } else {",
          "3255:      if(pi->key_val == 10) {",
          "3256:       tmp_unistim_info->key_buffer = g_strdup(\"*\");",
          "3257:      } else if(pi->key_val == 11) {",
          "3258:       tmp_unistim_info->key_buffer = g_strdup(\"#\");",
          "3259:      } else {",
          "3260:       tmp_unistim_info->key_buffer = g_strdup_printf(\"%d\",pi->key_val);",
          "3261:      }",
          "3263:     }",
          "3266:     if(pi->key_val == 10) {",
          "3267:      comment = g_strdup_printf(\"Key Input Sent: * (%d)\", pi->sequence);",
          "3268:     } else if(pi->key_val == 11) {",
          "3269:      comment = g_strdup_printf(\"Key Input Sent: # (%d)\", pi->sequence);",
          "3270:     } else {",
          "3271:      comment = g_strdup_printf(\"Key Input Sent: %d (%d)\",pi->key_val, pi->sequence);",
          "3272:     }",
          "3273:    } else if(pi->key_val == 12) {",
          "3275:     comment = g_strdup_printf(\"Key Input Sent: UP (%d)\", pi->sequence);",
          "3276:    } else if(pi->key_val == 13) {",
          "3278:     comment = g_strdup_printf(\"Key Input Sent: DOWN (%d)\", pi->sequence);",
          "3279:    } else if(pi->key_val == 14) {",
          "3281:     comment = g_strdup_printf(\"Key Input Sent: RIGHT (%d)\", pi->sequence);",
          "3282:    } else if(pi->key_val == 15) {",
          "3283:     if(pi->key_buffer != NULL) {",
          "3285:      g_string_assign(g_tmp,pi->key_buffer);",
          "3288:      g_string_truncate(g_tmp,g_tmp->len-1);",
          "3291:      tmp_unistim_info->key_buffer = g_strdup(g_tmp->str);",
          "3292:     }",
          "3295:     comment = g_strdup_printf(\"Key Input Sent: LEFT (%d)\", pi->sequence);",
          "3296:    } else if(pi->key_val == 20) {",
          "3298:     comment = g_strdup_printf(\"Key Input Sent: S0 (%d)\", pi->sequence);",
          "3299:    } else if(pi->key_val == 21) {",
          "3301:     comment = g_strdup_printf(\"Key Input Sent: S1 (%d)\", pi->sequence);",
          "3302:    } else if(pi->key_val == 22) {",
          "3305:     if(pi->key_buffer != NULL) {",
          "3308:      g_string_assign(g_tmp,pi->key_buffer);",
          "3311:      g_string_truncate(g_tmp,g_tmp->len-1);",
          "3314:      tmp_unistim_info->key_buffer = g_strdup(g_tmp->str);",
          "3315:     }",
          "3318:     comment = g_strdup_printf(\"Key Input Sent: S2 (%d)\", pi->sequence);",
          "3319:    } else if(pi->key_val == 28) {",
          "3321:     comment = g_strdup_printf(\"Key Input Sent: Release (%d)\", pi->sequence);",
          "3322:    } else if(pi->key_val == 23) {",
          "3326:     tmp_unistim_info->key_buffer = g_strdup(\"\\n\");",
          "3329:     comment = g_strdup_printf(\"Key Input Sent: S3 (%d)\", pi->sequence);",
          "3330:    } else if(pi->key_val == 27) {",
          "3332:     comment = g_strdup_printf(\"Key Input Sent: Hold (%d)\", pi->sequence);",
          "3333:    } else if(pi->key_val == 29) {",
          "3335:     comment = g_strdup_printf(\"Key Input Sent: Mute (%d)\", pi->sequence);",
          "3336:    } else if(pi->key_val == 30) {",
          "3338:     comment = g_strdup_printf(\"Key Input Sent: Headset (%d)\", pi->sequence);",
          "3339:    } else if(pi->key_val == 31) {",
          "3341:     comment = g_strdup_printf(\"Key Input Sent: Handsfree (%d)\", pi->sequence);",
          "3342:    } else if(pi->key_val >= 32 && pi->key_val <= 56) {",
          "3344:     comment = g_strdup_printf(\"Key Input Sent: Prog%d (%d)\", (pi->key_val & 31), pi->sequence);",
          "3345:    }",
          "3347:    if(pi->key_val != -1) {",
          "3349:     frame_label = \"KEY INPUT\";",
          "3351:     if (comment == NULL)",
          "3354:      comment = g_strdup_printf(\"Key Input Sent: UNKNOWN - %d (%d)\", pi->key_val, pi->sequence);",
          "3357:     add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3359:     g_free(comment);",
          "3360:    }",
          "3362:    if(pi->hook_state == 1) {",
          "3365:     frame_label = \"OFF HOOK\";",
          "3366:     comment = g_strdup_printf(\"Off Hook (%d)\", pi->sequence);",
          "3369:     add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3371:     g_free(comment);",
          "3372:    } else if(pi->hook_state == 0) {",
          "3375:     frame_label = \"ON HOOK\";",
          "3376:     comment = g_strdup_printf(\"On Hook (%d)\", pi->sequence);",
          "3379:     add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3381:     g_free(comment);",
          "3382:    }",
          "3383:   }",
          "3386:   if(pi->stream_connect == 1 && callsinfo != NULL) {",
          "3391:    callsinfo->start_fd=pinfo->fd;",
          "3392:    callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3395:    callsinfo->stop_fd = pinfo->fd;",
          "3396:    callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3399:    ++(callsinfo->npackets);",
          "3402:    ++(tapinfo->npackets);",
          "3405:       Call control protocol, we can only guess at the destination by messing with",
          "3407:    if(tmp_unistim_info->key_buffer != NULL) {",
          "3408:     callsinfo->to_identity = g_strdup_printf(\"?? %s\",tmp_unistim_info->key_buffer);",
          "3409:    }",
          "3412:    tmp_unistim_info->sequence = pi->sequence;",
          "3415:    callsinfo->call_active_state = VOIP_ACTIVE;",
          "3416:    callsinfo->call_state = VOIP_IN_CALL;",
          "3419:    frame_label = \"STREAM OPENED\";",
          "3420:    comment = g_strdup_printf(\"Stream Opened (%d)\",pi->sequence);",
          "3423:    add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3425:   } else if(pi->stream_connect == 1 && callsinfo == NULL) {",
          "3432:    callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3433:    callsinfo->call_active_state = VOIP_ACTIVE;",
          "3434:    callsinfo->call_state = VOIP_CALL_SETUP;",
          "3435:    callsinfo->from_identity=g_strdup(\"UNKNOWN\");",
          "3436:    callsinfo->to_identity=g_strdup(\"UNKNOWN\");",
          "3437:    COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "3438:    callsinfo->selected=FALSE;",
          "3442:    callsinfo->start_fd=pinfo->fd;",
          "3443:    callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3445:    callsinfo->protocol=VOIP_UNISTIM;",
          "3446:    callsinfo->prot_info=g_malloc(sizeof(unistim_info_t));",
          "3448:    tmp_unistim_info = (unistim_info_t *)callsinfo->prot_info;",
          "3451:    tmp_unistim_info->rudp_type = 0;",
          "3452:    tmp_unistim_info->payload_type = 0;",
          "3453:    tmp_unistim_info->sequence = pi->sequence;",
          "3454:    tmp_unistim_info->termid = 0;",
          "3455:    tmp_unistim_info->key_val = -1;",
          "3456:    tmp_unistim_info->key_state = -1;",
          "3457:    tmp_unistim_info->hook_state = -1;",
          "3458:    tmp_unistim_info->stream_connect = -1;",
          "3459:    tmp_unistim_info->trans_connect = -1;",
          "3460:    tmp_unistim_info->set_termid = -1;",
          "3461:    tmp_unistim_info->string_data = NULL;",
          "3462:    tmp_unistim_info->key_buffer = NULL;",
          "3464:    COPY_ADDRESS(&(tmp_unistim_info->it_ip),&(pi->it_ip));",
          "3465:    COPY_ADDRESS(&(tmp_unistim_info->ni_ip),&(pi->ni_ip));",
          "3466:    tmp_unistim_info->it_port = pi->it_port;",
          "3468:    callsinfo->free_prot_info = g_free;",
          "3469:    callsinfo->npackets = 0;",
          "3470:    callsinfo->call_num = tapinfo->ncalls++;",
          "3471:    g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3476:    callsinfo->stop_fd = pinfo->fd;",
          "3477:    callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3479:    ++(callsinfo->npackets);",
          "3482:    ++(tapinfo->npackets);",
          "3485:       Call control protocol, we can only guess at the destination by messing with",
          "3487:    if(tmp_unistim_info->key_buffer != NULL) {",
          "3488:     callsinfo->to_identity = g_strdup_printf(\"?? %s\",tmp_unistim_info->key_buffer);",
          "3489:    }",
          "3492:    tmp_unistim_info->sequence = pi->sequence;",
          "3495:    callsinfo->call_active_state = VOIP_ACTIVE;",
          "3496:    callsinfo->call_state = VOIP_IN_CALL;",
          "3499:    frame_label = \"STREAM OPENED\";",
          "3500:    comment = g_strdup_printf(\"Stream Opened (%d)\",pi->sequence);",
          "3503:    add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3505:   } else if(pi->stream_connect == 0 && callsinfo != NULL) {",
          "3510:    callsinfo->stop_fd = pinfo->fd;",
          "3511:    callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3513:    tmp_unistim_info->sequence = pi->sequence;",
          "3515:    if(callsinfo->call_state == VOIP_IN_CALL) {",
          "3516:     callsinfo->call_active_state = VOIP_INACTIVE;",
          "3517:     callsinfo->call_state = VOIP_COMPLETED;",
          "3518:    } else {",
          "3519:     callsinfo->call_state = VOIP_UNKNOWN;",
          "3520:     callsinfo->call_active_state = VOIP_INACTIVE;",
          "3521:    }",
          "3523:    frame_label = \"STREAM CLOSED\";",
          "3524:    comment = g_strdup_printf(\"Stream Closed (%d)\",pi->sequence);",
          "3527:    add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3529:   } else",
          "3530:    comment = NULL;",
          "3532:  } else if(pi->rudp_type == 1 && callsinfo != NULL) {",
          "3535:   if(tmp_unistim_info->sequence == pi->sequence) {",
          "3537:    frame_label = \"ACK\";",
          "3538:    comment = g_strdup_printf(\"ACK for sequence %d\",pi->sequence);",
          "3541:    add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3543:   }",
          "3545:  } else if(pi->rudp_type == 0 && callsinfo != NULL) {",
          "3548:   frame_label = \"NAK\";",
          "3549:   comment = g_strdup_printf(\"NAK for sequence %d\",pi->sequence);",
          "3552:   add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3554:  }",
          "3557:  g_free(comment);",
          "3559:  tapinfo->redraw = TRUE;",
          "3561:  return 1;",
          "",
          "[Added Lines]",
          "3099:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_unistim_);",
          "3100:     voip_calls_info_t *tmp_listinfo;",
          "3101:     voip_calls_info_t *callsinfo = NULL;",
          "3102:     unistim_info_t *tmp_unistim_info = NULL;",
          "3103:     GList *list = NULL;",
          "3104:     GString *g_tmp = NULL;",
          "3105:     const gchar *frame_label = NULL;",
          "3106:     gchar *comment = NULL;",
          "3109:     const unistim_info_t *pi = (const unistim_info_t *)unistim_info;",
          "3112:     g_tmp = g_string_new(NULL);",
          "3115:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3117:     while(list)",
          "3118:     {",
          "3119:         tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3121:         if(tmp_listinfo->protocol == VOIP_UNISTIM) {",
          "3123:             tmp_unistim_info = (unistim_info_t *)tmp_listinfo->prot_info;",
          "3126:             if(pi->termid != 0) {",
          "3127:                 if(tmp_unistim_info->termid == pi->termid) {",
          "3129:                     if(tmp_listinfo->call_state == VOIP_COMPLETED || tmp_listinfo->call_state == VOIP_UNKNOWN) {",
          "3131:                     } else {",
          "3132:                         callsinfo = (voip_calls_info_t*)(list->data);",
          "3133:                         break;",
          "3134:                     }",
          "3135:                 }",
          "3136:             } else {",
          "3138:                 if(ADDRESSES_EQUAL(&tmp_unistim_info->it_ip, &pinfo->dst) && ADDRESSES_EQUAL(&tmp_unistim_info->ni_ip,&pinfo->src) && (tmp_unistim_info->it_port == pinfo->destport)) {",
          "3139:                     if(tmp_listinfo->call_state == VOIP_COMPLETED || tmp_listinfo->call_state == VOIP_UNKNOWN) {",
          "3141:                     } else {",
          "3142:                         callsinfo = (voip_calls_info_t*)(list->data);",
          "3143:                         break;",
          "3144:                     }",
          "3145:                 }",
          "3146:                 else if(ADDRESSES_EQUAL(&tmp_unistim_info->it_ip, &pinfo->src) && ADDRESSES_EQUAL(&tmp_unistim_info->ni_ip,&pinfo->dst) && (tmp_unistim_info->it_port == pinfo->srcport)) {",
          "3147:                     if(tmp_listinfo->call_state == VOIP_COMPLETED || tmp_listinfo->call_state == VOIP_UNKNOWN) {",
          "3149:                     } else {",
          "3150:                         callsinfo = (voip_calls_info_t*)(list->data);",
          "3151:                         break;",
          "3152:                     }",
          "3153:                 }",
          "3154:             }",
          "3155:         }",
          "3158:         list = g_list_next(list);",
          "3159:     }",
          "3161:     if(pi->payload_type == 2 || pi->payload_type == 1) {",
          "3163:         if(pi->key_state == 1 || pi->hook_state == 1) {",
          "3169:             if (callsinfo==NULL) {",
          "3171:                 callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3172:                 callsinfo->call_active_state = VOIP_ACTIVE;",
          "3173:                 callsinfo->call_state = VOIP_CALL_SETUP;",
          "3174:                 callsinfo->from_identity=g_strdup_printf(\"%x\",pi->termid);",
          "3175:                 callsinfo->to_identity=g_strdup(\"UNKNOWN\");",
          "3176:                 COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "3177:                 callsinfo->selected=FALSE;",
          "3182:                 callsinfo->start_fd=pinfo->fd;",
          "3183:                 callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3185:                 callsinfo->protocol=VOIP_UNISTIM;",
          "3186:                 callsinfo->prot_info=g_malloc(sizeof(unistim_info_t));",
          "3188:                 tmp_unistim_info = (unistim_info_t *)callsinfo->prot_info;",
          "3191:                 tmp_unistim_info->rudp_type = 0;",
          "3192:                 tmp_unistim_info->payload_type = 0;",
          "3193:                 tmp_unistim_info->sequence = pi->sequence;",
          "3194:                 tmp_unistim_info->termid = pi->termid;",
          "3195:                 tmp_unistim_info->key_val = -1;",
          "3196:                 tmp_unistim_info->key_state = -1;",
          "3197:                 tmp_unistim_info->hook_state = -1;",
          "3198:                 tmp_unistim_info->stream_connect = -1;",
          "3199:                 tmp_unistim_info->trans_connect = -1;",
          "3200:                 tmp_unistim_info->set_termid = -1;",
          "3201:                 tmp_unistim_info->string_data = NULL;",
          "3202:                 tmp_unistim_info->key_buffer = NULL;",
          "3204:                 COPY_ADDRESS(&(tmp_unistim_info->it_ip),&(pi->it_ip));",
          "3205:                 COPY_ADDRESS(&(tmp_unistim_info->ni_ip),&(pi->ni_ip));",
          "3206:                 tmp_unistim_info->it_port = pi->it_port;",
          "3208:                 callsinfo->free_prot_info = g_free;",
          "3209:                 callsinfo->npackets = 0;",
          "3210:                 callsinfo->call_num = tapinfo->ncalls++;",
          "3211:                 g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3213:             } else {",
          "3216:                 tmp_unistim_info = (unistim_info_t *)callsinfo->prot_info;",
          "3217:                 tmp_unistim_info->sequence = pi->sequence;",
          "3218:             }",
          "3222:             callsinfo->stop_fd = pinfo->fd;",
          "3223:             callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3226:             ++(callsinfo->npackets);",
          "3229:             ++(tapinfo->npackets);",
          "3232:             if(pi->key_val >= 0 && pi->key_val <= 11) {",
          "3234:                 if(tmp_unistim_info->key_buffer != NULL) {",
          "3237:                     g_string_assign(g_tmp,tmp_unistim_info->key_buffer);",
          "3240:                     if(pi->key_val == 10) {",
          "3241:                         tmp_unistim_info->key_buffer = g_strdup_printf(\"%s*\",g_tmp->str);",
          "3242:                     } else if(pi->key_val == 11) {",
          "3243:                         tmp_unistim_info->key_buffer = g_strdup_printf(\"%s#\",g_tmp->str);",
          "3244:                     } else {",
          "3245:                         tmp_unistim_info->key_buffer = g_strdup_printf(\"%s%d\",g_tmp->str,pi->key_val);",
          "3246:                     }",
          "3248:                 } else {",
          "3251:                     if(pi->key_val == 10) {",
          "3252:                         tmp_unistim_info->key_buffer = g_strdup(\"*\");",
          "3253:                     } else if(pi->key_val == 11) {",
          "3254:                         tmp_unistim_info->key_buffer = g_strdup(\"#\");",
          "3255:                     } else {",
          "3256:                         tmp_unistim_info->key_buffer = g_strdup_printf(\"%d\",pi->key_val);",
          "3257:                     }",
          "3259:                 }",
          "3262:                 if(pi->key_val == 10) {",
          "3263:                     comment = g_strdup_printf(\"Key Input Sent: * (%d)\", pi->sequence);",
          "3264:                 } else if(pi->key_val == 11) {",
          "3265:                     comment = g_strdup_printf(\"Key Input Sent: # (%d)\", pi->sequence);",
          "3266:                 } else {",
          "3267:                     comment = g_strdup_printf(\"Key Input Sent: %d (%d)\",pi->key_val, pi->sequence);",
          "3268:                 }",
          "3269:             } else if(pi->key_val == 12) {",
          "3271:                 comment = g_strdup_printf(\"Key Input Sent: UP (%d)\", pi->sequence);",
          "3272:             } else if(pi->key_val == 13) {",
          "3274:                 comment = g_strdup_printf(\"Key Input Sent: DOWN (%d)\", pi->sequence);",
          "3275:             } else if(pi->key_val == 14) {",
          "3277:                 comment = g_strdup_printf(\"Key Input Sent: RIGHT (%d)\", pi->sequence);",
          "3278:             } else if(pi->key_val == 15) {",
          "3279:                 if(pi->key_buffer != NULL) {",
          "3281:                     g_string_assign(g_tmp,pi->key_buffer);",
          "3284:                     g_string_truncate(g_tmp,g_tmp->len-1);",
          "3287:                     tmp_unistim_info->key_buffer = g_strdup(g_tmp->str);",
          "3288:                 }",
          "3291:                 comment = g_strdup_printf(\"Key Input Sent: LEFT (%d)\", pi->sequence);",
          "3292:             } else if(pi->key_val == 20) {",
          "3294:                 comment = g_strdup_printf(\"Key Input Sent: S0 (%d)\", pi->sequence);",
          "3295:             } else if(pi->key_val == 21) {",
          "3297:                 comment = g_strdup_printf(\"Key Input Sent: S1 (%d)\", pi->sequence);",
          "3298:             } else if(pi->key_val == 22) {",
          "3301:                 if(pi->key_buffer != NULL) {",
          "3304:                     g_string_assign(g_tmp,pi->key_buffer);",
          "3307:                     g_string_truncate(g_tmp,g_tmp->len-1);",
          "3310:                     tmp_unistim_info->key_buffer = g_strdup(g_tmp->str);",
          "3311:                 }",
          "3314:                 comment = g_strdup_printf(\"Key Input Sent: S2 (%d)\", pi->sequence);",
          "3315:             } else if(pi->key_val == 28) {",
          "3317:                 comment = g_strdup_printf(\"Key Input Sent: Release (%d)\", pi->sequence);",
          "3318:             } else if(pi->key_val == 23) {",
          "3322:                 tmp_unistim_info->key_buffer = g_strdup(\"\\n\");",
          "3325:                 comment = g_strdup_printf(\"Key Input Sent: S3 (%d)\", pi->sequence);",
          "3326:             } else if(pi->key_val == 27) {",
          "3328:                 comment = g_strdup_printf(\"Key Input Sent: Hold (%d)\", pi->sequence);",
          "3329:             } else if(pi->key_val == 29) {",
          "3331:                 comment = g_strdup_printf(\"Key Input Sent: Mute (%d)\", pi->sequence);",
          "3332:             } else if(pi->key_val == 30) {",
          "3334:                 comment = g_strdup_printf(\"Key Input Sent: Headset (%d)\", pi->sequence);",
          "3335:             } else if(pi->key_val == 31) {",
          "3337:                 comment = g_strdup_printf(\"Key Input Sent: Handsfree (%d)\", pi->sequence);",
          "3338:             } else if(pi->key_val >= 32 && pi->key_val <= 56) {",
          "3340:                 comment = g_strdup_printf(\"Key Input Sent: Prog%d (%d)\", (pi->key_val & 31), pi->sequence);",
          "3341:             }",
          "3343:             if(pi->key_val != -1) {",
          "3345:                 frame_label = \"KEY INPUT\";",
          "3347:                 if (comment == NULL)",
          "3350:                     comment = g_strdup_printf(\"Key Input Sent: UNKNOWN - %d (%d)\", pi->key_val, pi->sequence);",
          "3353:                 add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3355:                 g_free(comment);",
          "3356:             }",
          "3358:             if(pi->hook_state == 1) {",
          "3361:                 frame_label = \"OFF HOOK\";",
          "3362:                 comment = g_strdup_printf(\"Off Hook (%d)\", pi->sequence);",
          "3365:                 add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3367:                 g_free(comment);",
          "3368:             } else if(pi->hook_state == 0) {",
          "3371:                 frame_label = \"ON HOOK\";",
          "3372:                 comment = g_strdup_printf(\"On Hook (%d)\", pi->sequence);",
          "3375:                 add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3377:                 g_free(comment);",
          "3378:             }",
          "3379:         }",
          "3382:         if(pi->stream_connect == 1 && callsinfo != NULL) {",
          "3387:             callsinfo->start_fd=pinfo->fd;",
          "3388:             callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3391:             callsinfo->stop_fd = pinfo->fd;",
          "3392:             callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3395:             ++(callsinfo->npackets);",
          "3398:             ++(tapinfo->npackets);",
          "3401:                Call control protocol, we can only guess at the destination by messing with",
          "3403:             if(tmp_unistim_info->key_buffer != NULL) {",
          "3404:                 callsinfo->to_identity = g_strdup_printf(\"?? %s\",tmp_unistim_info->key_buffer);",
          "3405:             }",
          "3408:             tmp_unistim_info->sequence = pi->sequence;",
          "3411:             callsinfo->call_active_state = VOIP_ACTIVE;",
          "3412:             callsinfo->call_state = VOIP_IN_CALL;",
          "3415:             frame_label = \"STREAM OPENED\";",
          "3416:             comment = g_strdup_printf(\"Stream Opened (%d)\",pi->sequence);",
          "3419:             add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3421:         } else if(pi->stream_connect == 1 && callsinfo == NULL) {",
          "3428:             callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3429:             callsinfo->call_active_state = VOIP_ACTIVE;",
          "3430:             callsinfo->call_state = VOIP_CALL_SETUP;",
          "3431:             callsinfo->from_identity=g_strdup(\"UNKNOWN\");",
          "3432:             callsinfo->to_identity=g_strdup(\"UNKNOWN\");",
          "3433:             COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "3434:             callsinfo->selected=FALSE;",
          "3438:             callsinfo->start_fd=pinfo->fd;",
          "3439:             callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3441:             callsinfo->protocol=VOIP_UNISTIM;",
          "3442:             callsinfo->prot_info=g_malloc(sizeof(unistim_info_t));",
          "3444:             tmp_unistim_info = (unistim_info_t *)callsinfo->prot_info;",
          "3447:             tmp_unistim_info->rudp_type = 0;",
          "3448:             tmp_unistim_info->payload_type = 0;",
          "3449:             tmp_unistim_info->sequence = pi->sequence;",
          "3450:             tmp_unistim_info->termid = 0;",
          "3451:             tmp_unistim_info->key_val = -1;",
          "3452:             tmp_unistim_info->key_state = -1;",
          "3453:             tmp_unistim_info->hook_state = -1;",
          "3454:             tmp_unistim_info->stream_connect = -1;",
          "3455:             tmp_unistim_info->trans_connect = -1;",
          "3456:             tmp_unistim_info->set_termid = -1;",
          "3457:             tmp_unistim_info->string_data = NULL;",
          "3458:             tmp_unistim_info->key_buffer = NULL;",
          "3460:             COPY_ADDRESS(&(tmp_unistim_info->it_ip),&(pi->it_ip));",
          "3461:             COPY_ADDRESS(&(tmp_unistim_info->ni_ip),&(pi->ni_ip));",
          "3462:             tmp_unistim_info->it_port = pi->it_port;",
          "3464:             callsinfo->free_prot_info = g_free;",
          "3465:             callsinfo->npackets = 0;",
          "3466:             callsinfo->call_num = tapinfo->ncalls++;",
          "3467:             g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3472:             callsinfo->stop_fd = pinfo->fd;",
          "3473:             callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3475:             ++(callsinfo->npackets);",
          "3478:             ++(tapinfo->npackets);",
          "3481:                Call control protocol, we can only guess at the destination by messing with",
          "3483:             if(tmp_unistim_info->key_buffer != NULL) {",
          "3484:                 callsinfo->to_identity = g_strdup_printf(\"?? %s\",tmp_unistim_info->key_buffer);",
          "3485:             }",
          "3488:             tmp_unistim_info->sequence = pi->sequence;",
          "3491:             callsinfo->call_active_state = VOIP_ACTIVE;",
          "3492:             callsinfo->call_state = VOIP_IN_CALL;",
          "3495:             frame_label = \"STREAM OPENED\";",
          "3496:             comment = g_strdup_printf(\"Stream Opened (%d)\",pi->sequence);",
          "3499:             add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3501:         } else if(pi->stream_connect == 0 && callsinfo != NULL) {",
          "3506:             callsinfo->stop_fd = pinfo->fd;",
          "3507:             callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3509:             tmp_unistim_info->sequence = pi->sequence;",
          "3511:             if(callsinfo->call_state == VOIP_IN_CALL) {",
          "3512:                 callsinfo->call_active_state = VOIP_INACTIVE;",
          "3513:                 callsinfo->call_state = VOIP_COMPLETED;",
          "3514:             } else {",
          "3515:                 callsinfo->call_state = VOIP_UNKNOWN;",
          "3516:                 callsinfo->call_active_state = VOIP_INACTIVE;",
          "3517:             }",
          "3519:             frame_label = \"STREAM CLOSED\";",
          "3520:             comment = g_strdup_printf(\"Stream Closed (%d)\",pi->sequence);",
          "3523:             add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3525:         } else",
          "3526:             comment = NULL;",
          "3528:     } else if(pi->rudp_type == 1 && callsinfo != NULL) {",
          "3531:         if(tmp_unistim_info->sequence == pi->sequence) {",
          "3533:             frame_label = \"ACK\";",
          "3534:             comment = g_strdup_printf(\"ACK for sequence %d\",pi->sequence);",
          "3537:             add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3539:         }",
          "3541:     } else if(pi->rudp_type == 0 && callsinfo != NULL) {",
          "3544:         frame_label = \"NAK\";",
          "3545:         comment = g_strdup_printf(\"NAK for sequence %d\",pi->sequence);",
          "3548:         add_to_graph(tapinfo, pinfo, edt, frame_label, comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3550:     }",
          "3553:     g_free(comment);",
          "3555:     tapinfo->redraw = TRUE;",
          "3557:     return 1;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3567: void",
          "3568: unistim_calls_init_tap(voip_calls_tapinfo_t *tap_id_base) {",
          "3585: }",
          "3588: void",
          "3589: remove_tap_listener_unistim_calls(voip_calls_tapinfo_t *tap_id_base)",
          "3590: {",
          "3592: }",
          "",
          "[Removed Lines]",
          "3570:  GString *error_string;",
          "3572:  error_string = register_tap_listener(\"unistim\", tap_base_to_id(tap_id_base, tap_id_offset_unistim_),",
          "3573:   NULL,",
          "3574:   0,",
          "3575:   voip_calls_dlg_reset,",
          "3576:   unistim_calls_packet,",
          "3577:   voip_calls_dlg_draw",
          "3578:   );",
          "3580:  if (error_string != NULL) {",
          "3581:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3582:          \"%s\", error_string->str);",
          "3583:   g_string_free(error_string, TRUE);",
          "3584:  }",
          "3591:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_unistim_));",
          "",
          "[Added Lines]",
          "3566:     GString *error_string;",
          "3568:     error_string = register_tap_listener(\"unistim\", tap_base_to_id(tap_id_base, tap_id_offset_unistim_),",
          "3569:             NULL,",
          "3570:             0,",
          "3571:             voip_calls_dlg_reset,",
          "3572:             unistim_calls_packet,",
          "3573:             voip_calls_dlg_draw",
          "3574:             );",
          "3576:     if (error_string != NULL) {",
          "3577:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3578:                 \"%s\", error_string->str);",
          "3579:         g_string_free(error_string, TRUE);",
          "3580:     }",
          "3587:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_unistim_));",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3599: static const voip_call_state skinny_tap_voip_state[] = {",
          "3615: };",
          "3617: static int",
          "3618: skinny_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *skinny_info)",
          "3619: {",
          "3709: }",
          "",
          "[Removed Lines]",
          "3600:  VOIP_NO_STATE,",
          "3601:  VOIP_CALL_SETUP,",
          "3602:  VOIP_COMPLETED,",
          "3603:  VOIP_RINGING,",
          "3604:  VOIP_RINGING,",
          "3605:  VOIP_IN_CALL,",
          "3606:  VOIP_REJECTED,",
          "3607:  VOIP_REJECTED,",
          "3608:  VOIP_IN_CALL,",
          "3609:  VOIP_IN_CALL,",
          "3610:  VOIP_COMPLETED,",
          "3611:  VOIP_COMPLETED,",
          "3612:  VOIP_CALL_SETUP,",
          "3613:  VOIP_UNKNOWN,",
          "3614:  VOIP_REJECTED",
          "3620:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_skinny_);",
          "3621:  GList* list;",
          "3622:  voip_calls_info_t *callsinfo = NULL;",
          "3623:  address* phone;",
          "3624:  const skinny_info_t *si = (const skinny_info_t *)skinny_info;",
          "3625:  skinny_calls_info_t *tmp_skinnyinfo;",
          "3626:  gchar *comment;",
          "3628:  if (si == NULL || (si->callId == 0 && si->passThruId == 0))",
          "3629:   return 0;",
          "3631:  list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3632:  while (list)",
          "3633:  {",
          "3634:   voip_calls_info_t* tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3635:   if (tmp_listinfo->protocol == VOIP_SKINNY) {",
          "3636:    tmp_skinnyinfo = (skinny_calls_info_t *)tmp_listinfo->prot_info;",
          "3637:    if (tmp_skinnyinfo->callId == si->callId ||",
          "3638:        tmp_skinnyinfo->callId == si->passThruId) {",
          "3639:     callsinfo = (voip_calls_info_t*)(list->data);",
          "3640:     break;",
          "3641:    }",
          "3642:   }",
          "3643:   list = g_list_next (list);",
          "3644:  }",
          "3646:  if (si->messId >= 256)",
          "3647:   phone = &(pinfo->dst);",
          "3648:  else",
          "3649:   phone = &(pinfo->src);",
          "3651:  if (callsinfo==NULL) {",
          "3652:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3653:   callsinfo->call_state = VOIP_NO_STATE;",
          "3654:   callsinfo->call_active_state = VOIP_ACTIVE;",
          "3656:   callsinfo->from_identity = g_strdup(\"\");",
          "3657:   callsinfo->to_identity = g_strdup(\"\");",
          "3658:   callsinfo->prot_info = g_malloc(sizeof(skinny_calls_info_t));",
          "3659:   callsinfo->free_prot_info = g_free;",
          "3660:   tmp_skinnyinfo = (skinny_calls_info_t *)callsinfo->prot_info;",
          "3661:   tmp_skinnyinfo->callId = si->callId ? si->callId : si->passThruId;",
          "3662:   callsinfo->npackets = 1;",
          "3664:   COPY_ADDRESS(&(callsinfo->initial_speaker), phone);",
          "3666:   callsinfo->protocol = VOIP_SKINNY;",
          "3667:   callsinfo->call_num = tapinfo->ncalls++;",
          "3668:   callsinfo->start_fd = pinfo->fd;",
          "3669:   callsinfo->start_rel_ts = pinfo->rel_ts;",
          "3670:   callsinfo->stop_fd = pinfo->fd;",
          "3671:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3673:   callsinfo->selected = FALSE;",
          "3674:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3675:  } else {",
          "3676:   if (si->callingParty) {",
          "3677:    g_free(callsinfo->from_identity);",
          "3678:    callsinfo->from_identity = g_strdup(si->callingParty);",
          "3679:   }",
          "3680:   if (si->calledParty) {",
          "3681:    g_free(callsinfo->to_identity);",
          "3682:    callsinfo->to_identity =  g_strdup(si->calledParty);",
          "3683:   }",
          "3684:   if ((si->callState > 0) && (si->callState < (sizeof(skinny_tap_voip_state)/sizeof(skinny_tap_voip_state[0]))))",
          "3685:    callsinfo->call_state = skinny_tap_voip_state[si->callState];",
          "3687:   callsinfo->stop_fd = pinfo->fd;",
          "3688:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3689:   ++(callsinfo->npackets);",
          "3690:  }",
          "3692:  if (si->callId) {",
          "3693:   if (si->passThruId)",
          "3694:    comment = g_strdup_printf(\"CallId = %u, PTId = %u\", si->callId, si->passThruId);",
          "3695:   else",
          "3696:    comment = g_strdup_printf(\"CallId = %u, LineId = %u\", si->callId, si->lineId);",
          "3697:  } else {",
          "3698:   if (si->passThruId)",
          "3699:    comment = g_strdup_printf(\"PTId = %u\", si->passThruId);",
          "3700:   else",
          "3701:    comment = NULL;",
          "3702:  }",
          "3704:  add_to_graph(tapinfo, pinfo, edt, si->messageName, comment,",
          "3705:      callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3706:  g_free(comment);",
          "3708:  return 1;",
          "",
          "[Added Lines]",
          "3596:     VOIP_NO_STATE,",
          "3597:     VOIP_CALL_SETUP,",
          "3598:     VOIP_COMPLETED,",
          "3599:     VOIP_RINGING,",
          "3600:     VOIP_RINGING,",
          "3601:     VOIP_IN_CALL,",
          "3602:     VOIP_REJECTED,",
          "3603:     VOIP_REJECTED,",
          "3604:     VOIP_IN_CALL,",
          "3605:     VOIP_IN_CALL,",
          "3606:     VOIP_COMPLETED,",
          "3607:     VOIP_COMPLETED,",
          "3608:     VOIP_CALL_SETUP,",
          "3609:     VOIP_UNKNOWN,",
          "3610:     VOIP_REJECTED",
          "3616:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_skinny_);",
          "3617:     GList* list;",
          "3618:     voip_calls_info_t *callsinfo = NULL;",
          "3619:     address* phone;",
          "3620:     const skinny_info_t *si = (const skinny_info_t *)skinny_info;",
          "3621:     skinny_calls_info_t *tmp_skinnyinfo;",
          "3622:     gchar *comment;",
          "3624:     if (si == NULL || (si->callId == 0 && si->passThruId == 0))",
          "3625:         return 0;",
          "3627:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3628:     while (list)",
          "3629:     {",
          "3630:         voip_calls_info_t* tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3631:         if (tmp_listinfo->protocol == VOIP_SKINNY) {",
          "3632:             tmp_skinnyinfo = (skinny_calls_info_t *)tmp_listinfo->prot_info;",
          "3633:             if (tmp_skinnyinfo->callId == si->callId ||",
          "3634:                     tmp_skinnyinfo->callId == si->passThruId) {",
          "3635:                 callsinfo = (voip_calls_info_t*)(list->data);",
          "3636:                 break;",
          "3637:             }",
          "3638:         }",
          "3639:         list = g_list_next (list);",
          "3640:     }",
          "3642:     if (si->messId >= 256)",
          "3643:         phone = &(pinfo->dst);",
          "3644:     else",
          "3645:         phone = &(pinfo->src);",
          "3647:     if (callsinfo==NULL) {",
          "3648:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3649:         callsinfo->call_state = VOIP_NO_STATE;",
          "3650:         callsinfo->call_active_state = VOIP_ACTIVE;",
          "3652:         callsinfo->from_identity = g_strdup(\"\");",
          "3653:         callsinfo->to_identity = g_strdup(\"\");",
          "3654:         callsinfo->prot_info = g_malloc(sizeof(skinny_calls_info_t));",
          "3655:         callsinfo->free_prot_info = g_free;",
          "3656:         tmp_skinnyinfo = (skinny_calls_info_t *)callsinfo->prot_info;",
          "3657:         tmp_skinnyinfo->callId = si->callId ? si->callId : si->passThruId;",
          "3658:         callsinfo->npackets = 1;",
          "3660:         COPY_ADDRESS(&(callsinfo->initial_speaker), phone);",
          "3662:         callsinfo->protocol = VOIP_SKINNY;",
          "3663:         callsinfo->call_num = tapinfo->ncalls++;",
          "3664:         callsinfo->start_fd = pinfo->fd;",
          "3665:         callsinfo->start_rel_ts = pinfo->rel_ts;",
          "3666:         callsinfo->stop_fd = pinfo->fd;",
          "3667:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3669:         callsinfo->selected = FALSE;",
          "3670:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3671:     } else {",
          "3672:         if (si->callingParty) {",
          "3673:             g_free(callsinfo->from_identity);",
          "3674:             callsinfo->from_identity = g_strdup(si->callingParty);",
          "3675:         }",
          "3676:         if (si->calledParty) {",
          "3677:             g_free(callsinfo->to_identity);",
          "3678:             callsinfo->to_identity =  g_strdup(si->calledParty);",
          "3679:         }",
          "3680:         if ((si->callState > 0) && (si->callState < (sizeof(skinny_tap_voip_state)/sizeof(skinny_tap_voip_state[0]))))",
          "3681:             callsinfo->call_state = skinny_tap_voip_state[si->callState];",
          "3683:         callsinfo->stop_fd = pinfo->fd;",
          "3684:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3685:         ++(callsinfo->npackets);",
          "3686:     }",
          "3688:     if (si->callId) {",
          "3689:         if (si->passThruId)",
          "3690:             comment = g_strdup_printf(\"CallId = %u, PTId = %u\", si->callId, si->passThruId);",
          "3691:         else",
          "3692:             comment = g_strdup_printf(\"CallId = %u, LineId = %u\", si->callId, si->lineId);",
          "3693:     } else {",
          "3694:         if (si->passThruId)",
          "3695:             comment = g_strdup_printf(\"PTId = %u\", si->passThruId);",
          "3696:         else",
          "3697:             comment = NULL;",
          "3698:     }",
          "3700:     add_to_graph(tapinfo, pinfo, edt, si->messageName, comment,",
          "3701:             callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3702:     g_free(comment);",
          "3704:     return 1;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3715: void",
          "3716: skinny_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "3717: {",
          "3739: }",
          "3742: void",
          "3743: remove_tap_listener_skinny_calls(voip_calls_tapinfo_t *tap_id_base)",
          "3744: {",
          "3746: }",
          "",
          "[Removed Lines]",
          "3718:  GString *error_string;",
          "3726:  error_string = register_tap_listener(\"skinny\",",
          "3727:   tap_base_to_id(tap_id_base, tap_id_offset_skinny_),",
          "3728:   NULL,",
          "3729:   TL_REQUIRES_PROTO_TREE,",
          "3730:   voip_calls_dlg_reset,",
          "3731:   skinny_calls_packet,",
          "3732:   voip_calls_dlg_draw",
          "3733:   );",
          "3734:  if (error_string != NULL) {",
          "3735:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3736:          \"%s\", error_string->str);",
          "3737:   g_string_free(error_string, TRUE);",
          "3738:  }",
          "3745:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_skinny_));",
          "",
          "[Added Lines]",
          "3714:     GString *error_string;",
          "3722:     error_string = register_tap_listener(\"skinny\",",
          "3723:             tap_base_to_id(tap_id_base, tap_id_offset_skinny_),",
          "3724:             NULL,",
          "3725:             TL_REQUIRES_PROTO_TREE,",
          "3726:             voip_calls_dlg_reset,",
          "3727:             skinny_calls_packet,",
          "3728:             voip_calls_dlg_draw",
          "3729:             );",
          "3730:     if (error_string != NULL) {",
          "3731:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3732:                 \"%s\", error_string->str);",
          "3733:         g_string_free(error_string, TRUE);",
          "3734:     }",
          "3741:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_skinny_));",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3752: static void free_iax2_info(gpointer p) {",
          "3756: }",
          "",
          "[Removed Lines]",
          "3753:  iax2_info_t *ii = (iax2_info_t *)p;",
          "3755:  g_free(ii);",
          "",
          "[Added Lines]",
          "3749:     iax2_info_t *ii = (iax2_info_t *)p;",
          "3751:     g_free(ii);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3761: static int",
          "3762: iax2_calls_packet( void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *iax2_info)",
          "3763: {",
          "3835: }",
          "",
          "[Removed Lines]",
          "3764:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_iax2_);",
          "3765:  GList* list;",
          "3766:  voip_calls_info_t *callsinfo = NULL;",
          "3767:  address* phone;",
          "3768:  const iax2_info_t *ii = (const iax2_info_t *)iax2_info;",
          "3769:  iax2_info_t *tmp_iax2info;",
          "3771:  if (ii == NULL || ii->ptype != IAX2_FULL_PACKET || (ii->scallno == 0 && ii->dcallno == 0))",
          "3772:   return 0;",
          "3774:  list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3775:  while (list)",
          "3776:  {",
          "3777:   voip_calls_info_t* tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3778:   if (tmp_listinfo->protocol == VOIP_IAX2) {",
          "3779:    tmp_iax2info = (iax2_info_t *)tmp_listinfo->prot_info;",
          "3780:    if (tmp_iax2info->scallno == ii->scallno ||",
          "3781:        tmp_iax2info->scallno == ii->dcallno) {",
          "3782:     callsinfo = (voip_calls_info_t*)(list->data);",
          "3783:     break;",
          "3784:    }",
          "3785:   }",
          "3786:   list = g_list_next (list);",
          "3787:  }",
          "3788:  phone = &(pinfo->src);",
          "3791:  if (callsinfo==NULL) {",
          "3793:   if (ii->ftype != AST_FRAME_IAX ||  ii->csub != IAX_COMMAND_NEW)",
          "3794:    return 0;",
          "3795:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3796:   callsinfo->call_state = VOIP_NO_STATE;",
          "3797:   callsinfo->call_active_state = VOIP_ACTIVE;",
          "3798:   callsinfo->prot_info=g_malloc(sizeof(iax2_info_t));",
          "3799:   callsinfo->free_prot_info = free_iax2_info;",
          "3800:   tmp_iax2info = (iax2_info_t *)callsinfo->prot_info;",
          "3802:   tmp_iax2info->scallno = ii->scallno;",
          "3803:   if (tmp_iax2info->scallno == 0) tmp_iax2info->scallno = ii->dcallno;",
          "3804:   tmp_iax2info->callState = ii->callState;",
          "3806:   callsinfo->npackets = 1;",
          "3808:   COPY_ADDRESS(&(callsinfo->initial_speaker), phone);",
          "3809:   callsinfo->from_identity = g_strdup(ii->callingParty);",
          "3810:   callsinfo->to_identity =  g_strdup(ii->calledParty);",
          "3812:   callsinfo->protocol = VOIP_IAX2;",
          "3813:   callsinfo->call_num = tapinfo->ncalls++;",
          "3814:   callsinfo->start_fd=pinfo->fd;",
          "3815:   callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3816:   callsinfo->stop_fd = pinfo->fd;",
          "3817:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3819:   callsinfo->selected = FALSE;",
          "3820:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3822:  } else {",
          "3823:   callsinfo->call_state = ii->callState;",
          "3825:   callsinfo->stop_fd = pinfo->fd;",
          "3826:   callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3827:   ++(callsinfo->npackets);",
          "3828:  }",
          "3830:  add_to_graph(tapinfo, pinfo, edt, ii->messageName, \"\",",
          "3831:      callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3833:  return 1;",
          "",
          "[Added Lines]",
          "3760:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_iax2_);",
          "3761:     GList* list;",
          "3762:     voip_calls_info_t *callsinfo = NULL;",
          "3763:     address* phone;",
          "3764:     const iax2_info_t *ii = (const iax2_info_t *)iax2_info;",
          "3765:     iax2_info_t *tmp_iax2info;",
          "3767:     if (ii == NULL || ii->ptype != IAX2_FULL_PACKET || (ii->scallno == 0 && ii->dcallno == 0))",
          "3768:         return 0;",
          "3770:     list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3771:     while (list)",
          "3772:     {",
          "3773:         voip_calls_info_t* tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3774:         if (tmp_listinfo->protocol == VOIP_IAX2) {",
          "3775:             tmp_iax2info = (iax2_info_t *)tmp_listinfo->prot_info;",
          "3776:             if (tmp_iax2info->scallno == ii->scallno ||",
          "3777:                     tmp_iax2info->scallno == ii->dcallno) {",
          "3778:                 callsinfo = (voip_calls_info_t*)(list->data);",
          "3779:                 break;",
          "3780:             }",
          "3781:         }",
          "3782:         list = g_list_next (list);",
          "3783:     }",
          "3784:     phone = &(pinfo->src);",
          "3787:     if (callsinfo==NULL) {",
          "3789:         if (ii->ftype != AST_FRAME_IAX ||  ii->csub != IAX_COMMAND_NEW)",
          "3790:             return 0;",
          "3791:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3792:         callsinfo->call_state = VOIP_NO_STATE;",
          "3793:         callsinfo->call_active_state = VOIP_ACTIVE;",
          "3794:         callsinfo->prot_info=g_malloc(sizeof(iax2_info_t));",
          "3795:         callsinfo->free_prot_info = free_iax2_info;",
          "3796:         tmp_iax2info = (iax2_info_t *)callsinfo->prot_info;",
          "3798:         tmp_iax2info->scallno = ii->scallno;",
          "3799:         if (tmp_iax2info->scallno == 0) tmp_iax2info->scallno = ii->dcallno;",
          "3800:         tmp_iax2info->callState = ii->callState;",
          "3802:         callsinfo->npackets = 1;",
          "3804:         COPY_ADDRESS(&(callsinfo->initial_speaker), phone);",
          "3805:         callsinfo->from_identity = g_strdup(ii->callingParty);",
          "3806:         callsinfo->to_identity =  g_strdup(ii->calledParty);",
          "3808:         callsinfo->protocol = VOIP_IAX2;",
          "3809:         callsinfo->call_num = tapinfo->ncalls++;",
          "3810:         callsinfo->start_fd=pinfo->fd;",
          "3811:         callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3812:         callsinfo->stop_fd = pinfo->fd;",
          "3813:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3815:         callsinfo->selected = FALSE;",
          "3816:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3818:     } else {",
          "3819:         callsinfo->call_state = ii->callState;",
          "3821:         callsinfo->stop_fd = pinfo->fd;",
          "3822:         callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3823:         ++(callsinfo->npackets);",
          "3824:     }",
          "3826:     add_to_graph(tapinfo, pinfo, edt, ii->messageName, \"\",",
          "3827:             callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3829:     return 1;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3841: void",
          "3842: iax2_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "3843: {",
          "3868: }",
          "3871: void",
          "3872: remove_tap_listener_iax2_calls(voip_calls_tapinfo_t *tap_id_base)",
          "3873: {",
          "3875: }",
          "",
          "[Removed Lines]",
          "3844:  GString *error_string;",
          "3855:  error_string = register_tap_listener(\"IAX2\",",
          "3856:   tap_base_to_id(tap_id_base, tap_id_offset_iax2_),",
          "3857:   NULL,",
          "3858:   TL_REQUIRES_PROTO_TREE,",
          "3859:   voip_calls_dlg_reset,",
          "3860:   iax2_calls_packet,",
          "3861:   voip_calls_dlg_draw",
          "3862:   );",
          "3863:  if (error_string != NULL) {",
          "3864:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\",",
          "3865:          error_string->str);",
          "3866:   g_string_free(error_string, TRUE);",
          "3867:  }",
          "3874:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_iax2_));",
          "",
          "[Added Lines]",
          "3840:     GString *error_string;",
          "3851:     error_string = register_tap_listener(\"IAX2\",",
          "3852:             tap_base_to_id(tap_id_base, tap_id_offset_iax2_),",
          "3853:             NULL,",
          "3854:             TL_REQUIRES_PROTO_TREE,",
          "3855:             voip_calls_dlg_reset,",
          "3856:             iax2_calls_packet,",
          "3857:             voip_calls_dlg_draw",
          "3858:             );",
          "3859:     if (error_string != NULL) {",
          "3860:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\",",
          "3861:                 error_string->str);",
          "3862:         g_string_free(error_string, TRUE);",
          "3863:     }",
          "3870:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_iax2_));",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3881: static int",
          "3882: voip_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *VoIPinfo)",
          "3883: {",
          "3946: }",
          "3949: void",
          "3950: VoIPcalls_init_tap(voip_calls_tapinfo_t *tap_id_base)",
          "3951: {",
          "3967: }",
          "3969: void",
          "3970: remove_tap_listener_voip_calls(voip_calls_tapinfo_t *tap_id_base)",
          "3971: {",
          "3973: }",
          "",
          "[Removed Lines]",
          "3884:  voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_voip_);",
          "3885:  voip_calls_info_t *callsinfo = NULL;",
          "3886:  voip_calls_info_t *tmp_listinfo;",
          "3887:  GList *list = NULL;",
          "3888:  const voip_packet_info_t *pi = (const voip_packet_info_t *)VoIPinfo;",
          "3890:  if (pi->call_id)",
          "3891:   list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3892:  while (list) {",
          "3893:   tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3894:   if ( tmp_listinfo->protocol == VOIP_COMMON ) {",
          "3895:    if (!strcmp(pi->call_id, tmp_listinfo->call_id)) {",
          "3896:     callsinfo = (voip_calls_info_t*)(list->data);",
          "3897:     break;",
          "3898:    }",
          "3899:   }",
          "3900:   list = g_list_next(list);",
          "3901:  }",
          "3903:  if (callsinfo == NULL) {",
          "3904:   callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3905:   callsinfo->call_active_state = pi->call_active_state;",
          "3906:   callsinfo->call_state = pi->call_state;",
          "3907:   callsinfo->call_id=g_strdup((pi->call_id)?pi->call_id:\"\");",
          "3908:   callsinfo->from_identity = g_strdup((pi->from_identity)?pi->from_identity:\"\");",
          "3909:   callsinfo->to_identity = g_strdup((pi->to_identity)?pi->to_identity:\"\");",
          "3910:   COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "3911:   callsinfo->selected=FALSE;",
          "3912:   callsinfo->start_fd=pinfo->fd;",
          "3913:   callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3914:   callsinfo->protocol=VOIP_COMMON;",
          "3915:   callsinfo->protocol_name=g_strdup((pi->protocol_name)?pi->protocol_name:\"\");",
          "3916:   callsinfo->call_comment=g_strdup((pi->call_comment)?pi->call_comment:\"\");",
          "3917:   callsinfo->prot_info=NULL;",
          "3918:   callsinfo->free_prot_info = NULL;",
          "3920:   callsinfo->call_num = tapinfo->ncalls++;",
          "3921:   callsinfo->npackets = 0;",
          "3923:   g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3924:  }",
          "3926:  callsinfo->call_active_state = pi->call_active_state;",
          "3927:  if ((callsinfo->call_state != VOIP_COMPLETED) && (pi->call_state == VOIP_COMPLETED))",
          "3928:   tapinfo->completed_calls++;",
          "3929:  if (pi->call_state != VOIP_NO_STATE)",
          "3930:   callsinfo->call_state = pi->call_state;",
          "3931:  if (pi->call_comment) {",
          "3932:   g_free(callsinfo->call_comment);",
          "3933:   callsinfo->call_comment=g_strdup(pi->call_comment);",
          "3934:  }",
          "3935:  callsinfo->stop_fd = pinfo->fd;",
          "3936:  callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3937:  ++(callsinfo->npackets);",
          "3938:  ++(tapinfo->npackets);",
          "3941:  add_to_graph(tapinfo, pinfo, edt, (pi->frame_label)?pi->frame_label:\"VoIP msg\", pi->frame_comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3943:  tapinfo->redraw = TRUE;",
          "3945:  return 1;",
          "3952:  GString *error_string;",
          "3954:  error_string = register_tap_listener(\"voip\", tap_base_to_id(tap_id_base, tap_id_offset_voip_),",
          "3955:   NULL,",
          "3956:   0,",
          "3957:   voip_calls_dlg_reset,",
          "3958:         voip_calls_packet,",
          "3959:   voip_calls_dlg_draw",
          "3960:   );",
          "3962:  if (error_string != NULL) {",
          "3963:   simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3964:          \"%s\", error_string->str);",
          "3965:   g_string_free(error_string, TRUE);",
          "3966:  }",
          "3972:  remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_voip_));",
          "",
          "[Added Lines]",
          "3880:     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_voip_);",
          "3881:     voip_calls_info_t *callsinfo = NULL;",
          "3882:     voip_calls_info_t *tmp_listinfo;",
          "3883:     GList *list = NULL;",
          "3884:     const voip_packet_info_t *pi = (const voip_packet_info_t *)VoIPinfo;",
          "3886:     if (pi->call_id)",
          "3887:         list = g_queue_peek_nth_link(tapinfo->callsinfos, 0);",
          "3888:     while (list) {",
          "3889:         tmp_listinfo = (voip_calls_info_t *)list->data;",
          "3890:         if ( tmp_listinfo->protocol == VOIP_COMMON ) {",
          "3891:             if (!strcmp(pi->call_id, tmp_listinfo->call_id)) {",
          "3892:                 callsinfo = (voip_calls_info_t*)(list->data);",
          "3893:                 break;",
          "3894:             }",
          "3895:         }",
          "3896:         list = g_list_next(list);",
          "3897:     }",
          "3899:     if (callsinfo == NULL) {",
          "3900:         callsinfo = (voip_calls_info_t *)g_malloc0(sizeof(voip_calls_info_t));",
          "3901:         callsinfo->call_active_state = pi->call_active_state;",
          "3902:         callsinfo->call_state = pi->call_state;",
          "3903:         callsinfo->call_id=g_strdup((pi->call_id)?pi->call_id:\"\");",
          "3904:         callsinfo->from_identity = g_strdup((pi->from_identity)?pi->from_identity:\"\");",
          "3905:         callsinfo->to_identity = g_strdup((pi->to_identity)?pi->to_identity:\"\");",
          "3906:         COPY_ADDRESS(&(callsinfo->initial_speaker),&(pinfo->src));",
          "3907:         callsinfo->selected=FALSE;",
          "3908:         callsinfo->start_fd=pinfo->fd;",
          "3909:         callsinfo->start_rel_ts=pinfo->rel_ts;",
          "3910:         callsinfo->protocol=VOIP_COMMON;",
          "3911:         callsinfo->protocol_name=g_strdup((pi->protocol_name)?pi->protocol_name:\"\");",
          "3912:         callsinfo->call_comment=g_strdup((pi->call_comment)?pi->call_comment:\"\");",
          "3913:         callsinfo->prot_info=NULL;",
          "3914:         callsinfo->free_prot_info = NULL;",
          "3916:         callsinfo->call_num = tapinfo->ncalls++;",
          "3917:         callsinfo->npackets = 0;",
          "3919:         g_queue_push_tail(tapinfo->callsinfos, callsinfo);",
          "3920:     }",
          "3922:     callsinfo->call_active_state = pi->call_active_state;",
          "3923:     if ((callsinfo->call_state != VOIP_COMPLETED) && (pi->call_state == VOIP_COMPLETED))",
          "3924:         tapinfo->completed_calls++;",
          "3925:     if (pi->call_state != VOIP_NO_STATE)",
          "3926:         callsinfo->call_state = pi->call_state;",
          "3927:     if (pi->call_comment) {",
          "3928:         g_free(callsinfo->call_comment);",
          "3929:         callsinfo->call_comment=g_strdup(pi->call_comment);",
          "3930:     }",
          "3931:     callsinfo->stop_fd = pinfo->fd;",
          "3932:     callsinfo->stop_rel_ts = pinfo->rel_ts;",
          "3933:     ++(callsinfo->npackets);",
          "3934:     ++(tapinfo->npackets);",
          "3937:     add_to_graph(tapinfo, pinfo, edt, (pi->frame_label)?pi->frame_label:\"VoIP msg\", pi->frame_comment, callsinfo->call_num, &(pinfo->src), &(pinfo->dst), 1);",
          "3939:     tapinfo->redraw = TRUE;",
          "3941:     return 1;",
          "3948:     GString *error_string;",
          "3950:     error_string = register_tap_listener(\"voip\", tap_base_to_id(tap_id_base, tap_id_offset_voip_),",
          "3951:             NULL,",
          "3952:             0,",
          "3953:             voip_calls_dlg_reset,",
          "3954:             voip_calls_packet,",
          "3955:             voip_calls_dlg_draw",
          "3956:             );",
          "3958:     if (error_string != NULL) {",
          "3959:         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,",
          "3960:                 \"%s\", error_string->str);",
          "3961:         g_string_free(error_string, TRUE);",
          "3962:     }",
          "3968:     remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_voip_));",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3978: flow_show_options VoIPcalls_get_flow_show_option(void)",
          "3979: {",
          "3981: }",
          "3983: void VoIPcalls_set_flow_show_option(flow_show_options option)",
          "3984: {",
          "3986: }",
          "",
          "[Removed Lines]",
          "3980:  return flow_show_option;",
          "3985:  flow_show_option = option;",
          "",
          "[Added Lines]",
          "3976:     return flow_show_option;",
          "3981:     flow_show_option = option;",
          "",
          "---------------"
        ],
        "ui/gtk/voip_calls.h||ui/gtk/voip_calls.h": [
          "File: ui/gtk/voip_calls.h -> ui/gtk/voip_calls.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: extern const char *voip_call_state_name[8];",
          "46: typedef enum _voip_protocol {",
          "62: } voip_protocol;",
          "64: typedef enum _hash_indexes {",
          "66: } hash_indexes;",
          "68: extern const char *voip_protocol_name[];",
          "",
          "[Removed Lines]",
          "47:   VOIP_SIP,",
          "48:   VOIP_ISUP,",
          "49:   VOIP_H323,",
          "50:   VOIP_MGCP,",
          "51:   VOIP_AC_ISDN,",
          "52:   VOIP_AC_CAS,",
          "53:   MEDIA_T38,",
          "54:   TEL_H248,",
          "55:   TEL_SCCP,",
          "56:   TEL_BSSMAP,",
          "57:   TEL_RANAP,",
          "58:   VOIP_UNISTIM,",
          "59:   VOIP_SKINNY,",
          "60:   VOIP_IAX2,",
          "61:   VOIP_COMMON",
          "65:   SIP_HASH=0",
          "",
          "[Added Lines]",
          "47:     VOIP_SIP,",
          "48:     VOIP_ISUP,",
          "49:     VOIP_H323,",
          "50:     VOIP_MGCP,",
          "51:     VOIP_AC_ISDN,",
          "52:     VOIP_AC_CAS,",
          "53:     MEDIA_T38,",
          "54:     TEL_H248,",
          "55:     TEL_SCCP,",
          "56:     TEL_BSSMAP,",
          "57:     TEL_RANAP,",
          "58:     VOIP_UNISTIM,",
          "59:     VOIP_SKINNY,",
          "60:     VOIP_IAX2,",
          "61:     VOIP_COMMON",
          "65:     SIP_HASH=0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81: typedef enum _sip_call_state {",
          "85: } sip_call_state;",
          "87: typedef struct _sip_calls_info {",
          "91: } sip_calls_info_t;",
          "94: typedef struct _isup_calls_info {",
          "98: } isup_calls_info_t;",
          "101: typedef struct _h245_address {",
          "104: } h245_address_t;",
          "107: typedef struct _h323_calls_info {",
          "118: } h323_calls_info_t;",
          "121: typedef struct _mgcp_calls_info {",
          "124: } mgcp_calls_info_t;",
          "127: typedef struct _actrace_isdn_calls_info {",
          "130: } actrace_isdn_calls_info_t;",
          "133: typedef struct _actrace_cas_calls_info {",
          "136: } actrace_cas_calls_info_t;",
          "139: typedef struct _skinny_calls_info {",
          "141: } skinny_calls_info_t;",
          "144: typedef struct _voip_calls_info {",
          "165: } voip_calls_info_t;",
          "",
          "[Removed Lines]",
          "82:  SIP_INVITE_SENT,",
          "83:  SIP_200_REC,",
          "84:  SIP_CANCEL_SENT",
          "88:  gchar *call_identifier;",
          "89:  guint32 invite_cseq;",
          "90:  sip_call_state sip_state;",
          "95:  guint16   cic;",
          "96:  guint32   opc, dpc;",
          "97:  guint8   ni;",
          "102:  address h245_address;",
          "103:  guint16 h245_port;",
          "111:  gboolean is_h245;",
          "114:  gboolean is_h245Tunneling;",
          "115:  gint32 q931_crv;",
          "116:  gint32 q931_crv2;",
          "117:  guint requestSeqNum;",
          "122:  gchar *endpointId;",
          "128:  gint32 crv;",
          "129:  int trunk;",
          "134:  gint32 bchannel;",
          "135:  int trunk;",
          "140:  guint32 callId;",
          "145:  voip_call_state call_state;",
          "146:  voip_call_active_state call_active_state;",
          "147:  gchar *call_id;",
          "148:  gchar *from_identity;",
          "149:  gchar *to_identity;",
          "150:  gpointer prot_info;",
          "151:  void(*free_prot_info)(gpointer);",
          "152:  address initial_speaker;",
          "153:  guint32 npackets;",
          "154:  voip_protocol protocol;",
          "155:  gchar *protocol_name;",
          "156:  gchar *call_comment;",
          "157:  guint16 call_num;",
          "159:  frame_data *start_fd;",
          "160:  nstime_t start_rel_ts;",
          "161:  frame_data *stop_fd;",
          "162:  nstime_t stop_rel_ts;",
          "163:  gboolean selected;",
          "",
          "[Added Lines]",
          "82:     SIP_INVITE_SENT,",
          "83:     SIP_200_REC,",
          "84:     SIP_CANCEL_SENT",
          "88:     gchar *call_identifier;",
          "89:     guint32 invite_cseq;",
          "90:     sip_call_state sip_state;",
          "95:     guint16   cic;",
          "96:     guint32   opc, dpc;",
          "97:     guint8   ni;",
          "102:     address h245_address;",
          "103:     guint16 h245_port;",
          "111:     gboolean is_h245;",
          "114:     gboolean is_h245Tunneling;",
          "115:     gint32 q931_crv;",
          "116:     gint32 q931_crv2;",
          "117:     guint requestSeqNum;",
          "122:     gchar *endpointId;",
          "128:     gint32 crv;",
          "129:     int trunk;",
          "134:     gint32 bchannel;",
          "135:     int trunk;",
          "140:     guint32 callId;",
          "145:     voip_call_state call_state;",
          "146:     voip_call_active_state call_active_state;",
          "147:     gchar *call_id;",
          "148:     gchar *from_identity;",
          "149:     gchar *to_identity;",
          "150:     gpointer prot_info;",
          "151:     void(*free_prot_info)(gpointer);",
          "152:     address initial_speaker;",
          "153:     guint32 npackets;",
          "154:     voip_protocol protocol;",
          "155:     gchar *protocol_name;",
          "156:     gchar *call_comment;",
          "157:     guint16 call_num;",
          "159:     frame_data *start_fd;",
          "160:     nstime_t start_rel_ts;",
          "161:     frame_data *stop_fd;",
          "162:     nstime_t stop_rel_ts;",
          "163:     gboolean selected;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171: typedef struct _voip_calls_tapinfo {",
          "184: } voip_calls_tapinfo_t;",
          "",
          "[Removed Lines]",
          "178:  int start_packets;",
          "179:  int completed_calls;",
          "180:  int rejected_calls;",
          "181:  seq_analysis_info_t* graph_analysis;",
          "183:  gboolean redraw;",
          "",
          "[Added Lines]",
          "178:     int start_packets;",
          "179:     int completed_calls;",
          "180:     int rejected_calls;",
          "181:     seq_analysis_info_t* graph_analysis;",
          "183:     gboolean redraw;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b0090fd046d98c1410cb1f8d4012fea905621fc8",
      "candidate_info": {
        "commit_hash": "b0090fd046d98c1410cb1f8d4012fea905621fc8",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/b0090fd046d98c1410cb1f8d4012fea905621fc8",
        "files": [
          "epan/dissectors/packet-pcp.c",
          "epan/dissectors/packet-pflog.c",
          "epan/dissectors/packet-pptp.c",
          "epan/dissectors/packet-reload-framing.c",
          "epan/dissectors/packet-rmt-alc.c",
          "epan/dissectors/packet-rmt-fec.c",
          "epan/dissectors/packet-rmt-norm.c",
          "epan/dissectors/packet-roofnet.c",
          "epan/dissectors/packet-sasp.c",
          "epan/dissectors/packet-sbc.c",
          "epan/dissectors/packet-sdp.c",
          "epan/dissectors/packet-sflow.c",
          "epan/dissectors/packet-sigcomp.c",
          "epan/dissectors/packet-sip.c",
          "epan/dissectors/packet-slsk.c",
          "epan/dissectors/packet-smb.c",
          "epan/dissectors/packet-spice.c",
          "epan/dissectors/packet-sprt.c",
          "epan/dissectors/packet-ssh.c",
          "epan/dissectors/packet-ssl.c",
          "epan/dissectors/packet-sysex.c"
        ],
        "message": "Batch of filterable expert infos\n\nsvn path=/trunk/; revision=49600",
        "before_after_code_files": [
          "epan/dissectors/packet-pcp.c||epan/dissectors/packet-pcp.c",
          "epan/dissectors/packet-pflog.c||epan/dissectors/packet-pflog.c",
          "epan/dissectors/packet-pptp.c||epan/dissectors/packet-pptp.c",
          "epan/dissectors/packet-reload-framing.c||epan/dissectors/packet-reload-framing.c",
          "epan/dissectors/packet-rmt-alc.c||epan/dissectors/packet-rmt-alc.c",
          "epan/dissectors/packet-rmt-fec.c||epan/dissectors/packet-rmt-fec.c",
          "epan/dissectors/packet-rmt-norm.c||epan/dissectors/packet-rmt-norm.c",
          "epan/dissectors/packet-roofnet.c||epan/dissectors/packet-roofnet.c",
          "epan/dissectors/packet-sasp.c||epan/dissectors/packet-sasp.c",
          "epan/dissectors/packet-sbc.c||epan/dissectors/packet-sbc.c",
          "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c",
          "epan/dissectors/packet-sflow.c||epan/dissectors/packet-sflow.c",
          "epan/dissectors/packet-sigcomp.c||epan/dissectors/packet-sigcomp.c",
          "epan/dissectors/packet-sip.c||epan/dissectors/packet-sip.c",
          "epan/dissectors/packet-slsk.c||epan/dissectors/packet-slsk.c",
          "epan/dissectors/packet-smb.c||epan/dissectors/packet-smb.c",
          "epan/dissectors/packet-spice.c||epan/dissectors/packet-spice.c",
          "epan/dissectors/packet-sprt.c||epan/dissectors/packet-sprt.c",
          "epan/dissectors/packet-ssh.c||epan/dissectors/packet-ssh.c",
          "epan/dissectors/packet-ssl.c||epan/dissectors/packet-ssl.c",
          "epan/dissectors/packet-sysex.c||epan/dissectors/packet-sysex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-pcp.c||epan/dissectors/packet-pcp.c": [
          "File: epan/dissectors/packet-pcp.c -> epan/dissectors/packet-pcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "220: static gint ett_pcp_text_buflen = -1;",
          "221: static gint ett_pcp_text_buffer = -1;",
          "224: static const value_string packettypenames[] = {",
          "225:     #define    START_OR_ERROR 0x7000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "223: static expert_field ei_pcp_type_event_unimplemented = EI_INIT;",
          "224: static expert_field ei_pcp_type_nosupport_unsupported = EI_INIT;",
          "225: static expert_field ei_pcp_type_unknown_unknown_value = EI_INIT;",
          "226: static expert_field ei_pcp_unimplemented_value = EI_INIT;",
          "227: static expert_field ei_pcp_unimplemented_packet_type = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "985:                                 pmvalueblock_offset, pmvalueblock_value_length-4, ENC_NA);",
          "986:                             break;",
          "987:                         case PM_TYPE_EVENT:",
          "990:                             break;",
          "991:                         case PM_TYPE_NOSUPPORT:",
          "994:                             break;",
          "995:                         case PM_TYPE_UNKNOWN:",
          "998:                             break;",
          "999:                         default:",
          "1002:                             break;",
          "1003:                 }",
          "1004:             }",
          "",
          "[Removed Lines]",
          "988:                             expert_add_info_format(pinfo, pcp_result_instance_tree, PI_UNDECODED, PI_WARN,",
          "989:                                                    \"PM_TYPE_EVENT: Unimplemented Value Type\");",
          "992:                             expert_add_info_format(pinfo, pcp_result_instance_tree, PI_UNDECODED, PI_WARN,",
          "993:                                                    \"PM_TYPE_NOSUPPORT: Unsupported Value Type\");",
          "996:                             expert_add_info_format(pinfo, pcp_result_instance_tree, PI_UNDECODED,",
          "997:                                                    PI_WARN, \"PM_TYPE_UNKNOWN: Unknown Value Type\");",
          "1000:                             expert_add_info_format(pinfo, pcp_result_instance_tree, PI_UNDECODED, PI_WARN,",
          "1001:                                                    \"Unimplemented Value Type\");",
          "",
          "[Added Lines]",
          "994:                             expert_add_info(pinfo, pcp_result_instance_tree, &ei_pcp_type_event_unimplemented);",
          "997:                             expert_add_info(pinfo, pcp_result_instance_tree, &ei_pcp_type_nosupport_unsupported);",
          "1000:                             expert_add_info(pinfo, pcp_result_instance_tree, &ei_pcp_type_unknown_unknown_value);",
          "1003:                             expert_add_info(pinfo, pcp_result_instance_tree, &ei_pcp_unimplemented_value);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1480:             col_append_str(pinfo->cinfo, COL_INFO, \"[UNIMPLEMENTED TYPE]\");",
          "1483:             break;",
          "1484:     }",
          "1485: }",
          "",
          "[Removed Lines]",
          "1482:             expert_add_info_format(pinfo, pcp_tree, PI_UNDECODED, PI_WARN, \"Unimplemented Packet Type\");",
          "",
          "[Added Lines]",
          "1484:             expert_add_info(pinfo, pcp_tree, &ei_pcp_unimplemented_packet_type);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2235:         &ett_pcp_text_buffer,",
          "2236:     };",
          "2238:     proto_pcp = proto_register_protocol(\"Performance Co-Pilot\", \"PCP\", \"pcp\");",
          "2240:     proto_register_field_array(proto_pcp, hf, array_length(hf));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2240:     static ei_register_info ei[] = {",
          "2241:         { &ei_pcp_type_event_unimplemented, { \"pcp.pmid.type.event.unimplemented\", PI_UNDECODED, PI_WARN, \"PM_TYPE_EVENT: Unimplemented Value Type\", EXPFILL }},",
          "2242:         { &ei_pcp_type_nosupport_unsupported, { \"pcp.pmid.type.nosupport.unsupported\", PI_UNDECODED, PI_WARN, \"PM_TYPE_NOSUPPORT: Unsupported Value Type\", EXPFILL }},",
          "2243:         { &ei_pcp_type_unknown_unknown_value, { \"pcp.pmid.type.unknown.unknown_value\", PI_UNDECODED, PI_WARN, \"PM_TYPE_UNKNOWN: Unknown Value Type\", EXPFILL }},",
          "2244:         { &ei_pcp_unimplemented_value, { \"pcp.pmid.type.unimplemented\", PI_UNDECODED, PI_WARN, \"Unimplemented Value Type\", EXPFILL }},",
          "2245:         { &ei_pcp_unimplemented_packet_type, { \"pcp.type.unimplemented\", PI_UNDECODED, PI_WARN, \"Unimplemented Packet Type\", EXPFILL }},",
          "2246:     };",
          "2248:     expert_module_t* expert_pcp;",
          "2250:     expert_pcp = expert_register_protocol(proto_pcp);",
          "2251:     expert_register_field_array(expert_pcp, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-pflog.c||epan/dissectors/packet-pflog.c": [
          "File: epan/dissectors/packet-pflog.c -> epan/dissectors/packet-pflog.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: static int hf_pflog_dport = -1;",
          "71: static gint ett_pflog = -1;",
          "74: static int proto_old_pflog = -1;",
          "75: static int hf_old_pflog_af = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: static expert_field ei_pflog_invalid_header_length = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "176:   ti_len = proto_tree_add_item(pflog_tree, hf_pflog_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "177:   if(length < LEN_PFLOG_BSD34)",
          "178:   {",
          "180:   }",
          "182:   offset += 1;",
          "",
          "[Removed Lines]",
          "179:     expert_add_info_format(pinfo, ti_len, PI_MALFORMED, PI_ERROR, \"Invalid header length %u\", length);",
          "",
          "[Added Lines]",
          "181:     expert_add_info_format_text(pinfo, ti_len, &ei_pflog_invalid_header_length, \"Invalid header length %u\", length);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "381:   };",
          "382:   static gint *ett[] = { &ett_pflog };",
          "384:   proto_pflog = proto_register_protocol(\"OpenBSD Packet Filter log file\",",
          "385:                                         \"PFLOG\", \"pflog\");",
          "386:   proto_register_field_array(proto_pflog, hf, array_length(hf));",
          "387:   proto_register_subtree_array(ett, array_length(ett));",
          "388: }",
          "390: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "386:   static ei_register_info ei[] = {",
          "387:      { &ei_pflog_invalid_header_length, { \"pflog.invalid_header_length\", PI_MALFORMED, PI_ERROR, \"Invalid header length \", EXPFILL }},",
          "388:   };",
          "390:   expert_module_t* expert_pflog;",
          "396:   expert_pflog = expert_register_protocol(proto_pflog);",
          "397:   expert_register_field_array(expert_pflog, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-pptp.c||epan/dissectors/packet-pptp.c": [
          "File: epan/dissectors/packet-pptp.c -> epan/dissectors/packet-pptp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: static gint ett_pptp = -1;",
          "88: static dissector_handle_t data_handle;",
          "90: #define TCP_PORT_PPTP  1723",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88: static expert_field ei_pptp_incorrect_magic_cookie = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "621:     proto_item_append_text(item,\" (correct)\");",
          "622:   else {",
          "623:     proto_item_append_text(item,\" (incorrect)\");",
          "625:   }",
          "627:   if (tree) {",
          "",
          "[Removed Lines]",
          "624:     expert_add_info_format(pinfo, item, PI_MALFORMED, PI_WARN, \"Incorrect Magic Cookie\");",
          "",
          "[Added Lines]",
          "626:     expert_add_info(pinfo, item, &ei_pptp_incorrect_magic_cookie);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "940:     },",
          "941:   };",
          "943:   proto_pptp = proto_register_protocol(\"Point-to-Point Tunnelling Protocol\",",
          "944:            \"PPTP\", \"pptp\");",
          "945:   proto_register_field_array(proto_pptp, hf, array_length(hf));",
          "946:   proto_register_subtree_array(ett, array_length(ett));",
          "947: }",
          "949: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "945:   static ei_register_info ei[] = {",
          "946:      { &ei_pptp_incorrect_magic_cookie, { \"pptp.magic_cookie.incorrect\", PI_PROTOCOL, PI_WARN, \"Incorrect Magic Cookie\", EXPFILL }},",
          "947:   };",
          "949:   expert_module_t* expert_pptp;",
          "955:   expert_pptp = expert_register_protocol(proto_pptp);",
          "956:   expert_register_field_array(expert_pptp, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-reload-framing.c||epan/dissectors/packet-reload-framing.c": [
          "File: epan/dissectors/packet-reload-framing.c -> epan/dissectors/packet-reload-framing.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: static gint ett_reload_framing_message = -1;",
          "75: static gint ett_reload_framing_received = -1;",
          "78: #define UDP_PORT_RELOAD                 6084",
          "79: #define TCP_PORT_RELOAD                 6084",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77: static expert_field ei_reload_no_dissector = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "329:     proto_tree_add_item(message_tree, hf_reload_framing_message_data, tvb, offset, message_length, ENC_NA);",
          "330:     next_tvb = tvb_new_subset(tvb, offset, effective_length - offset, message_length);",
          "331:     if (reload_handle == NULL) {",
          "333:       return tvb_length(tvb);",
          "334:     }",
          "335:     call_dissector_only(reload_handle, next_tvb, pinfo, tree, NULL);",
          "",
          "[Removed Lines]",
          "332:       expert_add_info_format(pinfo, ti, PI_PROTOCOL, PI_WARN, \"Can not find reload dissector\");",
          "",
          "[Added Lines]",
          "333:       expert_add_info(pinfo, ti, &ei_reload_no_dissector);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "538:     &ett_reload_framing_received,",
          "539:   };",
          "542:   proto_reload_framing = proto_register_protocol(\"REsource LOcation And Discovery Framing\", \"RELOAD FRAMING\", \"reload-framing\");",
          "545:   proto_register_field_array(proto_reload_framing, hf, array_length(hf));",
          "546:   proto_register_subtree_array(ett, array_length(ett));",
          "548:   register_dissector(\"reload-framing\", dissect_reload_framing_message_no_return, proto_reload_framing);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "542:   static ei_register_info ei[] = {",
          "543:      { &ei_reload_no_dissector, { \"reload_framing.no_dissector\", PI_PROTOCOL, PI_WARN, \"Can not find reload dissector\", EXPFILL }},",
          "544:   };",
          "546:   expert_module_t* expert_reload_framing;",
          "554:   expert_reload_framing = expert_register_protocol(proto_reload_framing);",
          "555:   expert_register_field_array(expert_reload_framing, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rmt-alc.c||epan/dissectors/packet-rmt-alc.c": [
          "File: epan/dissectors/packet-rmt-alc.c -> epan/dissectors/packet-rmt-alc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: static int ett_main = -1;",
          "61: static dissector_handle_t xml_handle;",
          "62: static dissector_handle_t rmt_lct_handle;",
          "63: static dissector_handle_t rmt_fec_handle;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: static expert_field ei_version1_only = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:  if (version != 1) {",
          "112:   col_add_fstr(pinfo->cinfo, COL_INFO, \"Version: %u (not supported)\", version);",
          "",
          "[Removed Lines]",
          "109:   expert_add_info_format(pinfo, ti, PI_PROTOCOL, PI_WARN, \"Sorry, this dissector supports ALC version 1 only\");",
          "",
          "[Added Lines]",
          "111:   expert_add_info(pinfo, ti, &ei_version1_only);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "202:   &ett_main,",
          "203:  };",
          "205:  module_t *module;",
          "208:  proto_rmt_alc = proto_register_protocol(\"Asynchronous Layered Coding\", \"ALC\", \"alc\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:  static ei_register_info ei[] = {",
          "208:   { &ei_version1_only, { \"alc.version1_only\", PI_PROTOCOL, PI_WARN, \"Sorry, this dissector supports ALC version 1 only\", EXPFILL }},",
          "209:  };",
          "212:  expert_module_t* expert_rmt_alc;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "212:  proto_register_field_array(proto_rmt_alc, hf_ptr, array_length(hf_ptr));",
          "213:  proto_register_subtree_array(ett_ptr, array_length(ett_ptr));",
          "216:  module = prefs_register_protocol(proto_rmt_alc, proto_reg_handoff_alc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221:  expert_rmt_alc = expert_register_protocol(proto_rmt_alc);",
          "222:  expert_register_field_array(expert_rmt_alc, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rmt-fec.c||epan/dissectors/packet-rmt-fec.c": [
          "File: epan/dissectors/packet-rmt-fec.c -> epan/dissectors/packet-rmt-fec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: static int ett_main = -1;",
          "70: typedef struct fec_packet_data",
          "71: {",
          "72:  guint8 instance_id;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: static expert_field ei_fec_encoding_id = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131:   proto_tree_add_uint64(tree, hf_fti_transfer_length, tvb, offset+2, 6, transfer_length);",
          "132:   ti = proto_tree_add_item(tree, hf_instance_id, tvb,  offset+8, 2, ENC_BIG_ENDIAN);",
          "133:   if ((encoding_id < 128) && (instance_id != 0)) {",
          "135:   }",
          "136:  }",
          "",
          "[Removed Lines]",
          "134:    expert_add_info_format(pinfo, ti, PI_PROTOCOL, PI_WARN, \"FEC Encoding ID < 128, should be zero\");",
          "",
          "[Added Lines]",
          "136:    expert_add_info(pinfo, ti, &ei_fec_encoding_id);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "307:   &ett_main,",
          "308:  };",
          "311:  proto_rmt_fec = proto_register_protocol(\"Forward Error Correction (FEC)\", \"RMT-FEC\", \"rmt-fec\");",
          "312:  new_register_dissector(\"rmt-fec\", dissect_fec, proto_rmt_fec);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312:  static ei_register_info ei[] = {",
          "313:   { &ei_fec_encoding_id, { \"rmt-fec.encoding_id.not0\", PI_PROTOCOL, PI_WARN, \"FEC Encoding ID < 128, should be zero\", EXPFILL }},",
          "314:  };",
          "316:  expert_module_t* expert_rmt_fec;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "315:  proto_register_field_array(proto_rmt_fec, hf, array_length(hf));",
          "316:  proto_register_subtree_array(ett, array_length(ett));",
          "317: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "325:  expert_rmt_fec = expert_register_protocol(proto_rmt_fec);",
          "326:  expert_register_field_array(expert_rmt_fec, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rmt-norm.c||epan/dissectors/packet-rmt-norm.c": [
          "File: epan/dissectors/packet-rmt-norm.c -> epan/dissectors/packet-rmt-norm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "207: static int ett_congestioncontrol = -1;",
          "208: static int ett_nackdata = -1;",
          "211: static const double RTT_MIN = 1.0e-06;",
          "212: static const double RTT_MAX = 1000;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "210: static expert_field ei_version1_only = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "602:  if (version != 1) {",
          "606:   col_add_fstr(pinfo->cinfo, COL_INFO, \"Version: %u (not supported)\", version);",
          "",
          "[Removed Lines]",
          "603:   expert_add_info_format(pinfo, ti, PI_PROTOCOL, PI_WARN, \"Sorry, this dissector supports ALC version 1 only\");",
          "",
          "[Added Lines]",
          "604:   expert_add_info(pinfo, ti, &ei_version1_only);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "816:   &ett_nackdata,",
          "817:  };",
          "819:  module_t *module;",
          "822:  proto_rmt_norm = proto_register_protocol(\"Negative-acknowledgment Oriented Reliable Multicast\", \"NORM\", \"norm\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "820:  static ei_register_info ei[] = {",
          "821:   { &ei_version1_only, { \"alc.version1_only\", PI_PROTOCOL, PI_WARN, \"Sorry, this dissector supports ALC version 1 only\", EXPFILL }},",
          "822:  };",
          "825:  expert_module_t* expert_rmt_norm;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "825:  proto_register_field_array(proto_rmt_norm, hf, array_length(hf));",
          "826:  proto_register_subtree_array(ett, array_length(ett));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "833:  expert_rmt_norm = expert_register_protocol(proto_rmt_norm);",
          "834:  expert_register_field_array(expert_rmt_norm, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-roofnet.c||epan/dissectors/packet-roofnet.c": [
          "File: epan/dissectors/packet-roofnet.c -> epan/dissectors/packet-roofnet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "104: static gint ett_roofnet = -1;",
          "105: static gint ett_roofnet_link = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107: static expert_field ei_rooftop_too_many_links = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:   roofnet_nlinks= tvb_get_guint8(tvb, ROOFNET_OFFSET_NLINKS);",
          "226:   if ((roofnet_nlinks*6*4)+ROOFNET_HEADER_LENGTH > ROOFNET_MAX_LENGTH) {",
          "230:     return;",
          "231:   }",
          "",
          "[Removed Lines]",
          "227:     if (tree) {",
          "228:       expert_add_info_format(pinfo, it, PI_MALFORMED, PI_ERROR, \"Too many links (%u)\\n\", roofnet_nlinks);",
          "229:     }",
          "",
          "[Added Lines]",
          "229:     expert_add_info_format_text(pinfo, it, &ei_rooftop_too_many_links, \"Too many links (%u)\\n\", roofnet_nlinks);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "338:     &ett_roofnet_link",
          "339:   };",
          "341:   proto_roofnet = proto_register_protocol(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341:   static ei_register_info ei[] = {",
          "342:      { &ei_rooftop_too_many_links, { \"rooftop.too_many_links\", PI_MALFORMED, PI_ERROR, \"Too many links\", EXPFILL }},",
          "343:   };",
          "345:   expert_module_t* expert_roofnet;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "347:   proto_register_field_array(proto_roofnet, hf, array_length(hf));",
          "348:   proto_register_subtree_array(ett, array_length(ett));",
          "349: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:   expert_roofnet = expert_register_protocol(proto_roofnet);",
          "356:   expert_register_field_array(expert_roofnet, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sasp.c||epan/dissectors/packet-sasp.c": [
          "File: epan/dissectors/packet-sasp.c -> epan/dissectors/packet-sasp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "208: static gint ett_wt_entry_data_flag = -1;",
          "209: static gint ett_sasp_wt_rep = -1;",
          "212: static gboolean sasp_desegment = TRUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211: static expert_field ei_msg_type_invalid = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "384:  hti = proto_tree_add_uint_format(sasp_tree, hf_sasp_type, tvb, offset, 2, hdr_type,",
          "385:        \"Type: %s\", (hdr_type == SASP_HDR_TYPE) ? \"SASP\" : \"[Invalid]\");",
          "386:  if (hdr_type != SASP_HDR_TYPE) {",
          "388:            \"Invalid SASP Header Type [0x%04x]\", hdr_type);",
          "390:   col_set_str(pinfo->cinfo, COL_INFO, \"[Malformed: Invalid SASP Header Type]\");",
          "",
          "[Removed Lines]",
          "387:   expert_add_info_format(pinfo, hti, PI_MALFORMED, PI_ERROR,",
          "",
          "[Added Lines]",
          "389:   expert_add_info_format_text(pinfo, hti, &ei_msg_type_invalid,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "503:    col_add_fstr(pinfo->cinfo, COL_INFO,",
          "504:          \"[Malformed: Unknown Message Type [0x%04x]\", msg_type);",
          "506:             \"Unknown SASP Message Type: 0x%4x\", msg_type);",
          "507:    return;",
          "508:   }",
          "",
          "[Removed Lines]",
          "505:    expert_add_info_format(pinfo, mti, PI_MALFORMED, PI_WARN,",
          "",
          "[Added Lines]",
          "507:    expert_add_info_format_text(pinfo, mti, &ei_msg_type_invalid,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1705:   &ett_sasp_wt_rep,",
          "1706:  };",
          "1708:  module_t *sasp_module;",
          "1710:  proto_sasp = proto_register_protocol(\"Server/Application State Protocol\", \"SASP\", \"sasp\");",
          "1712:  proto_register_field_array(proto_sasp, hf, array_length(hf));",
          "1713:  proto_register_subtree_array(ett, array_length(ett));",
          "1715:  sasp_module = prefs_register_protocol(proto_sasp, NULL);",
          "1716:  prefs_register_bool_preference(sasp_module, \"desegment_sasp_messages\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1710:  static ei_register_info ei[] = {",
          "1711:   { &ei_msg_type_invalid, { \"sasp.msg.type.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Type\", EXPFILL }},",
          "1712:  };",
          "1715:  expert_module_t* expert_sasp;",
          "1721:  expert_sasp = expert_register_protocol(proto_sasp);",
          "1722:  expert_register_field_array(expert_sasp, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sbc.c||epan/dissectors/packet-sbc.c": [
          "File: epan/dissectors/packet-sbc.c -> epan/dissectors/packet-sbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60: static gint ett_sbc             = -1;",
          "61: static gint ett_sbc_list        = -1;",
          "63: static dissector_handle_t data_handle;",
          "65: extern value_string_ext media_codec_audio_type_vals_ext;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: static expert_field ei_sbc_syncword = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:         pitem = proto_tree_add_item(rtree, hf_sbc_syncword, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "193:         syncword = tvb_get_guint8(tvb, offset);",
          "194:         if (syncword != 0x9C) {",
          "197:         }",
          "198:         offset += 1;",
          "",
          "[Removed Lines]",
          "195:             expert_add_info_format(pinfo, pitem, PI_PROTOCOL, PI_WARN,",
          "196:                     \"Unexpected syncword\");",
          "",
          "[Added Lines]",
          "197:             expert_add_info(pinfo, pitem, &ei_sbc_syncword);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232: proto_register_sbc(void)",
          "233: {",
          "234:     module_t *module;",
          "236:     static hf_register_info hf[] = {",
          "237:         { &hf_sbc_fragmented,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "236:     expert_module_t* expert_sbc;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "312:         &ett_sbc_list,",
          "313:     };",
          "315:     proto_sbc = proto_register_protocol(\"Bluetooth SBC Codec\", \"SBC\", \"sbc\");",
          "317:     proto_register_field_array(proto_sbc, hf, array_length(hf));",
          "318:     proto_register_subtree_array(ett, array_length(ett));",
          "320:     new_register_dissector(\"sbc\", dissect_sbc, proto_sbc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "317:     static ei_register_info ei[] = {",
          "318:         { &ei_sbc_syncword, { \"sbc.syncword.unexpected\", PI_PROTOCOL, PI_WARN, \"Unexpected syncword\", EXPFILL }},",
          "319:     };",
          "325:     expert_sbc = expert_register_protocol(proto_sbc);",
          "326:     expert_register_field_array(expert_sbc, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c": [
          "File: epan/dissectors/packet-sdp.c -> epan/dissectors/packet-sdp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205: static int ett_sdp_key_mgmt = -1;",
          "206: static int ett_sdp_crypto_key_parameters = -1;",
          "208: #define SDP_RTP_PROTO       0x00000001",
          "209: #define SDP_SRTP_PROTO      0x00000002",
          "210: #define SDP_T38_PROTO       0x00000004",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "208: static expert_field ei_sdp_invalid_key_param = EI_INIT;",
          "209: static expert_field ei_sdp_invalid_line = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1485:           next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "1486:           if (next_offset == -1) {",
          "1489:               break;",
          "1490:           }",
          "",
          "[Removed Lines]",
          "1487:               expert_add_info_format(pinfo, parameter_item, PI_MALFORMED, PI_NOTE,",
          "1488:                   \"Invalid key-param (no ':' delimiter)\");",
          "",
          "[Added Lines]",
          "1490:               expert_add_info(pinfo, parameter_item, &ei_sdp_invalid_key_param);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2058:     delim = tvb_get_guint8(tvb, offset + 1);",
          "2059:     if (delim != '=') {",
          "2060:       proto_item *ti2 = proto_tree_add_item(sdp_tree, hf_invalid, tvb, offset, linelen, ENC_ASCII|ENC_NA);",
          "2063:       offset = next_offset;",
          "2064:       continue;",
          "2065:     }",
          "",
          "[Removed Lines]",
          "2061:       expert_add_info_format(pinfo, ti2, PI_MALFORMED, PI_NOTE,",
          "2062:                              \"Invalid SDP line (no '=' delimiter)\");",
          "",
          "[Added Lines]",
          "2063:       expert_add_info(pinfo, ti2, &ei_sdp_invalid_line);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2702:     &ett_sdp_crypto_key_parameters,",
          "2703:   };",
          "2705:   module_t *sdp_module;",
          "2707:   proto_sdp = proto_register_protocol(\"Session Description Protocol\",",
          "2708:                                       \"SDP\", \"sdp\");",
          "2709:   proto_register_field_array(proto_sdp, hf, array_length(hf));",
          "2710:   proto_register_subtree_array(ett, array_length(ett));",
          "2712:   key_mgmt_dissector_table = register_dissector_table(\"key_mgmt\",",
          "2713:                                                       \"Key Management\", FT_STRING, BASE_NONE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2706:   static ei_register_info ei[] = {",
          "2707:      { &ei_sdp_invalid_key_param, { \"sdp.invalid_key_param\", PI_MALFORMED, PI_NOTE, \"Invalid key-param (no ':' delimiter)\", EXPFILL }},",
          "2708:      { &ei_sdp_invalid_line, { \"sdp.invalid_line\", PI_MALFORMED, PI_NOTE, \"Invalid SDP line (no '=' delimiter)\", EXPFILL }},",
          "2709:   };",
          "2712:   expert_module_t* expert_sdp;",
          "2718:   expert_sdp = expert_register_protocol(proto_sdp);",
          "2719:   expert_register_field_array(expert_sdp, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sflow.c||epan/dissectors/packet-sflow.c": [
          "File: epan/dissectors/packet-sflow.c -> epan/dissectors/packet-sflow.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "676: static gint ett_sflow_245_gw_community = -1;",
          "677: static gint ett_sflow_245_sampled_header = -1;",
          "680: static dissector_handle_t eth_withoutfcs_handle;",
          "681: static dissector_handle_t tr_handle;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "679: static expert_field ei_sflow_invalid_address_type = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "896:         len = 0;",
          "897:         pi = proto_tree_add_text(tree, tvb, offset - 4, 4, \"Unknown address type (%u)\", addr_type);",
          "899:     }",
          "901:     if (addr_detail) {",
          "",
          "[Removed Lines]",
          "898:         expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, \"Unknown/invalid address type\");",
          "",
          "[Added Lines]",
          "900:         expert_add_info(pinfo, pi, &ei_sflow_invalid_address_type);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3348:         &ett_sflow_245_sampled_header,",
          "3349:     };",
          "3352:     proto_sflow = proto_register_protocol(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3353:     static ei_register_info ei[] = {",
          "3354:         { &ei_sflow_invalid_address_type, { \"sflow.invalid_address_type\", PI_MALFORMED, PI_ERROR, \"Unknown/invalid address type\", EXPFILL }},",
          "3355:     };",
          "3357:     expert_module_t* expert_sflow;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3359:     proto_register_field_array(proto_sflow, hf, array_length(hf));",
          "3360:     proto_register_subtree_array(ett, array_length(ett));",
          "3363:     sflow_245_module = prefs_register_protocol(proto_sflow, proto_reg_handoff_sflow_245);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3369:     expert_sflow = expert_register_protocol(proto_sflow);",
          "3370:     expert_register_field_array(expert_sflow, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sigcomp.c||epan/dissectors/packet-sigcomp.c": [
          "File: epan/dissectors/packet-sigcomp.c -> epan/dissectors/packet-sigcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "115: static gint ett_sigcomp_udvm_exe    = -1;",
          "116: static gint ett_raw_text            = -1;",
          "118: static dissector_handle_t sip_handle;",
          "120: static guint SigCompUDPPort1 = 5555;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "118: static expert_field ei_sigcomp_nack_failed_op_code = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "829:             offset++;",
          "833:                                    \"SigComp NACK (reason=%s, opcode=%s)\",",
          "834:                                    val_to_str_const(octet, sigcomp_nack_reason_code_vals, \"Unknown\"),",
          "835:                                    val_to_str_const(opcode, udvm_instruction_code_vals, \"Unknown\"));",
          "",
          "[Removed Lines]",
          "832:             expert_add_info_format(pinfo, reason_ti, PI_SEQUENCE, PI_WARN,",
          "",
          "[Added Lines]",
          "834:             expert_add_info_format_text(pinfo, reason_ti, &ei_sigcomp_nack_failed_op_code,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2582:         &ett_raw_text,",
          "2583:     };",
          "2585:     module_t *sigcomp_module;",
          "2586:     static const enum_val_t udvm_detail_vals[] = {",
          "2587:         {\"no-printout\",   \"No-Printout\", 0},",
          "2588:         {\"low-detail\",    \"Low-detail\", 1},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2587:     static ei_register_info ei[] = {",
          "2588:         { &ei_sigcomp_nack_failed_op_code, { \"sigcomp.nack.failed_op_code.expert\", PI_SEQUENCE, PI_WARN, \"SigComp NACK\", EXPFILL }},",
          "2589:     };",
          "2592:     expert_module_t* expert_sigcomp;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2604:     proto_register_field_array(proto_sigcomp, hf, array_length(hf));",
          "2605:     proto_register_subtree_array(ett, array_length(ett));",
          "2606:     proto_register_subtree_array(ett_raw, array_length(ett_raw));",
          "2609:     sigcomp_module = prefs_register_protocol(proto_sigcomp,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2615:     expert_sigcomp = expert_register_protocol(proto_sigcomp);",
          "2616:     expert_register_field_array(expert_sigcomp, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sip.c||epan/dissectors/packet-sip.c": [
          "File: epan/dissectors/packet-sip.c -> epan/dissectors/packet-sip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "208: static gint ett_sip_ppi_uri               = -1;",
          "209: static gint ett_sip_tc_uri                = -1;",
          "212: static const char *sip_methods[] = {",
          "213: #define SIP_METHOD_INVALID 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211: static expert_field ei_sip_unrecognized_header = EI_INIT;",
          "212: static expert_field ei_sip_header_not_terminated = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2378:      next_tvb2 = tvb_new_subset(tvb, value_offset, value_len, value_len);",
          "2379:      dissector_try_string(ext_hdr_subdissector_table, header_name, next_tvb2, pinfo, proto_item_add_subtree(ti_c, ett_sip_ext_hdr));",
          "2380:      } else {",
          "2383:                             \"Unrecognised SIP header (%s)\",",
          "2384:                             tvb_format_text(tvb, offset, header_len));",
          "2385:     }",
          "",
          "[Removed Lines]",
          "2381:      expert_add_info_format(pinfo, ti_c,",
          "2382:                             PI_UNDECODED, PI_NOTE,",
          "",
          "[Added Lines]",
          "2384:      expert_add_info_format_text(pinfo, ti_c, &ei_sip_unrecognized_header,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3097:       \"[Header not terminated by empty line (CRLF)]\");",
          "3099:    proto_item_set_expert_flags(cause, PI_MALFORMED, PI_WARN);",
          "3103:   }",
          "3104:   offset = next_offset;",
          "",
          "[Removed Lines]",
          "3100:    expert_add_info_format(pinfo, sip_element_item,",
          "3101:     PI_MALFORMED, PI_WARN,",
          "3102:     \"Header not terminated by empty line (CRLF)\");",
          "",
          "[Added Lines]",
          "3102:    expert_add_info(pinfo, sip_element_item, &ei_sip_header_not_terminated);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5168:   &ett_raw_text,",
          "5169:  };",
          "5171:  module_t *sip_module;",
          "5174:  proto_sip = proto_register_protocol(\"Session Initiation Protocol\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5171:  static ei_register_info ei[] = {",
          "5172:   { &ei_sip_unrecognized_header, { \"sip.unrecognized_header\", PI_UNDECODED, PI_NOTE, \"Unrecognised SIP header\", EXPFILL }},",
          "5173:   { &ei_sip_header_not_terminated, { \"sip.header_not_terminated\", PI_MALFORMED, PI_WARN, \"Header not terminated by empty line (CRLF)\", EXPFILL }},",
          "5174:  };",
          "5177:  expert_module_t* expert_sip;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5182:  proto_register_field_array(proto_sip, hf, array_length(hf));",
          "5183:  proto_register_subtree_array(ett, array_length(ett));",
          "5184:  proto_register_subtree_array(ett_raw, array_length(ett_raw));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5190:  expert_sip = expert_register_protocol(proto_sip);",
          "5191:  expert_register_field_array(expert_sip, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-slsk.c||epan/dissectors/packet-slsk.c": [
          "File: epan/dissectors/packet-slsk.c -> epan/dissectors/packet-slsk.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: static gint ett_slsk = -1;",
          "111: static gint ett_slsk_compr_packet = -1;",
          "113: #define TCP_PORT_SLSK_1       2234",
          "114: #define TCP_PORT_SLSK_2       5534",
          "115: #define TCP_PORT_SLSK_3       2240",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113: static expert_field ei_slsk_unknown_data = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2380:   }",
          "2381:   if(offset < (int)msg_len){",
          "2383:   }",
          "",
          "[Removed Lines]",
          "2382:    expert_add_info_format(pinfo, ti_len, PI_UNDECODED, PI_WARN, \"Unknown Data (not interpreted)\");",
          "",
          "[Added Lines]",
          "2384:    expert_add_info(pinfo, ti_len, &ei_slsk_unknown_data);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2591:     &ett_slsk,",
          "2592:     &ett_slsk_compr_packet,",
          "2593:   };",
          "2594:   module_t *slsk_module;",
          "2597:   proto_slsk = proto_register_protocol(\"SoulSeek Protocol\", \"SoulSeek\", \"slsk\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2597:   static ei_register_info ei[] = {",
          "2598:      { &ei_slsk_unknown_data, { \"slsk.unknown_data\", PI_UNDECODED, PI_WARN, \"Unknown Data (not interpreted)\", EXPFILL }},",
          "2599:   };",
          "2602:   expert_module_t* expert_slsk;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2600:   proto_register_field_array(proto_slsk, hf, array_length(hf));",
          "2601:   proto_register_subtree_array(ett, array_length(ett));",
          "2603:   slsk_module = prefs_register_protocol(proto_slsk, NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2610:   expert_slsk = expert_register_protocol(proto_slsk);",
          "2611:   expert_register_field_array(expert_slsk, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-smb.c||epan/dissectors/packet-smb.c": [
          "File: epan/dissectors/packet-smb.c -> epan/dissectors/packet-smb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "800: static gint ett_smb_posix_ace_perms = -1;",
          "801: static gint ett_smb_info2_file_flags = -1;",
          "803: static int smb_tap = -1;",
          "804: static int smb_eo_tap = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "803: static expert_field ei_smb_mal_information_level = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "13411:  }",
          "13413:  if (trunc) {",
          "13416:  }",
          "13417:  return offset;",
          "13418: }",
          "",
          "[Removed Lines]",
          "13414:   expert_add_info_format(pinfo, item, PI_MALFORMED, PI_ERROR,",
          "13415:            \"Information level structure goes past the end of the transation data.\");",
          "",
          "[Added Lines]",
          "13416:   expert_add_info(pinfo, item, &ei_smb_mal_information_level);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "13548:  }",
          "13550:  if (trunc) {",
          "13553:  }",
          "13554:  return offset;",
          "13555: }",
          "",
          "[Removed Lines]",
          "13551:   expert_add_info_format(pinfo, item, PI_MALFORMED, PI_ERROR,",
          "13552:            \"Information level structure goes past the end of the transation data.\");",
          "",
          "[Added Lines]",
          "13552:   expert_add_info(pinfo, item, &ei_smb_mal_information_level);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "21055:   &ett_smb_posix_ace_perms,",
          "21056:   &ett_smb_info2_file_flags",
          "21057:  };",
          "21058:  module_t *smb_module;",
          "21060:  proto_smb = proto_register_protocol(\"SMB (Server Message Block Protocol)\",",
          "21061:      \"SMB\", \"smb\");",
          "21062:  proto_register_subtree_array(ett, array_length(ett));",
          "21063:  proto_register_field_array(proto_smb, hf, array_length(hf));",
          "21065:  proto_do_register_windows_common(proto_smb);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21059:  static ei_register_info ei[] = {",
          "21060:   { &ei_smb_mal_information_level, { \"smb.information_level.malformed\", PI_MALFORMED, PI_ERROR, \"Information level structure goes past the end of the transation data.\", EXPFILL }},",
          "21061:  };",
          "21064:  expert_module_t* expert_smb;",
          "21070:  expert_smb = expert_register_protocol(proto_smb);",
          "21071:  expert_register_field_array(expert_smb, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-spice.c||epan/dissectors/packet-spice.c": [
          "File: epan/dissectors/packet-spice.c -> epan/dissectors/packet-spice.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1026: static int hf_visibility = -1;",
          "1027: static int hf_num_glyphs = -1;",
          "1029: static dissector_handle_t jpeg_handle;",
          "1031: static guint32",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1029: static expert_field ei_spice_decompress_error = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1486:         Uncomp_tree = proto_item_add_subtree(ti, ett_Uncomp_tree);",
          "1487:         dissect_ImageGLZ_RGB(uncompressed_tvb, Uncomp_tree, 0, ZLIB_uncompSize);",
          "1488:     } else {",
          "1490:     }",
          "1491: }",
          "1492: #else",
          "",
          "[Removed Lines]",
          "1489:         expert_add_info_format(pinfo, ti, PI_PROTOCOL, PI_WARN, \"Error: Unable to decompress content\");",
          "",
          "[Added Lines]",
          "1491:         expert_add_info(pinfo, ti, &ei_spice_decompress_error);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4343:         &ett_cap_tree",
          "4344:     };",
          "4347:     proto_spice = proto_register_protocol(\"Spice protocol\",",
          "4348:                                           \"Spice\", \"spice\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4348:     static ei_register_info ei[] = {",
          "4349:         { &ei_spice_decompress_error, { \"spice.decompress_error\", PI_PROTOCOL, PI_WARN, \"Error: Unable to decompress content\", EXPFILL }},",
          "4350:     };",
          "4352:     expert_module_t* expert_spice;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4351:     proto_register_field_array(proto_spice, hf, array_length(hf));",
          "4352:     proto_register_subtree_array(ett, array_length(ett));",
          "4354: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4361:     expert_spice = expert_register_protocol(proto_spice);",
          "4362:     expert_register_field_array(expert_spice, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sprt.c||epan/dissectors/packet-sprt.c": [
          "File: epan/dissectors/packet-sprt.c -> epan/dissectors/packet-sprt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "498: static gint ett_jminfo_msg_cat_data =   -1;",
          "499: static gint ett_connect_msg_adt =       -1;",
          "502: static const value_string sprt_transport_channel_characteristics[] = {",
          "503:     { 0, \"Unreliable, unsequenced\" },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "501: static expert_field ei_sprt_sequence_number_0 = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1437:     proto_tree_add_item(sprt_tree, hf_sprt_transport_channel_id, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1438:     ti = proto_tree_add_item(sprt_tree, hf_sprt_sequence_number, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1439:     if (tc == 0 && seqnum != 0)",
          "1443:     offset+=2;",
          "",
          "[Removed Lines]",
          "1440:         expert_add_info_format(pinfo, ti, PI_PROTOCOL, PI_WARN, \"Should be 0 for transport channel 0\");",
          "",
          "[Added Lines]",
          "1442:         expert_add_info(pinfo, ti, &ei_sprt_sequence_number_0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1518: proto_register_sprt(void)",
          "1519: {",
          "1520:     module_t *sprt_module;",
          "1522:     static hf_register_info hf[] =",
          "1523:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1523:     expert_module_t* expert_sprt;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3393:         &ett_connect_msg_adt",
          "3394:     };",
          "3397:     proto_sprt = proto_register_protocol(\"Simple Packet Relay Transport\", \"SPRT\", \"sprt\");",
          "3400:     proto_register_field_array(proto_sprt, hf, array_length(hf));",
          "3401:     proto_register_subtree_array(ett, array_length(ett));",
          "3404:     new_register_dissector(\"sprt\", dissect_sprt, proto_sprt);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3399:     static ei_register_info ei[] = {",
          "3400:         { &ei_sprt_sequence_number_0, { \"sprt.sequence_number_0\", PI_PROTOCOL, PI_WARN, \"Should be 0 for transport channel 0\", EXPFILL }},",
          "3401:     };",
          "3409:     expert_sprt = expert_register_protocol(proto_sprt);",
          "3410:     expert_register_field_array(expert_sprt, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-ssh.c||epan/dissectors/packet-ssh.c": [
          "File: epan/dissectors/packet-ssh.c -> epan/dissectors/packet-ssh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "145: static gint ett_ssh1 = -1;",
          "146: static gint ett_ssh2 = -1;",
          "148: static gboolean ssh_desegment = TRUE;",
          "150: #define TCP_PORT_SSH  22",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "148: static expert_field ei_ssh_packet_length = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "634:  ti = proto_tree_add_uint(tree, hf_ssh_packet_length, tvb,",
          "635:      offset, 4, plen);",
          "636:  if (plen >= 0xffff) {",
          "638:   plen = remain_length-4;",
          "639:  }",
          "640:  offset+=4;",
          "",
          "[Removed Lines]",
          "637:   expert_add_info_format(pinfo, ti, PI_PROTOCOL, PI_WARN, \"Overly large number %d\",plen);",
          "",
          "[Added Lines]",
          "639:   expert_add_info_format_text(pinfo, ti, &ei_ssh_packet_length, \"Overly large number %d\", plen);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1237:   &ett_ssh2,",
          "1238:   &ett_key_init",
          "1239:  };",
          "1240:  module_t *ssh_module;",
          "1242:  proto_ssh = proto_register_protocol(\"SSH Protocol\", \"SSH\", \"ssh\");",
          "1243:  proto_register_field_array(proto_ssh, hf, array_length(hf));",
          "1244:  proto_register_subtree_array(ett, array_length(ett));",
          "1246:  ssh_module = prefs_register_protocol(proto_ssh, NULL);",
          "1247:  prefs_register_bool_preference(ssh_module, \"desegment_buffers\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1243:  static ei_register_info ei[] = {",
          "1244:   { &ei_ssh_packet_length, { \"ssh.packet_length.error\", PI_PROTOCOL, PI_WARN, \"Overly large number\", EXPFILL }},",
          "1245:  };",
          "1248:  expert_module_t* expert_ssh;",
          "1253:  expert_ssh = expert_register_protocol(proto_ssh);",
          "1254:  expert_register_field_array(expert_ssh, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-ssl.c||epan/dissectors/packet-ssl.c": [
          "File: epan/dissectors/packet-ssl.c -> epan/dissectors/packet-ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "302: static gint ett_ssl_segments          = -1;",
          "303: static gint ett_ssl_segment           = -1;",
          "307:    them anyways to comply with the api (which was aimed for ip fragment",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "305: static expert_field ei_ssl_handshake_cipher_suites_mult2 = EI_INIT;",
          "306: static expert_field ei_ssl_handshake_sig_hash_algs_mult2 = EI_INIT;",
          "307: static expert_field ei_ssl2_handshake_session_id_len_error = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2727:             if (cipher_suite_length % 2) {",
          "2728:                 proto_tree_add_text(tree, tvb, offset, 2,",
          "2729:                     \"Invalid cipher suite length: %d\", cipher_suite_length);",
          "2731:                     \"Cipher suite length (%d) must be a multiple of 2\",",
          "2732:                     cipher_suite_length);",
          "2733:                 return;",
          "",
          "[Removed Lines]",
          "2730:                 expert_add_info_format(pinfo, NULL, PI_MALFORMED, PI_ERROR,",
          "",
          "[Added Lines]",
          "2734:                 expert_add_info_format_text(pinfo, NULL, &ei_ssl_handshake_cipher_suites_mult2,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3083:                 if (sh_alg_length % 2) {",
          "3084:                     proto_tree_add_text(tree, tvb, offset, 2,",
          "3085:                         \"Invalid Signature Hash Algorithm length: %d\", sh_alg_length);",
          "3087:                         \"Signature Hash Algorithm length (%d) must be a multiple of 2\",",
          "3088:                         sh_alg_length);",
          "3089:                     return;",
          "",
          "[Removed Lines]",
          "3086:                     expert_add_info_format(pinfo, NULL, PI_MALFORMED, PI_ERROR,",
          "",
          "[Added Lines]",
          "3090:                     expert_add_info_format_text(pinfo, NULL, &ei_ssl_handshake_sig_hash_algs_mult2,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4017:         if (session_id_length > SSLV2_MAX_SESSION_ID_LENGTH_IN_BYTES) {",
          "4018:             proto_tree_add_text(tree, tvb, offset, 2,",
          "4019:                                 \"Invalid session ID length: %d\", session_id_length);",
          "4021:                                    \"Session ID length (%u) must be less than %u.\",",
          "4022:                                    session_id_length, SSLV2_MAX_SESSION_ID_LENGTH_IN_BYTES);",
          "4023:             return;",
          "",
          "[Removed Lines]",
          "4020:             expert_add_info_format(pinfo, NULL, PI_MALFORMED, PI_ERROR,",
          "",
          "[Added Lines]",
          "4024:             expert_add_info_format_text(pinfo, NULL, &ei_ssl2_handshake_session_id_len_error,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5868:         &ett_ssl_segment",
          "5869:     };",
          "5872:     proto_ssl = proto_register_protocol(\"Secure Sockets Layer\",",
          "5873:                                         \"SSL\", \"ssl\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5875:     static ei_register_info ei[] = {",
          "5876:         { &ei_ssl_handshake_cipher_suites_mult2, { \"ssl.handshake.cipher_suites_length.mult2\", PI_MALFORMED, PI_ERROR, \"Cipher suite length must be a multiple of 2\", EXPFILL }},",
          "5877:         { &ei_ssl_handshake_sig_hash_algs_mult2, { \"ssl.handshake.sig_hash_alg_len.mult2\", PI_MALFORMED, PI_ERROR, \"Signature Hash Algorithm length must be a multiple of 2\", EXPFILL }},",
          "5878:         { &ei_ssl2_handshake_session_id_len_error, { \"ssl.handshake.session_id_length.error\", PI_MALFORMED, PI_ERROR, \"Session ID length error\", EXPFILL }},",
          "5879:     };",
          "5881:     expert_module_t* expert_ssl;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5877:     proto_register_field_array(proto_ssl, hf, array_length(hf));",
          "5878:     proto_register_subtree_array(ett, array_length(ett));",
          "5880:     {",
          "5881:         module_t *ssl_module = prefs_register_protocol(proto_ssl, proto_reg_handoff_ssl);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5891:     expert_ssl = expert_register_protocol(proto_ssl);",
          "5892:     expert_register_field_array(expert_ssl, ei, array_length(ei));",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sysex.c||epan/dissectors/packet-sysex.c": [
          "File: epan/dissectors/packet-sysex.c -> epan/dissectors/packet-sysex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93: static int hf_digitech_nack_request_proc_id = -1;",
          "95: static int hf_digitech_checksum = -1;",
          "99: static gint ett_sysex = -1;",
          "101: #define SYSEX_MANUFACTURER_DOD 0x000010",
          "103: static const value_string sysex_three_byte_manufacturer_id[] = {",
          "",
          "[Removed Lines]",
          "96: static int hf_digitech_checksum_bad = -1;",
          "",
          "[Added Lines]",
          "99: static expert_field ei_sysex_message_start_byte = EI_INIT;",
          "100: static expert_field ei_digitech_checksum_bad = EI_INIT;",
          "101: static expert_field ei_sysex_message_end_byte = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1122:         item = proto_tree_add_item(tree, hf_sysex_message_start, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1123:         if (sysex_helper != 0xF0)",
          "1124:         {",
          "1127:         }",
          "1129:         offset++;",
          "",
          "[Removed Lines]",
          "1125:             expert_add_info_format(pinfo, item, PI_MALFORMED, PI_WARN,",
          "1126:                                    \"SYSEX Error: Wrong start byte\");",
          "",
          "[Added Lines]",
          "1127:             expert_add_info(pinfo, item, &ei_sysex_message_start_byte);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1180:                     digitech_helper ^= *data_ptr++;",
          "1181:                 }",
          "1183:                 checksum = tvb_get_guint8(tvb, offset);",
          "1184:                 if (digitech_helper == 0)",
          "1185:                 {",
          "1190:                 }",
          "1191:                 else",
          "1192:                 {",
          "1202:                 }",
          "1203:                 offset++;",
          "1204:                 break;",
          "",
          "[Removed Lines]",
          "1186:                     proto_tree_add_uint_format(tree,",
          "1187:                                                hf_digitech_checksum, tvb, offset, 1, checksum,",
          "1188:                                                \"Checksum: 0x%02x (correct)\", checksum);",
          "1193:                     item = proto_tree_add_uint_format(tree,",
          "1194:                                                       hf_digitech_checksum, tvb, offset, 1, checksum,",
          "1195:                                                       \"Checksum: 0x%02x (NOT correct)\", checksum);",
          "1196:                     expert_add_info_format(pinfo, item, PI_CHECKSUM, PI_ERROR,",
          "1197:                                            \"Bad checksum\");",
          "1198:                     item = proto_tree_add_boolean(tree,",
          "1199:                                                   hf_digitech_checksum_bad, tvb, offset, 1, TRUE);",
          "1200:                     PROTO_ITEM_SET_HIDDEN(item);",
          "1201:                     PROTO_ITEM_SET_GENERATED(item);",
          "",
          "[Added Lines]",
          "1184:                 item = proto_tree_add_item(tree, hf_digitech_checksum, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1188:                     proto_item_append_text(item, \" (correct)\");",
          "1192:                     proto_item_append_text(item, \" (NOT correct)\");",
          "1193:                     expert_add_info(pinfo, item, &ei_digitech_checksum_bad);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1219:         item = proto_tree_add_item(tree, hf_sysex_message_eox, tvb, data_len - 1, 1, ENC_BIG_ENDIAN);",
          "1220:         if (sysex_helper != 0xF7)",
          "1221:         {",
          "1224:         }",
          "1225:     }",
          "1226: }",
          "",
          "[Removed Lines]",
          "1222:             expert_add_info_format(pinfo, item, PI_MALFORMED, PI_WARN,",
          "1223:                                    \"SYSEX Error: Wrong end byte\");",
          "",
          "[Added Lines]",
          "1214:             expert_add_info(pinfo, item, &ei_sysex_message_end_byte);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1396:         { &hf_digitech_checksum,",
          "1397:             { \"Checksum\", \"sysex.digitech.checksum\", FT_UINT8, BASE_HEX,",
          "1398:               NULL, 0, NULL, HFILL }},",
          "1402:     };",
          "1404:     static gint *sysex_subtrees[] = {",
          "1405:         &ett_sysex",
          "1406:     };",
          "1408:     proto_sysex = proto_register_protocol(\"MIDI System Exclusive\", \"SYSEX\", \"sysex\");",
          "1409:     proto_register_field_array(proto_sysex, hf, array_length(hf));",
          "1410:     proto_register_subtree_array(sysex_subtrees, array_length(sysex_subtrees));",
          "1412:     register_dissector(\"sysex\", dissect_sysex_command, proto_sysex);",
          "1413: }",
          "",
          "[Removed Lines]",
          "1399:         { &hf_digitech_checksum_bad,",
          "1400:             { \"Bad Checksum\", \"sysex.digitech.checksum_bad\", FT_BOOLEAN, BASE_NONE,",
          "1401:               NULL, 0, \"A bad checksum in command\", HFILL }},",
          "",
          "[Added Lines]",
          "1396:     static ei_register_info ei[] = {",
          "1397:         { &ei_sysex_message_start_byte, { \"sysex.message_start_byte\", PI_PROTOCOL, PI_WARN, \"SYSEX Error: Wrong start byte\", EXPFILL }},",
          "1398:         { &ei_digitech_checksum_bad, { \"sysex.digitech.checksum_bad\", PI_CHECKSUM, PI_WARN, \"ARP packet storm detected\", EXPFILL }},",
          "1399:         { &ei_sysex_message_end_byte, { \"sysex.message_end_byte\", PI_PROTOCOL, PI_WARN, \"SYSEX Error: Wrong end byte\", EXPFILL }},",
          "1400:     };",
          "1402:     expert_module_t* expert_sysex;",
          "1407:     expert_sysex = expert_register_protocol(proto_sysex);",
          "1408:     expert_register_field_array(expert_sysex, ei, array_length(ei));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4daf6f38d9b4ac0c51f6441d8b8b1cadb90327f6",
      "candidate_info": {
        "commit_hash": "4daf6f38d9b4ac0c51f6441d8b8b1cadb90327f6",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/4daf6f38d9b4ac0c51f6441d8b8b1cadb90327f6",
        "files": [
          "epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-rtp.h"
        ],
        "message": "Make payload type arguments guint rather than guint8.\n\nThat should suppress some \"cast to pointer from integer of different\nsize\" warnings.\n\nChange-Id: I2ef38e16ce866e244cb7c0a2275dfb5975980fc4\nReviewed-on: https://code.wireshark.org/review/938\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h"
          ],
          "candidate": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
          "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "975: void",
          "976: rtp_dyn_payload_insert(rtp_dyn_payload_t *rtp_dyn_payload,",
          "978:                        const gchar* encoding_name,",
          "979:                        const int sample_rate)",
          "980: {",
          "",
          "[Removed Lines]",
          "977:                        const guint8 pt,",
          "",
          "[Added Lines]",
          "977:                        const guint pt,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "993: void",
          "994: rtp_dyn_payload_replace(rtp_dyn_payload_t *rtp_dyn_payload,",
          "996:                         const gchar* encoding_name,",
          "997:                         const int sample_rate)",
          "998: {",
          "",
          "[Removed Lines]",
          "995:                         const guint8 pt,",
          "",
          "[Added Lines]",
          "995:                         const guint pt,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1009: gboolean",
          "1011: {",
          "1012:     return (rtp_dyn_payload && rtp_dyn_payload->table &&",
          "1013:             g_hash_table_remove(rtp_dyn_payload->table, GUINT_TO_POINTER(pt)));",
          "",
          "[Removed Lines]",
          "1010: rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt)",
          "",
          "[Added Lines]",
          "1010: rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint pt)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1017: const gchar*",
          "1019: {",
          "1020:     encoding_name_and_rate_t *encoding_name_and_rate_pt;",
          "",
          "[Removed Lines]",
          "1018: rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt)",
          "",
          "[Added Lines]",
          "1018: rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint pt)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1031:    successful, else FALSE. The encoding string pointed to is only valid until the entry is",
          "1033: gboolean",
          "1035:                          const gchar **encoding_name, int *sample_rate)",
          "1036: {",
          "1037:     encoding_name_and_rate_t *encoding_name_and_rate_pt;",
          "",
          "[Removed Lines]",
          "1034: rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt,",
          "",
          "[Added Lines]",
          "1034: rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint pt,",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h": [
          "File: epan/dissectors/packet-rtp.h -> epan/dissectors/packet-rtp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "126: WS_DLL_PUBLIC",
          "127: void rtp_dyn_payload_insert(rtp_dyn_payload_t *rtp_dyn_payload,",
          "129:        const gchar* encoding_name,",
          "130:        const int sample_rate);",
          "",
          "[Removed Lines]",
          "128:        const guint8 pt,",
          "",
          "[Added Lines]",
          "128:        const guint pt,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135: WS_DLL_PUBLIC",
          "136: void rtp_dyn_payload_replace(rtp_dyn_payload_t *rtp_dyn_payload,",
          "138:        const gchar* encoding_name,",
          "139:        const int sample_rate);",
          "142: WS_DLL_PUBLIC",
          "146:    until the entry is replaced, removed, or the hash table is destroyed, so duplicate it if",
          "148: WS_DLL_PUBLIC",
          "152:    successful, else FALSE. The encoding string pointed to is only valid until the entry is",
          "154: WS_DLL_PUBLIC",
          "156:           const gchar **encoding_name, int *sample_rate);",
          "",
          "[Removed Lines]",
          "137:        const guint8 pt,",
          "143: gboolean rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt);",
          "149: const gchar* rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt);",
          "155: gboolean rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt,",
          "",
          "[Added Lines]",
          "137:        const guint pt,",
          "143: gboolean rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint pt);",
          "149: const gchar* rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint pt);",
          "155: gboolean rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint pt,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-20218",
  "cve_desc": "selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.",
  "repo": "sqlite/sqlite",
  "patch_hash": "a6c1a71cde082e09750465d5675699062922e387",
  "patch_info": {
    "commit_hash": "a6c1a71cde082e09750465d5675699062922e387",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/a6c1a71cde082e09750465d5675699062922e387",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/altertab3.test"
    ],
    "message": "Do not attempt to unwind the WITH stack in the Parse object following an error. This fixes a separate case to [de6e6d68].\n\nFossilOrigin-Name: d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/altertab3.test||test/altertab3.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 597896ed0ae9e2960a8f39576bd7f77a11dccc1da84b6a44ebb5c38d90ebc330",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4982:     return WRC_Abort;",
      "4983:   }",
      "",
      "[Removed Lines]",
      "4981:   if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "[Added Lines]",
      "4981:   if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "---------------"
    ],
    "test/altertab3.test||test/altertab3.test": [
      "File: test/altertab3.test -> test/altertab3.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "531:   ALTER TABLE t1 RENAME TO t1x;",
      "532: } {1 {error in trigger r1: no such table: main.t2}}",
      "534: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "534: #------------------------------------------------------------------------",
      "535: #",
      "536: reset_db",
      "537: do_execsql_test 23.1 {",
      "538:   CREATE TABLE v0 (a);",
      "539:   CREATE VIEW v2 (v3) AS",
      "540:     WITH x1 AS (SELECT * FROM v2)",
      "541:     SELECT v3 AS x, v3 AS y FROM v2;",
      "542: }",
      "544: do_catchsql_test 23.2 {",
      "545:   SELECT * FROM v2",
      "546: } {1 {view v2 is circularly defined}}",
      "548: db close",
      "549: sqlite3 db test.db",
      "551: do_catchsql_test 23.3 {",
      "552:   ALTER TABLE v0 RENAME TO t3 ;",
      "553: } {1 {error in view v2: view v2 is circularly defined}}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "34ab941e5bae10894b3c0653248c6636edc5e9f8",
      "candidate_info": {
        "commit_hash": "34ab941e5bae10894b3c0653248c6636edc5e9f8",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/34ab941e5bae10894b3c0653248c6636edc5e9f8",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "test/nulls1.test"
        ],
        "message": "Detect the invalid use of NULLS LAST on an INTEGER PRIMARY KEY definition of a WITHOUT ROWID table.\n\nFossilOrigin-Name: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "test/nulls1.test||test/nulls1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: a80f84b511231204658304226de3e075a55afc2e3f39ac063716f7a57f585c06",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1547:     assert( autoInc==0 || autoInc==1 );",
          "1548:     pTab->tabFlags |= autoInc*TF_Autoincrement;",
          "1549:     if( pList ) pParse->iPkSortOrder = pList->a[0].sortFlags;",
          "1550:   }else if( autoInc ){",
          "1551: #ifndef SQLITE_OMIT_AUTOINCREMENT",
          "1552:     sqlite3ErrorMsg(pParse, \"AUTOINCREMENT is only allowed on an \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1550:     (void)sqlite3HasExplicitNulls(pParse, pList);",
          "",
          "---------------"
        ],
        "test/nulls1.test||test/nulls1.test": [
          "File: test/nulls1.test -> test/nulls1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "248:   SELECT * FROM t71 ORDER BY a DESC NULLS FIRST;",
          "249: }",
          "251: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "251: # 2019-12-18 gramfuzz1 find",
          "252: # NULLS LAST not allows on an INTEGER PRIMARY KEY.",
          "253: #",
          "254: do_catchsql_test 8.0 {",
          "255:   CREATE TABLE t80(a, b INTEGER, PRIMARY KEY(b NULLS LAST)) WITHOUT ROWID;",
          "256: } {1 {unsupported use of NULLS LAST}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "37874d7dccf49e8de10341cf61184db407425eb4",
      "candidate_info": {
        "commit_hash": "37874d7dccf49e8de10341cf61184db407425eb4",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/37874d7dccf49e8de10341cf61184db407425eb4",
        "files": [
          "ext/expert/expert1.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Disable broken test case in expert1.test.\n\nFossilOrigin-Name: 73e30c2e92ccab274ff7cee48511c461de148786bb9d338921c1ecb193822282",
        "before_after_code_files": [
          "ext/expert/expert1.test||ext/expert/expert1.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/expert/expert1.test||ext/expert/expert1.test": [
          "File: ext/expert/expert1.test -> ext/expert/expert1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:   SEARCH TABLE t1 USING COVERING INDEX t1_idx_000123a7 (a=?)",
          "135: }",
          "137: do_setup_rec_test $tn.6 {",
          "138:   CREATE TABLE t1(a, b, c);",
          "139: } {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: if 0 {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142:   CREATE INDEX t1_idx_00000061 ON t1(a);",
          "143:   SEARCH TABLE t1 USING COVERING INDEX t1_idx_00000061",
          "144: }",
          "146: do_setup_rec_test $tn.7 {",
          "147:   CREATE TABLE t1(a, b, c);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146: }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6153bcf41a9aa0497f8210311c99ac23846223068f2b6a3a1c2d9dec7673c7e1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f1173b69b1c3bfc68ea2877e6fabf15902b7bf72",
      "candidate_info": {
        "commit_hash": "f1173b69b1c3bfc68ea2877e6fabf15902b7bf72",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f1173b69b1c3bfc68ea2877e6fabf15902b7bf72",
        "files": [
          "ext/misc/dbdata.c",
          "manifest",
          "manifest.uuid",
          "test/dbdata.test"
        ],
        "message": "Add the experimental dbdata extension.\n\nFossilOrigin-Name: a3ab58832935e1399ecc7e4d8daefa3a6afa6b301792ce7176bc5d7c173510fb",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "manifest.uuid||manifest.uuid",
          "test/dbdata.test||test/dbdata.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: #if !defined(SQLITEINT_H)",
          "57: #include \"sqlite3ext.h\"",
          "59: typedef unsigned char u8;",
          "60: typedef unsigned int u32;",
          "62: #endif",
          "63: SQLITE_EXTENSION_INIT1",
          "64: #include <string.h>",
          "65: #include <assert.h>",
          "67: typedef struct DbdataTable DbdataTable;",
          "68: typedef struct DbdataCursor DbdataCursor;",
          "71: struct DbdataCursor {",
          "86:   sqlite3_int64 iRowid;",
          "87: };",
          "90: struct DbdataTable {",
          "93: };",
          "95: #define DBDATA_COLUMN_PGNO        0",
          "96: #define DBDATA_COLUMN_CELL        1",
          "97: #define DBDATA_COLUMN_FIELD       2",
          "98: #define DBDATA_COLUMN_VALUE       3",
          "99: #define DBDATA_COLUMN_SCHEMA      4",
          "101: #define DBDATA_SCHEMA             \\",
          "102:       \"CREATE TABLE x(\"           \\",
          "103:       \"  pgno INTEGER,\"           \\",
          "104:       \"  cell INTEGER,\"           \\",
          "105:       \"  field INTEGER,\"          \\",
          "106:       \"  value ANY,\"              \\",
          "107:       \"  schema TEXT HIDDEN\"      \\",
          "108:       \")\"",
          "113: static int dbdataConnect(",
          "114:   sqlite3 *db,",
          "115:   void *pAux,",
          "116:   int argc, const char *const*argv,",
          "117:   sqlite3_vtab **ppVtab,",
          "118:   char **pzErr",
          "119: ){",
          "120:   DbdataTable *pTab = 0;",
          "121:   int rc = sqlite3_declare_vtab(db, DBDATA_SCHEMA);",
          "123:   if( rc==SQLITE_OK ){",
          "124:     pTab = (DbdataTable*)sqlite3_malloc64(sizeof(DbdataTable));",
          "125:     if( pTab==0 ){",
          "126:       rc = SQLITE_NOMEM;",
          "127:     }else{",
          "128:       memset(pTab, 0, sizeof(DbdataTable));",
          "129:       pTab->db = db;",
          "130:     }",
          "131:   }",
          "134:   return rc;",
          "135: }",
          "140: static int dbdataDisconnect(sqlite3_vtab *pVtab){",
          "141:   sqlite3_free(pVtab);",
          "142:   return SQLITE_OK;",
          "143: }",
          "159: static int dbdataBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){",
          "160:   int i;",
          "161:   int iSchema = -1;",
          "162:   int iPgno = -1;",
          "164:   for(i=0; i<pIdxInfo->nConstraint; i++){",
          "165:     struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[i];",
          "166:     if( p->op==SQLITE_INDEX_CONSTRAINT_EQ ){",
          "167:       if( p->iColumn==DBDATA_COLUMN_SCHEMA ){",
          "168:         if( p->usable==0 ) return SQLITE_CONSTRAINT;",
          "169:         iSchema = i;",
          "170:       }",
          "171:       if( p->iColumn==DBDATA_COLUMN_PGNO && p->usable ){",
          "172:         iPgno = i;",
          "173:       }",
          "174:     }",
          "175:   }",
          "177:   if( iSchema>=0 ){",
          "178:     pIdxInfo->aConstraintUsage[iSchema].argvIndex = 1;",
          "179:     pIdxInfo->aConstraintUsage[iSchema].omit = 1;",
          "180:   }",
          "181:   if( iPgno>=0 ){",
          "182:     pIdxInfo->aConstraintUsage[iPgno].argvIndex = 1 + (iSchema>=0);",
          "183:     pIdxInfo->aConstraintUsage[iPgno].omit = 1;",
          "184:   }",
          "185:   pIdxInfo->idxNum = (iSchema>=0 ? 0x01 : 0x00) | (iPgno>=0 ? 0x02 : 0x00);",
          "186:   return SQLITE_OK;",
          "187: }",
          "192: static int dbdataOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){",
          "193:   DbdataCursor *pCsr;",
          "195:   pCsr = (DbdataCursor*)sqlite3_malloc64(sizeof(DbdataCursor));",
          "196:   if( pCsr==0 ){",
          "197:     return SQLITE_NOMEM;",
          "198:   }else{",
          "199:     memset(pCsr, 0, sizeof(DbdataCursor));",
          "200:     pCsr->base.pVtab = pVTab;",
          "201:   }",
          "204:   return SQLITE_OK;",
          "205: }",
          "207: static void dbdataResetCursor(DbdataCursor *pCsr){",
          "208:   sqlite3_finalize(pCsr->pStmt);",
          "209:   pCsr->pStmt = 0;",
          "210:   pCsr->iPgno = 1;",
          "211:   pCsr->iCell = 0;",
          "212:   pCsr->iField = 0;",
          "213: }",
          "218: static int dbdataClose(sqlite3_vtab_cursor *pCursor){",
          "219:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "220:   dbdataResetCursor(pCsr);",
          "221:   sqlite3_free(pCsr);",
          "222:   return SQLITE_OK;",
          "223: }",
          "227: static unsigned int get_uint16(unsigned char *a){",
          "228:   return (a[0]<<8)|a[1];",
          "229: }",
          "230: static unsigned int get_uint32(unsigned char *a){",
          "231:   return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|a[3];",
          "232: }",
          "234: static int dbdataLoadPage(",
          "235:   DbdataCursor *pCsr,",
          "236:   u32 pgno,",
          "237:   u8 **ppPage,",
          "238:   int *pnPage",
          "239: ){",
          "240:   int rc2;",
          "241:   int rc = SQLITE_OK;",
          "242:   sqlite3_stmt *pStmt = pCsr->pStmt;",
          "246:   sqlite3_bind_int64(pStmt, 2, pgno);",
          "247:   if( SQLITE_ROW==sqlite3_step(pStmt) ){",
          "248:     int nCopy = sqlite3_column_bytes(pStmt, 0);",
          "249:     u8 *pPage = (u8*)sqlite3_malloc64(nCopy);",
          "250:     if( pPage==0 ){",
          "251:       rc = SQLITE_NOMEM;",
          "252:     }else{",
          "253:       const u8 *pCopy = sqlite3_column_blob(pStmt, 0);",
          "254:       memcpy(pPage, pCopy, nCopy);",
          "257:     }",
          "258:   }",
          "259:   rc2 = sqlite3_reset(pStmt);",
          "260:   if( *ppPage==0 ) rc = rc2;",
          "262:   return rc;",
          "263: }",
          "268: static int dbdataGetVarint(const u8 *z, sqlite3_int64 *pVal){",
          "269:   sqlite3_int64 v = 0;",
          "270:   int i;",
          "271:   for(i=0; i<8; i++){",
          "272:     v = (v<<7) + (z[i]&0x7f);",
          "273:     if( (z[i]&0x80)==0 ){ *pVal = v; return i+1; }",
          "274:   }",
          "275:   v = (v<<8) + (z[i]&0xff);",
          "277:   return 9;",
          "278: }",
          "283: static int dbdataNext(sqlite3_vtab_cursor *pCursor){",
          "284:   DbdataCursor *pCsr = (DbdataCursor *)pCursor;",
          "286:   pCsr->iRowid++;",
          "287:   while( 1 ){",
          "288:     int rc;",
          "290:     if( pCsr->aPage==0 ){",
          "291:       rc = dbdataLoadPage(pCsr, pCsr->iPgno, &pCsr->aPage, &pCsr->nPage);",
          "292:       if( rc!=SQLITE_OK ) return rc;",
          "293:       pCsr->iCell = 0;",
          "294:       pCsr->nCell = get_uint16(&pCsr->aPage[pCsr->iPgno==1 ? 103 : 3]);",
          "295:     }",
          "298:     if( pCsr->pRec==0 ){",
          "299:       int iOff = (pCsr->iPgno==1 ? 100 : 0);",
          "300:       int bHasRowid = 0;",
          "301:       int nPointer = 0;",
          "302:       sqlite3_int64 nPayload = 0;",
          "303:       sqlite3_int64 nHdr = 0;",
          "304:       int iHdr;",
          "305:       int U, X;",
          "306:       int nLocal;",
          "308:       switch( pCsr->aPage[iOff] ){",
          "309:         case 0x02:",
          "310:           nPointer = 4;",
          "311:           break;",
          "312:         case 0x0a:",
          "313:           break;",
          "314:         case 0x0d:",
          "315:           bHasRowid = 1;",
          "316:           break;",
          "317:         default:",
          "318:           pCsr->iCell = pCsr->nCell;",
          "319:           break;",
          "320:       }",
          "321:       if( pCsr->iCell>=pCsr->nCell ){",
          "322:         sqlite3_free(pCsr->aPage);",
          "323:         pCsr->aPage = 0;",
          "324:         return SQLITE_OK;",
          "325:       }",
          "327:       iOff += 8 + nPointer + pCsr->iCell*2;",
          "328:       iOff = get_uint16(&pCsr->aPage[iOff]);",
          "331:       iOff += nPointer;",
          "334:       iOff += dbdataGetVarint(&pCsr->aPage[iOff], &nPayload);",
          "337:       if( bHasRowid ){",
          "338:         iOff += dbdataGetVarint(&pCsr->aPage[iOff], &pCsr->iIntkey);",
          "339:       }",
          "342:       pCsr->pRec = (u8*)sqlite3_malloc64(nPayload);",
          "343:       if( pCsr->pRec==0 ) return SQLITE_NOMEM;",
          "344:       pCsr->nRec = nPayload;",
          "346:       U = pCsr->nPage;",
          "347:       if( bHasRowid ){",
          "348:         X = U-35;",
          "349:       }else{",
          "350:         X = ((U-12)*64/255)-23;",
          "351:       }",
          "352:       if( nPayload<=X ){",
          "353:         nLocal = nPayload;",
          "354:       }else{",
          "355:         int M, K;",
          "356:         M = ((U-12)*32/255)-23;",
          "357:         K = M+((nPayload-M)%(U-4));",
          "358:         if( K<=X ){",
          "359:           nLocal = K;",
          "360:         }else{",
          "361:           nLocal = M;",
          "362:         }",
          "363:       }",
          "366:       memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);",
          "367:       iOff += nLocal;",
          "370:       if( nPayload>nLocal ){",
          "371:         sqlite3_int64 nRem = nPayload - nLocal;",
          "372:         u32 pgnoOvfl = get_uint32(&pCsr->aPage[iOff]);",
          "373:         while( nRem>0 ){",
          "374:           u8 *aOvfl = 0;",
          "375:           int nOvfl = 0;",
          "376:           int nCopy;",
          "377:           rc = dbdataLoadPage(pCsr, pgnoOvfl, &aOvfl, &nOvfl);",
          "378:           assert( rc!=SQLITE_OK || nOvfl==pCsr->nPage );",
          "379:           if( rc!=SQLITE_OK ) return rc;",
          "381:           nCopy = U-4;",
          "382:           if( nCopy>nRem ) nCopy = nRem;",
          "383:           memcpy(&pCsr->pRec[nPayload-nRem], &aOvfl[4], nCopy);",
          "384:           nRem -= nCopy;",
          "386:           sqlite3_free(aOvfl);",
          "387:         }",
          "388:       }",
          "391:       pCsr->nField = 0;",
          "392:       iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);",
          "393:       while( iHdr<nHdr ){",
          "394:         sqlite3_int64 iDummy;",
          "395:         iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iDummy);",
          "396:         pCsr->nField++;",
          "397:       }",
          "399:       pCsr->iField = (bHasRowid ? -2 : -1);",
          "400:     }",
          "402:     pCsr->iField++;",
          "403:     if( pCsr->iField<pCsr->nField ) return SQLITE_OK;",
          "407:     sqlite3_free(pCsr->pRec);",
          "408:     pCsr->pRec = 0;",
          "409:     pCsr->iCell++;",
          "410:   }",
          "412:   assert( !\"can't get here\" );",
          "413:   return SQLITE_OK;",
          "414: }",
          "419: static int dbdataEof(sqlite3_vtab_cursor *pCursor){",
          "420:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "421:   return pCsr->aPage==0;",
          "422: }",
          "426: static int dbdataFilter(",
          "427:   sqlite3_vtab_cursor *pCursor,",
          "428:   int idxNum, const char *idxStr,",
          "429:   int argc, sqlite3_value **argv",
          "430: ){",
          "431:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "432:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "433:   int rc;",
          "434:   const char *zSchema = \"main\";",
          "436:   dbdataResetCursor(pCsr);",
          "437:   assert( pCsr->iPgno==1 );",
          "438:   if( idxNum & 0x01 ){",
          "439:     zSchema = sqlite3_value_text(argv[0]);",
          "440:   }",
          "441:   if( idxNum & 0x02 ){",
          "442:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);",
          "443:   }",
          "445:   rc = sqlite3_prepare_v2(pTab->db,",
          "446:       \"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\", -1,",
          "447:       &pCsr->pStmt, 0",
          "448:   );",
          "449:   if( rc==SQLITE_OK ){",
          "450:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);",
          "451:   }",
          "452:   if( rc==SQLITE_OK ){",
          "453:     rc = dbdataNext(pCursor);",
          "454:   }",
          "455:   return rc;",
          "456: }",
          "458: static int dbdataValueBytes(int eType){",
          "459:   switch( eType ){",
          "460:     case 0: case 8: case 9:",
          "461:     case 10: case 11:",
          "462:       return 0;",
          "463:     case 1:",
          "464:       return 1;",
          "465:     case 2:",
          "466:       return 2;",
          "467:     case 3:",
          "468:       return 3;",
          "469:     case 4:",
          "470:       return 4;",
          "471:     case 5:",
          "472:       return 6;",
          "473:     case 6:",
          "474:     case 7:",
          "475:       return 8;",
          "476:     default:",
          "477:       return ((eType-12) / 2);",
          "478:   }",
          "479: }",
          "481: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "482:   switch( eType ){",
          "483:     case 0:",
          "484:     case 10:",
          "485:     case 11:",
          "486:       sqlite3_result_null(pCtx);",
          "487:       break;",
          "489:     case 8:",
          "490:       sqlite3_result_int(pCtx, 0);",
          "491:       break;",
          "492:     case 9:",
          "493:       sqlite3_result_int(pCtx, 1);",
          "494:       break;",
          "496:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "497:       sqlite3_uint64 v = (signed char)pData[0];",
          "498:       pData++;",
          "499:       switch( eType ){",
          "500:         case 7:",
          "501:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "502:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "503:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "504:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "505:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "506:       }",
          "508:       if( eType==7 ){",
          "509:         double r;",
          "510:         memcpy(&r, &v, sizeof(r));",
          "511:         sqlite3_result_double(pCtx, r);",
          "512:       }else{",
          "513:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "514:       }",
          "515:       break;",
          "516:     }",
          "518:     default: {",
          "519:       int n = ((eType-12) / 2);",
          "520:       if( eType % 2 ){",
          "521:         sqlite3_result_text(pCtx, pData, n, SQLITE_TRANSIENT);",
          "522:       }else{",
          "523:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "524:       }",
          "525:     }",
          "526:   }",
          "527: }",
          "530: static int dbdataColumn(",
          "531:   sqlite3_vtab_cursor *pCursor,",
          "532:   sqlite3_context *ctx,",
          "533:   int i",
          "534: ){",
          "535:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "536:   switch( i ){",
          "537:     case DBDATA_COLUMN_PGNO:",
          "538:       sqlite3_result_int64(ctx, pCsr->iPgno);",
          "539:       break;",
          "540:     case DBDATA_COLUMN_CELL:",
          "541:       sqlite3_result_int(ctx, pCsr->iCell);",
          "542:       break;",
          "543:     case DBDATA_COLUMN_FIELD:",
          "544:       sqlite3_result_int(ctx, pCsr->iField);",
          "545:       break;",
          "546:     case DBDATA_COLUMN_VALUE: {",
          "547:       if( pCsr->iField<0 ){",
          "548:         sqlite3_result_int64(ctx, pCsr->iIntkey);",
          "549:       }else{",
          "550:         int iHdr;",
          "551:         sqlite3_int64 iType;",
          "552:         sqlite3_int64 iOff;",
          "553:         int i;",
          "554:         iHdr = dbdataGetVarint(pCsr->pRec, &iOff);",
          "555:         for(i=0; i<pCsr->iField; i++){",
          "556:           iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "557:           iOff += dbdataValueBytes(iType);",
          "558:         }",
          "559:         dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "561:         dbdataValue(ctx, iType, &pCsr->pRec[iOff]);",
          "562:       }",
          "563:       break;",
          "564:     }",
          "565:   }",
          "566:   return SQLITE_OK;",
          "567: }",
          "570: static int dbdataRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){",
          "571:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "573:   return SQLITE_OK;",
          "574: }",
          "580: static int sqlite3DbdataRegister(sqlite3 *db){",
          "581:   static sqlite3_module dbdata_module = {",
          "606:   };",
          "607:   return sqlite3_create_module(db, \"sqlite_dbdata\", &dbdata_module, 0);",
          "608: }",
          "610: #ifdef _WIN32",
          "611: __declspec(dllexport)",
          "612: #endif",
          "613: int sqlite3_dbdata_init(",
          "614:   sqlite3 *db,",
          "615:   char **pzErrMsg,",
          "616:   const sqlite3_api_routines *pApi",
          "617: ){",
          "618:   SQLITE_EXTENSION_INIT2(pApi);",
          "619:   return sqlite3DbdataRegister(db);",
          "620: }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7ac500fb5abfe1ad60f2ffdcc8fbe5ccc1c641bbeed53f00940e9ff78788e53d",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/dbdata.test||test/dbdata.test": [
          "File: test/dbdata.test -> test/dbdata.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019-04-11",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this file is testing the sqlite_dbpage virtual table.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix dbdata",
          "19: ifcapable !vtab||!compound {",
          "20:   finish_test",
          "21:   return",
          "22: }",
          "23: db enable_load_extension 1",
          "24: if { [catch { db eval { SELECT load_extension('../dbdata') } }] } {",
          "25:   finish_test",
          "26:   return",
          "27: }",
          "29: do_execsql_test 1.0 {",
          "30:   CREATE TABLE T1(a, b);",
          "31:   INSERT INTO t1(rowid, a ,b) VALUES(5, 'v', 'five');",
          "32:   INSERT INTO t1(rowid, a, b) VALUES(10, 'x', 'ten');",
          "33: }",
          "35: do_execsql_test 1.1 {",
          "36:   SELECT pgno, cell, field, quote(value) FROM sqlite_dbdata WHERE pgno=2;",
          "37: } {",
          "38:   2 0 -1 5",
          "39:   2 0  0 'v'",
          "40:   2 0  1 'five'",
          "41:   2 1 -1 10",
          "42:   2 1  0 'x'",
          "43:   2 1  1 'ten'",
          "44: }",
          "46: set big [string repeat big 2000]",
          "47: do_execsql_test 1.2 {",
          "48:   INSERT INTO t1 VALUES(NULL, $big);",
          "49:   SELECT value FROM sqlite_dbdata WHERE pgno=2 AND cell=2 AND field=1;",
          "50: } $big",
          "54: finish_test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e087a7c35b1bedfb37c2b41baac77e794ed89f63",
      "candidate_info": {
        "commit_hash": "e087a7c35b1bedfb37c2b41baac77e794ed89f63",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e087a7c35b1bedfb37c2b41baac77e794ed89f63",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/windowB.test"
        ],
        "message": "Fix the windowB test module so that it works even if SQLite is built without JSON support.\n\nFossilOrigin-Name: 807975c76b36347f02aa0ce9661d608adbffe1f7e77c15f8da677e47e1187153",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/windowB.test||test/windowB.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ba2ebc3a348decc5cedaf14960e30e7ae26a26824cfa198727f2499162142ef3",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/windowB.test||test/windowB.test": [
          "File: test/windowB.test -> test/windowB.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:   INSERT INTO testjson VALUES(2, '{\"b\":2}');",
          "88: }",
          "102: }",
          "105: finish_test",
          "",
          "[Removed Lines]",
          "90: do_execsql_test 3.1 {",
          "91:   SELECT json_group_array(json(j)) FROM testjson;",
          "92: } {",
          "93:   {[{\"a\":1},{\"b\":2}]}",
          "94: }",
          "96: breakpoint",
          "97: do_execsql_test 3.2 {",
          "98:   SELECT json_group_array(json(j)) OVER (ORDER BY id) FROM testjson;",
          "99: } {",
          "100:   {[{\"a\":1}]}",
          "101:   {[{\"a\":1},{\"b\":2}]}",
          "",
          "[Added Lines]",
          "90: ifcapable json1 {",
          "91:   do_execsql_test 3.1 {",
          "92:     SELECT json_group_array(json(j)) FROM testjson;",
          "93:   } {",
          "94:     {[{\"a\":1},{\"b\":2}]}",
          "95:   }",
          "97:   do_execsql_test 3.2 {",
          "98:     SELECT json_group_array(json(j)) OVER (ORDER BY id) FROM testjson;",
          "99:   } {",
          "100:     {[{\"a\":1}]}",
          "101:     {[{\"a\":1},{\"b\":2}]}",
          "102:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f4f31df02d77857252093c7be4641d9abb27476b",
      "candidate_info": {
        "commit_hash": "f4f31df02d77857252093c7be4641d9abb27476b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f4f31df02d77857252093c7be4641d9abb27476b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vtab.c",
          "test/fuzzdata8.db"
        ],
        "message": "When creating a new virtual table, ensure that the OP_ParseSchema opcode processes the correct entry in the sqlite_master table even if there is a second entry with the same name and table values due to database corruption and the use of writable_schema=ON.  Dbsqlfuzz find.\n\nFossilOrigin-Name: 4dbb6e1cb094f3428c74ea8bdd86ab63341fecce978a062968ca01423f382e90",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vtab.c||src/vtab.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ea721b34477ab8b49d182352c4bc198245933b850e9b6248b4f97600e80bb44b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vtab.c||src/vtab.c": [
          "File: src/vtab.c -> src/vtab.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "484:       zStmt,",
          "485:       pParse->regRowid",
          "486:     );",
          "488:     v = sqlite3GetVdbe(pParse);",
          "489:     sqlite3ChangeCookie(pParse, iDb);",
          "491:     sqlite3VdbeAddOp0(v, OP_Expire);",
          "493:     sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);",
          "495:     iReg = ++pParse->nMem;",
          "496:     sqlite3VdbeLoadString(v, iReg, pTab->zName);",
          "",
          "[Removed Lines]",
          "487:     sqlite3DbFree(db, zStmt);",
          "492:     zWhere = sqlite3MPrintf(db, \"name='%q' AND type='table'\", pTab->zName);",
          "",
          "[Added Lines]",
          "491:     zWhere = sqlite3MPrintf(db, \"name=%Q AND sql=%Q\", pTab->zName, zStmt);",
          "493:     sqlite3DbFree(db, zStmt);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
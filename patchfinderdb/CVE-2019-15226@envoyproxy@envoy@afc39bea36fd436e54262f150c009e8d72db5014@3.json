{
  "cve_id": "CVE-2019-15226",
  "cve_desc": "Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.",
  "repo": "envoyproxy/envoy",
  "patch_hash": "afc39bea36fd436e54262f150c009e8d72db5014",
  "patch_info": {
    "commit_hash": "afc39bea36fd436e54262f150c009e8d72db5014",
    "repo": "envoyproxy/envoy",
    "commit_url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014",
    "files": [
      "docs/root/intro/version_history.rst",
      "include/envoy/access_log/access_log.h",
      "include/envoy/http/header_map.h",
      "source/common/http/conn_manager_impl.cc",
      "source/common/http/header_map_impl.cc",
      "source/common/http/header_map_impl.h",
      "source/common/http/http1/codec_impl.cc",
      "source/common/http/http2/codec_impl.cc",
      "source/common/router/router.cc",
      "source/extensions/access_loggers/common/access_log_base.h",
      "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc",
      "source/extensions/filters/common/expr/context.cc",
      "source/extensions/filters/http/rbac/rbac_filter.cc",
      "test/common/http/conn_manager_impl_test.cc",
      "test/common/http/header_map_impl_speed_test.cc",
      "test/common/http/header_map_impl_test.cc",
      "test/common/http/http2/codec_impl_test.cc",
      "test/integration/http2_integration_test.cc",
      "test/integration/http_integration.cc",
      "test/integration/http_integration.h",
      "test/integration/protocol_integration_test.cc"
    ],
    "message": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>",
    "before_after_code_files": [
      "include/envoy/access_log/access_log.h||include/envoy/access_log/access_log.h",
      "include/envoy/http/header_map.h||include/envoy/http/header_map.h",
      "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc",
      "source/common/http/header_map_impl.cc||source/common/http/header_map_impl.cc",
      "source/common/http/header_map_impl.h||source/common/http/header_map_impl.h",
      "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
      "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc",
      "source/common/router/router.cc||source/common/router/router.cc",
      "source/extensions/access_loggers/common/access_log_base.h||source/extensions/access_loggers/common/access_log_base.h",
      "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc||source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc",
      "source/extensions/filters/common/expr/context.cc||source/extensions/filters/common/expr/context.cc",
      "source/extensions/filters/http/rbac/rbac_filter.cc||source/extensions/filters/http/rbac/rbac_filter.cc",
      "test/common/http/conn_manager_impl_test.cc||test/common/http/conn_manager_impl_test.cc",
      "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc",
      "test/common/http/header_map_impl_test.cc||test/common/http/header_map_impl_test.cc",
      "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc",
      "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc",
      "test/integration/http_integration.cc||test/integration/http_integration.cc",
      "test/integration/http_integration.h||test/integration/http_integration.h",
      "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
    ]
  },
  "patch_diff": {
    "include/envoy/access_log/access_log.h||include/envoy/access_log/access_log.h": [
      "File: include/envoy/access_log/access_log.h -> include/envoy/access_log/access_log.h"
    ],
    "include/envoy/http/header_map.h||include/envoy/http/header_map.h": [
      "File: include/envoy/http/header_map.h -> include/envoy/http/header_map.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "457:   virtual void setReferenceKey(const LowerCaseString& key, const std::string& value) PURE;",
      "",
      "[Removed Lines]",
      "462:   virtual uint64_t byteSize() const PURE;",
      "",
      "[Added Lines]",
      "473:   virtual absl::optional<uint64_t> byteSize() const PURE;",
      "484:   virtual uint64_t refreshByteSize() PURE;",
      "494:   virtual uint64_t byteSizeInternal() const PURE;",
      "",
      "---------------"
    ],
    "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc": [
      "File: source/common/http/conn_manager_impl.cc -> source/common/http/conn_manager_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "506:   }",
      "508:   connection_manager_.stats_.named_.downstream_rq_active_.dec();",
      "509:   for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {",
      "510:     access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),",
      "511:                     stream_info_);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "512:   if (request_headers_ != nullptr) {",
      "513:     request_headers_->refreshByteSize();",
      "514:   }",
      "515:   if (response_headers_ != nullptr) {",
      "516:     response_headers_->refreshByteSize();",
      "517:   }",
      "518:   if (response_trailers_ != nullptr) {",
      "519:     response_trailers_->refreshByteSize();",
      "520:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "719:     }",
      "720:   }",
      "",
      "[Removed Lines]",
      "722:   ASSERT(connection_manager_.config_.maxRequestHeadersKb() > 0);",
      "723:   if (request_headers_->byteSize() > (connection_manager_.config_.maxRequestHeadersKb() * 1024)) {",
      "724:     sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),",
      "725:                    Code::RequestHeaderFieldsTooLarge, \"\", nullptr, is_head_request_, absl::nullopt,",
      "726:                    StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);",
      "727:     return;",
      "728:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "source/common/http/header_map_impl.cc||source/common/http/header_map_impl.cc": [
      "File: source/common/http/header_map_impl.cc -> source/common/http/header_map_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "295:   }",
      "296: };",
      "299:   if (data.empty()) {",
      "301:   }",
      "302:   if (!header.empty()) {",
      "303:     header.append(\",\", 1);",
      "304:   }",
      "305:   header.append(data.data(), data.size());",
      "306: }",
      "308: HeaderMapImpl::HeaderMapImpl() { memset(&inline_headers_, 0, sizeof(inline_headers_)); }",
      "",
      "[Removed Lines]",
      "298: void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {",
      "300:     return;",
      "",
      "[Added Lines]",
      "298: uint64_t HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {",
      "300:     return 0;",
      "302:   uint64_t byte_size = 0;",
      "305:     byte_size += 1;",
      "308:   return data.size() + byte_size;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "319:   }",
      "320: }",
      "322: void HeaderMapImpl::copyFrom(const HeaderMap& header_map) {",
      "323:   header_map.iterate(",
      "324:       [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "325: void HeaderMapImpl::addSize(uint64_t size) {",
      "327:   if (cached_byte_size_.has_value()) {",
      "328:     cached_byte_size_.value() += size;",
      "329:   }",
      "330: }",
      "332: void HeaderMapImpl::subtractSize(uint64_t size) {",
      "333:   if (cached_byte_size_.has_value()) {",
      "334:     ASSERT(cached_byte_size_ >= size);",
      "335:     cached_byte_size_.value() -= size;",
      "336:   }",
      "337: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "359:     if (*ref_lookup_response.entry_ == nullptr) {",
      "360:       maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));",
      "361:     } else {",
      "363:       value.clear();",
      "364:     }",
      "365:   } else {",
      "366:     std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));",
      "367:     i->entry_ = i;",
      "368:   }",
      "",
      "[Removed Lines]",
      "362:       appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());",
      "",
      "[Added Lines]",
      "379:       const uint64_t added_size =",
      "380:           appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());",
      "381:       addSize(added_size);",
      "385:     addSize(key.size() + value.size());",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "374:   auto* entry = getExistingInline(key.getStringView());",
      "375:   if (entry != nullptr) {",
      "377:     key.clear();",
      "378:     value.clear();",
      "379:   } else {",
      "",
      "[Removed Lines]",
      "376:     appendToHeader(entry->value(), value.getStringView());",
      "",
      "[Added Lines]",
      "396:     const uint64_t added_size = appendToHeader(entry->value(), value.getStringView());",
      "397:     addSize(added_size);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "408:   if (entry != nullptr) {",
      "409:     char buf[32];",
      "410:     StringUtil::itoa(buf, sizeof(buf), value);",
      "412:     return;",
      "413:   }",
      "414:   HeaderString new_key;",
      "",
      "[Removed Lines]",
      "411:     appendToHeader(entry->value(), buf);",
      "",
      "[Added Lines]",
      "432:     const uint64_t added_size = appendToHeader(entry->value(), buf);",
      "433:     addSize(added_size);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "423: void HeaderMapImpl::addCopy(const LowerCaseString& key, const std::string& value) {",
      "424:   auto* entry = getExistingInline(key.get());",
      "425:   if (entry != nullptr) {",
      "427:     return;",
      "428:   }",
      "429:   HeaderString new_key;",
      "",
      "[Removed Lines]",
      "426:     appendToHeader(entry->value(), value);",
      "",
      "[Added Lines]",
      "448:     const uint64_t added_size = appendToHeader(entry->value(), value);",
      "449:     addSize(added_size);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "451:   ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)",
      "452: }",
      "455:   uint64_t byte_size = 0;",
      "456:   for (const HeaderEntryImpl& header : headers_) {",
      "457:     byte_size += header.key().size();",
      "458:     byte_size += header.value().size();",
      "459:   }",
      "461:   return byte_size;",
      "462: }",
      "",
      "[Removed Lines]",
      "454: uint64_t HeaderMapImpl::byteSize() const {",
      "",
      "[Added Lines]",
      "477: absl::optional<uint64_t> HeaderMapImpl::byteSize() const { return cached_byte_size_; }",
      "479: uint64_t HeaderMapImpl::refreshByteSize() {",
      "480:   if (!cached_byte_size_.has_value()) {",
      "483:     cached_byte_size_ = byteSizeInternal();",
      "484:   }",
      "485:   return cached_byte_size_.value();",
      "486: }",
      "488: uint64_t HeaderMapImpl::byteSizeInternal() const {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "474: HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {",
      "475:   for (HeaderEntryImpl& header : headers_) {",
      "476:     if (header.key() == key.get().c_str()) {",
      "477:       return &header;",
      "478:     }",
      "479:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "511:       cached_byte_size_.reset();",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "528:   } else {",
      "529:     for (auto i = headers_.begin(); i != headers_.end();) {",
      "530:       if (i->key() == key.get().c_str()) {",
      "531:         i = headers_.erase(i);",
      "532:       } else {",
      "533:         ++i;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "566:         subtractSize(i->key().size() + i->value().size());",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "537: }",
      "539: void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {",
      "541:     bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());",
      "542:     if (to_remove) {",
      "",
      "[Removed Lines]",
      "540:   headers_.remove_if([&](const HeaderEntryImpl& entry) {",
      "",
      "[Added Lines]",
      "576:   headers_.remove_if([&prefix, this](const HeaderEntryImpl& entry) {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "546:       if (cb) {",
      "547:         StaticLookupResponse ref_lookup_response = cb(*this);",
      "548:         if (ref_lookup_response.entry_) {",
      "550:         }",
      "551:       }",
      "552:     }",
      "553:     return to_remove;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "585:           const uint32_t key_value_size = (*ref_lookup_response.entry_)->key().size() +",
      "586:                                           (*ref_lookup_response.entry_)->value().size();",
      "587:           subtractSize(key_value_size);",
      "590:       } else {",
      "591:         subtractSize(entry.key().size() + entry.value().size());",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "571: HeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,",
      "572:                                                                  const LowerCaseString& key) {",
      "573:   if (*entry) {",
      "574:     return **entry;",
      "575:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "614:   cached_byte_size_.reset();",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "588:     return **entry;",
      "589:   }",
      "591:   std::list<HeaderEntryImpl>::iterator i = headers_.insert(key, std::move(value));",
      "592:   i->entry_ = i;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "633:   addSize(key.get().size() + value.size());",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "609:   }",
      "611:   HeaderEntryImpl* entry = *ptr_to_entry;",
      "613:   headers_.erase(entry->entry_);",
      "614: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "655:   const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();",
      "656:   subtractSize(size_to_subtract);",
      "",
      "---------------"
    ],
    "source/common/http/header_map_impl.h||source/common/http/header_map_impl.h": [
      "File: source/common/http/header_map_impl.h -> source/common/http/header_map_impl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "20: #define DEFINE_INLINE_HEADER_FUNCS(name)                                                           \\",
      "21: public:                                                                                            \\",
      "22:   const HeaderEntry* name() const override { return inline_headers_.name##_; }                     \\",
      "24:   HeaderEntry& insert##name() override {                                                           \\",
      "25:     return maybeCreateInline(&inline_headers_.name##_, Headers::get().name);                       \\",
      "26:   }                                                                                                \\",
      "27:   void remove##name() override { removeInline(&inline_headers_.name##_); }",
      "",
      "[Removed Lines]",
      "23:   HeaderEntry* name() override { return inline_headers_.name##_; }                                 \\",
      "",
      "[Added Lines]",
      "28:   HeaderEntry* name() override {                                                                   \\",
      "29:     cached_byte_size_.reset();                                                                     \\",
      "30:     return inline_headers_.name##_;                                                                \\",
      "31:   }                                                                                                \\",
      "33:     cached_byte_size_.reset();                                                                     \\",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "48:   HeaderMapImpl();",
      "49:   explicit HeaderMapImpl(",
      "",
      "[Removed Lines]",
      "46:   static void appendToHeader(HeaderString& header, absl::string_view data);",
      "",
      "[Added Lines]",
      "55:   static uint64_t appendToHeader(HeaderString& header, absl::string_view data);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "71:   void addCopy(const LowerCaseString& key, const std::string& value) override;",
      "72:   void setReference(const LowerCaseString& key, const std::string& value) override;",
      "73:   void setReferenceKey(const LowerCaseString& key, const std::string& value) override;",
      "75:   const HeaderEntry* get(const LowerCaseString& key) const override;",
      "76:   HeaderEntry* get(const LowerCaseString& key) override;",
      "77:   void iterate(ConstIterateCb cb, void* context) const override;",
      "",
      "[Removed Lines]",
      "74:   uint64_t byteSize() const override;",
      "",
      "[Added Lines]",
      "83:   absl::optional<uint64_t> byteSize() const override;",
      "84:   uint64_t refreshByteSize() override;",
      "85:   uint64_t byteSizeInternal() const override;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "195:   HeaderEntryImpl* getExistingInline(absl::string_view key);",
      "197:   void removeInline(HeaderEntryImpl** entry);",
      "199:   AllInlineHeaders inline_headers_;",
      "200:   HeaderList headers_;",
      "202:   ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER_FUNCS)",
      "203: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "209:   void addSize(uint64_t size);",
      "210:   void subtractSize(uint64_t size);",
      "217:   absl::optional<uint64_t> cached_byte_size_ = 0;",
      "",
      "---------------"
    ],
    "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
      "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "460:   header_parsing_state_ = HeaderParsingState::Value;",
      "461:   current_header_value_.append(data, length);",
      "465:   if (total > (max_request_headers_kb_ * 1024)) {",
      "466:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
      "467:     sendProtocolError();",
      "",
      "[Removed Lines]",
      "463:   const uint32_t total =",
      "464:       current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();",
      "",
      "[Added Lines]",
      "464:   ASSERT(current_header_map_->byteSize().has_value());",
      "465:   const uint32_t total = current_header_field_.size() + current_header_value_.size() +",
      "466:                          current_header_map_->byteSize().value();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "472: int ConnectionImpl::onHeadersCompleteBase() {",
      "473:   ENVOY_CONN_LOG(trace, \"headers complete\", connection_);",
      "474:   completeLastHeader();",
      "475:   if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "479:   ASSERT(current_header_map_->byteSize().has_value() &&",
      "480:          current_header_map_->byteSize() == current_header_map_->byteSizeInternal());",
      "",
      "---------------"
    ],
    "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc": [
      "File: source/common/http/http2/codec_impl.cc -> source/common/http/http2/codec_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "510:   switch (frame->hd.type) {",
      "511:   case NGHTTP2_HEADERS: {",
      "512:     stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;",
      "513:     if (!stream->cookies_.empty()) {",
      "514:       HeaderString key(Headers::get().Cookie);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "514:     ASSERT(stream->headers_->byteSize().has_value() &&",
      "515:            stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "620:   case NGHTTP2_HEADERS:",
      "621:   case NGHTTP2_DATA: {",
      "622:     StreamImpl* stream = getStream(frame->hd.stream_id);",
      "623:     stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;",
      "624:     break;",
      "625:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "627:     if (stream->headers_) {",
      "630:       ASSERT(stream->headers_->byteSize().has_value() &&",
      "631:              stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());",
      "632:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "808:     stats_.headers_cb_no_stream_.inc();",
      "809:     return 0;",
      "810:   }",
      "812:   stream->saveHeader(std::move(name), std::move(value));",
      "815:     stats_.header_overflow_.inc();",
      "816:     return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;",
      "",
      "[Removed Lines]",
      "813:   if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {",
      "",
      "[Added Lines]",
      "823:   ASSERT(stream->headers_->byteSize().has_value());",
      "824:   if (stream->headers_->byteSize().value() > max_request_headers_kb_ * 1024) {",
      "",
      "---------------"
    ],
    "source/common/router/router.cc||source/common/router/router.cc": [
      "File: source/common/router/router.cc -> source/common/router/router.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1399:   stream_info_.setUpstreamTiming(upstream_timing_);",
      "1400:   stream_info_.onRequestComplete();",
      "1401:   for (const auto& upstream_log : parent_.config_.upstream_logs_) {",
      "1402:     upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),",
      "1403:                       upstream_trailers_.get(), stream_info_);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1404:   if (upstream_headers_ != nullptr) {",
      "1405:     upstream_headers_->refreshByteSize();",
      "1406:   }",
      "1407:   if (upstream_trailers_ != nullptr) {",
      "1408:     upstream_trailers_->refreshByteSize();",
      "1409:   }",
      "",
      "---------------"
    ],
    "source/extensions/access_loggers/common/access_log_base.h||source/extensions/access_loggers/common/access_log_base.h": [
      "File: source/extensions/access_loggers/common/access_log_base.h -> source/extensions/access_loggers/common/access_log_base.h"
    ],
    "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc||source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc": [
      "File: source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc -> source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "95:     request_properties->set_original_path(",
      "96:         std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));",
      "97:   }",
      "99:   request_properties->set_request_body_bytes(stream_info.bytesReceived());",
      "100:   if (request_headers.Method() != nullptr) {",
      "101:     envoy::api::v2::core::RequestMethod method =",
      "",
      "[Removed Lines]",
      "98:   request_properties->set_request_headers_bytes(request_headers.byteSize());",
      "",
      "[Added Lines]",
      "98:   request_properties->set_request_headers_bytes(request_headers.byteSize().value());",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "123:   if (stream_info.responseCodeDetails()) {",
      "124:     response_properties->set_response_code_details(stream_info.responseCodeDetails().value());",
      "125:   }",
      "127:   response_properties->set_response_body_bytes(stream_info.bytesSent());",
      "128:   if (!response_headers_to_log_.empty()) {",
      "129:     auto* logged_headers = response_properties->mutable_response_headers();",
      "",
      "[Removed Lines]",
      "126:   response_properties->set_response_headers_bytes(response_headers.byteSize());",
      "",
      "[Added Lines]",
      "126:   response_properties->set_response_headers_bytes(response_headers.byteSize().value());",
      "",
      "---------------"
    ],
    "source/extensions/filters/common/expr/context.cc||source/extensions/filters/common/expr/context.cc": [
      "File: source/extensions/filters/common/expr/context.cc -> source/extensions/filters/common/expr/context.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:     } else if (value == UserAgent) {",
      "80:       return convertHeaderEntry(headers_.value_->UserAgent());",
      "81:     } else if (value == TotalSize) {",
      "83:     }",
      "84:   }",
      "85:   return {};",
      "",
      "[Removed Lines]",
      "82:       return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());",
      "",
      "[Added Lines]",
      "82:       return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize().value());",
      "",
      "---------------"
    ],
    "source/extensions/filters/http/rbac/rbac_filter.cc||source/extensions/filters/http/rbac/rbac_filter.cc": [
      "File: source/extensions/filters/http/rbac/rbac_filter.cc -> source/extensions/filters/http/rbac/rbac_filter.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "76:   if (shadow_engine != nullptr) {",
      "77:     std::string shadow_resp_code =",
      "78:         Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().EngineResultAllowed;",
      "79:     if (shadow_engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(),",
      "80:                                &effective_policy_id)) {",
      "81:       ENVOY_LOG(debug, \"shadow allowed\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "82:     headers.refreshByteSize();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:   const auto engine =",
      "106:       config_->engine(callbacks_->route(), Filters::Common::RBAC::EnforcementMode::Enforced);",
      "107:   if (engine != nullptr) {",
      "108:     if (engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(), nullptr)) {",
      "109:       ENVOY_LOG(debug, \"enforced allowed\");",
      "110:       config_->stats().allowed_.inc();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "115:     headers.refreshByteSize();",
      "",
      "---------------"
    ],
    "test/common/http/conn_manager_impl_test.cc||test/common/http/conn_manager_impl_test.cc": [
      "File: test/common/http/conn_manager_impl_test.cc -> test/common/http/conn_manager_impl_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "4409:   EXPECT_EQ(1U, stats_.named_.downstream_cx_overload_disable_keepalive_.value());",
      "4410: }",
      "4457: TEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathFirstFilter) {",
      "4458:   setup(false, \"envoy-custom-server\", false);",
      "4459:   setUpEncoderAndDecoder(true, true);",
      "",
      "[Removed Lines]",
      "4412: TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {",
      "4413:   setup(false, \"\");",
      "4415:   std::string response_code;",
      "4416:   std::string response_body;",
      "4417:   EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {",
      "4418:     StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);",
      "4419:     HeaderMapPtr headers{",
      "4420:         new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};",
      "4421:     headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));",
      "4423:     EXPECT_CALL(response_encoder_, encodeHeaders(_, true))",
      "4424:         .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {",
      "4425:           response_code = std::string(headers.Status()->value().getStringView());",
      "4426:         }));",
      "4427:     decoder->decodeHeaders(std::move(headers), true);",
      "4428:     conn_manager_->newStream(response_encoder_);",
      "4429:   }));",
      "4431:   Buffer::OwnedImpl fake_input(\"1234\");",
      "4432:   conn_manager_->onData(fake_input, false); // kick off request",
      "4434:   EXPECT_EQ(\"431\", response_code);",
      "4435:   EXPECT_EQ(\"\", response_body);",
      "4436: }",
      "4438: TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersAcceptedIfConfigured) {",
      "4439:   max_request_headers_kb_ = 62;",
      "4440:   setup(false, \"\");",
      "4442:   EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {",
      "4443:     StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);",
      "4444:     HeaderMapPtr headers{",
      "4445:         new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};",
      "4446:     headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));",
      "4448:     EXPECT_CALL(response_encoder_, encodeHeaders(_, _)).Times(0);",
      "4449:     decoder->decodeHeaders(std::move(headers), true);",
      "4450:     conn_manager_->newStream(response_encoder_);",
      "4451:   }));",
      "4453:   Buffer::OwnedImpl fake_input(\"1234\");",
      "4454:   conn_manager_->onData(fake_input, false); // kick off request",
      "4455: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc": [
      "File: test/common/http/header_map_impl_speed_test.cc -> test/common/http/header_map_impl_speed_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "104:   addDummyHeaders(headers, state.range(0));",
      "105:   uint64_t size = 0;",
      "106:   for (auto _ : state) {",
      "108:   }",
      "109:   benchmark::DoNotOptimize(size);",
      "110: }",
      "",
      "[Removed Lines]",
      "107:     size += headers.byteSize();",
      "",
      "[Added Lines]",
      "107:     size += headers.byteSize().value();",
      "",
      "---------------"
    ],
    "test/common/http/header_map_impl_test.cc||test/common/http/header_map_impl_test.cc": [
      "File: test/common/http/header_map_impl_test.cc -> test/common/http/header_map_impl_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "366:   HeaderMapImpl headers;",
      "367:   EXPECT_TRUE(headers.empty());",
      "368:   EXPECT_EQ(0, headers.size());",
      "369:   EXPECT_EQ(nullptr, headers.Host());",
      "370:   headers.insertHost().value(std::string(\"hello\"));",
      "371:   EXPECT_FALSE(headers.empty());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "369:   EXPECT_EQ(headers.byteSize().value(), 0);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "375:   EXPECT_EQ(\"hello\", headers.get(Headers::get().Host)->value().getStringView());",
      "376: }",
      "378: TEST(HeaderMapImplTest, MoveIntoInline) {",
      "379:   HeaderMapImpl headers;",
      "380:   HeaderString key;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "380: uint64_t countBytesForTest(const HeaderMapImpl& headers) {",
      "381:   uint64_t byte_size = 0;",
      "382:   headers.iterate(",
      "383:       [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {",
      "384:         auto* byte_size = static_cast<uint64_t*>(context);",
      "386:         return Http::HeaderMap::Iterate::Continue;",
      "387:       },",
      "388:       &byte_size);",
      "389:   return byte_size;",
      "390: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "392:   headers.addViaMove(std::move(key2), std::move(value2));",
      "393:   EXPECT_EQ(\"cache-control\", headers.CacheControl()->key().getStringView());",
      "394:   EXPECT_EQ(\"hello,there\", headers.CacheControl()->value().getStringView());",
      "395: }",
      "397: TEST(HeaderMapImplTest, Remove) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "409:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "401:   LowerCaseString static_key(\"hello\");",
      "402:   std::string ref_value(\"value\");",
      "403:   headers.addReference(static_key, ref_value);",
      "404:   EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());",
      "405:   EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());",
      "406:   EXPECT_EQ(1UL, headers.size());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "419:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "409:   EXPECT_EQ(nullptr, headers.get(static_key));",
      "410:   EXPECT_EQ(0UL, headers.size());",
      "411:   EXPECT_TRUE(headers.empty());",
      "414:   headers.insertContentLength().value(5);",
      "415:   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());",
      "416:   EXPECT_EQ(1UL, headers.size());",
      "417:   EXPECT_FALSE(headers.empty());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "428:   EXPECT_EQ(headers.refreshByteSize(), 0);",
      "432:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "419:   EXPECT_EQ(nullptr, headers.ContentLength());",
      "420:   EXPECT_EQ(0UL, headers.size());",
      "421:   EXPECT_TRUE(headers.empty());",
      "424:   headers.insertContentLength().value(5);",
      "425:   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());",
      "426:   EXPECT_EQ(1UL, headers.size());",
      "427:   EXPECT_FALSE(headers.empty());",
      "428:   headers.remove(Headers::get().ContentLength);",
      "429:   EXPECT_EQ(nullptr, headers.ContentLength());",
      "430:   EXPECT_EQ(0UL, headers.size());",
      "431:   EXPECT_TRUE(headers.empty());",
      "432: }",
      "434: TEST(HeaderMapImplTest, RemoveRegex) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "440:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "447:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "452:   EXPECT_EQ(headers.refreshByteSize(), 0);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "446:   headers.addReference(key3, \"value\");",
      "447:   headers.addReference(key4, \"value\");",
      "448:   headers.addReference(key5, \"value\");",
      "451:   headers.removePrefix(LowerCaseString(\"x-prefix-\"));",
      "452:   EXPECT_EQ(nullptr, headers.get(key1));",
      "453:   EXPECT_NE(nullptr, headers.get(key2));",
      "454:   EXPECT_EQ(nullptr, headers.get(key3));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "470:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "474:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "456:   EXPECT_EQ(nullptr, headers.get(key5));",
      "459:   headers.removePrefix(LowerCaseString(\"\"));",
      "460:   EXPECT_EQ(nullptr, headers.get(key2));",
      "461:   EXPECT_EQ(nullptr, headers.get(key4));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "482:   headers.refreshByteSize();",
      "484:   EXPECT_EQ(headers.byteSize().value(), 0);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "465:   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());",
      "466:   EXPECT_EQ(1UL, headers.size());",
      "467:   EXPECT_FALSE(headers.empty());",
      "468:   headers.removePrefix(LowerCaseString(\"content\"));",
      "469:   EXPECT_EQ(nullptr, headers.ContentLength());",
      "470: }",
      "472: TEST(HeaderMapImplTest, SetRemovesAllValues) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "493:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "496:   EXPECT_EQ(headers.refreshByteSize(), 0);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "484:   headers.addReference(key2, ref_value2);",
      "485:   headers.addReference(key1, ref_value3);",
      "486:   headers.addReference(key1, ref_value4);",
      "488:   using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "514:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "531:     const std::string bar(\"bar\");",
      "532:     headers.addReference(Headers::get().ContentLength, foo);",
      "533:     headers.addReference(Headers::get().ContentLength, bar);",
      "534:     EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());",
      "535:     EXPECT_EQ(1UL, headers.size());",
      "536:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "562:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "538:     HeaderMapImpl headers;",
      "539:     headers.addReferenceKey(Headers::get().ContentLength, \"foo\");",
      "540:     headers.addReferenceKey(Headers::get().ContentLength, \"bar\");",
      "541:     EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());",
      "542:     EXPECT_EQ(1UL, headers.size());",
      "543:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "570:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "545:     HeaderMapImpl headers;",
      "546:     headers.addReferenceKey(Headers::get().ContentLength, 5);",
      "547:     headers.addReferenceKey(Headers::get().ContentLength, 6);",
      "548:     EXPECT_EQ(\"5,6\", headers.ContentLength()->value().getStringView());",
      "549:     EXPECT_EQ(1UL, headers.size());",
      "550:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "578:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "553:     const std::string foo(\"foo\");",
      "554:     headers.addReference(Headers::get().ContentLength, foo);",
      "555:     headers.addReferenceKey(Headers::get().ContentLength, 6);",
      "556:     EXPECT_EQ(\"foo,6\", headers.ContentLength()->value().getStringView());",
      "557:     EXPECT_EQ(1UL, headers.size());",
      "558:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "587:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "568:   headers.addReference(set_cookie, foo);",
      "569:   headers.addReference(set_cookie, bar);",
      "570:   EXPECT_EQ(2UL, headers.size());",
      "572:   std::vector<absl::string_view> out;",
      "573:   Http::HeaderUtility::getAllOfHeader(headers, \"set-cookie\", out);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "603:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "580:   HeaderMapImpl headers;",
      "581:   headers.setReferenceKey(Headers::get().ContentType, \"blah\");",
      "582:   headers.setReferenceKey(Headers::get().ContentType, \"text/html\");",
      "583:   EXPECT_EQ(\"text/html\", headers.ContentType()->value().getStringView());",
      "584:   EXPECT_EQ(1UL, headers.size());",
      "585: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "616:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "588:   HeaderMapImpl headers;",
      "589:   LowerCaseString foo(\"hello\");",
      "590:   headers.addReferenceKey(foo, \"world\");",
      "591:   EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());",
      "592:   EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());",
      "593: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "625:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "596:   HeaderMapImpl headers;",
      "597:   LowerCaseString foo(\"hello\");",
      "598:   headers.setReferenceKey(foo, \"world\");",
      "599:   EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());",
      "600:   EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());",
      "602:   headers.setReferenceKey(foo, \"monde\");",
      "603:   EXPECT_NE(\"monde\", headers.get(foo)->value().getStringView().data());",
      "604:   EXPECT_EQ(\"monde\", headers.get(foo)->value().getStringView());",
      "605: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "634:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "637:   headers.refreshByteSize();",
      "640:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "611:   std::unique_ptr<LowerCaseString> lcKeyPtr(new LowerCaseString(\"hello\"));",
      "612:   headers.addCopy(*lcKeyPtr, \"world\");",
      "614:   const HeaderString& value = headers.get(*lcKeyPtr)->value();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "651:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "632:   headers.remove(LowerCaseString(\"hello\"));",
      "636:   lcKeyPtr = std::make_unique<LowerCaseString>(std::string(\"he\") + \"llo\");",
      "637:   EXPECT_STREQ(\"hello\", lcKeyPtr->get().c_str());",
      "639:   headers.addCopy(*lcKeyPtr, 42);",
      "641:   const HeaderString& value3 = headers.get(*lcKeyPtr)->value();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "672:   headers.refreshByteSize();",
      "674:   EXPECT_EQ(headers.byteSize().value(), 0);",
      "681:   headers.refreshByteSize();",
      "683:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "662:   headers.addCopy(cache_control, \"max-age=1345\");",
      "663:   EXPECT_EQ(\"max-age=1345\", headers.get(cache_control)->value().getStringView());",
      "664:   EXPECT_EQ(\"max-age=1345\", headers.CacheControl()->value().getStringView());",
      "665:   headers.addCopy(cache_control, \"public\");",
      "666:   EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());",
      "667:   headers.addCopy(cache_control, \"\");",
      "668:   EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());",
      "669:   headers.addCopy(cache_control, 123);",
      "670:   EXPECT_EQ(\"max-age=1345,public,123\", headers.get(cache_control)->value().getStringView());",
      "671:   headers.addCopy(cache_control, std::numeric_limits<uint64_t>::max());",
      "672:   EXPECT_EQ(\"max-age=1345,public,123,18446744073709551615\",",
      "673:             headers.get(cache_control)->value().getStringView());",
      "674: }",
      "676: TEST(HeaderMapImplTest, Equality) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "709:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "711:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "714:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "717:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "722:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "690:   LowerCaseString static_key(\"\\x90hello\");",
      "691:   std::string ref_value(\"value\");",
      "692:   headers.addReference(static_key, ref_value);",
      "693:   EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());",
      "694: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "742:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "844:   {",
      "845:     LowerCaseString foo(\"hello\");",
      "846:     Http::TestHeaderMapImpl headers{};",
      "847:     EXPECT_EQ(0UL, headers.size());",
      "848:     EXPECT_TRUE(headers.empty());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "897:     EXPECT_EQ(headers.refreshByteSize(), 0);",
      "",
      "---------------"
    ],
    "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc": [
      "File: test/common/http/http2/codec_impl_test.cc -> test/common/http/http2/codec_impl_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1090:   TestHeaderMapImpl request_headers;",
      "1091:   HttpTestUtility::addDefaultHeaders(request_headers);",
      "1092:   std::string key = \"big\";",
      "1093:   uint32_t head_room = 77;",
      "1094:   uint32_t long_string_length =",
      "1096:   std::string long_string = std::string(long_string_length, 'q');",
      "1097:   request_headers.addCopy(key, long_string);",
      "1104:   EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));",
      "1105:   request_encoder_->encodeHeaders(request_headers, true);",
      "",
      "[Removed Lines]",
      "1095:       codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;",
      "1102:   ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);",
      "",
      "[Added Lines]",
      "1093:   request_headers.refreshByteSize();",
      "1097:       codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;",
      "1104:   ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);",
      "",
      "---------------"
    ],
    "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc": [
      "File: test/integration/http2_integration_test.cc -> test/integration/http2_integration_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "65: TEST_P(Http2IntegrationTest, RetryAttemptCount) { testRetryAttemptCountHeader(); }",
      "67: static std::string response_metadata_filter = R\"EOF(",
      "68: name: response-metadata-filter",
      "69: config: {}",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "67: TEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }",
      "",
      "---------------"
    ],
    "test/integration/http_integration.cc||test/integration/http_integration.cc": [
      "File: test/integration/http_integration.cc -> test/integration/http_integration.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "261: IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(",
      "262:     const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,",
      "264:   ASSERT(codec_client_ != nullptr);",
      "266:   IntegrationStreamDecoderPtr response;",
      "",
      "[Removed Lines]",
      "263:     const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {",
      "",
      "[Added Lines]",
      "263:     const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,",
      "264:     std::chrono::milliseconds time) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "269:   } else {",
      "270:     response = codec_client_->makeHeaderOnlyRequest(request_headers);",
      "271:   }",
      "274:   upstream_request_->encodeHeaders(response_headers, response_size == 0);",
      "",
      "[Removed Lines]",
      "272:   waitForNextUpstreamRequest(upstream_index);",
      "",
      "[Added Lines]",
      "273:   waitForNextUpstreamRequest(upstream_index, time);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "333: }",
      "335: uint64_t",
      "337:   uint64_t upstream_with_request;",
      "339:   if (!fake_upstream_connection_) {",
      "",
      "[Removed Lines]",
      "336: HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices) {",
      "",
      "[Added Lines]",
      "337: HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices,",
      "338:                                                 std::chrono::milliseconds connection_wait_timeout) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "361:   return upstream_with_request;",
      "362: }",
      "366: }",
      "368: void HttpIntegrationTest::checkSimpleRequestSuccess(uint64_t expected_request_size,",
      "",
      "[Removed Lines]",
      "364: void HttpIntegrationTest::waitForNextUpstreamRequest(uint64_t upstream_index) {",
      "365:   waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}));",
      "",
      "[Added Lines]",
      "366: void HttpIntegrationTest::waitForNextUpstreamRequest(",
      "367:     uint64_t upstream_index, std::chrono::milliseconds connection_wait_timeout) {",
      "368:   waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}), connection_wait_timeout);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "916:   }",
      "917: }",
      "919: void HttpIntegrationTest::testDownstreamResetBeforeResponseComplete() {",
      "920:   initialize();",
      "921:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "922: void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {",
      "927:   config_helper_.addConfigModifier(",
      "928:       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)",
      "929:           -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });",
      "930:   max_request_headers_kb_ = max_size;",
      "931:   Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};",
      "932:   request_trailers.addCopy(\"big\", std::string(size * 1024, 'a'));",
      "934:   initialize();",
      "936:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "937:   fake_upstreams_[0]->set_allow_unexpected_disconnects(true);",
      "939:   auto encoder_decoder = codec_client_->startRequest(default_request_headers_);",
      "940:   request_encoder_ = &encoder_decoder.first;",
      "941:   auto response = std::move(encoder_decoder.second);",
      "942:   codec_client_->sendData(*request_encoder_, 10, false);",
      "943:   codec_client_->sendTrailers(*request_encoder_, request_trailers);",
      "945:   if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {",
      "948:     response->waitForReset();",
      "949:     codec_client_->close();",
      "950:     EXPECT_FALSE(response->complete());",
      "952:   } else {",
      "953:     waitForNextUpstreamRequest();",
      "954:     upstream_request_->encodeHeaders(default_response_headers_, true);",
      "955:     response->waitForEndStream();",
      "956:     EXPECT_TRUE(response->complete());",
      "957:   }",
      "958: }",
      "960: void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {",
      "961:   config_helper_.addConfigModifier(",
      "962:       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)",
      "963:           -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });",
      "964:   max_request_headers_kb_ = 96;",
      "966:   Http::TestHeaderMapImpl big_headers{",
      "967:       {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};",
      "969:   for (int i = 0; i < 20000; i++) {",
      "970:     big_headers.addCopy(std::to_string(i), std::string(0, 'a'));",
      "971:   }",
      "972:   initialize();",
      "974:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "976:   auto response =",
      "977:       sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);",
      "979:   EXPECT_TRUE(response->complete());",
      "980:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "981: }",
      "",
      "---------------"
    ],
    "test/integration/http_integration.h||test/integration/http_integration.h": [
      "File: test/integration/http_integration.h -> test/integration/http_integration.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:   void cleanupUpstreamAndDownstream();",
      "",
      "[Removed Lines]",
      "125:   IntegrationStreamDecoderPtr",
      "126:   sendRequestAndWaitForResponse(const Http::TestHeaderMapImpl& request_headers,",
      "127:                                 uint32_t request_body_size,",
      "128:                                 const Http::TestHeaderMapImpl& response_headers,",
      "129:                                 uint32_t response_body_size, int upstream_index = 0);",
      "135:   uint64_t waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices);",
      "136:   void waitForNextUpstreamRequest(uint64_t upstream_index = 0);",
      "",
      "[Added Lines]",
      "125:   IntegrationStreamDecoderPtr sendRequestAndWaitForResponse(",
      "126:       const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,",
      "127:       const Http::TestHeaderMapImpl& response_headers, uint32_t response_body_size,",
      "128:       int upstream_index = 0, std::chrono::milliseconds time = TestUtility::DefaultTimeout);",
      "134:   uint64_t waitForNextUpstreamRequest(",
      "135:       const std::vector<uint64_t>& upstream_indices,",
      "136:       std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);",
      "137:   void waitForNextUpstreamRequest(",
      "138:       uint64_t upstream_index = 0,",
      "139:       std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:   void testRouterUpstreamResponseBeforeRequestComplete();",
      "187:   void testTwoRequests(bool force_network_backup = false);",
      "188:   void testLargeRequestHeaders(uint32_t size, uint32_t max_size = 60);",
      "190:   void testAddEncodedTrailers();",
      "191:   void testRetry();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "191:   void testLargeHeaders(Http::TestHeaderMapImpl request_headers,",
      "192:                         Http::TestHeaderMapImpl request_trailers, uint32_t size, uint32_t max_size);",
      "194:   void testLargeRequestTrailers(uint32_t size, uint32_t max_size = 60);",
      "195:   void testManyRequestHeaders(std::chrono::milliseconds time = TestUtility::DefaultTimeout);",
      "",
      "---------------"
    ],
    "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc": [
      "File: test/integration/protocol_integration_test.cc -> test/integration/protocol_integration_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "576:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "577: }",
      "579: TEST_P(DownstreamProtocolIntegrationTest, InvalidContentLength) {",
      "580:   initialize();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "580: TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingConcatenated) {",
      "581:   initialize();",
      "583:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "584:   Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
      "585:                                           {\":path\", \"/test/long/url\"},",
      "586:                                           {\":scheme\", \"http\"},",
      "587:                                           {\":authority\", \"host\"},",
      "588:                                           {\"content-length\", \"0\"}};",
      "589:   std::vector<std::string> cookie_pieces;",
      "590:   for (int i = 0; i < 7000; i++) {",
      "591:     cookie_pieces.push_back(fmt::sprintf(\"a%x=b\", i));",
      "592:   }",
      "593:   request_headers.addCopy(\"cookie\", absl::StrJoin(cookie_pieces, \"; \"));",
      "594:   auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);",
      "596:   ASSERT_TRUE(response->complete());",
      "597:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "598: }",
      "601: TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingMany) {",
      "602:   initialize();",
      "604:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "605:   Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
      "606:                                           {\":path\", \"/test/long/url\"},",
      "607:                                           {\":scheme\", \"http\"},",
      "608:                                           {\":authority\", \"host\"},",
      "609:                                           {\"content-length\", \"0\"}};",
      "610:   for (int i = 0; i < 2000; i++) {",
      "611:     request_headers.addCopy(\"cookie\", fmt::sprintf(\"a%x=b\", i));",
      "612:   }",
      "613:   auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);",
      "615:   ASSERT_TRUE(response->complete());",
      "616:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "617: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "850:   testLargeRequestHeaders(95, 96);",
      "851: }",
      "855: TEST_P(DownstreamProtocolIntegrationTest, testDecodeHeadersReturnsStopAll) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "893: TEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersTimeout) {",
      "895:   testManyRequestHeaders(std::chrono::milliseconds(5000));",
      "896: }",
      "898: TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersAccepted) {",
      "899:   testLargeRequestTrailers(60, 96);",
      "900: }",
      "902: TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersRejected) {",
      "903:   testLargeRequestTrailers(66, 60);",
      "904: }",
      "906: TEST_P(DownstreamProtocolIntegrationTest, ManyTrailerHeaders) {",
      "907:   config_helper_.addConfigModifier(",
      "908:       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)",
      "909:           -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });",
      "911:   Http::TestHeaderMapImpl request_trailers{};",
      "912:   for (int i = 0; i < 20000; i++) {",
      "913:     request_trailers.addCopy(std::to_string(i), \"\");",
      "914:   }",
      "916:   initialize();",
      "917:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "918:   auto encoder_decoder =",
      "919:       codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},",
      "920:                                                           {\":path\", \"/test/long/url\"},",
      "921:                                                           {\":scheme\", \"http\"},",
      "922:                                                           {\":authority\", \"host\"}});",
      "923:   request_encoder_ = &encoder_decoder.first;",
      "924:   auto response = std::move(encoder_decoder.second);",
      "925:   codec_client_->sendTrailers(*request_encoder_, request_trailers);",
      "926:   waitForNextUpstreamRequest();",
      "927:   upstream_request_->encodeHeaders(default_response_headers_, true);",
      "928:   response->waitForEndStream();",
      "930:   EXPECT_TRUE(upstream_request_->complete());",
      "931:   EXPECT_TRUE(response->complete());",
      "932:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "933: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4292718b9c473061ffbd5e378f36893de2953387",
      "candidate_info": {
        "commit_hash": "4292718b9c473061ffbd5e378f36893de2953387",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/4292718b9c473061ffbd5e378f36893de2953387",
        "files": [
          "source/common/router/BUILD",
          "source/common/router/router.cc",
          "source/common/router/router.h",
          "source/common/router/upstream_request.cc",
          "source/common/router/upstream_request.h"
        ],
        "message": "router: moving upstream to a new file (#10253)\n\nSigned-off-by: Alyssa Wilk <alyssar@chromium.org>",
        "before_after_code_files": [
          "source/common/router/router.cc||source/common/router/router.cc",
          "source/common/router/router.h||source/common/router/router.h",
          "source/common/router/upstream_request.cc||source/common/router/upstream_request.cc",
          "source/common/router/upstream_request.h||source/common/router/upstream_request.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/router/router.cc||source/common/router/router.cc"
          ],
          "candidate": [
            "source/common/router/router.cc||source/common/router/router.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/router/router.cc||source/common/router/router.cc": [
          "File: source/common/router/router.cc -> source/common/router/router.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"common/router/config_impl.h\"",
          "33: #include \"common/router/debug_config.h\"",
          "34: #include \"common/router/retry_state_impl.h\"",
          "35: #include \"common/runtime/runtime_impl.h\"",
          "36: #include \"common/stream_info/uint32_accessor_impl.h\"",
          "37: #include \"common/tracing/http_tracer_impl.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #include \"common/router/upstream_request.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: constexpr uint64_t TimeoutPrecisionFactor = 100;",
          "121:   if (timeout.count() == 0) {",
          "",
          "[Removed Lines]",
          "117: uint64_t percentageOfTimeout(const std::chrono::milliseconds response_time,",
          "118:                              const std::chrono::milliseconds timeout) {",
          "",
          "[Added Lines]",
          "116: } // namespace",
          "120: uint64_t FilterUtility::percentageOfTimeout(const std::chrono::milliseconds response_time,",
          "121:                                             const std::chrono::milliseconds timeout) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:   return static_cast<uint64_t>(response_time.count() * TimeoutPrecisionFactor / timeout.count());",
          "126: }",
          "130: void FilterUtility::setUpstreamScheme(Http::RequestHeaderMap& headers, bool use_secure_transport) {",
          "131:   if (use_secure_transport) {",
          "132:     headers.setReferenceScheme(Http::Headers::get().SchemeValues.Https);",
          "",
          "[Removed Lines]",
          "128: } // namespace",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "773:     }",
          "775:     for (auto& upstream_request : upstream_requests_) {",
          "777:         upstream_request->setupPerTryTimeout();",
          "778:       }",
          "779:     }",
          "",
          "[Removed Lines]",
          "776:       if (upstream_request->create_per_try_timeout_on_request_complete_) {",
          "",
          "[Added Lines]",
          "777:       if (upstream_request->createPerTryTimeoutOnRequestComplete()) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "794:   if (final_upstream_request_) {",
          "796:   }",
          "",
          "[Removed Lines]",
          "795:     callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstream_timing_);",
          "",
          "[Added Lines]",
          "796:     callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstreamTiming());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "801:         upstream_requests_.back()->removeFromList(upstream_requests_);",
          "805:       cluster_->stats().upstream_rq_timeout_.inc();",
          "807:       if (cluster_->timeoutBudgetStats().has_value()) {",
          "811:       }",
          "815:       }",
          "820:         updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, *upstream_request,",
          "821:                                absl::optional<uint64_t>(enumToInt(timeout_response_code_)));",
          "822:       }",
          "",
          "[Removed Lines]",
          "804:     if (upstream_request->awaiting_headers_) {",
          "810:         upstream_request->record_timeout_budget_ = false;",
          "813:       if (upstream_request->upstream_host_) {",
          "814:         upstream_request->upstream_host_->stats().rq_timeout_.inc();",
          "819:       if (!upstream_request->outlier_detection_timeout_recorded_) {",
          "",
          "[Added Lines]",
          "805:     if (upstream_request->awaitingHeaders()) {",
          "811:         upstream_request->recordTimeoutBudget(false);",
          "814:       if (upstream_request->upstreamHost()) {",
          "815:         upstream_request->upstreamHost()->stats().rq_timeout_.inc();",
          "820:       if (!upstream_request->outlierDetectionTimeoutRecorded()) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "838:   updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,",
          "839:                          absl::optional<uint64_t>(enumToInt(timeout_response_code_)));",
          "842:   if (!downstream_response_started_ && retry_state_) {",
          "843:     RetryStatus retry_status =",
          "",
          "[Removed Lines]",
          "840:   upstream_request.outlier_detection_timeout_recorded_ = true;",
          "",
          "[Added Lines]",
          "841:   upstream_request.outlierDetectionTimeoutRecorded(true);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "854:     } else if (retry_status == RetryStatus::NoOverflow) {",
          "",
          "[Removed Lines]",
          "851:       upstream_request.retried_ = true;",
          "",
          "[Added Lines]",
          "852:       upstream_request.retried(true);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "867:   }",
          "869:   cluster_->stats().upstream_rq_per_try_timeout_.inc();",
          "872:   }",
          "874:   upstream_request.resetStream();",
          "",
          "[Removed Lines]",
          "870:   if (upstream_request.upstream_host_) {",
          "871:     upstream_request.upstream_host_->stats().rq_timeout_.inc();",
          "",
          "[Added Lines]",
          "871:   if (upstream_request.upstreamHost()) {",
          "872:     upstream_request.upstreamHost()->stats().rq_timeout_.inc();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "891: void Filter::updateOutlierDetection(Upstream::Outlier::Result result,",
          "892:                                     UpstreamRequest& upstream_request,",
          "893:                                     absl::optional<uint64_t> code) {",
          "896:   }",
          "897: }",
          "899: void Filter::chargeUpstreamAbort(Http::Code code, bool dropped, UpstreamRequest& upstream_request) {",
          "900:   if (downstream_response_started_) {",
          "903:       config_.stats_.rq_reset_after_downstream_response_started_.inc();",
          "904:     }",
          "905:   } else {",
          "908:     chargeUpstreamCode(code, upstream_host, dropped);",
          "",
          "[Removed Lines]",
          "894:   if (upstream_request.upstream_host_) {",
          "895:     upstream_request.upstream_host_->outlierDetector().putResult(result, code);",
          "901:     if (upstream_request.grpc_rq_success_deferred_) {",
          "902:       upstream_request.upstream_host_->stats().rq_error_.inc();",
          "906:     Upstream::HostDescriptionConstSharedPtr upstream_host = upstream_request.upstream_host_;",
          "",
          "[Added Lines]",
          "895:   if (upstream_request.upstreamHost()) {",
          "896:     upstream_request.upstreamHost()->outlierDetector().putResult(result, code);",
          "902:     if (upstream_request.grpcRqSuccessDeferred()) {",
          "903:       upstream_request.upstreamHost()->stats().rq_error_.inc();",
          "907:     Upstream::HostDescriptionConstSharedPtr upstream_host = upstream_request.upstreamHost();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "924:         dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);",
          "926:     cluster_->timeoutBudgetStats()->upstream_rq_timeout_budget_percent_used_.recordValue(",
          "928:   }",
          "930:   const absl::string_view body =",
          "",
          "[Removed Lines]",
          "927:         percentageOfTimeout(response_time, timeout_.global_timeout_));",
          "",
          "[Added Lines]",
          "928:         FilterUtility::percentageOfTimeout(response_time, timeout_.global_timeout_));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "968:     return false;",
          "969:   }",
          "971:   const RetryStatus retry_status =",
          "972:       retry_state_->shouldRetryReset(reset_reason, [this]() -> void { doRetry(); });",
          "973:   if (retry_status == RetryStatus::Yes && setupRetry()) {",
          "976:     }",
          "977:     upstream_request.removeFromList(upstream_requests_);",
          "978:     return true;",
          "",
          "[Removed Lines]",
          "967:   if (downstream_response_started_ || !retry_state_ || upstream_request.retried_) {",
          "974:     if (upstream_request.upstream_host_) {",
          "975:       upstream_request.upstream_host_->stats().rq_error_.inc();",
          "",
          "[Added Lines]",
          "968:   if (downstream_response_started_ || !retry_state_ || upstream_request.retried()) {",
          "975:     if (upstream_request.upstreamHost()) {",
          "976:       upstream_request.upstreamHost()->stats().rq_error_.inc();",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1055:   if (grpc_request_) {",
          "1056:     if (end_stream) {",
          "1057:       if (grpc_status && !Http::CodeUtility::is5xx(grpc_to_http_status)) {",
          "1059:       } else {",
          "1061:       }",
          "1062:     } else {",
          "1064:     }",
          "1065:   } else {",
          "1067:   }",
          "1068: }",
          "1070: void Filter::onUpstream100ContinueHeaders(Http::ResponseHeaderMapPtr&& headers,",
          "1071:                                           UpstreamRequest& upstream_request) {",
          "1073:   ENVOY_STREAM_LOG(debug, \"upstream 100 continue\", *callbacks_);",
          "1075:   downstream_response_started_ = true;",
          "",
          "[Removed Lines]",
          "1058:         upstream_request.upstream_host_->stats().rq_success_.inc();",
          "1060:         upstream_request.upstream_host_->stats().rq_error_.inc();",
          "1063:       upstream_request.grpc_rq_success_deferred_ = true;",
          "1066:     upstream_request.upstream_host_->stats().rq_success_.inc();",
          "1072:   chargeUpstreamCode(100, *headers, upstream_request.upstream_host_, false);",
          "",
          "[Added Lines]",
          "1059:         upstream_request.upstreamHost()->stats().rq_success_.inc();",
          "1061:         upstream_request.upstreamHost()->stats().rq_error_.inc();",
          "1064:       upstream_request.grpcRqSuccessDeferred(true);",
          "1067:     upstream_request.upstreamHost()->stats().rq_success_.inc();",
          "1073:   chargeUpstreamCode(100, *headers, upstream_request.upstreamHost(), false);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1130:   }",
          "1132:   if (grpc_status.has_value()) {",
          "1134:   } else {",
          "1136:   }",
          "1138:   if (headers->EnvoyImmediateHealthCheckFail() != nullptr) {",
          "1140:   }",
          "1142:   bool could_not_retry = false;",
          "",
          "[Removed Lines]",
          "1133:     upstream_request.upstream_host_->outlierDetector().putHttpResponseCode(grpc_to_http_status);",
          "1135:     upstream_request.upstream_host_->outlierDetector().putHttpResponseCode(response_code);",
          "1139:     upstream_request.upstream_host_->healthChecker().setUnhealthy();",
          "",
          "[Added Lines]",
          "1134:     upstream_request.upstreamHost()->outlierDetector().putHttpResponseCode(grpc_to_http_status);",
          "1136:     upstream_request.upstreamHost()->outlierDetector().putHttpResponseCode(response_code);",
          "1140:     upstream_request.upstreamHost()->healthChecker().setUnhealthy();",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1146:   if (retry_state_) {",
          "",
          "[Removed Lines]",
          "1147:     if (upstream_request.retried_) {",
          "",
          "[Added Lines]",
          "1148:     if (upstream_request.retried()) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1154:           retry_state_->shouldRetryHeaders(*headers, [this]() -> void { doRetry(); });",
          "1158:       if (retry_status == RetryStatus::Yes && setupRetry()) {",
          "1159:         if (!end_stream) {",
          "1160:           upstream_request.resetStream();",
          "",
          "[Removed Lines]",
          "1157:       const auto upstream_host = upstream_request.upstream_host_;",
          "",
          "[Added Lines]",
          "1158:       const auto upstream_host = upstream_request.upstreamHost();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1191:   if (could_not_retry && (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0)) {",
          "",
          "[Removed Lines]",
          "1192:     upstream_request.upstream_host_->stats().rq_error_.inc();",
          "",
          "[Added Lines]",
          "1193:     upstream_request.upstreamHost()->stats().rq_error_.inc();",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1215:     }",
          "1216:   }",
          "1219:       (headers->EnvoyUpstreamCanary() && headers->EnvoyUpstreamCanary()->value() == \"true\") ||",
          "1222:   if (!Http::CodeUtility::is5xx(response_code)) {",
          "1223:     handleNon5xxResponseHeaders(grpc_status, upstream_request, end_stream, grpc_to_http_status);",
          "1224:   }",
          "",
          "[Removed Lines]",
          "1218:   upstream_request.upstream_canary_ =",
          "1220:       upstream_request.upstream_host_->canary();",
          "1221:   chargeUpstreamCode(response_code, *headers, upstream_request.upstream_host_, false);",
          "",
          "[Added Lines]",
          "1219:   upstream_request.upstreamCanary(",
          "1221:       upstream_request.upstreamHost()->canary());",
          "1222:   chargeUpstreamCode(response_code, *headers, upstream_request.upstreamHost(), false);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1253:   ASSERT(upstream_requests_.size() == 1);",
          "1254:   if (end_stream) {",
          "1258:     }",
          "1259:     onUpstreamComplete(upstream_request);",
          "1260:   }",
          "",
          "[Removed Lines]",
          "1256:     if (upstream_request.grpc_rq_success_deferred_) {",
          "1257:       upstream_request.upstream_host_->stats().rq_error_.inc();",
          "",
          "[Added Lines]",
          "1257:     if (upstream_request.grpcRqSuccessDeferred()) {",
          "1258:       upstream_request.upstreamHost()->stats().rq_error_.inc();",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1270:   ASSERT(upstream_requests_.size() == 1);",
          "1273:     absl::optional<Grpc::Status::GrpcStatus> grpc_status = Grpc::Common::getGrpcStatus(*trailers);",
          "1274:     if (grpc_status &&",
          "1275:         !Http::CodeUtility::is5xx(Grpc::Utility::grpcToHttpStatus(grpc_status.value()))) {",
          "1277:     } else {",
          "1279:     }",
          "1280:   }",
          "",
          "[Removed Lines]",
          "1272:   if (upstream_request.grpc_rq_success_deferred_) {",
          "1276:       upstream_request.upstream_host_->stats().rq_success_.inc();",
          "1278:       upstream_request.upstream_host_->stats().rq_error_.inc();",
          "",
          "[Added Lines]",
          "1273:   if (upstream_request.grpcRqSuccessDeferred()) {",
          "1277:       upstream_request.upstreamHost()->stats().rq_success_.inc();",
          "1279:       upstream_request.upstreamHost()->stats().rq_error_.inc();",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1292:   if (!downstream_end_stream_) {",
          "1293:     upstream_request.resetStream();",
          "1294:   }",
          "1297:   Event::Dispatcher& dispatcher = callbacks_->dispatcher();",
          "1298:   std::chrono::milliseconds response_time = std::chrono::duration_cast<std::chrono::milliseconds>(",
          "",
          "[Removed Lines]",
          "1295:   callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstream_timing_);",
          "",
          "[Added Lines]",
          "1296:   callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstreamTiming());",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1301:   if (cluster_->timeoutBudgetStats().has_value()) {",
          "1302:     cluster_->timeoutBudgetStats()->upstream_rq_timeout_budget_percent_used_.recordValue(",
          "1304:   }",
          "1306:   if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck() &&",
          "1307:       DateUtil::timePointValid(downstream_request_complete_time_)) {",
          "1309:     const bool internal_request = Http::HeaderUtility::isEnvoyInternalRequest(*downstream_headers_);",
          "1311:     Http::CodeStats& code_stats = httpContext().codeStats();",
          "",
          "[Removed Lines]",
          "1303:         percentageOfTimeout(response_time, timeout_.global_timeout_));",
          "1308:     upstream_request.upstream_host_->outlierDetector().putResponseTime(response_time);",
          "",
          "[Added Lines]",
          "1304:         FilterUtility::percentageOfTimeout(response_time, timeout_.global_timeout_));",
          "1309:     upstream_request.upstreamHost()->outlierDetector().putResponseTime(response_time);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1313:                                              cluster_->statsScope(),",
          "1314:                                              config_.empty_stat_name_,",
          "1315:                                              response_time,",
          "1317:                                              internal_request,",
          "1318:                                              route_entry_->virtualHost().statName(),",
          "1319:                                              request_vcluster_ ? request_vcluster_->statName()",
          "1320:                                                                : config_.empty_stat_name_,",
          "1321:                                              config_.zone_name_,",
          "1324:     code_stats.chargeResponseTiming(info);",
          "",
          "[Removed Lines]",
          "1316:                                              upstream_request.upstream_canary_,",
          "1322:                                              upstreamZone(upstream_request.upstream_host_)};",
          "",
          "[Added Lines]",
          "1317:                                              upstream_request.upstreamCanary(),",
          "1323:                                              upstreamZone(upstream_request.upstreamHost())};",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1328:                                                cluster_->statsScope(),",
          "1329:                                                alt_stat_prefix_->statName(),",
          "1330:                                                response_time,",
          "1332:                                                internal_request,",
          "1333:                                                config_.empty_stat_name_,",
          "1334:                                                config_.empty_stat_name_,",
          "1335:                                                config_.zone_name_,",
          "1338:       code_stats.chargeResponseTiming(info);",
          "1339:     }",
          "",
          "[Removed Lines]",
          "1331:                                                upstream_request.upstream_canary_,",
          "1336:                                                upstreamZone(upstream_request.upstream_host_)};",
          "",
          "[Added Lines]",
          "1332:                                                upstream_request.upstreamCanary(),",
          "1337:                                                upstreamZone(upstream_request.upstreamHost())};",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1378:   attempting_internal_redirect_with_complete_stream_ =",
          "1381:   const StreamInfo::FilterStateSharedPtr& filter_state = callbacks_->streamInfo().filterState();",
          "",
          "[Removed Lines]",
          "1379:       upstream_request.upstream_timing_.last_upstream_rx_byte_received_ && downstream_end_stream_;",
          "",
          "[Added Lines]",
          "1380:       upstream_request.upstreamTiming().last_upstream_rx_byte_received_ && downstream_end_stream_;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1439: uint32_t Filter::numRequestsAwaitingHeaders() {",
          "1440:   return std::count_if(upstream_requests_.begin(), upstream_requests_.end(),",
          "1787: }",
          "1789: RetryStatePtr",
          "",
          "[Removed Lines]",
          "1441:                        [](const auto& req) -> bool { return req->awaiting_headers_; });",
          "1442: }",
          "1444: Filter::UpstreamRequest::UpstreamRequest(Filter& parent, Http::ConnectionPool::Instance& pool)",
          "1445:     : parent_(parent), conn_pool_(pool), grpc_rq_success_deferred_(false),",
          "1446:       stream_info_(pool.protocol(), parent_.callbacks_->dispatcher().timeSource()),",
          "1447:       start_time_(parent_.callbacks_->dispatcher().timeSource().monotonicTime()),",
          "1448:       calling_encode_headers_(false), upstream_canary_(false), decode_complete_(false),",
          "1449:       encode_complete_(false), encode_trailers_(false), retried_(false), awaiting_headers_(true),",
          "1450:       outlier_detection_timeout_recorded_(false),",
          "1451:       create_per_try_timeout_on_request_complete_(false),",
          "1452:       record_timeout_budget_(parent_.cluster_->timeoutBudgetStats().has_value()) {",
          "1453:   if (parent_.config_.start_child_span_) {",
          "1454:     span_ = parent_.callbacks_->activeSpan().spawnChild(",
          "1455:         parent_.callbacks_->tracingConfig(), \"router \" + parent.cluster_->name() + \" egress\",",
          "1456:         parent.timeSource().systemTime());",
          "1457:     if (parent.attempt_count_ != 1) {",
          "1459:       span_->setTag(Tracing::Tags::get().RetryCount, std::to_string(parent.attempt_count_ - 1));",
          "1460:     }",
          "1461:   }",
          "1463:   stream_info_.healthCheck(parent_.callbacks_->streamInfo().healthCheck());",
          "1464: }",
          "1466: Filter::UpstreamRequest::~UpstreamRequest() {",
          "1467:   if (span_ != nullptr) {",
          "1468:     Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, upstream_headers_.get(),",
          "1469:                                                      upstream_trailers_.get(), stream_info_,",
          "1470:                                                      Tracing::EgressConfig::get());",
          "1471:   }",
          "1473:   if (per_try_timeout_ != nullptr) {",
          "1475:     per_try_timeout_->disableTimer();",
          "1476:   }",
          "1477:   clearRequestEncoder();",
          "1481:   if (record_timeout_budget_) {",
          "1482:     Event::Dispatcher& dispatcher = parent_.callbacks_->dispatcher();",
          "1483:     const MonotonicTime end_time = dispatcher.timeSource().monotonicTime();",
          "1484:     const std::chrono::milliseconds response_time =",
          "1485:         std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time_);",
          "1486:     parent_.cluster_->timeoutBudgetStats()",
          "1487:         ->upstream_rq_timeout_budget_per_try_percent_used_.recordValue(",
          "1488:             percentageOfTimeout(response_time, parent_.timeout_.per_try_timeout_));",
          "1489:   }",
          "1491:   stream_info_.setUpstreamTiming(upstream_timing_);",
          "1492:   stream_info_.onRequestComplete();",
          "1493:   for (const auto& upstream_log : parent_.config_.upstream_logs_) {",
          "1494:     upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),",
          "1495:                       upstream_trailers_.get(), stream_info_);",
          "1496:   }",
          "1497: }",
          "1499: void Filter::UpstreamRequest::decode100ContinueHeaders(Http::ResponseHeaderMapPtr&& headers) {",
          "1500:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "1502:   ASSERT(100 == Http::Utility::getResponseStatus(*headers));",
          "1503:   parent_.onUpstream100ContinueHeaders(std::move(headers), *this);",
          "1504: }",
          "1506: void Filter::UpstreamRequest::decodeHeaders(Http::ResponseHeaderMapPtr&& headers, bool end_stream) {",
          "1507:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "1511:   upstream_timing_.onFirstUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());",
          "1512:   maybeEndDecode(end_stream);",
          "1514:   awaiting_headers_ = false;",
          "1515:   if (!parent_.config_.upstream_logs_.empty()) {",
          "1516:     upstream_headers_ = Http::createHeaderMap<Http::ResponseHeaderMapImpl>(*headers);",
          "1517:   }",
          "1518:   const uint64_t response_code = Http::Utility::getResponseStatus(*headers);",
          "1519:   stream_info_.response_code_ = static_cast<uint32_t>(response_code);",
          "1520:   parent_.onUpstreamHeaders(response_code, std::move(headers), *this, end_stream);",
          "1521: }",
          "1523: void Filter::UpstreamRequest::decodeData(Buffer::Instance& data, bool end_stream) {",
          "1524:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "1526:   maybeEndDecode(end_stream);",
          "1527:   stream_info_.addBytesReceived(data.length());",
          "1528:   parent_.onUpstreamData(data, *this, end_stream);",
          "1529: }",
          "1531: void Filter::UpstreamRequest::decodeTrailers(Http::ResponseTrailerMapPtr&& trailers) {",
          "1532:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "1534:   maybeEndDecode(true);",
          "1535:   if (!parent_.config_.upstream_logs_.empty()) {",
          "1536:     upstream_trailers_ = Http::createHeaderMap<Http::ResponseTrailerMapImpl>(*trailers);",
          "1537:   }",
          "1538:   parent_.onUpstreamTrailers(std::move(trailers), *this);",
          "1539: }",
          "1541: void Filter::UpstreamRequest::decodeMetadata(Http::MetadataMapPtr&& metadata_map) {",
          "1542:   parent_.onUpstreamMetadata(std::move(metadata_map));",
          "1543: }",
          "1545: void Filter::UpstreamRequest::maybeEndDecode(bool end_stream) {",
          "1546:   if (end_stream) {",
          "1547:     upstream_timing_.onLastUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());",
          "1548:     decode_complete_ = true;",
          "1549:   }",
          "1550: }",
          "1552: void Filter::UpstreamRequest::encodeHeaders(bool end_stream) {",
          "1553:   ASSERT(!encode_complete_);",
          "1554:   encode_complete_ = end_stream;",
          "1559:   Http::ConnectionPool::Cancellable* handle = conn_pool_.newStream(*this, *this);",
          "1560:   if (handle) {",
          "1561:     conn_pool_stream_handle_ = handle;",
          "1562:   }",
          "1563: }",
          "1565: void Filter::UpstreamRequest::encodeData(Buffer::Instance& data, bool end_stream) {",
          "1566:   ASSERT(!encode_complete_);",
          "1567:   encode_complete_ = end_stream;",
          "1569:   if (!request_encoder_) {",
          "1570:     ENVOY_STREAM_LOG(trace, \"buffering {} bytes\", *parent_.callbacks_, data.length());",
          "1571:     if (!buffered_request_body_) {",
          "1572:       buffered_request_body_ = std::make_unique<Buffer::WatermarkBuffer>(",
          "1573:           [this]() -> void { this->enableDataFromDownstream(); },",
          "1574:           [this]() -> void { this->disableDataFromDownstream(); });",
          "1575:       buffered_request_body_->setWatermarks(parent_.callbacks_->decoderBufferLimit());",
          "1576:     }",
          "1578:     buffered_request_body_->move(data);",
          "1579:   } else {",
          "1580:     ASSERT(downstream_metadata_map_vector_.empty());",
          "1582:     ENVOY_STREAM_LOG(trace, \"proxying {} bytes\", *parent_.callbacks_, data.length());",
          "1583:     stream_info_.addBytesSent(data.length());",
          "1584:     request_encoder_->encodeData(data, end_stream);",
          "1585:     if (end_stream) {",
          "1586:       upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "1587:     }",
          "1588:   }",
          "1589: }",
          "1591: void Filter::UpstreamRequest::encodeTrailers(const Http::RequestTrailerMap& trailers) {",
          "1592:   ASSERT(!encode_complete_);",
          "1593:   encode_complete_ = true;",
          "1594:   encode_trailers_ = true;",
          "1596:   if (!request_encoder_) {",
          "1597:     ENVOY_STREAM_LOG(trace, \"buffering trailers\", *parent_.callbacks_);",
          "1598:   } else {",
          "1599:     ASSERT(downstream_metadata_map_vector_.empty());",
          "1601:     ENVOY_STREAM_LOG(trace, \"proxying trailers\", *parent_.callbacks_);",
          "1602:     request_encoder_->encodeTrailers(trailers);",
          "1603:     upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "1604:   }",
          "1605: }",
          "1607: void Filter::UpstreamRequest::encodeMetadata(Http::MetadataMapPtr&& metadata_map_ptr) {",
          "1608:   if (!request_encoder_) {",
          "1609:     ENVOY_STREAM_LOG(trace, \"request_encoder_ not ready. Store metadata_map to encode later: {}\",",
          "1611:     downstream_metadata_map_vector_.emplace_back(std::move(metadata_map_ptr));",
          "1612:   } else {",
          "1613:     ENVOY_STREAM_LOG(trace, \"Encode metadata: {}\", *parent_.callbacks_, *metadata_map_ptr);",
          "1614:     Http::MetadataMapVector metadata_map_vector;",
          "1615:     metadata_map_vector.emplace_back(std::move(metadata_map_ptr));",
          "1616:     request_encoder_->encodeMetadata(metadata_map_vector);",
          "1617:   }",
          "1618: }",
          "1620: void Filter::UpstreamRequest::onResetStream(Http::StreamResetReason reason,",
          "1621:                                             absl::string_view transport_failure_reason) {",
          "1622:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "1624:   if (span_ != nullptr) {",
          "1626:     span_->setTag(Tracing::Tags::get().Error, Tracing::Tags::get().True);",
          "1627:     span_->setTag(Tracing::Tags::get().ErrorReason, Http::Utility::resetReasonToString(reason));",
          "1628:   }",
          "1630:   clearRequestEncoder();",
          "1631:   awaiting_headers_ = false;",
          "1632:   if (!calling_encode_headers_) {",
          "1633:     stream_info_.setResponseFlag(parent_.streamResetReasonToResponseFlag(reason));",
          "1634:     parent_.onUpstreamReset(reason, transport_failure_reason, *this);",
          "1635:   } else {",
          "1636:     deferred_reset_reason_ = reason;",
          "1637:   }",
          "1638: }",
          "1640: void Filter::UpstreamRequest::resetStream() {",
          "1642:   if (encode_complete_ && decode_complete_) {",
          "1643:     return;",
          "1644:   }",
          "1646:   if (span_ != nullptr) {",
          "1648:     span_->setTag(Tracing::Tags::get().Canceled, Tracing::Tags::get().True);",
          "1649:   }",
          "1651:   if (conn_pool_stream_handle_) {",
          "1652:     ENVOY_STREAM_LOG(debug, \"cancelling pool request\", *parent_.callbacks_);",
          "1653:     ASSERT(!request_encoder_);",
          "1654:     conn_pool_stream_handle_->cancel();",
          "1655:     conn_pool_stream_handle_ = nullptr;",
          "1656:   }",
          "1658:   if (request_encoder_) {",
          "1659:     ENVOY_STREAM_LOG(debug, \"resetting pool request\", *parent_.callbacks_);",
          "1660:     request_encoder_->getStream().removeCallbacks(*this);",
          "1661:     request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);",
          "1662:     clearRequestEncoder();",
          "1663:   }",
          "1664: }",
          "1666: void Filter::UpstreamRequest::setupPerTryTimeout() {",
          "1667:   ASSERT(!per_try_timeout_);",
          "1668:   if (parent_.timeout_.per_try_timeout_.count() > 0) {",
          "1669:     per_try_timeout_ =",
          "1670:         parent_.callbacks_->dispatcher().createTimer([this]() -> void { onPerTryTimeout(); });",
          "1671:     per_try_timeout_->enableTimer(parent_.timeout_.per_try_timeout_);",
          "1672:   }",
          "1673: }",
          "1675: void Filter::UpstreamRequest::onPerTryTimeout() {",
          "1678:   if (!parent_.downstream_response_started_) {",
          "1679:     ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks_);",
          "1681:     stream_info_.setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout);",
          "1682:     parent_.onPerTryTimeout(*this);",
          "1683:   } else {",
          "1684:     ENVOY_STREAM_LOG(debug,",
          "1685:                      \"ignored upstream per try timeout due to already started downstream response\",",
          "1687:   }",
          "1688: }",
          "1690: void Filter::UpstreamRequest::onPoolFailure(Http::ConnectionPool::PoolFailureReason reason,",
          "1691:                                             absl::string_view transport_failure_reason,",
          "1692:                                             Upstream::HostDescriptionConstSharedPtr host) {",
          "1693:   Http::StreamResetReason reset_reason = Http::StreamResetReason::ConnectionFailure;",
          "1694:   switch (reason) {",
          "1695:   case Http::ConnectionPool::PoolFailureReason::Overflow:",
          "1696:     reset_reason = Http::StreamResetReason::Overflow;",
          "1697:     break;",
          "1698:   case Http::ConnectionPool::PoolFailureReason::ConnectionFailure:",
          "1699:     reset_reason = Http::StreamResetReason::ConnectionFailure;",
          "1700:     break;",
          "1701:   }",
          "1704:   onUpstreamHostSelected(host);",
          "1705:   onResetStream(reset_reason, transport_failure_reason);",
          "1706: }",
          "1708: void Filter::UpstreamRequest::onPoolReady(Http::RequestEncoder& request_encoder,",
          "1709:                                           Upstream::HostDescriptionConstSharedPtr host,",
          "1710:                                           const StreamInfo::StreamInfo& info) {",
          "1712:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "1713:   ENVOY_STREAM_LOG(debug, \"pool ready\", *parent_.callbacks_);",
          "1715:   host->outlierDetector().putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess);",
          "1717:   onUpstreamHostSelected(host);",
          "1718:   request_encoder.getStream().addCallbacks(*this);",
          "1720:   stream_info_.setUpstreamLocalAddress(request_encoder.getStream().connectionLocalAddress());",
          "1721:   parent_.callbacks_->streamInfo().setUpstreamLocalAddress(",
          "1722:       request_encoder.getStream().connectionLocalAddress());",
          "1724:   stream_info_.setUpstreamSslConnection(info.downstreamSslConnection());",
          "1725:   parent_.callbacks_->streamInfo().setUpstreamSslConnection(info.downstreamSslConnection());",
          "1727:   if (parent_.downstream_end_stream_) {",
          "1728:     setupPerTryTimeout();",
          "1729:   } else {",
          "1730:     create_per_try_timeout_on_request_complete_ = true;",
          "1731:   }",
          "1733:   conn_pool_stream_handle_ = nullptr;",
          "1734:   setRequestEncoder(request_encoder);",
          "1735:   calling_encode_headers_ = true;",
          "1736:   if (parent_.route_entry_->autoHostRewrite() && !host->hostname().empty()) {",
          "1737:     parent_.downstream_headers_->setHost(host->hostname());",
          "1738:   }",
          "1740:   if (span_ != nullptr) {",
          "1741:     span_->injectContext(*parent_.downstream_headers_);",
          "1742:   }",
          "1744:   upstream_timing_.onFirstUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "1746:   const bool end_stream = !buffered_request_body_ && encode_complete_ && !encode_trailers_;",
          "1749:   const bool delay_headers_end_stream = end_stream && !downstream_metadata_map_vector_.empty();",
          "1750:   request_encoder.encodeHeaders(*parent_.downstream_headers_,",
          "1751:                                 end_stream && !delay_headers_end_stream);",
          "1752:   calling_encode_headers_ = false;",
          "1759:   if (deferred_reset_reason_) {",
          "1760:     onResetStream(deferred_reset_reason_.value(), absl::string_view());",
          "1761:   } else {",
          "1763:     if (!downstream_metadata_map_vector_.empty()) {",
          "1764:       ENVOY_STREAM_LOG(debug, \"Send metadata onPoolReady. {}\", *parent_.callbacks_,",
          "1765:                        downstream_metadata_map_vector_);",
          "1766:       request_encoder.encodeMetadata(downstream_metadata_map_vector_);",
          "1767:       downstream_metadata_map_vector_.clear();",
          "1768:       if (delay_headers_end_stream) {",
          "1769:         Buffer::OwnedImpl empty_data(\"\");",
          "1770:         request_encoder.encodeData(empty_data, true);",
          "1771:       }",
          "1772:     }",
          "1774:     if (buffered_request_body_) {",
          "1775:       stream_info_.addBytesSent(buffered_request_body_->length());",
          "1776:       request_encoder.encodeData(*buffered_request_body_, encode_complete_ && !encode_trailers_);",
          "1777:     }",
          "1779:     if (encode_trailers_) {",
          "1780:       request_encoder.encodeTrailers(*parent_.downstream_trailers_);",
          "1781:     }",
          "1783:     if (encode_complete_) {",
          "1784:       upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "1785:     }",
          "1786:   }",
          "",
          "[Added Lines]",
          "1442:                        [](const auto& req) -> bool { return req->awaitingHeaders(); });",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1795:                                 priority);",
          "1796: }",
          "1841: } // namespace Router",
          "1842: } // namespace Envoy",
          "",
          "[Removed Lines]",
          "1798: void Filter::UpstreamRequest::setRequestEncoder(Http::RequestEncoder& request_encoder) {",
          "1799:   request_encoder_ = &request_encoder;",
          "1803:   parent_.callbacks_->addDownstreamWatermarkCallbacks(downstream_watermark_manager_);",
          "1804: }",
          "1806: void Filter::UpstreamRequest::clearRequestEncoder() {",
          "1808:   if (request_encoder_) {",
          "1809:     parent_.callbacks_->removeDownstreamWatermarkCallbacks(downstream_watermark_manager_);",
          "1810:   }",
          "1811:   request_encoder_ = nullptr;",
          "1812: }",
          "1814: void Filter::UpstreamRequest::DownstreamWatermarkManager::onAboveWriteBufferHighWatermark() {",
          "1815:   ASSERT(parent_.request_encoder_);",
          "1822:   ASSERT(!parent_.parent_.final_upstream_request_ ||",
          "1823:          &parent_ == parent_.parent_.final_upstream_request_);",
          "1828:   parent_.parent_.cluster_->stats().upstream_flow_control_paused_reading_total_.inc();",
          "1829:   parent_.request_encoder_->getStream().readDisable(true);",
          "1830: }",
          "1832: void Filter::UpstreamRequest::DownstreamWatermarkManager::onBelowWriteBufferLowWatermark() {",
          "1833:   ASSERT(parent_.request_encoder_);",
          "1837:   parent_.parent_.cluster_->stats().upstream_flow_control_resumed_reading_total_.inc();",
          "1838:   parent_.request_encoder_->getStream().readDisable(false);",
          "1839: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "source/common/router/router.h||source/common/router/router.h": [
          "File: source/common/router/router.h -> source/common/router/router.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include \"common/config/well_known_names.h\"",
          "29: #include \"common/http/utility.h\"",
          "30: #include \"common/router/config_impl.h\"",
          "31: #include \"common/stats/symbol_table_impl.h\"",
          "32: #include \"common/stream_info/stream_info_impl.h\"",
          "33: #include \"common/upstream/load_balancer_impl.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include \"common/router/upstream_request.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115:     }",
          "116:   };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "126:   static uint64_t percentageOfTimeout(const std::chrono::milliseconds response_time,",
          "127:                                       const std::chrono::milliseconds timeout);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "233: using FilterConfigSharedPtr = std::shared_ptr<FilterConfig>;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: class UpstreamRequest;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "363:     return cookie_value;",
          "364:   }",
          "369: private:",
          "501:   using UpstreamRequestPtr = std::unique_ptr<UpstreamRequest>;",
          "503:   StreamInfo::ResponseFlag streamResetReasonToResponseFlag(Http::StreamResetReason reset_reason);",
          "",
          "[Removed Lines]",
          "366: protected:",
          "367:   RetryStatePtr retry_state_;",
          "370:   struct UpstreamRequest : public Http::ResponseDecoder,",
          "371:                            public Http::StreamCallbacks,",
          "372:                            public Http::ConnectionPool::Callbacks,",
          "373:                            public LinkedObject<UpstreamRequest> {",
          "374:     UpstreamRequest(Filter& parent, Http::ConnectionPool::Instance& pool);",
          "375:     ~UpstreamRequest() override;",
          "377:     void encodeHeaders(bool end_stream);",
          "378:     void encodeData(Buffer::Instance& data, bool end_stream);",
          "379:     void encodeTrailers(const Http::RequestTrailerMap& trailers);",
          "380:     void encodeMetadata(Http::MetadataMapPtr&& metadata_map_ptr);",
          "382:     void resetStream();",
          "383:     void setupPerTryTimeout();",
          "384:     void onPerTryTimeout();",
          "385:     void maybeEndDecode(bool end_stream);",
          "387:     void onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host) {",
          "388:       stream_info_.onUpstreamHostSelected(host);",
          "389:       upstream_host_ = host;",
          "390:       parent_.callbacks_->streamInfo().onUpstreamHostSelected(host);",
          "391:       if (parent_.retry_state_ && host) {",
          "392:         parent_.retry_state_->onHostAttempted(host);",
          "393:       }",
          "394:     }",
          "397:     void decodeData(Buffer::Instance& data, bool end_stream) override;",
          "398:     void decodeMetadata(Http::MetadataMapPtr&& metadata_map) override;",
          "401:     void decode100ContinueHeaders(Http::ResponseHeaderMapPtr&& headers) override;",
          "402:     void decodeHeaders(Http::ResponseHeaderMapPtr&& headers, bool end_stream) override;",
          "403:     void decodeTrailers(Http::ResponseTrailerMapPtr&& trailers) override;",
          "406:     void onResetStream(Http::StreamResetReason reason,",
          "407:                        absl::string_view transport_failure_reason) override;",
          "408:     void onAboveWriteBufferHighWatermark() override { disableDataFromDownstream(); }",
          "409:     void onBelowWriteBufferLowWatermark() override { enableDataFromDownstream(); }",
          "411:     void disableDataFromDownstream() {",
          "421:       ASSERT(parent_.upstream_requests_.size() == 1 || parent_.downstream_end_stream_);",
          "422:       parent_.cluster_->stats().upstream_flow_control_backed_up_total_.inc();",
          "423:       parent_.callbacks_->onDecoderFilterAboveWriteBufferHighWatermark();",
          "424:     }",
          "426:     void enableDataFromDownstream() {",
          "436:       ASSERT(parent_.upstream_requests_.size() == 1 || parent_.downstream_end_stream_);",
          "437:       parent_.cluster_->stats().upstream_flow_control_drained_total_.inc();",
          "438:       parent_.callbacks_->onDecoderFilterBelowWriteBufferLowWatermark();",
          "439:     }",
          "442:     void onPoolFailure(Http::ConnectionPool::PoolFailureReason reason,",
          "443:                        absl::string_view transport_failure_reason,",
          "444:                        Upstream::HostDescriptionConstSharedPtr host) override;",
          "445:     void onPoolReady(Http::RequestEncoder& request_encoder,",
          "446:                      Upstream::HostDescriptionConstSharedPtr host,",
          "447:                      const StreamInfo::StreamInfo& info) override;",
          "449:     void setRequestEncoder(Http::RequestEncoder& request_encoder);",
          "450:     void clearRequestEncoder();",
          "452:     struct DownstreamWatermarkManager : public Http::DownstreamWatermarkCallbacks {",
          "453:       DownstreamWatermarkManager(UpstreamRequest& parent) : parent_(parent) {}",
          "456:       void onBelowWriteBufferLowWatermark() override;",
          "457:       void onAboveWriteBufferHighWatermark() override;",
          "459:       UpstreamRequest& parent_;",
          "460:     };",
          "462:     void readEnable();",
          "464:     Filter& parent_;",
          "465:     Http::ConnectionPool::Instance& conn_pool_;",
          "466:     bool grpc_rq_success_deferred_;",
          "467:     Event::TimerPtr per_try_timeout_;",
          "468:     Http::ConnectionPool::Cancellable* conn_pool_stream_handle_{};",
          "469:     Http::RequestEncoder* request_encoder_{};",
          "470:     absl::optional<Http::StreamResetReason> deferred_reset_reason_;",
          "471:     Buffer::WatermarkBufferPtr buffered_request_body_;",
          "472:     Upstream::HostDescriptionConstSharedPtr upstream_host_;",
          "473:     DownstreamWatermarkManager downstream_watermark_manager_{*this};",
          "474:     Tracing::SpanPtr span_;",
          "475:     StreamInfo::StreamInfoImpl stream_info_;",
          "476:     StreamInfo::UpstreamTiming upstream_timing_;",
          "477:     const MonotonicTime start_time_;",
          "480:     Http::ResponseHeaderMapPtr upstream_headers_;",
          "481:     Http::ResponseTrailerMapPtr upstream_trailers_;",
          "482:     Http::MetadataMapVector downstream_metadata_map_vector_;",
          "484:     bool calling_encode_headers_ : 1;",
          "485:     bool upstream_canary_ : 1;",
          "486:     bool decode_complete_ : 1;",
          "487:     bool encode_complete_ : 1;",
          "488:     bool encode_trailers_ : 1;",
          "489:     bool retried_ : 1;",
          "490:     bool awaiting_headers_ : 1;",
          "491:     bool outlier_detection_timeout_recorded_ : 1;",
          "494:     bool create_per_try_timeout_on_request_complete_ : 1;",
          "498:     bool record_timeout_budget_ : 1;",
          "499:   };",
          "",
          "[Added Lines]",
          "381:   friend class UpstreamRequest;",
          "383:   RetryStatePtr retry_state_;",
          "",
          "---------------"
        ],
        "source/common/router/upstream_request.cc||source/common/router/upstream_request.cc": [
          "File: source/common/router/upstream_request.cc -> source/common/router/upstream_request.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"common/router/upstream_request.h\"",
          "3: #include <chrono>",
          "4: #include <cstdint>",
          "5: #include <functional>",
          "6: #include <memory>",
          "7: #include <string>",
          "9: #include \"envoy/event/dispatcher.h\"",
          "10: #include \"envoy/event/timer.h\"",
          "11: #include \"envoy/grpc/status.h\"",
          "12: #include \"envoy/http/conn_pool.h\"",
          "13: #include \"envoy/runtime/runtime.h\"",
          "14: #include \"envoy/upstream/cluster_manager.h\"",
          "15: #include \"envoy/upstream/upstream.h\"",
          "17: #include \"common/common/assert.h\"",
          "18: #include \"common/common/empty_string.h\"",
          "19: #include \"common/common/enum_to_int.h\"",
          "20: #include \"common/common/scope_tracker.h\"",
          "21: #include \"common/common/utility.h\"",
          "22: #include \"common/grpc/common.h\"",
          "23: #include \"common/http/codes.h\"",
          "24: #include \"common/http/header_map_impl.h\"",
          "25: #include \"common/http/headers.h\"",
          "26: #include \"common/http/message_impl.h\"",
          "27: #include \"common/http/utility.h\"",
          "28: #include \"common/network/application_protocol.h\"",
          "29: #include \"common/network/transport_socket_options_impl.h\"",
          "30: #include \"common/network/upstream_server_name.h\"",
          "31: #include \"common/network/upstream_subject_alt_names.h\"",
          "32: #include \"common/router/config_impl.h\"",
          "33: #include \"common/router/debug_config.h\"",
          "34: #include \"common/router/retry_state_impl.h\"",
          "35: #include \"common/runtime/runtime_impl.h\"",
          "36: #include \"common/stream_info/uint32_accessor_impl.h\"",
          "37: #include \"common/tracing/http_tracer_impl.h\"",
          "39: #include \"extensions/filters/http/well_known_names.h\"",
          "41: namespace Envoy {",
          "42: namespace Router {",
          "44: UpstreamRequest::UpstreamRequest(Filter& parent, Http::ConnectionPool::Instance& pool)",
          "45:     : parent_(parent), conn_pool_(pool), grpc_rq_success_deferred_(false),",
          "46:       stream_info_(pool.protocol(), parent_.callbacks_->dispatcher().timeSource()),",
          "47:       start_time_(parent_.callbacks_->dispatcher().timeSource().monotonicTime()),",
          "48:       calling_encode_headers_(false), upstream_canary_(false), decode_complete_(false),",
          "49:       encode_complete_(false), encode_trailers_(false), retried_(false), awaiting_headers_(true),",
          "50:       outlier_detection_timeout_recorded_(false),",
          "51:       create_per_try_timeout_on_request_complete_(false),",
          "52:       record_timeout_budget_(parent_.cluster_->timeoutBudgetStats().has_value()) {",
          "53:   if (parent_.config_.start_child_span_) {",
          "54:     span_ = parent_.callbacks_->activeSpan().spawnChild(",
          "55:         parent_.callbacks_->tracingConfig(), \"router \" + parent.cluster_->name() + \" egress\",",
          "56:         parent.timeSource().systemTime());",
          "57:     if (parent.attempt_count_ != 1) {",
          "59:       span_->setTag(Tracing::Tags::get().RetryCount, std::to_string(parent.attempt_count_ - 1));",
          "60:     }",
          "61:   }",
          "63:   stream_info_.healthCheck(parent_.callbacks_->streamInfo().healthCheck());",
          "64: }",
          "66: UpstreamRequest::~UpstreamRequest() {",
          "67:   if (span_ != nullptr) {",
          "68:     Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, upstream_headers_.get(),",
          "69:                                                      upstream_trailers_.get(), stream_info_,",
          "70:                                                      Tracing::EgressConfig::get());",
          "71:   }",
          "73:   if (per_try_timeout_ != nullptr) {",
          "75:     per_try_timeout_->disableTimer();",
          "76:   }",
          "77:   clearRequestEncoder();",
          "81:   if (record_timeout_budget_) {",
          "82:     Event::Dispatcher& dispatcher = parent_.callbacks_->dispatcher();",
          "83:     const MonotonicTime end_time = dispatcher.timeSource().monotonicTime();",
          "84:     const std::chrono::milliseconds response_time =",
          "85:         std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time_);",
          "86:     parent_.cluster_->timeoutBudgetStats()",
          "87:         ->upstream_rq_timeout_budget_per_try_percent_used_.recordValue(",
          "88:             FilterUtility::percentageOfTimeout(response_time, parent_.timeout_.per_try_timeout_));",
          "89:   }",
          "91:   stream_info_.setUpstreamTiming(upstream_timing_);",
          "92:   stream_info_.onRequestComplete();",
          "93:   for (const auto& upstream_log : parent_.config_.upstream_logs_) {",
          "94:     upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),",
          "95:                       upstream_trailers_.get(), stream_info_);",
          "96:   }",
          "97: }",
          "99: void UpstreamRequest::decode100ContinueHeaders(Http::ResponseHeaderMapPtr&& headers) {",
          "100:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "102:   ASSERT(100 == Http::Utility::getResponseStatus(*headers));",
          "103:   parent_.onUpstream100ContinueHeaders(std::move(headers), *this);",
          "104: }",
          "106: void UpstreamRequest::decodeHeaders(Http::ResponseHeaderMapPtr&& headers, bool end_stream) {",
          "107:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "111:   upstream_timing_.onFirstUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());",
          "112:   maybeEndDecode(end_stream);",
          "114:   awaiting_headers_ = false;",
          "115:   if (!parent_.config_.upstream_logs_.empty()) {",
          "116:     upstream_headers_ = Http::createHeaderMap<Http::ResponseHeaderMapImpl>(*headers);",
          "117:   }",
          "118:   const uint64_t response_code = Http::Utility::getResponseStatus(*headers);",
          "119:   stream_info_.response_code_ = static_cast<uint32_t>(response_code);",
          "120:   parent_.onUpstreamHeaders(response_code, std::move(headers), *this, end_stream);",
          "121: }",
          "123: void UpstreamRequest::decodeData(Buffer::Instance& data, bool end_stream) {",
          "124:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "126:   maybeEndDecode(end_stream);",
          "127:   stream_info_.addBytesReceived(data.length());",
          "128:   parent_.onUpstreamData(data, *this, end_stream);",
          "129: }",
          "131: void UpstreamRequest::decodeTrailers(Http::ResponseTrailerMapPtr&& trailers) {",
          "132:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "134:   maybeEndDecode(true);",
          "135:   if (!parent_.config_.upstream_logs_.empty()) {",
          "136:     upstream_trailers_ = Http::createHeaderMap<Http::ResponseTrailerMapImpl>(*trailers);",
          "137:   }",
          "138:   parent_.onUpstreamTrailers(std::move(trailers), *this);",
          "139: }",
          "141: void UpstreamRequest::decodeMetadata(Http::MetadataMapPtr&& metadata_map) {",
          "142:   parent_.onUpstreamMetadata(std::move(metadata_map));",
          "143: }",
          "145: void UpstreamRequest::maybeEndDecode(bool end_stream) {",
          "146:   if (end_stream) {",
          "147:     upstream_timing_.onLastUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());",
          "148:     decode_complete_ = true;",
          "149:   }",
          "150: }",
          "152: void UpstreamRequest::onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host) {",
          "153:   stream_info_.onUpstreamHostSelected(host);",
          "154:   upstream_host_ = host;",
          "155:   parent_.callbacks_->streamInfo().onUpstreamHostSelected(host);",
          "156:   if (parent_.retry_state_ && host) {",
          "157:     parent_.retry_state_->onHostAttempted(host);",
          "158:   }",
          "159: }",
          "161: void UpstreamRequest::encodeHeaders(bool end_stream) {",
          "162:   ASSERT(!encode_complete_);",
          "163:   encode_complete_ = end_stream;",
          "168:   Http::ConnectionPool::Cancellable* handle = conn_pool_.newStream(*this, *this);",
          "169:   if (handle) {",
          "170:     conn_pool_stream_handle_ = handle;",
          "171:   }",
          "172: }",
          "174: void UpstreamRequest::encodeData(Buffer::Instance& data, bool end_stream) {",
          "175:   ASSERT(!encode_complete_);",
          "176:   encode_complete_ = end_stream;",
          "178:   if (!request_encoder_) {",
          "179:     ENVOY_STREAM_LOG(trace, \"buffering {} bytes\", *parent_.callbacks_, data.length());",
          "180:     if (!buffered_request_body_) {",
          "181:       buffered_request_body_ = std::make_unique<Buffer::WatermarkBuffer>(",
          "182:           [this]() -> void { this->enableDataFromDownstreamForFlowControl(); },",
          "183:           [this]() -> void { this->disableDataFromDownstreamForFlowControl(); });",
          "184:       buffered_request_body_->setWatermarks(parent_.callbacks_->decoderBufferLimit());",
          "185:     }",
          "187:     buffered_request_body_->move(data);",
          "188:   } else {",
          "189:     ASSERT(downstream_metadata_map_vector_.empty());",
          "191:     ENVOY_STREAM_LOG(trace, \"proxying {} bytes\", *parent_.callbacks_, data.length());",
          "192:     stream_info_.addBytesSent(data.length());",
          "193:     request_encoder_->encodeData(data, end_stream);",
          "194:     if (end_stream) {",
          "195:       upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "196:     }",
          "197:   }",
          "198: }",
          "200: void UpstreamRequest::encodeTrailers(const Http::RequestTrailerMap& trailers) {",
          "201:   ASSERT(!encode_complete_);",
          "202:   encode_complete_ = true;",
          "203:   encode_trailers_ = true;",
          "205:   if (!request_encoder_) {",
          "206:     ENVOY_STREAM_LOG(trace, \"buffering trailers\", *parent_.callbacks_);",
          "207:   } else {",
          "208:     ASSERT(downstream_metadata_map_vector_.empty());",
          "210:     ENVOY_STREAM_LOG(trace, \"proxying trailers\", *parent_.callbacks_);",
          "211:     request_encoder_->encodeTrailers(trailers);",
          "212:     upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "213:   }",
          "214: }",
          "216: void UpstreamRequest::encodeMetadata(Http::MetadataMapPtr&& metadata_map_ptr) {",
          "217:   if (!request_encoder_) {",
          "218:     ENVOY_STREAM_LOG(trace, \"request_encoder_ not ready. Store metadata_map to encode later: {}\",",
          "220:     downstream_metadata_map_vector_.emplace_back(std::move(metadata_map_ptr));",
          "221:   } else {",
          "222:     ENVOY_STREAM_LOG(trace, \"Encode metadata: {}\", *parent_.callbacks_, *metadata_map_ptr);",
          "223:     Http::MetadataMapVector metadata_map_vector;",
          "224:     metadata_map_vector.emplace_back(std::move(metadata_map_ptr));",
          "225:     request_encoder_->encodeMetadata(metadata_map_vector);",
          "226:   }",
          "227: }",
          "229: void UpstreamRequest::onResetStream(Http::StreamResetReason reason,",
          "230:                                     absl::string_view transport_failure_reason) {",
          "231:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "233:   if (span_ != nullptr) {",
          "235:     span_->setTag(Tracing::Tags::get().Error, Tracing::Tags::get().True);",
          "236:     span_->setTag(Tracing::Tags::get().ErrorReason, Http::Utility::resetReasonToString(reason));",
          "237:   }",
          "239:   clearRequestEncoder();",
          "240:   awaiting_headers_ = false;",
          "241:   if (!calling_encode_headers_) {",
          "242:     stream_info_.setResponseFlag(parent_.streamResetReasonToResponseFlag(reason));",
          "243:     parent_.onUpstreamReset(reason, transport_failure_reason, *this);",
          "244:   } else {",
          "245:     deferred_reset_reason_ = reason;",
          "246:   }",
          "247: }",
          "249: void UpstreamRequest::resetStream() {",
          "251:   if (encode_complete_ && decode_complete_) {",
          "252:     return;",
          "253:   }",
          "255:   if (span_ != nullptr) {",
          "257:     span_->setTag(Tracing::Tags::get().Canceled, Tracing::Tags::get().True);",
          "258:   }",
          "260:   if (conn_pool_stream_handle_) {",
          "261:     ENVOY_STREAM_LOG(debug, \"cancelling pool request\", *parent_.callbacks_);",
          "262:     ASSERT(!request_encoder_);",
          "263:     conn_pool_stream_handle_->cancel();",
          "264:     conn_pool_stream_handle_ = nullptr;",
          "265:   }",
          "267:   if (request_encoder_) {",
          "268:     ENVOY_STREAM_LOG(debug, \"resetting pool request\", *parent_.callbacks_);",
          "269:     request_encoder_->getStream().removeCallbacks(*this);",
          "270:     request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);",
          "271:     clearRequestEncoder();",
          "272:   }",
          "273: }",
          "275: void UpstreamRequest::setupPerTryTimeout() {",
          "276:   ASSERT(!per_try_timeout_);",
          "277:   if (parent_.timeout_.per_try_timeout_.count() > 0) {",
          "278:     per_try_timeout_ =",
          "279:         parent_.callbacks_->dispatcher().createTimer([this]() -> void { onPerTryTimeout(); });",
          "280:     per_try_timeout_->enableTimer(parent_.timeout_.per_try_timeout_);",
          "281:   }",
          "282: }",
          "284: void UpstreamRequest::onPerTryTimeout() {",
          "287:   if (!parent_.downstream_response_started_) {",
          "288:     ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks_);",
          "290:     stream_info_.setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout);",
          "291:     parent_.onPerTryTimeout(*this);",
          "292:   } else {",
          "293:     ENVOY_STREAM_LOG(debug,",
          "294:                      \"ignored upstream per try timeout due to already started downstream response\",",
          "296:   }",
          "297: }",
          "299: void UpstreamRequest::onPoolFailure(Http::ConnectionPool::PoolFailureReason reason,",
          "300:                                     absl::string_view transport_failure_reason,",
          "301:                                     Upstream::HostDescriptionConstSharedPtr host) {",
          "302:   Http::StreamResetReason reset_reason = Http::StreamResetReason::ConnectionFailure;",
          "303:   switch (reason) {",
          "304:   case Http::ConnectionPool::PoolFailureReason::Overflow:",
          "305:     reset_reason = Http::StreamResetReason::Overflow;",
          "306:     break;",
          "307:   case Http::ConnectionPool::PoolFailureReason::ConnectionFailure:",
          "308:     reset_reason = Http::StreamResetReason::ConnectionFailure;",
          "309:     break;",
          "310:   }",
          "313:   onUpstreamHostSelected(host);",
          "314:   onResetStream(reset_reason, transport_failure_reason);",
          "315: }",
          "317: void UpstreamRequest::onPoolReady(Http::RequestEncoder& request_encoder,",
          "318:                                   Upstream::HostDescriptionConstSharedPtr host,",
          "319:                                   const StreamInfo::StreamInfo& info) {",
          "321:   ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());",
          "322:   ENVOY_STREAM_LOG(debug, \"pool ready\", *parent_.callbacks_);",
          "324:   host->outlierDetector().putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess);",
          "326:   onUpstreamHostSelected(host);",
          "327:   request_encoder.getStream().addCallbacks(*this);",
          "329:   stream_info_.setUpstreamLocalAddress(request_encoder.getStream().connectionLocalAddress());",
          "330:   parent_.callbacks_->streamInfo().setUpstreamLocalAddress(",
          "331:       request_encoder.getStream().connectionLocalAddress());",
          "333:   stream_info_.setUpstreamSslConnection(info.downstreamSslConnection());",
          "334:   parent_.callbacks_->streamInfo().setUpstreamSslConnection(info.downstreamSslConnection());",
          "336:   if (parent_.downstream_end_stream_) {",
          "337:     setupPerTryTimeout();",
          "338:   } else {",
          "339:     create_per_try_timeout_on_request_complete_ = true;",
          "340:   }",
          "342:   conn_pool_stream_handle_ = nullptr;",
          "343:   setRequestEncoder(request_encoder);",
          "344:   calling_encode_headers_ = true;",
          "345:   if (parent_.route_entry_->autoHostRewrite() && !host->hostname().empty()) {",
          "346:     parent_.downstream_headers_->setHost(host->hostname());",
          "347:   }",
          "349:   if (span_ != nullptr) {",
          "350:     span_->injectContext(*parent_.downstream_headers_);",
          "351:   }",
          "353:   upstream_timing_.onFirstUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "355:   const bool end_stream = !buffered_request_body_ && encode_complete_ && !encode_trailers_;",
          "358:   const bool delay_headers_end_stream = end_stream && !downstream_metadata_map_vector_.empty();",
          "359:   request_encoder.encodeHeaders(*parent_.downstream_headers_,",
          "360:                                 end_stream && !delay_headers_end_stream);",
          "361:   calling_encode_headers_ = false;",
          "368:   if (deferred_reset_reason_) {",
          "369:     onResetStream(deferred_reset_reason_.value(), absl::string_view());",
          "370:   } else {",
          "372:     if (!downstream_metadata_map_vector_.empty()) {",
          "373:       ENVOY_STREAM_LOG(debug, \"Send metadata onPoolReady. {}\", *parent_.callbacks_,",
          "374:                        downstream_metadata_map_vector_);",
          "375:       request_encoder.encodeMetadata(downstream_metadata_map_vector_);",
          "376:       downstream_metadata_map_vector_.clear();",
          "377:       if (delay_headers_end_stream) {",
          "378:         Buffer::OwnedImpl empty_data(\"\");",
          "379:         request_encoder.encodeData(empty_data, true);",
          "380:       }",
          "381:     }",
          "383:     if (buffered_request_body_) {",
          "384:       stream_info_.addBytesSent(buffered_request_body_->length());",
          "385:       request_encoder.encodeData(*buffered_request_body_, encode_complete_ && !encode_trailers_);",
          "386:     }",
          "388:     if (encode_trailers_) {",
          "389:       request_encoder.encodeTrailers(*parent_.downstream_trailers_);",
          "390:     }",
          "392:     if (encode_complete_) {",
          "393:       upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());",
          "394:     }",
          "395:   }",
          "396: }",
          "398: void UpstreamRequest::setRequestEncoder(Http::RequestEncoder& request_encoder) {",
          "399:   request_encoder_ = &request_encoder;",
          "403:   parent_.callbacks_->addDownstreamWatermarkCallbacks(downstream_watermark_manager_);",
          "404: }",
          "406: void UpstreamRequest::clearRequestEncoder() {",
          "408:   if (request_encoder_) {",
          "409:     parent_.callbacks_->removeDownstreamWatermarkCallbacks(downstream_watermark_manager_);",
          "410:   }",
          "411:   request_encoder_ = nullptr;",
          "412: }",
          "414: void UpstreamRequest::DownstreamWatermarkManager::onAboveWriteBufferHighWatermark() {",
          "415:   ASSERT(parent_.request_encoder_);",
          "422:   ASSERT(!parent_.parent_.final_upstream_request_ ||",
          "423:          &parent_ == parent_.parent_.final_upstream_request_);",
          "428:   parent_.parent_.cluster_->stats().upstream_flow_control_paused_reading_total_.inc();",
          "429:   parent_.request_encoder_->getStream().readDisable(true);",
          "430: }",
          "432: void UpstreamRequest::DownstreamWatermarkManager::onBelowWriteBufferLowWatermark() {",
          "433:   ASSERT(parent_.request_encoder_);",
          "437:   parent_.parent_.cluster_->stats().upstream_flow_control_resumed_reading_total_.inc();",
          "438:   parent_.request_encoder_->getStream().readDisable(false);",
          "439: }",
          "441: void UpstreamRequest::disableDataFromDownstreamForFlowControl() {",
          "451:   ASSERT(parent_.upstream_requests_.size() == 1 || parent_.downstream_end_stream_);",
          "452:   parent_.cluster_->stats().upstream_flow_control_backed_up_total_.inc();",
          "453:   parent_.callbacks_->onDecoderFilterAboveWriteBufferHighWatermark();",
          "454: }",
          "456: void UpstreamRequest::enableDataFromDownstreamForFlowControl() {",
          "466:   ASSERT(parent_.upstream_requests_.size() == 1 || parent_.downstream_end_stream_);",
          "467:   parent_.cluster_->stats().upstream_flow_control_drained_total_.inc();",
          "468:   parent_.callbacks_->onDecoderFilterBelowWriteBufferLowWatermark();",
          "469: }",
          "471: } // namespace Router",
          "472: } // namespace Envoy",
          "",
          "---------------"
        ],
        "source/common/router/upstream_request.h||source/common/router/upstream_request.h": [
          "File: source/common/router/upstream_request.h -> source/common/router/upstream_request.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #pragma once",
          "3: #include <chrono>",
          "4: #include <cstdint>",
          "5: #include <functional>",
          "6: #include <memory>",
          "7: #include <string>",
          "9: #include \"envoy/http/codec.h\"",
          "10: #include \"envoy/http/codes.h\"",
          "11: #include \"envoy/http/filter.h\"",
          "12: #include \"envoy/stats/scope.h\"",
          "14: #include \"common/buffer/watermark_buffer.h\"",
          "15: #include \"common/common/cleanup.h\"",
          "16: #include \"common/common/hash.h\"",
          "17: #include \"common/common/hex.h\"",
          "18: #include \"common/common/linked_object.h\"",
          "19: #include \"common/common/logger.h\"",
          "20: #include \"common/config/well_known_names.h\"",
          "21: #include \"common/router/router.h\"",
          "22: #include \"common/stream_info/stream_info_impl.h\"",
          "24: namespace Envoy {",
          "25: namespace Router {",
          "27: class Filter;",
          "29: class UpstreamRequest : public Logger::Loggable<Logger::Id::router>,",
          "30:                         public Http::ResponseDecoder,",
          "31:                         public Http::StreamCallbacks,",
          "32:                         public Http::ConnectionPool::Callbacks,",
          "33:                         public LinkedObject<UpstreamRequest> {",
          "34: public:",
          "35:   UpstreamRequest(Filter& parent, Http::ConnectionPool::Instance& pool);",
          "36:   ~UpstreamRequest() override;",
          "38:   void encodeHeaders(bool end_stream);",
          "39:   void encodeData(Buffer::Instance& data, bool end_stream);",
          "40:   void encodeTrailers(const Http::RequestTrailerMap& trailers);",
          "41:   void encodeMetadata(Http::MetadataMapPtr&& metadata_map_ptr);",
          "43:   void resetStream();",
          "44:   void setupPerTryTimeout();",
          "45:   void onPerTryTimeout();",
          "46:   void maybeEndDecode(bool end_stream);",
          "47:   void onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host);",
          "50:   void decodeData(Buffer::Instance& data, bool end_stream) override;",
          "51:   void decodeMetadata(Http::MetadataMapPtr&& metadata_map) override;",
          "54:   void decode100ContinueHeaders(Http::ResponseHeaderMapPtr&& headers) override;",
          "55:   void decodeHeaders(Http::ResponseHeaderMapPtr&& headers, bool end_stream) override;",
          "56:   void decodeTrailers(Http::ResponseTrailerMapPtr&& trailers) override;",
          "59:   void onResetStream(Http::StreamResetReason reason,",
          "60:                      absl::string_view transport_failure_reason) override;",
          "61:   void onAboveWriteBufferHighWatermark() override { disableDataFromDownstreamForFlowControl(); }",
          "62:   void onBelowWriteBufferLowWatermark() override { enableDataFromDownstreamForFlowControl(); }",
          "64:   void disableDataFromDownstreamForFlowControl();",
          "65:   void enableDataFromDownstreamForFlowControl();",
          "68:   void onPoolFailure(Http::ConnectionPool::PoolFailureReason reason,",
          "69:                      absl::string_view transport_failure_reason,",
          "70:                      Upstream::HostDescriptionConstSharedPtr host) override;",
          "71:   void onPoolReady(Http::RequestEncoder& request_encoder,",
          "72:                    Upstream::HostDescriptionConstSharedPtr host,",
          "73:                    const StreamInfo::StreamInfo& info) override;",
          "75:   void setRequestEncoder(Http::RequestEncoder& request_encoder);",
          "76:   void clearRequestEncoder();",
          "78:   struct DownstreamWatermarkManager : public Http::DownstreamWatermarkCallbacks {",
          "79:     DownstreamWatermarkManager(UpstreamRequest& parent) : parent_(parent) {}",
          "82:     void onBelowWriteBufferLowWatermark() override;",
          "83:     void onAboveWriteBufferHighWatermark() override;",
          "85:     UpstreamRequest& parent_;",
          "86:   };",
          "88:   void readEnable();",
          "91:   Upstream::HostDescriptionConstSharedPtr& upstreamHost() { return upstream_host_; }",
          "92:   void outlierDetectionTimeoutRecorded(bool recorded) {",
          "93:     outlier_detection_timeout_recorded_ = recorded;",
          "94:   }",
          "95:   bool outlierDetectionTimeoutRecorded() { return outlier_detection_timeout_recorded_; }",
          "96:   const StreamInfo::UpstreamTiming& upstreamTiming() { return upstream_timing_; }",
          "97:   void retried(bool value) { retried_ = value; }",
          "98:   bool retried() { return retried_; }",
          "99:   bool grpcRqSuccessDeferred() { return grpc_rq_success_deferred_; }",
          "100:   void grpcRqSuccessDeferred(bool deferred) { grpc_rq_success_deferred_ = deferred; }",
          "101:   void upstreamCanary(bool value) { upstream_canary_ = value; }",
          "102:   bool upstreamCanary() { return upstream_canary_; }",
          "103:   bool awaitingHeaders() { return awaiting_headers_; }",
          "104:   void recordTimeoutBudget(bool value) { record_timeout_budget_ = value; }",
          "105:   bool createPerTryTimeoutOnRequestComplete() {",
          "106:     return create_per_try_timeout_on_request_complete_;",
          "107:   }",
          "109: private:",
          "110:   Filter& parent_;",
          "111:   Http::ConnectionPool::Instance& conn_pool_;",
          "112:   bool grpc_rq_success_deferred_;",
          "113:   Event::TimerPtr per_try_timeout_;",
          "114:   Http::ConnectionPool::Cancellable* conn_pool_stream_handle_{};",
          "115:   Http::RequestEncoder* request_encoder_{};",
          "116:   absl::optional<Http::StreamResetReason> deferred_reset_reason_;",
          "117:   Buffer::WatermarkBufferPtr buffered_request_body_;",
          "118:   Upstream::HostDescriptionConstSharedPtr upstream_host_;",
          "119:   DownstreamWatermarkManager downstream_watermark_manager_{*this};",
          "120:   Tracing::SpanPtr span_;",
          "121:   StreamInfo::StreamInfoImpl stream_info_;",
          "122:   StreamInfo::UpstreamTiming upstream_timing_;",
          "123:   const MonotonicTime start_time_;",
          "126:   Http::ResponseHeaderMapPtr upstream_headers_;",
          "127:   Http::ResponseTrailerMapPtr upstream_trailers_;",
          "128:   Http::MetadataMapVector downstream_metadata_map_vector_;",
          "130:   bool calling_encode_headers_ : 1;",
          "131:   bool upstream_canary_ : 1;",
          "132:   bool decode_complete_ : 1;",
          "133:   bool encode_complete_ : 1;",
          "134:   bool encode_trailers_ : 1;",
          "135:   bool retried_ : 1;",
          "136:   bool awaiting_headers_ : 1;",
          "137:   bool outlier_detection_timeout_recorded_ : 1;",
          "140:   bool create_per_try_timeout_on_request_complete_ : 1;",
          "144:   bool record_timeout_budget_ : 1;",
          "145: };",
          "147: } // namespace Router",
          "148: } // namespace Envoy",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df3d47f478c29188d22b517d1a0d05793dfe2c62",
      "candidate_info": {
        "commit_hash": "df3d47f478c29188d22b517d1a0d05793dfe2c62",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/df3d47f478c29188d22b517d1a0d05793dfe2c62",
        "files": [
          "api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto",
          "bazel/external/http-parser.BUILD",
          "source/common/http/conn_manager_utility.cc",
          "source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h",
          "source/common/http/http2/codec_impl.cc",
          "source/extensions/filters/network/http_connection_manager/config.cc",
          "test/common/http/codec_impl_fuzz_test.cc",
          "test/common/http/http1/codec_impl_test.cc",
          "test/common/http/http2/codec_impl_test.cc",
          "test/extensions/filters/network/http_connection_manager/config_test.cc",
          "test/integration/autonomous_upstream.cc",
          "test/integration/fake_upstream.cc",
          "test/integration/fake_upstream.h",
          "test/integration/http2_integration_test.cc",
          "test/integration/http_integration.cc",
          "test/integration/http_integration.h",
          "test/integration/http_protocol_integration.h",
          "test/integration/integration_test.cc",
          "test/integration/protocol_integration_test.cc",
          "tools/spelling_dictionary.txt"
        ],
        "message": "codec: Raise max_request_headers_kb limit to 96 KiB (#5859)\n\nBump up max configurable max_request_headers_kb to 96 KiB.\nAdd a check to http1/codec_impl.cc for headers size.\nRaise the default library limits in http_parser nghttp2 so we'll rely on our own codec check.\n\nRisk Level: Medium.\nTesting: Moved all the large request headers tests to ProtocolIntegrationTest.\nPart of #5626.\n\nSigned-off-by: Auni Ahsan <auni@google.com>",
        "before_after_code_files": [
          "api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto||api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto",
          "bazel/external/http-parser.BUILD||bazel/external/http-parser.BUILD",
          "source/common/http/conn_manager_utility.cc||source/common/http/conn_manager_utility.cc",
          "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h",
          "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc",
          "source/extensions/filters/network/http_connection_manager/config.cc||source/extensions/filters/network/http_connection_manager/config.cc",
          "test/common/http/codec_impl_fuzz_test.cc||test/common/http/codec_impl_fuzz_test.cc",
          "test/common/http/http1/codec_impl_test.cc||test/common/http/http1/codec_impl_test.cc",
          "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc",
          "test/extensions/filters/network/http_connection_manager/config_test.cc||test/extensions/filters/network/http_connection_manager/config_test.cc",
          "test/integration/autonomous_upstream.cc||test/integration/autonomous_upstream.cc",
          "test/integration/fake_upstream.cc||test/integration/fake_upstream.cc",
          "test/integration/fake_upstream.h||test/integration/fake_upstream.h",
          "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc",
          "test/integration/http_integration.cc||test/integration/http_integration.cc",
          "test/integration/http_integration.h||test/integration/http_integration.h",
          "test/integration/http_protocol_integration.h||test/integration/http_protocol_integration.h",
          "test/integration/integration_test.cc||test/integration/integration_test.cc",
          "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
            "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc",
            "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc",
            "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc",
            "test/integration/http_integration.cc||test/integration/http_integration.cc",
            "test/integration/http_integration.h||test/integration/http_integration.h",
            "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
          ],
          "candidate": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
            "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc",
            "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc",
            "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc",
            "test/integration/http_integration.cc||test/integration/http_integration.cc",
            "test/integration/http_integration.h||test/integration/http_integration.h",
            "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto||api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto": [
          "File: api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto -> api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:   string server_name = 10;",
          "146:   google.protobuf.UInt32Value max_request_headers_kb = 29",
          "",
          "[Removed Lines]",
          "147:       [(validate.rules).uint32.gt = 0, (validate.rules).uint32.lte = 64];",
          "",
          "[Added Lines]",
          "146:       [(validate.rules).uint32.gt = 0, (validate.rules).uint32.lte = 96];",
          "",
          "---------------"
        ],
        "bazel/external/http-parser.BUILD||bazel/external/http-parser.BUILD": [
          "File: bazel/external/http-parser.BUILD -> bazel/external/http-parser.BUILD",
          "--- Hunk 1 ---",
          "[Context before]",
          "7:         \"http_parser.h\",",
          "8:     ],",
          "9:     hdrs = [\"http_parser.h\"],",
          "10:     includes = [\".\"],",
          "11:     visibility = [\"//visibility:public\"],",
          "12: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10:     # This compiler flag is set to an arbtitrarily high number so",
          "11:     # as to effectively disables the http_parser header limit, as",
          "12:     # we do our own checks in the conn manager and codec.",
          "13:     copts = [\"-DHTTP_MAX_HEADER_SIZE=0x2000000\"],",
          "",
          "---------------"
        ],
        "source/common/http/conn_manager_utility.cc||source/common/http/conn_manager_utility.cc": [
          "File: source/common/http/conn_manager_utility.cc -> source/common/http/conn_manager_utility.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:     ServerConnectionCallbacks& callbacks, Stats::Scope& scope, const Http1Settings& http1_settings,",
          "42:     const Http2Settings& http2_settings, const uint32_t max_request_headers_kb) {",
          "43:   if (determineNextProtocol(connection, data) == Http2::ALPN_STRING) {",
          "46:   } else {",
          "49:   }",
          "50: }",
          "",
          "[Removed Lines]",
          "44:     return ServerConnectionPtr{new Http2::ServerConnectionImpl(",
          "45:         connection, callbacks, scope, http2_settings, max_request_headers_kb)};",
          "47:     return ServerConnectionPtr{",
          "48:         new Http1::ServerConnectionImpl(connection, callbacks, http1_settings)};",
          "",
          "[Added Lines]",
          "44:     return std::make_unique<Http2::ServerConnectionImpl>(connection, callbacks, scope,",
          "45:                                                          http2_settings, max_request_headers_kb);",
          "47:     return std::make_unique<Http1::ServerConnectionImpl>(connection, callbacks, http1_settings,",
          "48:                                                          max_request_headers_kb);",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
          "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "316:   return *table;",
          "317: }",
          "320:     : connection_(connection), output_buffer_([&]() -> void { this->onBelowLowWatermark(); },",
          "322:   output_buffer_.setWatermarks(connection.bufferLimit());",
          "323:   http_parser_init(&parser_, type);",
          "324:   parser_.data = this;",
          "",
          "[Removed Lines]",
          "319: ConnectionImpl::ConnectionImpl(Network::Connection& connection, http_parser_type type)",
          "321:                                               [&]() -> void { this->onAboveHighWatermark(); }) {",
          "",
          "[Added Lines]",
          "319: ConnectionImpl::ConnectionImpl(Network::Connection& connection, http_parser_type type,",
          "320:                                uint32_t max_headers_kb)",
          "322:                                               [&]() -> void { this->onAboveHighWatermark(); }),",
          "323:       max_headers_kb_(max_headers_kb) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "420:   header_parsing_state_ = HeaderParsingState::Value;",
          "421:   current_header_value_.append(data, length);",
          "422: }",
          "424: int ConnectionImpl::onHeadersCompleteBase() {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "425:   const uint32_t total =",
          "426:       current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();",
          "427:   if (total > (max_headers_kb_ * 1024)) {",
          "428:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
          "429:     sendProtocolError();",
          "430:     throw CodecProtocolException(\"headers size exceeds limit\");",
          "431:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "472: ServerConnectionImpl::ServerConnectionImpl(Network::Connection& connection,",
          "473:                                            ServerConnectionCallbacks& callbacks,",
          "477: void ServerConnectionImpl::onEncodeComplete() {",
          "478:   ASSERT(active_request_);",
          "",
          "[Removed Lines]",
          "474:                                            Http1Settings settings)",
          "475:     : ConnectionImpl(connection, HTTP_REQUEST), callbacks_(callbacks), codec_settings_(settings) {}",
          "",
          "[Added Lines]",
          "484:                                            Http1Settings settings, uint32_t max_request_headers_kb)",
          "485:     : ConnectionImpl(connection, HTTP_REQUEST, max_request_headers_kb), callbacks_(callbacks),",
          "486:       codec_settings_(settings) {}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "643: }",
          "645: ClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, ConnectionCallbacks&)",
          "648: bool ClientConnectionImpl::cannotHaveBody() {",
          "649:   if ((!pending_responses_.empty() && pending_responses_.front().head_request_) ||",
          "",
          "[Removed Lines]",
          "646:     : ConnectionImpl(connection, HTTP_RESPONSE) {}",
          "",
          "[Added Lines]",
          "657:     : ConnectionImpl(connection, HTTP_RESPONSE, MAX_RESPONSE_HEADERS_KB) {}",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h": [
          "File: source/common/http/http1/codec_impl.h -> source/common/http/http1/codec_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:   bool maybeDirectDispatch(Buffer::Instance& data);",
          "167: protected:",
          "170:   bool resetStreamCalled() { return reset_stream_called_; }",
          "",
          "[Removed Lines]",
          "168:   ConnectionImpl(Network::Connection& connection, http_parser_type type);",
          "",
          "[Added Lines]",
          "168:   ConnectionImpl(Network::Connection& connection, http_parser_type type,",
          "169:                  uint32_t max_request_headers_kb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "273:   Buffer::RawSlice reserved_iovec_;",
          "274:   char* reserved_current_{};",
          "275:   Protocol protocol_{Protocol::Http11};",
          "276: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277:   const uint32_t max_headers_kb_;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "281: class ServerConnectionImpl : public ServerConnection, public ConnectionImpl {",
          "282: public:",
          "283:   ServerConnectionImpl(Network::Connection& connection, ServerConnectionCallbacks& callbacks,",
          "286:   virtual bool supports_http_10() override { return codec_settings_.accept_http_10_; }",
          "",
          "[Removed Lines]",
          "284:                        Http1Settings settings);",
          "",
          "[Added Lines]",
          "286:                        Http1Settings settings, uint32_t max_request_headers_kb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "363:   std::list<PendingResponse> pending_responses_;",
          "365:   bool ignore_message_complete_for_100_continue_{};",
          "366: };",
          "368: } // namespace Http1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "370:   static constexpr uint32_t MAX_RESPONSE_HEADERS_KB = 80;",
          "",
          "---------------"
        ],
        "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc": [
          "File: source/common/http/http2/codec_impl.cc -> source/common/http/http2/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "868:   nghttp2_option_set_no_closed_streams(options_, 1);",
          "869:   nghttp2_option_set_no_auto_window_update(options_, 1);",
          "871:   if (http2_settings.hpack_table_size_ != NGHTTP2_DEFAULT_HEADER_TABLE_SIZE) {",
          "872:     nghttp2_option_set_max_deflate_dynamic_table_size(options_, http2_settings.hpack_table_size_);",
          "873:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "873:   nghttp2_option_set_max_send_header_block_length(options_, 0x2000000);",
          "",
          "---------------"
        ],
        "source/extensions/filters/network/http_connection_manager/config.cc||source/extensions/filters/network/http_connection_manager/config.cc": [
          "File: source/extensions/filters/network/http_connection_manager/config.cc -> source/extensions/filters/network/http_connection_manager/config.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:                                          Http::ServerConnectionCallbacks& callbacks) {",
          "322:   switch (codec_type_) {",
          "323:   case CodecType::HTTP1:",
          "326:   case CodecType::HTTP2:",
          "329:   case CodecType::AUTO:",
          "330:     return Http::ConnectionManagerUtility::autoCreateCodec(connection, data, callbacks,",
          "331:                                                            context_.scope(), http1_settings_,",
          "",
          "[Removed Lines]",
          "324:     return Http::ServerConnectionPtr{",
          "325:         new Http::Http1::ServerConnectionImpl(connection, callbacks, http1_settings_)};",
          "327:     return Http::ServerConnectionPtr{new Http::Http2::ServerConnectionImpl(",
          "328:         connection, callbacks, context_.scope(), http2_settings_, maxRequestHeadersKb())};",
          "",
          "[Added Lines]",
          "324:     return std::make_unique<Http::Http1::ServerConnectionImpl>(",
          "325:         connection, callbacks, http1_settings_, maxRequestHeadersKb());",
          "327:     return std::make_unique<Http::Http2::ServerConnectionImpl>(",
          "328:         connection, callbacks, context_.scope(), http2_settings_, maxRequestHeadersKb());",
          "",
          "---------------"
        ],
        "test/common/http/codec_impl_fuzz_test.cc||test/common/http/codec_impl_fuzz_test.cc": [
          "File: test/common/http/codec_impl_fuzz_test.cc -> test/common/http/codec_impl_fuzz_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "369:                                                                 max_request_headers_kb);",
          "370:   } else {",
          "371:     const Http1Settings server_http1settings{fromHttp1Settings(input.h1_settings().server())};",
          "374:   }",
          "376:   ReorderBuffer client_write_buf{*server};",
          "",
          "[Removed Lines]",
          "372:     server = absl::make_unique<Http1::ServerConnectionImpl>(server_connection, server_callbacks,",
          "373:                                                             server_http1settings);",
          "",
          "[Added Lines]",
          "372:     server = absl::make_unique<Http1::ServerConnectionImpl>(",
          "373:         server_connection, server_callbacks, server_http1settings, max_request_headers_kb);",
          "",
          "---------------"
        ],
        "test/common/http/http1/codec_impl_test.cc||test/common/http/http1/codec_impl_test.cc": [
          "File: test/common/http/http1/codec_impl_test.cc -> test/common/http/http1/codec_impl_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: class Http1ServerConnectionImplTest : public testing::Test {",
          "32: public:",
          "33:   void initialize() {",
          "35:   }",
          "37:   NiceMock<Network::MockConnection> connection_;",
          "",
          "[Removed Lines]",
          "34:     codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_);",
          "",
          "[Added Lines]",
          "34:     codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,",
          "35:                                                     max_request_headers_kb_);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:   void expectHeadersTest(Protocol p, bool allow_absolute_url, Buffer::OwnedImpl& buffer,",
          "43:                          TestHeaderMapImpl& expected_headers);",
          "44:   void expect400(Protocol p, bool allow_absolute_url, Buffer::OwnedImpl& buffer);",
          "45: };",
          "47: void Http1ServerConnectionImplTest::expect400(Protocol p, bool allow_absolute_url,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: protected:",
          "48:   uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:   if (allow_absolute_url) {",
          "55:     codec_settings_.allow_absolute_url_ = allow_absolute_url;",
          "57:   }",
          "59:   Http::MockStreamDecoder decoder;",
          "",
          "[Removed Lines]",
          "56:     codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_);",
          "",
          "[Added Lines]",
          "60:     codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,",
          "61:                                                     max_request_headers_kb_);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "73:   if (allow_absolute_url) {",
          "74:     codec_settings_.allow_absolute_url_ = allow_absolute_url;",
          "76:   }",
          "78:   Http::MockStreamDecoder decoder;",
          "",
          "[Removed Lines]",
          "75:     codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_);",
          "",
          "[Added Lines]",
          "80:     codec_ = std::make_unique<ServerConnectionImpl>(connection_, callbacks_, codec_settings_,",
          "81:                                                     max_request_headers_kb_);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1006:   static_cast<ClientConnection*>(codec_.get())",
          "1007:       ->onUnderlyingConnectionBelowWriteBufferLowWatermark();",
          "1008: }",
          "1012:   initialize();",
          "1014:   std::string exception_reason;",
          "",
          "[Removed Lines]",
          "1011: TEST_F(Http1ServerConnectionImplTest, TestCodecHeaderLimits) {",
          "",
          "[Added Lines]",
          "1015: TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersRejected) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1023:   Buffer::OwnedImpl buffer(\"GET / HTTP/1.1\\r\\n\");",
          "1024:   codec_->dispatch(buffer);",
          "1028:     codec_->dispatch(buffer);",
          "1029:   }",
          "1030:   buffer = Buffer::OwnedImpl(long_string);",
          "1033: }",
          "1035: } // namespace Http1",
          "",
          "[Removed Lines]",
          "1025:   std::string long_string = \"foo: \" + std::string(1024, 'q') + \"\\r\\n\";",
          "1026:   for (int i = 0; i < 79; ++i) {",
          "1027:     buffer = Buffer::OwnedImpl(long_string);",
          "1031:   EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException,",
          "1032:                             \"http/1.1 protocol error: HPE_HEADER_OVERFLOW\");",
          "",
          "[Added Lines]",
          "1030:   std::string long_string = \"big: \" + std::string(60 * 1024, 'q') + \"\\r\\n\";",
          "1031:   buffer = Buffer::OwnedImpl(long_string);",
          "1032:   EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, \"headers size exceeds limit\");",
          "1033: }",
          "1035: TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersSplitRejected) {",
          "1037:   initialize();",
          "1039:   std::string exception_reason;",
          "1040:   NiceMock<Http::MockStreamDecoder> decoder;",
          "1041:   Http::StreamEncoder* response_encoder = nullptr;",
          "1042:   EXPECT_CALL(callbacks_, newStream(_, _))",
          "1043:       .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {",
          "1044:         response_encoder = &encoder;",
          "1045:         return decoder;",
          "1046:       }));",
          "1047:   Buffer::OwnedImpl buffer(\"GET / HTTP/1.1\\r\\n\");",
          "1048:   codec_->dispatch(buffer);",
          "1050:   std::string long_string = std::string(1024, 'q');",
          "1051:   for (int i = 0; i < 59; i++) {",
          "1052:     buffer = Buffer::OwnedImpl(fmt::format(\"big: {}\\r\\n\", long_string));",
          "1056:   buffer = Buffer::OwnedImpl(fmt::format(\"big: {}\\r\\n\", long_string));",
          "1057:   EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, \"headers size exceeds limit\");",
          "1058: }",
          "1060: TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersAccepted) {",
          "1061:   max_request_headers_kb_ = 65;",
          "1062:   initialize();",
          "1064:   NiceMock<Http::MockStreamDecoder> decoder;",
          "1065:   Http::StreamEncoder* response_encoder = nullptr;",
          "1066:   EXPECT_CALL(callbacks_, newStream(_, _))",
          "1067:       .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {",
          "1068:         response_encoder = &encoder;",
          "1069:         return decoder;",
          "1070:       }));",
          "1072:   Buffer::OwnedImpl buffer(\"GET / HTTP/1.1\\r\\n\");",
          "1073:   codec_->dispatch(buffer);",
          "1074:   std::string long_string = \"big: \" + std::string(64 * 1024, 'q') + \"\\r\\n\";",
          "1075:   buffer = Buffer::OwnedImpl(long_string);",
          "1076:   codec_->dispatch(buffer);",
          "1077: }",
          "1079: TEST_F(Http1ServerConnectionImplTest, TestLargeRequestHeadersAcceptedMaxConfigurable) {",
          "1080:   max_request_headers_kb_ = 96;",
          "1081:   initialize();",
          "1083:   NiceMock<Http::MockStreamDecoder> decoder;",
          "1084:   Http::StreamEncoder* response_encoder = nullptr;",
          "1085:   EXPECT_CALL(callbacks_, newStream(_, _))",
          "1086:       .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {",
          "1087:         response_encoder = &encoder;",
          "1088:         return decoder;",
          "1089:       }));",
          "1091:   Buffer::OwnedImpl buffer(\"GET / HTTP/1.1\\r\\n\");",
          "1092:   codec_->dispatch(buffer);",
          "1093:   std::string long_string = \"big: \" + std::string(95 * 1024, 'q') + \"\\r\\n\";",
          "1095:   codec_->dispatch(buffer);",
          "1096: }",
          "1098: TEST_F(Http1ClientConnectionImplTest, TestLargeResponseHeadersRejected) {",
          "1099:   initialize();",
          "1101:   NiceMock<Http::MockStreamDecoder> response_decoder;",
          "1102:   Http::StreamEncoder& request_encoder = codec_->newStream(response_decoder);",
          "1103:   TestHeaderMapImpl headers{{\":method\", \"GET\"}, {\":path\", \"/\"}, {\":authority\", \"host\"}};",
          "1104:   request_encoder.encodeHeaders(headers, true);",
          "1106:   Buffer::OwnedImpl buffer(\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\");",
          "1107:   codec_->dispatch(buffer);",
          "1108:   std::string long_header = \"big: \" + std::string(80 * 1024, 'q') + \"\\r\\n\";",
          "1109:   buffer = Buffer::OwnedImpl(long_header);",
          "1110:   EXPECT_THROW_WITH_MESSAGE(codec_->dispatch(buffer), EnvoyException, \"headers size exceeds limit\");",
          "1111: }",
          "1113: TEST_F(Http1ClientConnectionImplTest, TestLargeResponseHeadersAccepted) {",
          "1114:   initialize();",
          "1116:   NiceMock<Http::MockStreamDecoder> response_decoder;",
          "1117:   Http::StreamEncoder& request_encoder = codec_->newStream(response_decoder);",
          "1118:   TestHeaderMapImpl headers{{\":method\", \"GET\"}, {\":path\", \"/\"}, {\":authority\", \"host\"}};",
          "1119:   request_encoder.encodeHeaders(headers, true);",
          "1121:   Buffer::OwnedImpl buffer(\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\");",
          "1122:   codec_->dispatch(buffer);",
          "1123:   std::string long_header = \"big: \" + std::string(79 * 1024, 'q') + \"\\r\\n\";",
          "1124:   buffer = Buffer::OwnedImpl(long_header);",
          "1125:   codec_->dispatch(buffer);",
          "",
          "---------------"
        ],
        "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc": [
          "File: test/common/http/http2/codec_impl_test.cc -> test/common/http/http2/codec_impl_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:     setupDefaultConnectionMocks();",
          "68:     EXPECT_CALL(server_callbacks_, newStream(_, _))",
          "70:           response_encoder_ = &encoder;",
          "71:           encoder.getStream().addCallbacks(server_stream_callbacks_);",
          "72:           return request_decoder_;",
          "",
          "[Removed Lines]",
          "69:         .WillOnce(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {",
          "",
          "[Added Lines]",
          "69:         .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "865:   }",
          "866: }",
          "869:   initialize();",
          "871:   TestHeaderMapImpl request_headers;",
          "",
          "[Removed Lines]",
          "868: TEST_P(Http2CodecImplTest, TestLargeHeadersInvokeResetStream) {",
          "",
          "[Added Lines]",
          "868: TEST_P(Http2CodecImplTest, TestLargeRequestHeadersInvokeResetStream) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "876:   request_encoder_->encodeHeaders(request_headers, false);",
          "877: }",
          "880:   max_request_headers_kb_ = 64;",
          "881:   initialize();",
          "",
          "[Removed Lines]",
          "879: TEST_P(Http2CodecImplTest, TestLargeHeadersAcceptedIfConfigured) {",
          "",
          "[Added Lines]",
          "879: TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAccepted) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "890:   request_encoder_->encodeHeaders(request_headers, false);",
          "891: }",
          "894:   uint32_t codec_limit_kb = 64;",
          "895:   max_request_headers_kb_ = codec_limit_kb;",
          "896:   initialize();",
          "",
          "[Removed Lines]",
          "893: TEST_P(Http2CodecImplTest, TestLargeHeadersAtLimitAccepted) {",
          "",
          "[Added Lines]",
          "893: TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "913:   request_encoder_->encodeHeaders(request_headers, true);",
          "914: }",
          "916: TEST_P(Http2CodecImplTest, TestCodecHeaderCompression) {",
          "917:   initialize();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "916: TEST_P(Http2CodecImplTest, TestLargeRequestHeadersOverDefaultCodecLibraryLimit) {",
          "917:   max_request_headers_kb_ = 66;",
          "918:   initialize();",
          "920:   TestHeaderMapImpl request_headers;",
          "921:   HttpTestUtility::addDefaultHeaders(request_headers);",
          "922:   std::string long_string = std::string(65 * 1024, 'q');",
          "923:   request_headers.addCopy(\"big\", long_string);",
          "925:   EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);",
          "926:   EXPECT_CALL(server_stream_callbacks_, onResetStream(_)).Times(0);",
          "927:   request_encoder_->encodeHeaders(request_headers, true);",
          "928: }",
          "930: TEST_P(Http2CodecImplTest, TestLargeRequestHeadersExceedPerHeaderLimit) {",
          "935:   max_request_headers_kb_ = 81;",
          "936:   initialize();",
          "938:   TestHeaderMapImpl request_headers;",
          "939:   HttpTestUtility::addDefaultHeaders(request_headers);",
          "940:   std::string long_string = std::string(80 * 1024, 'q');",
          "941:   request_headers.addCopy(\"big\", long_string);",
          "943:   EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(0);",
          "944:   EXPECT_CALL(client_callbacks_, onGoAway());",
          "945:   server_->shutdownNotice();",
          "946:   server_->goAway();",
          "947:   request_encoder_->encodeHeaders(request_headers, true);",
          "948: }",
          "950: TEST_P(Http2CodecImplTest, TestManyLargeRequestHeadersUnderPerHeaderLimit) {",
          "951:   max_request_headers_kb_ = 81;",
          "952:   initialize();",
          "954:   TestHeaderMapImpl request_headers;",
          "955:   HttpTestUtility::addDefaultHeaders(request_headers);",
          "956:   std::string long_string = std::string(1024, 'q');",
          "957:   for (int i = 0; i < 80; i++) {",
          "958:     request_headers.addCopy(fmt::format(\"{}\", i), long_string);",
          "959:   }",
          "961:   EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);",
          "962:   EXPECT_CALL(server_stream_callbacks_, onResetStream(_)).Times(0);",
          "963:   request_encoder_->encodeHeaders(request_headers, true);",
          "964: }",
          "966: TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtMaxConfigurable) {",
          "969:   max_request_headers_kb_ = 96;",
          "970:   initialize();",
          "972:   TestHeaderMapImpl request_headers;",
          "973:   HttpTestUtility::addDefaultHeaders(request_headers);",
          "974:   std::string long_string = std::string(1024, 'q');",
          "975:   for (int i = 0; i < 95; i++) {",
          "976:     request_headers.addCopy(fmt::format(\"{}\", i), long_string);",
          "977:   }",
          "979:   EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);",
          "980:   EXPECT_CALL(server_stream_callbacks_, onResetStream(_)).Times(0);",
          "981:   request_encoder_->encodeHeaders(request_headers, true);",
          "982: }",
          "",
          "---------------"
        ],
        "test/extensions/filters/network/http_connection_manager/config_test.cc||test/extensions/filters/network/http_connection_manager/config_test.cc": [
          "File: test/extensions/filters/network/http_connection_manager/config_test.cc -> test/extensions/filters/network/http_connection_manager/config_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:   EXPECT_FALSE(config.internalAddressConfig().isInternalAddress(externalIpAddress));",
          "153: }",
          "156:   const std::string yaml_string = R\"EOF(",
          "157:   stat_prefix: ingress_http",
          "158:   route_config:",
          "",
          "[Removed Lines]",
          "155: TEST_F(HttpConnectionManagerConfigTest, MaxRequestHeadersSizeDefault) {",
          "",
          "[Added Lines]",
          "155: TEST_F(HttpConnectionManagerConfigTest, MaxRequestHeadersKbDefault) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "166:   EXPECT_EQ(60, config.maxRequestHeadersKb());",
          "167: }",
          "170:   const std::string yaml_string = R\"EOF(",
          "171:   stat_prefix: ingress_http",
          "172:   max_request_headers_kb: 16",
          "",
          "[Removed Lines]",
          "169: TEST_F(HttpConnectionManagerConfigTest, MaxRequestHeadersSizeConfigured) {",
          "",
          "[Added Lines]",
          "169: TEST_F(HttpConnectionManagerConfigTest, MaxRequestHeadersKbConfigured) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:   EXPECT_EQ(16, config.maxRequestHeadersKb());",
          "182: }",
          "185: TEST_F(HttpConnectionManagerConfigTest, DisabledStreamIdleTimeout) {",
          "186:   const std::string yaml_string = R\"EOF(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184: TEST_F(HttpConnectionManagerConfigTest, MaxRequestHeadersKbMaxConfigurable) {",
          "185:   const std::string yaml_string = R\"EOF(",
          "186:   stat_prefix: ingress_http",
          "187:   max_request_headers_kb: 96",
          "188:   route_config:",
          "189:     name: local_route",
          "190:   http_filters:",
          "191:   - name: envoy.router",
          "192:   )EOF\";",
          "194:   HttpConnectionManagerConfig config(parseHttpConnectionManagerFromV2Yaml(yaml_string), context_,",
          "195:                                      date_provider_, route_config_provider_manager_);",
          "196:   EXPECT_EQ(96, config.maxRequestHeadersKb());",
          "197: }",
          "",
          "---------------"
        ],
        "test/integration/autonomous_upstream.cc||test/integration/autonomous_upstream.cc": [
          "File: test/integration/autonomous_upstream.cc -> test/integration/autonomous_upstream.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: AutonomousHttpConnection::AutonomousHttpConnection(SharedConnectionWrapper& shared_connection,",
          "63:                                                    Stats::Store& store, Type type,",
          "64:                                                    AutonomousUpstream& upstream)",
          "66:       upstream_(upstream) {}",
          "68: Http::StreamDecoder& AutonomousHttpConnection::newStream(Http::StreamEncoder& response_encoder,",
          "",
          "[Removed Lines]",
          "65:     : FakeHttpConnection(shared_connection, store, type, upstream.timeSystem()),",
          "",
          "[Added Lines]",
          "65:     : FakeHttpConnection(shared_connection, store, type, upstream.timeSystem(),",
          "66:                          Http::DEFAULT_MAX_REQUEST_HEADERS_KB),",
          "",
          "---------------"
        ],
        "test/integration/fake_upstream.cc||test/integration/fake_upstream.cc": [
          "File: test/integration/fake_upstream.cc -> test/integration/fake_upstream.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "209: FakeHttpConnection::FakeHttpConnection(SharedConnectionWrapper& shared_connection,",
          "210:                                        Stats::Store& store, Type type,",
          "212:     : FakeConnectionBase(shared_connection, time_system) {",
          "213:   if (type == Type::HTTP1) {",
          "216:   } else {",
          "217:     auto settings = Http::Http2Settings();",
          "218:     settings.allow_connect_ = true;",
          "219:     settings.allow_metadata_ = true;",
          "220:     codec_ = std::make_unique<Http::Http2::ServerConnectionImpl>(",
          "223:     ASSERT(type == Type::HTTP2);",
          "224:   }",
          "",
          "[Removed Lines]",
          "211:                                        Event::TestTimeSystem& time_system)",
          "214:     codec_ = std::make_unique<Http::Http1::ServerConnectionImpl>(shared_connection_.connection(),",
          "221:         shared_connection_.connection(), *this, store, settings,",
          "222:         Http::DEFAULT_MAX_REQUEST_HEADERS_KB);",
          "",
          "[Added Lines]",
          "211:                                        Event::TestTimeSystem& time_system,",
          "212:                                        uint32_t max_request_headers_kb)",
          "215:     codec_ = std::make_unique<Http::Http1::ServerConnectionImpl>(",
          "216:         shared_connection_.connection(), *this, Http::Http1Settings(), max_request_headers_kb);",
          "222:         shared_connection_.connection(), *this, store, settings, max_request_headers_kb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "433: AssertionResult FakeUpstream::waitForHttpConnection(Event::Dispatcher& client_dispatcher,",
          "434:                                                     FakeHttpConnectionPtr& connection,",
          "436:   Event::TestTimeSystem& time_system = timeSystem();",
          "437:   auto end_time = time_system.monotonicTime() + timeout;",
          "438:   {",
          "",
          "[Removed Lines]",
          "435:                                                     milliseconds timeout) {",
          "",
          "[Added Lines]",
          "435:                                                     milliseconds timeout,",
          "436:                                                     uint32_t max_request_headers_kb) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "452:       return AssertionFailure() << \"Got a new connection event, but didn't create a connection.\";",
          "453:     }",
          "454:     connection = std::make_unique<FakeHttpConnection>(consumeConnection(), stats_store_, http_type_,",
          "456:   }",
          "457:   VERIFY_ASSERTION(connection->initialize());",
          "458:   VERIFY_ASSERTION(connection->readDisable(false));",
          "",
          "[Removed Lines]",
          "455:                                                       time_system);",
          "",
          "[Added Lines]",
          "456:                                                       time_system, max_request_headers_kb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "482:       } else {",
          "483:         connection = std::make_unique<FakeHttpConnection>(",
          "484:             upstream.consumeConnection(), upstream.stats_store_, upstream.http_type_,",
          "486:         lock.release();",
          "487:         VERIFY_ASSERTION(connection->initialize());",
          "488:         VERIFY_ASSERTION(connection->readDisable(false));",
          "",
          "[Removed Lines]",
          "485:             upstream.timeSystem());",
          "",
          "[Added Lines]",
          "486:             upstream.timeSystem(), Http::DEFAULT_MAX_REQUEST_HEADERS_KB);",
          "",
          "---------------"
        ],
        "test/integration/fake_upstream.h||test/integration/fake_upstream.h": [
          "File: test/integration/fake_upstream.h -> test/integration/fake_upstream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "401:   enum class Type { HTTP1, HTTP2 };",
          "403:   FakeHttpConnection(SharedConnectionWrapper& shared_connection, Stats::Store& store, Type type,",
          "",
          "[Removed Lines]",
          "404:                      Event::TestTimeSystem& time_system);",
          "",
          "[Added Lines]",
          "404:                      Event::TestTimeSystem& time_system, uint32_t max_request_headers_kb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "529:   ABSL_MUST_USE_RESULT",
          "530:   testing::AssertionResult",
          "531:   waitForHttpConnection(Event::Dispatcher& client_dispatcher, FakeHttpConnectionPtr& connection,",
          "534:   ABSL_MUST_USE_RESULT",
          "535:   testing::AssertionResult",
          "",
          "[Removed Lines]",
          "532:                         std::chrono::milliseconds timeout = TestUtility::DefaultTimeout);",
          "",
          "[Added Lines]",
          "532:                         std::chrono::milliseconds timeout = TestUtility::DefaultTimeout,",
          "533:                         uint32_t max_request_headers_kb = Http::DEFAULT_MAX_REQUEST_HEADERS_KB);",
          "",
          "---------------"
        ],
        "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc": [
          "File: test/integration/http2_integration_test.cc -> test/integration/http2_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "431: TEST_P(Http2IntegrationTest, GrpcRetry) { testGrpcRetry(); }",
          "437: TEST_P(Http2IntegrationTest, BadMagic) {",
          "438:   initialize();",
          "439:   Buffer::OwnedImpl buffer(\"hello\");",
          "",
          "[Removed Lines]",
          "433: TEST_P(Http2IntegrationTest, LargeHeadersInvokeResetStream) { testLargeRequestHeaders(62, 60); }",
          "435: TEST_P(Http2IntegrationTest, LargeHeadersAcceptedIfConfigured) { testLargeRequestHeaders(62, 63); }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/integration/http_integration.cc||test/integration/http_integration.cc": [
          "File: test/integration/http_integration.cc -> test/integration/http_integration.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "284:   if (!fake_upstream_connection_) {",
          "285:     AssertionResult result = AssertionFailure();",
          "286:     for (auto upstream_index : upstream_indices) {",
          "289:       if (result) {",
          "290:         upstream_with_request = upstream_index;",
          "291:         break;",
          "",
          "[Removed Lines]",
          "287:       result = fake_upstreams_[upstream_index]->waitForHttpConnection(*dispatcher_,",
          "288:                                                                       fake_upstream_connection_);",
          "",
          "[Added Lines]",
          "287:       result = fake_upstreams_[upstream_index]->waitForHttpConnection(",
          "289:           max_request_headers_kb_);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "827:   config_helper_.addConfigModifier(",
          "828:       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)",
          "829:           -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });",
          "831:   Http::TestHeaderMapImpl big_headers{",
          "832:       {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "831:   max_request_headers_kb_ = max_size;",
          "",
          "---------------"
        ],
        "test/integration/http_integration.h||test/integration/http_integration.h": [
          "File: test/integration/http_integration.h -> test/integration/http_integration.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "196:       {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};",
          "198:   Http::CodecClient::Type downstream_protocol_{Http::CodecClient::Type::HTTP1};",
          "199: };",
          "200: } // namespace Envoy",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "199:   uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};",
          "",
          "---------------"
        ],
        "test/integration/http_protocol_integration.h||test/integration/http_protocol_integration.h": [
          "File: test/integration/http_protocol_integration.h -> test/integration/http_protocol_integration.h"
        ],
        "test/integration/integration_test.cc||test/integration/integration_test.cc": [
          "File: test/integration/integration_test.cc -> test/integration/integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "468:   EXPECT_EQ(normalizeDate(response1), normalizeDate(response2));",
          "469: }",
          "475: TEST_P(IntegrationTest, UpstreamProtocolError) {",
          "476:   initialize();",
          "477:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "",
          "[Removed Lines]",
          "471: TEST_P(IntegrationTest, LargeHeadersRejected) { testLargeRequestHeaders(62, 60); }",
          "473: TEST_P(IntegrationTest, LargeHeadersAccepted) { testLargeRequestHeaders(62, 63); }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc": [
          "File: test/integration/protocol_integration_test.cc -> test/integration/protocol_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "739:   EXPECT_EQ(0, upstream_request_->body().length());",
          "740: }",
          "744: INSTANTIATE_TEST_SUITE_P(Protocols, DownstreamProtocolIntegrationTest,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742: TEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersRejected) {",
          "743:   testLargeRequestHeaders(95, 60);",
          "744: }",
          "746: TEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersAccepted) {",
          "747:   testLargeRequestHeaders(95, 96);",
          "748: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3550a7a7b0b858f4c2ac505efa6c71c2610f2666",
      "candidate_info": {
        "commit_hash": "3550a7a7b0b858f4c2ac505efa6c71c2610f2666",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/3550a7a7b0b858f4c2ac505efa6c71c2610f2666",
        "files": [
          "source/common/http/http1/BUILD",
          "source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h"
        ],
        "message": "[http] Remove exceptions from HTTP/1 codec callbacks (#11101)\n\nCommit Message: Remove exceptions from HTTP/1 codec callbacks. Replaces with http_parser exit codes that indicate failure. codec_status_ propagates the error.\n\nAdditional Description:\n\nI know the diff is slightly messy but the principles I abided by were: Replace throw with setting codec_status_, immediately return and propagate return up to callback with an error exit code, always ASSERT(dispatching_) in the body of the method that throws, always ASSERT(codec_status_.ok()) before setting the codec status.\nThe remaining exception is in encodeHeaders, which I will need to replace with ENVOY_BUG\nI audited for throws in the includes for this file and did not find anything used in the codec_impl, but I will need to do another pass.\nThis is just part 1 of my HTTP/1 PRs. Part 2 is exception to error handling for encodeHeaders and any other utility functions. This is just a PR to stage.\nTesting: Tests pass, codec_impl_fuzz_test has been running for a few minutes.\nRisk level: Medium, this should do nothing but is a codec behavior change.\nIssues: #10878\n\nSigned-off-by: Asra Ali asraa@google.com",
        "before_after_code_files": [
          "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ],
          "candidate": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
          "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"envoy/http/header_map.h\"",
          "10: #include \"envoy/network/connection.h\"",
          "12: #include \"common/common/enum_to_int.h\"",
          "13: #include \"common/common/utility.h\"",
          "14: #include \"common/http/exception.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"common/common/cleanup.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "266:   outbound_responses_++;",
          "267: }",
          "270:   if (!flood_protection_) {",
          "272:   }",
          "",
          "[Removed Lines]",
          "269: void ServerConnectionImpl::doFloodProtectionChecks() const {",
          "271:     return;",
          "",
          "[Added Lines]",
          "270: ConnectionImpl::HttpParserCode ServerConnectionImpl::doFloodProtectionChecks() {",
          "271:   ASSERT(dispatching_);",
          "273:     return HttpParserCode::Success;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "276:     ENVOY_CONN_LOG(trace, \"error accepting request: too many pending responses queued\",",
          "277:                    connection_);",
          "278:     stats_.response_flood_.inc();",
          "280:   }",
          "281: }",
          "283: void ConnectionImpl::flushOutput(bool end_encode) {",
          "",
          "[Removed Lines]",
          "279:     throw FrameFloodException(\"Too many responses queued.\");",
          "",
          "[Added Lines]",
          "281:     ASSERT(codec_status_.ok());",
          "282:     codec_status_ = Http::bufferFloodError(\"Too many responses queued.\");",
          "283:     return HttpParserCode::Error;",
          "285:   return HttpParserCode::Success;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "402: http_parser_settings ConnectionImpl::settings_{",
          "403:     [](http_parser* parser) -> int {",
          "406:     },",
          "407:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "408:       static_cast<ConnectionImpl*>(parser->data)->onUrl(at, length);",
          "",
          "[Removed Lines]",
          "404:       static_cast<ConnectionImpl*>(parser->data)->onMessageBeginBase();",
          "405:       return 0;",
          "",
          "[Added Lines]",
          "409:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onMessageBeginBase());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "410:     },",
          "411:     nullptr, // on_status",
          "412:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "415:     },",
          "416:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "419:     },",
          "420:     [](http_parser* parser) -> int {",
          "422:     },",
          "423:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "424:       static_cast<ConnectionImpl*>(parser->data)->bufferBody(at, length);",
          "425:       return 0;",
          "426:     },",
          "427:     [](http_parser* parser) -> int {",
          "430:     },",
          "431:     [](http_parser* parser) -> int {",
          "",
          "[Removed Lines]",
          "413:       static_cast<ConnectionImpl*>(parser->data)->onHeaderField(at, length);",
          "414:       return 0;",
          "417:       static_cast<ConnectionImpl*>(parser->data)->onHeaderValue(at, length);",
          "418:       return 0;",
          "421:       return static_cast<ConnectionImpl*>(parser->data)->onHeadersCompleteBase();",
          "428:       static_cast<ConnectionImpl*>(parser->data)->onMessageCompleteBase();",
          "429:       return 0;",
          "",
          "[Added Lines]",
          "417:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onHeaderField(at, length));",
          "420:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onHeaderValue(at, length));",
          "423:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onHeadersCompleteBase());",
          "430:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onMessageCompleteBase());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "454:       enable_trailers_(enable_trailers),",
          "455:       reject_unsupported_transfer_encodings_(Runtime::runtimeFeatureEnabled(",
          "456:           \"envoy.reloadable_features.reject_unsupported_transfer_encodings\")),",
          "459:       max_headers_kb_(max_headers_kb), max_headers_count_(max_headers_count) {",
          "460:   output_buffer_.setWatermarks(connection.bufferLimit());",
          "461:   http_parser_init(&parser_, type);",
          "462:   parser_.data = this;",
          "463: }",
          "466:   ENVOY_CONN_LOG(trace, \"completed header: key={} value={}\", connection_,",
          "467:                  current_header_field_.getStringView(), current_header_value_.getStringView());",
          "470:   auto& headers_or_trailers = headersOrTrailers();",
          "471:   if (!current_header_field_.empty()) {",
          "472:     current_header_field_.inlineTransform([](char c) { return absl::ascii_tolower(c); });",
          "",
          "[Removed Lines]",
          "457:       output_buffer_([&]() -> void { this->onBelowLowWatermark(); },",
          "458:                      [&]() -> void { this->onAboveHighWatermark(); }),",
          "465: void ConnectionImpl::completeLastHeader() {",
          "469:   checkHeaderNameForUnderscores();",
          "",
          "[Added Lines]",
          "458:       dispatching_(false), output_buffer_([&]() -> void { this->onBelowLowWatermark(); },",
          "459:                                           [&]() -> void { this->onAboveHighWatermark(); }),",
          "466: ConnectionImpl::HttpParserCode ConnectionImpl::completeLastHeader() {",
          "467:   ASSERT(dispatching_);",
          "471:   if (!checkHeaderNameForUnderscores()) {",
          "473:     return HttpParserCode::Error;",
          "474:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "484:     sendProtocolError(Http1ResponseCodeDetails::get().TooManyHeaders);",
          "485:     const absl::string_view header_type =",
          "486:         processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "488:   }",
          "490:   header_parsing_state_ = HeaderParsingState::Field;",
          "491:   ASSERT(current_header_field_.empty());",
          "492:   ASSERT(current_header_value_.empty());",
          "493: }",
          "495: bool ConnectionImpl::maybeDirectDispatch(Buffer::Instance& data) {",
          "",
          "[Removed Lines]",
          "487:     throw CodecProtocolException(absl::StrCat(header_type, \" size exceeds limit\"));",
          "",
          "[Added Lines]",
          "492:     ASSERT(codec_status_.ok());",
          "493:     codec_status_ = codecProtocolError(absl::StrCat(header_type, \" size exceeds limit\"));",
          "494:     return HttpParserCode::Error;",
          "500:   return HttpParserCode::Success;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "515: Http::Status ConnectionImpl::innerDispatch(Buffer::Instance& data) {",
          "516:   ENVOY_CONN_LOG(trace, \"parsing {} bytes\", connection_, data.length());",
          "517:   ASSERT(buffered_body_.length() == 0);",
          "519:   if (maybeDirectDispatch(data)) {",
          "520:     return Http::okStatus();",
          "521:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "527:   Cleanup cleanup([this]() { dispatching_ = false; });",
          "528:   ASSERT(!dispatching_);",
          "531:   dispatching_ = true;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "526:   ssize_t total_parsed = 0;",
          "527:   if (data.length() > 0) {",
          "528:     for (const Buffer::RawSlice& slice : data.getRawSlices()) {",
          "530:       if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK) {",
          "",
          "[Removed Lines]",
          "529:       total_parsed += dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);",
          "",
          "[Added Lines]",
          "542:       auto statusor_parsed = dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);",
          "543:       if (!statusor_parsed.ok()) {",
          "544:         return statusor_parsed.status();",
          "545:       }",
          "546:       total_parsed += statusor_parsed.value();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "536:     }",
          "537:     dispatchBufferedBody();",
          "538:   } else {",
          "540:   }",
          "541:   ASSERT(buffered_body_.length() == 0);",
          "",
          "[Removed Lines]",
          "539:     dispatchSlice(nullptr, 0);",
          "",
          "[Added Lines]",
          "556:     auto result = dispatchSlice(nullptr, 0);",
          "557:     if (!result.ok()) {",
          "558:       return result.status();",
          "559:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "549:   return Http::okStatus();",
          "550: }",
          "553:   ssize_t rc = http_parser_execute(&parser_, &settings_, slice, len);",
          "554:   if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK && HTTP_PARSER_ERRNO(&parser_) != HPE_PAUSED) {",
          "555:     sendProtocolError(Http1ResponseCodeDetails::get().HttpCodecError);",
          "558:   }",
          "560:   return rc;",
          "561: }",
          "566:   if (header_parsing_state_ == HeaderParsingState::Done) {",
          "567:     if (!enable_trailers_) {",
          "570:     }",
          "571:     processing_trailers_ = true;",
          "572:     header_parsing_state_ = HeaderParsingState::Field;",
          "573:   }",
          "574:   if (header_parsing_state_ == HeaderParsingState::Value) {",
          "576:   }",
          "578:   current_header_field_.append(data, length);",
          "579: }",
          "582:   if (header_parsing_state_ == HeaderParsingState::Done && !enable_trailers_) {",
          "585:   }",
          "587:   if (processing_trailers_) {",
          "",
          "[Removed Lines]",
          "552: size_t ConnectionImpl::dispatchSlice(const char* slice, size_t len) {",
          "556:     throw CodecProtocolException(\"http/1.1 protocol error: \" +",
          "557:                                  std::string(http_errno_name(HTTP_PARSER_ERRNO(&parser_))));",
          "563: void ConnectionImpl::onHeaderField(const char* data, size_t length) {",
          "569:       return;",
          "575:     completeLastHeader();",
          "581: void ConnectionImpl::onHeaderValue(const char* data, size_t length) {",
          "584:     return;",
          "",
          "[Added Lines]",
          "572: Envoy::StatusOr<size_t> ConnectionImpl::dispatchSlice(const char* slice, size_t len) {",
          "573:   ASSERT(codec_status_.ok() && dispatching_);",
          "575:   if (!codec_status_.ok()) {",
          "576:     return codec_status_;",
          "577:   }",
          "581:     ASSERT(codec_status_.ok());",
          "582:     codec_status_ = codecProtocolError(",
          "583:         absl::StrCat(\"http/1.1 protocol error: \", http_errno_name(HTTP_PARSER_ERRNO(&parser_))));",
          "584:     return codec_status_;",
          "590: ConnectionImpl::HttpParserCode ConnectionImpl::onHeaderField(const char* data, size_t length) {",
          "591:   ASSERT(dispatching_);",
          "597:       return HttpParserCode::Success;",
          "603:     HttpParserCode exit_code = completeLastHeader();",
          "604:     if (exit_code == HttpParserCode::Error) {",
          "606:       ASSERT(!codec_status_.ok());",
          "607:       return HttpParserCode::Error;",
          "608:     }",
          "612:   return HttpParserCode::Success;",
          "615: ConnectionImpl::HttpParserCode ConnectionImpl::onHeaderValue(const char* data, size_t length) {",
          "616:   ASSERT(dispatching_);",
          "619:     return HttpParserCode::Success;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "595:       ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);",
          "596:       error_code_ = Http::Code::BadRequest;",
          "597:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters);",
          "599:     }",
          "600:   }",
          "",
          "[Removed Lines]",
          "598:       throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");",
          "",
          "[Added Lines]",
          "633:       ASSERT(codec_status_.ok());",
          "634:       codec_status_ =",
          "635:           codecProtocolError(\"http/1.1 protocol error: header value contains invalid chars\");",
          "636:       return HttpParserCode::Error;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "616:         processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "617:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
          "618:     sendProtocolError(Http1ResponseCodeDetails::get().HeadersTooLarge);",
          "620:   }",
          "621: }",
          "624:   ASSERT(!processing_trailers_);",
          "625:   ENVOY_CONN_LOG(trace, \"onHeadersCompleteBase\", connection_);",
          "628:   if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {",
          "",
          "[Removed Lines]",
          "619:     throw CodecProtocolException(absl::StrCat(header_type, \" size exceeds limit\"));",
          "623: int ConnectionImpl::onHeadersCompleteBase() {",
          "626:   completeLastHeader();",
          "",
          "[Added Lines]",
          "657:     ASSERT(codec_status_.ok());",
          "658:     codec_status_ = codecProtocolError(absl::StrCat(header_type, \" size exceeds limit\"));",
          "659:     return HttpParserCode::Error;",
          "661:   return HttpParserCode::Success;",
          "664: ConnectionImpl::HttpParserCode ConnectionImpl::onHeadersCompleteBase() {",
          "666:   ASSERT(dispatching_);",
          "668:   HttpParserCode exit_code = completeLastHeader();",
          "669:   if (exit_code == HttpParserCode::Error) {",
          "671:     ASSERT(!codec_status_.ok());",
          "672:     return exit_code;",
          "673:   }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "670:         !absl::EqualsIgnoreCase(encoding, Headers::get().TransferEncodingValues.Chunked)) {",
          "671:       error_code_ = Http::Code::NotImplemented;",
          "672:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidTransferEncoding);",
          "674:     }",
          "675:   }",
          "678:   header_parsing_state_ = HeaderParsingState::Done;",
          "682: }",
          "684: void ConnectionImpl::bufferBody(const char* data, size_t length) {",
          "",
          "[Removed Lines]",
          "673:       throw CodecProtocolException(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "677:   int rc = onHeadersComplete();",
          "681:   return handling_upgrade_ ? 2 : rc;",
          "",
          "[Added Lines]",
          "720:       ASSERT(codec_status_.ok());",
          "721:       codec_status_ = codecProtocolError(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "722:       return HttpParserCode::Error;",
          "726:   HttpParserCode rc = onHeadersComplete();",
          "727:   if (rc == HttpParserCode::Error) {",
          "728:     return rc;",
          "729:   }",
          "733:   return handling_upgrade_ ? HttpParserCode::NoBodyData : rc;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "688: void ConnectionImpl::dispatchBufferedBody() {",
          "689:   ASSERT(HTTP_PARSER_ERRNO(&parser_) == HPE_OK || HTTP_PARSER_ERRNO(&parser_) == HPE_PAUSED);",
          "690:   if (buffered_body_.length() > 0) {",
          "691:     onBody(buffered_body_);",
          "692:     buffered_body_.drain(buffered_body_.length());",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742:   ASSERT(codec_status_.ok());",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "701:   }",
          "702: }",
          "705:   ENVOY_CONN_LOG(trace, \"message complete\", connection_);",
          "707:   dispatchBufferedBody();",
          "",
          "[Removed Lines]",
          "704: void ConnectionImpl::onMessageCompleteBase() {",
          "",
          "[Added Lines]",
          "757: ConnectionImpl::HttpParserCode ConnectionImpl::onMessageCompleteBase() {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "712:     ASSERT(!deferred_end_stream_headers_);",
          "713:     ENVOY_CONN_LOG(trace, \"Pausing parser due to upgrade.\", connection_);",
          "714:     http_parser_pause(&parser_, 1);",
          "716:   }",
          "720:   if (header_parsing_state_ == HeaderParsingState::Value) {",
          "722:   }",
          "724:   onMessageComplete();",
          "725: }",
          "728:   ENVOY_CONN_LOG(trace, \"message begin\", connection_);",
          "",
          "[Removed Lines]",
          "715:     return;",
          "721:     completeLastHeader();",
          "727: void ConnectionImpl::onMessageBeginBase() {",
          "",
          "[Added Lines]",
          "768:     return HttpParserCode::Success;",
          "774:     HttpParserCode exit_code = completeLastHeader();",
          "775:     if (exit_code == HttpParserCode::Error) {",
          "777:       ASSERT(!codec_status_.ok());",
          "778:       return exit_code;",
          "779:     }",
          "783:   return HttpParserCode::Success;",
          "786: ConnectionImpl::HttpParserCode ConnectionImpl::onMessageBeginBase() {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "733:   processing_trailers_ = false;",
          "734:   header_parsing_state_ = HeaderParsingState::Field;",
          "735:   allocHeaders();",
          "737: }",
          "739: void ConnectionImpl::onResetStreamBase(StreamResetReason reason) {",
          "",
          "[Removed Lines]",
          "736:   onMessageBegin();",
          "",
          "[Added Lines]",
          "795:   return onMessageBegin();",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "773:   }",
          "774: }",
          "777:   HeaderString path(Headers::get().Path);",
          "779:   bool is_connect = (method == HTTP_CONNECT);",
          "",
          "[Removed Lines]",
          "776: void ServerConnectionImpl::handlePath(RequestHeaderMap& headers, unsigned int method) {",
          "",
          "[Added Lines]",
          "835: bool ServerConnectionImpl::handlePath(RequestHeaderMap& headers, unsigned int method) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "784:       (active_request.request_url_.getStringView()[0] == '/' ||",
          "785:        ((method == HTTP_OPTIONS) && active_request.request_url_.getStringView()[0] == '*'))) {",
          "786:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "788:   }",
          "",
          "[Removed Lines]",
          "787:     return;",
          "",
          "[Added Lines]",
          "846:     return true;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "794:   if (!codec_settings_.allow_absolute_url_ && !is_connect) {",
          "795:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "797:   }",
          "799:   Utility::Url absolute_url;",
          "800:   if (!absolute_url.initialize(active_request.request_url_.getStringView(), is_connect)) {",
          "801:     sendProtocolError(Http1ResponseCodeDetails::get().InvalidUrl);",
          "803:   }",
          "",
          "[Removed Lines]",
          "796:     return;",
          "802:     throw CodecProtocolException(\"http/1.1 protocol error: invalid url in request line\");",
          "",
          "[Added Lines]",
          "855:     return true;",
          "861:     ASSERT(codec_status_.ok());",
          "862:     codec_status_ = codecProtocolError(\"http/1.1 protocol error: invalid url in request line\");",
          "863:     return false;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "814:     headers.setPath(absolute_url.pathAndQueryParams());",
          "815:   }",
          "816:   active_request.request_url_.clear();",
          "817: }",
          "",
          "[Removed Lines]",
          "819: int ServerConnectionImpl::onHeadersComplete() {",
          "",
          "[Added Lines]",
          "878:   return true;",
          "881: ConnectionImpl::HttpParserCode ServerConnectionImpl::onHeadersComplete() {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "834:                        header_value);",
          "835:         error_code_ = Http::Code::BadRequest;",
          "836:         sendProtocolError(Http1ResponseCodeDetails::get().ConnectionHeaderSanitization);",
          "838:       }",
          "839:     }",
          "",
          "[Removed Lines]",
          "837:         throw CodecProtocolException(\"Invalid nominated headers in Connection.\");",
          "",
          "[Added Lines]",
          "899:         ASSERT(codec_status_.ok());",
          "900:         codec_status_ = codecProtocolError(\"Invalid nominated headers in Connection.\");",
          "901:         return HttpParserCode::Error;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "843:     active_request.response_encoder_.setIsResponseToHeadRequest(parser_.method == HTTP_HEAD);",
          "844:     active_request.response_encoder_.setIsResponseToConnectRequest(parser_.method == HTTP_CONNECT);",
          "847:     ASSERT(active_request.request_url_.empty());",
          "849:     headers->setMethod(method_string);",
          "",
          "[Removed Lines]",
          "846:     handlePath(*headers, parser_.method);",
          "",
          "[Added Lines]",
          "910:     if (!handlePath(*headers, parser_.method)) {",
          "912:       ASSERT(!codec_status_.ok());",
          "913:       return HttpParserCode::Error;",
          "914:     }",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "852:     auto details = HeaderUtility::requestHeadersValid(*headers);",
          "853:     if (details.has_value()) {",
          "854:       sendProtocolError(details.value().get());",
          "856:           \"http/1.1 protocol error: request headers failed spec compliance checks\");",
          "857:     }",
          "",
          "[Removed Lines]",
          "855:       throw CodecProtocolException(",
          "",
          "[Added Lines]",
          "923:       ASSERT(codec_status_.ok());",
          "924:       codec_status_ = codecProtocolError(",
          "926:       return HttpParserCode::Error;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "876:     }",
          "877:   }",
          "880: }",
          "883:   if (!resetStreamCalled()) {",
          "884:     ASSERT(!active_request_.has_value());",
          "885:     active_request_.emplace(*this, header_key_formatter_.get());",
          "886:     auto& active_request = active_request_.value();",
          "887:     active_request.request_decoder_ = &callbacks_.newStream(active_request.response_encoder_);",
          "893:   }",
          "894: }",
          "",
          "[Removed Lines]",
          "879:   return 0;",
          "882: void ServerConnectionImpl::onMessageBegin() {",
          "892:     doFloodProtectionChecks();",
          "",
          "[Added Lines]",
          "949:   return HttpParserCode::Success;",
          "952: ConnectionImpl::HttpParserCode ServerConnectionImpl::onMessageBegin() {",
          "957:     if (resetStreamCalled()) {",
          "958:       ASSERT(codec_status_.ok());",
          "959:       codec_status_ = codecClientError(\"cannot create new streams after calling reset\");",
          "960:       return HttpParserCode::Error;",
          "961:     }",
          "967:     return doFloodProtectionChecks();",
          "968:   } else {",
          "969:     return HttpParserCode::Success;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "979:   delete fragment;",
          "980: }",
          "983:   if (headers_with_underscores_action_ != envoy::config::core::v3::HttpProtocolOptions::ALLOW &&",
          "984:       Http::HeaderUtility::headerNameContainsUnderscore(current_header_field_.getStringView())) {",
          "985:     if (headers_with_underscores_action_ ==",
          "",
          "[Removed Lines]",
          "982: void ServerConnectionImpl::checkHeaderNameForUnderscores() {",
          "",
          "[Added Lines]",
          "1059: bool ServerConnectionImpl::checkHeaderNameForUnderscores() {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "995:       error_code_ = Http::Code::BadRequest;",
          "996:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters);",
          "997:       stats_.requests_rejected_with_underscores_in_headers_.inc();",
          "999:     }",
          "1000:   }",
          "1001: }",
          "1003: ClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, Stats::Scope& stats,",
          "",
          "[Removed Lines]",
          "998:       throw CodecProtocolException(\"http/1.1 protocol error: header name contains underscores\");",
          "",
          "[Added Lines]",
          "1075:       ASSERT(codec_status_.ok());",
          "1076:       codec_status_ =",
          "1077:           codecProtocolError(\"http/1.1 protocol error: header name contains underscores\");",
          "1078:       return false;",
          "1081:   return true;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1019: }",
          "1021: RequestEncoder& ClientConnectionImpl::newStream(ResponseDecoder& response_decoder) {",
          "1028:   ASSERT(connection_.readEnabled());",
          "",
          "[Removed Lines]",
          "1022:   if (resetStreamCalled()) {",
          "1023:     throw CodecClientException(\"cannot create new streams after calling reset\");",
          "1024:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1034:   return pending_response_.value().encoder_;",
          "1035: }",
          "1041:   if (!pending_response_.has_value() && !resetStreamCalled()) {",
          "1043:   } else if (pending_response_.has_value()) {",
          "1044:     ASSERT(!pending_response_done_);",
          "1045:     auto& headers = absl::get<ResponseHeaderMapPtr>(headers_or_trailers_);",
          "",
          "[Removed Lines]",
          "1037: int ClientConnectionImpl::onHeadersComplete() {",
          "1042:     throw PrematureResponseException(static_cast<Http::Code>(parser_.status_code));",
          "",
          "[Added Lines]",
          "1114: ConnectionImpl::HttpParserCode ClientConnectionImpl::onHeadersComplete() {",
          "1119:     ASSERT(codec_status_.ok());",
          "1120:     codec_status_ = prematureResponseError(\"\", static_cast<Http::Code>(parser_.status_code));",
          "1121:     return HttpParserCode::Error;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1074: }",
          "1076: bool ClientConnectionImpl::upgradeAllowed() const {",
          "",
          "[Removed Lines]",
          "1073:   return cannotHaveBody() ? 1 : 0;",
          "",
          "[Added Lines]",
          "1152:   return cannotHaveBody() ? HttpParserCode::NoBody : HttpParserCode::Success;",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h": [
          "File: source/common/http/http1/codec_impl.h -> source/common/http/http1/codec_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:   void onUnderlyingConnectionAboveWriteBufferHighWatermark() override { onAboveHighWatermark(); }",
          "229:   void onUnderlyingConnectionBelowWriteBufferLowWatermark() override { onBelowLowWatermark(); }",
          "231: protected:",
          "232:   ConnectionImpl(Network::Connection& connection, Stats::Scope& stats, http_parser_type type,",
          "233:                  uint32_t max_headers_kb, const uint32_t max_headers_count,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:   Envoy::Http::Status codec_status_;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "236:   bool resetStreamCalled() { return reset_stream_called_; }",
          "238:   Network::Connection& connection_;",
          "239:   CodecStats stats_;",
          "240:   http_parser parser_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246:   enum class HttpParserCode {",
          "250:     Error = -1,",
          "251:     Success = 0,",
          "254:     NoBody = 1,",
          "257:     NoBodyData = 2,",
          "258:   };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "253:   const bool connection_header_sanitization_ : 1;",
          "254:   const bool enable_trailers_ : 1;",
          "255:   const bool reject_unsupported_transfer_encodings_ : 1;",
          "257: private:",
          "258:   enum class HeaderParsingState { Field, Value, Done };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "278:   bool dispatching_ : 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "268:   void completeLastHeader();",
          "",
          "[Added Lines]",
          "292:   HttpParserCode completeLastHeader();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "296:   size_t dispatchSlice(const char* slice, size_t len);",
          "",
          "[Added Lines]",
          "320:   Envoy::StatusOr<size_t> dispatchSlice(const char* slice, size_t len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "314:   void onMessageBeginBase();",
          "315:   virtual void onMessageBegin() PURE;",
          "",
          "[Added Lines]",
          "339:   HttpParserCode onMessageBeginBase();",
          "340:   virtual HttpParserCode onMessageBegin() PURE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "329:   void onHeaderField(const char* data, size_t length);",
          "336:   void onHeaderValue(const char* data, size_t length);",
          "",
          "[Added Lines]",
          "355:   HttpParserCode onHeaderField(const char* data, size_t length);",
          "363:   HttpParserCode onHeaderValue(const char* data, size_t length);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "344:   int onHeadersCompleteBase();",
          "345:   virtual int onHeadersComplete() PURE;",
          "",
          "[Added Lines]",
          "371:   HttpParserCode onHeadersCompleteBase();",
          "372:   virtual HttpParserCode onHeadersComplete() PURE;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "368:   virtual void onMessageComplete() PURE;",
          "",
          "[Removed Lines]",
          "367:   void onMessageCompleteBase();",
          "",
          "[Added Lines]",
          "395:   HttpParserCode onMessageCompleteBase();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "403:   static http_parser_settings settings_;",
          "",
          "[Removed Lines]",
          "401:   virtual void checkHeaderNameForUnderscores() {}",
          "",
          "[Added Lines]",
          "430:   virtual bool checkHeaderNameForUnderscores() { return true; }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "457:   void onEncodeComplete() override;",
          "459:   void onUrl(const char* data, size_t length) override;",
          "462:   bool upgradeAllowed() const override { return true; }",
          "463:   void onBody(Buffer::Instance& data) override;",
          "",
          "[Removed Lines]",
          "454:   void handlePath(RequestHeaderMap& headers, unsigned int method);",
          "458:   void onMessageBegin() override;",
          "460:   int onHeadersComplete() override;",
          "",
          "[Added Lines]",
          "484:   bool handlePath(RequestHeaderMap& headers, unsigned int method);",
          "488:   HttpParserCode onMessageBegin() override;",
          "490:   HttpParserCode onHeadersComplete() override;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "489:   void releaseOutboundResponse(const Buffer::OwnedBufferFragmentImpl* fragment);",
          "490:   void maybeAddSentinelBufferFragment(Buffer::WatermarkBuffer& output_buffer) override;",
          "494:   ServerConnectionCallbacks& callbacks_;",
          "495:   absl::optional<ActiveRequest> active_request_;",
          "",
          "[Removed Lines]",
          "491:   void doFloodProtectionChecks() const;",
          "492:   void checkHeaderNameForUnderscores() override;",
          "",
          "[Added Lines]",
          "521:   HttpParserCode doFloodProtectionChecks();",
          "522:   bool checkHeaderNameForUnderscores() override;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "540:   void onEncodeComplete() override {}",
          "542:   void onUrl(const char*, size_t) override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }",
          "544:   bool upgradeAllowed() const override;",
          "545:   void onBody(Buffer::Instance& data) override;",
          "546:   void onMessageComplete() override;",
          "",
          "[Removed Lines]",
          "541:   void onMessageBegin() override {}",
          "543:   int onHeadersComplete() override;",
          "",
          "[Added Lines]",
          "571:   HttpParserCode onMessageBegin() override { return HttpParserCode::Success; }",
          "573:   HttpParserCode onHeadersComplete() override;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5083a9a4bf84edf172ca76f531acd27e58522314",
      "candidate_info": {
        "commit_hash": "5083a9a4bf84edf172ca76f531acd27e58522314",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/5083a9a4bf84edf172ca76f531acd27e58522314",
        "files": [
          "source/common/http/http1/BUILD",
          "source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h"
        ],
        "message": "Revert \"[http] Remove exceptions from HTTP/1 codec callbacks (#11101)\" (#11194)\n\nThis reverts commit 3550a7a7b0b858f4c2ac505efa6c71c2610f2666.\n\nSigned-off-by: Asra Ali <asraa@google.com>",
        "before_after_code_files": [
          "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ],
          "candidate": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
          "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"envoy/http/header_map.h\"",
          "10: #include \"envoy/network/connection.h\"",
          "13: #include \"common/common/enum_to_int.h\"",
          "14: #include \"common/common/utility.h\"",
          "15: #include \"common/http/exception.h\"",
          "",
          "[Removed Lines]",
          "12: #include \"common/common/cleanup.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "267:   outbound_responses_++;",
          "268: }",
          "272:   if (!flood_protection_) {",
          "274:   }",
          "",
          "[Removed Lines]",
          "270: ConnectionImpl::HttpParserCode ServerConnectionImpl::doFloodProtectionChecks() {",
          "271:   ASSERT(dispatching_);",
          "273:     return HttpParserCode::Success;",
          "",
          "[Added Lines]",
          "269: void ServerConnectionImpl::doFloodProtectionChecks() const {",
          "271:     return;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "278:     ENVOY_CONN_LOG(trace, \"error accepting request: too many pending responses queued\",",
          "279:                    connection_);",
          "280:     stats_.response_flood_.inc();",
          "284:   }",
          "286: }",
          "288: void ConnectionImpl::flushOutput(bool end_encode) {",
          "",
          "[Removed Lines]",
          "281:     ASSERT(codec_status_.ok());",
          "282:     codec_status_ = Http::bufferFloodError(\"Too many responses queued.\");",
          "283:     return HttpParserCode::Error;",
          "285:   return HttpParserCode::Success;",
          "",
          "[Added Lines]",
          "279:     throw FrameFloodException(\"Too many responses queued.\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "407: http_parser_settings ConnectionImpl::settings_{",
          "408:     [](http_parser* parser) -> int {",
          "410:     },",
          "411:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "412:       static_cast<ConnectionImpl*>(parser->data)->onUrl(at, length);",
          "",
          "[Removed Lines]",
          "409:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onMessageBeginBase());",
          "",
          "[Added Lines]",
          "404:       static_cast<ConnectionImpl*>(parser->data)->onMessageBeginBase();",
          "405:       return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "414:     },",
          "415:     nullptr, // on_status",
          "416:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "418:     },",
          "419:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "421:     },",
          "422:     [](http_parser* parser) -> int {",
          "424:     },",
          "425:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "426:       static_cast<ConnectionImpl*>(parser->data)->bufferBody(at, length);",
          "427:       return 0;",
          "428:     },",
          "429:     [](http_parser* parser) -> int {",
          "431:     },",
          "432:     [](http_parser* parser) -> int {",
          "",
          "[Removed Lines]",
          "417:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onHeaderField(at, length));",
          "420:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onHeaderValue(at, length));",
          "423:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onHeadersCompleteBase());",
          "430:       return enumToInt(static_cast<ConnectionImpl*>(parser->data)->onMessageCompleteBase());",
          "",
          "[Added Lines]",
          "413:       static_cast<ConnectionImpl*>(parser->data)->onHeaderField(at, length);",
          "414:       return 0;",
          "417:       static_cast<ConnectionImpl*>(parser->data)->onHeaderValue(at, length);",
          "418:       return 0;",
          "421:       return static_cast<ConnectionImpl*>(parser->data)->onHeadersCompleteBase();",
          "428:       static_cast<ConnectionImpl*>(parser->data)->onMessageCompleteBase();",
          "429:       return 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "455:       enable_trailers_(enable_trailers),",
          "456:       reject_unsupported_transfer_encodings_(Runtime::runtimeFeatureEnabled(",
          "457:           \"envoy.reloadable_features.reject_unsupported_transfer_encodings\")),",
          "460:       max_headers_kb_(max_headers_kb), max_headers_count_(max_headers_count) {",
          "461:   output_buffer_.setWatermarks(connection.bufferLimit());",
          "462:   http_parser_init(&parser_, type);",
          "463:   parser_.data = this;",
          "464: }",
          "468:   ENVOY_CONN_LOG(trace, \"completed header: key={} value={}\", connection_,",
          "469:                  current_header_field_.getStringView(), current_header_value_.getStringView());",
          "475:   auto& headers_or_trailers = headersOrTrailers();",
          "476:   if (!current_header_field_.empty()) {",
          "477:     current_header_field_.inlineTransform([](char c) { return absl::ascii_tolower(c); });",
          "",
          "[Removed Lines]",
          "458:       dispatching_(false), output_buffer_([&]() -> void { this->onBelowLowWatermark(); },",
          "459:                                           [&]() -> void { this->onAboveHighWatermark(); }),",
          "466: ConnectionImpl::HttpParserCode ConnectionImpl::completeLastHeader() {",
          "467:   ASSERT(dispatching_);",
          "471:   if (!checkHeaderNameForUnderscores()) {",
          "473:     return HttpParserCode::Error;",
          "474:   }",
          "",
          "[Added Lines]",
          "457:       output_buffer_([&]() -> void { this->onBelowLowWatermark(); },",
          "458:                      [&]() -> void { this->onAboveHighWatermark(); }),",
          "465: void ConnectionImpl::completeLastHeader() {",
          "469:   checkHeaderNameForUnderscores();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "489:     sendProtocolError(Http1ResponseCodeDetails::get().TooManyHeaders);",
          "490:     const absl::string_view header_type =",
          "491:         processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "495:   }",
          "497:   header_parsing_state_ = HeaderParsingState::Field;",
          "498:   ASSERT(current_header_field_.empty());",
          "499:   ASSERT(current_header_value_.empty());",
          "501: }",
          "503: bool ConnectionImpl::maybeDirectDispatch(Buffer::Instance& data) {",
          "",
          "[Removed Lines]",
          "492:     ASSERT(codec_status_.ok());",
          "493:     codec_status_ = codecProtocolError(absl::StrCat(header_type, \" size exceeds limit\"));",
          "494:     return HttpParserCode::Error;",
          "500:   return HttpParserCode::Success;",
          "",
          "[Added Lines]",
          "487:     throw CodecProtocolException(absl::StrCat(header_type, \" size exceeds limit\"));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "523: Http::Status ConnectionImpl::innerDispatch(Buffer::Instance& data) {",
          "524:   ENVOY_CONN_LOG(trace, \"parsing {} bytes\", connection_, data.length());",
          "529:   ASSERT(buffered_body_.length() == 0);",
          "532:   if (maybeDirectDispatch(data)) {",
          "533:     return Http::okStatus();",
          "534:   }",
          "",
          "[Removed Lines]",
          "527:   Cleanup cleanup([this]() { dispatching_ = false; });",
          "528:   ASSERT(!dispatching_);",
          "531:   dispatching_ = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "539:   ssize_t total_parsed = 0;",
          "540:   if (data.length() > 0) {",
          "541:     for (const Buffer::RawSlice& slice : data.getRawSlices()) {",
          "547:       if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK) {",
          "",
          "[Removed Lines]",
          "542:       auto statusor_parsed = dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);",
          "543:       if (!statusor_parsed.ok()) {",
          "544:         return statusor_parsed.status();",
          "545:       }",
          "546:       total_parsed += statusor_parsed.value();",
          "",
          "[Added Lines]",
          "529:       total_parsed += dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "553:     }",
          "554:     dispatchBufferedBody();",
          "555:   } else {",
          "560:   }",
          "561:   ASSERT(buffered_body_.length() == 0);",
          "",
          "[Removed Lines]",
          "556:     auto result = dispatchSlice(nullptr, 0);",
          "557:     if (!result.ok()) {",
          "558:       return result.status();",
          "559:     }",
          "",
          "[Added Lines]",
          "539:     dispatchSlice(nullptr, 0);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "569:   return Http::okStatus();",
          "570: }",
          "574:   ssize_t rc = http_parser_execute(&parser_, &settings_, slice, len);",
          "578:   if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK && HTTP_PARSER_ERRNO(&parser_) != HPE_PAUSED) {",
          "579:     sendProtocolError(Http1ResponseCodeDetails::get().HttpCodecError);",
          "585:   }",
          "587:   return rc;",
          "588: }",
          "594:   if (header_parsing_state_ == HeaderParsingState::Done) {",
          "595:     if (!enable_trailers_) {",
          "598:     }",
          "599:     processing_trailers_ = true;",
          "600:     header_parsing_state_ = HeaderParsingState::Field;",
          "601:   }",
          "602:   if (header_parsing_state_ == HeaderParsingState::Value) {",
          "609:   }",
          "611:   current_header_field_.append(data, length);",
          "613: }",
          "617:   if (header_parsing_state_ == HeaderParsingState::Done && !enable_trailers_) {",
          "620:   }",
          "622:   if (processing_trailers_) {",
          "",
          "[Removed Lines]",
          "572: Envoy::StatusOr<size_t> ConnectionImpl::dispatchSlice(const char* slice, size_t len) {",
          "573:   ASSERT(codec_status_.ok() && dispatching_);",
          "575:   if (!codec_status_.ok()) {",
          "576:     return codec_status_;",
          "577:   }",
          "581:     ASSERT(codec_status_.ok());",
          "582:     codec_status_ = codecProtocolError(",
          "583:         absl::StrCat(\"http/1.1 protocol error: \", http_errno_name(HTTP_PARSER_ERRNO(&parser_))));",
          "584:     return codec_status_;",
          "590: ConnectionImpl::HttpParserCode ConnectionImpl::onHeaderField(const char* data, size_t length) {",
          "591:   ASSERT(dispatching_);",
          "597:       return HttpParserCode::Success;",
          "603:     HttpParserCode exit_code = completeLastHeader();",
          "604:     if (exit_code == HttpParserCode::Error) {",
          "606:       ASSERT(!codec_status_.ok());",
          "607:       return HttpParserCode::Error;",
          "608:     }",
          "612:   return HttpParserCode::Success;",
          "615: ConnectionImpl::HttpParserCode ConnectionImpl::onHeaderValue(const char* data, size_t length) {",
          "616:   ASSERT(dispatching_);",
          "619:     return HttpParserCode::Success;",
          "",
          "[Added Lines]",
          "552: size_t ConnectionImpl::dispatchSlice(const char* slice, size_t len) {",
          "556:     throw CodecProtocolException(\"http/1.1 protocol error: \" +",
          "557:                                  std::string(http_errno_name(HTTP_PARSER_ERRNO(&parser_))));",
          "563: void ConnectionImpl::onHeaderField(const char* data, size_t length) {",
          "569:       return;",
          "575:     completeLastHeader();",
          "581: void ConnectionImpl::onHeaderValue(const char* data, size_t length) {",
          "584:     return;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "630:       ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);",
          "631:       error_code_ = Http::Code::BadRequest;",
          "632:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters);",
          "637:     }",
          "638:   }",
          "",
          "[Removed Lines]",
          "633:       ASSERT(codec_status_.ok());",
          "634:       codec_status_ =",
          "635:           codecProtocolError(\"http/1.1 protocol error: header value contains invalid chars\");",
          "636:       return HttpParserCode::Error;",
          "",
          "[Added Lines]",
          "598:       throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "654:         processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "655:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
          "656:     sendProtocolError(Http1ResponseCodeDetails::get().HeadersTooLarge);",
          "660:   }",
          "662: }",
          "665:   ASSERT(!processing_trailers_);",
          "667:   ENVOY_CONN_LOG(trace, \"onHeadersCompleteBase\", connection_);",
          "675:   if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {",
          "",
          "[Removed Lines]",
          "657:     ASSERT(codec_status_.ok());",
          "658:     codec_status_ = codecProtocolError(absl::StrCat(header_type, \" size exceeds limit\"));",
          "659:     return HttpParserCode::Error;",
          "661:   return HttpParserCode::Success;",
          "664: ConnectionImpl::HttpParserCode ConnectionImpl::onHeadersCompleteBase() {",
          "666:   ASSERT(dispatching_);",
          "668:   HttpParserCode exit_code = completeLastHeader();",
          "669:   if (exit_code == HttpParserCode::Error) {",
          "671:     ASSERT(!codec_status_.ok());",
          "672:     return exit_code;",
          "673:   }",
          "",
          "[Added Lines]",
          "619:     throw CodecProtocolException(absl::StrCat(header_type, \" size exceeds limit\"));",
          "623: int ConnectionImpl::onHeadersCompleteBase() {",
          "626:   completeLastHeader();",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "717:         !absl::EqualsIgnoreCase(encoding, Headers::get().TransferEncodingValues.Chunked)) {",
          "718:       error_code_ = Http::Code::NotImplemented;",
          "719:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidTransferEncoding);",
          "723:     }",
          "724:   }",
          "730:   header_parsing_state_ = HeaderParsingState::Done;",
          "734: }",
          "736: void ConnectionImpl::bufferBody(const char* data, size_t length) {",
          "",
          "[Removed Lines]",
          "720:       ASSERT(codec_status_.ok());",
          "721:       codec_status_ = codecProtocolError(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "722:       return HttpParserCode::Error;",
          "726:   HttpParserCode rc = onHeadersComplete();",
          "727:   if (rc == HttpParserCode::Error) {",
          "728:     return rc;",
          "729:   }",
          "733:   return handling_upgrade_ ? HttpParserCode::NoBodyData : rc;",
          "",
          "[Added Lines]",
          "673:       throw CodecProtocolException(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "677:   int rc = onHeadersComplete();",
          "681:   return handling_upgrade_ ? 2 : rc;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "740: void ConnectionImpl::dispatchBufferedBody() {",
          "741:   ASSERT(HTTP_PARSER_ERRNO(&parser_) == HPE_OK || HTTP_PARSER_ERRNO(&parser_) == HPE_PAUSED);",
          "743:   if (buffered_body_.length() > 0) {",
          "744:     onBody(buffered_body_);",
          "745:     buffered_body_.drain(buffered_body_.length());",
          "",
          "[Removed Lines]",
          "742:   ASSERT(codec_status_.ok());",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "754:   }",
          "755: }",
          "758:   ENVOY_CONN_LOG(trace, \"message complete\", connection_);",
          "760:   dispatchBufferedBody();",
          "",
          "[Removed Lines]",
          "757: ConnectionImpl::HttpParserCode ConnectionImpl::onMessageCompleteBase() {",
          "",
          "[Added Lines]",
          "704: void ConnectionImpl::onMessageCompleteBase() {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "765:     ASSERT(!deferred_end_stream_headers_);",
          "766:     ENVOY_CONN_LOG(trace, \"Pausing parser due to upgrade.\", connection_);",
          "767:     http_parser_pause(&parser_, 1);",
          "769:   }",
          "773:   if (header_parsing_state_ == HeaderParsingState::Value) {",
          "780:   }",
          "782:   onMessageComplete();",
          "784: }",
          "787:   ENVOY_CONN_LOG(trace, \"message begin\", connection_);",
          "",
          "[Removed Lines]",
          "768:     return HttpParserCode::Success;",
          "774:     HttpParserCode exit_code = completeLastHeader();",
          "775:     if (exit_code == HttpParserCode::Error) {",
          "777:       ASSERT(!codec_status_.ok());",
          "778:       return exit_code;",
          "779:     }",
          "783:   return HttpParserCode::Success;",
          "786: ConnectionImpl::HttpParserCode ConnectionImpl::onMessageBeginBase() {",
          "",
          "[Added Lines]",
          "715:     return;",
          "721:     completeLastHeader();",
          "727: void ConnectionImpl::onMessageBeginBase() {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "792:   processing_trailers_ = false;",
          "793:   header_parsing_state_ = HeaderParsingState::Field;",
          "794:   allocHeaders();",
          "796: }",
          "798: void ConnectionImpl::onResetStreamBase(StreamResetReason reason) {",
          "",
          "[Removed Lines]",
          "795:   return onMessageBegin();",
          "",
          "[Added Lines]",
          "736:   onMessageBegin();",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "832:   }",
          "833: }",
          "836:   HeaderString path(Headers::get().Path);",
          "838:   bool is_connect = (method == HTTP_CONNECT);",
          "",
          "[Removed Lines]",
          "835: bool ServerConnectionImpl::handlePath(RequestHeaderMap& headers, unsigned int method) {",
          "",
          "[Added Lines]",
          "776: void ServerConnectionImpl::handlePath(RequestHeaderMap& headers, unsigned int method) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "843:       (active_request.request_url_.getStringView()[0] == '/' ||",
          "844:        ((method == HTTP_OPTIONS) && active_request.request_url_.getStringView()[0] == '*'))) {",
          "845:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "847:   }",
          "",
          "[Removed Lines]",
          "846:     return true;",
          "",
          "[Added Lines]",
          "787:     return;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "853:   if (!codec_settings_.allow_absolute_url_ && !is_connect) {",
          "854:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "856:   }",
          "858:   Utility::Url absolute_url;",
          "859:   if (!absolute_url.initialize(active_request.request_url_.getStringView(), is_connect)) {",
          "860:     sendProtocolError(Http1ResponseCodeDetails::get().InvalidUrl);",
          "864:   }",
          "",
          "[Removed Lines]",
          "855:     return true;",
          "861:     ASSERT(codec_status_.ok());",
          "862:     codec_status_ = codecProtocolError(\"http/1.1 protocol error: invalid url in request line\");",
          "863:     return false;",
          "",
          "[Added Lines]",
          "796:     return;",
          "802:     throw CodecProtocolException(\"http/1.1 protocol error: invalid url in request line\");",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "875:     headers.setPath(absolute_url.pathAndQueryParams());",
          "876:   }",
          "877:   active_request.request_url_.clear();",
          "879: }",
          "",
          "[Removed Lines]",
          "878:   return true;",
          "881: ConnectionImpl::HttpParserCode ServerConnectionImpl::onHeadersComplete() {",
          "",
          "[Added Lines]",
          "819: int ServerConnectionImpl::onHeadersComplete() {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "896:                        header_value);",
          "897:         error_code_ = Http::Code::BadRequest;",
          "898:         sendProtocolError(Http1ResponseCodeDetails::get().ConnectionHeaderSanitization);",
          "902:       }",
          "903:     }",
          "",
          "[Removed Lines]",
          "899:         ASSERT(codec_status_.ok());",
          "900:         codec_status_ = codecProtocolError(\"Invalid nominated headers in Connection.\");",
          "901:         return HttpParserCode::Error;",
          "",
          "[Added Lines]",
          "837:         throw CodecProtocolException(\"Invalid nominated headers in Connection.\");",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "907:     active_request.response_encoder_.setIsResponseToHeadRequest(parser_.method == HTTP_HEAD);",
          "908:     active_request.response_encoder_.setIsResponseToConnectRequest(parser_.method == HTTP_CONNECT);",
          "915:     ASSERT(active_request.request_url_.empty());",
          "917:     headers->setMethod(method_string);",
          "",
          "[Removed Lines]",
          "910:     if (!handlePath(*headers, parser_.method)) {",
          "912:       ASSERT(!codec_status_.ok());",
          "913:       return HttpParserCode::Error;",
          "914:     }",
          "",
          "[Added Lines]",
          "846:     handlePath(*headers, parser_.method);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "920:     auto details = HeaderUtility::requestHeadersValid(*headers);",
          "921:     if (details.has_value()) {",
          "922:       sendProtocolError(details.value().get());",
          "925:           \"http/1.1 protocol error: request headers failed spec compliance checks\");",
          "927:     }",
          "",
          "[Removed Lines]",
          "923:       ASSERT(codec_status_.ok());",
          "924:       codec_status_ = codecProtocolError(",
          "926:       return HttpParserCode::Error;",
          "",
          "[Added Lines]",
          "855:       throw CodecProtocolException(",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "946:     }",
          "947:   }",
          "950: }",
          "953:   if (!resetStreamCalled()) {",
          "954:     ASSERT(!active_request_.has_value());",
          "955:     active_request_.emplace(*this, header_key_formatter_.get());",
          "956:     auto& active_request = active_request_.value();",
          "962:     active_request.request_decoder_ = &callbacks_.newStream(active_request.response_encoder_);",
          "970:   }",
          "971: }",
          "",
          "[Removed Lines]",
          "949:   return HttpParserCode::Success;",
          "952: ConnectionImpl::HttpParserCode ServerConnectionImpl::onMessageBegin() {",
          "957:     if (resetStreamCalled()) {",
          "958:       ASSERT(codec_status_.ok());",
          "959:       codec_status_ = codecClientError(\"cannot create new streams after calling reset\");",
          "960:       return HttpParserCode::Error;",
          "961:     }",
          "967:     return doFloodProtectionChecks();",
          "968:   } else {",
          "969:     return HttpParserCode::Success;",
          "",
          "[Added Lines]",
          "879:   return 0;",
          "882: void ServerConnectionImpl::onMessageBegin() {",
          "892:     doFloodProtectionChecks();",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1056:   delete fragment;",
          "1057: }",
          "1060:   if (headers_with_underscores_action_ != envoy::config::core::v3::HttpProtocolOptions::ALLOW &&",
          "1061:       Http::HeaderUtility::headerNameContainsUnderscore(current_header_field_.getStringView())) {",
          "1062:     if (headers_with_underscores_action_ ==",
          "",
          "[Removed Lines]",
          "1059: bool ServerConnectionImpl::checkHeaderNameForUnderscores() {",
          "",
          "[Added Lines]",
          "982: void ServerConnectionImpl::checkHeaderNameForUnderscores() {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1072:       error_code_ = Http::Code::BadRequest;",
          "1073:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters);",
          "1074:       stats_.requests_rejected_with_underscores_in_headers_.inc();",
          "1079:     }",
          "1080:   }",
          "1082: }",
          "1084: ClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, Stats::Scope& stats,",
          "",
          "[Removed Lines]",
          "1075:       ASSERT(codec_status_.ok());",
          "1076:       codec_status_ =",
          "1077:           codecProtocolError(\"http/1.1 protocol error: header name contains underscores\");",
          "1078:       return false;",
          "1081:   return true;",
          "",
          "[Added Lines]",
          "998:       throw CodecProtocolException(\"http/1.1 protocol error: header name contains underscores\");",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1100: }",
          "1102: RequestEncoder& ClientConnectionImpl::newStream(ResponseDecoder& response_decoder) {",
          "1105:   ASSERT(connection_.readEnabled());",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1022:   if (resetStreamCalled()) {",
          "1023:     throw CodecClientException(\"cannot create new streams after calling reset\");",
          "1024:   }",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1111:   return pending_response_.value().encoder_;",
          "1112: }",
          "1118:   if (!pending_response_.has_value() && !resetStreamCalled()) {",
          "1122:   } else if (pending_response_.has_value()) {",
          "1123:     ASSERT(!pending_response_done_);",
          "1124:     auto& headers = absl::get<ResponseHeaderMapPtr>(headers_or_trailers_);",
          "",
          "[Removed Lines]",
          "1114: ConnectionImpl::HttpParserCode ClientConnectionImpl::onHeadersComplete() {",
          "1119:     ASSERT(codec_status_.ok());",
          "1120:     codec_status_ = prematureResponseError(\"\", static_cast<Http::Code>(parser_.status_code));",
          "1121:     return HttpParserCode::Error;",
          "",
          "[Added Lines]",
          "1037: int ClientConnectionImpl::onHeadersComplete() {",
          "1042:     throw PrematureResponseException(static_cast<Http::Code>(parser_.status_code));",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1153: }",
          "1155: bool ClientConnectionImpl::upgradeAllowed() const {",
          "",
          "[Removed Lines]",
          "1152:   return cannotHaveBody() ? HttpParserCode::NoBody : HttpParserCode::Success;",
          "",
          "[Added Lines]",
          "1073:   return cannotHaveBody() ? 1 : 0;",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h": [
          "File: source/common/http/http1/codec_impl.h -> source/common/http/http1/codec_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:   void onUnderlyingConnectionAboveWriteBufferHighWatermark() override { onAboveHighWatermark(); }",
          "229:   void onUnderlyingConnectionBelowWriteBufferLowWatermark() override { onBelowLowWatermark(); }",
          "235: protected:",
          "236:   ConnectionImpl(Network::Connection& connection, Stats::Scope& stats, http_parser_type type,",
          "237:                  uint32_t max_headers_kb, const uint32_t max_headers_count,",
          "",
          "[Removed Lines]",
          "233:   Envoy::Http::Status codec_status_;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "240:   bool resetStreamCalled() { return reset_stream_called_; }",
          "260:   Network::Connection& connection_;",
          "261:   CodecStats stats_;",
          "262:   http_parser parser_;",
          "",
          "[Removed Lines]",
          "246:   enum class HttpParserCode {",
          "250:     Error = -1,",
          "251:     Success = 0,",
          "254:     NoBody = 1,",
          "257:     NoBodyData = 2,",
          "258:   };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "275:   const bool connection_header_sanitization_ : 1;",
          "276:   const bool enable_trailers_ : 1;",
          "277:   const bool reject_unsupported_transfer_encodings_ : 1;",
          "280: private:",
          "281:   enum class HeaderParsingState { Field, Value, Done };",
          "",
          "[Removed Lines]",
          "278:   bool dispatching_ : 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "292:   HttpParserCode completeLastHeader();",
          "",
          "[Added Lines]",
          "268:   void completeLastHeader();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "320:   Envoy::StatusOr<size_t> dispatchSlice(const char* slice, size_t len);",
          "",
          "[Added Lines]",
          "296:   size_t dispatchSlice(const char* slice, size_t len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "339:   HttpParserCode onMessageBeginBase();",
          "340:   virtual HttpParserCode onMessageBegin() PURE;",
          "",
          "[Added Lines]",
          "314:   void onMessageBeginBase();",
          "315:   virtual void onMessageBegin() PURE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "355:   HttpParserCode onHeaderField(const char* data, size_t length);",
          "363:   HttpParserCode onHeaderValue(const char* data, size_t length);",
          "",
          "[Added Lines]",
          "329:   void onHeaderField(const char* data, size_t length);",
          "336:   void onHeaderValue(const char* data, size_t length);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "371:   HttpParserCode onHeadersCompleteBase();",
          "372:   virtual HttpParserCode onHeadersComplete() PURE;",
          "",
          "[Added Lines]",
          "344:   int onHeadersCompleteBase();",
          "345:   virtual int onHeadersComplete() PURE;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "396:   virtual void onMessageComplete() PURE;",
          "",
          "[Removed Lines]",
          "395:   HttpParserCode onMessageCompleteBase();",
          "",
          "[Added Lines]",
          "367:   void onMessageCompleteBase();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "432:   static http_parser_settings settings_;",
          "",
          "[Removed Lines]",
          "430:   virtual bool checkHeaderNameForUnderscores() { return true; }",
          "",
          "[Added Lines]",
          "401:   virtual void checkHeaderNameForUnderscores() {}",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "487:   void onEncodeComplete() override;",
          "489:   void onUrl(const char* data, size_t length) override;",
          "492:   bool upgradeAllowed() const override { return true; }",
          "493:   void onBody(Buffer::Instance& data) override;",
          "",
          "[Removed Lines]",
          "484:   bool handlePath(RequestHeaderMap& headers, unsigned int method);",
          "488:   HttpParserCode onMessageBegin() override;",
          "490:   HttpParserCode onHeadersComplete() override;",
          "",
          "[Added Lines]",
          "454:   void handlePath(RequestHeaderMap& headers, unsigned int method);",
          "458:   void onMessageBegin() override;",
          "460:   int onHeadersComplete() override;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "519:   void releaseOutboundResponse(const Buffer::OwnedBufferFragmentImpl* fragment);",
          "520:   void maybeAddSentinelBufferFragment(Buffer::WatermarkBuffer& output_buffer) override;",
          "524:   ServerConnectionCallbacks& callbacks_;",
          "525:   absl::optional<ActiveRequest> active_request_;",
          "",
          "[Removed Lines]",
          "521:   HttpParserCode doFloodProtectionChecks();",
          "522:   bool checkHeaderNameForUnderscores() override;",
          "",
          "[Added Lines]",
          "491:   void doFloodProtectionChecks() const;",
          "492:   void checkHeaderNameForUnderscores() override;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "570:   void onEncodeComplete() override {}",
          "572:   void onUrl(const char*, size_t) override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }",
          "574:   bool upgradeAllowed() const override;",
          "575:   void onBody(Buffer::Instance& data) override;",
          "576:   void onMessageComplete() override;",
          "",
          "[Removed Lines]",
          "571:   HttpParserCode onMessageBegin() override { return HttpParserCode::Success; }",
          "573:   HttpParserCode onHeadersComplete() override;",
          "",
          "[Added Lines]",
          "541:   void onMessageBegin() override {}",
          "543:   int onHeadersComplete() override;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a5b8fa9867eccc202a507a87487ff0d3be35936",
      "candidate_info": {
        "commit_hash": "5a5b8fa9867eccc202a507a87487ff0d3be35936",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/5a5b8fa9867eccc202a507a87487ff0d3be35936",
        "files": [
          "test/common/http/BUILD",
          "test/common/http/header_map_impl_speed_test.cc"
        ],
        "message": "add a performance benchmark test for Http::HeaderMapImpl (#5667)\n\nSigned-off-by: Brian Pane <brianp+github@brianp.net>",
        "before_after_code_files": [
          "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc"
          ],
          "candidate": [
            "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc": [
          "File: test/common/http/header_map_impl_speed_test.cc -> test/common/http/header_map_impl_speed_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"common/http/header_map_impl.h\"",
          "3: #include \"testing/base/public/benchmark.h\"",
          "5: namespace Envoy {",
          "6: namespace Http {",
          "12: static void addDummyHeaders(HeaderMap& headers, size_t num_headers) {",
          "13:   const std::string prefix(\"dummy-key-\");",
          "14:   for (size_t i = 0; i < num_headers; i++) {",
          "15:     headers.addCopy(LowerCaseString(prefix + std::to_string(i)), \"abcd\");",
          "16:   }",
          "17: }",
          "20: static void HeaderMapImplCreate(benchmark::State& state) {",
          "21:   for (auto _ : state) {",
          "22:     HeaderMapImpl headers;",
          "23:     benchmark::DoNotOptimize(headers.size());",
          "24:   }",
          "25: }",
          "26: BENCHMARK(HeaderMapImplCreate);",
          "35: static void HeaderMapImplSetReference(benchmark::State& state) {",
          "36:   const LowerCaseString key(\"example-key\");",
          "37:   const std::string value(\"01234567890123456789\");",
          "38:   HeaderMapImpl headers;",
          "39:   addDummyHeaders(headers, state.range(0));",
          "40:   for (auto _ : state) {",
          "41:     headers.setReference(key, value);",
          "42:   }",
          "43:   benchmark::DoNotOptimize(headers.size());",
          "44: }",
          "45: BENCHMARK(HeaderMapImplSetReference)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "55: static void HeaderMapImplGet(benchmark::State& state) {",
          "56:   const LowerCaseString key(\"example-key\");",
          "57:   const std::string value(\"01234567890123456789\");",
          "58:   HeaderMapImpl headers;",
          "59:   addDummyHeaders(headers, state.range(0));",
          "60:   headers.setReference(key, value);",
          "61:   size_t successes = 0;",
          "62:   for (auto _ : state) {",
          "63:     successes += (headers.get(key) != nullptr);",
          "64:   }",
          "65:   benchmark::DoNotOptimize(successes);",
          "66: }",
          "67: BENCHMARK(HeaderMapImplGet)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "73: static void HeaderMapImplGetInline(benchmark::State& state) {",
          "74:   const std::string value(\"01234567890123456789\");",
          "75:   HeaderMapImpl headers;",
          "76:   addDummyHeaders(headers, state.range(0));",
          "77:   headers.insertConnection().value().setReference(value);",
          "78:   size_t size = 0;",
          "79:   for (auto _ : state) {",
          "80:     size += headers.Connection()->value().size();",
          "81:   }",
          "82:   benchmark::DoNotOptimize(size);",
          "83: }",
          "84: BENCHMARK(HeaderMapImplGetInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "90: static void HeaderMapImplSetInline(benchmark::State& state) {",
          "91:   const std::string value(\"01234567890123456789\");",
          "92:   HeaderMapImpl headers;",
          "93:   addDummyHeaders(headers, state.range(0));",
          "94:   for (auto _ : state) {",
          "95:     headers.insertConnection().value().setReference(value);",
          "96:   }",
          "97:   benchmark::DoNotOptimize(headers.size());",
          "98: }",
          "99: BENCHMARK(HeaderMapImplSetInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "102: static void HeaderMapImplGetByteSize(benchmark::State& state) {",
          "103:   HeaderMapImpl headers;",
          "104:   addDummyHeaders(headers, state.range(0));",
          "105:   uint64_t size = 0;",
          "106:   for (auto _ : state) {",
          "107:     size += headers.byteSize();",
          "108:   }",
          "109:   benchmark::DoNotOptimize(size);",
          "110: }",
          "111: BENCHMARK(HeaderMapImplGetByteSize)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "114: static void HeaderMapImplIterate(benchmark::State& state) {",
          "115:   HeaderMapImpl headers;",
          "116:   size_t num_callbacks = 0;",
          "117:   addDummyHeaders(headers, state.range(0));",
          "118:   auto counting_callback = [](const HeaderEntry&, void* context) -> HeaderMap::Iterate {",
          "119:     (*static_cast<size_t*>(context))++;",
          "120:     return HeaderMap::Iterate::Continue;",
          "121:   };",
          "122:   for (auto _ : state) {",
          "123:     headers.iterate(counting_callback, &num_callbacks);",
          "124:   }",
          "125:   benchmark::DoNotOptimize(num_callbacks);",
          "126: }",
          "127: BENCHMARK(HeaderMapImplIterate)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "130: static void HeaderMapImplLookup(benchmark::State& state) {",
          "131:   const LowerCaseString key(\"connection\");",
          "132:   const std::string value(\"01234567890123456789\");",
          "133:   HeaderMapImpl headers;",
          "134:   addDummyHeaders(headers, state.range(0));",
          "135:   headers.addReference(key, value);",
          "136:   for (auto _ : state) {",
          "137:     const HeaderEntry* entry = nullptr;",
          "138:     auto result = headers.lookup(key, &entry);",
          "139:     benchmark::DoNotOptimize(result);",
          "140:   }",
          "141: }",
          "142: BENCHMARK(HeaderMapImplLookup)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "149: static void HeaderMapImplRemove(benchmark::State& state) {",
          "150:   const LowerCaseString key(\"example-key\");",
          "151:   const std::string value(\"01234567890123456789\");",
          "152:   HeaderMapImpl headers;",
          "153:   addDummyHeaders(headers, state.range(0));",
          "154:   for (auto _ : state) {",
          "155:     headers.addReference(key, value);",
          "156:     headers.remove(key);",
          "157:   }",
          "158:   benchmark::DoNotOptimize(headers.size());",
          "159: }",
          "160: BENCHMARK(HeaderMapImplRemove)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "168: static void HeaderMapImplRemoveInline(benchmark::State& state) {",
          "169:   const LowerCaseString key(\"connection\");",
          "170:   const std::string value(\"01234567890123456789\");",
          "171:   HeaderMapImpl headers;",
          "172:   addDummyHeaders(headers, state.range(0));",
          "173:   for (auto _ : state) {",
          "174:     headers.addReference(key, value);",
          "175:     headers.remove(key);",
          "176:   }",
          "177:   benchmark::DoNotOptimize(headers.size());",
          "178: }",
          "179: BENCHMARK(HeaderMapImplRemoveInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);",
          "185: static void HeaderMapImplPopulate(benchmark::State& state) {",
          "186:   const std::pair<LowerCaseString, std::string> headers_to_add[] = {",
          "187:       {LowerCaseString(\"cache-control\"), \"max-age=0, private, must-revalidate\"},",
          "188:       {LowerCaseString(\"content-encoding\"), \"gzip\"},",
          "189:       {LowerCaseString(\"content-type\"), \"text/html; charset=utf-8\"},",
          "190:       {LowerCaseString(\"date\"), \"Wed, 23 Jan 2019 04:00:00 GMT\"},",
          "191:       {LowerCaseString(\"server\"), \"envoy\"},",
          "192:       {LowerCaseString(\"x-custom-header-1\"), \"example 1\"},",
          "193:       {LowerCaseString(\"x-custom-header-2\"), \"example 2\"},",
          "194:       {LowerCaseString(\"x-custom-header-3\"), \"example 3\"},",
          "195:       {LowerCaseString(\"set-cookie\"), \"_cookie1=12345678; path = /; secure\"},",
          "196:       {LowerCaseString(\"set-cookie\"), \"_cookie2=12345678; path = /; secure\"},",
          "197:   };",
          "198:   for (auto _ : state) {",
          "199:     HeaderMapImpl headers;",
          "200:     for (const auto& key_value : headers_to_add) {",
          "201:       headers.addReference(key_value.first, key_value.second);",
          "202:     }",
          "203:     benchmark::DoNotOptimize(headers.size());",
          "204:   }",
          "205: }",
          "206: BENCHMARK(HeaderMapImplPopulate);",
          "208: } // namespace Http",
          "209: } // namespace Envoy",
          "212: int main(int argc, char** argv) {",
          "213:   benchmark::Initialize(&argc, argv);",
          "215:   if (benchmark::ReportUnrecognizedArguments(argc, argv)) {",
          "216:     return 1;",
          "217:   }",
          "218:   benchmark::RunSpecifiedBenchmarks();",
          "219: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-10030",
  "cve_desc": "The _prolog_error function in slurmd/req.c in Slurm before 15.08.13, 16.x before 16.05.7, and 17.x before 17.02.0-pre4 has a vulnerability in how the slurmd daemon informs users of a Prolog failure on a compute node. That vulnerability could allow a user to assume control of an arbitrary file on the system. Any exploitation of this is dependent on the user being able to cause or anticipate the failure (non-zero return code) of a Prolog script that their job would run on. This issue affects all Slurm versions from 0.6.0 (September 2005) to present. Workarounds to prevent exploitation of this are to either disable your Prolog script, or modify it such that it always returns 0 (\"success\") and adjust it to set the node as down using scontrol instead of relying on the slurmd to handle that automatically. If you do not have a Prolog set you are unaffected by this issue.",
  "repo": "SchedMD/slurm",
  "patch_hash": "92362a92fffe60187df61f99ab11c249d44120ee",
  "patch_info": {
    "commit_hash": "92362a92fffe60187df61f99ab11c249d44120ee",
    "repo": "SchedMD/slurm",
    "commit_url": "https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee",
    "files": [
      "NEWS",
      "src/slurmd/slurmd/req.c"
    ],
    "message": "Fix security issue in _prolog_error().\n\nFix security issue caused by insecure file path handling triggered by\nthe failure of a Prolog script. To exploit this a user needs to\nanticipate or cause the Prolog to fail for their job.\n\n(This commit is slightly different from the fix to the 15.08 branch.)\n\nCVE-2016-10030.",
    "before_after_code_files": [
      "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
    ]
  },
  "patch_diff": {
    "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c": [
      "File: src/slurmd/slurmd/req.c -> src/slurmd/slurmd/req.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "168: static int  _prolog_is_running (uint32_t jobid);",
      "169: static int  _step_limits_match(void *x, void *key);",
      "170: static int  _terminate_all_steps(uint32_t jobid, bool batch);",
      "171: static void _rpc_launch_tasks(slurm_msg_t *);",
      "172: static void _rpc_abort_job(slurm_msg_t *);",
      "173: static void _rpc_batch_job(slurm_msg_t *msg, bool new_msg);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "171: static int  _receive_fd(int socket);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "214: static int  _waiter_init (uint32_t jobid);",
      "215: static int  _waiter_complete (uint32_t jobid);",
      "217: static bool _steps_completed_now(uint32_t jobid);",
      "218: static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,",
      "219:           uint16_t block_no, uint32_t *job_id);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "218: static void _send_back_fd(int socket, int fd);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1383:   send_registration_msg(errnum, false);",
      "1384: }",
      "1386: static void",
      "1387: _prolog_error(batch_job_launch_msg_t *req, int rc)",
      "1388: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1395: static int _open_as_other(char *path_name, batch_job_launch_msg_t *req)",
      "1396: {",
      "1397:  pid_t child;",
      "1398:  gids_t *gids;",
      "1399:  int pipe[2];",
      "1400:  int fd = -1, rc = 0;",
      "1402:  if (!(gids = _gids_cache_lookup(req->user_name, req->gid))) {",
      "1403:   error(\"%s: gids_cache_lookup for %s failed\",",
      "1404:         __func__, req->user_name);",
      "1405:   return -1;",
      "1406:  }",
      "1408:  if ((rc = container_g_create(req->job_id))) {",
      "1409:   error(\"%s: container_g_create(%u): %m\", __func__, req->job_id);",
      "1410:   _dealloc_gids(gids);",
      "1411:   return -1;",
      "1412:  }",
      "1416:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {",
      "1417:   error(\"%s: Failed to open pipe: %m\", __func__);",
      "1418:   _dealloc_gids(gids);",
      "1419:   return -1;",
      "1420:  }",
      "1422:  child = fork();",
      "1423:  if (child == -1) {",
      "1424:   error(\"%s: fork failure\", __func__);",
      "1425:   _dealloc_gids(gids);",
      "1426:   close(pipe[0]);",
      "1427:   close(pipe[1]);",
      "1428:   return -1;",
      "1429:  } else if (child > 0) {",
      "1430:   close(pipe[0]);",
      "1431:   (void) waitpid(child, &rc, 0);",
      "1432:   _dealloc_gids(gids);",
      "1433:   if (WIFEXITED(rc) && (WEXITSTATUS(rc) == 0))",
      "1434:    fd = _receive_fd(pipe[1]);",
      "1435:   close(pipe[1]);",
      "1436:   return fd;",
      "1437:  }",
      "1441:  close(pipe[1]);",
      "1448:  if (container_g_add_pid(req->job_id, getpid(), req->uid)) {",
      "1449:   error(\"%s container_g_add_pid(%u): %m\", __func__, req->job_id);",
      "1450:   exit(SLURM_ERROR);",
      "1451:  }",
      "1467:  if (setgroups(gids->ngids, gids->gids) < 0) {",
      "1468:   error(\"%s: uid: %u setgroups failed: %m\", __func__, req->uid);",
      "1469:   exit(errno);",
      "1470:  }",
      "1471:  _dealloc_gids(gids);",
      "1473:  if (setgid(req->gid) < 0) {",
      "1474:   error(\"%s: uid:%u setgid(%u): %m\", __func__, req->uid,req->gid);",
      "1475:   exit(errno);",
      "1476:  }",
      "1477:  if (setuid(req->uid) < 0) {",
      "1478:   error(\"%s: getuid(%u): %m\", __func__, req->uid);",
      "1479:   exit(errno);",
      "1480:  }",
      "1482:  fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644);",
      "1483:  if (fd == -1) {",
      "1484:   error(\"%s: uid:%u can't open `%s`: %m\",",
      "1485:         __func__, req->uid, path_name);",
      "1486:   exit(errno);",
      "1487:  }",
      "1488:  _send_back_fd(pipe[0], fd);",
      "1489:  close(fd);",
      "1490:  exit(SLURM_SUCCESS);",
      "1491: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1415:    req->work_dir, err_name_ptr);",
      "1416:  else",
      "1417:   snprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);",
      "1422:   return;",
      "1423:  }",
      "1424:  snprintf(err_name, sizeof(err_name),",
      "",
      "[Removed Lines]",
      "1419:  if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {",
      "1420:   error(\"Unable to open %s: %s\", path_name,",
      "1421:         slurm_strerror(errno));",
      "",
      "[Added Lines]",
      "1525:  if ((fd = _open_as_other(path_name, req)) == -1) {",
      "1526:   error(\"Unable to open %s: Permission denied\", path_name);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dcb84d0c753863801c04415361c3b58566871b35",
      "candidate_info": {
        "commit_hash": "dcb84d0c753863801c04415361c3b58566871b35",
        "repo": "SchedMD/slurm",
        "commit_url": "https://github.com/SchedMD/slurm/commit/dcb84d0c753863801c04415361c3b58566871b35",
        "files": [
          "src/slurmd/slurmd/req.c"
        ],
        "message": "Refactor a little bit now that gids will already be set, and the job-specific cache is no more.",
        "before_after_code_files": [
          "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
          ],
          "candidate": [
            "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
          ]
        }
      },
      "candidate_diff": {
        "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c": [
          "File: src/slurmd/slurmd/req.c -> src/slurmd/slurmd/req.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1531: static int _open_as_other(char *path_name, int flags, int mode,",
          "1533: {",
          "1534:  pid_t child;",
          "1537:  int pipe[2];",
          "1538:  int fd = -1, rc = 0;",
          "",
          "[Removed Lines]",
          "1532:      uint32_t jobid, uid_t uid, gid_t gid)",
          "1535:  int ngids;",
          "1536:  gid_t *gids;",
          "",
          "[Added Lines]",
          "1532:      uint32_t jobid, uid_t uid, gid_t gid,",
          "1533:      int ngids, gid_t *gids)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1549:   return -1;",
          "1550:  }",
          "1554:  child = fork();",
          "1555:  if (child == -1) {",
          "1556:   error(\"%s: fork failure\", __func__);",
          "",
          "[Removed Lines]",
          "1552:  ngids = group_cache_lookup_job(jobid, uid, gid, &gids);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1633:  path_name = fname_create2(req);",
          "1634:  if ((fd = _open_as_other(path_name, flags, 0644,",
          "1636:   error(\"Unable to open %s: Permission denied\", path_name);",
          "1637:   xfree(path_name);",
          "1638:   return;",
          "",
          "[Removed Lines]",
          "1635:      req->job_id, req->uid, req->gid)) == -1) {",
          "",
          "[Added Lines]",
          "1632:      req->job_id, req->uid, req->gid,",
          "1633:      req->ngids, req->gids)) == -1) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4036:          file_bcast_info_t *key)",
          "4037: {",
          "4038:  file_bcast_msg_t *req = msg->data;",
          "4040:  file_bcast_info_t *file_info;",
          "4042:  flags = O_WRONLY | O_CREAT;",
          "4043:  if (req->force)",
          "",
          "[Removed Lines]",
          "4039:  int fd, flags;",
          "",
          "[Added Lines]",
          "4037:  int fd, flags, ngids;",
          "4039:  gid_t *gids;",
          "4042:  ngids = group_cache_lookup(key->uid, key->gid, NULL, &gids);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4046:   flags |= O_EXCL;",
          "4048:  if ((fd = _open_as_other(req->fname, flags, 0700,",
          "4050:   error(\"Unable to open %s: Permission denied\", req->fname);",
          "4051:   return SLURM_ERROR;",
          "4052:  }",
          "",
          "[Removed Lines]",
          "4049:      key->job_id, key->uid, key->gid)) == -1) {",
          "",
          "[Added Lines]",
          "4051:      key->job_id, key->uid, key->gid,",
          "4052:      ngids, gids)) == -1) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8b9c61d54038018556af5ce74bcc6bc3ae4f4b60",
      "candidate_info": {
        "commit_hash": "8b9c61d54038018556af5ce74bcc6bc3ae4f4b60",
        "repo": "SchedMD/slurm",
        "commit_url": "https://github.com/SchedMD/slurm/commit/8b9c61d54038018556af5ce74bcc6bc3ae4f4b60",
        "files": [
          "src/slurmd/slurmd/req.c"
        ],
        "message": "Convert slurmd to use group_cache_lookup_job call.\n\nModify _open_as_other so that both _file_bcast_register_file\nand _prolog_error can both use it. (That code was originally\nextracted from _file_bcast_register_file, but tailored to\n_prolog_error's requirements. Less duplication is good.)",
        "before_after_code_files": [
          "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
          ],
          "candidate": [
            "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
          ]
        }
      },
      "candidate_diff": {
        "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c": [
          "File: src/slurmd/slurmd/req.c -> src/slurmd/slurmd/req.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1526: {",
          "1527:  pid_t child;",
          "1529:  int pipe[2];",
          "1530:  int fd = -1, rc = 0;",
          "1541:   return -1;",
          "1542:  }",
          "",
          "[Removed Lines]",
          "1525: static int _open_as_other(char *path_name, batch_job_launch_msg_t *req)",
          "1528:  gids_t *gids;",
          "1532:  if (!(gids = gids_cache_lookup(req->user_name, req->gid))) {",
          "1533:   error(\"%s: gids_cache_lookup for %s failed\",",
          "1534:         __func__, req->user_name);",
          "1535:   return -1;",
          "1536:  }",
          "1538:  if ((rc = container_g_create(req->job_id))) {",
          "1539:   error(\"%s: container_g_create(%u): %m\", __func__, req->job_id);",
          "1540:   free_gids(gids);",
          "",
          "[Added Lines]",
          "1529: static int _open_as_other(char *path_name, int flags, int mode,",
          "1530:      uint32_t jobid, uid_t uid, gid_t gid)",
          "1533:  int ngids;",
          "1534:  gid_t *gids;",
          "1538:  if ((rc = container_g_create(jobid))) {",
          "1539:   error(\"%s: container_g_create(%u): %m\", __func__, jobid);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1546:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {",
          "1547:   error(\"%s: Failed to open pipe: %m\", __func__);",
          "1549:   return -1;",
          "1550:  }",
          "1552:  child = fork();",
          "1553:  if (child == -1) {",
          "1554:   error(\"%s: fork failure\", __func__);",
          "1556:   close(pipe[0]);",
          "1557:   close(pipe[1]);",
          "1558:   return -1;",
          "1559:  } else if (child > 0) {",
          "1560:   close(pipe[0]);",
          "1561:   (void) waitpid(child, &rc, 0);",
          "1563:   if (WIFEXITED(rc) && (WEXITSTATUS(rc) == 0))",
          "1564:    fd = _receive_fd(pipe[1]);",
          "1565:   close(pipe[1]);",
          "",
          "[Removed Lines]",
          "1548:   free_gids(gids);",
          "1555:   free_gids(gids);",
          "1562:   free_gids(gids);",
          "",
          "[Added Lines]",
          "1550:  ngids = group_cache_lookup_job(jobid, uid, gid, &gids);",
          "1555:   xfree(gids);",
          "1562:   xfree(gids);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1580:   exit(SLURM_ERROR);",
          "1581:  }",
          "",
          "[Removed Lines]",
          "1578:  if (container_g_add_pid(req->job_id, getpid(), req->uid)) {",
          "1579:   error(\"%s container_g_add_pid(%u): %m\", __func__, req->job_id);",
          "",
          "[Added Lines]",
          "1578:  if (container_g_add_pid(jobid, getpid(), uid)) {",
          "1579:   error(\"%s container_g_add_pid(%u): %m\", __func__, jobid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1599:   exit(errno);",
          "1600:  }",
          "1605:   exit(errno);",
          "1606:  }",
          "1609:   exit(errno);",
          "1610:  }",
          "1613:  if (fd == -1) {",
          "1617:  }",
          "1618:  _send_back_fd(pipe[0], fd);",
          "1619:  close(fd);",
          "1620:  exit(SLURM_SUCCESS);",
          "1621: }",
          "1623: static void",
          "1624: _prolog_error(batch_job_launch_msg_t *req, int rc)",
          "1625: {",
          "1626:  char *err_name = NULL, *path_name = NULL;",
          "1627:  int fd;",
          "1629:  path_name = fname_create2(req);",
          "1631:   error(\"Unable to open %s: Permission denied\", path_name);",
          "1632:   xfree(path_name);",
          "1633:   return;",
          "1634:  }",
          "1635:  xfree(path_name);",
          "1636:  xstrfmtcat(err_name, \"Error running slurm prolog: %d\\n\",",
          "1637:      WEXITSTATUS(rc));",
          "1638:  safe_write(fd, err_name, strlen(err_name));",
          "1643: rwfail:",
          "1644:  xfree(err_name);",
          "1645:  close(fd);",
          "",
          "[Removed Lines]",
          "1597:  if (setgroups(gids->ngids, gids->gids) < 0) {",
          "1598:   error(\"%s: uid: %u setgroups failed: %m\", __func__, req->uid);",
          "1601:  free_gids(gids);",
          "1603:  if (setgid(req->gid) < 0) {",
          "1604:   error(\"%s: uid:%u setgid(%u): %m\", __func__, req->uid,req->gid);",
          "1607:  if (setuid(req->uid) < 0) {",
          "1608:   error(\"%s: getuid(%u): %m\", __func__, req->uid);",
          "1612:  fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644);",
          "1614:   error(\"%s: uid:%u can't open `%s`: %m\",",
          "1615:         __func__, req->uid, path_name);",
          "1616:   exit(errno);",
          "1630:  if ((fd = _open_as_other(path_name, req)) == -1) {",
          "1639:  if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {",
          "1640:   error(\"%s: Couldn't change fd owner to %u:%u: %m\",",
          "1641:         __func__, req->uid, req->gid);",
          "1642:  }",
          "",
          "[Added Lines]",
          "1597:  if (setgroups(ngids, gids) < 0) {",
          "1598:   error(\"%s: uid: %u setgroups failed: %m\", __func__, uid);",
          "1601:  xfree(gids);",
          "1603:  if (setgid(gid) < 0) {",
          "1604:   error(\"%s: uid:%u setgid(%u): %m\", __func__, uid, gid);",
          "1607:  if (setuid(uid) < 0) {",
          "1608:   error(\"%s: getuid(%u): %m\", __func__, uid);",
          "1612:  fd = open(path_name, flags, mode);",
          "1614:    error(\"%s: uid:%u can't open `%s`: %m\",",
          "1615:    __func__, uid, path_name);",
          "1616:    exit(errno);",
          "1629:  int flags = (O_CREAT|O_APPEND|O_WRONLY);",
          "1632:  if ((fd = _open_as_other(path_name, flags, 0644,",
          "1633:      req->job_id, req->uid, req->gid)) == -1) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4028:          file_bcast_info_t *key)",
          "4029: {",
          "4030:  file_bcast_msg_t *req = msg->data;",
          "4035:  file_bcast_info_t *file_info;",
          "4137:  flags = O_WRONLY | O_CREAT;",
          "4138:  if (req->force)",
          "4139:   flags |= O_TRUNC;",
          "4140:  else",
          "4141:   flags |= O_EXCL;",
          "4148:  }",
          "4152: }",
          "4154: static void",
          "",
          "[Removed Lines]",
          "4031:  int fd, flags, rc;",
          "4032:  int pipe[2];",
          "4033:  gids_t *gids;",
          "4034:  pid_t child;",
          "4037:  if (!(gids = gids_cache_lookup(req->user_name, key->gid))) {",
          "4038:   error(\"sbcast: gids_cache_lookup for %s failed\", req->user_name);",
          "4039:   return SLURM_ERROR;",
          "4040:  }",
          "4042:  if ((rc = container_g_create(key->job_id))) {",
          "4043:   error(\"sbcast: container_g_create(%u): %m\", key->job_id);",
          "4044:   free_gids(gids);",
          "4045:   return rc;",
          "4046:  }",
          "4051:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {",
          "4052:   error(\"%s: Failed to open pipe: %m\", __func__);",
          "4053:   free_gids(gids);",
          "4054:   return SLURM_ERROR;",
          "4055:  }",
          "4057:  child = fork();",
          "4058:  if (child == -1) {",
          "4059:   error(\"sbcast: fork failure\");",
          "4060:   free_gids(gids);",
          "4061:   close(pipe[0]);",
          "4062:   close(pipe[1]);",
          "4063:   return errno;",
          "4064:  } else if (child > 0) {",
          "4066:   close(pipe[0]);",
          "4067:   waitpid(child, &rc, 0);",
          "4068:   free_gids(gids);",
          "4069:   if (rc) {",
          "4070:    close(pipe[1]);",
          "4071:    return WEXITSTATUS(rc);",
          "4072:   }",
          "4074:   fd = _receive_fd(pipe[1]);",
          "4075:   close(pipe[1]);",
          "4077:   file_info = xmalloc(sizeof(file_bcast_info_t));",
          "4078:   file_info->fd = fd;",
          "4079:   file_info->fname = xstrdup(req->fname);",
          "4080:   file_info->uid = key->uid;",
          "4081:   file_info->gid = key->gid;",
          "4082:   file_info->job_id = key->job_id;",
          "4083:   file_info->start_time = time(NULL);",
          "4086:   _fb_wrlock();",
          "4087:   list_append(file_bcast_list, file_info);",
          "4088:   _fb_wrunlock();",
          "4090:   return SLURM_SUCCESS;",
          "4091:  }",
          "4095:  close(pipe[1]);",
          "4098:     forked process part of the fork to avoid a race",
          "4099:     condition where if this process makes a file or",
          "4100:     detacts itself from a child before we add the pid",
          "4101:     to the container in the parent of the fork.",
          "4103:  if (container_g_add_pid(key->job_id, getpid(), key->uid)) {",
          "4104:   error(\"container_g_add_pid(%u): %m\", key->job_id);",
          "4105:   exit(SLURM_ERROR);",
          "4106:  }",
          "4122:  if (setgroups(gids->ngids, gids->gids) < 0) {",
          "4123:   error(\"sbcast: uid: %u setgroups failed: %m\", key->uid);",
          "4124:   exit(errno);",
          "4125:  }",
          "4126:  free_gids(gids);",
          "4128:  if (setgid(key->gid) < 0) {",
          "4129:   error(\"sbcast: uid:%u setgid(%u): %m\", key->uid, key->gid);",
          "4130:   exit(errno);",
          "4131:  }",
          "4132:  if (setuid(key->uid) < 0) {",
          "4133:   error(\"sbcast: getuid(%u): %m\", key->uid);",
          "4134:   exit(errno);",
          "4135:  }",
          "4143:  fd = open(key->fname, flags, 0700);",
          "4144:  if (fd == -1) {",
          "4145:   error(\"sbcast: uid:%u can't open `%s`: %m\",",
          "4146:         key->uid, key->fname);",
          "4147:   exit(errno);",
          "4149:  _send_back_fd(pipe[0], fd);",
          "4150:  close(fd);",
          "4151:  exit(SLURM_SUCCESS);",
          "",
          "[Added Lines]",
          "4032:  int fd, flags;",
          "4041:  if ((fd = _open_as_other(req->fname, flags, 0700,",
          "4042:      key->job_id, key->uid, key->gid)) == -1) {",
          "4043:   error(\"Unable to open %s: Permission denied\", req->fname);",
          "4044:   return SLURM_ERROR;",
          "4047:  file_info = xmalloc(sizeof(file_bcast_info_t));",
          "4048:  file_info->fd = fd;",
          "4049:  file_info->fname = xstrdup(req->fname);",
          "4050:  file_info->uid = key->uid;",
          "4051:  file_info->gid = key->gid;",
          "4052:  file_info->job_id = key->job_id;",
          "4053:  file_info->start_time = time(NULL);",
          "4056:  _fb_wrlock();",
          "4057:  list_append(file_bcast_list, file_info);",
          "4058:  _fb_wrunlock();",
          "4060:  return SLURM_SUCCESS;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "07fae5df436eafe503a94a312260bae331122718",
      "candidate_info": {
        "commit_hash": "07fae5df436eafe503a94a312260bae331122718",
        "repo": "SchedMD/slurm",
        "commit_url": "https://github.com/SchedMD/slurm/commit/07fae5df436eafe503a94a312260bae331122718",
        "files": [
          "src/common/Makefile.am",
          "src/common/Makefile.in",
          "src/common/group_cache.c",
          "src/common/group_cache.h",
          "src/slurmd/slurmd/req.c",
          "src/slurmd/slurmd/slurmd.c"
        ],
        "message": "Add a user-to-extended-groups cache into src/common/group_cache.c\n\nLoosely based on src/slurmd/req.c. But with major alterations\nin preparation for use with PrologFlags=SendGIDs.\n\nConvert slurmd to use a compatibility shim in here for now.",
        "before_after_code_files": [
          "src/common/Makefile.am||src/common/Makefile.am",
          "src/common/Makefile.in||src/common/Makefile.in",
          "src/common/group_cache.c||src/common/group_cache.c",
          "src/common/group_cache.h||src/common/group_cache.h",
          "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c",
          "src/slurmd/slurmd/slurmd.c||src/slurmd/slurmd/slurmd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
          ],
          "candidate": [
            "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c"
          ]
        }
      },
      "candidate_diff": {
        "src/common/Makefile.am||src/common/Makefile.am": [
          "File: src/common/Makefile.am -> src/common/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:  xcgroup_read_config.c xcgroup_read_config.h \\",
          "123:  xlua.c xlua.h                   \\",
          "124:  callerid.c callerid.h  \\",
          "125:  slurm_persist_conn.c slurm_persist_conn.h \\",
          "126:  state_control.c state_control.h",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125:  group_cache.c group_cache.h \\",
          "",
          "---------------"
        ],
        "src/common/Makefile.in||src/common/Makefile.in": [
          "File: src/common/Makefile.in -> src/common/Makefile.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "182:  stepd_api.lo write_labelled_message.lo proc_args.lo \\",
          "183:  node_conf.lo gres.lo entity.lo layout.lo layouts_mgr.lo \\",
          "184:  mapping.lo xcgroup_read_config.lo xlua.lo callerid.lo \\",
          "186: libcommon_la_OBJECTS = $(am_libcommon_la_OBJECTS)",
          "187: AM_V_lt = $(am__v_lt_@AM_V@)",
          "188: am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)",
          "",
          "[Removed Lines]",
          "185:  slurm_persist_conn.lo state_control.lo",
          "",
          "[Added Lines]",
          "185:  group_cache.lo slurm_persist_conn.lo state_control.lo",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "648:  xcgroup_read_config.c xcgroup_read_config.h \\",
          "649:  xlua.c xlua.h                   \\",
          "650:  callerid.c callerid.h  \\",
          "651:  slurm_persist_conn.c slurm_persist_conn.h \\",
          "652:  state_control.c state_control.h",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "651:  group_cache.c group_cache.h \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "768: @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/forward.Plo@am__quote@",
          "769: @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/global_defaults.Plo@am__quote@",
          "770: @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gres.Plo@am__quote@",
          "771: @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hostlist.Plo@am__quote@",
          "772: @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io_hdr.Plo@am__quote@",
          "773: @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/job_options.Plo@am__quote@",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "772: @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/group_cache.Plo@am__quote@",
          "",
          "---------------"
        ],
        "src/common/group_cache.c||src/common/group_cache.c": [
          "File: src/common/group_cache.c -> src/common/group_cache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #include <grp.h>",
          "63: #include \"src/common/group_cache.h\"",
          "64: #include \"src/common/list.h\"",
          "65: #include \"src/common/read_config.h\"",
          "66: #include \"src/common/uid.h\"",
          "67: #include \"src/common/xmalloc.h\"",
          "68: #include \"src/common/xstring.h\"",
          "71: #define NGROUPS_START 64",
          "73: typedef struct gids_cache {",
          "74:  uid_t uid;",
          "75:  gid_t gid;",
          "76:  char *username;",
          "79:  int ngids;",
          "80:  gid_t *gids;",
          "81:  time_t expiration;",
          "82: } gids_cache_t;",
          "84: typedef struct gids_cache_needle {",
          "90: } gids_cache_needle_t;",
          "92: static pthread_mutex_t gids_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "93: static List gids_cache_list = NULL;",
          "95: static void _group_cache_list_delete(void *x)",
          "96: {",
          "97:  gids_cache_t *entry = (gids_cache_t *) x;",
          "98:  xfree(entry->username);",
          "99:  xfree(entry);",
          "100: }",
          "103: void group_cache_purge(void)",
          "104: {",
          "105:  slurm_mutex_lock(&gids_mutex);",
          "106:  if (gids_cache_list)",
          "107:   list_destroy(gids_cache_list);",
          "108:  gids_cache_list = NULL;",
          "109:  slurm_mutex_unlock(&gids_mutex);",
          "110: }",
          "112: static int _find_entry(void *x, void *key)",
          "113: {",
          "114:  gids_cache_t *entry = (gids_cache_t *) x;",
          "115:  gids_cache_needle_t *needle = (gids_cache_needle_t *) key;",
          "117:  if (needle->jobid && (needle->jobid == entry->jobid))",
          "120:  if (needle->uid != entry->uid)",
          "121:   return 0;",
          "123:  if (needle->gid != entry->gid)",
          "124:   return 0;",
          "132:  if (entry->jobid && (entry->expiration < needle->now))",
          "133:   return 0;",
          "136:  return 1;",
          "137: }",
          "145: static int _group_cache_lookup_internal(gids_cache_needle_t *needle, gid_t **gids)",
          "146: {",
          "147:  gids_cache_t *entry;",
          "150:  slurm_mutex_lock(&gids_mutex);",
          "151:  if (!gids_cache_list)",
          "152:   gids_cache_list = list_create(_group_cache_list_delete);",
          "154:  needle->now = time(NULL);",
          "155:  entry = list_find_first(gids_cache_list, _find_entry, needle);",
          "157:  if (entry && (entry->jobid || entry->expiration > needle->now)) {",
          "158:   debug2(\"%s: found valid entry for %s\",",
          "159:          __func__, entry->username);",
          "160:   goto out;",
          "161:  }",
          "163:  if (entry) {",
          "164:   debug2(\"%s: found old entry for %s, looking up again\",",
          "165:          __func__, entry->username);",
          "171:   entry->ngids = xsize(entry->gids) / sizeof(gid_t);",
          "172:  } else {",
          "173:   if (!needle->username)",
          "174:    needle->username = uid_to_string(needle->uid);",
          "175:   debug2(\"%s: no entry found for %s\",",
          "176:          __func__, needle->username);",
          "178:   entry = xmalloc(sizeof(gids_cache_t));",
          "179:   entry->username = xstrdup(needle->username);",
          "180:   entry->uid = needle->uid;",
          "181:   entry->gid = needle->gid;",
          "183:   entry->ngids = NGROUPS_START;",
          "184:   entry->gids = xmalloc(sizeof(gid_t) * entry->ngids);",
          "185:   list_prepend(gids_cache_list, entry);",
          "186:  }",
          "188:  entry->expiration = needle->now + slurmctld_conf.group_time;",
          "192:  while (getgrouplist(needle->username, needle->gid,",
          "193:        entry->gids, &entry->ngids) == -1) {",
          "195:   entry->gids = xrealloc(entry->gids,",
          "196:            entry->ngids * sizeof(gid_t));",
          "197:  }",
          "199: out:",
          "200:  ngids = entry->ngids;",
          "202:  memcpy(*gids, entry->gids, ngids * sizeof(gid_t));",
          "204:  slurm_mutex_unlock(&gids_mutex);",
          "206:  return ngids;",
          "207: }",
          "209: static int _find_others_to_delete(void *x, void *key)",
          "210: {",
          "211:  gids_cache_t *cached = (gids_cache_t *) x;",
          "212:  gids_cache_needle_t *needle = (gids_cache_needle_t *) key;",
          "215:   return 0;",
          "217:  if (needle->uid != cached->uid)",
          "218:   return 0;",
          "220:  if (needle->gid != cached->gid)",
          "221:   return 0;",
          "223:  return 1;",
          "224: }",
          "237: extern void group_cache_push(uint32_t jobid, uid_t uid, gid_t gid,",
          "238:         char *username, int ngids, gid_t **gids)",
          "239: {",
          "240:  gids_cache_t *new = xmalloc(sizeof(gids_cache_t));",
          "242:  debug2(\"%s: pushing entry for %s job %u\", __func__, username, jobid);",
          "244:  slurm_mutex_lock(&gids_mutex);",
          "245:  if (!gids_cache_list)",
          "246:   gids_cache_list = list_create(_group_cache_list_delete);",
          "247:  else {",
          "249:   gids_cache_needle_t needle = {0};",
          "250:   needle.uid = uid;",
          "251:   needle.gid = gid;",
          "252:   list_delete_all(gids_cache_list, _find_others_to_delete,",
          "253:     &needle);",
          "254:  }",
          "256:  new->uid = uid;",
          "257:  new->gid = gid;",
          "258:  new->username = xstrdup(username);",
          "259:  new->jobid = jobid;",
          "260:  new->ngids = ngids;",
          "261:  new->gids = *gids;",
          "263:  new->expiration = time(NULL) + slurmctld_conf.group_time;",
          "264:  list_prepend(gids_cache_list, new);",
          "265:  slurm_mutex_unlock(&gids_mutex);",
          "266: }",
          "275: extern int group_cache_lookup(uid_t uid, gid_t gid, char *username, gid_t **gids)",
          "276: {",
          "277:  gids_cache_needle_t needle = {0};",
          "279:  needle.username = username;",
          "280:  needle.uid = uid;",
          "281:  needle.gid = gid;",
          "283:  return _group_cache_lookup_internal(&needle, gids);",
          "284: }",
          "293: extern int group_cache_lookup_job(uint32_t jobid, uid_t uid, gid_t gid,",
          "294:       gid_t **gids)",
          "295: {",
          "296:  gids_cache_needle_t needle = {0};",
          "298:  needle.jobid = jobid;",
          "299:  needle.uid = gid;",
          "300:  needle.gid = gid;",
          "302:  return _group_cache_lookup_internal(&needle, gids);",
          "303: }",
          "305: static int _cleanup_search(void *x, void *key)",
          "306: {",
          "307:  gids_cache_t *cached = (gids_cache_t *) x;",
          "308:  time_t *now = (time_t *) key;",
          "310:  if (cached->jobid)",
          "311:   return 0;",
          "313:  if (cached->expiration < *now)",
          "314:   return 1;",
          "316:  return 0;",
          "317: }",
          "322: extern void group_cache_cleanup(void)",
          "323: {",
          "324:  time_t now = time(NULL);",
          "325:  if (gids_cache_list)",
          "326:   list_delete_all(gids_cache_list, _cleanup_search, &now);",
          "327: }",
          "329: static int _remove_jobid(void *x, void *key)",
          "330: {",
          "331:  gids_cache_t *cached = (gids_cache_t *) x;",
          "332:  uint32_t *jobid = (uint32_t *) key;",
          "334:  if (cached->jobid == *jobid)",
          "335:   return 1;",
          "337:  return 0;",
          "338: }",
          "343: extern void group_cache_remove_jobid(uint32_t jobid)",
          "344: {",
          "345:  if (!(slurmctld_conf.prolog_flags | PROLOG_FLAG_SEND_GIDS))",
          "346:   return;",
          "348:  list_delete_all(gids_cache_list, _remove_jobid, &jobid);",
          "349: }",
          "353: extern void free_gids(gids_t *p)",
          "354: {",
          "355:  xfree(p->gids);",
          "356:  xfree(p);",
          "357: }",
          "359: extern gids_t *gids_cache_lookup(char *username, gid_t gid)",
          "360: {",
          "361:  gids_t *gids;",
          "362:  gids_cache_needle_t needle = {0};",
          "364:  if (uid_from_string(username, &needle.uid) < 0)",
          "365:   return NULL;",
          "367:  needle.username = username;",
          "368:  needle.gid = gid;",
          "370:  gids = xmalloc(sizeof(gids_t));",
          "371:  gids->ngids = _group_cache_lookup_internal(&needle, &gids->gids);",
          "373:  return gids;",
          "374: }",
          "",
          "---------------"
        ],
        "src/common/group_cache.h||src/common/group_cache.h": [
          "File: src/common/group_cache.h -> src/common/group_cache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #ifndef _SLURM_GROUP_CACHE_H",
          "38: #define _SLURM_GROUP_CACHE_H",
          "40: #include <inttypes.h>",
          "41: #include <sys/types.h>",
          "54: void group_cache_push(uint32_t jobid, uid_t uid, gid_t gid, char *username, int ngids, gid_t **gids);",
          "63: extern int group_cache_lookup(uid_t uid, gid_t gid, char *username, gid_t **gids);",
          "72: extern int group_cache_lookup_job(uint32_t jobid, uid_t uid, gid_t gid, gid_t **gids);",
          "77: extern void group_cache_remove_jobid(uint32_t jobid);",
          "80: void group_cache_purge(void);",
          "83: void group_cache_cleanup(void);",
          "87: typedef struct {",
          "88:  int ngids;",
          "89:  gid_t *gids;",
          "90: } gids_t;",
          "92: gids_t *gids_cache_lookup(char *username, gid_t gid);",
          "94: void free_gids(gids_t *p);",
          "97: #endif",
          "",
          "---------------"
        ],
        "src/slurmd/slurmd/req.c||src/slurmd/slurmd/req.c": [
          "File: src/slurmd/slurmd/req.c -> src/slurmd/slurmd/req.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: #include \"src/common/fd.h\"",
          "70: #include \"src/common/forward.h\"",
          "71: #include \"src/common/gres.h\"",
          "72: #include \"src/common/hostlist.h\"",
          "73: #include \"src/common/list.h\"",
          "74: #include \"src/common/log.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: #include \"src/common/group_cache.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116: #define MAX_CPU_CNT 1024",
          "117: #define MAX_NUMA_CNT 128",
          "124: typedef struct {",
          "125:  uint32_t job_id;",
          "126:  uint32_t step_id;",
          "",
          "[Removed Lines]",
          "119: typedef struct {",
          "120:  int ngids;",
          "121:  gid_t *gids;",
          "122: } gids_t;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "209: static int  _run_prolog(job_env_t *job_env, slurm_cred_t *cred);",
          "210: static void _rpc_forward_data(slurm_msg_t *msg);",
          "211: static int  _rpc_network_callerid(slurm_msg_t *msg);",
          "215: static bool _pause_for_job_completion(uint32_t jobid, char *nodes,",
          "216:           int maxtime);",
          "",
          "[Removed Lines]",
          "212: static void _dealloc_gids(gids_t *p);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "226: static void _wait_state_completed(uint32_t jobid, int max_delay);",
          "227: static uid_t _get_job_uid(uint32_t jobid);",
          "231: static int  _add_starting_step(uint16_t type, void *req);",
          "232: static int  _remove_starting_step(uint16_t type, void *req);",
          "233: static int  _compare_starting_steps(void *s0, void *s1);",
          "",
          "[Removed Lines]",
          "229: static gids_t *_gids_cache_lookup(char *user, gid_t gid);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "693:   return errno;",
          "694:  }",
          "697:   int i;",
          "698:   uint32_t tmp32;",
          "699:   safe_write(fd, &gids->ngids, sizeof(int));",
          "",
          "[Removed Lines]",
          "696:  if ((gids = _gids_cache_lookup(user_name, gid))) {",
          "",
          "[Added Lines]",
          "688:  if ((gids = gids_cache_lookup(user_name, gid))) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "701:    tmp32 = (uint32_t)gids->gids[i];",
          "702:    safe_write(fd, &tmp32, sizeof(uint32_t));",
          "703:   }",
          "705:  } else {",
          "706:   len = 0;",
          "707:   safe_write(fd, &len, sizeof(int));",
          "",
          "[Removed Lines]",
          "704:   _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "696:   free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1582:  int pipe[2];",
          "1583:  int fd = -1, rc = 0;",
          "1586:   error(\"%s: gids_cache_lookup for %s failed\",",
          "1587:         __func__, req->user_name);",
          "1588:   return -1;",
          "",
          "[Removed Lines]",
          "1585:  if (!(gids = _gids_cache_lookup(req->user_name, req->gid))) {",
          "",
          "[Added Lines]",
          "1577:  if (!(gids = gids_cache_lookup(req->user_name, req->gid))) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1591:  if ((rc = container_g_create(req->job_id))) {",
          "1592:   error(\"%s: container_g_create(%u): %m\", __func__, req->job_id);",
          "1594:   return -1;",
          "1595:  }",
          "",
          "[Removed Lines]",
          "1593:   _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "1585:   free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1599:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {",
          "1600:   error(\"%s: Failed to open pipe: %m\", __func__);",
          "1602:   return -1;",
          "1603:  }",
          "1605:  child = fork();",
          "1606:  if (child == -1) {",
          "1607:   error(\"%s: fork failure\", __func__);",
          "1609:   close(pipe[0]);",
          "1610:   close(pipe[1]);",
          "1611:   return -1;",
          "1612:  } else if (child > 0) {",
          "1613:   close(pipe[0]);",
          "1614:   (void) waitpid(child, &rc, 0);",
          "1616:   if (WIFEXITED(rc) && (WEXITSTATUS(rc) == 0))",
          "1617:    fd = _receive_fd(pipe[1]);",
          "1618:   close(pipe[1]);",
          "",
          "[Removed Lines]",
          "1601:   _dealloc_gids(gids);",
          "1608:   _dealloc_gids(gids);",
          "1615:   _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "1593:   free_gids(gids);",
          "1600:   free_gids(gids);",
          "1607:   free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1651:   error(\"%s: uid: %u setgroups failed: %m\", __func__, req->uid);",
          "1652:   exit(errno);",
          "1653:  }",
          "1656:  if (setgid(req->gid) < 0) {",
          "1657:   error(\"%s: uid:%u setgid(%u): %m\", __func__, req->uid,req->gid);",
          "",
          "[Removed Lines]",
          "1654:  _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "1646:  free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4082:  pid_t child;",
          "4083:  file_bcast_info_t *file_info;",
          "4086:   error(\"sbcast: gids_cache_lookup for %s failed\", req->user_name);",
          "4087:   return SLURM_ERROR;",
          "4088:  }",
          "4090:  if ((rc = container_g_create(key->job_id))) {",
          "4091:   error(\"sbcast: container_g_create(%u): %m\", key->job_id);",
          "4093:   return rc;",
          "4094:  }",
          "",
          "[Removed Lines]",
          "4085:  if (!(gids = _gids_cache_lookup(req->user_name, key->gid))) {",
          "4092:   _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "4077:  if (!(gids = gids_cache_lookup(req->user_name, key->gid))) {",
          "4084:   free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4099:  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {",
          "4100:   error(\"%s: Failed to open pipe: %m\", __func__);",
          "4102:   return SLURM_ERROR;",
          "4103:  }",
          "4105:  child = fork();",
          "4106:  if (child == -1) {",
          "4107:   error(\"sbcast: fork failure\");",
          "4109:   close(pipe[0]);",
          "4110:   close(pipe[1]);",
          "4111:   return errno;",
          "",
          "[Removed Lines]",
          "4101:   _dealloc_gids(gids);",
          "4108:   _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "4093:   free_gids(gids);",
          "4100:   free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4114:   close(pipe[0]);",
          "4115:   waitpid(child, &rc, 0);",
          "4117:   if (rc) {",
          "4118:    close(pipe[1]);",
          "4119:    return WEXITSTATUS(rc);",
          "",
          "[Removed Lines]",
          "4116:   _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "4108:   free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4171:   error(\"sbcast: uid: %u setgroups failed: %m\", key->uid);",
          "4172:   exit(errno);",
          "4173:  }",
          "4176:  if (setgid(key->gid) < 0) {",
          "4177:   error(\"sbcast: uid:%u setgid(%u): %m\", key->uid, key->gid);",
          "",
          "[Removed Lines]",
          "4174:  _dealloc_gids(gids);",
          "",
          "[Added Lines]",
          "4166:  free_gids(gids);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "6026:  return error_code;",
          "6027: }",
          "6207: extern void",
          "6208: destroy_starting_step(void *x)",
          "6209: {",
          "",
          "[Removed Lines]",
          "6035: typedef struct gid_cache_s {",
          "6036:  char *user;",
          "6037:  time_t timestamp;",
          "6038:  gid_t gid;",
          "6039:  gids_t *gids;",
          "6040:  struct gid_cache_s *next;",
          "6041: } gids_cache_t;",
          "6043: #define GIDS_HASH_LEN 64",
          "6044: static gids_cache_t *gids_hashtbl[GIDS_HASH_LEN] = {NULL};",
          "6045: static pthread_mutex_t gids_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "6047: static gids_t *",
          "6048: _alloc_gids(int n, gid_t *gids)",
          "6049: {",
          "6050:  gids_t *new;",
          "6052:  new = (gids_t *)xmalloc(sizeof(gids_t));",
          "6053:  new->ngids = n;",
          "6054:  new->gids = gids;",
          "6055:  return new;",
          "6056: }",
          "6058: static void",
          "6059: _dealloc_gids(gids_t *p)",
          "6060: {",
          "6061:  xfree(p->gids);",
          "6062:  xfree(p);",
          "6063: }",
          "6066: static gids_t *",
          "6067: _gids_dup(gids_t *g)",
          "6068: {",
          "6069:  int buf_size;",
          "6070:  gids_t *n = xmalloc(sizeof(gids_t));",
          "6071:  n->ngids = g->ngids;",
          "6072:  buf_size = g->ngids * sizeof(gid_t);",
          "6073:  n->gids = xmalloc(buf_size);",
          "6074:  memcpy(n->gids, g->gids, buf_size);",
          "6075:  return n;",
          "6076: }",
          "6078: static gids_cache_t *",
          "6079: _alloc_gids_cache(char *user, gid_t gid, gids_t *gids, gids_cache_t *next)",
          "6080: {",
          "6081:  gids_cache_t *p;",
          "6083:  p = (gids_cache_t *)xmalloc(sizeof(gids_cache_t));",
          "6084:  p->user = xstrdup(user);",
          "6085:  p->timestamp = time(NULL);",
          "6086:  p->gid = gid;",
          "6087:  p->gids = gids;",
          "6088:  p->next = next;",
          "6089:  return p;",
          "6090: }",
          "6092: static void",
          "6093: _dealloc_gids_cache(gids_cache_t *p)",
          "6094: {",
          "6095:  xfree(p->user);",
          "6096:  _dealloc_gids(p->gids);",
          "6097:  xfree(p);",
          "6098: }",
          "6100: static size_t",
          "6101: _gids_hashtbl_idx(const char *user)",
          "6102: {",
          "6103:  uint64_t x = 0;",
          "6104:  int i = 0;",
          "6108:  while (*user) {",
          "6109:   x += i++ * (int) *user++;",
          "6110:  }",
          "6112:  return x % GIDS_HASH_LEN;",
          "6113: }",
          "6115: void",
          "6116: gids_cache_purge(void)",
          "6117: {",
          "6118:  int i;",
          "6119:  gids_cache_t *p, *q;",
          "6121:  slurm_mutex_lock(&gids_mutex);",
          "6122:  for (i=0; i<GIDS_HASH_LEN; i++) {",
          "6123:   p = gids_hashtbl[i];",
          "6124:   while (p) {",
          "6125:    q = p->next;",
          "6126:    _dealloc_gids_cache(p);",
          "6127:    p = q;",
          "6128:   }",
          "6129:   gids_hashtbl[i] = NULL;",
          "6130:  }",
          "6131:  slurm_mutex_unlock(&gids_mutex);",
          "6132: }",
          "6134: static void",
          "6135: _gids_cache_register(char *user, gid_t gid, gids_t *gids)",
          "6136: {",
          "6137:  size_t idx;",
          "6138:  gids_cache_t *p, *q;",
          "6140:  idx = _gids_hashtbl_idx(user);",
          "6141:  q = gids_hashtbl[idx];",
          "6142:  p = _alloc_gids_cache(user, gid, gids, q);",
          "6143:  gids_hashtbl[idx] = p;",
          "6144:  debug2(\"Cached group access list for %s/%d\", user, gid);",
          "6145: }",
          "6148: #define NGROUPS_START 64",
          "6150: static gids_t *_gids_cache_lookup(char *user, gid_t gid)",
          "6151: {",
          "6152:  size_t idx;",
          "6153:  gids_cache_t *p;",
          "6154:  bool found_but_old = false;",
          "6155:  time_t now = 0;",
          "6156:  int ngroups = NGROUPS_START;",
          "6157:  gid_t *groups;",
          "6158:  gids_t *ret_gids = NULL;",
          "6160:  idx = _gids_hashtbl_idx(user);",
          "6161:  slurm_mutex_lock(&gids_mutex);",
          "6162:  p = gids_hashtbl[idx];",
          "6163:  while (p) {",
          "6164:   if (xstrcmp(p->user, user) == 0 && p->gid == gid) {",
          "6165:    slurm_ctl_conf_t *cf = slurm_conf_lock();",
          "6166:    int group_ttl = cf->group_time;",
          "6167:    slurm_conf_unlock();",
          "6168:    if (!group_ttl) {",
          "6169:     ret_gids = _gids_dup(p->gids);",
          "6170:     goto done;",
          "6171:    }",
          "6172:    now = time(NULL);",
          "6173:    if (difftime(now, p->timestamp) < group_ttl) {",
          "6174:     ret_gids = _gids_dup(p->gids);",
          "6175:     goto done;",
          "6176:    } else {",
          "6177:     found_but_old = true;",
          "6178:     break;",
          "6179:    }",
          "6180:   }",
          "6181:   p = p->next;",
          "6182:  }",
          "6185:  groups = xmalloc(ngroups * sizeof(gid_t));",
          "6186:  while (getgrouplist(user, gid, groups, &ngroups) == -1) {",
          "6188:   groups = xrealloc(groups, ngroups * sizeof(gid_t));",
          "6189:  }",
          "6190:  if (found_but_old) {",
          "6191:   xfree(p->gids->gids);",
          "6192:   p->gids->gids = groups;",
          "6193:   p->gids->ngids = ngroups;",
          "6194:   p->timestamp = now;",
          "6195:   ret_gids = _gids_dup(p->gids);",
          "6196:  } else {",
          "6197:   gids_t *gids = _alloc_gids(ngroups, groups);",
          "6198:   _gids_cache_register(user, gid, gids);",
          "6199:   ret_gids = _gids_dup(gids);",
          "6200:  }",
          "6201: done:",
          "6202:  slurm_mutex_unlock(&gids_mutex);",
          "6203:  return ret_gids;",
          "6204: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/slurmd/slurmd/slurmd.c||src/slurmd/slurmd/slurmd.c": [
          "File: src/slurmd/slurmd/slurmd.c -> src/slurmd/slurmd/slurmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: #include \"src/common/fd.h\"",
          "69: #include \"src/common/forward.h\"",
          "70: #include \"src/common/gres.h\"",
          "71: #include \"src/common/hostlist.h\"",
          "72: #include \"src/common/list.h\"",
          "73: #include \"src/common/log.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71: #include \"src/common/group_cache.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "386:  _slurmd_fini();",
          "387:  _destroy_conf();",
          "390:  file_bcast_purge();",
          "392:  info(\"Slurmd shutdown completing\");",
          "",
          "[Removed Lines]",
          "389:  gids_cache_purge();",
          "",
          "[Added Lines]",
          "390:  group_cache_purge();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1038:  gids_cache_purge();",
          "",
          "[Added Lines]",
          "1039:  group_cache_purge();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-15147",
  "cve_desc": "GoPro GPMF-parser 1.2.2 has an out-of-bounds read and SEGV in GPMF_Next in GPMF_parser.c.",
  "repo": "gopro/gpmf-parser",
  "patch_hash": "341f12cd5b97ab419e53853ca00176457c9f1681",
  "patch_info": {
    "commit_hash": "341f12cd5b97ab419e53853ca00176457c9f1681",
    "repo": "gopro/gpmf-parser",
    "commit_url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681",
    "files": [
      "GPMF_parser.c",
      "GPMF_parser.h",
      "demo/GPMF_demo.c",
      "demo/GPMF_mp4reader.c",
      "demo/GPMF_mp4reader.h"
    ],
    "message": "fixed many security issues with the too crude mp4 reader",
    "before_after_code_files": [
      "GPMF_parser.c||GPMF_parser.c",
      "GPMF_parser.h||GPMF_parser.h",
      "demo/GPMF_demo.c||demo/GPMF_demo.c",
      "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
      "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
    ]
  },
  "patch_diff": {
    "GPMF_parser.c||GPMF_parser.c": [
      "File: GPMF_parser.c -> GPMF_parser.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: {",
      "43:  if (ms)",
      "44:  {",
      "46:   if (nestsize == 0 && ms->nest_level == 0)",
      "47:    nestsize = ms->buffer_size_longs;",
      "",
      "[Removed Lines]",
      "45:   int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];",
      "",
      "[Added Lines]",
      "45:   uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];",
      "",
      "---------------"
    ],
    "GPMF_parser.h||GPMF_parser.h": [
      "File: GPMF_parser.h -> GPMF_parser.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "126:  GPMF_KEY_UNITS =   MAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \"RPM\", \"MPH\", \"km/h\", etc)",
      "127:  GPMF_KEY_SCALE =   MAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.",
      "128:  GPMF_KEY_TYPE =    MAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures",
      "130:  GPMF_KEY_TICK =    MAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds.",
      "131:  GPMF_KEY_TOCK =    MAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds.",
      "132:  GPMF_KEY_EMPTY_PAYLOADS = MAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)",
      "",
      "[Removed Lines]",
      "129:  GPMF_KEY_TOTAL_SAMPLES = MAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload",
      "",
      "[Added Lines]",
      "129:  GPMF_KEY_TOTAL_SAMPLES = MAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload",
      "130:  GPMF_KEY_TIME_OFFSET =  MAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)",
      "131:  GPMF_KEY_TIMING_OFFSET = MAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO",
      "132:  GPMF_KEY_TIME_STAMP =  MAKEID('S','T','M','P'),//STMP - Time stamp for the first sample.",
      "133:  GPMF_KEY_TIME_STAMPS =  MAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.)",
      "",
      "---------------"
    ],
    "demo/GPMF_demo.c||demo/GPMF_demo.c": [
      "File: demo/GPMF_demo.c -> demo/GPMF_demo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "46:  }",
      "48:  size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);",
      "51:  metadatalength = GetDuration(mp4);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "49:  if (mp4 == 0)",
      "50:  {",
      "51:   printf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);",
      "52:   return -1;",
      "53:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "90:   for (index = 0; index < payloads; index++)",
      "91:   {",
      "92:    uint32_t payloadsize = GetPayloadSize(mp4, index);",
      "94:    payload = GetPayload(mp4, payload, index);",
      "95:    if (payload == NULL)",
      "96:     goto cleanup;",
      "",
      "[Removed Lines]",
      "93:    float in = 0.0, out = 0.0; //times",
      "",
      "[Added Lines]",
      "99:    double in = 0.0, out = 0.0; //times",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:   {",
      "239:    if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream",
      "240:    {",
      "241:     uint32_t fourcc = GPMF_Key(ms);",
      "244:    }",
      "245:   }",
      "246: #endif",
      "",
      "[Removed Lines]",
      "242:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);",
      "243:     printf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);",
      "",
      "[Added Lines]",
      "247:     double in = 0.0, out = 0.0;",
      "249:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);",
      "250:     printf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);",
      "",
      "---------------"
    ],
    "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
      "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "26: #include <stdlib.h>",
      "27: #include <stdio.h>",
      "28: #include <string.h>",
      "29: #include <stdint.h>",
      "30: #include \"GPMF_mp4reader.h\"",
      "32: #define PRINT_MP4_STRUCTURE  0",
      "34: #ifdef WIN32",
      "36: #else",
      "38: #endif",
      "",
      "[Removed Lines]",
      "35: #define LONGSEEK  _fseeki64",
      "37: #define LONGSEEK  fseeko",
      "",
      "[Added Lines]",
      "28: #include <sys/types.h>",
      "29: #include <sys/stat.h>",
      "36: #define LONGSEEK _fseeki64",
      "37: #define stat64  _stat64",
      "39: #define LONGSEEK fseeko",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:   if (MP4buffer)",
      "65:   {",
      "69:   }",
      "70:  }",
      "71:  return NULL;",
      "72: }",
      "76: {",
      "82:  {",
      "85:  }",
      "87: }",
      "91: void FreePayload(uint32_t *lastpayload)",
      "92: {",
      "93:  if (lastpayload)",
      "",
      "[Removed Lines]",
      "66:    LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "67:    fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
      "68:    return MP4buffer;",
      "75: void SavePayload(size_t handle, uint32_t *payload, uint32_t index)",
      "77:  mp4object *mp4 = (mp4object *)handle;",
      "78:  if (mp4 == NULL) return;",
      "80:  uint32_t *MP4buffer = NULL;",
      "81:  if (index < mp4->indexcount && mp4->mediafp && payload)",
      "83:   LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "84:   fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);",
      "86:  return;",
      "",
      "[Added Lines]",
      "67:    if (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])",
      "68:    {",
      "69:     LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "70:     fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
      "71:     mp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];",
      "72:     return MP4buffer;",
      "73:    }",
      "80: void LongSeek(mp4object *mp4, int64_t offset)",
      "82:  if (mp4 && offset)",
      "84:   if (mp4->filepos + offset < mp4->filesize)",
      "85:   {",
      "86:    LONGSEEK(mp4->mediafp, offset, SEEK_CUR);",
      "87:    mp4->filepos += offset;",
      "88:   }",
      "89:   else",
      "90:   {",
      "91:    mp4->filepos = mp4->filesize;",
      "92:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "116:  memset(mp4, 0, sizeof(mp4object));",
      "118: #ifdef _WINDOWS",
      "119:  fopen_s(&mp4->mediafp, filename, \"rb\");",
      "120: #else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "124:  struct stat64 mp4stat;",
      "125:  stat64(filename, &mp4stat);",
      "126:  mp4->filesize = mp4stat.st_size;",
      "128:  if (mp4->filesize < 64) return 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "129:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
      "130:   uint64_t lastsize = 0, qtsize;",
      "132:   do",
      "133:   {",
      "134:    len = fread(&qtsize32, 1, 4, mp4->mediafp);",
      "135:    len += fread(&qttag, 1, 4, mp4->mediafp);",
      "137:    {",
      "138:     if (!VALID_FOURCC(qttag))",
      "139:     {",
      "144:     }",
      "146:     qtsize32 = BYTESWAP32(qtsize32);",
      "148:     if (qtsize32 == 1) // 64-bit Atom",
      "149:     {",
      "151:      qtsize = BYTESWAP64(qtsize) - 8;",
      "152:     }",
      "153:     else",
      "",
      "[Removed Lines]",
      "136:    if (len == 8)",
      "140:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
      "142:      NESTSIZE(lastsize - 8);",
      "143:      continue;",
      "150:      fread(&qtsize, 1, 8, mp4->mediafp);",
      "",
      "[Added Lines]",
      "149:    mp4->filepos += len;",
      "150:    if (len == 8 && mp4->filepos < mp4->filesize)",
      "154:      CloseSource((size_t)mp4);",
      "155:      mp4 = NULL;",
      "156:      break;",
      "163:      len = fread(&qtsize, 1, 8, mp4->mediafp);",
      "164:      mp4->filepos += len;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "169:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
      "170:      qttag == MAKEID('f', 't', 'y', 'p') ||",
      "172:     {",
      "175:      NESTSIZE(qtsize);",
      "",
      "[Removed Lines]",
      "171:      qttag == MAKEID('u', 'd', 't', 'a'))",
      "173:      LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "185:      qttag == MAKEID('u', 'd', 't', 'a') ||",
      "186:      qttag == MAKEID('f', 'r', 'e', 'e'))",
      "188:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "187:      qttag != MAKEID('d', 'i', 'n', 'f') &&",
      "188:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "189:      qttag != MAKEID('s', 't', 's', 'd') &&",
      "192:      qttag != MAKEID('s', 't', 'b', 'l') &&",
      "193:      qttag != MAKEID('s', 't', 't', 's') &&",
      "194:      qttag != MAKEID('s', 't', 's', 'c') &&",
      "",
      "[Removed Lines]",
      "190:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "191:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "197:      qttag != MAKEID('c', 'o', '6', '4') &&",
      "198:      qttag != MAKEID('h', 'd', 'l', 'r'))",
      "199:     {",
      "202:      NESTSIZE(qtsize);",
      "203:     }",
      "",
      "[Removed Lines]",
      "200:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "213:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "210:       len += fread(&skip, 1, 4, mp4->mediafp);",
      "211:       len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);",
      "212:       len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);",
      "215:       NESTSIZE(qtsize);",
      "216:      }",
      "",
      "[Removed Lines]",
      "213:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
      "",
      "[Added Lines]",
      "227:       mp4->filepos += len;",
      "228:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "233:         mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);",
      "234:        }",
      "235:       }",
      "238:       NESTSIZE(qtsize);",
      "239:      }",
      "",
      "[Removed Lines]",
      "236:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
      "",
      "[Added Lines]",
      "252:       mp4->filepos += len;",
      "253:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "244:       len += fread(&skip, 1, 4, mp4->mediafp);",
      "245:       len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.",
      "248:        type = temp;",
      "252:       NESTSIZE(qtsize);",
      "",
      "[Removed Lines]",
      "247:       if (temp != MAKEID('a', 'l', 'i', 's'))",
      "250:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr",
      "",
      "[Added Lines]",
      "264:       if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))",
      "267:       mp4->filepos += len;",
      "268:       LongSeek(mp4, qtsize - 8 - len); // skip over hldr",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "267:          type = 0; // MP4",
      "268:         }",
      "269:        }",
      "271:       }",
      "272:       else",
      "275:       NESTSIZE(qtsize);",
      "276:      }",
      "",
      "[Removed Lines]",
      "270:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd",
      "273:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "288:        mp4->filepos += len;",
      "289:        LongSeek(mp4, qtsize - 8 - len); // skip over stsd",
      "292:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "286:        {",
      "287:         mp4->metastsc_count = num;",
      "288:         if (mp4->metastsc) free(mp4->metastsc);",
      "291:         {",
      "296:          {",
      "305:         {",
      "309:         }",
      "310:        }",
      "312:       }",
      "313:       else",
      "316:       NESTSIZE(qtsize);",
      "317:      }",
      "",
      "[Removed Lines]",
      "289:         mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
      "290:         if (mp4->metastsc)",
      "292:          uint32_t total_stsc = num;",
      "293:          len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
      "295:          do",
      "297:           num--;",
      "298:           mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
      "299:           mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
      "300:           mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
      "301:          } while (num > 0);",
      "302:         }",
      "304:         if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
      "306:          if (mp4->metastsc) free(mp4->metastsc);",
      "307:          mp4->metastsc = NULL;",
      "308:          mp4->metastsc_count = 0;",
      "311:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx",
      "314:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "308:         if (num > 0)",
      "310:          mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));",
      "311:          if (mp4->metastsc)",
      "313:           len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
      "315:           do",
      "316:           {",
      "317:            num--;",
      "318:            mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
      "319:            mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
      "320:            mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
      "321:           } while (num > 0);",
      "322:          }",
      "323:         }",
      "324:         else",
      "327:          CloseSource((size_t)mp4);",
      "328:          mp4 = NULL;",
      "329:          break;",
      "332:        mp4->filepos += len;",
      "333:        LongSeek(mp4, qtsize - 8 - len); // skip over stsx",
      "336:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "330:        {",
      "331:         mp4->metasize_count = num;",
      "332:         if (mp4->metasizes) free(mp4->metasizes);",
      "335:         {",
      "337:          {",
      "340:           {",
      "349:           {",
      "353:          }",
      "354:         }",
      "355:        }",
      "357:       }",
      "358:       else",
      "361:       NESTSIZE(qtsize);",
      "362:      }",
      "",
      "[Removed Lines]",
      "333:         mp4->metasizes = (uint32_t *)malloc(num * 4);",
      "334:         if (mp4->metasizes)",
      "336:          if (equalsamplesize == 0)",
      "338:           len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
      "339:           do",
      "341:            num--;",
      "342:            mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
      "343:           } while (num > 0);",
      "344:          }",
      "345:          else",
      "346:          {",
      "347:           equalsamplesize = BYTESWAP32(equalsamplesize);",
      "348:           do",
      "350:            num--;",
      "351:            mp4->metasizes[num] = equalsamplesize;",
      "352:           } while (num > 0);",
      "356:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
      "359:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "355:         if(num > 0)",
      "357:          mp4->metasizes = (uint32_t *)malloc(num * 4);",
      "358:          if (mp4->metasizes)",
      "360:           if (equalsamplesize == 0)",
      "362:            len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
      "363:            do",
      "364:            {",
      "365:             num--;",
      "366:             mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
      "367:            } while (num > 0);",
      "368:           }",
      "369:           else",
      "371:            equalsamplesize = BYTESWAP32(equalsamplesize);",
      "372:            do",
      "373:            {",
      "374:             num--;",
      "375:             mp4->metasizes[num] = equalsamplesize;",
      "376:            } while (num > 0);",
      "377:           }",
      "380:         else",
      "381:         {",
      "383:          CloseSource((size_t)mp4);",
      "384:          mp4 = NULL;",
      "385:          break;",
      "386:         }",
      "388:        mp4->filepos += len;",
      "389:        LongSeek(mp4, qtsize - 8 - len); // skip over stsz",
      "392:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "369:        num = BYTESWAP32(num);",
      "370:        if (num * 4 <= qtsize - 8 - len)",
      "371:        {",
      "372:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
      "373:         {",
      "375:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "378:          {",
      "382:           {",
      "397:            {",
      "399:             {",
      "411:             {",
      "414:             }",
      "421:            }",
      "428:           }",
      "429:          }",
      "430:         }",
      "431:         else",
      "432:         {",
      "433:          mp4->indexcount = num;",
      "434:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "437:          {",
      "441:           {",
      "445:            {",
      "451:           }",
      "452:          }",
      "453:         }",
      "454:        }",
      "456:       }",
      "457:       else",
      "460:       NESTSIZE(qtsize);",
      "461:      }",
      "",
      "[Removed Lines]",
      "374:          mp4->indexcount = mp4->metasize_count;",
      "376:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "377:          if (mp4->metaoffsets)",
      "379:           uint32_t *metaoffsets32 = NULL;",
      "380:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "381:           if (metaoffsets32)",
      "383:            uint64_t fileoffset = 0;",
      "384:            int stsc_pos = 0;",
      "385:            int stco_pos = 0;",
      "386:            int repeat = 1;",
      "387:            len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "388:            do",
      "389:            {",
      "390:             num--;",
      "391:             metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
      "392:            } while (num > 0);",
      "394:            mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
      "395:            num = 1;",
      "396:            while (num < mp4->metasize_count)",
      "398:             if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)",
      "400:              stco_pos++; stsc_pos++;",
      "401:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "402:              repeat = 1;",
      "403:             }",
      "404:             else if (repeat == mp4->metastsc[stsc_pos].samples)",
      "405:             {",
      "406:              stco_pos++;",
      "407:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "408:              repeat = 1;",
      "409:             }",
      "410:             else",
      "412:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "413:              repeat++;",
      "416:             mp4->metaoffsets[num] = fileoffset;",
      "420:             num++;",
      "423:            if (mp4->metastsc) free(mp4->metastsc);",
      "424:            mp4->metastsc = NULL;",
      "425:            mp4->metastsc_count = 0;",
      "427:            free(metaoffsets32);",
      "435:          mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "436:          if (mp4->metaoffsets)",
      "438:           uint32_t *metaoffsets32 = NULL;",
      "439:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "440:           if (metaoffsets32)",
      "442:            size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "443:            len += readlen;",
      "444:            do",
      "446:             num--;",
      "447:             mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
      "448:            } while (num > 0);",
      "450:            free(metaoffsets32);",
      "455:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "458:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "405:         uint32_t metastco_count = num;",
      "409:          mp4->indexcount = num;",
      "411:          if(num > 0)",
      "413:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "414:           if (mp4->metaoffsets)",
      "416:            uint32_t *metaoffsets32 = NULL;",
      "417:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "418:            if (metaoffsets32)",
      "420:             uint64_t fileoffset = 0;",
      "421:             int stsc_pos = 0;",
      "422:             int stco_pos = 0;",
      "423:             int repeat = 1;",
      "424:             len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "425:             do",
      "427:              num--;",
      "428:              metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
      "429:             } while (num > 0);",
      "431:             mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
      "432:             num = 1;",
      "433:             while (num < mp4->indexcount)",
      "435:              if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)",
      "436:              {",
      "437:               if ((uint32_t)stco_pos + 1 < metastco_count)",
      "438:               {",
      "439:                stco_pos++;",
      "440:                fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "441:               }",
      "442:               else",
      "443:               {",
      "444:                fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "445:               }",
      "446:               if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)",
      "447:                if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)",
      "448:                 stsc_pos++;",
      "450:               repeat = 1;",
      "451:              }",
      "452:              else",
      "453:              {",
      "454:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "455:               repeat++;",
      "456:              }",
      "458:              mp4->metaoffsets[num] = fileoffset;",
      "462:              num++;",
      "465:             if (mp4->metastsc) free(mp4->metastsc);",
      "466:             mp4->metastsc = NULL;",
      "467:             mp4->metastsc_count = 0;",
      "469:             free(metaoffsets32);",
      "473:          else",
      "474:          {",
      "476:           CloseSource((size_t)mp4);",
      "477:           mp4 = NULL;",
      "478:           break;",
      "479:          }",
      "485:          if (num > 0)",
      "487:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "488:           if (mp4->metaoffsets)",
      "490:            uint32_t *metaoffsets32 = NULL;",
      "491:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "492:            if (metaoffsets32)",
      "494:             size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "495:             len += readlen;",
      "496:             do",
      "497:             {",
      "498:              num--;",
      "499:              mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
      "500:             } while (num > 0);",
      "502:             free(metaoffsets32);",
      "503:            }",
      "506:          else",
      "507:          {",
      "509:           CloseSource((size_t)mp4);",
      "510:           mp4 = NULL;",
      "511:           break;",
      "512:          }",
      "515:        mp4->filepos += len;",
      "516:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "519:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "467:        len = fread(&skip, 1, 4, mp4->mediafp);",
      "468:        len += fread(&num, 1, 4, mp4->mediafp);",
      "469:        num = BYTESWAP32(num);",
      "470:        if (num * 8 <= qtsize - 8 - len)",
      "471:        {",
      "472:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
      "473:         {",
      "474:          mp4->indexcount = mp4->metasize_count;",
      "475:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "478:          {",
      "482:           {",
      "488:            {",
      "506:             {",
      "508:             }",
      "515:            }",
      "522:           }",
      "523:          }",
      "524:         }",
      "525:         else",
      "526:         {",
      "",
      "[Removed Lines]",
      "476:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "477:          if (mp4->metaoffsets)",
      "479:           uint64_t *metaoffsets64 = NULL;",
      "480:           metaoffsets64 = (uint64_t *)malloc(num * 8);",
      "481:           if (metaoffsets64)",
      "483:            uint64_t fileoffset = 0;",
      "484:            int stsc_pos = 0;",
      "485:            int stco_pos = 0;",
      "486:            len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
      "487:            do",
      "489:             num--;",
      "490:             metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
      "491:            } while (num > 0);",
      "493:            fileoffset = metaoffsets64[0];",
      "494:            mp4->metaoffsets[0] = fileoffset;",
      "497:            num = 1;",
      "498:            while (num < mp4->metasize_count)",
      "499:            {",
      "500:             if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
      "501:             {",
      "502:              stco_pos++;",
      "503:              fileoffset = (uint64_t)metaoffsets64[stco_pos];",
      "504:             }",
      "505:             else",
      "507:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "510:             mp4->metaoffsets[num] = fileoffset;",
      "514:             num++;",
      "517:            if (mp4->metastsc) free(mp4->metastsc);",
      "518:            mp4->metastsc = NULL;",
      "519:            mp4->metastsc_count = 0;",
      "521:            free(metaoffsets64);",
      "",
      "[Added Lines]",
      "532:        if(num == 0)",
      "533:        {",
      "535:         CloseSource((size_t)mp4);",
      "536:         mp4 = NULL;",
      "537:         break;",
      "538:        }",
      "546:          if (mp4->metasize_count)",
      "548:           mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "549:           if (mp4->metaoffsets)",
      "551:            uint64_t *metaoffsets64 = NULL;",
      "552:            metaoffsets64 = (uint64_t *)malloc(num * 8);",
      "553:            if (metaoffsets64)",
      "555:             uint64_t fileoffset = 0;",
      "556:             int stsc_pos = 0;",
      "557:             int stco_pos = 0;",
      "558:             len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
      "559:             do",
      "560:             {",
      "561:              num--;",
      "562:              metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
      "563:             } while (num > 0);",
      "565:             fileoffset = metaoffsets64[0];",
      "566:             mp4->metaoffsets[0] = fileoffset;",
      "569:             num = 1;",
      "570:             while (num < mp4->metasize_count)",
      "572:              if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
      "573:              {",
      "574:               stco_pos++;",
      "575:               fileoffset = (uint64_t)metaoffsets64[stco_pos];",
      "576:              }",
      "577:              else",
      "578:              {",
      "579:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "580:              }",
      "582:              mp4->metaoffsets[num] = fileoffset;",
      "586:              num++;",
      "589:             if (mp4->metastsc) free(mp4->metastsc);",
      "590:             mp4->metastsc = NULL;",
      "591:             mp4->metastsc_count = 0;",
      "593:             free(metaoffsets64);",
      "597:          else",
      "598:          {",
      "600:           CloseSource((size_t)mp4);",
      "601:           mp4 = NULL;",
      "602:           break;",
      "603:          }",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "538:          }",
      "539:         }",
      "540:        }",
      "542:       }",
      "543:       else",
      "546:       NESTSIZE(qtsize);",
      "547:      }",
      "",
      "[Removed Lines]",
      "541:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "544:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "621:        mp4->filepos += len;",
      "622:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "625:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "578:         }",
      "579:         mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
      "580:        }",
      "582:       }",
      "583:       else",
      "586:       NESTSIZE(qtsize);",
      "587:      }",
      "",
      "[Removed Lines]",
      "581:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "584:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "662:        mp4->filepos += len;",
      "663:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "666:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "595:     break;",
      "596:    }",
      "597:   } while (len > 0);",
      "598:  }",
      "599:  else",
      "600:  {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "681:   if (mp4)",
      "682:   {",
      "683:    if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)",
      "684:    {",
      "685:     CloseSource((size_t)mp4);",
      "686:     mp4 = NULL;",
      "687:    }",
      "688:   }",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "631: }",
      "635: {",
      "636:  mp4object *mp4 = (mp4object *)handle;",
      "644: }",
      "649: size_t OpenMP4SourceUDTA(char *filename)",
      "650: {",
      "",
      "[Removed Lines]",
      "634: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)",
      "637:  if (mp4 == NULL) return 0;",
      "639:  if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;",
      "643:  return 0;",
      "",
      "[Added Lines]",
      "725: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)",
      "728:  if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
      "730:  if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;",
      "734:  return GPMF_OK;",
      "738: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)",
      "739: {",
      "740:     mp4object *mp4 = (mp4object *)handle;",
      "741:     if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
      "743:     if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;",
      "749:     return GPMF_OK;",
      "750: }",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "662:  if (mp4->mediafp)",
      "663:  {",
      "665:   int32_t nest = 0;",
      "666:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
      "667:   uint64_t lastsize = 0, qtsize;",
      "",
      "[Removed Lines]",
      "664:   uint32_t qttag, qtsize32, len;",
      "",
      "[Added Lines]",
      "767:   uint32_t qttag, qtsize32;",
      "768:   size_t len;",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "674:    {",
      "675:     if (!GPMF_VALID_FOURCC(qttag))",
      "676:     {",
      "679:      NESTSIZE(lastsize - 8);",
      "680:      continue;",
      "",
      "[Removed Lines]",
      "677:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "781:      LongSeek(mp4, lastsize - 8 - 8);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "701:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
      "702:      qttag == MAKEID('f', 't', 'y', 'p'))",
      "703:     {",
      "705:      NESTSIZE(qtsize);",
      "706:      continue;",
      "707:     }",
      "",
      "[Removed Lines]",
      "704:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "808:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "725:     if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms",
      "726:      qttag != MAKEID('u', 'd', 't', 'a'))",
      "727:     {",
      "729:      NESTSIZE(qtsize);",
      "730:      continue;",
      "731:     }",
      "",
      "[Removed Lines]",
      "728:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "832:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "740: }",
      "744: {",
      "745:  mp4object *mp4 = (mp4object *)handle;",
      "746:  if (mp4 == NULL) return 0.0;",
      "",
      "[Removed Lines]",
      "743: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)",
      "",
      "[Added Lines]",
      "847: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "750:  uint32_t testend = mp4->indexcount;",
      "751:  double rate = 0.0;",
      "753:  if (mp4->indexcount < 1)",
      "754:   return 0.0;",
      "766:  if (ret != GPMF_OK)",
      "767:   goto cleanup;",
      "769:  {",
      "770:   uint32_t startsamples = 0;",
      "771:   uint32_t endsamples = 0;",
      "775:   {",
      "777:    teststart++;",
      "778:    payload = GetPayload(handle, payload, teststart); // second last payload",
      "779:    payloadsize = GetPayloadSize(handle, teststart);",
      "780:    ret = GPMF_Init(ms, payload, payloadsize);",
      "781:   }",
      "792:   {",
      "794:    GPMF_stream find_stream;",
      "795:    GPMF_CopyState(ms, &find_stream);",
      "798:    {",
      "802:     payloadsize = GetPayloadSize(handle, testend);",
      "803:     ret = GPMF_Init(ms, payload, payloadsize);",
      "808:     {",
      "811:      {",
      "815:      }",
      "816:     }",
      "819:    }",
      "821:    {",
      "830:     {",
      "839:      {",
      "844:       {",
      "850:         {",
      "867:        {",
      "875:        }",
      "876:       }",
      "877:      }",
      "889:      {",
      "899: #if 0",
      "901:      {",
      "905:      }",
      "917:    }",
      "952:  }",
      "969:  return rate;",
      "970: }",
      "",
      "[Removed Lines]",
      "756:  if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies.",
      "757:  {",
      "758:   teststart++;",
      "759:   testend--;",
      "760:  }",
      "762:  uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload",
      "763:  uint32_t payloadsize = GetPayloadSize(handle, teststart);",
      "764:  int32_t ret = GPMF_Init(ms, payload, payloadsize);",
      "772:   uint32_t missing_samples = 0;",
      "774:   while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "776:    missing_samples = 1;",
      "783:   if (missing_samples)",
      "784:   {",
      "785:    teststart++;   //samples after sensor start are statistically the best",
      "786:    payload = GetPayload(handle, payload, teststart);",
      "787:    payloadsize = GetPayloadSize(handle, teststart);",
      "788:    ret = GPMF_Init(ms, payload, payloadsize);",
      "789:   }",
      "791:   if (ret == GPMF_OK)",
      "793:    uint32_t samples = GPMF_Repeat(ms);",
      "797:    if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "799:     startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;",
      "801:     payload = GetPayload(handle, payload, testend); // second last payload",
      "804:     if (ret != GPMF_OK)",
      "805:      goto cleanup;",
      "807:     if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "809:      GPMF_CopyState(ms, &find_stream);",
      "810:      if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "812:       endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "813:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "814:       goto cleanup;",
      "818:     rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "820:    else // for increased precision, for older GPMF streams sometimes missing the total sample count",
      "822:     uint32_t payloadpos = 0, payloadcount = 0;",
      "823:     double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
      "824:     uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
      "825:     memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
      "827:     samples = 0;",
      "829:     for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)",
      "831:      payload = GetPayload(handle, payload, payloadpos); // second last payload",
      "832:      payloadsize = GetPayloadSize(handle, payloadpos);",
      "833:      ret = GPMF_Init(ms, payload, payloadsize);",
      "835:      if (ret != GPMF_OK)",
      "836:       goto cleanup;",
      "838:      if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "840:       GPMF_stream find_stream2;",
      "841:       GPMF_CopyState(ms, &find_stream2);",
      "843:       if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats",
      "845:        if (repeatarray)",
      "846:        {",
      "847:         float in, out;",
      "849:         do",
      "851:          samples++;",
      "852:         } while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));",
      "854:         repeatarray[payloadpos] = samples;",
      "855:         meanY += (double)samples;",
      "857:         GetPayloadTime(handle, payloadpos, &in, &out);",
      "858:         meanX += out;",
      "859:        }",
      "860:       }",
      "861:       else",
      "862:       {",
      "863:        uint32_t repeat = GPMF_Repeat(ms);",
      "864:        samples += repeat;",
      "866:        if (repeatarray)",
      "868:         float in, out;",
      "870:         repeatarray[payloadpos] = samples;",
      "871:         meanY += (double)samples;",
      "873:         GetPayloadTime(handle, payloadpos, &in, &out);",
      "874:         meanX += out;",
      "878:     }",
      "883:     if (repeatarray)",
      "884:     {",
      "885:      meanY /= (double)payloadcount;",
      "886:      meanX /= (double)payloadcount;",
      "888:      for (payloadpos = teststart; payloadpos < testend; payloadpos++)",
      "890:       float in, out;",
      "891:       GetPayloadTime(handle, payloadpos, &in, &out);",
      "893:       top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);",
      "894:       bot += ((double)out - meanX)*((double)out - meanX);",
      "895:      }",
      "897:      slope = top / bot;",
      "902:       double intercept;",
      "903:       intercept = meanY - slope*meanX;",
      "904:       printf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);",
      "906: #endif",
      "907:      rate = slope;",
      "908:     }",
      "909:     else",
      "910:     {",
      "911:      rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "912:     }",
      "914:     free(repeatarray);",
      "916:     goto cleanup;",
      "918:   }",
      "919:  }",
      "921: cleanup:",
      "922:  if (payload)",
      "923:  {",
      "924:   FreePayload(payload);",
      "925:   payload = NULL;",
      "926:  }",
      "928:  return rate;",
      "929: }",
      "932: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)",
      "933: {",
      "934:  mp4object *mp4 = (mp4object *)handle;",
      "935:  if (mp4 == NULL) return 0.0;",
      "937:  uint32_t key, insamples;",
      "938:  uint32_t repeat, outsamples;",
      "939:  GPMF_stream find_stream;",
      "941:  if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;",
      "943:  key = GPMF_Key(gs);",
      "944:  repeat = GPMF_Repeat(gs);",
      "945:  if (rate == 0.0)",
      "946:   rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);",
      "948:  if (rate == 0.0)",
      "949:  {",
      "951:   return 0.0;",
      "954:  GPMF_CopyState(gs, &find_stream);",
      "955:  if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "956:  {",
      "957:   outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "958:   insamples = outsamples - repeat;",
      "962:  }",
      "963:  else",
      "964:  {",
      "968:  }",
      "",
      "[Added Lines]",
      "857:  uint32_t *payload;",
      "858:  uint32_t payloadsize;",
      "859:  int32_t ret;",
      "864:  payload = GetPayload(handle, NULL, teststart);",
      "865:  payloadsize = GetPayloadSize(handle, teststart);",
      "866:  ret = GPMF_Init(ms, payload, payloadsize);",
      "872:   uint64_t minimumtimestamp = 0;",
      "873:   uint64_t starttimestamp = 0;",
      "874:   uint64_t endtimestamp = 0;",
      "877:   double intercept = 0.0;",
      "881:   while (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "889:   if (ret == GPMF_OK && payload)",
      "891:    uint32_t samples = GPMF_PayloadSampleCount(ms);",
      "894:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "895:     startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;",
      "897:    GPMF_CopyState(ms, &find_stream);",
      "898:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))",
      "899:     starttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));",
      "901:    if (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.",
      "903:     GPMF_stream any_stream;",
      "904:     GPMF_Init(&any_stream, payload, payloadsize);",
      "906:     minimumtimestamp = starttimestamp;",
      "907:     while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))",
      "908:     {",
      "909:      uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));",
      "910:      if (timestamp < minimumtimestamp)",
      "911:       minimumtimestamp = timestamp;",
      "912:     }",
      "913:    }",
      "915:    testend = mp4->indexcount;",
      "916:    do",
      "917:    {",
      "918:     testend--;// last payload with the fourcc needed",
      "919:     payload = GetPayload(handle, payload, testend);",
      "922:    } while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
      "924:    GPMF_CopyState(ms, &find_stream);",
      "925:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "926:     endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "927:    else // If there is no TSMP we have to count the samples.",
      "928:    {",
      "929:     uint32_t i;",
      "930:     for (i = teststart; i <= testend; i++)",
      "932:      payload = GetPayload(handle,payload, i); // second last payload",
      "933:      payloadsize = GetPayloadSize(handle, i);",
      "934:      if (GPMF_OK == GPMF_Init(ms, payload, payloadsize))",
      "935:       if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "936:        endsamples += GPMF_PayloadSampleCount(ms);",
      "937:     }",
      "938:    }",
      "940:    if (starttimestamp != 0)",
      "941:    {",
      "942:     uint32_t last_samples = GPMF_PayloadSampleCount(ms);",
      "943:     uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;",
      "944:     double time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.",
      "946:     GPMF_CopyState(ms, &find_stream);",
      "947:     if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))",
      "948:      endtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));",
      "950:     if (endtimestamp)",
      "951:     {",
      "952:      double approxrate = 0.0;",
      "953:      if (endsamples > startsamples)",
      "954:       approxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "956:      if (approxrate == 0.0)",
      "957:       approxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "960:      while (time_stamp_scale >= 1)",
      "962:       rate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);",
      "963:       if (rate*0.9 < approxrate && approxrate < rate*1.1)",
      "964:        break;",
      "966:       time_stamp_scale *= 0.1;",
      "968:      if (time_stamp_scale < 1.0) rate = 0.0;",
      "969:      intercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;",
      "973:    if (rate == 0.0) //Timestamps didn't help weren't available",
      "975:     if (!(flags & GPMF_SAMPLE_RATE_PRECISE))",
      "976:     {",
      "977:      if (endsamples > startsamples)",
      "978:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "980:      if (rate == 0.0)",
      "981:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "983:      double in, out;",
      "984:      if (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))",
      "985:       intercept = (double)-in * rate;",
      "986:     }",
      "987:     else // for increased precision, for older GPMF streams sometimes missing the total sample count",
      "989:      uint32_t payloadpos = 0, payloadcount = 0;",
      "990:      double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
      "991:      uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
      "992:      memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
      "994:      samples = 0;",
      "996:      for (payloadpos = teststart; payloadpos <= testend; payloadpos++)",
      "998:       payload = GetPayload(handle, payload, payloadpos); // second last payload",
      "999:       payloadsize = GetPayloadSize(handle, payloadpos);",
      "1000:       ret = GPMF_Init(ms, payload, payloadsize);",
      "1002:       if (ret != GPMF_OK)",
      "1003:        goto cleanup;",
      "1005:       if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "1007:        GPMF_stream find_stream2;",
      "1008:        GPMF_CopyState(ms, &find_stream2);",
      "1010:        payloadcount++;",
      "1012:        if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats",
      "1013:        {",
      "1014:         if (repeatarray)",
      "1016:          double in, out;",
      "1018:          do",
      "1019:          {",
      "1020:           samples++;",
      "1021:          } while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));",
      "1023:          repeatarray[payloadpos] = samples;",
      "1024:          meanY += (double)samples;",
      "1026:          if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1027:           meanX += out;",
      "1028:         }",
      "1029:        }",
      "1030:        else",
      "1032:         uint32_t repeat = GPMF_PayloadSampleCount(ms);",
      "1033:         samples += repeat;",
      "1035:         if (repeatarray)",
      "1036:         {",
      "1037:          double in, out;",
      "1039:          repeatarray[payloadpos] = samples;",
      "1040:          meanY += (double)samples;",
      "1042:          if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1043:           meanX += out;",
      "1044:         }",
      "1047:       else",
      "1048:       {",
      "1049:        repeatarray[payloadpos] = 0;",
      "1050:       }",
      "1056:      if (repeatarray)",
      "1058:       meanY /= (double)payloadcount;",
      "1059:       meanX /= (double)payloadcount;",
      "1061:       for (payloadpos = teststart; payloadpos <= testend; payloadpos++)",
      "1062:       {",
      "1063:        double in, out;",
      "1064:        if (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1065:        {",
      "1066:         top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);",
      "1067:         bot += ((double)out - meanX)*((double)out - meanX);",
      "1068:        }",
      "1069:       }",
      "1071:       slope = top / bot;",
      "1072:       rate = slope;",
      "1075:       intercept = meanY - slope * meanX;",
      "1077:       printf(\"%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);",
      "1078:       printf(\"%c%c%c%c first sample at time %.3fms\\n\", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);",
      "1079: #endif",
      "1080:      }",
      "1081:      else",
      "1083:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "1086:      free(repeatarray);",
      "1087:     }",
      "1090:    if (firstsampletime && lastsampletime)",
      "1091:    {",
      "1092:     uint32_t endpayload = mp4->indexcount;",
      "1093:     do",
      "1094:     {",
      "1095:      endpayload--;// last payload with the fourcc needed",
      "1096:      payload = GetPayload(handle, payload, endpayload);",
      "1097:      payloadsize = GetPayloadSize(handle, endpayload);",
      "1098:      ret = GPMF_Init(ms, payload, payloadsize);",
      "1099:     } while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
      "1101:     if (endpayload > 0 && ret == GPMF_OK)",
      "1102:     {",
      "1103:      uint32_t totalsamples = endsamples - startsamples;",
      "1104:      float timo = 0.0;",
      "1106:      GPMF_CopyState(ms, &find_stream);",
      "1107:      if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))",
      "1108:       GPMF_FormattedData(&find_stream, &timo, 4, 0, 1);",
      "1110:      double first, last;",
      "1111:      first = -intercept / rate - timo;",
      "1112:      last = first + (double)totalsamples / rate;",
      "1116:      if (firstsampletime) *firstsampletime = first;",
      "1118:      if (lastsampletime) *lastsampletime = last;",
      "1119:     }",
      "1120:    }",
      "1121:   }",
      "1124: cleanup:",
      "1125:  if (payload)",
      "1126:   FreePayload(payload);",
      "1127:  payload = NULL;",
      "",
      "---------------"
    ],
    "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h": [
      "File: demo/GPMF_mp4reader.h -> demo/GPMF_mp4reader.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "64:  uint32_t meta_clockdemon, meta_clockcount;",
      "65:  double basemetadataduration;",
      "66:  FILE *mediafp;",
      "67: } mp4object;",
      "69: #define MAKEID(a,b,c,d)   (((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "67:  uint64_t filesize;",
      "68:  uint64_t filepos;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "101: float GetDuration(size_t handle);",
      "102: uint32_t GetNumberPayloads(size_t handle);",
      "103: uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);",
      "105: void FreePayload(uint32_t *lastpayload);",
      "106: uint32_t GetPayloadSize(size_t handle, uint32_t index);",
      "109: #define GPMF_SAMPLE_RATE_FAST  0",
      "110: #define GPMF_SAMPLE_RATE_PRECISE 1",
      "115: #ifdef __cplusplus",
      "116: }",
      "",
      "[Removed Lines]",
      "104: void SavePayload(size_t handle, uint32_t *payload, uint32_t index);",
      "107: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload",
      "112: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);",
      "113: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed",
      "",
      "[Added Lines]",
      "108: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload",
      "109: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);",
      "114: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *in, double *out);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e6ec456fbf393d8b60b76c4246c5eb576f8668ce",
      "candidate_info": {
        "commit_hash": "e6ec456fbf393d8b60b76c4246c5eb576f8668ce",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/e6ec456fbf393d8b60b76c4246c5eb576f8668ce",
        "files": [
          "GPMF_parser.c",
          "GPMF_parser.h",
          "demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c",
          "demo/GPMF_mp4reader.h"
        ],
        "message": "fixed many security issues with the too crude mp4 reader",
        "before_after_code_files": [
          "GPMF_parser.c||GPMF_parser.c",
          "GPMF_parser.h||GPMF_parser.h",
          "demo/GPMF_demo.c||demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
          "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "GPMF_parser.c||GPMF_parser.c",
            "GPMF_parser.h||GPMF_parser.h",
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
            "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
          ],
          "candidate": [
            "GPMF_parser.c||GPMF_parser.c",
            "GPMF_parser.h||GPMF_parser.h",
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
            "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
          ]
        }
      },
      "candidate_diff": {
        "GPMF_parser.c||GPMF_parser.c": [
          "File: GPMF_parser.c -> GPMF_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1435:      case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_NOSWAP_CAST_SCALE(uint16_t) break;",
          "1436:      case GPMF_TYPE_SIGNED_LONG:  MACRO_NOSWAP_CAST_SCALE(int32_t) break;",
          "1437:      case GPMF_TYPE_UNSIGNED_LONG:  MACRO_NOSWAP_CAST_SCALE(uint32_t) break;",
          "1439:      case GPMF_TYPE_UNSIGNED_64BIT_INT:  MACRO_NOSWAP_CAST_SCALE(uint64_t) break;",
          "1440:      default:",
          "1441:       ret = GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "1438:      case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_NOSWAP_CAST_SCALE(uint64_t) break;",
          "",
          "[Added Lines]",
          "1438:      case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_NOSWAP_CAST_SCALE(int64_t) break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1454:      case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, uint16_t, uint16_t) break;",
          "1455:      case GPMF_TYPE_SIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, int32_t, uint32_t) break;",
          "1456:      case GPMF_TYPE_UNSIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, uint32_t, uint32_t) break;",
          "1458:      case GPMF_TYPE_UNSIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;",
          "1459:      default:",
          "1460:       ret = GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "1457:      case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;",
          "",
          "[Added Lines]",
          "1457:      case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, int64_t, uint64_t) break;",
          "",
          "---------------"
        ],
        "GPMF_parser.h||GPMF_parser.h": [
          "File: GPMF_parser.h -> GPMF_parser.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #ifndef _GPMF_PARSER_H",
          "23: #define _GPMF_PARSER_H",
          "25: #include \"GPMF_common.h\"",
          "27: #ifdef __cplusplus",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include <stdint.h>",
          "",
          "---------------"
        ],
        "demo/GPMF_demo.c||demo/GPMF_demo.c": [
          "File: demo/GPMF_demo.c -> demo/GPMF_demo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:  }",
          "48:  size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);",
          "51:  metadatalength = GetDuration(mp4);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49:  if (mp4 == 0)",
          "50:  {",
          "51:   printf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);",
          "52:   return -1;",
          "53:  }",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #include <stdio.h>",
          "26: #include <string.h>",
          "27: #include <stdint.h>",
          "29: #include \"GPMF_mp4reader.h\"",
          "30: #include \"../GPMF_common.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <sys/types.h>",
          "29: #include <sys/stat.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: #define PRINT_MP4_STRUCTURE  0",
          "34: #ifdef WIN32",
          "36: #else",
          "38: #endif",
          "",
          "[Removed Lines]",
          "35: #define LONGSEEK  _fseeki64",
          "37: #define LONGSEEK  fseeko",
          "",
          "[Added Lines]",
          "37: #define LONGSEEK _fseeki64",
          "38: #define stat64  _stat64",
          "40: #define LONGSEEK fseeko",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:   if (MP4buffer)",
          "65:   {",
          "69:   }",
          "70:  }",
          "71:  return NULL;",
          "72: }",
          "76: {",
          "81:  {",
          "84:  }",
          "86: }",
          "90: void FreePayload(uint32_t *lastpayload)",
          "91: {",
          "92:  if (lastpayload)",
          "",
          "[Removed Lines]",
          "66:    LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
          "67:    fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
          "68:    return MP4buffer;",
          "75: void SavePayload(size_t handle, uint32_t *payload, uint32_t index)",
          "77:  mp4object *mp4 = (mp4object *)handle;",
          "78:  if (mp4 == NULL) return;",
          "80:  if (index < mp4->indexcount && mp4->mediafp && payload)",
          "82:   LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
          "83:   fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);",
          "85:  return;",
          "",
          "[Added Lines]",
          "68:    if (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])",
          "69:    {",
          "70:     LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
          "71:     fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
          "72:     mp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];",
          "73:     return MP4buffer;",
          "74:    }",
          "81: void LongSeek(mp4object *mp4, int64_t offset)",
          "83:  if (mp4 && offset)",
          "85:   if (mp4->filepos + offset < mp4->filesize)",
          "86:   {",
          "87:    LONGSEEK(mp4->mediafp, offset, SEEK_CUR);",
          "88:    mp4->filepos += offset;",
          "89:   }",
          "90:   else",
          "91:   {",
          "92:    mp4->filepos = mp4->filesize;",
          "93:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "115:  memset(mp4, 0, sizeof(mp4object));",
          "117: #ifdef _WINDOWS",
          "118:  fopen_s(&mp4->mediafp, filename, \"rb\");",
          "119: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125:  struct stat64 mp4stat;",
          "126:  stat64(filename, &mp4stat);",
          "127:  mp4->filesize = mp4stat.st_size;",
          "129:  if (mp4->filesize < 64) return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "128:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
          "129:   uint64_t lastsize = 0, qtsize;",
          "131:   do",
          "132:   {",
          "133:    len = fread(&qtsize32, 1, 4, mp4->mediafp);",
          "134:    len += fread(&qttag, 1, 4, mp4->mediafp);",
          "136:    {",
          "137:     if (!VALID_FOURCC(qttag))",
          "138:     {",
          "143:     }",
          "145:     qtsize32 = BYTESWAP32(qtsize32);",
          "147:     if (qtsize32 == 1) // 64-bit Atom",
          "148:     {",
          "150:      qtsize = BYTESWAP64(qtsize) - 8;",
          "151:     }",
          "152:     else",
          "",
          "[Removed Lines]",
          "135:    if (len == 8)",
          "139:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
          "141:      NESTSIZE(lastsize - 8);",
          "142:      continue;",
          "149:      fread(&qtsize, 1, 8, mp4->mediafp);",
          "",
          "[Added Lines]",
          "150:    mp4->filepos += len;",
          "151:    if (len == 8 && mp4->filepos < mp4->filesize)",
          "155:      CloseSource((size_t)mp4);",
          "156:      mp4 = NULL;",
          "157:      break;",
          "164:      len = fread(&qtsize, 1, 8, mp4->mediafp);",
          "165:      mp4->filepos += len;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "170:      qttag == MAKEID('u', 'd', 't', 'a') ||",
          "171:      qttag == MAKEID('f', 'r', 'e', 'e'))",
          "172:     {",
          "175:      NESTSIZE(qtsize);",
          "",
          "[Removed Lines]",
          "173:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "189:      LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "187:      qttag != MAKEID('d', 'i', 'n', 'f') &&",
          "188:      qttag != MAKEID('a', 'l', 'i', 's') &&",
          "189:      qttag != MAKEID('s', 't', 's', 'd') &&",
          "192:      qttag != MAKEID('s', 't', 'b', 'l') &&",
          "193:      qttag != MAKEID('s', 't', 't', 's') &&",
          "194:      qttag != MAKEID('s', 't', 's', 'c') &&",
          "",
          "[Removed Lines]",
          "190:      qttag != MAKEID('a', 'l', 'i', 's') &&",
          "191:      qttag != MAKEID('a', 'l', 'i', 's') &&",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "197:      qttag != MAKEID('c', 'o', '6', '4') &&",
          "198:      qttag != MAKEID('h', 'd', 'l', 'r'))",
          "199:     {",
          "202:      NESTSIZE(qtsize);",
          "203:     }",
          "",
          "[Removed Lines]",
          "200:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "214:      LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "210:       len += fread(&skip, 1, 4, mp4->mediafp);",
          "211:       len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);",
          "212:       len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);",
          "215:       NESTSIZE(qtsize);",
          "216:      }",
          "",
          "[Removed Lines]",
          "213:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
          "",
          "[Added Lines]",
          "228:       mp4->filepos += len;",
          "229:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "233:         mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);",
          "234:        }",
          "235:       }",
          "238:       NESTSIZE(qtsize);",
          "239:      }",
          "",
          "[Removed Lines]",
          "236:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
          "",
          "[Added Lines]",
          "253:       mp4->filepos += len;",
          "254:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "247:       if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))",
          "248:        type = temp;",
          "252:       NESTSIZE(qtsize);",
          "",
          "[Removed Lines]",
          "250:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr",
          "",
          "[Added Lines]",
          "268:       mp4->filepos += len;",
          "269:       LongSeek(mp4, qtsize - 8 - len); // skip over hldr",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "267:          type = 0; // MP4",
          "268:         }",
          "269:        }",
          "271:       }",
          "272:       else",
          "275:       NESTSIZE(qtsize);",
          "276:      }",
          "",
          "[Removed Lines]",
          "270:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd",
          "273:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "289:        mp4->filepos += len;",
          "290:        LongSeek(mp4, qtsize - 8 - len); // skip over stsd",
          "293:        LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "286:        {",
          "287:         mp4->metastsc_count = num;",
          "288:         if (mp4->metastsc) free(mp4->metastsc);",
          "291:         {",
          "295:          {",
          "301:         }",
          "302:        }",
          "304:       }",
          "305:       else",
          "308:       NESTSIZE(qtsize);",
          "309:      }",
          "",
          "[Removed Lines]",
          "289:         mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
          "290:         if (mp4->metastsc)",
          "292:          len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
          "294:          do",
          "296:           num--;",
          "297:           mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
          "298:           mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
          "299:           mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
          "300:          } while (num > 0);",
          "303:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx",
          "306:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "309:         if (num > 0)",
          "311:          mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));",
          "312:          if (mp4->metastsc)",
          "314:           len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
          "316:           do",
          "317:           {",
          "318:            num--;",
          "319:            mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
          "320:            mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
          "321:            mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
          "322:           } while (num > 0);",
          "323:          }",
          "324:         }",
          "325:         else",
          "326:         {",
          "328:          CloseSource((size_t)mp4);",
          "329:          mp4 = NULL;",
          "330:          break;",
          "333:        mp4->filepos += len;",
          "334:        LongSeek(mp4, qtsize - 8 - len); // skip over stsx",
          "337:        LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "322:        {",
          "323:         mp4->metasize_count = num;",
          "324:         if (mp4->metasizes) free(mp4->metasizes);",
          "327:         {",
          "329:          {",
          "332:           {",
          "341:           {",
          "345:          }",
          "346:         }",
          "347:        }",
          "349:       }",
          "350:       else",
          "353:       NESTSIZE(qtsize);",
          "354:      }",
          "",
          "[Removed Lines]",
          "325:         mp4->metasizes = (uint32_t *)malloc(num * 4);",
          "326:         if (mp4->metasizes)",
          "328:          if (equalsamplesize == 0)",
          "330:           len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
          "331:           do",
          "333:            num--;",
          "334:            mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
          "335:           } while (num > 0);",
          "336:          }",
          "337:          else",
          "338:          {",
          "339:           equalsamplesize = BYTESWAP32(equalsamplesize);",
          "340:           do",
          "342:            num--;",
          "343:            mp4->metasizes[num] = equalsamplesize;",
          "344:           } while (num > 0);",
          "348:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "351:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "356:         if(num > 0)",
          "358:          mp4->metasizes = (uint32_t *)malloc(num * 4);",
          "359:          if (mp4->metasizes)",
          "361:           if (equalsamplesize == 0)",
          "363:            len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
          "364:            do",
          "365:            {",
          "366:             num--;",
          "367:             mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
          "368:            } while (num > 0);",
          "369:           }",
          "370:           else",
          "372:            equalsamplesize = BYTESWAP32(equalsamplesize);",
          "373:            do",
          "374:            {",
          "375:             num--;",
          "376:             mp4->metasizes[num] = equalsamplesize;",
          "377:            } while (num > 0);",
          "378:           }",
          "381:         else",
          "382:         {",
          "384:          CloseSource((size_t)mp4);",
          "385:          mp4 = NULL;",
          "386:          break;",
          "387:         }",
          "389:        mp4->filepos += len;",
          "390:        LongSeek(mp4, qtsize - 8 - len); // skip over stsz",
          "393:        LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "366:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "367:         {",
          "369:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "372:          {",
          "376:           {",
          "383:            {",
          "393:             {",
          "395:              {",
          "398:              }",
          "399:              else",
          "400:              {",
          "401:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "402:              }",
          "413:             }",
          "420:            }",
          "427:           }",
          "428:          }",
          "429:         }",
          "430:         else",
          "431:         {",
          "432:          mp4->indexcount = num;",
          "433:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "436:          {",
          "440:           {",
          "444:            {",
          "450:           }",
          "451:          }",
          "452:         }",
          "453:        }",
          "455:       }",
          "456:       else",
          "459:       NESTSIZE(qtsize);",
          "460:      }",
          "",
          "[Removed Lines]",
          "368:          mp4->indexcount = mp4->metasize_count;",
          "370:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "371:          if (mp4->metaoffsets)",
          "373:           uint32_t *metaoffsets32 = NULL;",
          "374:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "375:           if (metaoffsets32)",
          "377:            uint64_t fileoffset = 0;",
          "378:            int stsc_pos = 0;",
          "379:            int stco_pos = 0;",
          "380:            int repeat = 1;",
          "381:            len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "382:            do",
          "384:             num--;",
          "385:             metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
          "386:            } while (num > 0);",
          "388:            mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
          "389:            num = 1;",
          "390:            while (num < mp4->metasize_count)",
          "391:            {",
          "392:             if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)",
          "394:              if ((uint32_t)stco_pos + 1 < metastco_count)",
          "396:               stco_pos++;",
          "397:               fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "403:              if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)",
          "404:               if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)",
          "405:                stsc_pos++;",
          "407:              repeat = 1;",
          "408:             }",
          "409:             else",
          "410:             {",
          "411:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "412:              repeat++;",
          "415:             mp4->metaoffsets[num] = fileoffset;",
          "419:             num++;",
          "422:            if (mp4->metastsc) free(mp4->metastsc);",
          "423:            mp4->metastsc = NULL;",
          "424:            mp4->metastsc_count = 0;",
          "426:            free(metaoffsets32);",
          "434:          mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "435:          if (mp4->metaoffsets)",
          "437:           uint32_t *metaoffsets32 = NULL;",
          "438:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "439:           if (metaoffsets32)",
          "441:            size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "442:            len += readlen;",
          "443:            do",
          "445:             num--;",
          "446:             mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
          "447:            } while (num > 0);",
          "449:            free(metaoffsets32);",
          "454:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "457:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "410:          mp4->indexcount = num;",
          "412:          if(num > 0)",
          "414:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "415:           if (mp4->metaoffsets)",
          "417:            uint32_t *metaoffsets32 = NULL;",
          "418:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "419:            if (metaoffsets32)",
          "421:             uint64_t fileoffset = 0;",
          "422:             int stsc_pos = 0;",
          "423:             int stco_pos = 0;",
          "424:             int repeat = 1;",
          "425:             len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "426:             do",
          "427:             {",
          "428:              num--;",
          "429:              metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
          "430:             } while (num > 0);",
          "432:             mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
          "433:             num = 1;",
          "434:             while (num < mp4->indexcount)",
          "436:              if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)",
          "438:               if ((uint32_t)stco_pos + 1 < metastco_count)",
          "439:               {",
          "440:                stco_pos++;",
          "441:                fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "442:               }",
          "443:               else",
          "444:               {",
          "445:                fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "446:               }",
          "447:               if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)",
          "448:                if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)",
          "449:                 stsc_pos++;",
          "451:               repeat = 1;",
          "456:               repeat++;",
          "459:              mp4->metaoffsets[num] = fileoffset;",
          "463:              num++;",
          "466:             if (mp4->metastsc) free(mp4->metastsc);",
          "467:             mp4->metastsc = NULL;",
          "468:             mp4->metastsc_count = 0;",
          "470:             free(metaoffsets32);",
          "474:          else",
          "475:          {",
          "477:           CloseSource((size_t)mp4);",
          "478:           mp4 = NULL;",
          "479:           break;",
          "480:          }",
          "486:          if (num > 0)",
          "488:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "489:           if (mp4->metaoffsets)",
          "491:            uint32_t *metaoffsets32 = NULL;",
          "492:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "493:            if (metaoffsets32)",
          "495:             size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "496:             len += readlen;",
          "497:             do",
          "498:             {",
          "499:              num--;",
          "500:              mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
          "501:             } while (num > 0);",
          "503:             free(metaoffsets32);",
          "504:            }",
          "507:          else",
          "508:          {",
          "510:           CloseSource((size_t)mp4);",
          "511:           mp4 = NULL;",
          "512:           break;",
          "513:          }",
          "516:        mp4->filepos += len;",
          "517:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
          "520:        LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "466:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "467:        len += fread(&num, 1, 4, mp4->mediafp);",
          "468:        num = BYTESWAP32(num);",
          "469:        if (num * 8 <= qtsize - 8 - len)",
          "470:        {",
          "471:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "472:         {",
          "473:          mp4->indexcount = mp4->metasize_count;",
          "474:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "477:          {",
          "481:           {",
          "487:            {",
          "500:             {",
          "521:           }",
          "522:          }",
          "523:         }",
          "524:         else",
          "525:         {",
          "",
          "[Removed Lines]",
          "475:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "476:          if (mp4->metaoffsets)",
          "478:           uint64_t *metaoffsets64 = NULL;",
          "479:           metaoffsets64 = (uint64_t *)malloc(num * 8);",
          "480:           if (metaoffsets64)",
          "482:            uint64_t fileoffset = 0;",
          "483:            int stsc_pos = 0;",
          "484:            int stco_pos = 0;",
          "485:            len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
          "486:            do",
          "488:             num--;",
          "489:             metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
          "490:            } while (num > 0);",
          "492:            fileoffset = metaoffsets64[0];",
          "493:            mp4->metaoffsets[0] = fileoffset;",
          "496:            num = 1;",
          "497:            while (num < mp4->metasize_count)",
          "498:            {",
          "499:             if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
          "501:              stco_pos++;",
          "502:              fileoffset = (uint64_t)metaoffsets64[stco_pos];",
          "503:             }",
          "504:             else",
          "505:             {",
          "506:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "507:             }",
          "509:             mp4->metaoffsets[num] = fileoffset;",
          "513:             num++;",
          "514:            }",
          "516:            if (mp4->metastsc) free(mp4->metastsc);",
          "517:            mp4->metastsc = NULL;",
          "518:            mp4->metastsc_count = 0;",
          "520:            free(metaoffsets64);",
          "",
          "[Added Lines]",
          "533:        if(num == 0)",
          "534:        {",
          "536:         CloseSource((size_t)mp4);",
          "537:         mp4 = NULL;",
          "538:         break;",
          "539:        }",
          "547:          if (mp4->metasize_count)",
          "549:           mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "550:           if (mp4->metaoffsets)",
          "552:            uint64_t *metaoffsets64 = NULL;",
          "553:            metaoffsets64 = (uint64_t *)malloc(num * 8);",
          "554:            if (metaoffsets64)",
          "556:             uint64_t fileoffset = 0;",
          "557:             int stsc_pos = 0;",
          "558:             int stco_pos = 0;",
          "559:             len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
          "560:             do",
          "561:             {",
          "562:              num--;",
          "563:              metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
          "564:             } while (num > 0);",
          "566:             fileoffset = metaoffsets64[0];",
          "567:             mp4->metaoffsets[0] = fileoffset;",
          "570:             num = 1;",
          "571:             while (num < mp4->metasize_count)",
          "573:              if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
          "574:              {",
          "575:               stco_pos++;",
          "576:               fileoffset = (uint64_t)metaoffsets64[stco_pos];",
          "577:              }",
          "578:              else",
          "579:              {",
          "580:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "581:              }",
          "583:              mp4->metaoffsets[num] = fileoffset;",
          "587:              num++;",
          "588:             }",
          "590:             if (mp4->metastsc) free(mp4->metastsc);",
          "591:             mp4->metastsc = NULL;",
          "592:             mp4->metastsc_count = 0;",
          "594:             free(metaoffsets64);",
          "595:            }",
          "598:          else",
          "599:          {",
          "601:           CloseSource((size_t)mp4);",
          "602:           mp4 = NULL;",
          "603:           break;",
          "604:          }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "537:          }",
          "538:         }",
          "539:        }",
          "541:       }",
          "542:       else",
          "545:       NESTSIZE(qtsize);",
          "546:      }",
          "",
          "[Removed Lines]",
          "540:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "543:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "622:        mp4->filepos += len;",
          "623:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
          "626:        LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "577:         }",
          "578:         mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
          "579:        }",
          "581:       }",
          "582:       else",
          "585:       NESTSIZE(qtsize);",
          "586:      }",
          "",
          "[Removed Lines]",
          "580:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "583:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "663:        mp4->filepos += len;",
          "664:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
          "667:        LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "594:     break;",
          "595:    }",
          "596:   } while (len > 0);",
          "597:  }",
          "598:  else",
          "599:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "682:   if (mp4)",
          "683:   {",
          "684:    if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)",
          "685:    {",
          "686:     CloseSource((size_t)mp4);",
          "687:     mp4 = NULL;",
          "688:    }",
          "689:   }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "686:    {",
          "687:     if (!GPMF_VALID_FOURCC(qttag))",
          "688:     {",
          "691:      NESTSIZE(lastsize - 8);",
          "692:      continue;",
          "",
          "[Removed Lines]",
          "689:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "782:      LongSeek(mp4, lastsize - 8 - 8);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "713:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
          "714:      qttag == MAKEID('f', 't', 'y', 'p'))",
          "715:     {",
          "717:      NESTSIZE(qtsize);",
          "718:      continue;",
          "719:     }",
          "",
          "[Removed Lines]",
          "716:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "809:      LongSeek(mp4, qtsize - 8);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "737:     if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms",
          "738:      qttag != MAKEID('u', 'd', 't', 'a'))",
          "739:     {",
          "741:      NESTSIZE(qtsize);",
          "742:      continue;",
          "743:     }",
          "",
          "[Removed Lines]",
          "740:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "833:      LongSeek(mp4, qtsize - 8);",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h": [
          "File: demo/GPMF_mp4reader.h -> demo/GPMF_mp4reader.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:  uint32_t meta_clockdemon, meta_clockcount;",
          "65:  double basemetadataduration;",
          "66:  FILE *mediafp;",
          "67: } mp4object;",
          "69: #define MAKEID(a,b,c,d)   (((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67:  uint64_t filesize;",
          "68:  uint64_t filepos;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101: float GetDuration(size_t handle);",
          "102: uint32_t GetNumberPayloads(size_t handle);",
          "103: uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);",
          "105: void FreePayload(uint32_t *lastpayload);",
          "106: uint32_t GetPayloadSize(size_t handle, uint32_t index);",
          "107: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload",
          "",
          "[Removed Lines]",
          "104: void SavePayload(size_t handle, uint32_t *payload, uint32_t index);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "676594dfb1f8bced8028fa5246a1678eebdb2540",
      "candidate_info": {
        "commit_hash": "676594dfb1f8bced8028fa5246a1678eebdb2540",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/676594dfb1f8bced8028fa5246a1678eebdb2540",
        "files": [
          "GPMF_parser.c",
          "demo/GPMF_mp4reader.c"
        ],
        "message": "fixed potential security issues",
        "before_after_code_files": [
          "GPMF_parser.c||GPMF_parser.c",
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "GPMF_parser.c||GPMF_parser.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "GPMF_parser.c||GPMF_parser.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "GPMF_parser.c||GPMF_parser.c": [
          "File: GPMF_parser.c -> GPMF_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: GPMF_ERR GPMF_Init(GPMF_stream *ms, uint32_t *buffer, int datasize)",
          "191: {",
          "193:  {",
          "194:   ms->buffer = buffer;",
          "197:   GPMF_ResetState(ms);",
          "",
          "[Removed Lines]",
          "192:  if(ms)",
          "195:   ms->buffer_size_longs = datasize >>2;",
          "",
          "[Added Lines]",
          "192:  if(ms && buffer && datasize > 0)",
          "195:   ms->buffer_size_longs = (datasize+3)>>2;",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:  uint32_t *MP4buffer = NULL;",
          "60:  if (index < mp4->indexcount && mp4->mediafp)",
          "61:  {",
          "65:   {",
          "67:    {",
          "68:     LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
          "69:     fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
          "",
          "[Removed Lines]",
          "62:   MP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);",
          "64:   if (MP4buffer)",
          "66:    if (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])",
          "",
          "[Added Lines]",
          "62:   if ((mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index]) && (mp4->metasizes[index] > 0))",
          "64:    MP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);",
          "66:    if (MP4buffer)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72:    }",
          "73:   }",
          "74:  }",
          "75:  return NULL;",
          "76: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76:  if (lastpayload)",
          "77:   free(lastpayload);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "864:  if (mp4->indexcount < 1)",
          "865:   return 0.0;",
          "868:  payloadsize = GetPayloadSize(handle, teststart);",
          "869:  ret = GPMF_Init(ms, payload, payloadsize);",
          "874:  {",
          "875:   uint64_t minimumtimestamp = 0;",
          "",
          "[Removed Lines]",
          "867:  payload = GetPayload(handle, NULL, teststart);",
          "871:  if (ret != GPMF_OK)",
          "872:   goto cleanup;",
          "",
          "[Added Lines]",
          "871:  payload = GetPayload(handle, NULL, teststart);",
          "874:  if (ret != GPMF_OK) goto cleanup;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "904:    if (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.",
          "905:    {",
          "906:     GPMF_stream any_stream;",
          "911:     {",
          "915:     }",
          "916:    }",
          "",
          "[Removed Lines]",
          "907:     GPMF_Init(&any_stream, payload, payloadsize);",
          "909:     minimumtimestamp = starttimestamp;",
          "910:     while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))",
          "912:      uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));",
          "913:      if (timestamp < minimumtimestamp)",
          "914:       minimumtimestamp = timestamp;",
          "",
          "[Added Lines]",
          "909:     if (GPMF_OK == GPMF_Init(&any_stream, payload, payloadsize))",
          "911:      minimumtimestamp = starttimestamp;",
          "912:      while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))",
          "913:      {",
          "914:       uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));",
          "915:       if (timestamp < minimumtimestamp)",
          "916:        minimumtimestamp = timestamp;",
          "917:      }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "922:     payload = GetPayload(handle, payload, testend);",
          "923:     payloadsize = GetPayloadSize(handle, testend);",
          "924:     ret = GPMF_Init(ms, payload, payloadsize);",
          "927:    GPMF_CopyState(ms, &find_stream);",
          "928:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
          "",
          "[Removed Lines]",
          "925:    } while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
          "",
          "[Added Lines]",
          "928:    } while (testend > 0 && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1099:      payload = GetPayload(handle, payload, endpayload);",
          "1100:      payloadsize = GetPayloadSize(handle, endpayload);",
          "1101:      ret = GPMF_Init(ms, payload, payloadsize);",
          "1104:     if (endpayload > 0 && ret == GPMF_OK)",
          "1105:     {",
          "",
          "[Removed Lines]",
          "1102:     } while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
          "",
          "[Added Lines]",
          "1105:     } while (endpayload > 0 && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0f1aafd90632e3d8f7330e7944e35b0ae2a9d17a",
      "candidate_info": {
        "commit_hash": "0f1aafd90632e3d8f7330e7944e35b0ae2a9d17a",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/0f1aafd90632e3d8f7330e7944e35b0ae2a9d17a",
        "files": [
          "GPMF_parser.c"
        ],
        "message": "Crash fix for corrupted GPMF sources, particularly for type-size field corruption.",
        "before_after_code_files": [
          "GPMF_parser.c||GPMF_parser.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "GPMF_parser.c||GPMF_parser.c"
          ],
          "candidate": [
            "GPMF_parser.c||GPMF_parser.c"
          ]
        }
      },
      "candidate_diff": {
        "GPMF_parser.c||GPMF_parser.c": [
          "File: GPMF_parser.c -> GPMF_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define DBG_MSG(...)",
          "38: #endif",
          "40: GPMF_ERR GPMF_Validate(GPMF_stream *ms, GPMF_LEVELS recurse)",
          "41: {",
          "42:  if (ms)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.",
          "42: {",
          "43:  if (ms)",
          "44:  {",
          "45:   int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];",
          "46:   if (nestsize == 0 && ms->nest_level == 0)",
          "47:    nestsize = ms->buffer_size_longs;",
          "49:   if (size + 2 <= nestsize) return GPMF_OK;",
          "50:  }",
          "51:  return GPMF_ERROR_BAD_STRUCTURE;",
          "52: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:    uint32_t key, type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "210:    uint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);",
          "212:    if (GPMF_TYPE_NEST == type && GPMF_KEY_DEVICE == ms->buffer[ms->pos] && ms->nest_level == 0)",
          "213:    {",
          "214:     ms->last_level_pos[ms->nest_level] = ms->pos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227:    if (GPMF_OK != IsValidSize(ms, size)) return GPMF_ERROR_BAD_STRUCTURE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "433:    while (0 == GPMF_Next(ms, GPMF_CURRENT_LEVEL))",
          "434:    {",
          "435:     uint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);",
          "436:     type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "453:     if (GPMF_OK != IsValidSize(ms, size))",
          "454:     {",
          "455:      memcpy(ms, &prevstate, sizeof(GPMF_stream));",
          "456:      return GPMF_ERROR_BAD_STRUCTURE;",
          "457:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "537:  if (ms && ms->pos+1 < ms->buffer_size_longs)",
          "538:  {",
          "539:   uint32_t ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);",
          "540:   return ssize;",
          "541:  }",
          "542:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:   uint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);",
          "565:   if (GPMF_OK != IsValidSize(ms, size)) return 0; // as the structure is corrupted. i.e. GPMF_ERROR_BAD_STRUCTURE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "547: {",
          "548:  if (ms && ms->pos+1 < ms->buffer_size_longs)",
          "549:  {",
          "551:   GPMF_SampleType type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "553:   if (type != GPMF_TYPE_NEST && type != GPMF_TYPE_COMPLEX)",
          "",
          "[Removed Lines]",
          "550:   uint32_t ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);",
          "",
          "[Added Lines]",
          "577:   uint32_t ssize = GPMF_StructSize(ms);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "594: {",
          "595:  if (ms && ms->pos+1 < ms->buffer_size_longs)",
          "596:  {",
          "598:   return size;",
          "599:  }",
          "600:  return 0;",
          "",
          "[Removed Lines]",
          "597:   uint32_t size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1])*GPMF_SAMPLES(ms->buffer[ms->pos + 1]);",
          "",
          "[Added Lines]",
          "624:   uint32_t size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);",
          "625:   if (GPMF_OK != IsValidSize(ms, size >> 2)) return 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "779:   char complextype[64] = \"L\";",
          "781:   if (type == GPMF_TYPE_NEST)",
          "784:   if (sample_size * read_samples > buffersize)",
          "785:    return GPMF_ERROR_MEMORY;",
          "",
          "[Removed Lines]",
          "782:    return GPMF_ERROR_MEMORY;",
          "",
          "[Added Lines]",
          "811:    return GPMF_ERROR_BAD_STRUCTURE;",
          "813:   if (GPMF_OK != IsValidSize(ms, remaining_sample_size>>2))",
          "814:    return GPMF_ERROR_BAD_STRUCTURE;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "985:   if (type == GPMF_TYPE_NEST)",
          "986:    return GPMF_ERROR_MEMORY;",
          "988:   remaining_sample_size -= sample_offset * sample_size; // skip samples",
          "989:   data += sample_offset * sample_size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1020:   if (GPMF_OK != IsValidSize(ms, remaining_sample_size >> 2))",
          "1021:    return GPMF_ERROR_BAD_STRUCTURE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "27d1a97ef8dec50241e5ee3d45175a7fd2090286",
      "candidate_info": {
        "commit_hash": "27d1a97ef8dec50241e5ee3d45175a7fd2090286",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/27d1a97ef8dec50241e5ee3d45175a7fd2090286",
        "files": [
          "demo/GPMF_mp4reader.c"
        ],
        "message": "Improved handling for corrupted MP4 headers.",
        "before_after_code_files": [
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "280:       {",
          "281:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "282:        len += fread(&num, 1, 4, mp4->mediafp);",
          "301:        {",
          "302:         if (mp4->metastsc) free(mp4->metastsc);",
          "305:        }",
          "307:       }",
          "308:       else",
          "309:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "[Removed Lines]",
          "283:        mp4->metastsc_count = num = BYTESWAP32(num);",
          "284:        if (mp4->metastsc) free(mp4->metastsc);",
          "285:        mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
          "286:        if (mp4->metastsc)",
          "287:        {",
          "288:         uint32_t total_stsc = num;",
          "289:         len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
          "291:         do",
          "292:         {",
          "293:          num--;",
          "294:          mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
          "295:          mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
          "296:          mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
          "297:         } while (num > 0);",
          "298:        }",
          "300:        if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
          "303:         mp4->metastsc = NULL;",
          "304:         mp4->metastsc_count = 0;",
          "306:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "",
          "[Added Lines]",
          "284:        num = BYTESWAP32(num);",
          "285:        if (num * 12 <= qtsize - 8 - len)",
          "287:         mp4->metastsc_count = num;",
          "289:         mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
          "290:         if (mp4->metastsc)",
          "291:         {",
          "292:          uint32_t total_stsc = num;",
          "293:          len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
          "295:          do",
          "296:          {",
          "297:           num--;",
          "298:           mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
          "299:           mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
          "300:           mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
          "301:          } while (num > 0);",
          "302:         }",
          "304:         if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
          "305:         {",
          "306:          if (mp4->metastsc) free(mp4->metastsc);",
          "307:          mp4->metastsc = NULL;",
          "308:          mp4->metastsc_count = 0;",
          "309:         }",
          "311:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "319:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "320:        len += fread(&equalsamplesize, 1, 4, mp4->mediafp);",
          "321:        len += fread(&num, 1, 4, mp4->mediafp);",
          "326:        {",
          "328:         {",
          "331:          {",
          "340:          {",
          "344:         }",
          "345:        }",
          "346:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "",
          "[Removed Lines]",
          "322:        mp4->metasize_count = num = BYTESWAP32(num);",
          "323:        if (mp4->metasizes) free(mp4->metasizes);",
          "324:        mp4->metasizes = (uint32_t *)malloc(num * 4);",
          "325:        if (mp4->metasizes)",
          "327:         if (equalsamplesize == 0)",
          "329:          len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
          "330:          do",
          "332:           num--;",
          "333:           mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
          "334:          } while (num > 0);",
          "335:         }",
          "336:         else",
          "337:         {",
          "338:          equalsamplesize = BYTESWAP32(equalsamplesize);",
          "339:          do",
          "341:           num--;",
          "342:           mp4->metasizes[num] = equalsamplesize;",
          "343:          } while (num > 0);",
          "",
          "[Added Lines]",
          "328:        num = BYTESWAP32(num);",
          "329:        if (num * 4 <= qtsize - 8 - len)",
          "331:         mp4->metasize_count = num;",
          "332:         if (mp4->metasizes) free(mp4->metasizes);",
          "333:         mp4->metasizes = (uint32_t *)malloc(num * 4);",
          "334:         if (mp4->metasizes)",
          "336:          if (equalsamplesize == 0)",
          "338:           len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
          "339:           do",
          "340:           {",
          "341:            num--;",
          "342:            mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
          "343:           } while (num > 0);",
          "344:          }",
          "345:          else",
          "347:           equalsamplesize = BYTESWAP32(equalsamplesize);",
          "348:           do",
          "349:           {",
          "350:            num--;",
          "351:            mp4->metasizes[num] = equalsamplesize;",
          "352:           } while (num > 0);",
          "353:          }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "357:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "358:        len += fread(&num, 1, 4, mp4->mediafp);",
          "359:        num = BYTESWAP32(num);",
          "361:        {",
          "366:         {",
          "370:          {",
          "385:           {",
          "387:            {",
          "399:            {",
          "402:            }",
          "409:           }",
          "416:          }",
          "417:         }",
          "425:         {",
          "429:          {",
          "433:           {",
          "439:          }",
          "440:         }",
          "441:        }",
          "",
          "[Removed Lines]",
          "360:        if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "362:         mp4->indexcount = mp4->metasize_count;",
          "363:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "364:         mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "365:         if (mp4->metaoffsets)",
          "367:          uint32_t *metaoffsets32 = NULL;",
          "368:          metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "369:          if (metaoffsets32)",
          "371:           uint64_t fileoffset = 0;",
          "372:           int stsc_pos = 0;",
          "373:           int stco_pos = 0;",
          "374:           int repeat = 1;",
          "375:           len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "376:           do",
          "377:           {",
          "378:            num--;",
          "379:            metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
          "380:           } while (num > 0);",
          "382:           mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
          "383:           num = 1;",
          "384:           while (num < mp4->metasize_count)",
          "386:            if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)",
          "388:             stco_pos++; stsc_pos++;",
          "389:             fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "390:             repeat = 1;",
          "391:            }",
          "392:            else if (repeat == mp4->metastsc[stsc_pos].samples)",
          "393:            {",
          "394:             stco_pos++;",
          "395:             fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "396:             repeat = 1;",
          "397:            }",
          "398:            else",
          "400:             fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "401:             repeat++;",
          "404:            mp4->metaoffsets[num] = fileoffset;",
          "408:            num++;",
          "411:           if (mp4->metastsc) free(mp4->metastsc);",
          "412:           mp4->metastsc = NULL;",
          "413:           mp4->metastsc_count = 0;",
          "415:           free(metaoffsets32);",
          "418:        }",
          "419:        else",
          "420:        {",
          "421:         mp4->indexcount = num;",
          "422:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "423:         mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "424:         if (mp4->metaoffsets)",
          "426:          uint32_t *metaoffsets32 = NULL;",
          "427:          metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "428:          if (metaoffsets32)",
          "430:           size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "431:           len += readlen;",
          "432:           do",
          "434:            num--;",
          "435:            mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
          "436:           } while (num > 0);",
          "438:           free(metaoffsets32);",
          "",
          "[Added Lines]",
          "370:        if (num * 4 <= qtsize - 8 - len)",
          "372:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "374:          mp4->indexcount = mp4->metasize_count;",
          "375:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "376:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "377:          if (mp4->metaoffsets)",
          "379:           uint32_t *metaoffsets32 = NULL;",
          "380:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "381:           if (metaoffsets32)",
          "383:            uint64_t fileoffset = 0;",
          "384:            int stsc_pos = 0;",
          "385:            int stco_pos = 0;",
          "386:            int repeat = 1;",
          "387:            len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "388:            do",
          "390:             num--;",
          "391:             metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
          "392:            } while (num > 0);",
          "394:            mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
          "395:            num = 1;",
          "396:            while (num < mp4->metasize_count)",
          "398:             if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)",
          "399:             {",
          "400:              stco_pos++; stsc_pos++;",
          "401:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "402:              repeat = 1;",
          "403:             }",
          "404:             else if (repeat == mp4->metastsc[stsc_pos].samples)",
          "405:             {",
          "406:              stco_pos++;",
          "407:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "408:              repeat = 1;",
          "409:             }",
          "410:             else",
          "411:             {",
          "412:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "413:              repeat++;",
          "414:             }",
          "416:             mp4->metaoffsets[num] = fileoffset;",
          "420:             num++;",
          "423:            if (mp4->metastsc) free(mp4->metastsc);",
          "424:            mp4->metastsc = NULL;",
          "425:            mp4->metastsc_count = 0;",
          "427:            free(metaoffsets32);",
          "431:         else",
          "433:          mp4->indexcount = num;",
          "434:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "435:          mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "436:          if (mp4->metaoffsets)",
          "438:           uint32_t *metaoffsets32 = NULL;",
          "439:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "440:           if (metaoffsets32)",
          "442:            size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "443:            len += readlen;",
          "444:            do",
          "445:            {",
          "446:             num--;",
          "447:             mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
          "448:            } while (num > 0);",
          "450:            free(metaoffsets32);",
          "451:           }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "454:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "455:        len += fread(&num, 1, 4, mp4->mediafp);",
          "456:        num = BYTESWAP32(num);",
          "458:        {",
          "463:         {",
          "467:          {",
          "473:           {",
          "491:            {",
          "493:            }",
          "500:           }",
          "507:          }",
          "508:         }",
          "516:         {",
          "519:          {",
          "523:         }",
          "524:        }",
          "525:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "",
          "[Removed Lines]",
          "457:        if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "459:         mp4->indexcount = mp4->metasize_count;",
          "460:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "461:         mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "462:         if (mp4->metaoffsets)",
          "464:          uint64_t *metaoffsets64 = NULL;",
          "465:          metaoffsets64 = (uint64_t *)malloc(num * 8);",
          "466:          if (metaoffsets64)",
          "468:           uint64_t fileoffset = 0;",
          "469:           int stsc_pos = 0;",
          "470:           int stco_pos = 0;",
          "471:           len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
          "472:           do",
          "474:            num--;",
          "475:            metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
          "476:           } while (num > 0);",
          "478:           fileoffset = metaoffsets64[0];",
          "479:           mp4->metaoffsets[0] = fileoffset;",
          "482:           num = 1;",
          "483:           while (num < mp4->metasize_count)",
          "484:           {",
          "485:            if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
          "486:            {",
          "487:             stco_pos++;",
          "488:             fileoffset = (uint64_t)metaoffsets64[stco_pos];",
          "489:            }",
          "490:            else",
          "492:             fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "495:            mp4->metaoffsets[num] = fileoffset;",
          "499:            num++;",
          "502:           if (mp4->metastsc) free(mp4->metastsc);",
          "503:           mp4->metastsc = NULL;",
          "504:           mp4->metastsc_count = 0;",
          "506:           free(metaoffsets64);",
          "509:        }",
          "510:        else",
          "511:        {",
          "512:         mp4->indexcount = num;",
          "513:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "514:         mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "515:         if (mp4->metaoffsets)",
          "517:          len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);",
          "518:          do",
          "520:           num--;",
          "521:           mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);",
          "522:          } while (num > 0);",
          "",
          "[Added Lines]",
          "470:        if (num * 8 <= qtsize - 8 - len)",
          "472:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "474:          mp4->indexcount = mp4->metasize_count;",
          "475:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "476:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "477:          if (mp4->metaoffsets)",
          "479:           uint64_t *metaoffsets64 = NULL;",
          "480:           metaoffsets64 = (uint64_t *)malloc(num * 8);",
          "481:           if (metaoffsets64)",
          "483:            uint64_t fileoffset = 0;",
          "484:            int stsc_pos = 0;",
          "485:            int stco_pos = 0;",
          "486:            len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
          "487:            do",
          "488:            {",
          "489:             num--;",
          "490:             metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
          "491:            } while (num > 0);",
          "493:            fileoffset = metaoffsets64[0];",
          "494:            mp4->metaoffsets[0] = fileoffset;",
          "497:            num = 1;",
          "498:            while (num < mp4->metasize_count)",
          "500:             if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
          "501:             {",
          "502:              stco_pos++;",
          "503:              fileoffset = (uint64_t)metaoffsets64[stco_pos];",
          "504:             }",
          "505:             else",
          "506:             {",
          "507:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "508:             }",
          "510:             mp4->metaoffsets[num] = fileoffset;",
          "514:             num++;",
          "517:            if (mp4->metastsc) free(mp4->metastsc);",
          "518:            mp4->metastsc = NULL;",
          "519:            mp4->metastsc_count = 0;",
          "521:            free(metaoffsets64);",
          "525:         else",
          "527:          mp4->indexcount = num;",
          "528:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "529:          mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "530:          if (mp4->metaoffsets)",
          "532:           len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);",
          "533:           do",
          "534:           {",
          "535:            num--;",
          "536:            mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);",
          "537:           } while (num > 0);",
          "538:          }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "538:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "539:        len += fread(&num, 1, 4, mp4->mediafp);",
          "540:        num = BYTESWAP32(num);",
          "560:        }",
          "562:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "563:       }",
          "564:       else",
          "",
          "[Removed Lines]",
          "541:        entries = num;",
          "543:        mp4->meta_clockdemon = mp4->trak_clockdemon;",
          "544:        mp4->meta_clockcount = mp4->trak_clockcount;",
          "546:        while (entries > 0)",
          "547:        {",
          "548:         int32_t samplecount;",
          "549:         int32_t duration;",
          "550:         len += fread(&samplecount, 1, 4, mp4->mediafp);",
          "551:         samplecount = BYTESWAP32(samplecount);",
          "552:         len += fread(&duration, 1, 4, mp4->mediafp);",
          "553:         duration = BYTESWAP32(duration);",
          "555:         samples += samplecount;",
          "556:         entries--;",
          "558:         totaldur += duration;",
          "559:         mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);",
          "561:        mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
          "",
          "[Added Lines]",
          "557:        if (num * 8 <= qtsize - 8 - len)",
          "558:        {",
          "559:         entries = num;",
          "561:         mp4->meta_clockdemon = mp4->trak_clockdemon;",
          "562:         mp4->meta_clockcount = mp4->trak_clockcount;",
          "564:         while (entries > 0)",
          "565:         {",
          "566:          int32_t samplecount;",
          "567:          int32_t duration;",
          "568:          len += fread(&samplecount, 1, 4, mp4->mediafp);",
          "569:          samplecount = BYTESWAP32(samplecount);",
          "570:          len += fread(&duration, 1, 4, mp4->mediafp);",
          "571:          duration = BYTESWAP32(duration);",
          "573:          samples += samplecount;",
          "574:          entries--;",
          "576:          totaldur += duration;",
          "577:          mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);",
          "578:         }",
          "579:         mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ffcd7ffe5e29b8d76f3d5fd0ceee4aebdf5de92f",
      "candidate_info": {
        "commit_hash": "ffcd7ffe5e29b8d76f3d5fd0ceee4aebdf5de92f",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/ffcd7ffe5e29b8d76f3d5fd0ceee4aebdf5de92f",
        "files": [
          "demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c",
          "demo/GPMF_mp4reader.h"
        ],
        "message": "improved mp4 parser",
        "before_after_code_files": [
          "demo/GPMF_demo.c||demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
          "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
            "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
          ],
          "candidate": [
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
            "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_demo.c||demo/GPMF_demo.c": [
          "File: demo/GPMF_demo.c -> demo/GPMF_demo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:   return -1;",
          "46:  }",
          "53:  if (metadatalength > 0.0)",
          "54:  {",
          "58: #if 1",
          "59:   if (payloads == 1) // Printf the contents of the single payload",
          "60:   {",
          "63:    if(payload == NULL)",
          "64:     goto cleanup;",
          "",
          "[Removed Lines]",
          "49:  metadatalength = OpenGPMFSource(argv[1]);",
          "55:   uint32_t index, payloads = GetNumberGPMFPayloads();",
          "61:    uint32_t payloadsize = GetGPMFPayloadSize(0);",
          "62:    payload = GetGPMFPayload(payload, 0);",
          "",
          "[Added Lines]",
          "48:  size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);",
          "51:  metadatalength = GetDuration(mp4);",
          "55:   uint32_t index, payloads = GetNumberPayloads(mp4);",
          "61:    uint32_t payloadsize = GetPayloadSize(mp4,0);",
          "62:    payload = GetPayload(mp4, payload, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:   for (index = 0; index < payloads; index++)",
          "91:   {",
          "95:    if (payload == NULL)",
          "96:     goto cleanup;",
          "99:    if (ret != GPMF_OK)",
          "100:     goto cleanup;",
          "",
          "[Removed Lines]",
          "92:    uint32_t payloadsize = GetGPMFPayloadSize(index);",
          "93:    double in = 0.0, out = 0.0; //times",
          "94:    payload = GetGPMFPayload(payload, index);",
          "98:    ret = GetGPMFPayloadTime(index, &in, &out);",
          "",
          "[Added Lines]",
          "92:    uint32_t payloadsize = GetPayloadSize(mp4, index);",
          "93:    float in = 0.0, out = 0.0; //times",
          "94:    payload = GetPayload(mp4, payload, index);",
          "98:    ret = GetPayloadTime(mp4, index, &in, &out);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:    if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream",
          "229:    {",
          "230:     uint32_t fourcc = GPMF_Key(ms);",
          "232:     printf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);",
          "233:    }",
          "234:   }",
          "",
          "[Removed Lines]",
          "231:     double rate = GetGPMFSampleRate(fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);",
          "",
          "[Added Lines]",
          "231:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "238:  cleanup:",
          "241:  }",
          "243:  return ret;",
          "",
          "[Removed Lines]",
          "239:   if (payload) FreeGPMFPayload(payload); payload = NULL;",
          "240:   CloseGPMFSource();",
          "",
          "[Added Lines]",
          "239:   if (payload) FreePayload(payload); payload = NULL;",
          "240:   CloseSource(mp4);",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include <stdlib.h>",
          "25: #include <stdio.h>",
          "26: #include <string.h>",
          "27: #include <stdint.h>",
          "29: #include \"GPMF_mp4reader.h\"",
          "32: #define PRINT_MP4_STRUCTURE  0",
          "",
          "[Removed Lines]",
          "30: #include \"../GPMF_parser.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: #endif",
          "58: {",
          "78: }",
          "82: {",
          "85:  {",
          "89:   {",
          "93:   }",
          "94:  }",
          "99:  return NULL;",
          "100: }",
          "105: {",
          "113: }",
          "125: {",
          "217: }",
          "221: {",
          "222: #ifdef _WINDOWS",
          "224: #else",
          "226: #endif",
          "237:  {",
          "239:   size_t len;",
          "240:   int32_t nest = 0;",
          "241:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
          "242:   uint64_t lastsize = 0, qtsize;",
          "281:   do",
          "282:   {",
          "285:    if (len == 8)",
          "286:    {",
          "288:     {",
          "291:      NESTSIZE(lastsize - 8);",
          "292:      continue;",
          "",
          "[Removed Lines]",
          "41: uint32_t *metasizes = NULL;",
          "42: uint32_t metasize_count = 0;",
          "43: uint64_t *metaoffsets = NULL;",
          "44: uint32_t indexcount = 0;",
          "45: double videolength = 0.0;",
          "46: double metadatalength = 0.0;",
          "47: uint32_t clockdemon, clockcount;",
          "48: uint32_t trak_clockdemon, trak_clockcount;",
          "49: uint32_t meta_clockdemon, meta_clockcount;",
          "50: uint32_t basemetadataduration = 0;",
          "51: uint32_t basemetadataoffset = 0;",
          "52: FILE *fp = NULL;",
          "53: SampleToChunk *metastsc = NULL;",
          "54: uint32_t metastsc_count = 0;",
          "57: typedef struct media_header",
          "59:  uint8_t version_flags[4];",
          "60:  uint32_t creation_time;",
          "61:  uint32_t modification_time;",
          "62:  uint32_t time_scale;",
          "63:  uint32_t duration;",
          "64:  uint16_t language;",
          "65:  uint16_t quality;",
          "66: } media_header;",
          "71: #define MAKETAG(d,c,b,a)  (((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))",
          "75: uint32_t GetNumberGPMFPayloads(void)",
          "76: {",
          "77:  return indexcount;",
          "81: uint32_t *GetGPMFPayload(uint32_t *lastpayload, uint32_t index)",
          "83:  uint32_t *GPMFbuffer = NULL;",
          "84:  if (index < indexcount && fp)",
          "86:   GPMFbuffer = realloc(lastpayload, metasizes[index]);",
          "88:   if (GPMFbuffer)",
          "90:    LONGSEEK(fp, metaoffsets[index], SEEK_SET);",
          "91:    fread(GPMFbuffer, 1, metasizes[index], fp);",
          "92:    return GPMFbuffer;",
          "95:  else if(lastpayload)",
          "96:  {",
          "97:   free(lastpayload);",
          "98:  }",
          "104: void FreeGPMFPayload(uint32_t *lastpayload)",
          "106:  free(lastpayload);",
          "107: }",
          "110: uint32_t GetGPMFPayloadSize(uint32_t index)",
          "111: {",
          "112:  return metasizes[index];",
          "116: #define TRAK_TYPE  MAKEID('m', 'e', 't', 'a')  // track is the type for metadata",
          "117: #define TRAK_SUBTYPE MAKEID('g', 'p', 'm', 'd')  // subtype is GPMF",
          "119: #define MAX_NEST_LEVEL 20",
          "120: #define NESTSIZE(x) { int i = nest; while (i > 0 && nestsize[i] > 0) { nestsize[i] -= x; if(nestsize[i]>=0 && nestsize[i] <= 8) { nestsize[i]=0; nest--; } i--; } }",
          "124: double OpenGPMFSourceUDTA(const char *filename)",
          "126: #ifdef _WINDOWS",
          "127:  fopen_s(&fp, filename, \"rb\");",
          "128: #else",
          "129:  fp = fopen(filename, \"rb\");",
          "130: #endif",
          "132:  metasizes = NULL;",
          "133:  metaoffsets = NULL;",
          "134:  indexcount = 0;",
          "135:  videolength = 0.0;",
          "136:  metadatalength = 0.0;",
          "137:  basemetadataduration = 0;",
          "138:  basemetadataoffset = 0;",
          "140:  if (fp)",
          "141:  {",
          "142:   uint32_t qttag, qtsize32, len;",
          "143:   int32_t nest = 0;",
          "144:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
          "145:   uint64_t lastsize = 0, qtsize;",
          "147:   do",
          "148:   {",
          "149:    len = fread(&qtsize32, 1, 4, fp);",
          "150:    len += fread(&qttag, 1, 4, fp);",
          "151:    if (len == 8)",
          "152:    {",
          "153:     if (!GPMF_VALID_FOURCC(qttag))",
          "154:     {",
          "155:      LONGSEEK(fp, lastsize - 8 - 8, SEEK_CUR);",
          "157:      NESTSIZE(lastsize - 8);",
          "158:      continue;",
          "159:     }",
          "161:     qtsize32 = BYTESWAP32(qtsize32);",
          "163:     if (qtsize32 == 1) // 64-bit Atom",
          "164:     {",
          "165:      fread(&qtsize, 1, 8, fp);",
          "166:      qtsize = BYTESWAP64(qtsize) - 8;",
          "167:     }",
          "168:     else",
          "169:      qtsize = qtsize32;",
          "171:     nest++;",
          "173:     if (qtsize < 8) break;",
          "174:     if (nest >= MAX_NEST_LEVEL) break;",
          "176:     nestsize[nest] = qtsize;",
          "177:     lastsize = qtsize;",
          "179:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
          "180:      qttag == MAKEID('f', 't', 'y', 'p'))",
          "181:     {",
          "182:      LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "183:      NESTSIZE(qtsize);",
          "184:      continue;",
          "185:     }",
          "187:     if (qttag == MAKEID('G', 'P', 'M', 'F'))",
          "188:     {",
          "189:      videolength += 1.0;",
          "190:      metadatalength += 1.0;",
          "192:      indexcount = (int)metadatalength;",
          "194:      metasizes = (uint32_t *)malloc(indexcount * 4 + 4);  memset(metasizes, 0, indexcount * 4 + 4);",
          "195:      metaoffsets = (uint64_t *)malloc(indexcount * 8 + 8);  memset(metaoffsets, 0, indexcount * 8 + 8);",
          "197:      metasizes[0] = (int)qtsize-8;",
          "198:      metaoffsets[0] = ftell(fp);",
          "200:      return metadatalength;  // not an MP4, RAW GPMF which has not inherent timing, assigning a during of 1second.",
          "201:     }",
          "202:     if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms",
          "203:      qttag != MAKEID('u', 'd', 't', 'a'))",
          "204:     {",
          "205:      LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "206:      NESTSIZE(qtsize);",
          "207:      continue;",
          "208:     }",
          "209:     else",
          "210:     {",
          "211:      NESTSIZE(8);",
          "212:     }",
          "213:    }",
          "214:   } while (len > 0);",
          "215:  }",
          "216:  return metadatalength;",
          "220: double OpenGPMFSource(const char *filename)  //RAW or within MP4",
          "223:  fopen_s(&fp, filename, \"rb\");",
          "225:  fp = fopen(filename, \"rb\");",
          "228:  metasizes = NULL;",
          "229:  metaoffsets = NULL;",
          "230:  indexcount = 0;",
          "231:  videolength = 0.0;",
          "232:  metadatalength = 0.0;",
          "233:  basemetadataduration = 0;",
          "234:  basemetadataoffset = 0;",
          "236:  if (fp)",
          "238:   uint32_t tag, qttag, qtsize32, skip, type = 0, subtype = 0, num;",
          "244:   len = fread(&tag, 1, 4, fp);",
          "245:   if (tag == GPMF_KEY_DEVICE) // RAW GPMF data, not in an MP4",
          "246:   {",
          "247:    int filesize;",
          "249:    videolength += 1.0;",
          "250:    metadatalength += 1.0;",
          "252:    fseek(fp, 0, SEEK_END);",
          "253:    filesize = ftell(fp);",
          "254:    fseek(fp, 0, SEEK_SET);",
          "256:    indexcount = (int)metadatalength;",
          "257:    LONGSEEK(fp, 0, SEEK_SET); // back to start",
          "259:    metasizes = (uint32_t *)malloc(indexcount * 4 + 4);",
          "260:    if (metasizes == NULL)",
          "261:     return 0;",
          "263:    metaoffsets = (uint64_t *)malloc(indexcount * 8 + 8);",
          "264:    if (metaoffsets == NULL)",
          "265:    {",
          "266:     free(metasizes);",
          "267:     metasizes = 0;",
          "268:     return 0;",
          "269:    }",
          "271:    memset(metasizes, 0, indexcount * 4 + 4);",
          "272:    memset(metaoffsets, 0, indexcount * 8 + 8);",
          "274:    metasizes[0] = (filesize)&~3;",
          "275:    metaoffsets[0] = 0;",
          "277:    return metadatalength;  // not an MP4, RAW GPMF which has not inherent timing, assigning a during of 1second.",
          "278:   }",
          "279:   LONGSEEK(fp, 0, SEEK_SET); // back to start",
          "283:    len = fread(&qtsize32, 1, 4, fp);",
          "284:    len += fread(&qttag, 1, 4, fp);",
          "287:     if (!GPMF_VALID_FOURCC(qttag))",
          "289:      LONGSEEK(fp, lastsize - 8 - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "41: uint32_t GetNumberPayloads(size_t handle)",
          "43:  mp4object *mp4 = (mp4object *)handle;",
          "45:  if (mp4)",
          "46:  {",
          "47:   return mp4->indexcount;",
          "48:  }",
          "50:  return 0;",
          "54: uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)",
          "56:  mp4object *mp4 = (mp4object *)handle;",
          "57:  if (mp4 == NULL) return NULL;",
          "59:  uint32_t *MP4buffer = NULL;",
          "60:  if (index < mp4->indexcount && mp4->mediafp)",
          "62:   MP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);",
          "64:   if (MP4buffer)",
          "66:    LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
          "67:    fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
          "68:    return MP4buffer;",
          "75: void SavePayload(size_t handle, uint32_t *payload, uint32_t index)",
          "77:  mp4object *mp4 = (mp4object *)handle;",
          "78:  if (mp4 == NULL) return;",
          "80:  uint32_t *MP4buffer = NULL;",
          "81:  if (index < mp4->indexcount && mp4->mediafp && payload)",
          "82:  {",
          "83:   LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
          "84:   fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);",
          "85:  }",
          "86:  return;",
          "91: void FreePayload(uint32_t *lastpayload)",
          "93:  if (lastpayload)",
          "94:   free(lastpayload);",
          "95: }",
          "98: uint32_t GetPayloadSize(size_t handle, uint32_t index)",
          "99: {",
          "100:  mp4object *mp4 = (mp4object *)handle;",
          "101:  if (mp4 == NULL) return 0;",
          "103:  if (mp4->metasizes && mp4->metasize_count > index)",
          "104:   return mp4->metasizes[index];",
          "106:  return 0;",
          "109: #define MAX_NEST_LEVEL 20",
          "111: size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4",
          "113:  mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));",
          "114:  if (mp4 == NULL) return 0;",
          "116:  memset(mp4, 0, sizeof(mp4object));",
          "119:  fopen_s(&mp4->mediafp, filename, \"rb\");",
          "121:  mp4->mediafp = fopen(filename, \"rb\");",
          "124:  if (mp4->mediafp)",
          "126:   uint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;",
          "134:    len = fread(&qtsize32, 1, 4, mp4->mediafp);",
          "135:    len += fread(&qttag, 1, 4, mp4->mediafp);",
          "138:     if (!VALID_FOURCC(qttag))",
          "140:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "297:     if (qtsize32 == 1) // 64-bit Atom",
          "298:     {",
          "300:      qtsize = BYTESWAP64(qtsize) - 8;",
          "301:     }",
          "302:     else",
          "",
          "[Removed Lines]",
          "299:      fread(&qtsize, 1, 8, fp);",
          "",
          "[Added Lines]",
          "150:      fread(&qtsize, 1, 8, mp4->mediafp);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "319:      qttag == MAKEID('f', 't', 'y', 'p') ||",
          "320:      qttag == MAKEID('u', 'd', 't', 'a'))",
          "321:     {",
          "324:      NESTSIZE(qtsize);",
          "",
          "[Removed Lines]",
          "322:      LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "",
          "[Added Lines]",
          "173:      LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "346:      qttag != MAKEID('c', 'o', '6', '4') &&",
          "347:      qttag != MAKEID('h', 'd', 'l', 'r'))",
          "348:     {",
          "351:      NESTSIZE(qtsize);",
          "352:     }",
          "354: #endif",
          "371:      {",
          "383:       }",
          "420:      }",
          "429:      {",
          "436:       {",
          "440:        {",
          "446:       }",
          "455:      }",
          "464:      {",
          "474:       {",
          "476:        {",
          "478:         do",
          "479:         {",
          "480:          num--;",
          "482:         } while (num > 0);",
          "483:        }",
          "485:        {",
          "492:        }",
          "493:       }",
          "504:      {",
          "509:       {",
          "514:        {",
          "518:         {",
          "523:          do",
          "524:          {",
          "525:           num--;",
          "527:          } while (num > 0);",
          "534:          {",
          "536:           {",
          "541:           {",
          "543:           }",
          "553:         }",
          "554:        }",
          "562:        {",
          "566:         {",
          "569:          {",
          "575:         }",
          "576:        }",
          "577:       }",
          "589:      {",
          "594:       {",
          "599:        {",
          "603:         {",
          "609:          {",
          "627:           {",
          "629:           }",
          "636:          }",
          "642:         }",
          "643:        }",
          "651:        {",
          "654:         {",
          "658:        }",
          "659:       }",
          "670:      {",
          "691:        {",
          "699:       }",
          "701:      }",
          "702:      else",
          "711:    }",
          "712:    else",
          "713:    {",
          "",
          "[Removed Lines]",
          "349:      LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "353:     else",
          "355:     if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header",
          "356:     {",
          "357:      len = fread(&skip, 1, 4, fp);",
          "358:      len += fread(&skip, 1, 4, fp);",
          "359:      len += fread(&skip, 1, 4, fp);",
          "360:      len += fread(&clockdemon, 1, 4, fp); clockdemon = BYTESWAP32(clockdemon);",
          "361:      len += fread(&clockcount, 1, 4, fp); clockcount = BYTESWAP32(clockcount);",
          "362:      LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
          "364:      NESTSIZE(qtsize);",
          "365:     }",
          "366:     else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header",
          "367:     {",
          "368:      media_header md;",
          "369:      len = fread(&md, 1, sizeof(md), fp);",
          "370:      if (len == sizeof(md))",
          "372:       md.creation_time = BYTESWAP32(md.creation_time);",
          "373:       md.modification_time = BYTESWAP32(md.modification_time);",
          "374:       md.time_scale = BYTESWAP32(md.time_scale);",
          "375:       md.duration = BYTESWAP32(md.duration);",
          "377:       trak_clockdemon = md.time_scale;",
          "378:       trak_clockcount = md.duration;",
          "380:       if (videolength == 0.0) // Get the video length from the first track",
          "381:       {",
          "382:        videolength = (double)trak_clockcount / (double)trak_clockdemon;",
          "384:      }",
          "385:      LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
          "387:      NESTSIZE(qtsize);",
          "388:     }",
          "389:     else if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr",
          "390:     {",
          "391:      uint32_t temp;",
          "392:      len = fread(&skip, 1, 4, fp);",
          "393:      len += fread(&skip, 1, 4, fp);",
          "394:      len += fread(&temp, 1, 4, fp);  // type will be 'meta' for the correct trak.",
          "396:      if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))",
          "397:       type = temp;",
          "399:      LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over hldr",
          "401:      NESTSIZE(qtsize);",
          "403:     }",
          "404:     else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata",
          "405:     {",
          "406:      if (type == TRAK_TYPE) // meta",
          "407:      {",
          "408:       len = fread(&skip, 1, 4, fp);",
          "409:       len += fread(&skip, 1, 4, fp);",
          "410:       len += fread(&skip, 1, 4, fp);",
          "411:       len += fread(&subtype, 1, 4, fp);  // type will be 'meta' for the correct trak.",
          "412:       if (len == 16)",
          "413:       {",
          "414:        if (subtype != TRAK_SUBTYPE) // GPMF metadata",
          "415:        {",
          "416:         type = 0; // GPMF",
          "417:        }",
          "418:       }",
          "419:       LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over stsd",
          "421:      else",
          "422:       LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "424:      NESTSIZE(qtsize);",
          "425:     }",
          "426:     else if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks",
          "427:     {",
          "428:      if (type == TRAK_TYPE) // meta",
          "430:       len = fread(&skip, 1, 4, fp);",
          "431:       len += fread(&num, 1, 4, fp);",
          "432:       metastsc_count = num = BYTESWAP32(num);",
          "433:       if (metastsc) free(metastsc);",
          "434:       metastsc = (SampleToChunk *)malloc(num * 12);",
          "435:       if (metastsc)",
          "437:        len += fread(metastsc, 1, num * sizeof(SampleToChunk), fp);",
          "439:        do",
          "441:         num--;",
          "442:         metastsc[num].chunk_num = BYTESWAP32(metastsc[num].chunk_num);",
          "443:         metastsc[num].samples = BYTESWAP32(metastsc[num].samples);",
          "444:         metastsc[num].id = BYTESWAP32(metastsc[num].id);",
          "445:        } while (num > 0);",
          "448:       if (metastsc_count == 1 && metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
          "449:       {",
          "450:        if (metastsc) free(metastsc);",
          "451:        metastsc = NULL;",
          "452:        metastsc_count = 0;",
          "453:       }",
          "454:       LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "456:      else",
          "457:       LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "459:      NESTSIZE(qtsize);",
          "460:     }",
          "461:     else if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes",
          "462:     {",
          "463:      if (type == TRAK_TYPE) // meta",
          "465:       uint32_t equalsamplesize;",
          "467:       len = fread(&skip, 1, 4, fp);",
          "468:       len += fread(&equalsamplesize, 1, 4, fp);",
          "469:       len += fread(&num, 1, 4, fp);",
          "470:       metasize_count = num = BYTESWAP32(num);",
          "471:       if (metasizes) free(metasizes);",
          "472:       metasizes = (uint32_t *)malloc(num * 4);",
          "473:       if (metasizes)",
          "475:        if (equalsamplesize == 0)",
          "477:         len += fread(metasizes, 1, num * 4, fp);",
          "481:          metasizes[num] = BYTESWAP32(metasizes[num]);",
          "484:        else",
          "486:         equalsamplesize = BYTESWAP32(equalsamplesize);",
          "487:         do",
          "488:         {",
          "489:          num--;",
          "490:          metasizes[num] = equalsamplesize;",
          "491:         } while (num > 0);",
          "494:       LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "495:      }",
          "496:      else",
          "497:       LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "499:      NESTSIZE(qtsize);",
          "500:     }",
          "501:     else if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets",
          "502:     {",
          "503:      if (type == TRAK_TYPE) // meta",
          "505:       len = fread(&skip, 1, 4, fp);",
          "506:       len += fread(&num, 1, 4, fp);",
          "507:       num = BYTESWAP32(num);",
          "508:       if (metastsc_count > 0 && num != metasize_count)",
          "510:        indexcount = metasize_count;",
          "511:        if (metaoffsets) free(metaoffsets);",
          "512:        metaoffsets = (uint64_t *)malloc(metasize_count * 8);",
          "513:        if (metaoffsets)",
          "515:         uint32_t *metaoffsets32 = NULL;",
          "516:         metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "517:         if (metaoffsets32)",
          "519:          uint64_t fileoffset = 0;",
          "520:          int stsc_pos = 0;",
          "521:          int stco_pos = 0;",
          "522:          len += fread(metaoffsets32, 1, num * 4, fp);",
          "526:           metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
          "529:          fileoffset = metaoffsets32[0];",
          "530:          metaoffsets[0] = fileoffset;",
          "532:          num = 1;",
          "533:          while (num < metasize_count)",
          "535:           if (num != metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (metastsc[stsc_pos].chunk_num - 1)) % metastsc[stsc_pos].samples)",
          "537:            stco_pos++;",
          "538:            fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "539:           }",
          "540:           else",
          "542:            fileoffset += (uint64_t)metasizes[num - 1];",
          "545:           metaoffsets[num] = fileoffset;",
          "546:           num++;",
          "547:          }",
          "549:          if (metastsc) free(metastsc);",
          "550:          metastsc_count = 0;",
          "552:          free(metaoffsets32);",
          "555:       }",
          "556:       else",
          "557:       {",
          "558:        indexcount = num;",
          "559:        if (metaoffsets) free(metaoffsets);",
          "560:        metaoffsets = (uint64_t *)malloc(num * 8);",
          "561:        if (metaoffsets)",
          "563:         uint32_t *metaoffsets32 = NULL;",
          "564:         metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "565:         if (metaoffsets32)",
          "567:          len += fread(metaoffsets32, 1, num * 4, fp);",
          "568:          do",
          "570:           num--;",
          "571:           metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
          "572:          } while (num > 0);",
          "574:          free(metaoffsets32);",
          "578:       LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "579:      }",
          "580:      else",
          "581:       LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "583:      NESTSIZE(qtsize);",
          "584:     }",
          "586:     else if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets",
          "587:     {",
          "588:      if (type == TRAK_TYPE) // meta",
          "590:       len = fread(&skip, 1, 4, fp);",
          "591:       len += fread(&num, 1, 4, fp);",
          "592:       num = BYTESWAP32(num);",
          "593:       if (metastsc_count > 0 && num != metasize_count)",
          "595:        indexcount = metasize_count;",
          "596:        if (metaoffsets) free(metaoffsets);",
          "597:        metaoffsets = (uint64_t *)malloc(metasize_count * 8);",
          "598:        if (metaoffsets)",
          "600:         uint64_t *metaoffsets64 = NULL;",
          "601:         metaoffsets64 = (uint64_t *)malloc(num * 8);",
          "602:         if (metaoffsets64)",
          "604:          uint64_t fileoffset = 0;",
          "605:          int stsc_pos = 0;",
          "606:          int stco_pos = 0;",
          "607:          len += fread(metaoffsets64, 1, num * 8, fp);",
          "608:          do",
          "610:           num--;",
          "611:           metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
          "612:          } while (num > 0);",
          "614:          fileoffset = metaoffsets64[0];",
          "615:          metaoffsets[0] = fileoffset;",
          "618:          num = 1;",
          "619:          while (num < metasize_count)",
          "620:          {",
          "621:           if (num != metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (metastsc[stsc_pos].chunk_num - 1)) % metastsc[stsc_pos].samples)",
          "622:           {",
          "623:            stco_pos++;",
          "624:            fileoffset = (uint64_t)metaoffsets64[stco_pos];",
          "625:           }",
          "626:           else",
          "628:            fileoffset += (uint64_t)metasizes[num - 1];",
          "631:           metaoffsets[num] = fileoffset;",
          "635:           num++;",
          "638:          if (metastsc) free(metastsc);",
          "639:          metastsc_count = 0;",
          "641:          free(metaoffsets64);",
          "644:       }",
          "645:       else",
          "646:       {",
          "647:        indexcount = num;",
          "648:        if (metaoffsets) free(metaoffsets);",
          "649:        metaoffsets = (uint64_t *)malloc(num * 8);",
          "650:        if (metaoffsets)",
          "652:         len += fread(metaoffsets, 1, num * 8, fp);",
          "653:         do",
          "655:          num--;",
          "656:          metaoffsets[num] = BYTESWAP64(metaoffsets[num]);",
          "657:         } while (num > 0);",
          "660:       LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "661:      }",
          "662:      else",
          "663:       LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "665:      NESTSIZE(qtsize);",
          "666:     }",
          "667:     else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples",
          "668:     {",
          "669:      if (type == TRAK_TYPE) // meta",
          "671:       uint32_t totaldur = 0;",
          "672:       int32_t entries = 0;",
          "673:       len = fread(&skip, 1, 4, fp);",
          "674:       len += fread(&num, 1, 4, fp);",
          "675:       num = BYTESWAP32(num);",
          "676:       entries = num;",
          "678:       meta_clockdemon = trak_clockdemon;",
          "679:       meta_clockcount = trak_clockcount;",
          "681:       while (entries > 0)",
          "682:       {",
          "683:        int32_t samplecount;",
          "684:        int32_t duration;",
          "685:        len += fread(&samplecount, 1, 4, fp);",
          "686:        samplecount = BYTESWAP32(samplecount);",
          "687:        len += fread(&duration, 1, 4, fp);",
          "688:        duration = BYTESWAP32(duration);",
          "690:        if (samplecount > 1)",
          "692:         basemetadataoffset = totaldur;",
          "693:         basemetadataduration = duration;",
          "694:        }",
          "695:        entries--;",
          "697:        totaldur += duration;",
          "698:        metadatalength += ((double)samplecount * (double)duration / (double)meta_clockdemon);",
          "700:       LONGSEEK(fp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "703:       LONGSEEK(fp, qtsize - 8, SEEK_CUR);",
          "705:      NESTSIZE(qtsize);",
          "706:     }",
          "707:     else",
          "708:     {",
          "709:      NESTSIZE(8);",
          "710:     }",
          "",
          "[Added Lines]",
          "200:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "204:     else",
          "206:      if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header",
          "208:       len = fread(&skip, 1, 4, mp4->mediafp);",
          "209:       len += fread(&skip, 1, 4, mp4->mediafp);",
          "210:       len += fread(&skip, 1, 4, mp4->mediafp);",
          "211:       len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);",
          "212:       len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);",
          "213:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
          "215:       NESTSIZE(qtsize);",
          "216:      }",
          "217:      else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header",
          "218:      {",
          "219:       media_header md;",
          "220:       len = fread(&md, 1, sizeof(md), mp4->mediafp);",
          "221:       if (len == sizeof(md))",
          "222:       {",
          "223:        md.creation_time = BYTESWAP32(md.creation_time);",
          "224:        md.modification_time = BYTESWAP32(md.modification_time);",
          "225:        md.time_scale = BYTESWAP32(md.time_scale);",
          "226:        md.duration = BYTESWAP32(md.duration);",
          "228:        mp4->trak_clockdemon = md.time_scale;",
          "229:        mp4->trak_clockcount = md.duration;",
          "231:        if (mp4->videolength == 0.0) // Get the video length from the first track",
          "232:        {",
          "233:         mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);",
          "234:        }",
          "236:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
          "238:       NESTSIZE(qtsize);",
          "239:      }",
          "240:      else if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr",
          "241:      {",
          "242:       uint32_t temp;",
          "243:       len = fread(&skip, 1, 4, mp4->mediafp);",
          "244:       len += fread(&skip, 1, 4, mp4->mediafp);",
          "245:       len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.",
          "247:       if (temp != MAKEID('a', 'l', 'i', 's'))",
          "248:        type = temp;",
          "250:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr",
          "252:       NESTSIZE(qtsize);",
          "255:      else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata",
          "257:       if (type == traktype) //like meta",
          "259:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "260:        len += fread(&skip, 1, 4, mp4->mediafp);",
          "261:        len += fread(&skip, 1, 4, mp4->mediafp);",
          "262:        len += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.",
          "263:        if (len == 16)",
          "265:         if (subtype != traksubtype) // MP4 metadata",
          "266:         {",
          "267:          type = 0; // MP4",
          "268:         }",
          "269:        }",
          "270:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd",
          "272:       else",
          "273:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "275:       NESTSIZE(qtsize);",
          "277:      else if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks",
          "279:       if (type == traktype) // meta",
          "281:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "282:        len += fread(&num, 1, 4, mp4->mediafp);",
          "283:        mp4->metastsc_count = num = BYTESWAP32(num);",
          "284:        if (mp4->metastsc) free(mp4->metastsc);",
          "285:        mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
          "286:        if (mp4->metastsc)",
          "288:         len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
          "293:          mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
          "294:          mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
          "295:          mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
          "299:        if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
          "301:         if (mp4->metastsc) free(mp4->metastsc);",
          "302:         mp4->metastsc_count = 0;",
          "304:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "306:       else",
          "307:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "309:       NESTSIZE(qtsize);",
          "310:      }",
          "311:      else if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes",
          "313:       if (type == traktype) // meta",
          "315:        uint32_t equalsamplesize;",
          "317:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "318:        len += fread(&equalsamplesize, 1, 4, mp4->mediafp);",
          "319:        len += fread(&num, 1, 4, mp4->mediafp);",
          "320:        mp4->metasize_count = num = BYTESWAP32(num);",
          "321:        if (mp4->metasizes) free(mp4->metasizes);",
          "322:        mp4->metasizes = (uint32_t *)malloc(num * 4);",
          "323:        if (mp4->metasizes)",
          "325:         if (equalsamplesize == 0)",
          "327:          len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
          "331:           mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
          "333:         }",
          "334:         else",
          "335:         {",
          "336:          equalsamplesize = BYTESWAP32(equalsamplesize);",
          "337:          do",
          "338:          {",
          "339:           num--;",
          "340:           mp4->metasizes[num] = equalsamplesize;",
          "341:          } while (num > 0);",
          "342:         }",
          "343:        }",
          "344:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "345:       }",
          "346:       else",
          "347:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "349:       NESTSIZE(qtsize);",
          "350:      }",
          "351:      else if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets",
          "352:      {",
          "353:       if (type == traktype) // meta",
          "354:       {",
          "355:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "356:        len += fread(&num, 1, 4, mp4->mediafp);",
          "357:        num = BYTESWAP32(num);",
          "358:        if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "359:        {",
          "360:         mp4->indexcount = mp4->metasize_count;",
          "361:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "362:         mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "363:         if (mp4->metaoffsets)",
          "364:         {",
          "365:          uint32_t *metaoffsets32 = NULL;",
          "366:          metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "367:          if (metaoffsets32)",
          "369:           uint64_t fileoffset = 0;",
          "370:           int stsc_pos = 0;",
          "371:           int stco_pos = 0;",
          "372:           len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "373:           do",
          "375:            num--;",
          "376:            metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
          "377:           } while (num > 0);",
          "379:           fileoffset = metaoffsets32[0];",
          "380:           mp4->metaoffsets[0] = fileoffset;",
          "383:           num = 1;",
          "384:           while (num < mp4->metasize_count)",
          "386:            if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
          "387:            {",
          "388:             stco_pos++;",
          "389:             fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "390:            }",
          "391:            else",
          "392:            {",
          "393:             fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "394:            }",
          "396:            mp4->metaoffsets[num] = fileoffset;",
          "400:            num++;",
          "403:           if (mp4->metastsc) free(mp4->metastsc);",
          "404:           mp4->metastsc_count = 0;",
          "406:           free(metaoffsets32);",
          "407:          }",
          "410:        else",
          "412:         mp4->indexcount = num;",
          "413:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "414:         mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "415:         if (mp4->metaoffsets)",
          "417:          uint32_t *metaoffsets32 = NULL;",
          "418:          metaoffsets32 = (uint32_t *)malloc(num * 4);",
          "419:          if (metaoffsets32)",
          "421:           size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "422:           len += readlen;",
          "423:           do",
          "424:           {",
          "425:            num--;",
          "426:            mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
          "427:           } while (num > 0);",
          "429:           free(metaoffsets32);",
          "430:          }",
          "433:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "435:       else",
          "436:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "438:       NESTSIZE(qtsize);",
          "439:      }",
          "441:      else if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets",
          "443:       if (type == traktype) // meta",
          "445:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "446:        len += fread(&num, 1, 4, mp4->mediafp);",
          "447:        num = BYTESWAP32(num);",
          "448:        if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "450:         mp4->indexcount = mp4->metasize_count;",
          "451:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "452:         mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
          "453:         if (mp4->metaoffsets)",
          "455:          uint64_t *metaoffsets64 = NULL;",
          "456:          metaoffsets64 = (uint64_t *)malloc(num * 8);",
          "457:          if (metaoffsets64)",
          "459:           uint64_t fileoffset = 0;",
          "460:           int stsc_pos = 0;",
          "461:           int stco_pos = 0;",
          "462:           len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
          "463:           do",
          "464:           {",
          "465:            num--;",
          "466:            metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
          "467:           } while (num > 0);",
          "469:           fileoffset = metaoffsets64[0];",
          "470:           mp4->metaoffsets[0] = fileoffset;",
          "473:           num = 1;",
          "474:           while (num < mp4->metasize_count)",
          "476:            if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
          "477:            {",
          "478:             stco_pos++;",
          "479:             fileoffset = (uint64_t)metaoffsets64[stco_pos];",
          "480:            }",
          "481:            else",
          "482:            {",
          "483:             fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "484:            }",
          "486:            mp4->metaoffsets[num] = fileoffset;",
          "490:            num++;",
          "493:           if (mp4->metastsc) free(mp4->metastsc);",
          "494:           mp4->metastsc_count = 0;",
          "496:           free(metaoffsets64);",
          "500:        else",
          "502:         mp4->indexcount = num;",
          "503:         if (mp4->metaoffsets) free(mp4->metaoffsets);",
          "504:         mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
          "505:         if (mp4->metaoffsets)",
          "507:          len += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);",
          "508:          do",
          "509:          {",
          "510:           num--;",
          "511:           mp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);",
          "512:          } while (num > 0);",
          "513:         }",
          "515:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "517:       else",
          "518:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "520:       NESTSIZE(qtsize);",
          "521:      }",
          "522:      else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples",
          "524:       if (type == traktype) // meta",
          "525:       {",
          "526:        uint32_t totaldur = 0;",
          "527:        int32_t entries = 0;",
          "528:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "529:        len += fread(&num, 1, 4, mp4->mediafp);",
          "530:        num = BYTESWAP32(num);",
          "531:        entries = num;",
          "533:        mp4->meta_clockdemon = mp4->trak_clockdemon;",
          "534:        mp4->meta_clockcount = mp4->trak_clockcount;",
          "536:        while (entries > 0)",
          "538:         int32_t samplecount;",
          "539:         int32_t duration;",
          "540:         len += fread(&samplecount, 1, 4, mp4->mediafp);",
          "541:         samplecount = BYTESWAP32(samplecount);",
          "542:         len += fread(&duration, 1, 4, mp4->mediafp);",
          "543:         duration = BYTESWAP32(duration);",
          "545:         if (samplecount > 1)",
          "546:         {",
          "547:          mp4->basemetadataoffset = totaldur;",
          "548:          mp4->basemetadataduration = duration;",
          "549:         }",
          "550:         entries--;",
          "552:         totaldur += duration;",
          "553:         mp4->metadatalength += (float)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);",
          "554:        }",
          "555:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
          "557:       else",
          "558:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "560:       NESTSIZE(qtsize);",
          "563:      {",
          "564:       NESTSIZE(8);",
          "565:      }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "715:    }",
          "716:   } while (len > 0);",
          "717:  }",
          "720: }",
          "724: {",
          "728: }",
          "732: {",
          "737:  return 0;",
          "738: }",
          "743: {",
          "744:  GPMF_stream metadata_stream, *ms = &metadata_stream;",
          "745:  uint32_t teststart = 0;",
          "747:  double rate = 0.0;",
          "754:   return 0.0;",
          "757:  {",
          "758:   teststart++;",
          "759:   testend--;",
          "760:  }",
          "766:  if (ret != GPMF_OK)",
          "767:   goto cleanup;",
          "",
          "[Removed Lines]",
          "719:  return metadatalength;",
          "723: void CloseGPMFSource(void)",
          "725:  if (fp) fclose(fp), fp = NULL;",
          "726:  if (metasizes) free(metasizes), metasizes = 0;",
          "727:  if (metaoffsets) free(metaoffsets), metaoffsets = 0;",
          "731: uint32_t GetGPMFPayloadTime(uint32_t index, double *in, double *out)",
          "733:  if (metaoffsets == 0 || basemetadataduration == 0 || meta_clockdemon == 0 || in == NULL || out == NULL) return 1;",
          "742: double GetGPMFSampleRate(uint32_t fourcc, uint32_t flags)",
          "746:  uint32_t testend = indexcount;",
          "749:  uint32_t *payload;",
          "750:  uint32_t payloadsize;",
          "751:  int32_t ret;",
          "753:  if (indexcount < 1)",
          "756:  if (indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies.",
          "762:  payload = GetGPMFPayload(NULL, teststart); // second payload",
          "763:  payloadsize = GetGPMFPayloadSize(teststart);",
          "764:  ret = GPMF_Init(ms, payload, payloadsize);",
          "",
          "[Added Lines]",
          "573:  else",
          "574:  {",
          "578:   free(mp4);",
          "579:   mp4 = NULL;",
          "580:  }",
          "582:  return (size_t)mp4;",
          "583: }",
          "586: float GetDuration(size_t handle)",
          "587: {",
          "588:  mp4object *mp4 = (mp4object *)handle;",
          "589:  if (mp4 == NULL) return 0.0;",
          "591:  return mp4->metadatalength;",
          "595: void CloseSource(size_t handle)",
          "597:  mp4object *mp4 = (mp4object *)handle;",
          "598:  if (mp4 == NULL) return;",
          "600:  if (mp4->mediafp) fclose(mp4->mediafp), mp4->mediafp = NULL;",
          "601:  if (mp4->metasizes) free(mp4->metasizes), mp4->metasizes = 0;",
          "602:  if (mp4->metaoffsets) free(mp4->metaoffsets), mp4->metaoffsets = 0;",
          "604:  free(mp4);",
          "608: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)",
          "610:  mp4object *mp4 = (mp4object *)handle;",
          "611:  if (mp4 == NULL) return 0;",
          "613:  if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;",
          "623: size_t OpenMP4SourceUDTA(char *filename)",
          "625:  mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));",
          "626:  if (mp4 == NULL) return 0;",
          "628:  memset(mp4, 0, sizeof(mp4object));",
          "630: #ifdef _WINDOWS",
          "631:  fopen_s(&mp4->mediafp, filename, \"rb\");",
          "632: #else",
          "633:  mp4->mediafp = fopen(filename, \"rb\");",
          "634: #endif",
          "636:  if (mp4->mediafp)",
          "637:  {",
          "638:   uint32_t qttag, qtsize32, len;",
          "639:   int32_t nest = 0;",
          "640:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
          "641:   uint64_t lastsize = 0, qtsize;",
          "643:   do",
          "644:   {",
          "645:    len = fread(&qtsize32, 1, 4, mp4->mediafp);",
          "646:    len += fread(&qttag, 1, 4, mp4->mediafp);",
          "647:    if (len == 8)",
          "648:    {",
          "649:     if (!GPMF_VALID_FOURCC(qttag))",
          "650:     {",
          "651:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
          "653:      NESTSIZE(lastsize - 8);",
          "654:      continue;",
          "655:     }",
          "657:     qtsize32 = BYTESWAP32(qtsize32);",
          "659:     if (qtsize32 == 1) // 64-bit Atom",
          "660:     {",
          "661:      fread(&qtsize, 1, 8, mp4->mediafp);",
          "662:      qtsize = BYTESWAP64(qtsize) - 8;",
          "663:     }",
          "664:     else",
          "665:      qtsize = qtsize32;",
          "667:     nest++;",
          "669:     if (qtsize < 8) break;",
          "670:     if (nest >= MAX_NEST_LEVEL) break;",
          "672:     nestsize[nest] = qtsize;",
          "673:     lastsize = qtsize;",
          "675:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
          "676:      qttag == MAKEID('f', 't', 'y', 'p'))",
          "677:     {",
          "678:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "679:      NESTSIZE(qtsize);",
          "680:      continue;",
          "681:     }",
          "683:     if (qttag == MAKEID('G', 'P', 'M', 'F'))",
          "684:     {",
          "685:      mp4->videolength += 1.0;",
          "686:      mp4->metadatalength += 1.0;",
          "688:      mp4->indexcount = (int)mp4->metadatalength;",
          "690:      mp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);",
          "691:      mp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);",
          "693:      mp4->metasizes[0] = (int)qtsize - 8;",
          "694:      mp4->metaoffsets[0] = ftell(mp4->mediafp);",
          "695:      mp4->metasize_count = 1;",
          "697:      return (size_t)mp4;  // not an MP4, RAW GPMF which has not inherent timing, assigning a during of 1second.",
          "698:     }",
          "699:     if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms",
          "700:      qttag != MAKEID('u', 'd', 't', 'a'))",
          "701:     {",
          "702:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
          "703:      NESTSIZE(qtsize);",
          "704:      continue;",
          "705:     }",
          "706:     else",
          "707:     {",
          "708:      NESTSIZE(8);",
          "709:     }",
          "710:    }",
          "711:   } while (len > 0);",
          "712:  }",
          "713:  return (size_t)mp4;",
          "714: }",
          "717: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)",
          "718: {",
          "719:  mp4object *mp4 = (mp4object *)handle;",
          "720:  if (mp4 == NULL) return 0.0;",
          "724:  uint32_t testend = mp4->indexcount;",
          "727:  if (mp4->indexcount < 1)",
          "730:  if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies.",
          "736:  uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload",
          "737:  uint32_t payloadsize = GetPayloadSize(handle, teststart);",
          "738:  int32_t ret = GPMF_Init(ms, payload, payloadsize);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "775:   {",
          "776:    missing_samples = 1;",
          "777:    teststart++;",
          "780:    ret = GPMF_Init(ms, payload, payloadsize);",
          "781:   }",
          "783:   if (missing_samples)",
          "784:   {",
          "785:    teststart++;   //samples after sensor start are statistically the best",
          "788:    ret = GPMF_Init(ms, payload, payloadsize);",
          "789:   }",
          "",
          "[Removed Lines]",
          "778:    payload = GetGPMFPayload(payload, teststart); // second last payload",
          "779:    payloadsize = GetGPMFPayloadSize(teststart);",
          "786:    payload = GetGPMFPayload(payload, teststart);",
          "787:    payloadsize = GetGPMFPayloadSize(teststart);",
          "",
          "[Added Lines]",
          "752:    payload = GetPayload(handle, payload, teststart); // second last payload",
          "753:    payloadsize = GetPayloadSize(handle, teststart);",
          "760:    payload = GetPayload(handle, payload, teststart);",
          "761:    payloadsize = GetPayloadSize(handle, teststart);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "798:    {",
          "799:     startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;",
          "803:     ret = GPMF_Init(ms, payload, payloadsize);",
          "804:     if (ret != GPMF_OK)",
          "805:      goto cleanup;",
          "",
          "[Removed Lines]",
          "801:     payload = GetGPMFPayload(payload, testend); // second last payload",
          "802:     payloadsize = GetGPMFPayloadSize(testend);",
          "",
          "[Added Lines]",
          "775:     payload = GetPayload(handle, payload, testend); // second last payload",
          "776:     payloadsize = GetPayloadSize(handle, testend);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "810:      if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
          "811:      {",
          "812:       endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
          "814:       goto cleanup;",
          "815:      }",
          "816:     }",
          "819:    }",
          "820:    else // for increased precision, for older GPMF streams sometimes missing the total sample count",
          "821:    {",
          "822:     uint32_t payloadpos = 0, payloadcount = 0;",
          "823:     double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
          "827:     samples = 0;",
          "829:     for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)",
          "830:     {",
          "833:      ret = GPMF_Init(ms, payload, payloadsize);",
          "835:      if (ret != GPMF_OK)",
          "",
          "[Removed Lines]",
          "813:       rate = (double)(endsamples - startsamples) / (metadatalength * ((double)(testend - teststart + 1)) / (double)indexcount);",
          "818:     rate = (double)(samples) / (metadatalength * ((double)(testend - teststart + 1)) / (double)indexcount);",
          "824:     uint32_t *repeatarray = malloc(indexcount * 4 + 4);",
          "825:     memset(repeatarray, 0, indexcount * 4 + 4);",
          "831:      payload = GetGPMFPayload(payload, payloadpos); // second last payload",
          "832:      payloadsize = GetGPMFPayloadSize(payloadpos);",
          "",
          "[Added Lines]",
          "787:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "792:     rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "798:     uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
          "799:     memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
          "805:      payload = GetPayload(handle, payload, payloadpos); // second last payload",
          "806:      payloadsize = GetPayloadSize(handle, payloadpos);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "844:       {",
          "845:        if (repeatarray)",
          "846:        {",
          "849:         do",
          "850:         {",
          "",
          "[Removed Lines]",
          "847:         double in, out;",
          "",
          "[Added Lines]",
          "821:         float in, out;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "854:         repeatarray[payloadpos] = samples;",
          "855:         meanY += (double)samples;",
          "858:         meanX += out;",
          "860:       }",
          "861:       else",
          "862:       {",
          "",
          "[Removed Lines]",
          "857:         GetGPMFPayloadTime(payloadpos, &in, &out);",
          "859:        }",
          "",
          "[Added Lines]",
          "831:         GetPayloadTime(handle, payloadpos, &in, &out);",
          "833:        }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "866:        if (repeatarray)",
          "867:        {",
          "870:         repeatarray[payloadpos] = samples;",
          "871:         meanY += (double)samples;",
          "874:         meanX += out;",
          "877:      }",
          "878:     }",
          "884:     {",
          "885:      meanY /= (double)payloadcount;",
          "886:      meanX /= (double)payloadcount;",
          "888:      for (payloadpos = teststart; payloadpos < testend; payloadpos++)",
          "889:      {",
          "893:       top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);",
          "894:       bot += ((double)out - meanX)*((double)out - meanX);",
          "",
          "[Removed Lines]",
          "868:         double in, out;",
          "873:         GetGPMFPayloadTime(payloadpos, &in, &out);",
          "875:        }",
          "876:       }",
          "883:      if (repeatarray)",
          "890:       double in, out;",
          "891:       GetGPMFPayloadTime(payloadpos, &in, &out);",
          "",
          "[Added Lines]",
          "842:         float in, out;",
          "847:         GetPayloadTime(handle, payloadpos, &in, &out);",
          "849:        }",
          "850:       }",
          "857:     if (repeatarray)",
          "864:       float in, out;",
          "865:       GetPayloadTime(handle, payloadpos, &in, &out);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "901:      {",
          "902:       double intercept;",
          "903:       intercept = meanY - slope*meanX;",
          "905:      }",
          "906: #endif",
          "907:      rate = slope;",
          "908:     }",
          "909:     else",
          "910:     {",
          "912:     }",
          "914:     free(repeatarray);",
          "916:     goto cleanup;",
          "",
          "[Removed Lines]",
          "904:       printf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope );",
          "911:      rate = (double)(samples) / (metadatalength * ((double)(testend - teststart + 1)) / (double)indexcount);",
          "",
          "[Added Lines]",
          "878:       printf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);",
          "885:      rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "919:  }",
          "921: cleanup:",
          "924:  return rate;",
          "925: }",
          "929: {",
          "930:  uint32_t key, insamples;",
          "931:  uint32_t repeat, outsamples;",
          "932:  GPMF_stream find_stream;",
          "936:  key = GPMF_Key(gs);",
          "937:  repeat = GPMF_Repeat(gs);",
          "938:  if (rate == 0.0)",
          "941:  if (rate == 0.0)",
          "942:  {",
          "",
          "[Removed Lines]",
          "922:  if(payload) if (payload) FreeGPMFPayload(payload); payload = NULL;",
          "928: double GetGPMFSampleRateAndTimes(GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)",
          "934:  if (gs == NULL || metaoffsets == 0 || indexcount == 0 || basemetadataduration == 0 || meta_clockdemon == 0 || in == NULL || out == NULL) return 1;",
          "939:   rate = GetGPMFSampleRate(key, GPMF_SAMPLE_RATE_FAST);",
          "",
          "[Added Lines]",
          "896:  if (payload)",
          "897:   FreePayload(payload);",
          "898:  payload = NULL;",
          "904: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)",
          "906:  mp4object *mp4 = (mp4object *)handle;",
          "907:  if (mp4 == NULL) return 0.0;",
          "913:  if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;",
          "918:   rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h": [
          "File: demo/GPMF_mp4reader.h -> demo/GPMF_mp4reader.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: extern \"C\" {",
          "29: #endif",
          "31: typedef struct SampleToChunk",
          "32: {",
          "33:  uint32_t chunk_num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: typedef struct media_header",
          "33: {",
          "34:  uint8_t version_flags[4];",
          "35:  uint32_t creation_time;",
          "36:  uint32_t modification_time;",
          "37:  uint32_t time_scale;",
          "38:  uint32_t duration;",
          "39:  uint16_t language;",
          "40:  uint16_t quality;",
          "41: } media_header;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:  uint32_t id;",
          "36: } SampleToChunk;",
          "47: #define GPMF_SAMPLE_RATE_FAST  0",
          "48: #define GPMF_SAMPLE_RATE_PRECISE 1",
          "53: #ifdef __cplusplus",
          "54: }",
          "",
          "[Removed Lines]",
          "38: double OpenGPMFSource(const char *filename);",
          "39: double OpenGPMFSourceUDTA(const char *filename);",
          "40: void CloseGPMFSource(void);",
          "41: uint32_t GetNumberGPMFPayloads(void);",
          "42: uint32_t *GetGPMFPayload(uint32_t *lastpayload, uint32_t index);",
          "43: void FreeGPMFPayload(uint32_t *lastpayload);",
          "44: uint32_t GetGPMFPayloadSize(uint32_t index);",
          "45: uint32_t GetGPMFPayloadTime(uint32_t index, double *in, double *out); //MP4 timestamps for the payload",
          "50: double GetGPMFSampleRate(uint32_t fourcc, uint32_t flags);",
          "51: double GetGPMFSampleRateAndTimes(GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed",
          "",
          "[Added Lines]",
          "52: typedef struct mp4object",
          "53: {",
          "54:  uint32_t *metasizes;",
          "55:  uint32_t metasize_count;",
          "56:  uint64_t *metaoffsets;",
          "57:  SampleToChunk *metastsc;",
          "58:  uint32_t metastsc_count;",
          "59:  uint32_t indexcount;",
          "60:  float videolength;",
          "61:  float metadatalength;",
          "62:  uint32_t clockdemon, clockcount;",
          "63:  uint32_t trak_clockdemon, trak_clockcount;",
          "64:  uint32_t meta_clockdemon, meta_clockcount;",
          "65:  uint32_t basemetadataduration;",
          "66:  uint32_t basemetadataoffset;",
          "67:  FILE *mediafp;",
          "68: } mp4object;",
          "70: #define MAKEID(a,b,c,d)   (((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))",
          "71: #define STR2FOURCC(s)   ((s[0]<<0)|(s[1]<<8)|(s[2]<<16)|(s[3]<<24))",
          "73: #define BYTESWAP64(a)   (((a&0xff)<<56)|((a&0xff00)<<40)|((a&0xff0000)<<24)|((a&0xff000000)<<8) | ((a>>56)&0xff)|((a>>40)&0xff00)|((a>>24)&0xff0000)|((a>>8)&0xff000000) )",
          "74: #define BYTESWAP32(a)   (((a&0xff)<<24)|((a&0xff00)<<8)|((a>>8)&0xff00)|((a>>24)&0xff))",
          "75: #define BYTESWAP16(a)   ((((a)>>8)&0xff)|(((a)<<8)&0xff00))",
          "76: #define NOSWAP8(a)    (a)",
          "81: #define MOV_GPMF_TRAK_TYPE  MAKEID('m', 'e', 't', 'a')  // track is the type for metadata",
          "82: #define MOV_GPMF_TRAK_SUBTYPE MAKEID('g', 'p', 'm', 'd')  // subtype is GPMF",
          "83: #define MOV_VIDE_TRAK_TYPE  MAKEID('v', 'i', 'd', 'e')  // MP4 track for video",
          "84: #define MOV_SOUN_TRAK_TYPE  MAKEID('s', 'o', 'u', 'n')  // MP4 track for audio",
          "85: #define MOV_AVC1_SUBTYPE  MAKEID('a', 'v', 'c', '1')  // subtype H264",
          "86: #define MOV_HVC1_SUBTYPE  MAKEID('h', 'v', 'c', '1')  // subtype H265",
          "87: #define MOV_MP4A_SUBTYPE  MAKEID('m', 'p', '4', 'a')  // subtype for audio",
          "88: #define MOV_CFHD_SUBTYPE  MAKEID('C', 'F', 'H', 'D')  // subtype is CineForm HD",
          "89: #define AVI_VIDS_TRAK_TYPE  MAKEID('v', 'i', 'd', 's')  // track is the type for video",
          "90: #define AVI_CFHD_SUBTYPE  MAKEID('c', 'f', 'h', 'd')  // subtype is CineForm HD",
          "92: #define NESTSIZE(x) { int i = nest; while (i > 0 && nestsize[i] > 0) { nestsize[i] -= x; if(nestsize[i]>=0 && nestsize[i] <= 8) { nestsize[i]=0; nest--; } i--; } }",
          "94: #define VALID_FOURCC(a) (((((a>>24)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>24)&0xff)>='A'&&((a>>24)&0xff)<='Z') || (((a>>24)&0xff)>='0'&&((a>>24)&0xff)<='9') || (((a>>24)&0xff)==' ') ) && \\",
          "95:       ( (((a>>16)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>16)&0xff)>='A'&&((a>>16)&0xff)<='Z') || (((a>>16)&0xff)>='0'&&((a>>16)&0xff)<='9') || (((a>>16)&0xff)==' ') ) && \\",
          "96:       ( (((a>>8)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>8)&0xff)>='A'&&((a>>8)&0xff)<='Z') || (((a>>8)&0xff)>='0'&&((a>>8)&0xff)<='9') || (((a>>8)&0xff)==' ') ) && \\",
          "97:       ( (((a>>0)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>0)&0xff)>='A'&&((a>>0)&0xff)<='Z') || (((a>>0)&0xff)>='0'&&((a>>0)&0xff)<='9') || (((a>>0)&0xff)==' ') ))",
          "99: size_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t subtype);",
          "100: size_t OpenMP4SourceUDTA(char *filename);",
          "101: void CloseSource(size_t handle);",
          "102: float GetDuration(size_t handle);",
          "103: uint32_t GetNumberPayloads(size_t handle);",
          "104: uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);",
          "105: void SavePayload(size_t handle, uint32_t *payload, uint32_t index);",
          "106: void FreePayload(uint32_t *lastpayload);",
          "107: uint32_t GetPayloadSize(size_t handle, uint32_t index);",
          "108: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload",
          "113: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);",
          "114: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-17854",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (integer overflow and memory corruption) or possibly have unspecified other impact by leveraging unrestricted integer values for pointer arithmetic.",
  "repo": "torvalds/linux",
  "patch_hash": "bb7f0f989ca7de1153bd128a40a71709e339fa03",
  "patch_info": {
    "commit_hash": "bb7f0f989ca7de1153bd128a40a71709e339fa03",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bb7f0f989ca7de1153bd128a40a71709e339fa03",
    "files": [
      "include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: fix integer overflows\n\nThere were various issues related to the limited size of integers used in\nthe verifier:\n - `off + size` overflow in __check_map_access()\n - `off + reg->off` overflow in check_mem_access()\n - `off + reg->var_off.value` overflow or 32-bit truncation of\n   `reg->var_off.value` in check_mem_access()\n - 32-bit truncation in check_stack_boundary()\n\nMake sure that any integer math cannot overflow by not allowing\npointer math with large values.\n\nAlso reduce the scope of \"scalar op scalar\" tracking.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "before_after_code_files": [
      "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
      "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "18: #define BPF_MAX_VAR_OFF (1ULL << 31)",
      "22: #define BPF_MAX_VAR_SIZ INT_MAX",
      "",
      "[Added Lines]",
      "18: #define BPF_MAX_VAR_OFF (1 << 29)",
      "22: #define BPF_MAX_VAR_SIZ (1 << 29)",
      "",
      "---------------"
    ],
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1819:  return res > a;",
      "1820: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1822: static bool check_reg_sane_offset(struct bpf_verifier_env *env,",
      "1823:       const struct bpf_reg_state *reg,",
      "1824:       enum bpf_reg_type type)",
      "1825: {",
      "1826:  bool known = tnum_is_const(reg->var_off);",
      "1827:  s64 val = reg->var_off.value;",
      "1828:  s64 smin = reg->smin_value;",
      "1830:  if (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {",
      "1831:   verbose(env, \"math between %s pointer and %lld is not allowed\\n\",",
      "1832:    reg_type_str[type], val);",
      "1833:   return false;",
      "1834:  }",
      "1836:  if (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {",
      "1837:   verbose(env, \"%s pointer offset %d is not allowed\\n\",",
      "1838:    reg_type_str[type], reg->off);",
      "1839:   return false;",
      "1840:  }",
      "1842:  if (smin == S64_MIN) {",
      "1843:   verbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",",
      "1844:    reg_type_str[type]);",
      "1845:   return false;",
      "1846:  }",
      "1848:  if (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {",
      "1849:   verbose(env, \"value %lld makes %s pointer be out of bounds\\n\",",
      "1850:    smin, reg_type_str[type]);",
      "1851:   return false;",
      "1852:  }",
      "1854:  return true;",
      "1855: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1887:  dst_reg->type = ptr_reg->type;",
      "1888:  dst_reg->id = ptr_reg->id;",
      "1890:  switch (opcode) {",
      "1891:  case BPF_ADD:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1925:  if (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||",
      "1926:      !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))",
      "1927:   return -EINVAL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2017:   return -EACCES;",
      "2018:  }",
      "2020:  __update_reg_bounds(dst_reg);",
      "2021:  __reg_deduce_bounds(dst_reg);",
      "2022:  __reg_bound_offset(dst_reg);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2059:  if (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))",
      "2060:   return -EINVAL;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2046:  src_known = tnum_is_const(src_reg.var_off);",
      "2047:  dst_known = tnum_is_const(dst_reg->var_off);",
      "2049:  switch (opcode) {",
      "2050:  case BPF_ADD:",
      "2051:   if (signed_add_overflows(dst_reg->smin_value, smin_val) ||",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2091:  if (!src_known &&",
      "2092:      opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {",
      "2093:   __mark_reg_unknown(dst_reg);",
      "2094:   return 0;",
      "2095:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
      "candidate_info": {
        "commit_hash": "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
        "files": [
          "include/linux/bpf_verifier.h",
          "include/linux/tnum.h",
          "kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf/verifier: track signed and unsigned min/max values\n\nAllows us to, sometimes, combine information from a signed check of one\n bound and an unsigned check of the other.\nWe now track the full range of possible values, rather than restricting\n ourselves to [0, 1<<30) and considering anything beyond that as\n unknown.  While this is probably not necessary, it makes the code more\n straightforward and symmetrical between signed and unsigned bounds.\n\nSigned-off-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "include/linux/tnum.h||include/linux/tnum.h",
          "kernel/bpf/tnum.c||kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <linux/tnum.h>",
          "20: struct bpf_reg_state {",
          "21:  enum bpf_reg_type type;",
          "",
          "[Removed Lines]",
          "17: #define BPF_REGISTER_MAX_RANGE (1024 * 1024 * 1024)",
          "18: #define BPF_REGISTER_MIN_RANGE -1",
          "",
          "[Added Lines]",
          "18: #define BPF_MAX_VAR_OFF (1ULL << 31)",
          "22: #define BPF_MAX_VAR_SIZ INT_MAX",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55: };",
          "57: enum bpf_stack_slot_type {",
          "",
          "[Removed Lines]",
          "52:  s64 min_value;",
          "53:  u64 max_value;",
          "54:  bool value_from_signed;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/tnum.h||include/linux/tnum.h": [
          "File: include/linux/tnum.h -> include/linux/tnum.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: struct tnum tnum_const(u64 value);",
          "19: extern const struct tnum tnum_unknown;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: struct tnum tnum_range(u64 min, u64 max);",
          "",
          "---------------"
        ],
        "kernel/bpf/tnum.c||kernel/bpf/tnum.c": [
          "File: kernel/bpf/tnum.c -> kernel/bpf/tnum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:  return TNUM(value, 0);",
          "18: }",
          "20: struct tnum tnum_lshift(struct tnum a, u8 shift)",
          "21: {",
          "22:  return TNUM(a.value << shift, a.mask << shift);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: struct tnum tnum_range(u64 min, u64 max)",
          "21: {",
          "22:  u64 chi = min ^ max, delta;",
          "23:  u8 bits = fls64(chi);",
          "26:  if (bits > 63)",
          "27:   return tnum_unknown;",
          "32:  delta = (1ULL << bits) - 1;",
          "33:  return TNUM(min & ~delta, delta);",
          "34: }",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:     verbose(\",ks=%d,vs=%d\",",
          "235:      reg->map_ptr->key_size,",
          "236:      reg->map_ptr->value_size);",
          "243:    if (!tnum_is_unknown(reg->var_off)) {",
          "244:     char tn_buf[48];",
          "",
          "[Removed Lines]",
          "237:    if (reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "238:     verbose(\",min_value=%lld\",",
          "239:      (long long)reg->min_value);",
          "240:    if (reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "241:     verbose(\",max_value=%llu\",",
          "242:      (unsigned long long)reg->max_value);",
          "",
          "[Added Lines]",
          "237:    if (reg->smin_value != reg->umin_value &&",
          "238:        reg->smin_value != S64_MIN)",
          "239:     verbose(\",smin_value=%lld\",",
          "240:      (long long)reg->smin_value);",
          "241:    if (reg->smax_value != reg->umax_value &&",
          "242:        reg->smax_value != S64_MAX)",
          "243:     verbose(\",smax_value=%lld\",",
          "244:      (long long)reg->smax_value);",
          "245:    if (reg->umin_value != 0)",
          "246:     verbose(\",umin_value=%llu\",",
          "247:      (unsigned long long)reg->umin_value);",
          "248:    if (reg->umax_value != U64_MAX)",
          "249:     verbose(\",umax_value=%llu\",",
          "250:      (unsigned long long)reg->umax_value);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "467: static void __mark_reg_not_init(struct bpf_reg_state *reg);",
          "472: static void __mark_reg_known_zero(struct bpf_reg_state *reg)",
          "473: {",
          "477: }",
          "479: static void mark_reg_known_zero(struct bpf_reg_state *regs, u32 regno)",
          "",
          "[Removed Lines]",
          "474:  reg->var_off = tnum_const(0);",
          "475:  reg->min_value = 0;",
          "476:  reg->max_value = 0;",
          "",
          "[Added Lines]",
          "480: static void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)",
          "481: {",
          "482:  reg->id = 0;",
          "483:  reg->var_off = tnum_const(imm);",
          "484:  reg->smin_value = (s64)imm;",
          "485:  reg->smax_value = (s64)imm;",
          "486:  reg->umin_value = imm;",
          "487:  reg->umax_value = imm;",
          "488: }",
          "495:  __mark_reg_known(reg, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "488:  __mark_reg_known_zero(regs + regno);",
          "489: }",
          "492: static void __mark_reg_unknown(struct bpf_reg_state *reg)",
          "493: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "511: static void __update_reg_bounds(struct bpf_reg_state *reg)",
          "512: {",
          "514:  reg->smin_value = max_t(s64, reg->smin_value,",
          "515:     reg->var_off.value | (reg->var_off.mask & S64_MIN));",
          "517:  reg->smax_value = min_t(s64, reg->smax_value,",
          "518:     reg->var_off.value | (reg->var_off.mask & S64_MAX));",
          "519:  reg->umin_value = max(reg->umin_value, reg->var_off.value);",
          "520:  reg->umax_value = min(reg->umax_value,",
          "521:          reg->var_off.value | reg->var_off.mask);",
          "522: }",
          "525: static void __reg_deduce_bounds(struct bpf_reg_state *reg)",
          "526: {",
          "532:  if (reg->smin_value >= 0 || reg->smax_value < 0) {",
          "533:   reg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,",
          "534:          reg->umin_value);",
          "535:   reg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,",
          "536:          reg->umax_value);",
          "537:   return;",
          "538:  }",
          "542:  if ((s64)reg->umax_value >= 0) {",
          "546:   reg->smin_value = reg->umin_value;",
          "547:   reg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,",
          "548:          reg->umax_value);",
          "549:  } else if ((s64)reg->umin_value < 0) {",
          "553:   reg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,",
          "554:          reg->umin_value);",
          "555:   reg->smax_value = reg->umax_value;",
          "556:  }",
          "557: }",
          "560: static void __reg_bound_offset(struct bpf_reg_state *reg)",
          "561: {",
          "562:  reg->var_off = tnum_intersect(reg->var_off,",
          "563:           tnum_range(reg->umin_value,",
          "564:        reg->umax_value));",
          "565: }",
          "568: static void __mark_reg_unbounded(struct bpf_reg_state *reg)",
          "569: {",
          "570:  reg->smin_value = S64_MIN;",
          "571:  reg->smax_value = S64_MAX;",
          "572:  reg->umin_value = 0;",
          "573:  reg->umax_value = U64_MAX;",
          "574: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "495:  reg->id = 0;",
          "496:  reg->off = 0;",
          "497:  reg->var_off = tnum_unknown;",
          "500: }",
          "502: static void mark_reg_unknown(struct bpf_reg_state *regs, u32 regno)",
          "",
          "[Removed Lines]",
          "498:  reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "499:  reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "",
          "[Added Lines]",
          "583:  __mark_reg_unbounded(reg);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "545:  mark_reg_known_zero(regs, BPF_REG_1);",
          "546: }",
          "555: enum reg_arg_type {",
          "",
          "[Removed Lines]",
          "548: static void reset_reg_range_values(struct bpf_reg_state *regs, u32 regno)",
          "549: {",
          "550:  regs[regno].min_value = BPF_REGISTER_MIN_RANGE;",
          "551:  regs[regno].max_value = BPF_REGISTER_MAX_RANGE;",
          "552:  regs[regno].value_from_signed = false;",
          "553: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "720:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "721:    regno);",
          "722:   return -EACCES;",
          "723:  }",
          "725:  if (err) {",
          "726:   verbose(\"R%d min value is outside of the array range\\n\", regno);",
          "727:   return err;",
          "728:  }",
          "734:   verbose(\"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",",
          "735:    regno);",
          "736:   return -EACCES;",
          "737:  }",
          "739:  if (err)",
          "740:   verbose(\"R%d max value is outside of the array range\\n\", regno);",
          "741:  return err;",
          "",
          "[Removed Lines]",
          "719:  if (reg->min_value < 0) {",
          "724:  err = __check_map_access(env, regno, reg->min_value + off, size);",
          "733:  if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "738:  err = __check_map_access(env, regno, reg->max_value + off, size);",
          "",
          "[Added Lines]",
          "796:  if (reg->smin_value < 0) {",
          "801:  err = __check_map_access(env, regno, reg->smin_value + off, size);",
          "811:  if (reg->umax_value >= BPF_MAX_VAR_OFF) {",
          "816:  err = __check_map_access(env, regno, reg->umax_value + off, size);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "801:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "802:    regno);",
          "803:   return -EACCES;",
          "",
          "[Removed Lines]",
          "800:  if (reg->min_value < 0) {",
          "",
          "[Added Lines]",
          "878:  if (reg->smin_value < 0) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1071:   state->regs[value_regno].var_off = tnum_cast(",
          "1072:      state->regs[value_regno].var_off, size);",
          "1079:  }",
          "1080:  return err;",
          "1081: }",
          "",
          "[Removed Lines]",
          "1074:   state->regs[value_regno].min_value = 0;",
          "1075:   state->regs[value_regno].max_value = min_t(u64,",
          "1076:      state->regs[value_regno].var_off.value |",
          "1077:      state->regs[value_regno].var_off.mask,",
          "1078:      BPF_REGISTER_MAX_RANGE);",
          "",
          "[Added Lines]",
          "1151:   __update_reg_bounds(&state->regs[value_regno]);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1334:    meta = NULL;",
          "1337:    verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "1338:     regno);",
          "1339:    return -EACCES;",
          "1340:   }",
          "1343:    err = check_helper_mem_access(env, regno - 1, 0,",
          "1344:             zero_size_allowed,",
          "1345:             meta);",
          "",
          "[Removed Lines]",
          "1336:   if (reg->min_value < 0) {",
          "1342:   if (reg->min_value == 0) {",
          "",
          "[Added Lines]",
          "1409:   if (reg->smin_value < 0) {",
          "1415:   if (reg->umin_value == 0) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1347:     return err;",
          "1348:   }",
          "1351:    verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "1352:     regno);",
          "1353:    return -EACCES;",
          "1354:   }",
          "1355:   err = check_helper_mem_access(env, regno - 1,",
          "1357:            zero_size_allowed, meta);",
          "1358:  }",
          "",
          "[Removed Lines]",
          "1350:   if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "1356:            reg->max_value,",
          "",
          "[Added Lines]",
          "1423:   if (reg->umax_value >= BPF_MAX_VAR_SIZ) {",
          "1429:            reg->umax_value,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1600:  return 0;",
          "1601: }",
          "1612: static void coerce_reg_to_32(struct bpf_reg_state *reg)",
          "1613: {",
          "1618:  reg->var_off = tnum_cast(reg->var_off, 4);",
          "1626: }",
          "",
          "[Removed Lines]",
          "1603: static void check_reg_overflow(struct bpf_reg_state *reg)",
          "1604: {",
          "1605:  if (reg->max_value > BPF_REGISTER_MAX_RANGE)",
          "1606:   reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1607:  if (reg->min_value < BPF_REGISTER_MIN_RANGE ||",
          "1608:      reg->min_value > BPF_REGISTER_MAX_RANGE)",
          "1609:   reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1610: }",
          "1615:  if (reg->min_value < 0)",
          "1616:   reg->min_value = 0;",
          "1620:  if (tnum_is_const(reg->var_off)) {",
          "1621:   if ((s64)reg->var_off.value > BPF_REGISTER_MIN_RANGE)",
          "1622:    reg->min_value = reg->var_off.value;",
          "1623:   if (reg->var_off.value < BPF_REGISTER_MAX_RANGE)",
          "1624:    reg->max_value = reg->var_off.value;",
          "1625:  }",
          "",
          "[Added Lines]",
          "1681:  __update_reg_bounds(reg);",
          "1682: }",
          "1684: static bool signed_add_overflows(s64 a, s64 b)",
          "1685: {",
          "1687:  s64 res = (s64)((u64)a + (u64)b);",
          "1689:  if (b < 0)",
          "1690:   return res > a;",
          "1691:  return res < a;",
          "1692: }",
          "1694: static bool signed_sub_overflows(s64 a, s64 b)",
          "1695: {",
          "1697:  s64 res = (s64)((u64)a - (u64)b);",
          "1699:  if (b < 0)",
          "1700:   return res < a;",
          "1701:  return res > a;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1638: {",
          "1639:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "1640:  bool known = tnum_is_const(off_reg->var_off);",
          "1643:  u8 opcode = BPF_OP(insn->code);",
          "1644:  u32 dst = insn->dst_reg;",
          "1646:  dst_reg = &regs[dst];",
          "1649:   print_verifier_state(&env->cur_state);",
          "1651:   return -EINVAL;",
          "1652:  }",
          "",
          "[Removed Lines]",
          "1641:  s64 min_val = off_reg->min_value;",
          "1642:  u64 max_val = off_reg->max_value;",
          "1648:  if (WARN_ON_ONCE(known && (min_val != max_val))) {",
          "1650:   verbose(\"verifier internal error\\n\");",
          "",
          "[Added Lines]",
          "1716:  s64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,",
          "1717:      smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;",
          "1718:  u64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,",
          "1719:      umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;",
          "1725:  if (WARN_ON_ONCE(known && (smin_val != smax_val))) {",
          "1727:   verbose(\"verifier internal error: known but bad sbounds\\n\");",
          "1728:   return -EINVAL;",
          "1729:  }",
          "1730:  if (WARN_ON_ONCE(known && (umin_val != umax_val))) {",
          "1731:   print_verifier_state(&env->cur_state);",
          "1732:   verbose(\"verifier internal error: known but bad ubounds\\n\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1697:    dst_reg->var_off = ptr_reg->var_off;",
          "1699:    dst_reg->range = ptr_reg->range;",
          "1700:    break;",
          "1701:   }",
          "",
          "[Removed Lines]",
          "1692:   if (known && (ptr_reg->off + min_val ==",
          "1693:          (s64)(s32)(ptr_reg->off + min_val))) {",
          "1695:    dst_reg->min_value = ptr_reg->min_value;",
          "1696:    dst_reg->max_value = ptr_reg->max_value;",
          "1698:    dst_reg->off = ptr_reg->off + min_val;",
          "1702:   if (max_val == BPF_REGISTER_MAX_RANGE) {",
          "1703:    if (!env->allow_ptr_leaks)",
          "1704:     verbose(\"R%d tried to add unbounded value to pointer\\n\",",
          "1705:      dst);",
          "1706:    return -EACCES;",
          "1707:   }",
          "",
          "[Added Lines]",
          "1774:   if (known && (ptr_reg->off + smin_val ==",
          "1775:          (s64)(s32)(ptr_reg->off + smin_val))) {",
          "1777:    dst_reg->smin_value = smin_ptr;",
          "1778:    dst_reg->smax_value = smax_ptr;",
          "1779:    dst_reg->umin_value = umin_ptr;",
          "1780:    dst_reg->umax_value = umax_ptr;",
          "1782:    dst_reg->off = ptr_reg->off + smin_val;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1723:   dst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);",
          "1724:   dst_reg->off = ptr_reg->off;",
          "1725:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "",
          "[Removed Lines]",
          "1717:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1718:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1719:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1720:    dst_reg->min_value += min_val;",
          "1721:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1722:    dst_reg->max_value += max_val;",
          "",
          "[Added Lines]",
          "1795:   if (signed_add_overflows(smin_ptr, smin_val) ||",
          "1796:       signed_add_overflows(smax_ptr, smax_val)) {",
          "1797:    dst_reg->smin_value = S64_MIN;",
          "1798:    dst_reg->smax_value = S64_MAX;",
          "1799:   } else {",
          "1800:    dst_reg->smin_value = smin_ptr + smin_val;",
          "1801:    dst_reg->smax_value = smax_ptr + smax_val;",
          "1802:   }",
          "1803:   if (umin_ptr + umin_val < umin_ptr ||",
          "1804:       umax_ptr + umax_val < umax_ptr) {",
          "1805:    dst_reg->umin_value = 0;",
          "1806:    dst_reg->umax_value = U64_MAX;",
          "1807:   } else {",
          "1808:    dst_reg->umin_value = umin_ptr + umin_val;",
          "1809:    dst_reg->umax_value = umax_ptr + umax_val;",
          "1810:   }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1746:      dst);",
          "1747:    return -EACCES;",
          "1748:   }",
          "1754:    dst_reg->var_off = ptr_reg->var_off;",
          "1755:    dst_reg->id = ptr_reg->id;",
          "1757:    dst_reg->range = ptr_reg->range;",
          "1758:    break;",
          "1759:   }",
          "1780:   dst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);",
          "1781:   dst_reg->off = ptr_reg->off;",
          "1782:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "1783:    dst_reg->id = ++env->id_gen;",
          "1786:     dst_reg->range = 0;",
          "1787:   }",
          "1788:   break;",
          "",
          "[Removed Lines]",
          "1749:   if (known && (ptr_reg->off - min_val ==",
          "1750:          (s64)(s32)(ptr_reg->off - min_val))) {",
          "1752:    dst_reg->min_value = ptr_reg->min_value;",
          "1753:    dst_reg->max_value = ptr_reg->max_value;",
          "1756:    dst_reg->off = ptr_reg->off - min_val;",
          "1763:   if ((s64)max_val < 0) {",
          "1764:    if (!env->allow_ptr_leaks)",
          "1765:     verbose(\"R%d tried to subtract negative max_val %lld from pointer\\n\",",
          "1766:      dst, (s64)max_val);",
          "1767:    return -EACCES;",
          "1768:   }",
          "1772:   if (max_val >= BPF_REGISTER_MAX_RANGE)",
          "1773:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1774:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1775:    dst_reg->min_value -= max_val;",
          "1776:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1777:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1778:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1779:    dst_reg->max_value -= min_val;",
          "1785:    if (min_val < 0)",
          "",
          "[Added Lines]",
          "1837:   if (known && (ptr_reg->off - smin_val ==",
          "1838:          (s64)(s32)(ptr_reg->off - smin_val))) {",
          "1840:    dst_reg->smin_value = smin_ptr;",
          "1841:    dst_reg->smax_value = smax_ptr;",
          "1842:    dst_reg->umin_value = umin_ptr;",
          "1843:    dst_reg->umax_value = umax_ptr;",
          "1846:    dst_reg->off = ptr_reg->off - smin_val;",
          "1853:   if (signed_sub_overflows(smin_ptr, smax_val) ||",
          "1854:       signed_sub_overflows(smax_ptr, smin_val)) {",
          "1856:    dst_reg->smin_value = S64_MIN;",
          "1857:    dst_reg->smax_value = S64_MAX;",
          "1858:   } else {",
          "1859:    dst_reg->smin_value = smin_ptr - smax_val;",
          "1860:    dst_reg->smax_value = smax_ptr - smin_val;",
          "1861:   }",
          "1862:   if (umin_ptr < umax_val) {",
          "1864:    dst_reg->umin_value = 0;",
          "1865:    dst_reg->umax_value = U64_MAX;",
          "1866:   } else {",
          "1868:    dst_reg->umin_value = umin_ptr - umax_val;",
          "1869:    dst_reg->umax_value = umax_ptr - umin_val;",
          "1870:   }",
          "1876:    if (smin_val < 0)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1805:   return -EACCES;",
          "1806:  }",
          "1809:  return 0;",
          "1810: }",
          "",
          "[Removed Lines]",
          "1808:  check_reg_overflow(dst_reg);",
          "",
          "[Added Lines]",
          "1899:  __update_reg_bounds(dst_reg);",
          "1900:  __reg_deduce_bounds(dst_reg);",
          "1901:  __reg_bound_offset(dst_reg);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1815:           struct bpf_reg_state src_reg)",
          "1816: {",
          "1817:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1820:  u8 opcode = BPF_OP(insn->code);",
          "1821:  bool src_known, dst_known;",
          "1823:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1825:   coerce_reg_to_32(dst_reg);",
          "1826:   coerce_reg_to_32(&src_reg);",
          "1827:  }",
          "1830:  src_known = tnum_is_const(src_reg.var_off);",
          "1831:  dst_known = tnum_is_const(dst_reg->var_off);",
          "1833:  switch (opcode) {",
          "1834:  case BPF_ADD:",
          "1842:   dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);",
          "1843:   break;",
          "1844:  case BPF_SUB:",
          "1853:   dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);",
          "1854:   break;",
          "1855:  case BPF_MUL:",
          "1859:    break;",
          "1860:   }",
          "1870:   break;",
          "1871:  case BPF_AND:",
          "1872:   if (src_known && dst_known) {",
          "1878:    break;",
          "1879:   }",
          "1885:   dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);",
          "1891:   break;",
          "1892:  case BPF_OR:",
          "1893:   if (src_known && dst_known) {",
          "1899:    break;",
          "1900:   }",
          "1905:   dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);",
          "1909:   } else {",
          "1912:   }",
          "1913:   break;",
          "1914:  case BPF_LSH:",
          "1917:    mark_reg_unknown(regs, insn->dst_reg);",
          "1918:    break;",
          "1919:   }",
          "1927:   } else {",
          "1934:   }",
          "1939:   break;",
          "1940:  case BPF_RSH:",
          "1943:    mark_reg_unknown(regs, insn->dst_reg);",
          "1944:    break;",
          "1945:   }",
          "1951:   } else {",
          "1954:   }",
          "1955:   if (src_known)",
          "1957:   else",
          "1962:   break;",
          "1963:  default:",
          "1964:   mark_reg_unknown(regs, insn->dst_reg);",
          "1965:   break;",
          "1966:  }",
          "1969:  return 0;",
          "1970: }",
          "",
          "[Removed Lines]",
          "1818:  s64 min_val = BPF_REGISTER_MIN_RANGE;",
          "1819:  u64 max_val = BPF_REGISTER_MAX_RANGE;",
          "1828:  min_val = src_reg.min_value;",
          "1829:  max_val = src_reg.max_value;",
          "1835:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1836:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1837:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1838:    dst_reg->min_value += min_val;",
          "1840:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1841:    dst_reg->max_value += max_val;",
          "1845:   if (max_val == BPF_REGISTER_MAX_RANGE)",
          "1846:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1847:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1848:    dst_reg->min_value -= max_val;",
          "1849:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1850:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1851:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1852:    dst_reg->max_value -= min_val;",
          "1856:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1858:    __mark_reg_unknown(dst_reg);",
          "1861:   dst_reg->min_value *= min_val;",
          "1866:   BUILD_BUG_ON(BPF_REGISTER_MAX_RANGE > (u32)-1);",
          "1867:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1868:    dst_reg->max_value *= max_val;",
          "1869:   dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);",
          "1873:    u64 value = dst_reg->var_off.value & src_reg.var_off.value;",
          "1875:    dst_reg->var_off = tnum_const(value);",
          "1876:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1877:      value, BPF_REGISTER_MAX_RANGE);",
          "1886:   if (min_val < 0 && dst_reg->min_value < 0)",
          "1887:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1888:   else",
          "1889:    dst_reg->min_value = dst_reg->var_off.value;",
          "1890:   dst_reg->max_value = min(dst_reg->max_value, max_val);",
          "1894:    u64 value = dst_reg->var_off.value | src_reg.var_off.value;",
          "1896:    dst_reg->var_off = tnum_const(value);",
          "1897:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1898:      value, BPF_REGISTER_MAX_RANGE);",
          "1906:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1907:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1908:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1910:    dst_reg->min_value = max(dst_reg->min_value, min_val);",
          "1911:    dst_reg->max_value = dst_reg->var_off.value | dst_reg->var_off.mask;",
          "1915:   if (min_val < 0) {",
          "1924:   if (min_val > ilog2(BPF_REGISTER_MAX_RANGE)) {",
          "1925:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1926:    dst_reg->var_off = tnum_unknown;",
          "1928:    if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1929:     dst_reg->min_value <<= min_val;",
          "1930:    if (src_known)",
          "1931:     dst_reg->var_off = tnum_lshift(dst_reg->var_off, min_val);",
          "1932:    else",
          "1933:     dst_reg->var_off = tnum_lshift(tnum_unknown, min_val);",
          "1935:   if (max_val > ilog2(BPF_REGISTER_MAX_RANGE))",
          "1936:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1937:   else if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1938:    dst_reg->max_value <<= max_val;",
          "1941:   if (min_val < 0) {",
          "1947:   if (dst_reg->min_value < 0) {",
          "1948:    if (min_val)",
          "1950:     dst_reg->min_value = 0;",
          "1952:    dst_reg->min_value =",
          "1953:     (u64)(dst_reg->min_value) >> min_val;",
          "1956:    dst_reg->var_off = tnum_rshift(dst_reg->var_off, min_val);",
          "1958:    dst_reg->var_off = tnum_rshift(tnum_unknown, min_val);",
          "1959:   if (dst_reg->max_value == BPF_REGISTER_MAX_RANGE)",
          "1960:    dst_reg->max_value = ~0;",
          "1961:   dst_reg->max_value >>= max_val;",
          "1968:  check_reg_overflow(dst_reg);",
          "",
          "[Added Lines]",
          "1913:  s64 smin_val, smax_val;",
          "1914:  u64 umin_val, umax_val;",
          "1921:  smin_val = src_reg.smin_value;",
          "1922:  smax_val = src_reg.smax_value;",
          "1923:  umin_val = src_reg.umin_value;",
          "1924:  umax_val = src_reg.umax_value;",
          "1930:   if (signed_add_overflows(dst_reg->smin_value, smin_val) ||",
          "1931:       signed_add_overflows(dst_reg->smax_value, smax_val)) {",
          "1932:    dst_reg->smin_value = S64_MIN;",
          "1933:    dst_reg->smax_value = S64_MAX;",
          "1934:   } else {",
          "1935:    dst_reg->smin_value += smin_val;",
          "1936:    dst_reg->smax_value += smax_val;",
          "1937:   }",
          "1938:   if (dst_reg->umin_value + umin_val < umin_val ||",
          "1939:       dst_reg->umax_value + umax_val < umax_val) {",
          "1940:    dst_reg->umin_value = 0;",
          "1941:    dst_reg->umax_value = U64_MAX;",
          "1942:   } else {",
          "1943:    dst_reg->umin_value += umin_val;",
          "1944:    dst_reg->umax_value += umax_val;",
          "1945:   }",
          "1949:   if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||",
          "1950:       signed_sub_overflows(dst_reg->smax_value, smin_val)) {",
          "1952:    dst_reg->smin_value = S64_MIN;",
          "1953:    dst_reg->smax_value = S64_MAX;",
          "1954:   } else {",
          "1955:    dst_reg->smin_value -= smax_val;",
          "1956:    dst_reg->smax_value -= smin_val;",
          "1957:   }",
          "1958:   if (dst_reg->umin_value < umax_val) {",
          "1960:    dst_reg->umin_value = 0;",
          "1961:    dst_reg->umax_value = U64_MAX;",
          "1962:   } else {",
          "1964:    dst_reg->umin_value -= umax_val;",
          "1965:    dst_reg->umax_value -= umin_val;",
          "1966:   }",
          "1970:   dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);",
          "1971:   if (smin_val < 0 || dst_reg->smin_value < 0) {",
          "1973:    __mark_reg_unbounded(dst_reg);",
          "1974:    __update_reg_bounds(dst_reg);",
          "1980:   if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {",
          "1982:    __mark_reg_unbounded(dst_reg);",
          "1984:    __update_reg_bounds(dst_reg);",
          "1985:    break;",
          "1986:   }",
          "1987:   dst_reg->umin_value *= umin_val;",
          "1988:   dst_reg->umax_value *= umax_val;",
          "1989:   if (dst_reg->umax_value > S64_MAX) {",
          "1991:    dst_reg->smin_value = S64_MIN;",
          "1992:    dst_reg->smax_value = S64_MAX;",
          "1993:   } else {",
          "1994:    dst_reg->smin_value = dst_reg->umin_value;",
          "1995:    dst_reg->smax_value = dst_reg->umax_value;",
          "1996:   }",
          "2000:    __mark_reg_known(dst_reg, dst_reg->var_off.value &",
          "2001:         src_reg.var_off.value);",
          "2008:   dst_reg->umin_value = dst_reg->var_off.value;",
          "2009:   dst_reg->umax_value = min(dst_reg->umax_value, umax_val);",
          "2010:   if (dst_reg->smin_value < 0 || smin_val < 0) {",
          "2014:    dst_reg->smin_value = S64_MIN;",
          "2015:    dst_reg->smax_value = S64_MAX;",
          "2016:   } else {",
          "2020:    dst_reg->smin_value = dst_reg->umin_value;",
          "2021:    dst_reg->smax_value = dst_reg->umax_value;",
          "2022:   }",
          "2024:   __update_reg_bounds(dst_reg);",
          "2028:    __mark_reg_known(dst_reg, dst_reg->var_off.value |",
          "2029:         src_reg.var_off.value);",
          "2036:   dst_reg->umin_value = max(dst_reg->umin_value, umin_val);",
          "2037:   dst_reg->umax_value = dst_reg->var_off.value |",
          "2038:           dst_reg->var_off.mask;",
          "2039:   if (dst_reg->smin_value < 0 || smin_val < 0) {",
          "2043:    dst_reg->smin_value = S64_MIN;",
          "2044:    dst_reg->smax_value = S64_MAX;",
          "2049:    dst_reg->smin_value = dst_reg->umin_value;",
          "2050:    dst_reg->smax_value = dst_reg->umax_value;",
          "2053:   __update_reg_bounds(dst_reg);",
          "2056:   if (umax_val > 63) {",
          "2066:   dst_reg->smin_value = S64_MIN;",
          "2067:   dst_reg->smax_value = S64_MAX;",
          "2069:   if (dst_reg->umax_value > 1ULL << (63 - umax_val)) {",
          "2070:    dst_reg->umin_value = 0;",
          "2071:    dst_reg->umax_value = U64_MAX;",
          "2073:    dst_reg->umin_value <<= umin_val;",
          "2074:    dst_reg->umax_value <<= umax_val;",
          "2076:   if (src_known)",
          "2077:    dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);",
          "2078:   else",
          "2079:    dst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);",
          "2081:   __update_reg_bounds(dst_reg);",
          "2084:   if (umax_val > 63) {",
          "2092:   if (dst_reg->smin_value < 0) {",
          "2093:    if (umin_val) {",
          "2095:     dst_reg->smin_value = 0;",
          "2096:    } else {",
          "2098:     dst_reg->smin_value = S64_MIN;",
          "2099:     dst_reg->smax_value = S64_MAX;",
          "2100:    }",
          "2102:    dst_reg->smin_value =",
          "2103:     (u64)(dst_reg->smin_value) >> umax_val;",
          "2106:    dst_reg->var_off = tnum_rshift(dst_reg->var_off,",
          "2107:              umin_val);",
          "2109:    dst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);",
          "2110:   dst_reg->umin_value >>= umax_val;",
          "2111:   dst_reg->umax_value >>= umin_val;",
          "2113:   __update_reg_bounds(dst_reg);",
          "2120:  __reg_deduce_bounds(dst_reg);",
          "2121:  __reg_bound_offset(dst_reg);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1981:  int rc;",
          "1983:  dst_reg = &regs[insn->dst_reg];",
          "1985:  src_reg = NULL;",
          "1986:  if (dst_reg->type != SCALAR_VALUE)",
          "1987:   ptr_reg = dst_reg;",
          "1988:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1989:   src_reg = &regs[insn->src_reg];",
          "1992:   if (src_reg->type != SCALAR_VALUE) {",
          "1993:    if (dst_reg->type != SCALAR_VALUE) {",
          "",
          "[Removed Lines]",
          "1984:  check_reg_overflow(dst_reg);",
          "1990:   check_reg_overflow(src_reg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2037:   off_reg.type = SCALAR_VALUE;",
          "2041:   src_reg = &off_reg;",
          "2044:    rc = adjust_ptr_min_max_vals(env, insn,",
          "2045:            ptr_reg, src_reg);",
          "",
          "[Removed Lines]",
          "2038:   off_reg.var_off = tnum_const(insn->imm);",
          "2039:   off_reg.min_value = insn->imm;",
          "2040:   off_reg.max_value = insn->imm;",
          "2042:   check_reg_overflow(src_reg);",
          "",
          "[Added Lines]",
          "2188:   __mark_reg_known(&off_reg, insn->imm);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2144:      return -EACCES;",
          "2145:     }",
          "2146:     mark_reg_unknown(regs, insn->dst_reg);",
          "2151:     regs[insn->dst_reg].var_off = tnum_cast(",
          "2152:       regs[insn->dst_reg].var_off, 4);",
          "2153:    }",
          "2154:   } else {",
          "2158:    regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2163:   }",
          "2165:  } else if (opcode > BPF_END) {",
          "",
          "[Removed Lines]",
          "2159:    regs[insn->dst_reg].var_off = tnum_const(insn->imm);",
          "2160:    regs[insn->dst_reg].max_value = insn->imm;",
          "2161:    regs[insn->dst_reg].min_value = insn->imm;",
          "2162:    regs[insn->dst_reg].id = 0;",
          "",
          "[Added Lines]",
          "2297:     __update_reg_bounds(&regs[insn->dst_reg]);",
          "2304:    __mark_reg_known(regs + insn->dst_reg, insn->imm);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2227:   return;",
          "",
          "[Removed Lines]",
          "2229:  if (dst_reg->max_value > MAX_PACKET_OFF ||",
          "2230:      dst_reg->max_value + dst_reg->off > MAX_PACKET_OFF)",
          "",
          "[Added Lines]",
          "2371:  if (dst_reg->umax_value > MAX_PACKET_OFF ||",
          "2372:      dst_reg->umax_value + dst_reg->off > MAX_PACKET_OFF)",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2291:        struct bpf_reg_state *false_reg, u64 val,",
          "2292:        u8 opcode)",
          "2293: {",
          "",
          "[Removed Lines]",
          "2294:  bool value_from_signed = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2312:   break;",
          "2313:  case BPF_JNE:",
          "2319:   break;",
          "2320:  case BPF_JGT:",
          "2323:  case BPF_JSGT:",
          "2339:   break;",
          "2340:  case BPF_JGE:",
          "2343:  case BPF_JSGE:",
          "2359:   break;",
          "2360:  default:",
          "2361:   break;",
          "2362:  }",
          "2366: }",
          "",
          "[Removed Lines]",
          "2310:   true_reg->max_value = true_reg->min_value = val;",
          "2311:   true_reg->var_off = tnum_const(val);",
          "2317:   false_reg->max_value = false_reg->min_value = val;",
          "2318:   false_reg->var_off = tnum_const(val);",
          "2321:   value_from_signed = false;",
          "2324:   if (true_reg->value_from_signed != value_from_signed)",
          "2325:    reset_reg_range_values(true_reg, 0);",
          "2326:   if (false_reg->value_from_signed != value_from_signed)",
          "2327:    reset_reg_range_values(false_reg, 0);",
          "2328:   if (opcode == BPF_JGT) {",
          "2330:    false_reg->min_value = 0;",
          "2331:   }",
          "2335:   false_reg->max_value = val;",
          "2336:   false_reg->value_from_signed = value_from_signed;",
          "2337:   true_reg->min_value = val + 1;",
          "2338:   true_reg->value_from_signed = value_from_signed;",
          "2341:   value_from_signed = false;",
          "2344:   if (true_reg->value_from_signed != value_from_signed)",
          "2345:    reset_reg_range_values(true_reg, 0);",
          "2346:   if (false_reg->value_from_signed != value_from_signed)",
          "2347:    reset_reg_range_values(false_reg, 0);",
          "2348:   if (opcode == BPF_JGE) {",
          "2350:    false_reg->min_value = 0;",
          "2351:   }",
          "2355:   false_reg->max_value = val - 1;",
          "2356:   false_reg->value_from_signed = value_from_signed;",
          "2357:   true_reg->min_value = val;",
          "2358:   true_reg->value_from_signed = value_from_signed;",
          "2364:  check_reg_overflow(false_reg);",
          "2365:  check_reg_overflow(true_reg);",
          "",
          "[Added Lines]",
          "2450:   __mark_reg_known(true_reg, val);",
          "2456:   __mark_reg_known(false_reg, val);",
          "2459:   false_reg->umax_value = min(false_reg->umax_value, val);",
          "2460:   true_reg->umin_value = max(true_reg->umin_value, val + 1);",
          "2461:   break;",
          "2463:   false_reg->smax_value = min_t(s64, false_reg->smax_value, val);",
          "2464:   true_reg->smin_value = max_t(s64, true_reg->smin_value, val + 1);",
          "2467:   false_reg->umax_value = min(false_reg->umax_value, val - 1);",
          "2468:   true_reg->umin_value = max(true_reg->umin_value, val);",
          "2469:   break;",
          "2471:   false_reg->smax_value = min_t(s64, false_reg->smax_value, val - 1);",
          "2472:   true_reg->smin_value = max_t(s64, true_reg->smin_value, val);",
          "2478:  __reg_deduce_bounds(false_reg);",
          "2479:  __reg_deduce_bounds(true_reg);",
          "2481:  __reg_bound_offset(false_reg);",
          "2482:  __reg_bound_offset(true_reg);",
          "2487:  __update_reg_bounds(false_reg);",
          "2488:  __update_reg_bounds(true_reg);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2372:     struct bpf_reg_state *false_reg, u64 val,",
          "2373:     u8 opcode)",
          "2374: {",
          "2377:  if (__is_pointer_value(false, false_reg))",
          "2378:   return;",
          "",
          "[Removed Lines]",
          "2375:  bool value_from_signed = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2387:   break;",
          "2388:  case BPF_JNE:",
          "2394:   break;",
          "2395:  case BPF_JGT:",
          "2398:  case BPF_JSGT:",
          "2415:   break;",
          "2416:  case BPF_JGE:",
          "2419:  case BPF_JSGE:",
          "2435:   break;",
          "2436:  default:",
          "2437:   break;",
          "2438:  }",
          "2442: }",
          "2445: static void __reg_combine_min_max(struct bpf_reg_state *src_reg,",
          "2446:       struct bpf_reg_state *dst_reg)",
          "2447: {",
          "2452:  src_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,",
          "2453:             dst_reg->var_off);",
          "2456: }",
          "2458: static void reg_combine_min_max(struct bpf_reg_state *true_src,",
          "",
          "[Removed Lines]",
          "2385:   true_reg->max_value = true_reg->min_value = val;",
          "2386:   true_reg->var_off = tnum_const(val);",
          "2392:   false_reg->max_value = false_reg->min_value = val;",
          "2393:   false_reg->var_off = tnum_const(val);",
          "2396:   value_from_signed = false;",
          "2399:   if (true_reg->value_from_signed != value_from_signed)",
          "2400:    reset_reg_range_values(true_reg, 0);",
          "2401:   if (false_reg->value_from_signed != value_from_signed)",
          "2402:    reset_reg_range_values(false_reg, 0);",
          "2403:   if (opcode == BPF_JGT) {",
          "2405:    true_reg->min_value = 0;",
          "2406:   }",
          "2411:   false_reg->min_value = val;",
          "2412:   false_reg->value_from_signed = value_from_signed;",
          "2413:   true_reg->max_value = val - 1;",
          "2414:   true_reg->value_from_signed = value_from_signed;",
          "2417:   value_from_signed = false;",
          "2420:   if (true_reg->value_from_signed != value_from_signed)",
          "2421:    reset_reg_range_values(true_reg, 0);",
          "2422:   if (false_reg->value_from_signed != value_from_signed)",
          "2423:    reset_reg_range_values(false_reg, 0);",
          "2424:   if (opcode == BPF_JGE) {",
          "2426:    true_reg->min_value = 0;",
          "2427:   }",
          "2431:   false_reg->min_value = val + 1;",
          "2432:   false_reg->value_from_signed = value_from_signed;",
          "2433:   true_reg->max_value = val;",
          "2434:   true_reg->value_from_signed = value_from_signed;",
          "2440:  check_reg_overflow(false_reg);",
          "2441:  check_reg_overflow(true_reg);",
          "2448:  src_reg->min_value = dst_reg->min_value = max(src_reg->min_value,",
          "2449:             dst_reg->min_value);",
          "2450:  src_reg->max_value = dst_reg->max_value = min(src_reg->max_value,",
          "2451:             dst_reg->max_value);",
          "2454:  check_reg_overflow(src_reg);",
          "2455:  check_reg_overflow(dst_reg);",
          "",
          "[Added Lines]",
          "2506:   __mark_reg_known(true_reg, val);",
          "2512:   __mark_reg_known(false_reg, val);",
          "2515:   true_reg->umax_value = min(true_reg->umax_value, val - 1);",
          "2516:   false_reg->umin_value = max(false_reg->umin_value, val);",
          "2517:   break;",
          "2519:   true_reg->smax_value = min_t(s64, true_reg->smax_value, val - 1);",
          "2520:   false_reg->smin_value = max_t(s64, false_reg->smin_value, val);",
          "2523:   true_reg->umax_value = min(true_reg->umax_value, val);",
          "2524:   false_reg->umin_value = max(false_reg->umin_value, val + 1);",
          "2525:   break;",
          "2527:   true_reg->smax_value = min_t(s64, true_reg->smax_value, val);",
          "2528:   false_reg->smin_value = max_t(s64, false_reg->smin_value, val + 1);",
          "2534:  __reg_deduce_bounds(false_reg);",
          "2535:  __reg_deduce_bounds(true_reg);",
          "2537:  __reg_bound_offset(false_reg);",
          "2538:  __reg_bound_offset(true_reg);",
          "2543:  __update_reg_bounds(false_reg);",
          "2544:  __update_reg_bounds(true_reg);",
          "2551:  src_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,",
          "2552:        dst_reg->umin_value);",
          "2553:  src_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,",
          "2554:        dst_reg->umax_value);",
          "2555:  src_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,",
          "2556:        dst_reg->smin_value);",
          "2557:  src_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,",
          "2558:        dst_reg->smax_value);",
          "2562:  __update_reg_bounds(src_reg);",
          "2563:  __update_reg_bounds(dst_reg);",
          "2565:  __reg_deduce_bounds(src_reg);",
          "2566:  __reg_deduce_bounds(dst_reg);",
          "2568:  __reg_bound_offset(src_reg);",
          "2569:  __reg_bound_offset(dst_reg);",
          "2574:  __update_reg_bounds(src_reg);",
          "2575:  __update_reg_bounds(dst_reg);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2467:   break;",
          "2468:  case BPF_JNE:",
          "2469:   __reg_combine_min_max(false_src, false_dst);",
          "2470:  }",
          "2471: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2590:   break;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2485:      reg->off)) {",
          "2488:   }",
          "2489:   if (is_null) {",
          "2490:    reg->type = SCALAR_VALUE;",
          "",
          "[Removed Lines]",
          "2483:   if (WARN_ON_ONCE(reg->min_value || reg->max_value ||",
          "2484:      reg->var_off.value || reg->var_off.mask ||",
          "2486:    reg->min_value = reg->max_value = reg->off = 0;",
          "2487:    reg->var_off = tnum_const(0);",
          "",
          "[Added Lines]",
          "2604:   if (WARN_ON_ONCE(reg->smin_value || reg->smax_value ||",
          "2605:      !tnum_equals_const(reg->var_off, 0) ||",
          "2607:    __mark_reg_known_zero(reg);",
          "2608:    reg->off = 0;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2676:   u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
          "2678:   regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2684:   return 0;",
          "2685:  }",
          "",
          "[Removed Lines]",
          "2679:   regs[insn->dst_reg].min_value = imm;",
          "2680:   regs[insn->dst_reg].max_value = imm;",
          "2681:   check_reg_overflow(&regs[insn->dst_reg]);",
          "2682:   regs[insn->dst_reg].var_off = tnum_const(imm);",
          "2683:   regs[insn->dst_reg].id = 0;",
          "",
          "[Added Lines]",
          "2800:   __mark_reg_known(&regs[insn->dst_reg], imm);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2968: static bool range_within(struct bpf_reg_state *old,",
          "2969:     struct bpf_reg_state *cur)",
          "2970: {",
          "2973: }",
          "",
          "[Removed Lines]",
          "2971:  return old->min_value <= cur->min_value &&",
          "2972:         old->max_value >= cur->max_value;",
          "",
          "[Added Lines]",
          "3088:  return old->umin_value <= cur->umin_value &&",
          "3089:         old->umax_value >= cur->umax_value &&",
          "3090:         old->smin_value <= cur->smin_value &&",
          "3091:         old->smax_value >= cur->smax_value;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3037:           tnum_is_unknown(rold->var_off);",
          "3038:   }",
          "3039:  case PTR_TO_MAP_VALUE:",
          "",
          "[Removed Lines]",
          "3035:    return rold->min_value == BPF_REGISTER_MIN_RANGE &&",
          "3036:           rold->max_value == BPF_REGISTER_MAX_RANGE &&",
          "",
          "[Added Lines]",
          "3154:    return rold->umin_value == 0 &&",
          "3155:           rold->umax_value == U64_MAX &&",
          "3156:           rold->smin_value == S64_MIN &&",
          "3157:           rold->smax_value == S64_MAX &&",
          "",
          "---------------"
        ]
      }
    }
  ]
}
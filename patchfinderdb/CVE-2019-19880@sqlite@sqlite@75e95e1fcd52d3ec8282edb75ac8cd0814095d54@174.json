{
  "cve_id": "CVE-2019-19880",
  "cve_desc": "exprListAppendList in window.c in SQLite 3.30.1 allows attackers to trigger an invalid pointer dereference because constant integer values in ORDER BY clauses of window definitions are mishandled.",
  "repo": "sqlite/sqlite",
  "patch_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
  "patch_info": {
    "commit_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/window.c"
    ],
    "message": "When processing constant integer values in ORDER BY clauses of window definitions (see check-in [7e4809eadfe99ebf]) be sure to fully disable the constant value to avoid an invalid pointer dereference if the expression is ever duplicated. This fixes a crash report from Yongheng and Rui.\n\nFossilOrigin-Name: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 8223e79f987feda5c8e51ec52cec6798cca16d070b10558939e2888ca1a25b8e",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "895:     int nInit = pList ? pList->nExpr : 0;",
      "896:     for(i=0; i<pAppend->nExpr; i++){",
      "897:       Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);",
      "898:       if( bIntToNull && pDup && pDup->op==TK_INTEGER ){",
      "899:         pDup->op = TK_NULL;",
      "900:         pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);",
      "901:       }",
      "902:       pList = sqlite3ExprListAppend(pParse, pList, pDup);",
      "903:       if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "898:       assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );",
      "902:         pDup->u.zToken = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c7d12f4ad4283f1b3a09d140c489319c9d2eb8f8",
      "candidate_info": {
        "commit_hash": "c7d12f4ad4283f1b3a09d140c489319c9d2eb8f8",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c7d12f4ad4283f1b3a09d140c489319c9d2eb8f8",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "src/whereInt.h",
          "src/whereexpr.c",
          "test/index6.test"
        ],
        "message": "When we play games with COLLATE in order to commute an operator in the WHERE clause processing, be sure not to use the commuted operator to qualify a partial index, as insufficient COLLATE information is preserved to verify that the expression will correctly qualify the index. Ticket [767a8cbc6d20bd68]\n\nFossilOrigin-Name: 5351e920f489562f959ab8a376ff720f845ea165e0cdc7c3a271aac53c2aa64a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "src/whereInt.h||src/whereInt.h",
          "src/whereexpr.c||src/whereexpr.c",
          "test/index6.test||test/index6.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6e7b4527d32cc1be0294614b9d7363d4b59cf654a954b86515b3f6888975ce73",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2800:   }",
          "2801:   if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;",
          "2802:   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){",
          "2804:     if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)",
          "2805:      && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)",
          "2806:     ){",
          "",
          "[Removed Lines]",
          "2803:     Expr *pExpr = pTerm->pExpr;",
          "",
          "[Added Lines]",
          "2803:     Expr *pExpr;",
          "2804:     if( pTerm->wtFlags & TERM_NOPARTIDX ) continue;",
          "2805:     pExpr = pTerm->pExpr;",
          "",
          "---------------"
        ],
        "src/whereInt.h||src/whereInt.h": [
          "File: src/whereInt.h -> src/whereInt.h"
        ],
        "src/whereexpr.c||src/whereexpr.c": [
          "File: src/whereexpr.c -> src/whereexpr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:   u16 expRight = (pExpr->pRight->flags & EP_Collate);",
          "123:   u16 expLeft = (pExpr->pLeft->flags & EP_Collate);",
          "124:   assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN );",
          "125:   if( expRight==expLeft ){",
          "",
          "[Removed Lines]",
          "121: static void exprCommute(Parse *pParse, Expr *pExpr){",
          "",
          "[Added Lines]",
          "126: static u16 exprCommute(Parse *pParse, Expr *pExpr){",
          "129:   u16 wtFlags = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:       pExpr->pRight->flags &= ~EP_Collate;",
          "131:     }else if( sqlite3ExprCollSeq(pParse, pExpr->pLeft)!=0 ){",
          "135:       pExpr->pLeft->flags |= EP_Collate;",
          "136:     }",
          "137:   }",
          "138:   SWAP(Expr*,pExpr->pRight,pExpr->pLeft);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137:       wtFlags |= TERM_NOPARTIDX;",
          "143:       wtFlags |= TERM_NOPARTIDX;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:     assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );",
          "145:     pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;",
          "146:   }",
          "147: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "155:   return wtFlags;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1140:         pDup = pExpr;",
          "1141:         pNew = pTerm;",
          "1142:       }",
          "1144:       pNew->leftCursor = aiCurCol[0];",
          "1145:       pNew->u.leftColumn = aiCurCol[1];",
          "1146:       testcase( (prereqLeft | extraRight) != prereqLeft );",
          "",
          "[Removed Lines]",
          "1143:       exprCommute(pParse, pDup);",
          "",
          "[Added Lines]",
          "1152:       pNew->wtFlags |= exprCommute(pParse, pDup);",
          "",
          "---------------"
        ],
        "test/index6.test||test/index6.test": [
          "File: test/index6.test -> test/index6.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "462:   SELECT 1 FROM t0 WHERE (c0 IS FALSE) IN (FALSE);",
          "463: } {1}",
          "466: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "465: # 2019-09-03",
          "466: # Ticket https://sqlite.org/src/info/767a8cbc6d20bd68",
          "467: do_execsql_test index6-16.1 {",
          "468:   DROP TABLE t0;",
          "469:   CREATE TABLE t0(c0 COLLATE NOCASE, c1);",
          "470:   CREATE INDEX i0 ON t0(0) WHERE c0 >= c1;",
          "471:   INSERT INTO t0 VALUES('a', 'B');",
          "472:   SELECT c1 <= c0, c0 >= c1 FROM t0;",
          "473: } {1 0}",
          "474: do_execsql_test index6-16.2 {",
          "475:   SELECT 2 FROM t0 WHERE c0 >= c1;",
          "476: } {}",
          "477: do_execsql_test index6-16.3 {",
          "478:   SELECT 3 FROM t0 WHERE c1 <= c0;",
          "479: } {3}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "920cf596e67ecccecb497cfa60cc65945048f866",
      "candidate_info": {
        "commit_hash": "920cf596e67ecccecb497cfa60cc65945048f866",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/920cf596e67ecccecb497cfa60cc65945048f866",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/analyze.c",
          "src/attach.c",
          "src/expr.c",
          "src/vdbe.c",
          "src/vdbe.h",
          "src/vdbeaux.c"
        ],
        "message": "Simplify the bytecode generation for SQL function calls such that the OP_Function or OP_PureFunc opcodes are coded directly, rather than using the intermediate OP_Function0 or OP_PureFunc0 - opcodes that are now removed.\n\nFossilOrigin-Name: 84e02d773d60cffe619104991d21d7f0c68616c0f6bb99686bf54f5306c756d0",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/analyze.c||src/analyze.c",
          "src/attach.c||src/attach.c",
          "src/expr.c||src/expr.c",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbe.h||src/vdbe.h",
          "src/vdbeaux.c||src/vdbeaux.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 13fe6978b7de208d2e27460d824f7fc778cf6ea0aabfe566b32bb410b8816f63",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/analyze.c||src/analyze.c": [
          "File: src/analyze.c -> src/analyze.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "916:   {0}",
          "917: };",
          "921: #ifdef SQLITE_ENABLE_STAT4",
          "923: #elif SQLITE_DEBUG",
          "924:   assert( iParam==STAT_GET_STAT1 );",
          "925: #else",
          "926:   UNUSED_PARAMETER( iParam );",
          "927: #endif",
          "931: }",
          "",
          "[Removed Lines]",
          "919: static void callStatGet(Vdbe *v, int regStat4, int iParam, int regOut){",
          "920:   assert( regOut!=regStat4 && regOut!=regStat4+1 );",
          "922:   sqlite3VdbeAddOp2(v, OP_Integer, iParam, regStat4+1);",
          "928:   sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4, regOut,",
          "929:                     (char*)&statGetFuncdef, P4_FUNCDEF);",
          "930:   sqlite3VdbeChangeP5(v, 1 + IsStat4);",
          "",
          "[Added Lines]",
          "919: static void callStatGet(Parse *pParse, int regStat4, int iParam, int regOut){",
          "921:   sqlite3VdbeAddOp2(pParse->pVdbe, OP_Integer, iParam, regStat4+1);",
          "927:   assert( regOut!=regStat4 && regOut!=regStat4+1 );",
          "928:   sqlite3VdbeAddFunctionCall(pParse, 0, regStat4, regOut, 1+IsStat4,",
          "929:                              &statGetFuncdef, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1095: #endif",
          "1096:     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat4+1);",
          "1097:     sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regStat4+2);",
          "",
          "[Removed Lines]",
          "1098:     sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4+1, regStat4,",
          "1099:                      (char*)&statInitFuncdef, P4_FUNCDEF);",
          "1100:     sqlite3VdbeChangeP5(v, 2+IsStat4);",
          "",
          "[Added Lines]",
          "1097:     sqlite3VdbeAddFunctionCall(pParse, 0, regStat4+1, regStat4, 2+IsStat4,",
          "1098:                                &statInitFuncdef, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1192:     }",
          "1193: #endif",
          "1194:     assert( regChng==(regStat4+1) );",
          "1198:     sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);",
          "1202:     assert( \"BBB\"[0]==SQLITE_AFF_TEXT );",
          "1203:     sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, \"BBB\", 0);",
          "1204:     sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);",
          "",
          "[Removed Lines]",
          "1195:     sqlite3VdbeAddOp4(v, OP_Function0, 1, regStat4, regTemp,",
          "1196:                      (char*)&statPushFuncdef, P4_FUNCDEF);",
          "1197:     sqlite3VdbeChangeP5(v, 2+IsStat4);",
          "1201:     callStatGet(v, regStat4, STAT_GET_STAT1, regStat1);",
          "",
          "[Added Lines]",
          "1193:     sqlite3VdbeAddFunctionCall(pParse, 1, regStat4, regTemp, 2+IsStat4,",
          "1194:                                &statPushFuncdef, 0);",
          "1198:     callStatGet(pParse, regStat4, STAT_GET_STAT1, regStat1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1224:       pParse->nMem = MAX(pParse->nMem, regCol+nCol);",
          "1226:       addrNext = sqlite3VdbeCurrentAddr(v);",
          "1228:       addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);",
          "1229:       VdbeCoverage(v);",
          "1233:       sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);",
          "1234:       VdbeCoverage(v);",
          "1235:       for(i=0; i<nCol; i++){",
          "",
          "[Removed Lines]",
          "1227:       callStatGet(v, regStat4, STAT_GET_ROWID, regSampleRowid);",
          "1230:       callStatGet(v, regStat4, STAT_GET_NEQ, regEq);",
          "1231:       callStatGet(v, regStat4, STAT_GET_NLT, regLt);",
          "1232:       callStatGet(v, regStat4, STAT_GET_NDLT, regDLt);",
          "",
          "[Added Lines]",
          "1224:       callStatGet(pParse, regStat4, STAT_GET_ROWID, regSampleRowid);",
          "1227:       callStatGet(pParse, regStat4, STAT_GET_NEQ, regEq);",
          "1228:       callStatGet(pParse, regStat4, STAT_GET_NLT, regLt);",
          "1229:       callStatGet(pParse, regStat4, STAT_GET_NDLT, regDLt);",
          "",
          "---------------"
        ],
        "src/attach.c||src/attach.c": [
          "File: src/attach.c -> src/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "402:   assert( v || db->mallocFailed );",
          "403:   if( v ){",
          "",
          "[Removed Lines]",
          "404:     sqlite3VdbeAddOp4(v, OP_Function0, 0, regArgs+3-pFunc->nArg, regArgs+3,",
          "405:                       (char *)pFunc, P4_FUNCDEF);",
          "406:     assert( pFunc->nArg==-1 || (pFunc->nArg&0xff)==pFunc->nArg );",
          "407:     sqlite3VdbeChangeP5(v, (u8)(pFunc->nArg));",
          "",
          "[Added Lines]",
          "404:     sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,",
          "405:                                pFunc->nArg, pFunc, 0);",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4032:       }else",
          "4033: #endif",
          "4034:       {",
          "4038:       }",
          "4039:       if( nFarg && constMask==0 ){",
          "4040:         sqlite3ReleaseTempRange(pParse, r1, nFarg);",
          "",
          "[Removed Lines]",
          "4035:         sqlite3VdbeAddOp4(v, pParse->iSelfTab ? OP_PureFunc0 : OP_Function0,",
          "4036:                           constMask, r1, target, (char*)pDef, P4_FUNCDEF);",
          "4037:         sqlite3VdbeChangeP5(v, (u8)nFarg);",
          "",
          "[Added Lines]",
          "4035:         sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,",
          "4036:                                    pDef, pParse->iSelfTab);",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7513:   int i;",
          "",
          "[Removed Lines]",
          "7488:   int n;",
          "7489:   sqlite3_context *pCtx;",
          "7491:   assert( pOp->p4type==P4_FUNCDEF );",
          "7492:   n = pOp->p5;",
          "7493:   assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );",
          "7494:   assert( n==0 || (pOp->p2>0 && pOp->p2+n<=(p->nMem+1 - p->nCursor)+1) );",
          "7495:   assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n );",
          "7496:   pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*));",
          "7497:   if( pCtx==0 ) goto no_mem;",
          "7498:   pCtx->pOut = 0;",
          "7499:   pCtx->pFunc = pOp->p4.pFunc;",
          "7500:   pCtx->iOp = (int)(pOp - aOp);",
          "7501:   pCtx->pVdbe = p;",
          "7502:   pCtx->isError = 0;",
          "7503:   pCtx->argc = n;",
          "7504:   pOp->p4type = P4_FUNCCTX;",
          "7505:   pOp->p4.pCtx = pCtx;",
          "7506:   assert( OP_PureFunc == OP_PureFunc0+2 );",
          "7507:   assert( OP_Function == OP_Function0+2 );",
          "7508:   pOp->opcode += 2;",
          "7510: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7523:   pOut = &aMem[pOp->p3];",
          "7524:   if( pCtx->pOut != pOut ){",
          "7525:     pCtx->pOut = pOut;",
          "7526:     for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];",
          "7527:   }",
          "7529:   memAboutToChange(p, pOut);",
          "7530: #ifdef SQLITE_DEBUG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7505:     pCtx->pVdbe = p;",
          "7509:   assert( pCtx->pVdbe==p );",
          "",
          "---------------"
        ],
        "src/vdbe.h||src/vdbe.h": [
          "File: src/vdbe.h -> src/vdbe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);",
          "191: int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);",
          "192: int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);",
          "193: void sqlite3VdbeEndCoroutine(Vdbe*,int);",
          "194: #if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)",
          "195:   void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: int sqlite3VdbeAddFunctionCall(Parse*,int,int,int,int,const FuncDef*,int);",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include \"sqliteInt.h\"",
          "16: #include \"vdbeInt.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef);",
          "20: static void vdbeFreeOpArray(sqlite3 *, Op *, int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "328:   return addr;",
          "329: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345: int sqlite3VdbeAddFunctionCall(",
          "353: ){",
          "354:   Vdbe *v = pParse->pVdbe;",
          "355:   int nByte;",
          "356:   int addr;",
          "357:   sqlite3_context *pCtx;",
          "358:   assert( v );",
          "359:   nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);",
          "360:   pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);",
          "361:   if( pCtx==0 ){",
          "362:     assert( pParse->db->mallocFailed );",
          "363:     freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);",
          "364:     return 0;",
          "365:   }",
          "366:   pCtx->pOut = 0;",
          "367:   pCtx->pFunc = (FuncDef*)pFunc;",
          "368:   pCtx->pVdbe = v;",
          "369:   pCtx->isError = 0;",
          "370:   pCtx->argc = nArg;",
          "371:   addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,",
          "372:                            p1, p2, p3, (char*)pCtx, P4_FUNCCTX);",
          "373:   pCtx->iOp = addr;",
          "374:   return addr;",
          "375: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1020:   }",
          "1021: }",
          "",
          "[Removed Lines]",
          "1023: static void vdbeFreeOpArray(sqlite3 *, Op *, int);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1031: }",
          "1032: static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){",
          "1033:   freeEphemeralFunction(db, p->pFunc);",
          "1035: }",
          "1036: static void freeP4(sqlite3 *db, int p4type, void *p4){",
          "1037:   assert( db );",
          "",
          "[Removed Lines]",
          "1034:  sqlite3DbFreeNN(db, p);",
          "",
          "[Added Lines]",
          "1078:   sqlite3DbFreeNN(db, p);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1537:       sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);",
          "1538:       break;",
          "1539:     }",
          "1541:     case P4_FUNCCTX: {",
          "1542:       FuncDef *pDef = pOp->p4.pCtx->pFunc;",
          "1543:       sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);",
          "1544:       break;",
          "1545:     }",
          "1547:     case P4_INT64: {",
          "1548:       sqlite3_str_appendf(&x, \"%lld\", *pOp->p4.pI64);",
          "1549:       break;",
          "",
          "[Removed Lines]",
          "1540: #if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)",
          "1546: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4961:   if( pCtx->pVdbe==0 ) return 1;",
          "4962: #endif",
          "4963:   if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==OP_PureFunc ){",
          "4964:     sqlite3_result_error(pCtx,",
          "4965:        \"non-deterministic function in index expression or CHECK constraint\",",
          "4966:        -1);",
          "4967:     return 0;",
          "4968:   }",
          "4969:   return 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5006: #if 0",
          "5007:     char *zMsg = sqlite3_mprintf(",
          "5008:        \"non-deterministic use of %s() in an index, CHECK constraint, \"",
          "5009:        \"or generated column\", pCtx->pFunc->zName);",
          "5010:     sqlite3_result_error(pCtx, zMsg, -1);",
          "5011:     sqlite3_free(zMsg);",
          "5012: #else",
          "5016: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a7c3b93fa634109dafd4170373d838faf6008d8a",
      "candidate_info": {
        "commit_hash": "a7c3b93fa634109dafd4170373d838faf6008d8a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a7c3b93fa634109dafd4170373d838faf6008d8a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c",
          "src/update.c"
        ],
        "message": "On an INSERT or UPDATE, generate the new table record prior to running foreign key checks, in case the foreign key checks changes datatypes on the registers holding column values.  Proposed fix for ticket [e63cbcfd3378afe6980d626].\n\nFossilOrigin-Name: 3f1c8051648a341db4dffad66d3b1f9980d8a2b314cb0ce879cb2a10d1779b84",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c",
          "src/update.c||src/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 8b6691f619ed9a56f6aecbd878ebb447c40984f8767508b248494fd9ec68fbaa",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "814:     int nIdx;",
          "815:     nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,",
          "816:                                       &iDataCur, &iIdxCur);",
          "818:     if( aRegIdx==0 ){",
          "819:       goto insert_cleanup;",
          "820:     }",
          "",
          "[Removed Lines]",
          "817:     aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+1));",
          "",
          "[Added Lines]",
          "817:     aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1845:     sqlite3VdbeJumpHere(v, ipkBottom);",
          "1846:   }",
          "1849:   VdbeModuleComment((v, \"END: GenCnstCks(%d)\", seenReplace));",
          "1850: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1858:   if( HasRowid(pTab) ){",
          "1859:     int regRec = aRegIdx[ix];",
          "1860:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nCol, regRec);",
          "1861:     sqlite3SetMakeRecordP5(v, pTab);",
          "1862:     if( !bAffinityDone ){",
          "1863:       sqlite3TableAffinity(v, pTab, 0);",
          "1864:     }",
          "1865:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1910:   for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){",
          "1911:     if( aRegIdx[i]==0 ) continue;",
          "1913:     if( pIdx->pPartIdxWhere ){",
          "1914:       sqlite3VdbeAddOp2(v, OP_IsNull, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);",
          "1915:       VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "1912:     bAffinityDone = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1937:     sqlite3VdbeChangeP5(v, pik_flags);",
          "1938:   }",
          "1939:   if( !HasRowid(pTab) ) return;",
          "1947:   if( pParse->nested ){",
          "1948:     pik_flags = 0;",
          "1949:   }else{",
          "",
          "[Removed Lines]",
          "1940:   regData = regNewData + 1;",
          "1941:   regRec = sqlite3GetTempReg(pParse);",
          "1942:   sqlite3VdbeAddOp3(v, OP_MakeRecord, regData, pTab->nCol, regRec);",
          "1943:   sqlite3SetMakeRecordP5(v, pTab);",
          "1944:   if( !bAffinityDone ){",
          "1945:     sqlite3TableAffinity(v, pTab, 0);",
          "1946:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1956:   if( useSeekResult ){",
          "1957:     pik_flags |= OPFLAG_USESEEKRESULT;",
          "1958:   }",
          "1960:   if( !pParse->nested ){",
          "1961:     sqlite3VdbeAppendP4(v, pTab, P4_TABLE);",
          "1962:   }",
          "",
          "[Removed Lines]",
          "1959:   sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, regRec, regNewData);",
          "",
          "[Added Lines]",
          "1967:   sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, aRegIdx[i], regNewData);",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277:   if( aXRef==0 ) goto update_cleanup;",
          "278:   aRegIdx = aXRef+pTab->nCol;",
          "280:   memset(aToOpen, 1, nIdx+1);",
          "281:   aToOpen[nIdx+1] = 0;",
          "282:   for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;",
          "",
          "[Removed Lines]",
          "276:   aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx) + nIdx+2 );",
          "279:   aToOpen = (u8*)(aRegIdx+nIdx);",
          "",
          "[Added Lines]",
          "276:   aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );",
          "279:   aToOpen = (u8*)(aRegIdx+nIdx+1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
      "candidate_info": {
        "commit_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1cf197583de15d352dc169437f619d2e4631cf4b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/malloc.c",
          "src/sqliteInt.h",
          "src/tokenize.c"
        ],
        "message": "Give the sqlite3 object a pointer to the current Parse so that if an OOM occurs, it can automatically set the Parse.rc value to SQLITE_NOMEM.  This avoids a frequent extra test of db.mallocFailed in the innermost parser loop.\n\nFossilOrigin-Name: 5c6638040b3017c6be016441422d965a3ca00dd6ae1f78cadc0b54562978f64e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/malloc.c||src/malloc.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/tokenize.c||src/tokenize.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 440a7cda000164d3b46109caf2e1dde80681ba9b0d94ba9be6847d2b917445cf",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/malloc.c||src/malloc.c": [
          "File: src/malloc.c -> src/malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "661:       db->u1.isInterrupted = 1;",
          "662:     }",
          "663:     db->lookaside.bDisable++;",
          "664:   }",
          "665: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "664:     if( db->pParse ){",
          "665:       db->pParse->rc = SQLITE_NOMEM_BKPT;",
          "666:     }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/tokenize.c||src/tokenize.c": [
          "File: src/tokenize.c -> src/tokenize.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "563: #ifdef sqlite3Parser_ENGINEALWAYSONSTACK",
          "565: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:   VVA_ONLY( u8 startedWithOom = db->mallocFailed );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "594:   assert( pParse->pNewTrigger==0 );",
          "595:   assert( pParse->nVar==0 );",
          "596:   assert( pParse->pVList==0 );",
          "597:   while( 1 ){",
          "598:     n = sqlite3GetToken((u8*)zSql, &tokenType);",
          "599:     mxSqlLen -= n;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "598:   pParse->pParentParse = db->pParse;",
          "599:   db->pParse = pParse;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "650:     sqlite3Parser(pEngine, tokenType, pParse->sLastToken);",
          "651:     lastTokenParsed = tokenType;",
          "652:     zSql += n;",
          "654:   }",
          "655:   assert( nErr==0 );",
          "656: #ifdef YYTRACKMAXSTACKDEPTH",
          "",
          "[Removed Lines]",
          "653:     if( pParse->rc!=SQLITE_OK || db->mallocFailed ) break;",
          "",
          "[Added Lines]",
          "656:     assert( db->mallocFailed==0 || pParse->rc!=SQLITE_OK || startedWithOom );",
          "657:     if( pParse->rc!=SQLITE_OK ) break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "718:     pParse->pZombieTab = p->pNextZombie;",
          "719:     sqlite3DeleteTable(db, p);",
          "720:   }",
          "721:   assert( nErr==0 || pParse->rc!=SQLITE_OK );",
          "722:   return nErr;",
          "723: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "725:   db->pParse = pParse->pParentParse;",
          "726:   pParse->pParentParse = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c3bb59f76bd1cc196e6a5609017555b228eb64c",
      "candidate_info": {
        "commit_hash": "9c3bb59f76bd1cc196e6a5609017555b228eb64c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9c3bb59f76bd1cc196e6a5609017555b228eb64c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Fix the build for when -DSQLITE_SMALL_STACK is used.\n\nFossilOrigin-Name: b9eda2249ab5cf523093e4849c317d9a4b1743f7e15d96bdd6bb6cc423302914",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 89bf0399e87be76e7b264e0a35e8a6d3af0f9e71123a929c20754882b636ca70",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2984:     }else if( pRec->flags & (MEM_Int|MEM_IntReal) ){",
          "2986:       i64 i = pRec->u.i;",
          "2988:       testcase( pRec->flags & MEM_Int );",
          "2989:       testcase( pRec->flags & MEM_IntReal );",
          "2990:       if( i<0 ){",
          "2992:       }else{",
          "2994:       }",
          "2995:       nHdr++;",
          "3002:         if( (i&1)==i && file_format>=4 ){",
          "3004:         }else{",
          "3005:           nData++;",
          "3006:           pRec->uTemp = 1;",
          "3007:         }",
          "3009:         nData += 2;",
          "3010:         pRec->uTemp = 2;",
          "3012:         nData += 3;",
          "3013:         pRec->uTemp = 3;",
          "3015:         nData += 4;",
          "3016:         pRec->uTemp = 4;",
          "3018:         nData += 6;",
          "3019:         pRec->uTemp = 5;",
          "3020:       }else{",
          "",
          "[Removed Lines]",
          "2987:       u64 u;",
          "2991:         u = ~i;",
          "2993:         u = i;",
          "2996:       testcase( u==127 );               testcase( u==128 );",
          "2997:       testcase( u==32767 );             testcase( u==32768 );",
          "2998:       testcase( u==8388607 );           testcase( u==8388608 );",
          "2999:       testcase( u==2147483647 );        testcase( u==2147483648 );",
          "3000:       testcase( u==140737488355327LL ); testcase( u==140737488355328LL );",
          "3001:       if( u<=127 ){",
          "3003:           pRec->uTemp = 8+(u32)u;",
          "3008:       }else if( u<=32767 ){",
          "3011:       }else if( u<=8388607 ){",
          "3014:       }else if( u<=2147483647 ){",
          "3017:       }else if( u<=140737488355327LL ){",
          "",
          "[Added Lines]",
          "2987:       u64 uu;",
          "2991:         uu = ~i;",
          "2993:         uu = i;",
          "2996:       testcase( uu==127 );               testcase( uu==128 );",
          "2997:       testcase( uu==32767 );             testcase( uu==32768 );",
          "2998:       testcase( uu==8388607 );           testcase( uu==8388608 );",
          "2999:       testcase( uu==2147483647 );        testcase( uu==2147483648 );",
          "3000:       testcase( uu==140737488355327LL ); testcase( uu==140737488355328LL );",
          "3001:       if( uu<=127 ){",
          "3003:           pRec->uTemp = 8+(u32)uu;",
          "3008:       }else if( uu<=32767 ){",
          "3011:       }else if( uu<=8388607 ){",
          "3014:       }else if( uu<=2147483647 ){",
          "3017:       }else if( uu<=140737488355327LL ){",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-31257",
  "cve_desc": "The HintFile function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.",
  "repo": "gpac/gpac",
  "patch_hash": "87afe070cd6866df7fe80f11b26ef75161de85e0",
  "patch_info": {
    "commit_hash": "87afe070cd6866df7fe80f11b26ef75161de85e0",
    "repo": "gpac/gpac",
    "commit_url": "https://github.com/gpac/gpac/commit/87afe070cd6866df7fe80f11b26ef75161de85e0",
    "files": [
      "applications/mp4box/main.c"
    ],
    "message": "fixed #1734",
    "before_after_code_files": [
      "applications/mp4box/main.c||applications/mp4box/main.c"
    ]
  },
  "patch_diff": {
    "applications/mp4box/main.c||applications/mp4box/main.c": [
      "File: applications/mp4box/main.c -> applications/mp4box/main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3371:   streamType = 0;",
      "3372:   esd = gf_isom_get_esd(file, i+1, 1);",
      "3374:    streamType = esd->decoderConfig->streamType;",
      "3375:    if (!prev_ocr) {",
      "3376:     prev_ocr = esd->OCRESID;",
      "",
      "[Removed Lines]",
      "3373:   if (esd) {",
      "",
      "[Added Lines]",
      "3373:   if (esd && esd->decoderConfig) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "223e36d02cbdabbfaa51eeb3ed9ba767ee9768b4",
      "candidate_info": {
        "commit_hash": "223e36d02cbdabbfaa51eeb3ed9ba767ee9768b4",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/223e36d02cbdabbfaa51eeb3ed9ba767ee9768b4",
        "files": [
          "applications/mp4box/filedump.c",
          "applications/mp4box/main.c",
          "applications/mp4box/mp4box.h",
          "include/gpac/main.h",
          "share/doc/man/gpac-filters.1",
          "share/doc/man/gpac.1",
          "share/doc/man/mp4box.1",
          "share/doc/man/mp4client.1",
          "src/filter_core/filter_session.c",
          "src/utils/os_config_init.c",
          "testsuite"
        ],
        "message": "re-arch of mp4box argument parsing",
        "before_after_code_files": [
          "applications/mp4box/filedump.c||applications/mp4box/filedump.c",
          "applications/mp4box/main.c||applications/mp4box/main.c",
          "applications/mp4box/mp4box.h||applications/mp4box/mp4box.h",
          "include/gpac/main.h||include/gpac/main.h",
          "src/filter_core/filter_session.c||src/filter_core/filter_session.c",
          "src/utils/os_config_init.c||src/utils/os_config_init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "applications/mp4box/main.c||applications/mp4box/main.c"
          ],
          "candidate": [
            "applications/mp4box/main.c||applications/mp4box/main.c"
          ]
        }
      },
      "candidate_diff": {
        "applications/mp4box/filedump.c||applications/mp4box/filedump.c": [
          "File: applications/mp4box/filedump.c -> applications/mp4box/filedump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: void scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist);",
          "66: {",
          "67:  u32 i=0, count = gf_lang_get_count();",
          "68:  fprintf(stderr, \"Supported ISO 639 languages and codes:\\n\\n\");",
          "",
          "[Removed Lines]",
          "65: void PrintLanguages()",
          "",
          "[Added Lines]",
          "65: u32 PrintLanguages(char *val, u32 opt)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:    fprintf(stderr, \"%s (%s - %s)\\n\", gf_lang_get_name(i), gf_lang_get_3cc(i), gf_lang_get_2cc(i));",
          "72:   }",
          "73:  }",
          "74: }",
          "76: static const char *GetLanguage(char *lcode)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74:  return 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "645: #endif",
          "649: {",
          "650: #ifdef GPAC_DISABLE_VRML",
          "651:  fprintf(stderr, \"VRML/MPEG-4/X3D scene graph is disabled in this build of GPAC\\n\");",
          "653: #else",
          "654:  const char *std_name;",
          "655:  GF_Node *node;",
          "",
          "[Removed Lines]",
          "648: void PrintNode(const char *name, u32 graph_type)",
          "652:  return;",
          "",
          "[Added Lines]",
          "649: u32 PrintNode(const char *name, u32 graph_type)",
          "653:  return 2;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "671:   std_name = \"X3D\";",
          "672: #else",
          "673:   fprintf(stderr, \"X3D node printing is not supported (X3D support disabled)\\n\");",
          "675: #endif",
          "676:  } else {",
          "677:   tag = gf_node_mpeg4_type_by_class_name(name);",
          "",
          "[Removed Lines]",
          "674:   return;",
          "",
          "[Added Lines]",
          "675:   return 2;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "679:  }",
          "680:  if (!tag) {",
          "681:   fprintf(stderr, \"Unknown %s node %s\\n\", std_name, name);",
          "683:  }",
          "685:  sg = gf_sg_new();",
          "",
          "[Removed Lines]",
          "682:   return;",
          "",
          "[Added Lines]",
          "683:   return 2;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "688:  name = gf_node_get_class_name(node);",
          "689:  if (!node) {",
          "690:   fprintf(stderr, \"Node %s not supported in current built\\n\", name);",
          "692:  }",
          "693:  do_print_node(node, sg, name, graph_type, is_nodefield, GF_FALSE);",
          "695:  gf_node_unregister(node, NULL);",
          "696:  gf_sg_del(sg);",
          "698: }",
          "701: {",
          "702: #if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D) && !defined(GPAC_DISABLE_SVG)",
          "703:  GF_SceneGraph *sg;",
          "704:  u32 i, nb_in, nb_not_in, start_tag, end_tag;",
          "706:  if (graph_type==1) {",
          "707: #if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D)",
          "",
          "[Removed Lines]",
          "691:   return;",
          "700: void PrintBuiltInNodes(u32 graph_type, Bool dump_nodes)",
          "",
          "[Added Lines]",
          "692:   return 2;",
          "699:  return 1;",
          "702: u32 PrintBuiltInNodes(char *arg_val, u32 dump_type)",
          "707:  u32 graph_type;",
          "708:  Bool dump_nodes = ((dump_type==1) || (dump_type==3)) ? 1 : 0;",
          "710:  if (dump_type==4) graph_type = 2;",
          "711:  else if ((dump_type==2) || (dump_type==3)) graph_type = 1;",
          "712:  else graph_type = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "709:   end_tag = TAG_LastImplementedX3D;",
          "710: #else",
          "711:   fprintf(stderr, \"X3D scene graph disabled in this build of GPAC\\n\");",
          "713: #endif",
          "714:  } else if (graph_type==2) {",
          "715: #ifdef GPAC_DISABLE_SVG",
          "716:   fprintf(stderr, \"SVG scene graph disabled in this build of GPAC\\n\");",
          "718: #else",
          "719:   start_tag = GF_NODE_RANGE_FIRST_SVG;",
          "720:   end_tag = GF_NODE_RANGE_LAST_SVG;",
          "",
          "[Removed Lines]",
          "712:   return;",
          "717:   return;",
          "",
          "[Added Lines]",
          "720:   return 2;",
          "725:   return 2;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "722:  } else {",
          "723: #ifdef GPAC_DISABLE_VRML",
          "724:   fprintf(stderr, \"VRML/MPEG-4 scene graph disabled in this build of GPAC\\n\");",
          "726: #else",
          "727:   start_tag = GF_NODE_RANGE_FIRST_MPEG4;",
          "728:   end_tag = TAG_LastImplementedMPEG4;",
          "",
          "[Removed Lines]",
          "725:   return;",
          "",
          "[Added Lines]",
          "733:   return 2;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "775: #else",
          "776:  fprintf(stderr, \"\\nNo scene graph enabled in this MP4Box build\\n\");",
          "777: #endif",
          "778: }",
          "782: {",
          "783:  u32 i, count=gf_isom_get_num_supported_boxes();",
          "784:  fprintf(stdout, \"<Boxes>\\n\");",
          "786:  for (i=1; i<count; i++) {",
          "",
          "[Removed Lines]",
          "781: void PrintBuiltInBoxes(Bool do_cov)",
          "",
          "[Added Lines]",
          "786:  return 1;",
          "790: u32 PrintBuiltInBoxes(char *argval, u32 do_cov)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "797:         }",
          "798:  }",
          "799:  fprintf(stdout, \"</Boxes>\\n\");",
          "800: }",
          "802: #if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_ISOM_DUMP)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "810:  return 1;",
          "",
          "---------------"
        ],
        "applications/mp4box/main.c||applications/mp4box/main.c": [
          "File: applications/mp4box/main.c -> applications/mp4box/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #define BUFFSIZE 8192",
          "58: #define DEFAULT_INTERLEAVING_IN_SEC 0.5",
          "61: int mp4boxTerminal(int argc, char **argv);",
          "75: {",
          "76:  fprintf(stderr, \"MP4Box - GPAC version %s\\n\"",
          "77:          \"%s\\n\"",
          "78:          \"GPAC Configuration: \" GPAC_CONFIGURATION \"\\n\"",
          "79:          \"Features: %s %s\\n\", gf_gpac_version(), gf_gpac_copyright_cite(), gf_sys_features(GF_FALSE), gf_sys_features(GF_TRUE));",
          "80: }",
          "83: {",
          "84: #ifdef GPAC_MEMORY_TRACKING",
          "87: #endif",
          "112:   \"  - ZoomPlayer: `AddChapter(nb_frames,chapter name)`, `AddChapterBySeconds(nb_sec,chapter name)` and `AddChapterByTime(h,m,s,chapter name)` with 1 chapter per line\\n\"",
          "113:   \"  - Time codes: `h:m:s chapter_name`, `h:m:s:ms chapter_name` and `h:m:s.ms chapter_name` with 1 chapter per line\\n\"",
          "114:   \"  - SMPTE codes: `h:m:s;nb_f/fps chapter_name` and `h:m:s;nb_f chapter_name` with `nb_f` the number of frames and `fps` the framerate with 1 chapter per line\\n\"",
          "128:      \"  - N:D: set PAR to N:D in track, do not modify the bitstream\\n\"",
          "129:      \"  - wN:D: set PAR to N:D in track and try to modify the bitstream\\n\"",
          "130:      \"  - none: remove PAR info from track, do not modify the bitstream\\n\"",
          "131:      \"  - auto: retrieve PAR info from bitstream and set it in track\\n\"",
          "134:     \"- n, d: numerator, denominator\\n\"",
          "135:          \"- W, H, HO, VO: clap width, clap height, clap horizontal offset, clap vertical offset\\n\"",
          "142:          \"- refTrack=ID: ID of the track used as a group reference. If not set, the track will belong to the same group as the \"",
          "143:          \"previous trackID specified. If 0 or no previous track specified, a new alternate group will be created\\n\"",
          "144:          \"- switchID=ID: ID of the switch group to create. If 0, a new ID will be computed for you. If <0, disables SwitchGroup\\n\"",
          "",
          "[Removed Lines]",
          "63: Bool dvbhdemux = GF_FALSE;",
          "64: Bool keep_sys_tracks = GF_FALSE;",
          "68: u32 swf_flags = 0;",
          "69: Float swf_flatten_angle = 0;",
          "70: s32 laser_resolution = 0;",
          "71: static FILE *helpout = NULL;",
          "72: static u32 help_flags = 0;",
          "74: void PrintVersion()",
          "82: GF_GPACArg m4b_gen_args[] =",
          "85:   GF_DEF_ARG(\"mem-track\", NULL, \"enable memory tracker\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "86:   GF_DEF_ARG(\"mem-track-stack\", NULL, \"enable memory tracker with stack dumping\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "88:   GF_DEF_ARG(\"p\", NULL, \"use indicated profile for the global GPAC config. If not found, config file is created. If a file path is indicated, this will load profile from that file. Otherwise, this will create a directory of the specified name and store new config there. Reserved name `0` means a new profile, not stored to disk. Works using -p=NAME or -p NAME\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "89:   GF_DEF_ARG(\"inter\", NULL, \"interleave file, producing track chunks with given duration in ms. A value of 0 disables interleaving \", \"0.5\", NULL, GF_ARG_DOUBLE, 0),",
          "90:   GF_DEF_ARG(\"old-inter\", NULL, \"same as [-inter]() but wihout drift correction\", NULL, NULL, GF_ARG_DOUBLE, GF_ARG_HINT_EXPERT),",
          "91:   GF_DEF_ARG(\"tight\", NULL, \"tight interleaving (sample based) of the file. This reduces disk seek operations but increases file size\", NULL, NULL, GF_ARG_DOUBLE, GF_ARG_HINT_EXPERT),",
          "92:   GF_DEF_ARG(\"flat\", NULL, \"store file with all media data first, non-interleaved. This speeds up writing time when creating new files\", NULL, NULL, GF_ARG_BOOL, 0),",
          "93:   GF_DEF_ARG(\"frag\", NULL, \"fragment file, producing track fragments of given duration in ms. This disables interleaving\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "94:   GF_DEF_ARG(\"out\", NULL, \"specify output file name. By default input file is overwritten\", NULL, NULL, GF_ARG_STRING, 0),",
          "95:   GF_DEF_ARG(\"tmp\", NULL, \"specify directory for temporary file creation\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "96:   GF_DEF_ARG(\"co64\", NULL, \"force usage of 64-bit chunk offsets for ISOBMF files\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "97:   GF_DEF_ARG(\"new\", NULL, \"force creation of a new destination file\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "98:   GF_DEF_ARG(\"newfs\", NULL, \"force creation of a new destination file without temp file but interleaving support\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "99:   GF_DEF_ARG(\"no-sys\", NULL, \"remove all MPEG-4 Systems info except IOD, kept for profiles. This is the default when creating regular AV content\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "100:   GF_DEF_ARG(\"no-iod\", NULL, \"remove MPEG-4 InitialObjectDescriptor from file\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "101:   GF_DEF_ARG(\"mfra\", NULL, \"insert movie fragment random offset when fragmenting file (ignored in dash mode)\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "102:   GF_DEF_ARG(\"isma\", NULL, \"rewrite the file as an ISMA 1.0 file\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "103:   GF_DEF_ARG(\"ismax\", NULL, \"same as [-isma]() and remove all clock references\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "104:   GF_DEF_ARG(\"3gp\", NULL, \"rewrite as 3GPP(2) file (no more MPEG-4 Systems Info), always enabled if destination file extension is `.3gp`, `.3g2` or `.3gpp`. Some tracks may be removed in the process\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "105:   GF_DEF_ARG(\"ipod\", NULL, \"rewrite the file for iPod/old iTunes\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "106:   GF_DEF_ARG(\"psp\", NULL, \"rewrite the file for PSP devices\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "107:   GF_DEF_ARG(\"brand\", NULL, \"set major brand of file (`ABCD`) or brand with optional version (`ABCD:v`)\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "108:   GF_DEF_ARG(\"ab\", NULL, \"add given brand to file's alternate brand list\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "109:   GF_DEF_ARG(\"rb\", NULL, \"remove given brand to file's alternate brand list\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "110:   GF_DEF_ARG(\"cprt\", NULL, \"add copyright string to file\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "111:   GF_DEF_ARG(\"chap\", NULL, \"set chapter information from given file. The following formats are supported (but cannot be mixed) in the chapter text file:\\n\"",
          "115:   \"  - Common syntax: `CHAPTERX=h:m:s[:ms or .ms]` on first line and `CHAPTERXNAME=name` on next line (reverse order accepted)\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "116:   GF_DEF_ARG(\"chapqt\", NULL, \"set chapter information from given file, using QT signaling for text tracks\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "117:   GF_DEF_ARG(\"set-track-id `id1:id2`\", NULL, \"change id of track with id1 to id2\", NULL, NULL, GF_ARG_STRING, 0),",
          "118:   GF_DEF_ARG(\"swap-track-id `id1:id2`\", NULL, \"swap the id between tracks with id1 to id2\", NULL, NULL, GF_ARG_STRING, 0),",
          "119:   GF_DEF_ARG(\"rem\", NULL, \"remove given track from file\", NULL, NULL, GF_ARG_INT, 0),",
          "120:   GF_DEF_ARG(\"rap\", NULL, \"remove all non-RAP samples from given track\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_ADVANCED),",
          "121:   GF_DEF_ARG(\"refonly\", NULL, \"remove all non-reference pictures from given track\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_ADVANCED),",
          "122:   GF_DEF_ARG(\"enable\", NULL, \"enable given track\", NULL, NULL, GF_ARG_INT, 0),",
          "123:   GF_DEF_ARG(\"disable\", NULL, \"disable given track\", NULL, NULL, GF_ARG_INT, 0),",
          "124:   GF_DEF_ARG(\"timescale\", NULL, \"set movie timescale to given value (ticks per second)\", \"600\", NULL, GF_ARG_INT, 0),",
          "125:   GF_DEF_ARG(\"lang `[tkID=]LAN`\", NULL, \"set language. LAN is the BCP-47 code (eng, en-UK, ...). If no track ID is given, sets language to all tracks\", NULL, NULL, GF_ARG_STRING, 0),",
          "126:   GF_DEF_ARG(\"delay `tkID=TIME`\", NULL, \"set track start delay in ms or in fractional seconds (`N/D`)\", NULL, NULL, GF_ARG_STRING, 0),",
          "127:   GF_DEF_ARG(\"par `tkID=PAR`\", NULL, \"set visual track pixel aspect ratio. PAR is:\\n\"",
          "132:      \"  - force: force 1:1 PAR in track, do not modify the bitstream\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "133:   GF_DEF_ARG(\"clap `tkID=CLAP`\", NULL, \"set visual track clean aperture. CLAP is `Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd` or `none`\\n\"",
          "136:     , NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "137:   GF_DEF_ARG(\"mx `tkID=MX`\", NULL, \"set track matrix, with MX is M1:M2:M3:M4:M5:M6:M7:M8:M9 in 16.16 fixed point intergers or hexa\"",
          "138:     , NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "139:   GF_DEF_ARG(\"name `tkID=NAME`\", NULL, \"set track handler name to NAME (UTF-8 string)\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "140:   GF_DEF_ARG(\"itags `tag1[:tag2]`\", NULL, \"set iTunes tags to file, see [-tag-list]()\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "141:   GF_DEF_ARG(\"group-add\", NULL, \"create a new grouping information in the file. Format is a colon-separated list of following options:\\n\"",
          "",
          "[Added Lines]",
          "66: static u32 mp4box_cleanup(u32 ret_code);",
          "74: typedef struct",
          "75: {",
          "76:  GF_ISOTrackID trackID;",
          "77:  char *line;",
          "78: } SDPLine;",
          "80: typedef enum {",
          "81:  META_ACTION_SET_TYPE   = 0,",
          "82:  META_ACTION_ADD_ITEM   = 1,",
          "83:  META_ACTION_REM_ITEM   = 2,",
          "84:  META_ACTION_SET_PRIMARY_ITEM = 3,",
          "85:  META_ACTION_SET_XML    = 4,",
          "86:  META_ACTION_SET_BINARY_XML  = 5,",
          "87:  META_ACTION_REM_XML    = 6,",
          "88:  META_ACTION_DUMP_ITEM   = 7,",
          "89:  META_ACTION_DUMP_XML   = 8,",
          "90:  META_ACTION_ADD_IMAGE_ITEM  = 9,",
          "91:  META_ACTION_ADD_IMAGE_GRID  = 10,",
          "92: } MetaActionType;",
          "94: typedef struct {",
          "95:  u32 ref_item_id;",
          "96:  u32 ref_type;",
          "97: } MetaRef;",
          "99: typedef struct",
          "100: {",
          "101:  MetaActionType act_type;",
          "102:  Bool root_meta, use_dref;",
          "103:  GF_ISOTrackID trackID;",
          "104:  u32 meta_4cc;",
          "105:  char *szPath, *szName, *mime_type, *enc_type;",
          "106:  u32 item_id;",
          "107:  Bool primary;",
          "108:  u32 item_type;",
          "109:  u32 ref_item_id;",
          "110:  GF_List *item_refs;",
          "111:  u32 group_id;",
          "112:  u32 group_type;",
          "113:  GF_ImageItemProperties *image_props;",
          "114: } MetaAction;",
          "117: typedef enum {",
          "118:  TRAC_ACTION_REM_TRACK= 0,",
          "119:  TRAC_ACTION_SET_LANGUAGE,",
          "120:  TRAC_ACTION_SET_DELAY,",
          "121:  TRAC_ACTION_SET_KMS_URI,",
          "122:  TRAC_ACTION_SET_PAR,",
          "123:  TRAC_ACTION_SET_HANDLER_NAME,",
          "124:  TRAC_ACTION_ENABLE,",
          "125:  TRAC_ACTION_DISABLE,",
          "126:  TRAC_ACTION_REFERENCE,",
          "127:  TRAC_ACTION_RAW_EXTRACT,",
          "128:  TRAC_ACTION_REM_NON_RAP,",
          "129:  TRAC_ACTION_SET_KIND,",
          "130:  TRAC_ACTION_REM_KIND,",
          "131:  TRAC_ACTION_SET_ID,",
          "132:  TRAC_ACTION_SET_UDTA,",
          "133:  TRAC_ACTION_SWAP_ID,",
          "134:  TRAC_ACTION_REM_NON_REFS,",
          "135:  TRAC_ACTION_SET_CLAP,",
          "136:  TRAC_ACTION_SET_MX,",
          "137:  TRAC_ACTION_SET_EDITS,",
          "138:  TRAC_ACTION_SET_TIME,",
          "139: } TrackActionType;",
          "141: typedef struct",
          "142: {",
          "143:  TrackActionType act_type;",
          "144:  GF_ISOTrackID trackID;",
          "145:  char lang[10];",
          "146:  GF_Fraction delay;",
          "147:  const char *kms;",
          "148:  const char *hdl_name;",
          "149:  s32 par_num, par_den;",
          "150:  u8 force_par, rewrite_bs;",
          "151:  u32 dump_type, sample_num;",
          "152:  char *out_name;",
          "153:  char *src_name;",
          "154:  char *string;",
          "155:  u32 udta_type;",
          "156:  char *kind_scheme, *kind_value;",
          "157:  u32 newTrackID;",
          "158:  s32 clap_wnum, clap_wden, clap_hnum, clap_hden, clap_honum, clap_hoden, clap_vonum, clap_voden;",
          "159:  s32 mx[9];",
          "160:  u64 time;",
          "161: } TrackAction;",
          "163: enum",
          "164: {",
          "165:  GF_ISOM_CONV_TYPE_ISMA = 1,",
          "166:  GF_ISOM_CONV_TYPE_ISMA_EX,",
          "167:  GF_ISOM_CONV_TYPE_3GPP,",
          "168:  GF_ISOM_CONV_TYPE_IPOD,",
          "169:  GF_ISOM_CONV_TYPE_PSP,",
          "170:  GF_ISOM_CONV_TYPE_MOV",
          "171: };",
          "173: typedef enum {",
          "174:  TSEL_ACTION_SET_PARAM = 0,",
          "175:  TSEL_ACTION_REMOVE_TSEL = 1,",
          "176:  TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP = 2,",
          "177: } TSELActionType;",
          "179: typedef struct",
          "180: {",
          "181:  TSELActionType act_type;",
          "182:  GF_ISOTrackID trackID;",
          "184:  GF_ISOTrackID refTrackID;",
          "185:  u32 criteria[30];",
          "186:  u32 nb_criteria;",
          "187:  Bool is_switchGroup;",
          "188:  u32 switchGroupID;",
          "189: } TSELAction;",
          "191: GF_FileType get_file_type_by_ext(char *inName);",
          "194: char outfile[GF_MAX_PATH];",
          "195: GF_SMEncodeOptions smenc_opts;",
          "196: GF_Fraction import_fps;",
          "199: MetaAction *metas = NULL;",
          "200: TrackAction *tracks = NULL;",
          "201: TSELAction *tsel_acts = NULL;",
          "202: SDPLine *sdp_lines = NULL;",
          "203: u32 *brand_add = NULL;",
          "204: u32 *brand_rem = NULL;",
          "205: char **mpd_base_urls = NULL;",
          "206: u32 nb_mpd_base_urls = 0;",
          "207: GF_DashSegmenterInput *dash_inputs = NULL;",
          "208: u32 nb_dash_inputs = 0;",
          "214: u32 swf_flags = GF_SM_SWF_SPLIT_TIMELINE;",
          "216: FILE *helpout = NULL;",
          "217: u32 help_flags = 0;",
          "219: Double interleaving_time=0.0, split_duration=0.0, split_start=-1.0, dash_duration=0.0, dash_subduration=0.0, swf_flatten_angle=0.0;",
          "220: Bool dash_duration_strict=0, dvbhdemux=0, keep_sys_tracks=0;",
          "222: u64 initial_tfdt=0;",
          "223: s32 subsegs_per_sidx=0, laser_resolution=0, ast_offset_ms=0;",
          "224: const char *split_range_str = NULL;",
          "225: GF_DashSwitchingMode bitstream_switching_mode = GF_DASH_BSMODE_DEFAULT;",
          "226: u32 stat_level=0, hint_flags=0, info_track_id=0, import_flags=0, nb_add=0, nb_cat=0, crypt=0, agg_samples=0, nb_sdp_ex=0, max_ptime=0, split_size=0, nb_meta_act=0, nb_track_act=0, rtp_rate=0, major_brand=0, nb_alt_brand_add=0, nb_alt_brand_rem=0, old_interleave=0, minor_version=0, conv_type=0, nb_tsel_acts=0, program_number=0, dump_nal=0, time_shift_depth=0, initial_moof_sn=0, dump_std=0, import_subtitle=0, dump_saps=0, dump_saps_mode=0, force_new=0;",
          "227: GF_DashDynamicMode dash_mode=GF_DASH_STATIC;",
          "228: #ifndef GPAC_DISABLE_SCENE_DUMP",
          "229: GF_SceneDumpFormat dump_mode=GF_SM_DUMP_NONE;",
          "230: #endif",
          "233: Bool align_cat=GF_TRUE;",
          "235: Double mpd_live_duration=0;",
          "236: Bool do_hint=0, do_save=0, full_interleave=0, do_frag=0, hint_interleave=0, dump_rtp=0, regular_iod=0, remove_sys_tracks=0, remove_hint=0, remove_root_od=0;",
          "237: Bool print_sdp=0, open_edit=0, dump_cr=0, force_ocr=0, encode=0, do_scene_log=0, dump_srt=0, dump_ttxt=0, do_saf=0, dump_m2ts=0, dump_cart=0;",
          "238: Bool do_hash=0, verbose=0, force_cat=0, pack_wgt=0, single_group=0, clean_groups=0, dash_live=0, no_fragments_defaults=0;",
          "239: Bool single_traf_per_moof=0, tfdt_per_traf=0, hls_clock=0, do_mpd_rip=0, merge_vtt_cues=0, compress_moov=0, get_nb_tracks=0;",
          "241: char *inName=NULL, *outName=NULL, *mediaSource=NULL, *tmpdir=NULL, *input_ctx=NULL, *output_ctx=NULL, *drm_file=NULL, *avi2raw=NULL, *cprt=NULL;",
          "242: char *chap_file=NULL, *chap_file_qt=NULL, *itunes_tags=NULL, *pack_file=NULL, *raw_cat=NULL, *seg_name=NULL, *dash_ctx_file=NULL;",
          "243: char *compress_top_boxes=NULL, *high_dynamc_range_filename=NULL, *use_init_seg=NULL, *box_patch_filename=NULL, *udp_dest = NULL;",
          "245: GF_ISOTrackID trackID=0;",
          "246: u32 track_dump_type=0, dump_isom=0, dump_timestamps=0, dump_nal_type=0, do_flat=0, box_patch_trackID=0, print_info=0;",
          "247: Bool no_inplace=0, merge_last_seg=0, freeze_box_order=0, no_odf_conf=0;",
          "248: Double min_buffer = 1.5;",
          "249: u32 size_top_box=0, fs_dump_flags=0, dump_chap=0, dump_udta_type=0, dump_udta_track=0, moov_pading=0, sdtp_in_traf=0, segment_marker=0, timescale=0;",
          "251: u32 dash_scale = 1000;",
          "252: GF_ISOFile *file = NULL;",
          "254: Bool insert_utc=0, chunk_mode=0, HintCopy=0, hint_no_offset=0, do_bin_xml=0, frag_real_time=0, force_co64=0, live_scene=0, use_mfra=0;",
          "255: Bool dump_iod=0, samplegroups_in_traf=0, mvex_after_traks=0, daisy_chain_sidx=0, use_ssix=0, single_segment=0, single_file=0, segment_timeline=0;",
          "256: char *do_mpd_conv=NULL;",
          "257: u32 MTUSize = 1450;",
          "258: const char *dash_start_date=NULL;",
          "259: GF_DASH_ContentLocationMode cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;",
          "260: Double mpd_update_time = 0.0;",
          "261: GF_MemTrackerType mem_track = GF_MemTrackerNone;",
          "262: GF_DASHPSSHMode pssh_mode=0;",
          "264: GF_DashProfile dash_profile=GF_DASH_PROFILE_AUTO;",
          "265: const char *dash_profile_extension = NULL;",
          "266: const char *dash_cues = NULL;",
          "267: Bool strict_cues=0, use_url_template=0, seg_at_rap=0, frag_at_rap=0, adjust_split_end=0, memory_frags=0, keep_utc=0, has_next_arg=0, no_cache=0, no_loop=0;",
          "268: const char *do_wget = NULL;",
          "270: char *seg_ext = NULL;",
          "271: char *init_seg_ext = NULL;",
          "272: const char *dash_title = NULL;",
          "273: const char *dash_source = NULL;",
          "274: const char *dash_more_info = NULL;",
          "276: FILE *logfile = NULL;",
          "277: u32 run_for=0, dash_cumulated_time=0, dash_prev_time=0, dash_now_time=0;",
          "278: GF_DASH_SplitMode dash_split_mode = GF_DASH_SPLIT_OUT;",
          "281: typedef u32 (*parse_arg_fun)(char *arg_val, u32 param);",
          "282: typedef u32 (*parse_arg_fun2)(char *arg_name, char *arg_val, u32 param);",
          "285: static u32 parse_meta_args(char *opts, MetaActionType act_type);",
          "286: static Bool parse_tsel_args(char *opts, TSELActionType act);",
          "295: Bool print_version(char *arg_val, u32 param)",
          "301:  return GF_TRUE;",
          "305: #define ARG_OPEN_EDIT  1",
          "307: #define ARG_NEED_SAVE  1<<1",
          "308: #define ARG_NO_INPLACE  1<<2",
          "309: #define ARG_BIT_MASK  1<<3",
          "310: #define ARG_BIT_MASK_REM 1<<4",
          "311: #define ARG_HAS_VALUE  1<<5",
          "312: #define ARG_DIV_1000  1<<6",
          "313: #define ARG_NON_ZERO  1<<7",
          "314: #define ARG_64BITS   1<<8",
          "315: #define ARG_IS_4CC   1<<9",
          "316: #define ARG_BOOL_REV  1<<10",
          "317: #define ARG_INT_INC   1<<11",
          "318: #define ARG_IS_FUN   1<<12",
          "319: #define ARG_EMPTY   1<<13",
          "320: #define ARG_PUSH_SYSARGS 1<<14",
          "321: #define ARG_IS_FUN2   1<<15",
          "325: typedef struct",
          "326: {",
          "327:  GF_GPAC_ARG_BASE",
          "329:  void *arg_ptr;",
          "330:  u32 argv_val;",
          "331:  u16 parse_flags;",
          "332: } MP4BoxArg;",
          "334: #define MP4BOX_ARG(_a, _c, _f, _g, _h, _i, _j) {_a, NULL, _c, NULL, NULL, _f, _g, _h, _i, _j}",
          "335: #define MP4BOX_ARG_ALT(_a, _b, _c, _f, _g, _h, _i, _j) {_a, _b, _c, NULL, NULL, _f, _g, _h, _i, _j}",
          "336: #define MP4BOX_ARG_S(_a, _s, _c, _g, _h, _i, _j) {_a, NULL, _c, _s, NULL, GF_ARG_CUSTOM, _g, _h, _i, _j}",
          "339: MP4BoxArg m4b_gen_args[] =",
          "342:   MP4BOX_ARG(\"mem-track\", \"enable memory tracker\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, NULL, 0, 0),",
          "343:   MP4BOX_ARG(\"mem-track-stack\", \"enable memory tracker with stack dumping\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, NULL, 0, 0),",
          "345:   MP4BOX_ARG(\"p\", \"use indicated profile for the global GPAC config. If not found, config file is created. If a file path is indicated, this will load profile from that file. Otherwise, this will create a directory of the specified name and store new config there. Reserved name `0` means a new profile, not stored to disk. Works using -p=NAME or -p NAME\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, NULL, 0, 0),",
          "346:   {\"inter\", NULL, \"interleave file, producing track chunks with given duration in ms. A value of 0 disables interleaving \", \"0.5\", NULL, GF_ARG_DOUBLE, 0, parse_store_mode, 0, ARG_IS_FUN},",
          "347:   MP4BOX_ARG(\"old-inter\", \"same as [-inter]() but wihout drift correction\", GF_ARG_DOUBLE, GF_ARG_HINT_EXPERT, parse_store_mode, 1, ARG_IS_FUN),",
          "348:   MP4BOX_ARG(\"tight\", \"tight interleaving (sample based) of the file. This reduces disk seek operations but increases file size\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &full_interleave, 0, ARG_OPEN_EDIT|ARG_NEED_SAVE),",
          "349:   MP4BOX_ARG(\"flat\", \"store file with all media data first, non-interleaved. This speeds up writing time when creating new files\", GF_ARG_BOOL, 0, &do_flat, 0, ARG_OPEN_EDIT| ARG_NO_INPLACE),",
          "350:   MP4BOX_ARG(\"frag\", \"fragment file, producing track fragments of given duration in ms. This disables interleaving\", GF_ARG_DOUBLE, 0, parse_store_mode, 2, ARG_IS_FUN),",
          "351:   MP4BOX_ARG(\"out\", \"specify output file name. By default input file is overwritten\", GF_ARG_STRING, 0, &outName, 0, 0),",
          "352:  MP4BOX_ARG(\"tmp\", \"specify directory for temporary file creation\", GF_ARG_STRING, 0, &tmpdir, 0, 0),",
          "353:   MP4BOX_ARG(\"co64\",\"force usage of 64-bit chunk offsets for ISOBMF files\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &force_co64, 0, ARG_OPEN_EDIT),",
          "354:   MP4BOX_ARG(\"new\", \"force creation of a new destination file\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &force_new, 0, 0),",
          "355:   MP4BOX_ARG(\"newfs\", \"force creation of a new destination file without temp file but interleaving support\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, parse_store_mode, 3, ARG_IS_FUN),",
          "356:   MP4BOX_ARG_ALT(\"no-sys\", \"nosys\", \"remove all MPEG-4 Systems info except IOD, kept for profiles. This is the default when creating regular AV content\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &remove_sys_tracks, 0, ARG_OPEN_EDIT),",
          "357:   MP4BOX_ARG(\"no-iod\", \"remove MPEG-4 InitialObjectDescriptor from file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &remove_root_od, 0, ARG_OPEN_EDIT),",
          "358:   MP4BOX_ARG(\"mfra\", \"insert movie fragment random offset when fragmenting file (ignored in dash mode)\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &use_mfra, 0, 0),",
          "359:   MP4BOX_ARG(\"isma\", \"rewrite the file as an ISMA 1.0 file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_ISMA, ARG_OPEN_EDIT),",
          "360:   MP4BOX_ARG(\"ismax\", \"same as [-isma]() and remove all clock references\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_ISMA_EX, ARG_OPEN_EDIT),",
          "361:   MP4BOX_ARG(\"3gp\", \"rewrite as 3GPP(2) file (no more MPEG-4 Systems Info), always enabled if destination file extension is `.3gp`, `.3g2` or `.3gpp`. Some tracks may be removed in the process\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_3GPP, ARG_OPEN_EDIT),",
          "362:   MP4BOX_ARG(\"ipod\", \"rewrite the file for iPod/old iTunes\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_IPOD, ARG_OPEN_EDIT),",
          "363:   MP4BOX_ARG(\"psp\", \"rewrite the file for PSP devices\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_PSP, ARG_OPEN_EDIT),",
          "364:   MP4BOX_ARG(\"brand\", \"set major brand of file (`ABCD`) or brand with optional version (`ABCD:v`)\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 0, ARG_IS_FUN),",
          "365:   MP4BOX_ARG(\"ab\", \"add given brand to file's alternate brand list\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 1, ARG_IS_FUN),",
          "366:   MP4BOX_ARG(\"rb\", \"remove given brand to file's alternate brand list\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 2, ARG_IS_FUN),",
          "367:   MP4BOX_ARG(\"cprt\", \"add copyright string to file\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &cprt, 0, 0),",
          "368:   MP4BOX_ARG(\"chap\", \"set chapter information from given file. The following formats are supported (but cannot be mixed) in the chapter text file:\\n\"",
          "372:   \"  - Common syntax: `CHAPTERX=h:m:s[:ms or .ms]` on first line and `CHAPTERXNAME=name` on next line (reverse order accepted)\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file, 0, ARG_OPEN_EDIT),",
          "373:   MP4BOX_ARG(\"chapqt\", \"set chapter information from given file, using QT signaling for text tracks\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file_qt, 0, ARG_OPEN_EDIT),",
          "374:   MP4BOX_ARG_S(\"set-track-id\", \"id1:id2\", \"change id of track with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SET_ID, ARG_IS_FUN),",
          "375:   MP4BOX_ARG_S(\"swap-track-id\", \"id1:id2\", \"swap the id between tracks with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SWAP_ID, ARG_IS_FUN),",
          "376:   MP4BOX_ARG(\"rem\", \"remove given track from file\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_REM_TRACK, ARG_IS_FUN),",
          "377:   MP4BOX_ARG(\"rap\", \"remove all non-RAP samples from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),",
          "378:   MP4BOX_ARG(\"refonly\", \"remove all non-reference pictures from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 1, ARG_IS_FUN | ARG_EMPTY),",
          "379:   MP4BOX_ARG(\"enable\", \"enable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_ENABLE, ARG_IS_FUN),",
          "380:   MP4BOX_ARG(\"disable\", \"disable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_DISABLE, ARG_IS_FUN),",
          "381:   {\"timescale\", NULL, \"set movie timescale to given value (ticks per second)\", \"600\", NULL, GF_ARG_INT, 0, &timescale, 0, ARG_OPEN_EDIT},",
          "382:   MP4BOX_ARG_S(\"lang\", \"[tkID=]LAN\", \"set language. LAN is the BCP-47 code (eng, en-UK, ...). If no track ID is given, sets language to all tracks\", 0, parse_track_action, TRAC_ACTION_SET_LANGUAGE, ARG_IS_FUN),",
          "383:   MP4BOX_ARG_S(\"delay\", \"tkID=TIME\", \"set track start delay in ms or in fractional seconds (`N/D`)\", 0, parse_track_action, TRAC_ACTION_SET_DELAY, ARG_IS_FUN),",
          "384:   MP4BOX_ARG_S(\"par\", \"tkID=PAR\", \"set visual track pixel aspect ratio. PAR is:\\n\"",
          "389:      \"  - force: force 1:1 PAR in track, do not modify the bitstream\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_PAR, ARG_IS_FUN",
          "390:      ),",
          "391:   MP4BOX_ARG_S(\"clap\", \"tkID=CLAP\", \"set visual track clean aperture. CLAP is `Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd` or `none`\\n\"",
          "394:     , GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_CLAP, ARG_IS_FUN),",
          "395:   MP4BOX_ARG_S(\"mx\", \"tkID=MX\", \"set track matrix, with MX is M1:M2:M3:M4:M5:M6:M7:M8:M9 in 16.16 fixed point intergers or hexa\"",
          "396:     , GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_MX, ARG_IS_FUN),",
          "397:  MP4BOX_ARG_S(\"kind\", \"tkID=schemeURI=value\", \"set kind for the track or for all tracks using `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_SET_KIND, ARG_IS_FUN),",
          "398:  MP4BOX_ARG_S(\"kind-rem\", \"tkID=schemeURI=value\", \"remove kind if given schemeID for the track or for all tracks with `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_REM_KIND, ARG_IS_FUN),",
          "399:   MP4BOX_ARG_S(\"name\", \"tkID=NAME\", \"set track handler name to NAME (UTF-8 string)\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_HANDLER_NAME, ARG_IS_FUN),",
          "400:   MP4BOX_ARG(\"itags\", \"set iTunes tags to file, see `-h tags`\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &itunes_tags, 0, ARG_OPEN_EDIT),",
          "401:   MP4BOX_ARG(\"group-add\", \"create a new grouping information in the file. Format is a colon-separated list of following options:\\n\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146:          \"- trackID=ID: ID of the track to add to this group\\n\"",
          "147:          \"  \\n\"",
          "148:          \"Warning: Options modify state as they are parsed, `trackID=1:criteria=lang:trackID=2` is different from `criteria=lang:trackID=1:trackID=2`\"",
          "157:          \"- type=CODE: 4CC code of the UDTA (not needed for `box=` option)\\n\"",
          "158:          \"- box=FILE: location of the udta data, formatted as serialized boxes\\n\"",
          "159:          \"- box=base64,DATA: base64 encoded udta data, formatted as serialized boxes\\n\"",
          "160:          \"- src=FILE: location of the udta data (will be stored in a single box of type CODE)\\n\"",
          "161:          \"- src=base64,DATA: base64 encoded udta data (will be stored in a single box of type CODE)\\n\"",
          "162:          \"- str=STRING: use the given string as payload for the udta box\\n\"",
          "169:    \" - `r`: removes all edits\\n\"",
          "170:    \" - `eSTART`: add empty edit with given start time (fractional or milliseconds). START can be\\n\"",
          "171:    \"   - `VAL`: start time in milliseconds (media duration used as edit duration)\\n\"",
          "",
          "[Removed Lines]",
          "149:          \"\\n\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "151:  GF_DEF_ARG(\"group-rem-track\", NULL, \"remove given track from its group\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_ADVANCED),",
          "152:  GF_DEF_ARG(\"group-rem\", NULL, \"remove the track's group\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_ADVANCED),",
          "153:  GF_DEF_ARG(\"group-clean\", NULL, \"remove all group information from all tracks\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "154:  GF_DEF_ARG(\"ref `id:XXXX:refID`\", NULL, \"add a reference of type 4CC from track ID to track refID\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "155:  GF_DEF_ARG(\"keep-utc\", NULL, \"keep UTC timing in the file after edit\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "156:  GF_DEF_ARG(\"udta tkID:[OPTS]\", NULL, \"set udta for given track or movie if tkID is 0. OPTS is a colon separated list of:\\n\"",
          "163:          \"Note: If no source is set, UDTA of type CODE will be removed\\n\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "164:  GF_DEF_ARG(\"patch [tkID=]FILE\", NULL, \"apply box patch described in FILE, for given trackID if set\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "165:  GF_DEF_ARG(\"bo\", NULL, \"freeze the order of boxes in input file\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "166:  GF_DEF_ARG(\"init-seg\", NULL, \"use the given file as an init segment for dumping or for encryption\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_ADVANCED),",
          "167:  GF_DEF_ARG(\"zmov\", NULL, \"compress movie box according to ISOBMFF box compression\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_ADVANCED),",
          "168:   GF_DEF_ARG(\"edits tkID=EDITS\", NULL, \"set edit list. The following syntax is used (no separators between entries):\\n\"",
          "",
          "[Added Lines]",
          "409:          \"\\n\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_SET_PARAM, ARG_IS_FUN),",
          "411:  MP4BOX_ARG(\"group-rem-track\", \"remove given track from its group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_TSEL, ARG_IS_FUN),",
          "412:  MP4BOX_ARG(\"group-rem\", \"remove the track's group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP, ARG_IS_FUN),",
          "413:  MP4BOX_ARG(\"group-clean\", \"remove all group information from all tracks\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &clean_groups, 0, ARG_OPEN_EDIT),",
          "414:  MP4BOX_ARG_S(\"ref\", \"id:XXXX:refID\", \"add a reference of type 4CC from track ID to track refID\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_REFERENCE, ARG_IS_FUN),",
          "415:  MP4BOX_ARG(\"keep-utc\", \"keep UTC timing in the file after edit\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &keep_utc, 0, 0),",
          "416:  MP4BOX_ARG_S(\"udta\", \"tkID:[OPTS]\", \"set udta for given track or movie if tkID is 0. OPTS is a colon separated list of:\\n\"",
          "423:          \"Note: If no source is set, UDTA of type CODE will be removed\\n\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_UDTA, ARG_IS_FUN|ARG_OPEN_EDIT),",
          "424:  MP4BOX_ARG_S(\"patch\", \"[tkID=]FILE\", \"apply box patch described in FILE, for given trackID if set\", GF_ARG_HINT_ADVANCED, parse_boxpatch, 0, ARG_IS_FUN),",
          "425:  MP4BOX_ARG(\"bo\", \"freeze the order of boxes in input file\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &freeze_box_order, 0, 0),",
          "426:  MP4BOX_ARG(\"init-seg\", \"use the given file as an init segment for dumping or for encryption\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &use_init_seg, 0, 0),",
          "427:  MP4BOX_ARG(\"zmov\", \"compress movie box according to ISOBMFF box compression\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &compress_moov, 0, 0),",
          "428:   MP4BOX_ARG_S(\"edits\", \"tkID=EDITS\", \"set edit list. The following syntax is used (no separators between entries):\\n\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "176:    \" - Examples: \\n\"",
          "177:    \"   - `-edits=re0-5/1e5-3/1,100/25`: remove edits, add empty edit at 0s for 5s, then add regular edit at 5s for 3s starting at 4s in media track\\n\"",
          "178:    \"   - `-edits=re0-4/1,0,2/1`: remove edits, add single edit at 0s for 4s starting at 0s in media track and playing at speed 2\\n\"",
          "182:  {0}",
          "183: };",
          "",
          "[Removed Lines]",
          "179:     , NULL, NULL, GF_ARG_INT, 0),",
          "180:   GF_DEF_ARG(\"moovpad\", NULL, \"specify amount of padding to keep after moov box for later inplace editing - if 0, moov padding is disabled\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_EXPERT),",
          "181:   GF_DEF_ARG(\"no-inplace\", NULL, \"disable inplace rewrite\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_EXPERT),",
          "",
          "[Added Lines]",
          "439:     , 0, parse_track_action, TRAC_ACTION_SET_EDITS, ARG_IS_FUN),",
          "440:   MP4BOX_ARG(\"moovpad\", \"specify amount of padding to keep after moov box for later inplace editing - if 0, moov padding is disabled\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &moov_pading, 0, ARG_NEED_SAVE),",
          "441:   MP4BOX_ARG(\"no-inplace\", \"disable inplace rewrite\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &no_inplace, 0, 0),",
          "442:   MP4BOX_ARG(\"hdr\", \"update HDR information based on given XML\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &high_dynamc_range_filename, 0, ARG_OPEN_EDIT),",
          "443:   MP4BOX_ARG_S(\"time\", \"[tkID=]DAY/MONTH/YEAR-H:M:S\", \"set movie or track creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRAC_ACTION_SET_TIME, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "202:  while (m4b_gen_args[i].name) {",
          "204:   i++;",
          "205:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-gen\");",
          "206:  }",
          "207: }",
          "211: {",
          "216:  \"- `S:E`: `S` (number of seconds) to `E` with `E` a number (in seconds), `end` or `end-N`, N  number of seconds before the end\\n\"",
          "219:  {0}",
          "220: };",
          "",
          "[Removed Lines]",
          "203:   GF_GPACArg *arg = &m4b_gen_args[i];",
          "210: GF_GPACArg m4b_split_args[] =",
          "212:   GF_DEF_ARG(\"split\", NULL, \"split in files of given max duration\", NULL, NULL, GF_ARG_STRING, 0),",
          "213:  GF_DEF_ARG(\"split-size\", \"splits\", \"split in files of given max size (in kb)\", NULL, NULL, GF_ARG_STRING, 0),",
          "214:  GF_DEF_ARG(\"split-rap\", \"splitr\", \"split in files at each new RAP\", NULL, NULL, GF_ARG_STRING, 0),",
          "215:  GF_DEF_ARG(\"split-chunk VAL\", \"splitx\", \"extract a new file from source. `VAL` can be formated as:\\n\"",
          "217:  \"- `S-E`: start and end dates, each formatted as `HH:MM:SS.ms` or `MM:SS.ms`\", NULL, NULL, GF_ARG_STRING, 0),",
          "218:  GF_DEF_ARG(\"splitz `S:E`\", NULL, \"same as -split-chunk, but adjust the end time to be before the next RAP sample, so that ranges `A:B` and `B:C` share exactly the same boundary `B`\", NULL, NULL, GF_ARG_STRING, 0),",
          "",
          "[Added Lines]",
          "465:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_gen_args[i];",
          "472: MP4BoxArg m4b_split_args[] =",
          "474:   MP4BOX_ARG(\"split\", \"split in files of given max duration\", GF_ARG_STRING, 0, parse_split, 0, ARG_IS_FUN),",
          "475:  MP4BOX_ARG_ALT(\"split-rap\", \"splitr\", \"split in files at each new RAP\", GF_ARG_STRING, 0, parse_split, 1, ARG_IS_FUN),",
          "476:  MP4BOX_ARG_ALT(\"split-size\", \"splits\", \"split in files of given max size (in kb)\", GF_ARG_STRING, 0, parse_split, 2, ARG_IS_FUN),",
          "477:  MP4BOX_ARG_ALT(\"split-chunk\", \"splitx\", \"extract a new file from source. `VAL` can be formated as:\\n\"",
          "479:  \"- `S-E`: start and end dates, each formatted as `HH:MM:SS.ms` or `MM:SS.ms`\", GF_ARG_STRING, 0, parse_split, 3, ARG_IS_FUN),",
          "480:  MP4BOX_ARG_S(\"splitz\", \"S:E\", \"same as -split-chunk, but adjust the end time to be before the next RAP sample, so that ranges `A:B` and `B:C` share exactly the same boundary `B`\", 0, parse_split, 4, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "236:  i=0;",
          "237:  while (m4b_split_args[i].name) {",
          "239:   i++;",
          "240:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-split\");",
          "241:  }",
          "",
          "[Removed Lines]",
          "238:   GF_GPACArg *arg = &m4b_split_args[i];",
          "",
          "[Added Lines]",
          "500:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_split_args[i];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "243: }",
          "247: {",
          "261:          \"- $Number[%%0Nd]$ is replaced by the segment number, possibly prefixed with 0\\n\"",
          "262:          \"- $RepresentationID$ is replaced by representation name\\n\"",
          "263:          \"- $Time$ is replaced by segment start time\\n\"",
          "",
          "[Removed Lines]",
          "246: GF_GPACArg m4b_dash_args[] =",
          "248:   GF_DEF_ARG(\"mpd\", NULL, \"convert given HLS or smooth manifest (local or remote http) to MPD.  \\nWarning: This is not compatible with other DASH options and does not convert associated segments\", NULL, NULL, GF_ARG_STRING, 0),",
          "249:   GF_DEF_ARG(\"dash\", \"-dash-strict\", \"create DASH from input files with given segment (subsegment for onDemand profile) duration in ms\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "250:   GF_DEF_ARG(\"dash-live\", NULL, \"generate a live DASH session using the given segment duration in ms; using `-dash-live=F`will also write the live context to `F`. MP4Box will run the live session until `q` is pressed or a fatal error occurs\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "251:   GF_DEF_ARG(\"ddbg-live\", NULL, \"same as [-dash-live]() without time regulation for debug purposes\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "252:  GF_DEF_ARG(\"frag\", NULL, \"specify the fragment duration in ms. If not set, this is the DASH duration (one fragment per segment)\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "253:  GF_DEF_ARG(\"out\", NULL, \"specify the output MPD file name\", NULL, NULL, GF_ARG_STRING, 0),",
          "254:  GF_DEF_ARG(\"tmp\", NULL, \"specify directory for temporary file creation\", NULL, NULL, GF_ARG_STRING, 0),",
          "255:  GF_DEF_ARG(\"profile\", NULL, \"specify the target DASH profile, and set default options to ensure conformance to the desired profile. Default profile is `full` in static mode, `live` in dynamic mode (old syntax using `:live` instead of `.live` as separator still possible)\", NULL, \"onDemand|live|main|simple|full|hbbtv1.5.live|dashavc264.live|dashavc264.onDemand|dashif.ll\", GF_ARG_STRING, 0),",
          "256:  GF_DEF_ARG(\"profile-ext\", NULL, \"specify a list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used\", NULL, NULL, GF_ARG_STRING, 0),",
          "258:  GF_DEF_ARG(\"rap\", NULL, \"ensure that segments begin with random access points, segment durations might vary depending on the source encoding\", NULL, NULL, GF_ARG_BOOL, 0),",
          "259:  GF_DEF_ARG(\"frag-rap\", NULL, \"ensure that all fragments begin with random access points (duration might vary depending on the source encoding)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "260:  GF_DEF_ARG(\"segment-name\", NULL, \"set the segment name for generated segments. If not set (default), segments are concatenated in output file except in `live` profile where `dash_%%s`. Supported replacement strings are:\\n\"",
          "",
          "[Added Lines]",
          "508: MP4BoxArg m4b_dash_args[] =",
          "510:   MP4BOX_ARG (\"dash\", \"create DASH from input files with given segment (subsegment for onDemand profile) duration in ms\", GF_ARG_DOUBLE, 0, &dash_duration, 0, ARG_DIV_1000 | ARG_NON_ZERO),",
          "511:   MP4BOX_ARG(\"dash-live\", \"generate a live DASH session using the given segment duration in ms; using `-dash-live=F` will also write the live context to `F`. MP4Box will run the live session until `q` is pressed or a fatal error occurs\", GF_ARG_DOUBLE, 0, parse_dashlive, 0, ARG_IS_FUN2),",
          "512:   MP4BOX_ARG(\"ddbg-live\", \"same as [-dash-live]() without time regulation for debug purposes\", GF_ARG_DOUBLE, 0, parse_dashlive, 1, ARG_IS_FUN2),",
          "513:  MP4BOX_ARG(\"frag\", \"specify the fragment duration in ms. If not set, this is the DASH duration (one fragment per segment)\", GF_ARG_DOUBLE, 0, parse_store_mode, 2, ARG_IS_FUN),",
          "514:  MP4BOX_ARG(\"out\", \"specify the output MPD file name\", GF_ARG_STRING, 0, &outName, 0, 0),",
          "515:  MP4BOX_ARG_ALT(\"profile\", \"dash-profile\", \"specify the target DASH profile, and set default options to ensure conformance to the desired profile. Default profile is `full` in static mode, `live` in dynamic mode (old syntax using `:live` instead of `.live` as separator still possible). Defined values are onDemand, live, main, simple, full, hbbtv1.5.live, dashavc264.live, dashavc264.onDemand, dashif.ll\", GF_ARG_STRING, 0, parse_dash_profile, 0, ARG_IS_FUN),",
          "516:  MP4BOX_ARG(\"profile-ext\", \"specify a list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used\", GF_ARG_STRING, 0, &dash_profile_extension, 0, 0),",
          "517:  MP4BOX_ARG(\"rap\", \"ensure that segments begin with random access points, segment durations might vary depending on the source encoding\", GF_ARG_BOOL, 0, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),",
          "518:  MP4BOX_ARG(\"frag-rap\", \"ensure that all fragments begin with random access points (duration might vary depending on the source encoding)\", GF_ARG_BOOL, 0, &frag_at_rap, 0, 0),",
          "519:  MP4BOX_ARG(\"segment-name\", \"set the segment name for generated segments. If not set (default), segments are concatenated in output file except in `live` profile where `dash_%%s`. Supported replacement strings are:\\n\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "265:          \"- $Init=NAME$ is replaced by NAME for init segment, ignored otherwise\\n\"",
          "266:          \"- $Index=NAME$ is replaced by NAME for index segments, ignored otherwise\\n\"",
          "267:          \"- $Path=PATH$ is replaced by PATH when creating segments, ignored otherwise\\n\"",
          "292:  \"- v: initial movie\\n\"",
          "293:  \"- f: movie fragments\\n\"",
          "294:  \"- m: MPD\\n\"",
          "295:  \"- mv, vm: in initial movie and MPD\\n\"",
          "300:  \"- no: do not use sdtp\\n\"",
          "301:  \"- sdtp: use sdtp box to indicate sample dependencies and don't write info in trun sample flags\\n\"",
          "310:  \"- 0: a single SIDX box is used per segment\\n\"",
          "318:  \"- inband: use inband param set and a single init segment\\n\"",
          "319:  \"- merge: try to merge param sets in a single sample description, fallback to `no`\\n\"",
          "320:  \"- multi: use several sample description, one per quality\\n\"",
          "321:  \"- no: use one init segment per quality\\n\"",
          "331:          \"- as: sets ContentProtection in AdaptationSet element\\n\"",
          "332:          \"- rep: sets ContentProtection in Representation element\\n\"",
          "340:  {0}",
          "341: };",
          "",
          "[Removed Lines]",
          "268:          \"- $Segment=NAME$ is replaced by NAME for media segments, ignored for init segments\", NULL, NULL, GF_ARG_STRING, 0),",
          "269:  GF_DEF_ARG(\"segment-ext\", NULL, \"set the segment extension, `null` means no extension\", \"m4s\", NULL, GF_ARG_STRING, 0),",
          "270:  GF_DEF_ARG(\"init-segment-ext\", NULL, \"set the segment extension for init, index and bitstream switching segments, `null` means no extension\\n\", \"mp4\", NULL, GF_ARG_STRING, 0),",
          "271:  GF_DEF_ARG(\"segment-timeline\", NULL, \"use `SegmentTimeline` when generating segments\", NULL, NULL, GF_ARG_BOOL, 0),",
          "272:  GF_DEF_ARG(\"segment-marker `MARK`\", NULL, \"add a box of type `MARK` (4CC) at the end of each DASH segment\", NULL, NULL, GF_ARG_STRING, 0),",
          "273:  GF_DEF_ARG(\"insert-utc\", NULL, \"insert UTC clock at the beginning of each ISOBMF segment\", NULL, NULL, GF_ARG_BOOL, 0),",
          "274:  GF_DEF_ARG(\"base-url\", NULL, \"set Base url at MPD level. Can be used several times.  \\nWarning: this does not  modify generated files location\", NULL, NULL, GF_ARG_STRING, 0),",
          "275:  GF_DEF_ARG(\"mpd-title\", NULL, \"set MPD title\", NULL, NULL, GF_ARG_STRING, 0),",
          "276:  GF_DEF_ARG(\"mpd-source\", NULL, \"set MPD source\", NULL, NULL, GF_ARG_STRING, 0),",
          "277:  GF_DEF_ARG(\"mpd-info-url\", NULL, \"set MPD info url\", NULL, NULL, GF_ARG_STRING, 0),",
          "278:  GF_DEF_ARG(\"cprt\", NULL, \"add copyright string to MPD\", NULL, NULL, GF_ARG_STRING, 0),",
          "279:  GF_DEF_ARG(\"dash-ctx\", NULL, \"store/restore DASH timing from indicated file\", NULL, NULL, GF_ARG_STRING, 0),",
          "280:  GF_DEF_ARG(\"dynamic\", NULL, \"use dynamic MPD type instead of static\", NULL, NULL, GF_ARG_BOOL, 0),",
          "281:  GF_DEF_ARG(\"last-dynamic\", NULL, \"same as [-dynamic]() but close the period (insert lmsg brand if needed and update duration)\", NULL, NULL, GF_ARG_STRING, 0),",
          "282:  GF_DEF_ARG(\"mpd-duration\", NULL, \"set the duration in second of a live session (if `0`, you must use [-mpd-refresh]())\", \"0\", NULL, GF_ARG_DOUBLE, 0),",
          "283:  GF_DEF_ARG(\"mpd-refresh\", NULL, \"specify MPD update time in seconds\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "284:  GF_DEF_ARG(\"time-shift\", NULL, \"specify MPD time shift buffer depth in seconds, `-1` to keep all files)\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "285:  GF_DEF_ARG(\"subdur\", NULL, \"specify maximum duration in ms of the input file to be dashed in LIVE or context mode. This does not change the segment duration, but stops dashing once segments produced exceeded the duration. If there is not enough samples to finish a segment, data is looped unless [-no-loop]() is used which triggers a period end\", NULL, NULL, GF_ARG_INT, 0),",
          "286:  GF_DEF_ARG(\"run-for\", NULL, \"run for given ms  the dash-live session then exits\", NULL, NULL, GF_ARG_INT, 0),",
          "287:  GF_DEF_ARG(\"min-buffer\", NULL, \"specify MPD min buffer time in ms\", NULL, NULL, GF_ARG_INT, 0),",
          "288:  GF_DEF_ARG(\"ast-offset\", NULL, \"specify MPD AvailabilityStartTime offset in ms if positive, or availabilityTimeOffset of each representation if negative\", \"0\", NULL, GF_ARG_INT, 0),",
          "289:  GF_DEF_ARG(\"dash-scale\", NULL, \"specify that timing for [-dash]() and [-frag]() are expressed in given timexale (units per seconds)\", NULL, NULL, GF_ARG_INT, 0),",
          "290:  GF_DEF_ARG(\"mem-frags\", NULL, \"fragmentation happens in memory rather than on disk before flushing to disk\", NULL, NULL, GF_ARG_BOOL, 0),",
          "291:  GF_DEF_ARG(\"pssh\", NULL, \"set pssh store mode\\n\"",
          "296:  \"- mf, fm: in movie fragments and MPD\", NULL, \"v|f|m|mv|vm|mf|fm\", GF_ARG_INT, 0),",
          "297:  GF_DEF_ARG(\"sample-groups-traf\", NULL, \"store sample group descriptions in traf (duplicated for each traf). If not set, sample group descriptions are stored in the initial movie\", NULL, NULL, GF_ARG_BOOL, 0),",
          "298:  GF_DEF_ARG(\"mvex-after-traks\", NULL, \"store `mvex` box after `trak` boxes within the moov box. If not set, `mvex` is before\", NULL, NULL, GF_ARG_BOOL, 0),",
          "299:  GF_DEF_ARG(\"sdtp-traf\", NULL, \"use `sdtp` box in `traf` (Smooth-like)\\n\"",
          "302:  \"- both: use sdtp box to indicate sample dependencies and also write info in trun sample flags\\n\", NULL, \"no|sdtp|both\", GF_ARG_INT, 0),",
          "303:  GF_DEF_ARG(\"no-cache\", NULL, \"disable file cache for dash inputs\", NULL, NULL, GF_ARG_BOOL, 0),",
          "304:  GF_DEF_ARG(\"no-loop\", NULL, \"disable looping content in live mode and uses period switch instead\", NULL, NULL, GF_ARG_BOOL, 0),",
          "305:  GF_DEF_ARG(\"hlsc\", NULL, \"insert UTC in variant playlists for live HLS\", NULL, NULL, GF_ARG_BOOL, 0),",
          "306:  GF_DEF_ARG(\"bound\", NULL, \"segmentation will always try to split before or at, but never after, the segment boundary\", NULL, NULL, GF_ARG_BOOL, 0),",
          "307:  GF_DEF_ARG(\"closest\", NULL, \"segmentation will use the closest frame to the segment boundary (before or after)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "309:  GF_DEF_ARG(\"subsegs-per-sidx\", NULL, \"set the number of subsegments to be written in each SIDX box\\n\"",
          "311:  \"- -1: no SIDX box is used\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_EXPERT),",
          "312:  GF_DEF_ARG(\"ssix\", NULL, \"enable SubsegmentIndexBox describing 2 ranges, first one from moof to end of first I-frame, second one unmapped. This does not work with daisy chaining mode enabled\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "313:  GF_DEF_ARG(\"url-template\", NULL, \"use SegmentTemplate instead of explicit sources in segments. Ignored if segments are stored in the output file\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "314:  GF_DEF_ARG(\"daisy-chain\", NULL, \"use daisy-chain SIDX instead of hierarchical. Ignored if frags/sidx is 0\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "315:  GF_DEF_ARG(\"single-segment\", NULL, \"use a single segment for the whole file (OnDemand profile)\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "316:  GF_DEF_ARG(\"single-file\", NULL, \"use a single file for the whole file (default)\", \"yes\", NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "317:  GF_DEF_ARG(\"bs-switching\", NULL, \"set bitstream switching mode\\n\"",
          "322:  \"- single: to test with single input\", \"inband\", \"inband|merge|multi|no|single\", GF_ARG_STRING, GF_ARG_HINT_EXPERT),",
          "323:  GF_DEF_ARG(\"moof-sn\", NULL, \"set sequence number of first moof to given value\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_EXPERT),",
          "324:  GF_DEF_ARG(\"tfdt\", NULL, \"set TFDT of first traf to given value in SCALE units (cf -dash-scale)\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_EXPERT),",
          "325:  GF_DEF_ARG(\"no-frags-default\", NULL, \"disable default fragments flags in trex (required by some dash-if profiles and CMAF/smooth streaming compatibility)\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "326:  GF_DEF_ARG(\"single-traf\", NULL, \"use a single track fragment per moof (smooth streaming and derived specs may require this)\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "327:  GF_DEF_ARG(\"tfdt-traf\", NULL, \"use a tfdt per track fragment (when -single-traf is used)\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "328:  GF_DEF_ARG(\"dash-ts-prog\", NULL, \"program_number to be considered in case of an MPTS input file\", NULL, NULL, GF_ARG_INT, GF_ARG_HINT_EXPERT),",
          "329:  GF_DEF_ARG(\"frag-rt\", NULL, \"when using fragments in live mode, flush fragments according to their timing\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "330:  GF_DEF_ARG(\"cp-location\", NULL, \"set ContentProtection element location\\n\"",
          "333:          \"- both: sets ContentProtection in both elements\", NULL, \"as|rep\\both\", GF_ARG_STRING, GF_ARG_HINT_EXPERT),",
          "334:  GF_DEF_ARG(\"start-date\", NULL, \"for live mode, set start date (as xs:date, eg YYYY-MM-DDTHH:MM:SSZ). Default is current UTC\\n\"",
          "335:  \"Warning: Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_EXPERT),",
          "337:  GF_DEF_ARG(\"cues\", NULL, \"ignore dash duration and segment according to cue times in given XML file (tests/media/dash_cues for examples)\", NULL, NULL, GF_ARG_STRING, GF_ARG_HINT_EXPERT),",
          "338:  GF_DEF_ARG(\"strict-cues\", NULL, \"throw error if something is wrong while parsing cues or applying cue-based segmentation\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "339:  GF_DEF_ARG(\"merge-last-seg\", NULL, \"merge last segment if shorter than half the target duration\", NULL, NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT),",
          "",
          "[Added Lines]",
          "527:          \"- $Segment=NAME$ is replaced by NAME for media segments, ignored for init segments\", GF_ARG_STRING, 0, &seg_name, 0, 0),",
          "528:  {\"segment-ext\", NULL, \"set the segment extension, `null` means no extension\", \"m4s\", NULL, GF_ARG_STRING, 0, &seg_ext, 0, 0},",
          "529:  {\"init-segment-ext\", NULL, \"set the segment extension for init, index and bitstream switching segments, `null` means no extension\\n\", \"mp4\", NULL, GF_ARG_STRING, 0, &init_seg_ext, 0, 0},",
          "530:  MP4BOX_ARG(\"segment-timeline\", \"use `SegmentTimeline` when generating segments\", GF_ARG_BOOL, 0, &segment_timeline, 0, 0),",
          "531:  MP4BOX_ARG(\"segment-marker\", \"add a box of given type (4CC) at the end of each DASH segment\", GF_ARG_STRING, 0, &segment_marker, 0, ARG_IS_4CC),",
          "532:  MP4BOX_ARG(\"insert-utc\", \"insert UTC clock at the beginning of each ISOBMF segment\", GF_ARG_BOOL, 0, &insert_utc, 0, 0),",
          "533:  MP4BOX_ARG(\"base-url\", \"set Base url at MPD level. Can be used several times.  \\nWarning: this does not  modify generated files location\", GF_ARG_STRING, 0, parse_base_url, 0, ARG_IS_FUN),",
          "534:  MP4BOX_ARG(\"mpd-title\", \"set MPD title\", GF_ARG_STRING, 0, &dash_title, 0, 0),",
          "535:  MP4BOX_ARG(\"mpd-source\", \"set MPD source\", GF_ARG_STRING, 0, &dash_source, 0, 0),",
          "536:  MP4BOX_ARG(\"mpd-info-url\", \"set MPD info url\", GF_ARG_STRING, 0, &dash_more_info, 0, 0),",
          "537:   MP4BOX_ARG(\"cprt\", \"add copyright string to MPD\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &cprt, 0, 0),",
          "538:  MP4BOX_ARG(\"dash-ctx\", \"store/restore DASH timing from indicated file\", GF_ARG_STRING, 0, &dash_ctx_file, 0, 0),",
          "539:  MP4BOX_ARG(\"dynamic\", \"use dynamic MPD type instead of static\", GF_ARG_BOOL, 0, &dash_mode, GF_DASH_DYNAMIC, 0),",
          "540:  MP4BOX_ARG(\"last-dynamic\", \"same as [-dynamic]() but close the period (insert lmsg brand if needed and update duration)\", GF_ARG_BOOL, 0, &dash_mode, GF_DASH_DYNAMIC_LAST, 0),",
          "541:  MP4BOX_ARG(\"mpd-duration\", \"set the duration in second of a live session (if `0`, you must use [-mpd-refresh]())\", GF_ARG_DOUBLE, 0, &mpd_live_duration, 0, 0),",
          "542:  MP4BOX_ARG(\"mpd-refresh\", \"specify MPD update time in seconds\", GF_ARG_DOUBLE, 0, &mpd_update_time, 0, 0),",
          "543:  MP4BOX_ARG(\"time-shift\", \"specify MPD time shift buffer depth in seconds, `-1` to keep all files)\", GF_ARG_INT, 0, &time_shift_depth, 0, 0),",
          "544:  MP4BOX_ARG(\"subdur\", \"specify maximum duration in ms of the input file to be dashed in LIVE or context mode. This does not change the segment duration, but stops dashing once segments produced exceeded the duration. If there is not enough samples to finish a segment, data is looped unless [-no-loop]() is used which triggers a period end\", GF_ARG_DOUBLE, 0, &dash_subduration, 0, ARG_DIV_1000),",
          "545:  MP4BOX_ARG(\"run-for\", \"run for given ms  the dash-live session then exits\", GF_ARG_INT, 0, &run_for, 0, 0),",
          "546:  MP4BOX_ARG(\"min-buffer\", \"specify MPD min buffer time in ms\", GF_ARG_INT, 0, &min_buffer, 0, ARG_DIV_1000),",
          "547:  MP4BOX_ARG(\"ast-offset\", \"specify MPD AvailabilityStartTime offset in ms if positive, or availabilityTimeOffset of each representation if negative\", GF_ARG_INT, 0, &ast_offset_ms, 0, 0),",
          "548:  MP4BOX_ARG(\"dash-scale\", \"specify that timing for [-dash]() and [-do_frag]() are expressed in given timexale (units per seconds)\", GF_ARG_INT, 0, &dash_scale, 0, ARG_NON_ZERO),",
          "549:  MP4BOX_ARG(\"mem-frags\", \"fragmentation happens in memory rather than on disk before flushing to disk\", GF_ARG_BOOL, 0, &memory_frags, 0, 0),",
          "550:  MP4BOX_ARG(\"pssh\", \"set pssh store mode\\n\"",
          "555:  \"- mf, fm: in movie fragments and MPD\", GF_ARG_INT, 0, parse_pssh, 0, ARG_IS_FUN),",
          "556:  MP4BOX_ARG(\"sample-groups-traf\", \"store sample group descriptions in traf (duplicated for each traf). If not set, sample group descriptions are stored in the initial movie\", GF_ARG_BOOL, 0, &samplegroups_in_traf, 0, 0),",
          "557:  MP4BOX_ARG(\"mvex-after-traks\", \"store `mvex` box after `trak` boxes within the moov box. If not set, `mvex` is before\", GF_ARG_BOOL, 0, &mvex_after_traks, 0, 0),",
          "558:  MP4BOX_ARG(\"sdtp-traf\", \"use `sdtp` box in `traf` (Smooth-like)\\n\"",
          "561:  \"- both: use sdtp box to indicate sample dependencies and also write info in trun sample flags\\n\", GF_ARG_INT, 0, parse_sdtp, 0, ARG_IS_FUN),",
          "562:  MP4BOX_ARG(\"no-cache\", \"disable file cache for dash inputs\", GF_ARG_BOOL, 0, &no_cache, 0, 0),",
          "563:  MP4BOX_ARG(\"no-loop\", \"disable looping content in live mode and uses period switch instead\", GF_ARG_BOOL, 0, &no_loop, 0, 0),",
          "564:  MP4BOX_ARG(\"hlsc\", \"insert UTC in variant playlists for live HLS\", GF_ARG_BOOL, 0, &hls_clock, 0, 0),",
          "565:  MP4BOX_ARG(\"bound\", \"segmentation will always try to split before or at, but never after, the segment boundary\", GF_ARG_BOOL, 0, &dash_split_mode, GF_DASH_SPLIT_IN, 0),",
          "566:  MP4BOX_ARG(\"closest\", \"segmentation will use the closest frame to the segment boundary (before or after)\", GF_ARG_BOOL, 0, &dash_split_mode, GF_DASH_SPLIT_CLOSEST, 0),",
          "567:  MP4BOX_ARG_ALT(\"subsegs-per-sidx\", \"frags-per-sidx\", \"set the number of subsegments to be written in each SIDX box\\n\"",
          "569:  \"- -1: no SIDX box is used\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &subsegs_per_sidx, 0, 0),",
          "570:  MP4BOX_ARG(\"ssix\", \"enable SubsegmentIndexBox describing 2 ranges, first one from moof to end of first I-frame, second one unmapped. This does not work with daisy chaining mode enabled\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_ssix, 0, 0),",
          "571:  MP4BOX_ARG(\"url-template\", \"use SegmentTemplate instead of explicit sources in segments. Ignored if segments are stored in the output file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_url_template, 1, 0),",
          "572:  MP4BOX_ARG(\"url-template-sim\", \"use SegmentTemplate simulation while converting HLS to MPD\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_url_template, 2, 0),",
          "573:  MP4BOX_ARG(\"daisy-chain\", \"use daisy-chain SIDX instead of hierarchical. Ignored if frags/sidx is 0\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &daisy_chain_sidx, 0, 0),",
          "574:  MP4BOX_ARG(\"single-segment\", \"use a single segment for the whole file (OnDemand profile)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_segment, 0, 0),",
          "575:  {\"single-file\", NULL, \"use a single file for the whole file (default)\", \"yes\", NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_file, 0, 0},",
          "576:  {\"bs-switching\", NULL, \"set bitstream switching mode\\n\"",
          "581:  \"- single: to test with single input\", \"inband\", \"inband|merge|multi|no|single\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, parse_bs_switch, 0, ARG_IS_FUN},",
          "582:  MP4BOX_ARG(\"moof-sn\", \"set sequence number of first moof to given value\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &initial_moof_sn, 0, 0),",
          "583:  MP4BOX_ARG(\"tfdt\", \"set TFDT of first traf to given value in SCALE units (cf -dash-scale)\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &initial_tfdt, 0, ARG_64BITS),",
          "584:  MP4BOX_ARG(\"no-frags-default\", \"disable default fragments flags in trex (required by some dash-if profiles and CMAF/smooth streaming compatibility)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &no_fragments_defaults, 0, 0),",
          "585:  MP4BOX_ARG(\"single-traf\", \"use a single track fragment per moof (smooth streaming and derived specs may require this)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_traf_per_moof, 0, 0),",
          "586:  MP4BOX_ARG(\"tfdt-traf\", \"use a tfdt per track fragment (when -single-traf is used)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &tfdt_per_traf, 0, 0),",
          "587:  MP4BOX_ARG(\"dash-ts-prog\", \"program_number to be considered in case of an MPTS input file\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &program_number, 0, 0),",
          "588:  MP4BOX_ARG(\"frag-rt\", \"when using fragments in live mode, flush fragments according to their timing\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &frag_real_time, 0, 0),",
          "589:  MP4BOX_ARG(\"cp-location\", \"set ContentProtection element location\\n\"",
          "592:          \"- both: sets ContentProtection in both elements\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, parse_cp_loc, 0, ARG_IS_FUN),",
          "593:  MP4BOX_ARG(\"start-date\", \"for live mode, set start date (as xs:date, eg YYYY-MM-DDTHH:MM:SSZ). Default is current UTC\\n\"",
          "594:  \"Warning: Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &dash_start_date, 0, 0),",
          "595:  MP4BOX_ARG(\"cues\", \"ignore dash duration and segment according to cue times in given XML file (tests/media/dash_cues for examples)\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &dash_cues, 0, 0),",
          "596:  MP4BOX_ARG(\"strict-cues\", \"throw error if something is wrong while parsing cues or applying cue-based segmentation\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &strict_cues, 0, 0),",
          "597:  MP4BOX_ARG(\"merge-last-seg\", \"merge last segment if shorter than half the target duration\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &merge_last_seg, 0, 0),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "387:  while (m4b_dash_args[i].name) {",
          "389:   i++;",
          "390:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-dash\");",
          "391:  }",
          "392: }",
          "396: {",
          "415:  {0}",
          "416: };",
          "420:  GF_DEF_ARG(\"dur\", NULL, \"`X` import only the specified duration from the media. Value can be:\\n\"",
          "421:   \"  - positive float: specifies duration in seconds\\n\"",
          "422:   \"  - fraction: specifies duration as NUM/DEN fraction\\n\"",
          "",
          "[Removed Lines]",
          "388:   GF_GPACArg *arg = &m4b_dash_args[i];",
          "395: GF_GPACArg m4b_imp_args[] =",
          "397:   GF_DEF_ARG(\"add\", NULL, \"add given file tracks to file. Multiple inputs can be specified using `+`, eg `-add url1+url2\", NULL, NULL, GF_ARG_STRING, 0),",
          "398:   GF_DEF_ARG(\"cat\", NULL, \"concatenate given file samples to file, creating tracks if needed. Multiple inputs can be specified using `+`(eg `-cat url1+url2).  \\nNote: This aligns initial timestamp of the file to be concatenated\", NULL, NULL, GF_ARG_STRING, 0),",
          "399:   GF_DEF_ARG(\"catx\", NULL, \"same as [-cat]() but new tracks can be imported before concatenation by specifying `+ADD_COMMAND` where `ADD_COMMAND` is a regular [-add]() syntax\", NULL, NULL, GF_ARG_STRING, 0),",
          "400:   GF_DEF_ARG(\"catpl\", NULL, \"concatenate files listed in the given playlist file (one file per line, lines starting with # are comments).  \\nNote: Each listed file is concatenated as if called with -cat\", NULL, NULL, GF_ARG_STRING, 0),",
          "401:   GF_DEF_ARG(\"unalign-cat\", NULL, \"do not attempt to align timestamps of samples inbetween tracks\", NULL, NULL, GF_ARG_STRING, 0),",
          "402:   GF_DEF_ARG(\"force-cat\", NULL, \"skip media configuration check when concatenating file.  \\nWarning: THIS MAY BREAK THE CONCATENATED TRACK(S)\", NULL, NULL, GF_ARG_STRING, 0),",
          "403:   GF_DEF_ARG(\"keep-sys\", NULL, \"keep all MPEG-4 Systems info when using [-add]() and [-cat]() (only used when adding IsoMedia files)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "404:   GF_DEF_ARG(\"dref\", NULL, \"keep media data in original file using `data referencing`. The resulting file only contains the meta-data of the presentation (frame sizes, timing, etc...) and references media data in the original file. This is extremely useful when developping content, since importing and storage of the MP4 file is much faster and the resulting file much smaller.  \\nNote: Data referencing may fail on some files because it requires the framed data (eg an IsoMedia sample) to be continuous in the original file, which is not always the case depending on the original interleaving or bitstream format (__AVC__ or __HEVC__ cannot use this option)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "405:   GF_DEF_ARG(\"no-drop\", NULL, \"force constant FPS when importing AVI video\", NULL, NULL, GF_ARG_BOOL, 0),",
          "406:   GF_DEF_ARG(\"packed\", NULL, \"force packed bitstream when importing raw MPEG-4 part 2 Advanced Simple Profile\", NULL, NULL, GF_ARG_BOOL, 0),",
          "407:   GF_DEF_ARG(\"sbr\", NULL, \"backward compatible signaling of AAC-SBR\", NULL, NULL, GF_ARG_BOOL, 0),",
          "408:   GF_DEF_ARG(\"sbrx\", NULL, \"non-backward compatible signaling of AAC-SBR\", NULL, NULL, GF_ARG_BOOL, 0),",
          "409:   GF_DEF_ARG(\"ps\", NULL, \"backward compatible signaling of AAC-PS\", NULL, NULL, GF_ARG_BOOL, 0),",
          "410:   GF_DEF_ARG(\"psx\", NULL, \"non-backward compatible signaling of AAC-PS\", NULL, NULL, GF_ARG_BOOL, 0),",
          "411:   GF_DEF_ARG(\"ovsbr\", NULL, \"oversample SBR import (SBR AAC, PS AAC and oversampled SBR cannot be detected at import time)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "412:   GF_DEF_ARG(\"fps\", NULL, \"force frame rate for video and SUB subtitles import to the given value, expressed as a number or as `timescale-increment`.  \\nNote: For raw H263 import, default FPS is `15`, otherwise `25`. This is ignored for ISOBMFF import, use `:rescale` option for that\", \"25\", NULL, GF_ARG_STRING, 0),",
          "413:   GF_DEF_ARG(\"mpeg4\", NULL, \"force MPEG-4 sample descriptions when possible. For AAC, forces MPEG-4 AAC signaling even if MPEG-2\", NULL, NULL, GF_ARG_BOOL, 0),",
          "414:   GF_DEF_ARG(\"agg\", NULL, \"aggregate N audio frames in 1 sample (3GP media only, maximum value is 15)\", NULL, NULL, GF_ARG_INT, 0),",
          "419: static GF_GPACArg m4b_imp_fileopt_args [] = {",
          "",
          "[Added Lines]",
          "646:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_dash_args[i];",
          "653: MP4BoxArg m4b_imp_args[] =",
          "655:   MP4BOX_ARG(\"add\", \"add given file tracks to file. Multiple inputs can be specified using `+`, eg `-add url1+url2\", GF_ARG_STRING, 0, &nb_add, 0, ARG_INT_INC),",
          "656:   MP4BOX_ARG(\"cat\", \"concatenate given file samples to file, creating tracks if needed. Multiple inputs can be specified using `+`(eg `-cat url1+url2).  \\nNote: This aligns initial timestamp of the file to be concatenated\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),",
          "657:   MP4BOX_ARG(\"catx\", \"same as [-cat]() but new tracks can be imported before concatenation by specifying `+ADD_COMMAND` where `ADD_COMMAND` is a regular [-add]() syntax\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),",
          "658:   MP4BOX_ARG(\"catpl\", \"concatenate files listed in the given playlist file (one file per line, lines starting with # are comments).  \\nNote: Each listed file is concatenated as if called with -cat\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),",
          "659:   MP4BOX_ARG(\"unalign-cat\", \"do not attempt to align timestamps of samples inbetween tracks\", GF_ARG_BOOL, 0, &align_cat, 0, ARG_BOOL_REV),",
          "660:   MP4BOX_ARG(\"force-cat\", \"skip media configuration check when concatenating file.  \\nWarning: THIS MAY BREAK THE CONCATENATED TRACK(S)\", GF_ARG_BOOL, 0, &force_cat, 0, 0),",
          "661:   MP4BOX_ARG(\"keep-sys\", \"keep all MPEG-4 Systems info when using [-add]() and [-cat]() (only used when adding IsoMedia files)\", GF_ARG_BOOL, 0, &keep_sys_tracks, 0, 0),",
          "662:   MP4BOX_ARG(\"dref\", \"keep media data in original file using `data referencing`. The resulting file only contains the meta-data of the presentation (frame sizes, timing, etc...) and references media data in the original file. This is extremely useful when developping content, since importing and storage of the MP4 file is much faster and the resulting file much smaller.  \\nNote: Data referencing may fail on some files because it requires the framed data (eg an IsoMedia sample) to be continuous in the original file, which is not always the case depending on the original interleaving or bitstream format (__AVC__ or __HEVC__ cannot use this option)\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_USE_DATAREF, ARG_BIT_MASK),",
          "663:   MP4BOX_ARG_ALT(\"no-drop\", \"nodrop\", \"force constant FPS when importing AVI video\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_NO_FRAME_DROP, ARG_BIT_MASK),",
          "664:   MP4BOX_ARG(\"packed\", \"force packed bitstream when importing raw MPEG-4 part 2 Advanced Simple Profile\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_PACKED, ARG_BIT_MASK),",
          "665:   MP4BOX_ARG(\"sbr\", \"backward compatible signaling of AAC-SBR\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_SBR_IMPLICIT, ARG_BIT_MASK),",
          "666:   MP4BOX_ARG(\"sbrx\", \"non-backward compatible signaling of AAC-SBR\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_SBR_EXPLICIT, ARG_BIT_MASK),",
          "667:   MP4BOX_ARG(\"ps\", \"backward compatible signaling of AAC-PS\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_PS_IMPLICIT, ARG_BIT_MASK),",
          "668:   MP4BOX_ARG(\"psx\", \"non-backward compatible signaling of AAC-PS\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_PS_EXPLICIT, ARG_BIT_MASK),",
          "669:   MP4BOX_ARG(\"ovsbr\", \"oversample SBR import (SBR AAC, PS AAC and oversampled SBR cannot be detected at import time)\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_OVSBR, ARG_BIT_MASK),",
          "670:   MP4BOX_ARG(\"fps\", \"force frame rate for video and SUB subtitles import to the given value, expressed as a number, as `TS-inc` or `TS/inc`.  \\nNote: For raw H263 import, default FPS is `15`, otherwise `25`. This is ignored for ISOBMFF import, use `:rescale` option for that\", GF_ARG_STRING, 0, parse_fps, 0, ARG_IS_FUN),",
          "671:   MP4BOX_ARG(\"mpeg4\", \"force MPEG-4 sample descriptions when possible. For AAC, forces MPEG-4 AAC signaling even if MPEG-2\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_MPEG4, ARG_BIT_MASK),",
          "672:   MP4BOX_ARG(\"agg\", \"aggregate N audio frames in 1 sample (3GP media only, maximum value is 15)\", GF_ARG_INT, 0, &agg_samples, 0, 0),",
          "677: static MP4BoxArg m4b_imp_fileopt_args [] = {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "584:  i=0;",
          "585:  while (m4b_imp_fileopt_args[i].name) {",
          "587:   i++;",
          "588:   gf_sys_print_arg(helpout, help_flags | GF_PRINTARG_NO_DASH, arg, \"mp4box-import\");",
          "589:  }",
          "",
          "[Removed Lines]",
          "586:   GF_GPACArg *arg = &m4b_imp_fileopt_args[i];",
          "",
          "[Added Lines]",
          "844:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_imp_fileopt_args[i];",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "596:  i=0;",
          "597:  while (m4b_imp_args[i].name) {",
          "599:   i++;",
          "600:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-import\");",
          "601:  }",
          "602: }",
          "605: {",
          "618:   {0}",
          "619: };",
          "",
          "[Removed Lines]",
          "598:   GF_GPACArg *arg = &m4b_imp_args[i];",
          "604: GF_GPACArg m4b_senc_args[] =",
          "606:   GF_DEF_ARG(\"mp4\", NULL, \"specify input file is for encoding\", NULL, NULL, GF_ARG_BOOL, 0),",
          "607:   GF_DEF_ARG(\"def\", NULL, \"encode DEF names in BIFS\", NULL, NULL, GF_ARG_BOOL, 0),",
          "608:   GF_DEF_ARG(\"sync\", NULL, \"force BIFS sync sample generation every given time in ms (cannot be used with [-shadow]() )\", NULL, NULL, GF_ARG_INT, 0),",
          "609:   GF_DEF_ARG(\"shadow\", NULL, \"force BIFS sync shadow sample generation every given time in ms (cannot be used with [-sync]() )\", NULL, NULL, GF_ARG_INT, 0),",
          "610:   GF_DEF_ARG(\"sclog\", NULL, \"generate scene codec log file if available\", NULL, NULL, GF_ARG_BOOL, 0),",
          "611:   GF_DEF_ARG(\"ms\", NULL, \"import tracks from the given file\", NULL, NULL, GF_ARG_STRING, 0),",
          "612:   GF_DEF_ARG(\"ctx-in\", NULL, \"specify initial context (MP4/BT/XMT) file for chunk processing. Input file must be a commands-only file\", NULL, NULL, GF_ARG_STRING, 0),",
          "613:   GF_DEF_ARG(\"ctx-out\", NULL, \"specify storage of updated context (MP4/BT/XMT) file for chunk processing, optional\", NULL, NULL, GF_ARG_STRING, 0),",
          "614:   GF_DEF_ARG(\"resolution\", NULL, \"resolution factor (-8 to 7, default 0) for LASeR encoding, and all coords are multiplied by `2^res` before truncation (LASeR encoding)\", NULL, NULL, GF_ARG_INT, 0),",
          "615:   GF_DEF_ARG(\"coord-bits\", NULL, \"number of bits used for encoding truncated coordinates (0 to 31, default 12) (LASeR encoding)\", NULL, NULL, GF_ARG_INT, 0),",
          "616:   GF_DEF_ARG(\"scale-bits\", NULL, \"extra bits used for encoding truncated scales (0 to 4, default 0) (LASeR encoding)\", NULL, NULL, GF_ARG_INT, 0),",
          "617:   GF_DEF_ARG(\"auto-quant\", NULL, \"resolution is given as if using -resolution but coord-bits and scale-bits are infered (LASeR encoding)\", NULL, NULL, GF_ARG_INT, 0),",
          "",
          "[Added Lines]",
          "856:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_imp_args[i];",
          "862: MP4BoxArg m4b_senc_args[] =",
          "864:   MP4BOX_ARG(\"mp4\", \"specify input file is for BIFS/LASeR encoding\", GF_ARG_BOOL, 0, &encode, 0, ARG_OPEN_EDIT),",
          "865:   MP4BOX_ARG(\"def\", \"encode DEF names in BIFS\", GF_ARG_BOOL, 0, &smenc_opts.flags, GF_SM_ENCODE_USE_NAMES, ARG_BIT_MASK),",
          "866:   MP4BOX_ARG(\"sync\", \"force BIFS sync sample generation every given time in ms (cannot be used with [-shadow]() or [-carousel]() )\", GF_ARG_INT, 0, parse_senc_param, 0, ARG_IS_FUN),",
          "867:   MP4BOX_ARG(\"shadow\", \"force BIFS sync shadow sample generation every given time in ms (cannot be used with [-sync]() or [-carousel]() )\", GF_ARG_INT, 0, parse_senc_param, 1, ARG_IS_FUN),",
          "868:   MP4BOX_ARG(\"carousel\", \"use bifs carousel (cannot be used with [-sync]() or [-shadow]() )\", GF_ARG_INT, 0, parse_senc_param, 2, ARG_IS_FUN),",
          "870:   MP4BOX_ARG(\"sclog\", \"generate scene codec log file if available\", GF_ARG_BOOL, 0, &do_scene_log, 0, 0),",
          "871:   MP4BOX_ARG(\"ms\", \"import tracks from the given file\", GF_ARG_STRING, 0, &mediaSource, 0, 0),",
          "872:   MP4BOX_ARG(\"ctx-in\", \"specify initial context (MP4/BT/XMT) file for chunk processing. Input file must be a commands-only file\", GF_ARG_STRING, 0, parse_senc_param, 5, ARG_IS_FUN),",
          "873:   MP4BOX_ARG(\"ctx-out\", \"specify storage of updated context (MP4/BT/XMT) file for chunk processing, optional\", GF_ARG_STRING, 0, &output_ctx, 0, 0),",
          "874:   MP4BOX_ARG(\"resolution\", \"resolution factor (-8 to 7, default 0) for LASeR encoding, and all coords are multiplied by `2^res` before truncation (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.resolution, 0, 0),",
          "875:   MP4BOX_ARG(\"coord-bits\", \"number of bits used for encoding truncated coordinates (0 to 31, default 12) (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.coord_bits, 0, 0),",
          "876:   MP4BOX_ARG(\"scale-bits\", \"extra bits used for encoding truncated scales (0 to 4, default 0) (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.scale_bits, 0, 0),",
          "877:   MP4BOX_ARG(\"auto-quant\", \"resolution is given as if using -resolution but coord-bits and scale-bits are infered (LASeR encoding)\", GF_ARG_INT, 0, parse_senc_param, 3, ARG_IS_FUN),",
          "878:   MP4BOX_ARG(\"global-quant\", \"resolution is given as if using -resolution but the res is inferred (BIFS encoding)\", GF_ARG_INT, 0, parse_senc_param, 4, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "639:  );",
          "641:  while (m4b_senc_args[i].name) {",
          "643:   i++;",
          "644:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-senc\");",
          "645:  }",
          "646: }",
          "649: {",
          "653:   {0}",
          "654: };",
          "",
          "[Removed Lines]",
          "642:   GF_GPACArg *arg = &m4b_senc_args[i];",
          "648: GF_GPACArg m4b_crypt_args[] =",
          "650:   GF_DEF_ARG(\"crypt\", NULL, \"encrypt the input file using the given `CryptFile`\", NULL, NULL, GF_ARG_STRING, 0),",
          "651:   GF_DEF_ARG(\"decrypt\", NULL, \"decrypt the input file, potentially using the given `CryptFile`. If `CryptFile` is not given, will fail if the key management system is not supported\", NULL, NULL, GF_ARG_STRING, 0),",
          "652:   GF_DEF_ARG(\"set-kms\", NULL, \"change ISMA/OMA KMS location for all tracks, or for a given one if `ID=kms_uri` is used\", NULL, NULL, GF_ARG_STRING, 0),",
          "",
          "[Added Lines]",
          "903:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_senc_args[i];",
          "909: MP4BoxArg m4b_crypt_args[] =",
          "911:   MP4BOX_ARG(\"crypt\", \"encrypt the input file using the given `CryptFile`\", GF_ARG_STRING, 0, parse_cryp, 0, ARG_IS_FUN),",
          "912:   MP4BOX_ARG(\"decrypt\", \"decrypt the input file, potentially using the given `CryptFile`. If `CryptFile` is not given, will fail if the key management system is not supported\", GF_ARG_STRING, 0, parse_cryp, 1, ARG_IS_FUN | ARG_EMPTY),",
          "913:   MP4BOX_ARG_S(\"set-kms\", \"tkID=kms_uri\", \"change ISMA/OMA KMS location for a given track or for all tracks if `all=` is used\", 0, parse_track_action, TRAC_ACTION_SET_KMS_URI, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "664:  \"Options:\\n\"",
          "665:  );",
          "666:  while (m4b_crypt_args[i].name) {",
          "668:   i++;",
          "669:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-crypt\");",
          "670:  }",
          "671: }",
          "674: {",
          "693:   {0}",
          "694: };",
          "",
          "[Removed Lines]",
          "667:   GF_GPACArg *arg = &m4b_crypt_args[i];",
          "673: GF_GPACArg m4b_hint_args[] =",
          "675:   GF_DEF_ARG(\"hint\", NULL, \"hint the file for RTP/RTSP\", NULL, NULL, GF_ARG_BOOL, 0),",
          "676:   GF_DEF_ARG(\"mtu\", NULL, \"specify RTP MTU (max size) in bytes (this includes 12 bytes RTP header)\", \"1450\", NULL, GF_ARG_INT, 0),",
          "677:   GF_DEF_ARG(\"copy\", NULL, \"copy media data to hint track rather than reference (speeds up server but takes much more space)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "678:   GF_DEF_ARG(\"multi `[maxptime]`\", NULL, \"enable frame concatenation in RTP packets if possible (with max duration 100 ms or `maxptime` ms if given)\", NULL, NULL, GF_ARG_INT, 0),",
          "679:   GF_DEF_ARG(\"rate\", NULL, \"specify rtp rate in Hz when no default for payload\", \"90000\", NULL, GF_ARG_INT, 0),",
          "680:   GF_DEF_ARG(\"mpeg4\", NULL, \"force MPEG-4 generic payload whenever possible\", NULL, NULL, GF_ARG_BOOL, 0),",
          "681:   GF_DEF_ARG(\"latm\", NULL, \"force MPG4-LATM transport for AAC streams\", NULL, NULL, GF_ARG_BOOL, 0),",
          "682:   GF_DEF_ARG(\"static\", NULL, \"enable static RTP payload IDs whenever possible (by default, dynamic payloads are always used)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "683:   GF_DEF_ARG(\"add-sdp\", NULL, \"add given SDP string to hint track (`tkID:string`) or movie (`string`)\", NULL, NULL, GF_ARG_STRING, 0),",
          "684:   GF_DEF_ARG(\"no-offset\", NULL, \"signal no random offset for sequence number and timestamp (support will depend on server)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "685:   GF_DEF_ARG(\"unhint\", NULL, \"remove all hinting information from file\", NULL, NULL, GF_ARG_BOOL, 0),",
          "686:   GF_DEF_ARG(\"group-single\", NULL, \"put all tracks in a single hint group\", NULL, NULL, GF_ARG_BOOL, 0),",
          "687:   GF_DEF_ARG(\"ocr\", NULL, \"force all MPEG-4 streams to be synchronized (MPEG-4 Systems only)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "688:   GF_DEF_ARG(\"rap\", NULL, \"signal random access points in RTP packets (MPEG-4 Systems)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "689:   GF_DEF_ARG(\"ts\", NULL, \"signal AU Time Stamps in RTP packets (MPEG-4 Systems)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "690:   GF_DEF_ARG(\"size\", NULL, \"signal AU size in RTP packets (MPEG-4 Systems)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "691:   GF_DEF_ARG(\"idx\", NULL, \"signal AU sequence numbers in RTP packets (MPEG-4 Systems)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "692:   GF_DEF_ARG(\"iod\", NULL, \"prevent systems tracks embedding in IOD (MPEG-4 Systems), not compatible with [-isma]()\", NULL, NULL, GF_ARG_BOOL, 0),",
          "",
          "[Added Lines]",
          "928:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_crypt_args[i];",
          "934: MP4BoxArg m4b_hint_args[] =",
          "936:   MP4BOX_ARG(\"hint\", \"hint the file for RTP/RTSP\", GF_ARG_BOOL, 0, &do_hint, 0, ARG_OPEN_EDIT),",
          "937:   {\"mtu\", NULL, \"specify RTP MTU (max size) in bytes (this includes 12 bytes RTP header)\", \"1450\", NULL, GF_ARG_INT, 0, &MTUSize, 0, 0},",
          "938:   MP4BOX_ARG(\"copy\", \"copy media data to hint track rather than reference (speeds up server but takes much more space)\", GF_ARG_BOOL, 0, &HintCopy, 0, 0),",
          "939:   MP4BOX_ARG_S(\"multi\", \"[maxptime]\", \"enable frame concatenation in RTP packets if possible (with max duration 100 ms or `maxptime` ms if given)\", 0, parse_multi_rtp, 0, ARG_IS_FUN),",
          "940:   {\"rate\", NULL, \"specify rtp rate in Hz when no default for payload\", \"90000\", NULL, GF_ARG_INT, 0, &rtp_rate, 0, 0},",
          "941:   MP4BOX_ARG(\"mpeg4\", \"force MPEG-4 generic payload whenever possible\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_MPEG4, ARG_BIT_MASK),",
          "942:   MP4BOX_ARG(\"latm\", \"force MPG4-LATM transport for AAC streams\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_USE_LATM_AAC, ARG_BIT_MASK),",
          "943:   MP4BOX_ARG(\"static\", \"enable static RTP payload IDs whenever possible (by default, dynamic payloads are always used)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_USE_STATIC_ID, ARG_BIT_MASK),",
          "944:   MP4BOX_ARG(\"add-sdp\", \"add given SDP string to hint track (`tkID:string`) or movie (`string`)\", GF_ARG_STRING, 0, parse_sdp_ext, 0, ARG_IS_FUN),",
          "945:   MP4BOX_ARG(\"no-offset\", \"signal no random offset for sequence number and timestamp (support will depend on server)\", GF_ARG_BOOL, 0, &hint_no_offset, 0, 0),",
          "946:   MP4BOX_ARG(\"unhint\", \"remove all hinting information from file\", GF_ARG_BOOL, 0, &remove_hint, 0, ARG_OPEN_EDIT),",
          "947:   MP4BOX_ARG(\"group-single\", \"put all tracks in a single hint group\", GF_ARG_BOOL, 0, &single_group, 0, 0),",
          "948:   MP4BOX_ARG(\"ocr\", \"force all MPEG-4 streams to be synchronized (MPEG-4 Systems only)\", GF_ARG_BOOL, 0, &force_ocr, 0, 0),",
          "949:   MP4BOX_ARG(\"rap\", \"signal random access points in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),",
          "950:   MP4BOX_ARG(\"ts\", \"signal AU Time Stamps in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_TS, ARG_BIT_MASK),",
          "951:  MP4BOX_ARG(\"size\", \"signal AU size in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_SIZE, ARG_BIT_MASK),",
          "952:   MP4BOX_ARG(\"idx\", \"signal AU sequence numbers in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_AU_IDX, ARG_BIT_MASK),",
          "953:   MP4BOX_ARG(\"iod\", \"prevent systems tracks embedding in IOD (MPEG-4 Systems), not compatible with [-isma]()\", GF_ARG_BOOL, 0, &regular_iod, 0, 0),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "705:   \"Options:\\n\"",
          "706:  );",
          "707:  while (m4b_hint_args[i].name) {",
          "709:   i++;",
          "710:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-hint\");",
          "711:  }",
          "712: }",
          "716: {",
          "731:   {0}",
          "732: };",
          "",
          "[Removed Lines]",
          "708:   GF_GPACArg *arg = &m4b_hint_args[i];",
          "715: GF_GPACArg m4b_extr_args[] =",
          "717:   GF_DEF_ARG(\"raw\", NULL, \"extract given track in raw format when supported. Use `tkID:output=FileName` to set output file name\", NULL, NULL, GF_ARG_STRING, 0),",
          "718:   GF_DEF_ARG(\"raws\", NULL, \"extract each sample of the given track to a file. Use `tkID:N`to extract the Nth sample\", NULL, NULL, GF_ARG_STRING, 0),",
          "719:   GF_DEF_ARG(\"nhnt\", NULL, \"extract given track to [NHNT](nhntr) format\", NULL, NULL, GF_ARG_INT, 0),",
          "720:   GF_DEF_ARG(\"nhml\", NULL, \"extract given track to [NHML](nhmlr) format. Use `tkID:full` for full NHML dump with all packet properties\", NULL, NULL, GF_ARG_STRING, 0),",
          "721:   GF_DEF_ARG(\"webvtt-raw\", NULL, \"extract given track as raw media in WebVTT as metadata. Use `tkID:embedded` to include media data in the WebVTT file\", NULL, NULL, GF_ARG_STRING, 0),",
          "722:   GF_DEF_ARG(\"single\", NULL, \"extract given track to a new mp4 file\", NULL, NULL, GF_ARG_INT, 0),",
          "723:   GF_DEF_ARG(\"six\", NULL, \"extract given track as raw media in **experimental** XML streaming instructions\", NULL, NULL, GF_ARG_INT, 0),",
          "724:   GF_DEF_ARG(\"avi\", NULL, \"extract given track to an avi file\", NULL, NULL, GF_ARG_INT, 0),",
          "725:   GF_DEF_ARG(\"avi\", NULL, \"same as [-raw]() but defaults to QCP file for EVRC/SMV\", NULL, NULL, GF_ARG_INT, 0),",
          "726:   GF_DEF_ARG(\"aviraw\", NULL, \"extract AVI track in raw format; parameter can be `video`, `audio`or `audioN`\", NULL, \"video|audio\", GF_ARG_STRING, 0),",
          "727:   GF_DEF_ARG(\"saf\", NULL, \"remux file to SAF multiplex\", NULL, NULL, GF_ARG_BOOL, 0),",
          "728:   GF_DEF_ARG(\"dvbhdemux\", NULL, \"demux DVB-H file into IP Datagrams sent on the network\", NULL, NULL, GF_ARG_BOOL, 0),",
          "729:   GF_DEF_ARG(\"raw-layer\", NULL, \"same as [-raw]() but skips SVC/MVC/LHVC extractors when extracting\", NULL, NULL, GF_ARG_INT, 0),",
          "730:   GF_DEF_ARG(\"diod\", NULL, \"extract file IOD in raw format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "",
          "[Added Lines]",
          "969:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_hint_args[i];",
          "976: MP4BoxArg m4b_extr_args[] =",
          "978:   MP4BOX_ARG(\"raw\", \"extract given track in raw format when supported. Use `tkID:output=FileName` to set output file name\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_NATIVE, ARG_IS_FUN),",
          "979:   MP4BOX_ARG(\"raws\", \"extract each sample of the given track to a file. Use `tkID:N`to extract the Nth sample\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_RAW_SAMPLES, ARG_IS_FUN),",
          "980:   MP4BOX_ARG(\"nhnt\", \"extract given track to [NHNT](nhntr) format\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NHNT, ARG_IS_FUN),",
          "981:   MP4BOX_ARG(\"nhml\", \"extract given track to [NHML](nhmlr) format. Use `tkID:full` for full NHML dump with all packet properties\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_NHML, ARG_IS_FUN),",
          "982:   MP4BOX_ARG(\"webvtt-raw\", \"extract given track as raw media in WebVTT as metadata. Use `tkID:embedded` to include media data in the WebVTT file\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_WEBVTT_META, ARG_IS_FUN),",
          "983:   MP4BOX_ARG(\"single\", \"extract given track to a new mp4 file\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_MP4, ARG_IS_FUN),",
          "984:   MP4BOX_ARG(\"six\", \"extract given track as raw media in **experimental** XML streaming instructions\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_SIX, ARG_IS_FUN),",
          "985:   MP4BOX_ARG(\"avi\", \"extract given track to an avi file\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_AVI, ARG_IS_FUN | ARG_EMPTY),",
          "986:   MP4BOX_ARG(\"qcp\", \"same as [-raw]() but defaults to QCP file for EVRC/SMV\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NATIVE | GF_EXPORT_USE_QCP, ARG_IS_FUN),",
          "987:   MP4BOX_ARG(\"aviraw\", \"extract AVI track in raw format; parameter can be `video`, `audio` or `audioN`\", GF_ARG_STRING, 0, parse_aviraw, 0, ARG_IS_FUN),",
          "988:   MP4BOX_ARG(\"saf\", \"remux file to SAF multiplex\", GF_ARG_BOOL, 0, &do_saf, 0, 0),",
          "989:   MP4BOX_ARG(\"dvbhdemux\", \"demux DVB-H file into IP Datagrams sent on the network\", GF_ARG_BOOL, 0, &dvbhdemux, 0, 0),",
          "990:   MP4BOX_ARG(\"raw-layer\", \"same as [-raw]() but skips SVC/MVC/LHVC extractors when extracting\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NATIVE | GF_EXPORT_SVC_LAYER, ARG_IS_FUN),",
          "991:   MP4BOX_ARG(\"diod\", \"extract file IOD in raw format\", GF_ARG_BOOL, 0, &dump_iod, 0, 0),",
          "992:   MP4BOX_ARG(\"mpd\", \"convert given HLS or smooth manifest (local or remote http) to MPD.  \\nWarning: This is not compatible with other DASH options and does not convert associated segments\", GF_ARG_STRING, 0, &do_mpd_conv, 0, 0),",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "740:  \"Options:\\n\"",
          "741:  );",
          "742:  while (m4b_extr_args[i].name) {",
          "744:   i++;",
          "745:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");",
          "746:  }",
          "747: }",
          "750: {",
          "799:   {0}",
          "800: };",
          "",
          "[Removed Lines]",
          "743:   GF_GPACArg *arg = &m4b_extr_args[i];",
          "749: GF_GPACArg m4b_dump_args[] =",
          "751:   GF_DEF_ARG(\"stdb\", NULL, \"dump/write to stdout and assume stdout is opened in binary mode\", NULL, NULL, GF_ARG_BOOL, 0),",
          "752:   GF_DEF_ARG(\"stdb\", NULL, \"dump/write to stdout  and try to reopen stdout in binary mode\", NULL, NULL, GF_ARG_BOOL, 0),",
          "753:   GF_DEF_ARG(\"tracks\", NULL, \"print the number of tracks on stdout\", NULL, NULL, GF_ARG_BOOL, 0),",
          "754:   GF_DEF_ARG(\"info\", NULL, \"print movie info (no parameter) or track info with specified ID\", NULL, NULL, GF_ARG_STRING, 0),",
          "755:   GF_DEF_ARG(\"infon\", NULL, \"print track info for given track number, 1 being the first track in the file\", NULL, NULL, GF_ARG_STRING, 0),",
          "756:   GF_DEF_ARG(\"diso\", NULL, \"dump IsoMedia file boxes in XML output\", NULL, NULL, GF_ARG_BOOL, 0),",
          "757:   GF_DEF_ARG(\"dxml\", NULL, \"dump IsoMedia file boxes and known track samples in XML output\", NULL, NULL, GF_ARG_BOOL, 0),",
          "758:   GF_DEF_ARG(\"disox\", NULL, \"dump IsoMedia file boxes except sample tables in XML output\", NULL, NULL, GF_ARG_BOOL, 0),",
          "759:   GF_DEF_ARG(\"keep-ods\", NULL, \"do not translate ISOM ODs and ESDs tags (debug purpose only)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "760:   GF_DEF_ARG(\"bt\", NULL, \"dump scene to BT format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "761:   GF_DEF_ARG(\"xmt\", NULL, \"dump scene to XMT format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "762:   GF_DEF_ARG(\"wrl\", NULL, \"dump scene to VRML format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "763:   GF_DEF_ARG(\"x3d\", NULL, \"dump scene to X3D XML format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "764:   GF_DEF_ARG(\"x3dc\", NULL, \"dump scene to X3D VRML format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "765:   GF_DEF_ARG(\"lsr\", NULL, \"dump scene to LASeR XML (XSR) format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "766:   GF_DEF_ARG(\"drtp\", NULL, \"dump rtp hint samples structure to XML output\", NULL, NULL, GF_ARG_BOOL, 0),",
          "767:   GF_DEF_ARG(\"dts\", NULL, \"print sample timing, size and position in file to text output\", NULL, NULL, GF_ARG_BOOL, 0),",
          "768:   GF_DEF_ARG(\"dtsx\", NULL, \"same as [-dts]() but does not print offset\", NULL, NULL, GF_ARG_BOOL, 0),",
          "769:   GF_DEF_ARG(\"dtsc\", NULL, \"same as [-dts]() but analyse each sample for duplicated dts/cts (__slow !__)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "770:   GF_DEF_ARG(\"dtsxc\", NULL, \"same as [-dtsc]() but does not print offset (__slow !__)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "771:   GF_DEF_ARG(\"dnal\", NULL, \"print NAL sample info of given track\", NULL, NULL, GF_ARG_INT, 0),",
          "772:   GF_DEF_ARG(\"dnalc\", NULL, \"print NAL sample info of given track, adding CRC for each nal\", NULL, NULL, GF_ARG_INT, 0),",
          "773:   GF_DEF_ARG(\"dnald\", NULL, \"print NAL sample info of given track without DTS and CTS info\", NULL, NULL, GF_ARG_INT, 0),",
          "774:   GF_DEF_ARG(\"dnalx\", NULL, \"print NAL sample info of given track without DTS and CTS info and adding CRC for each nal\", NULL, NULL, GF_ARG_INT, 0),",
          "775:   GF_DEF_ARG(\"sdp\", NULL, \"dump SDP description of hinted file\", NULL, NULL, GF_ARG_BOOL, 0),",
          "776:   GF_DEF_ARG(\"dsap\", NULL, \"dump DASH SAP cues (see -cues) for a given track\", NULL, NULL, GF_ARG_INT, 0),",
          "777:   GF_DEF_ARG(\"dsaps\", NULL, \"same as [-dsap]() but only print sample number\", NULL, NULL, GF_ARG_INT, 0),",
          "778:   GF_DEF_ARG(\"dsapc\", NULL, \"same as [-dsap]() but only print CTS\", NULL, NULL, GF_ARG_INT, 0),",
          "779:   GF_DEF_ARG(\"dsapd\", NULL, \"same as [-dsap]() but only print DTS, `-dsapp` to only print presentation time\", NULL, NULL, GF_ARG_INT, 0),",
          "780:   GF_DEF_ARG(\"dsapp\", NULL, \"same as [-dsap]() but only print presentation time\", NULL, NULL, GF_ARG_INT, 0),",
          "781:   GF_DEF_ARG(\"dcr\", NULL, \"dump ISMACryp samples structure to XML output\", NULL, NULL, GF_ARG_BOOL, 0),",
          "782:   GF_DEF_ARG(\"dump-cover\", NULL, \"extract cover art\", NULL, NULL, GF_ARG_BOOL, 0),",
          "783:   GF_DEF_ARG(\"dump-chap\", NULL, \"extract chapter file as TTXT format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "784:   GF_DEF_ARG(\"dump-chap-ogg\", NULL, \"extract chapter file as OGG format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "785:   GF_DEF_ARG(\"dump-chap-zoom\", NULL, \"extract chapter file as zoom format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "786:   GF_DEF_ARG(\"dump-udta `[tkID:]4cc`\", NULL, \"extract udta for the given 4CC. If `tkID` is given, dumps from UDTA of the given track ID, otherwise moov is used\", NULL, NULL, GF_ARG_STRING, 0),",
          "787:   GF_DEF_ARG(\"mergevtt\", NULL, \"merge vtt cues while dumping\", NULL, NULL, GF_ARG_BOOL, 0),",
          "788:   GF_DEF_ARG(\"ttxt\", NULL, \"convert input subtitle to GPAC TTXT format if no parameter. Otherwise, dump given text track to GPAC TTXT format\", NULL, NULL, GF_ARG_INT, 0),",
          "789:   GF_DEF_ARG(\"srt\", NULL, \"convert input subtitle to SRT format if no parameter. Otherwise, dump given text track to SRT format\", NULL, NULL, GF_ARG_BOOL, 0),",
          "790:   GF_DEF_ARG(\"rip-mpd\", NULL, \"download manifest and segments of an MPD. Does not work with live sessions\", NULL, NULL, GF_ARG_BOOL, 0),",
          "791:   GF_DEF_ARG(\"stat\", NULL, \"generate node/field statistics for scene\", NULL, NULL, GF_ARG_BOOL, 0),",
          "792:   GF_DEF_ARG(\"stats\", NULL, \"generate node/field statistics per Access Unit\", NULL, NULL, GF_ARG_BOOL, 0),",
          "793:   GF_DEF_ARG(\"statx\", NULL, \"generate node/field statistics for scene after each AU\", NULL, NULL, GF_ARG_BOOL, 0),",
          "794:   GF_DEF_ARG(\"hash\", NULL, \"generate SHA-1 Hash of the input file\", NULL, NULL, GF_ARG_BOOL, 0),",
          "795:   GF_DEF_ARG(\"comp\", NULL, \"replace with compressed version all top level box types given as parameter, formated as `orig_4cc_1=comp_4cc_1[,orig_4cc_2=comp_4cc_2]`\", NULL, NULL, GF_ARG_STRING, 0),",
          "796:   GF_DEF_ARG(\"bin\", NULL, \"convert input XML file using NHML bitstream syntax to binary\", NULL, NULL, GF_ARG_BOOL, 0),",
          "797:   GF_DEF_ARG(\"topcount\", NULL, \"print to stdout the number of top-level boxes matching box types given as parameter, formated as `4cc_1,4cc_2N`\", NULL, NULL, GF_ARG_STRING, 0),",
          "798:   GF_DEF_ARG(\"topsize\", NULL, \"print to stdout the number of bytes of top-level boxes matching types given as parameter, formated as `4cc_1,4cc_2N` or `all` for all boxes\", NULL, NULL, GF_ARG_STRING, 0),",
          "",
          "[Added Lines]",
          "1005:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_extr_args[i];",
          "1011: MP4BoxArg m4b_dump_args[] =",
          "1013:   MP4BOX_ARG(\"std\", \"dump/write to stdout and assume stdout is opened in binary mode\", GF_ARG_BOOL, 0, &dump_std, 2, 0),",
          "1014:   MP4BOX_ARG(\"stdb\", \"dump/write to stdout and try to reopen stdout in binary mode\", GF_ARG_BOOL, 0, &dump_std, 1, 0),",
          "1015:   MP4BOX_ARG(\"tracks\", \"print the number of tracks on stdout\", GF_ARG_BOOL, 0, &get_nb_tracks, 0, 0),",
          "1016:   MP4BOX_ARG(\"info\", \"print movie info (no parameter) or track info with specified ID\", GF_ARG_STRING, 0, parse_file_info, 0, ARG_IS_FUN|ARG_EMPTY),",
          "1017:   MP4BOX_ARG(\"infon\", \"print track info for given track number, 1 being the first track in the file\", GF_ARG_STRING, 0, parse_file_info, 1, ARG_IS_FUN|ARG_EMPTY),",
          "1018:   MP4BOX_ARG_ALT(\"diso\", \"dmp4\", \"dump IsoMedia file boxes in XML output\", GF_ARG_BOOL, 0, &dump_isom, 1, 0),",
          "1019:   MP4BOX_ARG(\"dxml\", \"dump IsoMedia file boxes and known track samples in XML output\", GF_ARG_BOOL, 0, &dump_isom, 2, 0),",
          "1020:   MP4BOX_ARG(\"disox\", \"dump IsoMedia file boxes except sample tables in XML output\", GF_ARG_BOOL, 0, &dump_isom, 3, 0),",
          "1021:   MP4BOX_ARG(\"keep-ods\", \"do not translate ISOM ODs and ESDs tags (debug purpose only)\", GF_ARG_BOOL, 0, &no_odf_conf, 0, 0),",
          "1022:   MP4BOX_ARG(\"bt\", \"dump scene to BT format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_BT, ARG_HAS_VALUE),",
          "1023:   MP4BOX_ARG(\"xmt\", \"dump scene to XMT format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_XMTA, 0),",
          "1024:   MP4BOX_ARG(\"wrl\", \"dump scene to VRML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_VRML, 0),",
          "1025:   MP4BOX_ARG(\"x3d\", \"dump scene to X3D XML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_X3D_XML, 0),",
          "1026:   MP4BOX_ARG(\"x3dv\", \"dump scene to X3D VRML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_X3D_VRML, 0),",
          "1027:   MP4BOX_ARG(\"lsr\", \"dump scene to LASeR XML (XSR) format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_LASER, 0),",
          "1028:   MP4BOX_ARG(\"svg\", \"dump scene to SVG\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_SVG, 0),",
          "1029:   MP4BOX_ARG(\"drtp\", \"dump rtp hint samples structure to XML output\", GF_ARG_BOOL, 0, &dump_rtp, 0, 0),",
          "1030:   MP4BOX_ARG(\"dts\", \"print sample timing, size and position in file to text output\", GF_ARG_BOOL, 0, parse_dump_ts, 0, ARG_IS_FUN),",
          "1031:   MP4BOX_ARG(\"dtsx\", \"same as [-dts]() but does not print offset\", GF_ARG_BOOL, 0, &dump_timestamps, 2, 0),",
          "1032:   MP4BOX_ARG(\"dtsc\", \"same as [-dts]() but analyse each sample for duplicated dts/cts (__slow !__)\", GF_ARG_BOOL, 0, &dump_timestamps, 3, 0),",
          "1033:   MP4BOX_ARG(\"dtsxc\", \"same as [-dtsc]() but does not print offset (__slow !__)\", GF_ARG_BOOL, 0, &dump_timestamps, 4, 0),",
          "1034:   MP4BOX_ARG(\"dnal\", \"print NAL sample info of given track\", GF_ARG_INT, 0, parse_dnal, 0, ARG_IS_FUN),",
          "1035:   MP4BOX_ARG(\"dnalc\", \"print NAL sample info of given track, adding CRC for each nal\", GF_ARG_INT, 0, parse_dnal, 1, ARG_IS_FUN),",
          "1036:   MP4BOX_ARG(\"dnald\", \"print NAL sample info of given track without DTS and CTS info\", GF_ARG_INT, 0, parse_dnal, 2, ARG_IS_FUN),",
          "1037:   MP4BOX_ARG(\"dnalx\", \"print NAL sample info of given track without DTS and CTS info and adding CRC for each nal\", GF_ARG_INT, 0, parse_dnal, 2|1, ARG_IS_FUN),",
          "1038:   MP4BOX_ARG(\"sdp\", \"dump SDP description of hinted file\", GF_ARG_BOOL, 0, &print_sdp, 0, 0),",
          "1039:   MP4BOX_ARG(\"dsap\", \"dump DASH SAP cues (see -cues) for a given track\", GF_ARG_INT, 0, parse_dsap, 0, ARG_IS_FUN),",
          "1040:   MP4BOX_ARG(\"dsaps\", \"same as [-dsap]() but only print sample number\", GF_ARG_INT, 0, parse_dsap, 1, ARG_IS_FUN),",
          "1041:   MP4BOX_ARG(\"dsapc\", \"same as [-dsap]() but only print CTS\", GF_ARG_INT, 0, parse_dsap, 2, ARG_IS_FUN),",
          "1042:   MP4BOX_ARG(\"dsapd\", \"same as [-dsap]() but only print DTS\", GF_ARG_INT, 0, parse_dsap, 3, ARG_IS_FUN),",
          "1043:   MP4BOX_ARG(\"dsapp\", \"same as [-dsap]() but only print presentation time\", GF_ARG_INT, 4, parse_dsap, 4, ARG_IS_FUN),",
          "1044:   MP4BOX_ARG(\"dcr\", \"dump ISMACryp samples structure to XML output\", GF_ARG_BOOL, 0, &dump_cr, 0, 0),",
          "1045:   MP4BOX_ARG(\"dump-cover\", \"extract cover art\", GF_ARG_BOOL, 0, &dump_cart, 0, 0),",
          "1046:   MP4BOX_ARG(\"dump-chap\", \"extract chapter file as TTXT format\", GF_ARG_BOOL, 0, &dump_chap, 1, 0),",
          "1047:   MP4BOX_ARG(\"dump-chap-ogg\", \"extract chapter file as OGG format\", GF_ARG_BOOL, 0, &dump_chap, 2, 0),",
          "1048:   MP4BOX_ARG(\"dump-chap-zoom\", \"extract chapter file as zoom format\", GF_ARG_BOOL, 0, &dump_chap, 3, 0),",
          "1049:   MP4BOX_ARG_S(\"dump-udta\", \"[tkID:]4cc\", \"extract udta for the given 4CC. If `tkID` is given, dumps from UDTA of the given track ID, otherwise moov is used\", 0, parse_dump_udta, 0, ARG_IS_FUN),",
          "1050:   MP4BOX_ARG(\"mergevtt\", \"merge vtt cues while dumping\", GF_ARG_BOOL, 0, &merge_vtt_cues, 0, 0),",
          "1051:   MP4BOX_ARG(\"ttxt\", \"convert input subtitle to GPAC TTXT format if no parameter. Otherwise, dump given text track to GPAC TTXT format\", GF_ARG_INT, 0, parse_ttxt, 0, ARG_IS_FUN),",
          "1052:   MP4BOX_ARG(\"srt\", \"convert input subtitle to SRT format if no parameter. Otherwise, dump given text track to SRT format\", GF_ARG_INT, 0, parse_ttxt, 1, ARG_IS_FUN),",
          "1053:   MP4BOX_ARG(\"stat\", \"generate node/field statistics for scene\", GF_ARG_BOOL, 0, &stat_level, 1, 0),",
          "1054:   MP4BOX_ARG(\"stats\", \"generate node/field statistics per Access Unit\", GF_ARG_BOOL, 0, &stat_level, 2, 0),",
          "1055:   MP4BOX_ARG(\"statx\", \"generate node/field statistics for scene after each AU\", GF_ARG_BOOL, 0, &stat_level, 3, 0),",
          "1056:   MP4BOX_ARG(\"hash\", \"generate SHA-1 Hash of the input file\", GF_ARG_BOOL, 0, &do_hash, 0, 0),",
          "1057:   MP4BOX_ARG(\"comp\", \"replace with compressed version all top level box types given as parameter, formated as `orig_4cc_1=comp_4cc_1[,orig_4cc_2=comp_4cc_2]`\", GF_ARG_STRING, 0, parse_comp_box, 0, ARG_IS_FUN),",
          "1058:   MP4BOX_ARG(\"topcount\", \"print to stdout the number of top-level boxes matching box types given as parameter, formated as `4cc_1,4cc_2N`\", GF_ARG_STRING, 0, parse_comp_box, 2, ARG_IS_FUN),",
          "1059:   MP4BOX_ARG(\"topsize\", \"print to stdout the number of bytes of top-level boxes matching types given as parameter, formated as `4cc_1,4cc_2N` or `all` for all boxes\", GF_ARG_STRING, 0, parse_comp_box, 1, ARG_IS_FUN),",
          "1060:   MP4BOX_ARG(\"bin\", \"convert input XML file using NHML bitstream syntax to binary\", GF_ARG_BOOL, 0, &do_bin_xml, 0, 0),",
          "1061:   MP4BOX_ARG(\"mpd-rip\", \"fetch MPD and segment to disk\", GF_ARG_BOOL, 0, &do_mpd_rip, 0, 0),",
          "1062:   MP4BOX_ARG_S(\"udp-write\", \"IP[:port]\", \"write input name to UDP (default port 2345)\", GF_FS_ARG_HINT_EXPERT, &udp_dest, 0, 0),",
          "1063:   MP4BOX_ARG(\"raw-cat\", \"raw concatenation of given file with input file\", GF_ARG_STRING, GF_FS_ARG_HINT_EXPERT, &raw_cat, 0, 0),",
          "1064:   MP4BOX_ARG(\"wget\", \"fetch ressource from http(s) URL\", GF_ARG_STRING, GF_FS_ARG_HINT_EXPERT, &do_wget, 0, 0),",
          "1065:   MP4BOX_ARG(\"dm2ts\", \"dump timing of an input MPEG-2 TS stream sample timing\", GF_ARG_BOOL, 0, &dump_m2ts, 0, 0),",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "809:  \"Options:\\n\"",
          "810:  );",
          "811:  while (m4b_dump_args[i].name) {",
          "813:   i++;",
          "814:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");",
          "815:  }",
          "816: }",
          "819: {",
          "821:   \"- tk not set: use root (file) meta\\n\"",
          "822:   \"- tkID == 0: use moov meta\\n\"",
          "825:   \"- file_path `this` or `self`: item is the file itself\\n\"",
          "826:   \"- tk=tkID: meta location (file, moov, track)\\n\"",
          "827:   \"- name=str: item name\\n\"",
          "",
          "[Removed Lines]",
          "812:   GF_GPACArg *arg = &m4b_dump_args[i];",
          "818: GF_GPACArg m4b_meta_args[] =",
          "820:   GF_DEF_ARG(\"set-meta `ABCD[:tk=tkID]`\", NULL, \"set meta box type, with `ABCD` the four char meta type (NULL or 0 to remove meta)\\n\"",
          "823:   \"- tkID != 0: use meta of given track\", NULL, NULL, GF_ARG_STRING, 0),",
          "824:   GF_DEF_ARG(\"add-item\", NULL, \"add resource to meta, with parameter syntax `file_path[:opt1:optN]`\\n\"",
          "",
          "[Added Lines]",
          "1079:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_dump_args[i];",
          "1085: MP4BoxArg m4b_meta_args[] =",
          "1087:   MP4BOX_ARG_S(\"set-meta\", \"ABCD[:tk=tkID]\", \"set meta box type, with `ABCD` the four char meta type (NULL or 0 to remove meta)\\n\"",
          "1090:   \"- tkID != 0: use meta of given track\", 0, parse_meta_args, META_ACTION_SET_TYPE, ARG_IS_FUN),",
          "1091:   MP4BOX_ARG(\"add-item\", \"add resource to meta, with parameter syntax `file_path[:opt1:optN]`\\n\"",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "831:   \"- id=ID: item ID\\n\"",
          "832:   \"- ref=4cc,id: reference of type 4cc to an other item (can be set multiple times)\\n\"",
          "833:   \"- group=id,type: indicate the id and type of an alternate group for this item\"",
          "836:   \"- name, id, ref: see [-add-item]()\\n\"",
          "837:   \"- primary: indicate that this item should be the primary item\\n\"",
          "838:   \"- time=t[-e][/i]: use the next sync sample after time t (float, in sec, default 0). A negative time imports ALL intra frames as items\\n\"",
          "",
          "[Removed Lines]",
          "834:   , NULL, NULL, GF_ARG_STRING, 0),",
          "835:  GF_DEF_ARG(\"add-image\", NULL, \"add the given file as HEIF image item, with parameter syntax `file_path[:opt1:optN]`. If `filepath` is omitted, source is the input MP4 file\\n\"",
          "",
          "[Added Lines]",
          "1101:   , GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_ITEM, ARG_IS_FUN),",
          "1102:  MP4BOX_ARG(\"add-image\", \"add the given file as HEIF image item, with parameter syntax `file_path[:opt1:optN]`. If `filepath` is omitted, source is the input MP4 file\\n\"",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "851:   \"- ref: do not copy the data but refer to the final sample location\\n\"",
          "852:   \"- agrid[=AR]: creates an automatic grid from the image items present in the file, in their declaration order. The grid will **try to** have `AR` aspect ratio if specified (float), or the aspect ratio of the source otherwise. The grid will be the primary item and all other images will be hidden\\n\"",
          "853:   \"- any other options will be passed as options to the media importer, see [-add]()\"",
          "856:   \"- image-grid-size=rxc: set the number of rows and colums of the grid\\n\"",
          "866:  {0}",
          "867: };",
          "",
          "[Removed Lines]",
          "854:   , NULL, NULL, GF_ARG_STRING, 0),",
          "855:  GF_DEF_ARG(\"add-image-grid\", NULL, \"create an image grid item, with parameter syntax `grid[:opt1:optN]`\\n\"",
          "857:      \"- any other options from [-add-image]() can be used\\n\", NULL, NULL, GF_ARG_STRING, 0),",
          "858:  GF_DEF_ARG(\"rem-item `item_ID[:tk=tkID]`\", NULL, \"remove resource from meta\", NULL, NULL, GF_ARG_STRING, 0),",
          "859:  GF_DEF_ARG(\"set-primary `item_ID[:tk=tkID]`\", NULL, \"set item as primary for meta\", NULL, NULL, GF_ARG_STRING, 0),",
          "860:  GF_DEF_ARG(\"set-xml `xml_file_path[:tk=tkID][:binary]`\", NULL, \"set meta XML data\", NULL, NULL, GF_ARG_STRING, 0),",
          "861:  GF_DEF_ARG(\"rem-xml `[tk=tkID]`\", NULL, \"remove meta XML data\", NULL, NULL, GF_ARG_STRING, 0),",
          "862:  GF_DEF_ARG(\"dump-xml `file_path[:tk=tkID]`\", NULL, \"dump meta XML to file\", NULL, NULL, GF_ARG_STRING, 0),",
          "863:  GF_DEF_ARG(\"dump-item `item_ID[:tk=tkID][:path=fileName]`\", NULL, \"dump item to file\", NULL, NULL, GF_ARG_STRING, 0),",
          "864:  GF_DEF_ARG(\"package\", NULL, \"package input XML file into an ISO container, all media referenced except hyperlinks are added to file\", NULL, NULL, GF_ARG_STRING, 0),",
          "865:  GF_DEF_ARG(\"package\", NULL, \"package input XML file into an MPEG-U widget with ISO container, all files contained in the current folder are added to the widget package\", NULL, NULL, GF_ARG_STRING, 0),",
          "",
          "[Added Lines]",
          "1121:   , GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_IMAGE_ITEM, ARG_IS_FUN),",
          "1122:  MP4BOX_ARG(\"add-image-grid\", \"create an image grid item, with parameter syntax `grid[:opt1:optN]`\\n\"",
          "1124:      \"- any other options from [-add-image]() can be used\\n\", GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_IMAGE_GRID, ARG_IS_FUN),",
          "1125:  MP4BOX_ARG_S(\"rem-item\", \"item_ID[:tk=tkID]\", \"remove resource from meta\", 0, parse_meta_args, META_ACTION_REM_ITEM, ARG_IS_FUN),",
          "1126:  MP4BOX_ARG_S(\"set-primary\", \"item_ID[:tk=tkID]\", \"set item as primary for meta\", 0, parse_meta_args, META_ACTION_SET_PRIMARY_ITEM, ARG_IS_FUN),",
          "1127:  MP4BOX_ARG_S(\"set-xml\", \"xml_file_path[:tk=tkID][:binary]\", \"set meta XML data\", 0, parse_meta_args, META_ACTION_SET_XML, ARG_IS_FUN),",
          "1128:  MP4BOX_ARG_S(\"rem-xml\", \"[tk=tkID]\", \"remove meta XML data\", 0, parse_meta_args, META_ACTION_REM_XML, ARG_IS_FUN),",
          "1129:  MP4BOX_ARG_S(\"dump-xml\", \"file_path[:tk=tkID]\", \"dump meta XML to file\", 0, parse_meta_args, META_ACTION_DUMP_XML, ARG_IS_FUN),",
          "1130:  MP4BOX_ARG_S(\"dump-item\", \"item_ID[:tk=tkID][:path=fileName]\", \"dump item to file\", 0, parse_meta_args, META_ACTION_DUMP_ITEM, ARG_IS_FUN),",
          "1131:  MP4BOX_ARG(\"package\", \"package input XML file into an ISO container, all media referenced except hyperlinks are added to file\", GF_ARG_STRING, 0, &pack_file, 0, 0),",
          "1132:  MP4BOX_ARG(\"mgt\", \"package input XML file into an MPEG-U widget with ISO container, all files contained in the current folder are added to the widget package\", GF_ARG_STRING, 0, parse_mpegu, 0, ARG_IS_FUN),",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "875:  \"These information can be stored at the file root level, as is the case for HEIF/IFF and MPEG-21 file formats, or at the moovie or track level for a regular movie.\"",
          "876:  \"  \\n  \\n\");",
          "877:  while (m4b_meta_args[i].name) {",
          "879:   i++;",
          "880:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");",
          "881:  }",
          "882: }",
          "885: {",
          "895:  {0}",
          "896: };",
          "",
          "[Removed Lines]",
          "878:   GF_GPACArg *arg = &m4b_meta_args[i];",
          "884: GF_GPACArg m4b_swf_args[] =",
          "886:   GF_DEF_ARG(\"global\", NULL, \"all SWF defines are placed in first scene replace rather than when needed\", NULL, NULL, GF_ARG_BOOL, 0),",
          "887:   GF_DEF_ARG(\"no-ctrl\", NULL, \"use a single stream for movie control and dictionary (this will disable ActionScript)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "888:   GF_DEF_ARG(\"no-text\", NULL, \"remove all SWF text\", NULL, NULL, GF_ARG_BOOL, 0),",
          "889:   GF_DEF_ARG(\"no-font\", NULL, \"remove all embedded SWF Fonts (local playback host fonts used)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "890:   GF_DEF_ARG(\"no-line\", NULL, \"remove all lines from SWF shapes\", NULL, NULL, GF_ARG_BOOL, 0),",
          "891:   GF_DEF_ARG(\"no-grad\", NULL, \"remove all gradients from swf shapes\", NULL, NULL, GF_ARG_BOOL, 0),",
          "892:   GF_DEF_ARG(\"quad\", NULL, \"use quadratic bezier curves instead of cubic ones\", NULL, NULL, GF_ARG_BOOL, 0),",
          "893:   GF_DEF_ARG(\"xlp\", NULL, \"support for lines transparency and scalability\", NULL, NULL, GF_ARG_BOOL, 0),",
          "894:   GF_DEF_ARG(\"flatten\", NULL, \"complementary angle below which 2 lines are merged, value `0`means no flattening\", NULL, NULL, GF_ARG_DOUBLE, 0),",
          "",
          "[Added Lines]",
          "1145:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_meta_args[i];",
          "1151: MP4BoxArg m4b_swf_args[] =",
          "1153:   MP4BOX_ARG(\"global\", \"all SWF defines are placed in first scene replace rather than when needed\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_STATIC_DICT, ARG_BIT_MASK),",
          "1154:   MP4BOX_ARG(\"no-ctrl\", \"use a single stream for movie control and dictionary (this will disable ActionScript)\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_SPLIT_TIMELINE, ARG_BIT_MASK_REM),",
          "1155:   MP4BOX_ARG(\"no-text\", \"remove all SWF text\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_TEXT, ARG_BIT_MASK),",
          "1156:   MP4BOX_ARG(\"no-font\", \"remove all embedded SWF Fonts (local playback host fonts used)\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_FONT, ARG_BIT_MASK),",
          "1157:   MP4BOX_ARG(\"no-line\", \"remove all lines from SWF shapes\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_LINE, ARG_BIT_MASK),",
          "1158:   MP4BOX_ARG(\"no-grad\", \"remove all gradients from swf shapes\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_GRADIENT, ARG_BIT_MASK),",
          "1159:   MP4BOX_ARG(\"quad\", \"use quadratic bezier curves instead of cubic ones\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_QUAD_CURVE, ARG_BIT_MASK),",
          "1160:   MP4BOX_ARG(\"xlp\", \"support for lines transparency and scalability\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_SCALABLE_LINE, ARG_BIT_MASK),",
          "1161:  MP4BOX_ARG(\"ic2d\", \"use indexed curve 2D hardcoded proto\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_USE_IC2D, ARG_BIT_MASK),",
          "1162:  MP4BOX_ARG(\"same-app\", \"appearance nodes are reused\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_REUSE_APPEARANCE, ARG_BIT_MASK),",
          "1163:   MP4BOX_ARG(\"flatten\", \"complementary angle below which 2 lines are merged, value `0`means no flattening\", GF_ARG_DOUBLE, 0, &swf_flatten_angle, 0, 0),",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "906:          \"Options:\\n\"",
          "907:  );",
          "908:  while (m4b_swf_args[i].name) {",
          "910:   i++;",
          "911:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");",
          "912:  }",
          "913: }",
          "916: {",
          "917:   GF_DEF_ARG(\"dst\", NULL, \"destination IP\", NULL, NULL, GF_ARG_STRING, 0),",
          "918:   GF_DEF_ARG(\"port\", NULL, \"destination port\", \"7000\", NULL, GF_ARG_INT, 0),",
          "919:   GF_DEF_ARG(\"mtu\", NULL, \"path MTU for RTP packets\", \"1450\", NULL, GF_ARG_INT, 0),",
          "",
          "[Removed Lines]",
          "909:   GF_GPACArg *arg = &m4b_swf_args[i];",
          "915: GF_GPACArg m4b_liveenc_args[] =",
          "",
          "[Added Lines]",
          "1178:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_swf_args[i];",
          "1184: MP4BoxArg m4b_liveenc_args[] =",
          "1186:   MP4BOX_ARG(\"live\", \"enable live BIFS/LASeR encoder\", GF_ARG_BOOL, 0, &live_scene, 0, 0),",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "936:          \"\\n\"",
          "937:  );",
          "938:  while (m4b_liveenc_args[i].name) {",
          "940:   i++;",
          "941:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");",
          "942:  }",
          "",
          "[Removed Lines]",
          "939:   GF_GPACArg *arg = &m4b_liveenc_args[i];",
          "",
          "[Added Lines]",
          "1209:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_liveenc_args[i];",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1036:  }",
          "1037: }",
          "1040: {",
          "1042:    \"- general: general options help\\n\"",
          "1043:   \"- hint: hinting options help\\n\"",
          "1044:   \"- dash: DASH segmenter help\\n\"",
          "",
          "[Removed Lines]",
          "1039: GF_GPACArg m4b_usage_args[] =",
          "1041:   GF_DEF_ARG(\"h\", NULL, \"print help\\n\"",
          "",
          "[Added Lines]",
          "1309: MP4BoxArg m4b_usage_args[] =",
          "1311:   MP4BOX_ARG(\"h\", \"print help\\n\"",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1058:   \"- tags: print supported iTunes tags\\n\"",
          "1059:   \"- cicp: print various CICP code points\\n\"",
          "1060:   \"- VAL: search for option named `VAL` (without `-` or `--`) in MP4Box, libgpac core and all filters\\n\"",
          "1076:   {0}",
          "1077: };",
          "",
          "[Removed Lines]",
          "1061:   , NULL, NULL, GF_ARG_STRING, 0),",
          "1062:   GF_DEF_ARG(\"hx\", NULL, \"look for given string in all possible options\"",
          "1063:   , NULL, NULL, GF_ARG_STRING, 0),",
          "1064:   GF_DEF_ARG(\"nodes\", NULL, \"list supported MPEG4 nodes\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1065:   GF_DEF_ARG(\"node\", NULL, \"get given MPEG4 node syntax and QP infolist\", NULL, NULL, GF_ARG_STRING, 0),",
          "1066:   GF_DEF_ARG(\"xnodes\", NULL, \"list supported X3D nodes\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1067:   GF_DEF_ARG(\"xnode\", NULL, \"get given X3D node syntax\", NULL, NULL, GF_ARG_STRING, 0),",
          "1068:   GF_DEF_ARG(\"snodes\", NULL, \"list supported SVG nodes\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1069:   GF_DEF_ARG(\"languages\", NULL, \"list supported ISO 639 languages\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1070:   GF_DEF_ARG(\"boxes\", NULL, \"list all supported ISOBMF boxes and their syntax\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1071:   GF_DEF_ARG(\"fstat\", NULL, \"print filter session statistics (import/export/encrypt/decrypt/dashing)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1072:   GF_DEF_ARG(\"fgraph\", NULL, \"print filter session graph (import/export/encrypt/decrypt/dashing)\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1073:   GF_DEF_ARG(\"v\", NULL, \"verbose mode\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1074:   GF_DEF_ARG(\"version\", NULL, \"get build version\", NULL, NULL, GF_ARG_BOOL, 0),",
          "1075:   GF_DEF_ARG(\"-- INPUT\", NULL, \"escape option if INPUT starts with `-` character\", NULL, NULL, GF_ARG_BOOL, 0),",
          "",
          "[Added Lines]",
          "1331:   , GF_ARG_STRING, 0, parse_help, 0, ARG_IS_FUN | ARG_EMPTY | ARG_PUSH_SYSARGS),",
          "1332:   MP4BOX_ARG(\"hx\", \"look for given string in all possible options\"",
          "1333:   , GF_ARG_STRING, 0, parse_help, 1, ARG_IS_FUN),",
          "1334:   MP4BOX_ARG(\"nodes\", \"list supported MPEG4 nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 0, ARG_IS_FUN),",
          "1335:   MP4BOX_ARG(\"nodex\", \"list supported MPEG4 nodes and print nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 1, ARG_IS_FUN),",
          "1336:   MP4BOX_ARG(\"node\", \"get given MPEG4 node syntax and QP infolist\", GF_ARG_STRING, 0, PrintNode, 0, ARG_IS_FUN),",
          "1337:   MP4BOX_ARG(\"xnodes\", \"list supported X3D nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 2, ARG_IS_FUN),",
          "1338:   MP4BOX_ARG(\"xnodex\", \"list supported X3D nodes and print nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 3, ARG_IS_FUN),",
          "1339:   MP4BOX_ARG(\"xnode\", \"get given X3D node syntax\", GF_ARG_STRING, 0, PrintNode, 1, ARG_IS_FUN),",
          "1340:   MP4BOX_ARG(\"snodes\", \"list supported SVG nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 4, ARG_IS_FUN),",
          "1341:   MP4BOX_ARG(\"languages\", \"list supported ISO 639 languages\", GF_ARG_BOOL, 0, PrintLanguages, 0, ARG_IS_FUN),",
          "1342:   MP4BOX_ARG(\"boxes\", \"list all supported ISOBMF boxes and their syntax\", GF_ARG_BOOL, 0, PrintBuiltInBoxes, 0, ARG_IS_FUN),",
          "1343:   MP4BOX_ARG(\"boxcov\", \"perform coverage of box IO coode\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, PrintBuiltInBoxes, 1, ARG_IS_FUN|ARG_PUSH_SYSARGS),",
          "1344:   MP4BOX_ARG(\"fstat\", \"print filter session statistics (import/export/encrypt/decrypt/dashing)\", GF_ARG_BOOL, 0, &fs_dump_flags, 1, ARG_BIT_MASK),",
          "1345:   MP4BOX_ARG(\"fgraph\", \"print filter session graph (import/export/encrypt/decrypt/dashing)\", GF_ARG_BOOL, 0, &fs_dump_flags, 2, ARG_BIT_MASK),",
          "1346:   MP4BOX_ARG(\"v\", \"verbose mode\", GF_ARG_BOOL, 0, &verbose, 0, ARG_INT_INC),",
          "1347:   MP4BOX_ARG(\"version\", \"get build version\", GF_ARG_BOOL, 0, print_version, 0, ARG_IS_FUN),",
          "1348:   MP4BOX_ARG(\"genmd\", \"generate MD doc\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, parse_gendoc, 0, ARG_IS_FUN),",
          "1349:   MP4BOX_ARG(\"genman\", \"generate man doc\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, parse_gendoc, 1, ARG_IS_FUN),",
          "1350:   MP4BOX_ARG_S(\"--\", \"INPUT\", \"escape option if INPUT starts with `-` character\", 0, NULL, 0, 0),",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1084:   \"# General Options:\\n\"",
          "1085:  );",
          "1086:  while (m4b_usage_args[i].name) {",
          "1088:   i++;",
          "1089:   gf_sys_print_arg(helpout, help_flags, arg, \"mp4box-general\");",
          "1090:  }",
          "1091: }",
          "1093: enum",
          "1094: {",
          "1095:  SEARCH_ARG_EXACT,",
          "",
          "[Removed Lines]",
          "1087:   GF_GPACArg *arg = &m4b_usage_args[i];",
          "",
          "[Added Lines]",
          "1362:   GF_GPACArg *arg = (GF_GPACArg *) &m4b_usage_args[i];",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1124:   GF_GPACArg an_arg;",
          "1125:   Bool do_match = GF_FALSE;",
          "1128:    flags = GF_PRINTARG_COLON;",
          "1129:    if (!strncmp(arg_name, arg->name, alen) && ((arg->name[alen]==0) || (arg->name[alen]=='=')))",
          "1130:     do_match = GF_TRUE;",
          "",
          "[Removed Lines]",
          "1127:   if (args==m4b_imp_fileopt_args) {",
          "",
          "[Added Lines]",
          "1407:   if (args == (GF_GPACArg *) m4b_imp_fileopt_args) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1168:  u32 i, count;",
          "1169:  u32 res = 0;",
          "1170:  u32 alen = (u32) strlen(arg_name);",
          "1185:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) gf_sys_get_options(), search_type);",
          "1187:  if (!fs) return res;",
          "",
          "[Removed Lines]",
          "1171:  res += PrintHelpForArgs(arg_name, m4b_gen_args, search_type);",
          "1172:  res += PrintHelpForArgs(arg_name, m4b_split_args, search_type);",
          "1173:  res += PrintHelpForArgs(arg_name, m4b_dash_args, search_type);",
          "1174:  res += PrintHelpForArgs(arg_name, m4b_imp_args, search_type);",
          "1175:  res += PrintHelpForArgs(arg_name, m4b_imp_fileopt_args, search_type);",
          "1176:  res += PrintHelpForArgs(arg_name, m4b_senc_args, search_type);",
          "1177:  res += PrintHelpForArgs(arg_name, m4b_crypt_args, search_type);",
          "1178:  res += PrintHelpForArgs(arg_name, m4b_hint_args, search_type);",
          "1179:  res += PrintHelpForArgs(arg_name, m4b_extr_args, search_type);",
          "1180:  res += PrintHelpForArgs(arg_name, m4b_dump_args, search_type);",
          "1181:  res += PrintHelpForArgs(arg_name, m4b_meta_args, search_type);",
          "1182:  res += PrintHelpForArgs(arg_name, m4b_swf_args, search_type);",
          "1183:  res += PrintHelpForArgs(arg_name, m4b_liveenc_args, search_type);",
          "1184:  res += PrintHelpForArgs(arg_name, m4b_usage_args, search_type);",
          "",
          "[Added Lines]",
          "1451:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_gen_args, search_type);",
          "1452:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_split_args, search_type);",
          "1453:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_dash_args, search_type);",
          "1454:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_imp_args, search_type);",
          "1455:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_imp_fileopt_args, search_type);",
          "1456:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_senc_args, search_type);",
          "1457:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_crypt_args, search_type);",
          "1458:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_hint_args, search_type);",
          "1459:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_extr_args, search_type);",
          "1460:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_dump_args, search_type);",
          "1461:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_meta_args, search_type);",
          "1462:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_swf_args, search_type);",
          "1463:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_liveenc_args, search_type);",
          "1464:  res += PrintHelpForArgs(arg_name, (GF_GPACArg *) m4b_usage_args, search_type);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1279:   gf_fs_del(fs);",
          "1280: }",
          "1297: {",
          "1315:   }",
          "1316:  }",
          "1317: }",
          "1323: {",
          "1381:    }",
          "1399:    }",
          "1406:   }",
          "1414:   }",
          "1425:    }",
          "1428:   }",
          "1443:    }",
          "1444:   }",
          "1453:    }",
          "1455:   }",
          "1482:   }",
          "1522:   }",
          "1535:   }",
          "1819:   }",
          "1821:   else if (!stricmp(szSlot, \"ref\")) {",
          "1822:    if (!meta->image_props) {",
          "1823:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1825:    }",
          "1826:    meta->image_props->use_reference = GF_TRUE;",
          "1828:   }",
          "1829:   else if (!strnicmp(szSlot, \"time=\", 5)) {",
          "1830:    Float s=0, e=0, step=0;",
          "1831:    if (!meta->image_props) {",
          "1832:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1834:    }",
          "1835:    if (sscanf(szSlot+5, \"%f-%f/%f\", &s, &e, &step)==3) {",
          "1836:     meta->image_props->time = s;",
          "1837:     meta->image_props->end_time = e;",
          "1838:     meta->image_props->step_time = step;",
          "1840:    } else if (sscanf(szSlot+5, \"%f-%f\", &s, &e)==2) {",
          "1841:     meta->image_props->time = s;",
          "1842:     meta->image_props->end_time = e;",
          "1844:    } else if (sscanf(szSlot+5, \"%f/%f\", &s, &step)==2) {",
          "1845:     meta->image_props->time = s;",
          "1846:     meta->image_props->step_time = step;",
          "1848:    } else if (sscanf(szSlot+5, \"%f\", &s)==1) {",
          "1849:     meta->image_props->time = s;",
          "1851:    }",
          "1852:   }",
          "1853:   else if (!strnicmp(szSlot, \"samp=\", 5)) {",
          "1854:    if (!meta->image_props) {",
          "1855:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1857:    }",
          "1858:    meta->image_props->sample_num = atoi(szSlot+5);",
          "1859:    meta->root_meta = 1;",
          "1861:   }",
          "1862:   else if (!strnicmp(szSlot, \"group=\", 6)) {",
          "1863:    char type[5];",
          "1864:    sscanf(szSlot, \"group=%4s,%u\", type, &meta->group_id);",
          "1865:    meta->group_type = GF_4CC(type[0], type[1], type[2], type[3]);",
          "1867:   }",
          "1868:   else if (!stricmp(szSlot, \"split_tiles\")) {",
          "1869:    if (!meta->image_props) {",
          "1870:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1872:    }",
          "1873:    meta->image_props->tile_mode = TILE_ITEM_ALL_BASE;",
          "1875:   }",
          "1876:   else if (!stricmp(szSlot, \"dref\")) {",
          "1877:    meta->use_dref = 1;",
          "1879:   }",
          "1880:   else if (!stricmp(szSlot, \"primary\")) {",
          "1881:    meta->primary = 1;",
          "1883:   }",
          "1884:   else if (!stricmp(szSlot, \"binary\")) {",
          "1885:    if (meta->act_type==META_ACTION_SET_XML) meta->act_type=META_ACTION_SET_BINARY_XML;",
          "1887:   }",
          "1888:   else if (!strnicmp(szSlot, \"icc_path=\", 9)) {",
          "1889:    if (!meta->image_props) {",
          "1890:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1892:    }",
          "1893:    strcpy(meta->image_props->iccPath, szSlot+9);",
          "1895:   }",
          "1896:   else if (!stricmp(szSlot, \"agrid\") || !strnicmp(szSlot, \"agrid=\", 6)) {",
          "1897:    if (!meta->image_props) {",
          "1898:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1900:    }",
          "1901:    meta->image_props->auto_grid = GF_TRUE;",
          "1902:    if (!strnicmp(szSlot, \"agrid=\", 6))",
          "1903:     meta->image_props->auto_grid_ratio = atof(szSlot+6);",
          "1905:   }",
          "1906:   else if (!strchr(szSlot, '=')) {",
          "1907:    switch (meta->act_type) {",
          "1908:    case META_ACTION_SET_TYPE:",
          "1909:     if (!stricmp(szSlot, \"null\") || !stricmp(szSlot, \"0\")) meta->meta_4cc = 0;",
          "1910:     else meta->meta_4cc = GF_4CC(szSlot[0], szSlot[1], szSlot[2], szSlot[3]);",
          "1912:     break;",
          "1913:    case META_ACTION_ADD_ITEM:",
          "1914:    case META_ACTION_ADD_IMAGE_ITEM:",
          "",
          "[Removed Lines]",
          "1282: void scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist)",
          "1283: {",
          "1284:  FILE *logs = cbk;",
          "1285:  if (log_tool != GF_LOG_CODING) return;",
          "1286:  vfprintf(logs, fmt, vlist);",
          "1287:  fflush(logs);",
          "1288: }",
          "1290: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "1293:   MP4 File Hinting",
          "1296: void SetupClockReferences(GF_ISOFile *file)",
          "1298:  u32 i, count, ocr_id;",
          "1299:  count = gf_isom_get_track_count(file);",
          "1300:  if (count==1) return;",
          "1301:  ocr_id = 0;",
          "1302:  for (i=0; i<count; i++) {",
          "1303:   if (!gf_isom_is_track_in_root_od(file, i+1)) continue;",
          "1304:   ocr_id = gf_isom_get_track_id(file, i+1);",
          "1305:   break;",
          "1306:  }",
          "1308:  if (!ocr_id) return;",
          "1309:  for (i=0; i<count; i++) {",
          "1310:   GF_ESD *esd = gf_isom_get_esd(file, i+1, 1);",
          "1311:   if (esd) {",
          "1312:    esd->OCRESID = ocr_id;",
          "1313:    gf_isom_change_mpeg4_description(file, i+1, 1, esd);",
          "1314:    gf_odf_desc_del((GF_Descriptor *) esd);",
          "1320: #define BASE_PAYT  96",
          "1322: GF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)",
          "1324:  GF_ESD *esd;",
          "1325:  GF_InitialObjectDescriptor *iod;",
          "1326:  u32 i, val, res, streamType;",
          "1327:  u32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;",
          "1328:  GF_Err e;",
          "1329:  char szPayload[30];",
          "1330:  GF_RTPHinter *hinter;",
          "1331:  Bool copy, has_iod, single_av;",
          "1332:  u8 init_payt = BASE_PAYT;",
          "1333:  u32 mtype;",
          "1334:  GF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;",
          "1335:  u32 media_group = 0;",
          "1336:  u8 media_prio = 0;",
          "1338:  tot_bw = 0;",
          "1339:  prev_ocr = 0;",
          "1340:  single_ocr = 1;",
          "1342:  has_iod = 1;",
          "1343:  iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);",
          "1344:  if (!iod) has_iod = 0;",
          "1345:  else {",
          "1346:   if (!gf_list_count(iod->ESDescriptors)) has_iod = 0;",
          "1347:   gf_odf_desc_del((GF_Descriptor *) iod);",
          "1348:  }",
          "1350:  spec_type = gf_isom_guess_specification(file);",
          "1351:  single_av = single_group ? 1 : gf_isom_is_single_av(file);",
          "1354:  for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "1355:   res = gf_isom_get_media_type(file, i+1);",
          "1356:   if ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {",
          "1357:    if (gf_isom_is_track_in_root_od(file, i+1)) {",
          "1358:     gf_isom_set_default_sync_track(file, i+1);",
          "1359:     break;",
          "1360:    }",
          "1361:   }",
          "1362:  }",
          "1364:  nb_done = 0;",
          "1365:  for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "1366:   sl_mode = base_flags;",
          "1367:   copy = copy_data;",
          "1369:   if (!gf_isom_get_sample_count(file, i+1)) continue;",
          "1370:   if (!gf_isom_is_track_enabled(file, i+1)) {",
          "1371:    fprintf(stderr, \"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) );",
          "1372:    continue;",
          "1373:   }",
          "1375:   mtype = gf_isom_get_media_type(file, i+1);",
          "1376:   switch (mtype) {",
          "1377:   case GF_ISOM_MEDIA_VISUAL:",
          "1378:    if (single_av) {",
          "1379:     media_group = 2;",
          "1380:     media_prio = 2;",
          "1382:    break;",
          "1383:         case GF_ISOM_MEDIA_AUXV:",
          "1384:             if (single_av) {",
          "1385:                 media_group = 2;",
          "1386:                 media_prio = 3;",
          "1387:             }",
          "1388:             break;",
          "1389:         case GF_ISOM_MEDIA_PICT:",
          "1390:             if (single_av) {",
          "1391:                 media_group = 2;",
          "1392:                 media_prio = 4;",
          "1393:             }",
          "1394:             break;",
          "1395:   case GF_ISOM_MEDIA_AUDIO:",
          "1396:    if (single_av) {",
          "1397:     media_group = 2;",
          "1398:     media_prio = 1;",
          "1400:    break;",
          "1401:   case GF_ISOM_MEDIA_HINT:",
          "1402:    continue;",
          "1403:   default:",
          "1405:    if (spec_type==GF_ISOM_BRAND_ISMA) continue;",
          "1407:   mtype = gf_isom_get_media_subtype(file, i+1, 1);",
          "1408:   if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);",
          "1410:   if (!single_av) {",
          "1412:    media_group ++;",
          "1413:    media_prio = 1;",
          "1416:   streamType = 0;",
          "1417:   esd = gf_isom_get_esd(file, i+1, 1);",
          "1418:   if (esd) {",
          "1419:    streamType = esd->decoderConfig->streamType;",
          "1420:    if (!prev_ocr) {",
          "1421:     prev_ocr = esd->OCRESID;",
          "1422:     if (!esd->OCRESID) prev_ocr = esd->ESID;",
          "1423:    } else if (esd->OCRESID && prev_ocr != esd->OCRESID) {",
          "1424:     single_ocr = 0;",
          "1427:    if (streamType==1) copy = 1;",
          "1429:   gf_odf_desc_del((GF_Descriptor *) esd);",
          "1431:   if (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {",
          "1433:    if (gf_isom_get_sample_count(file, i+1)==1) {",
          "1434:     GF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);",
          "1435:     if (streamType) {",
          "1436:      res = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);",
          "1437:     } else {",
          "1439:      res = 0;",
          "1440:     }",
          "1441:     if (samp) gf_isom_sample_del(&samp);",
          "1442:     if (res) continue;",
          "1445:   if (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;",
          "1447:   hinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);",
          "1449:   if (!hinter) {",
          "1450:    if (e) {",
          "1451:     fprintf(stderr, \"Cannot create hinter (%s)\\n\", gf_error_to_string(e));",
          "1452:     if (!nb_done) return e;",
          "1454:    continue;",
          "1457:   if (hint_no_offset)",
          "1458:    gf_hinter_track_force_no_offsets(hinter);",
          "1460:   bw = gf_hinter_track_get_bandwidth(hinter);",
          "1461:   tot_bw += bw;",
          "1462:   flags = gf_hinter_track_get_flags(hinter);",
          "1465:   gf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);",
          "1467:   gf_hinter_track_get_payload_name(hinter, szPayload);",
          "1468:   fprintf(stderr, \"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw);",
          "1469:   if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) fprintf(stderr, \"\\tMPEG-4 Systems stream carousel enabled\\n\");",
          "1471:     if (flags & GP_RTP_PCK_FORCE_MPEG4) fprintf(stderr, \"\\tMPEG4 transport forced\\n\");",
          "1472:     if (flags & GP_RTP_PCK_USE_MULTI) fprintf(stderr, \"\\tRTP aggregation enabled\\n\");",
          "1474:   e = gf_hinter_track_process(hinter);",
          "1476:   if (!e) e = gf_hinter_track_finalize(hinter, has_iod);",
          "1477:   gf_hinter_track_del(hinter);",
          "1479:   if (e) {",
          "1480:    fprintf(stderr, \"Error while hinting (%s)\\n\", gf_error_to_string(e));",
          "1481:    if (!nb_done) return e;",
          "1483:   init_payt++;",
          "1484:   nb_done ++;",
          "1485:  }",
          "1487:  if (has_iod) {",
          "1488:   iod_mode = GF_SDP_IOD_ISMA;",
          "1489:   if (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;",
          "1490:  } else {",
          "1491:   iod_mode = GF_SDP_IOD_NONE;",
          "1492:  }",
          "1493:  gf_hinter_finalize(file, iod_mode, tot_bw);",
          "1495:  if (!single_ocr)",
          "1496:   fprintf(stderr, \"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\");",
          "1498:  return GF_OK;",
          "1499: }",
          "1503: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_AV_PARSERS)",
          "1505: static void check_media_profile(GF_ISOFile *file, u32 track)",
          "1506: {",
          "1507:  u8 PL;",
          "1508:  GF_ESD *esd = gf_isom_get_esd(file, track, 1);",
          "1509:  if (!esd) return;",
          "1511:  switch (esd->decoderConfig->streamType) {",
          "1512:  case 0x04:",
          "1513:   PL = gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL);",
          "1514:   if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {",
          "1515:    GF_M4VDecSpecInfo vdsi;",
          "1516:    gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &vdsi);",
          "1517:    if (vdsi.VideoPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, vdsi.VideoPL);",
          "1518:   } else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {",
          "1519:    gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0x15);",
          "1520:   } else if (!PL) {",
          "1521:    gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFE);",
          "1523:   break;",
          "1524:  case 0x05:",
          "1525:   PL = gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO);",
          "1526:   switch (esd->decoderConfig->objectTypeIndication) {",
          "1527:   case GF_CODECID_AAC_MPEG2_MP:",
          "1528:   case GF_CODECID_AAC_MPEG2_LCP:",
          "1529:   case GF_CODECID_AAC_MPEG2_SSRP:",
          "1530:   case GF_CODECID_AAC_MPEG4:",
          "1531:   {",
          "1532:    GF_M4ADecSpecInfo adsi;",
          "1533:    gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &adsi);",
          "1534:    if (adsi.audioPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, adsi.audioPL);",
          "1536:    break;",
          "1537:   default:",
          "1538:    if (!PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFE);",
          "1539:   }",
          "1540:   break;",
          "1541:  }",
          "1542:  gf_odf_desc_del((GF_Descriptor *) esd);",
          "1543: }",
          "1544: void remove_systems_tracks(GF_ISOFile *file)",
          "1545: {",
          "1546:  u32 i, count;",
          "1548:  count = gf_isom_get_track_count(file);",
          "1549:  if (count==1) return;",
          "1552:  gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0);",
          "1553:  gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0);",
          "1556:  for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "1557:   switch (gf_isom_get_media_type(file, i+1)) {",
          "1558:   case GF_ISOM_MEDIA_VISUAL:",
          "1559:         case GF_ISOM_MEDIA_AUXV:",
          "1560:         case GF_ISOM_MEDIA_PICT:",
          "1561:   case GF_ISOM_MEDIA_AUDIO:",
          "1562:   case GF_ISOM_MEDIA_TEXT:",
          "1563:   case GF_ISOM_MEDIA_SUBT:",
          "1564:    gf_isom_remove_track_from_root_od(file, i+1);",
          "1565:    check_media_profile(file, i+1);",
          "1566:    break;",
          "1569:   case GF_ISOM_MEDIA_SCENE:",
          "1570:    switch (gf_isom_get_media_subtype(file, i+1, 1)) {",
          "1571:    case GF_ISOM_MEDIA_DIMS:",
          "1572:     gf_isom_remove_track_from_root_od(file, i+1);",
          "1573:     continue;",
          "1574:    default:",
          "1575:     break;",
          "1576:    }",
          "1577:   case GF_ISOM_MEDIA_OD:",
          "1578:   case GF_ISOM_MEDIA_OCR:",
          "1579:   case GF_ISOM_MEDIA_MPEGJ:",
          "1580:    gf_isom_remove_track(file, i+1);",
          "1581:    i--;",
          "1582:    break;",
          "1583:   default:",
          "1584:    break;",
          "1585:   }",
          "1586:  }",
          "1588:  if (!gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO)) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFF);",
          "1589:  if (!gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL)) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFF);",
          "1591:  gf_isom_set_pl_indication(file, GF_ISOM_PL_OD, 0xFF);",
          "1592:  gf_isom_set_pl_indication(file, GF_ISOM_PL_SCENE, 0xFF);",
          "1593:  gf_isom_set_pl_indication(file, GF_ISOM_PL_GRAPHICS, 0xFF);",
          "1594:  gf_isom_set_pl_indication(file, GF_ISOM_PL_INLINE, 0);",
          "1595: }",
          "1599: GF_FileType get_file_type_by_ext(char *inName)",
          "1600: {",
          "1601:  GF_FileType type = GF_FILE_TYPE_NOT_SUPPORTED;",
          "1602:  char *ext = strrchr(inName, '.');",
          "1603:  if (ext) {",
          "1604:   char *sep;",
          "1605:   if (!strcmp(ext, \".gz\")) ext = strrchr(ext-1, '.');",
          "1606:   ext+=1;",
          "1607:   sep = strchr(ext, '.');",
          "1608:   if (sep) sep[0] = 0;",
          "1610:   if (!stricmp(ext, \"mp4\") || !stricmp(ext, \"3gp\") || !stricmp(ext, \"mov\") || !stricmp(ext, \"3g2\") || !stricmp(ext, \"3gs\")) {",
          "1611:    type = GF_FILE_TYPE_ISO_MEDIA;",
          "1612:   } else if (!stricmp(ext, \"bt\") || !stricmp(ext, \"wrl\") || !stricmp(ext, \"x3dv\")) {",
          "1613:    type = GF_FILE_TYPE_BT_WRL_X3DV;",
          "1614:   } else if (!stricmp(ext, \"xmt\") || !stricmp(ext, \"x3d\")) {",
          "1615:    type = GF_FILE_TYPE_XMT_X3D;",
          "1616:   } else if (!stricmp(ext, \"lsr\") || !stricmp(ext, \"saf\")) {",
          "1617:    type = GF_FILE_TYPE_LSR_SAF;",
          "1618:   } else if (!stricmp(ext, \"svg\") || !stricmp(ext, \"xsr\") || !stricmp(ext, \"xml\")) {",
          "1619:    type = GF_FILE_TYPE_SVG;",
          "1620:   } else if (!stricmp(ext, \"swf\")) {",
          "1621:    type = GF_FILE_TYPE_SWF;",
          "1622:   } else if (!stricmp(ext, \"jp2\")) {",
          "1623:    if (sep) sep[0] = '.';",
          "1624:    return GF_FILE_TYPE_NOT_SUPPORTED;",
          "1625:   }",
          "1626:   else type = GF_FILE_TYPE_NOT_SUPPORTED;",
          "1628:   if (sep) sep[0] = '.';",
          "1629:  }",
          "1633:  if (!type && gf_isom_probe_file(inName)) type = GF_FILE_TYPE_ISO_MEDIA;",
          "1634:  return type;",
          "1635: }",
          "1637: typedef struct",
          "1638: {",
          "1639:  GF_ISOTrackID trackID;",
          "1640:  char *line;",
          "1641: } SDPLine;",
          "1643: typedef enum {",
          "1644:  META_ACTION_SET_TYPE   = 0,",
          "1645:  META_ACTION_ADD_ITEM   = 1,",
          "1646:  META_ACTION_REM_ITEM   = 2,",
          "1647:  META_ACTION_SET_PRIMARY_ITEM = 3,",
          "1648:  META_ACTION_SET_XML    = 4,",
          "1649:  META_ACTION_SET_BINARY_XML  = 5,",
          "1650:  META_ACTION_REM_XML    = 6,",
          "1651:  META_ACTION_DUMP_ITEM   = 7,",
          "1652:  META_ACTION_DUMP_XML   = 8,",
          "1653:  META_ACTION_ADD_IMAGE_ITEM  = 9,",
          "1654:  META_ACTION_ADD_IMAGE_GRID  = 10,",
          "1655: } MetaActionType;",
          "1657: typedef struct {",
          "1658:  u32 ref_item_id;",
          "1659:  u32 ref_type;",
          "1660: } MetaRef;",
          "1662: typedef struct",
          "1663: {",
          "1664:  MetaActionType act_type;",
          "1665:  Bool root_meta, use_dref;",
          "1666:  GF_ISOTrackID trackID;",
          "1667:  u32 meta_4cc;",
          "1668:  char *szPath, *szName, *mime_type, *enc_type;",
          "1669:  u32 item_id;",
          "1670:  Bool primary;",
          "1671:  u32 item_type;",
          "1672:  u32 ref_item_id;",
          "1673:  GF_List *item_refs;",
          "1674:  u32 group_id;",
          "1675:  u32 group_type;",
          "1676:  GF_ImageItemProperties *image_props;",
          "1677: } MetaAction;",
          "1679: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "1680: static Bool parse_meta_args(MetaAction *meta, MetaActionType act_type, char *opts)",
          "1681: {",
          "1682:  Bool ret = 0;",
          "1684:  memset(meta, 0, sizeof(MetaAction));",
          "1685:  meta->act_type = act_type;",
          "1686:  meta->trackID = 0;",
          "1687:  meta->root_meta = 1;",
          "1689:  if (!opts) return 0;",
          "1690:  while (1) {",
          "1691:   char *next;",
          "1692:   char *szSlot;",
          "1693:   if (!opts || !opts[0]) return ret;",
          "1694:   if (opts[0]==':') opts += 1;",
          "1696:   szSlot = opts;",
          "1697:   next = gf_url_colon_suffix(opts);",
          "1698:   if (next) next[0] = 0;",
          "1700:   if (!strnicmp(szSlot, \"tk=\", 3)) {",
          "1701:    sscanf(szSlot, \"tk=%u\", &meta->trackID);",
          "1702:    meta->root_meta = 0;",
          "1703:    ret = 1;",
          "1704:   }",
          "1705:   else if (!strnicmp(szSlot, \"id=\", 3)) {",
          "1706:    meta->item_id = atoi(szSlot+3);",
          "1707:    ret = 1;",
          "1708:   }",
          "1709:   else if (!strnicmp(szSlot, \"type=\", 5)) {",
          "1710:    meta->item_type = GF_4CC(szSlot[5], szSlot[6], szSlot[7], szSlot[8]);",
          "1711:    ret = 1;",
          "1712:   }",
          "1714:   else if (!strnicmp(szSlot, \"ref=\", 4)) {",
          "1715:    char type[5];",
          "1716:    MetaRef *ref;",
          "1717:    if (!meta->item_refs) {",
          "1718:     meta->item_refs = gf_list_new();",
          "1719:     if (!meta->item_refs) return 0;",
          "1720:    }",
          "1721:    GF_SAFEALLOC(ref, MetaRef);",
          "1722:    if (!ref) return 0;",
          "1723:    sscanf(szSlot, \"ref=%4s,%u\", type, &(ref->ref_item_id));",
          "1724:    ref->ref_type = GF_4CC(type[0], type[1], type[2], type[3]);",
          "1725:    gf_list_add(meta->item_refs, ref);",
          "1726:    ret = 1;",
          "1727:   }",
          "1728:   else if (!strnicmp(szSlot, \"name=\", 5)) {",
          "1729:    meta->szName = gf_strdup(szSlot+5);",
          "1730:    ret = 1;",
          "1731:   }",
          "1732:   else if (!strnicmp(szSlot, \"path=\", 5)) {",
          "1733:    meta->szPath = gf_strdup(szSlot+5);",
          "1734:    ret = 1;",
          "1735:   }",
          "1736:   else if (!strnicmp(szSlot, \"mime=\", 5)) {",
          "1737:    meta->item_type = GF_META_ITEM_TYPE_MIME;",
          "1738:    meta->mime_type = gf_strdup(szSlot+5);",
          "1739:    ret = 1;",
          "1740:   }",
          "1741:   else if (!strnicmp(szSlot, \"encoding=\", 9)) {",
          "1742:    meta->enc_type = gf_strdup(szSlot+9);",
          "1743:    ret = 1;",
          "1744:   }",
          "1745:   else if (!strnicmp(szSlot, \"image-size=\", 11)) {",
          "1746:    if (!meta->image_props) {",
          "1747:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1748:     if (!meta->image_props) return 0;",
          "1749:    }",
          "1751:    sscanf(szSlot+11, \"%dx%d\", &meta->image_props->width, &meta->image_props->height);",
          "1752:    ret = 1;",
          "1753:   }",
          "1754:   else if (!strnicmp(szSlot, \"image-grid-size=\", 16)) {",
          "1755:    if (!meta->image_props) {",
          "1756:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1757:    }",
          "1758:    sscanf(szSlot+16, \"%dx%d\", &meta->image_props->num_grid_rows, &meta->image_props->num_grid_columns);",
          "1759:    ret = 1;",
          "1760:   }",
          "1761:   else if (!strnicmp(szSlot, \"image-pasp=\", 11)) {",
          "1762:    if (!meta->image_props) {",
          "1763:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1764:     if (!meta->image_props) return 0;",
          "1765:    }",
          "1766:    sscanf(szSlot+11, \"%dx%d\", &meta->image_props->hSpacing, &meta->image_props->vSpacing);",
          "1767:    ret = 1;",
          "1768:   }",
          "1769:   else if (!strnicmp(szSlot, \"image-rloc=\", 11)) {",
          "1770:    if (!meta->image_props) {",
          "1771:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1772:     if (!meta->image_props) return 0;",
          "1773:    }",
          "1774:    sscanf(szSlot+11, \"%dx%d\", &meta->image_props->hOffset, &meta->image_props->vOffset);",
          "1775:    ret = 1;",
          "1776:   }",
          "1777:   else if (!strnicmp(szSlot, \"rotation=\", 9)) {",
          "1778:    if (!meta->image_props) {",
          "1779:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1780:     if (!meta->image_props) return 0;",
          "1781:    }",
          "1782:    meta->image_props->angle = atoi(szSlot+9);",
          "1783:    ret = 1;",
          "1784:   }",
          "1785:   else if (!strnicmp(szSlot, \"mirror-axis=\", 12)) {",
          "1786:    if (!meta->image_props) {",
          "1787:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1788:     if (!meta->image_props) return 0;",
          "1789:    }",
          "1790:    meta->image_props->mirror = (!strnicmp(szSlot+12, \"vertical\", 8) ? 1 : 2);",
          "1791:    ret = 1;",
          "1792:   }",
          "1793:   else if (!strnicmp(szSlot, \"clap=\", 5)) {",
          "1794:    if (!meta->image_props) {",
          "1795:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1796:     if (!meta->image_props) return 0;",
          "1797:    }",
          "1798:    sscanf(szSlot + 5, \"%d,%d,%d,%d,%d,%d,%d,%d\", &meta->image_props->clap_wnum, &meta->image_props->clap_wden,",
          "1799:         &meta->image_props->clap_hnum, &meta->image_props->clap_hden,",
          "1800:         &meta->image_props->clap_honum, &meta->image_props->clap_hoden,",
          "1801:         &meta->image_props->clap_vonum, &meta->image_props->clap_voden);",
          "1802:    ret = 1;",
          "1803:   }",
          "1804:   else if (!stricmp(szSlot, \"hidden\")) {",
          "1805:    if (!meta->image_props) {",
          "1806:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1807:     if (!meta->image_props) return 0;",
          "1808:    }",
          "1809:    meta->image_props->hidden = GF_TRUE;",
          "1810:    ret = 1;",
          "1811:   }",
          "1812:   else if (!stricmp(szSlot, \"alpha\")) {",
          "1813:    if (!meta->image_props) {",
          "1814:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1815:     if (!meta->image_props) return 0;",
          "1816:    }",
          "1817:    meta->image_props->alpha = GF_TRUE;",
          "1818:    ret = 1;",
          "1824:     if (!meta->image_props) return 0;",
          "1827:    ret = 1;",
          "1833:     if (!meta->image_props) return 0;",
          "1839:     ret = 1;",
          "1843:     ret = 1;",
          "1847:     ret = 1;",
          "1850:     ret = 1;",
          "1856:     if (!meta->image_props) return 0;",
          "1860:    ret = 1;",
          "1866:    ret = 1;",
          "1871:     if (!meta->image_props) return 0;",
          "1874:    ret = 1;",
          "1878:    ret = 1;",
          "1882:    ret = 1;",
          "1886:    ret = 1;",
          "1891:     if (!meta->image_props) return 0;",
          "1894:    ret = 1;",
          "1899:     if (!meta->image_props) return 0;",
          "1904:    ret = 1;",
          "1911:     ret = 1;",
          "",
          "[Added Lines]",
          "1563: static u32 parse_sdp_ext(char *arg_val, u32 param)",
          "1565:  char *id;",
          "1566:  sdp_lines = gf_realloc(sdp_lines, sizeof(SDPLine) * (nb_sdp_ex + 1));",
          "1567:  if (!sdp_lines) return 2;",
          "1568:  id = strchr(arg_val, ':');",
          "1569:  if (id) {",
          "1570:   id[0] = 0;",
          "1571:   if (sscanf(arg_val, \"%u\", &sdp_lines[0].trackID) == 1) {",
          "1572:    id[0] = ':';",
          "1573:    sdp_lines[nb_sdp_ex].line = id + 1;",
          "1574:   }",
          "1575:   else {",
          "1576:    id[0] = ':';",
          "1577:    sdp_lines[nb_sdp_ex].line = arg_val;",
          "1578:    sdp_lines[nb_sdp_ex].trackID = 0;",
          "1581:  else {",
          "1582:   sdp_lines[nb_sdp_ex].line = arg_val;",
          "1583:   sdp_lines[nb_sdp_ex].trackID = 0;",
          "1584:  }",
          "1585:  open_edit = GF_TRUE;",
          "1586:  nb_sdp_ex++;",
          "1587:  return GF_FALSE;",
          "1591: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "1592: static u32 parse_meta_args(char *opts, MetaActionType act_type)",
          "1594:  MetaAction *meta;",
          "1596:  metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "1597:  if (!metas) return 2;",
          "1598:  meta = &metas[nb_meta_act];",
          "1599:  nb_meta_act ++;",
          "1601:  memset(meta, 0, sizeof(MetaAction));",
          "1602:  meta->act_type = act_type;",
          "1603:  meta->trackID = 0;",
          "1604:  meta->root_meta = 1;",
          "1605:  open_edit = GF_TRUE;",
          "1607:  if (!opts) return 2;",
          "1609:  while (1) {",
          "1610:   char *next;",
          "1611:   char *szSlot;",
          "1612:   if (!opts || !opts[0]) return 0;",
          "1613:   if (opts[0]==':') opts += 1;",
          "1615:   szSlot = opts;",
          "1616:   next = gf_url_colon_suffix(opts);",
          "1617:   if (next) next[0] = 0;",
          "1619:   if (!strnicmp(szSlot, \"tk=\", 3)) {",
          "1620:    sscanf(szSlot, \"tk=%u\", &meta->trackID);",
          "1621:    meta->root_meta = 0;",
          "1622:   }",
          "1623:   else if (!strnicmp(szSlot, \"id=\", 3)) {",
          "1624:    meta->item_id = atoi(szSlot+3);",
          "1625:   }",
          "1626:   else if (!strnicmp(szSlot, \"type=\", 5)) {",
          "1627:    meta->item_type = GF_4CC(szSlot[5], szSlot[6], szSlot[7], szSlot[8]);",
          "1628:   }",
          "1630:   else if (!strnicmp(szSlot, \"ref=\", 4)) {",
          "1631:    char type[5];",
          "1632:    MetaRef *ref;",
          "1633:    if (!meta->item_refs) {",
          "1634:     meta->item_refs = gf_list_new();",
          "1635:     if (!meta->item_refs) return 2;",
          "1637:    GF_SAFEALLOC(ref, MetaRef);",
          "1638:    if (!ref) return 2;",
          "1639:    sscanf(szSlot, \"ref=%4s,%u\", type, &(ref->ref_item_id));",
          "1640:    ref->ref_type = GF_4CC(type[0], type[1], type[2], type[3]);",
          "1641:    gf_list_add(meta->item_refs, ref);",
          "1642:   }",
          "1643:   else if (!strnicmp(szSlot, \"name=\", 5)) {",
          "1644:    meta->szName = gf_strdup(szSlot+5);",
          "1645:   }",
          "1646:   else if (!strnicmp(szSlot, \"path=\", 5)) {",
          "1647:    meta->szPath = gf_strdup(szSlot+5);",
          "1648:   }",
          "1649:   else if (!strnicmp(szSlot, \"mime=\", 5)) {",
          "1650:    meta->item_type = GF_META_ITEM_TYPE_MIME;",
          "1651:    meta->mime_type = gf_strdup(szSlot+5);",
          "1652:   }",
          "1653:   else if (!strnicmp(szSlot, \"encoding=\", 9)) {",
          "1654:    meta->enc_type = gf_strdup(szSlot+9);",
          "1655:   }",
          "1656:   else if (!strnicmp(szSlot, \"image-size=\", 11)) {",
          "1657:    if (!meta->image_props) {",
          "1658:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1659:     if (!meta->image_props) return 2;",
          "1661:    sscanf(szSlot+11, \"%dx%d\", &meta->image_props->width, &meta->image_props->height);",
          "1663:   else if (!strnicmp(szSlot, \"image-grid-size=\", 16)) {",
          "1664:    if (!meta->image_props) {",
          "1665:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1666:    }",
          "1667:    sscanf(szSlot+16, \"%dx%d\", &meta->image_props->num_grid_rows, &meta->image_props->num_grid_columns);",
          "1669:   else if (!strnicmp(szSlot, \"image-pasp=\", 11)) {",
          "1670:    if (!meta->image_props) {",
          "1671:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1672:     if (!meta->image_props) return 2;",
          "1674:    sscanf(szSlot+11, \"%dx%d\", &meta->image_props->hSpacing, &meta->image_props->vSpacing);",
          "1676:   else if (!strnicmp(szSlot, \"image-rloc=\", 11)) {",
          "1677:    if (!meta->image_props) {",
          "1678:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1679:     if (!meta->image_props) return 2;",
          "1681:    sscanf(szSlot+11, \"%dx%d\", &meta->image_props->hOffset, &meta->image_props->vOffset);",
          "1683:   else if (!strnicmp(szSlot, \"rotation=\", 9)) {",
          "1684:    if (!meta->image_props) {",
          "1685:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1686:     if (!meta->image_props) return 2;",
          "1688:    meta->image_props->angle = atoi(szSlot+9);",
          "1690:   else if (!strnicmp(szSlot, \"mirror-axis=\", 12)) {",
          "1691:    if (!meta->image_props) {",
          "1692:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1693:     if (!meta->image_props) return 2;",
          "1694:    }",
          "1695:    meta->image_props->mirror = (!strnicmp(szSlot+12, \"vertical\", 8) ? 1 : 2);",
          "1697:   else if (!strnicmp(szSlot, \"clap=\", 5)) {",
          "1698:    if (!meta->image_props) {",
          "1699:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1700:     if (!meta->image_props) return 2;",
          "1701:    }",
          "1702:    sscanf(szSlot + 5, \"%d,%d,%d,%d,%d,%d,%d,%d\", &meta->image_props->clap_wnum, &meta->image_props->clap_wden,",
          "1703:         &meta->image_props->clap_hnum, &meta->image_props->clap_hden,",
          "1704:         &meta->image_props->clap_honum, &meta->image_props->clap_hoden,",
          "1705:         &meta->image_props->clap_vonum, &meta->image_props->clap_voden);",
          "1707:   else if (!stricmp(szSlot, \"hidden\")) {",
          "1708:    if (!meta->image_props) {",
          "1709:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1710:     if (!meta->image_props) return 2;",
          "1711:    }",
          "1712:    meta->image_props->hidden = GF_TRUE;",
          "1714:   else if (!stricmp(szSlot, \"alpha\")) {",
          "1715:    if (!meta->image_props) {",
          "1716:     GF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);",
          "1717:     if (!meta->image_props) return 2;",
          "1718:    }",
          "1719:    meta->image_props->alpha = GF_TRUE;",
          "1725:     if (!meta->image_props) return 2;",
          "1733:     if (!meta->image_props) return 2;",
          "1752:     if (!meta->image_props) return 2;",
          "1765:     if (!meta->image_props) return 2;",
          "1781:     if (!meta->image_props) return 2;",
          "1788:     if (!meta->image_props) return 2;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1920:     }",
          "1922:     gf_dynstrcat(&meta->szPath, szSlot, \":\");",
          "1924:     break;",
          "1925:    case META_ACTION_REM_ITEM:",
          "1926:    case META_ACTION_SET_PRIMARY_ITEM:",
          "1927:    case META_ACTION_DUMP_ITEM:",
          "1928:     meta->item_id = atoi(szSlot);",
          "1930:     break;",
          "1931:    default:",
          "1932:     break;",
          "",
          "[Removed Lines]",
          "1923:     ret = 1;",
          "1929:     ret = 1;",
          "",
          "[Added Lines]",
          "1810:     if (!meta->szPath) return 2;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1936:   opts += strlen(szSlot);",
          "1937:   next[0] = ':';",
          "1938:  }",
          "1940: }",
          "1941: #endif //GPAC_DISABLE_ISOM_WRITE",
          "1950: {",
          "1967:  u32 criteria[30];",
          "1968:  u32 nb_criteria = 0;",
          "1969:  TSELAction *tsel_act;",
          "1970:  char szSlot[1024];",
          "1973:  has_switch_id = 0;",
          "1976:  if (!opts) return 0;",
          "1977:  while (1) {",
          "1978:   char *next;",
          "1980:   if (opts[0]==':') opts += 1;",
          "1981:   strcpy(szSlot, opts);",
          "1982:   next = gf_url_colon_suffix(szSlot);",
          "",
          "[Removed Lines]",
          "1939:  return ret;",
          "1943: typedef enum {",
          "1944:  TSEL_ACTION_SET_PARAM = 0,",
          "1945:  TSEL_ACTION_REMOVE_TSEL = 1,",
          "1946:  TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP = 2,",
          "1947: } TSELActionType;",
          "1949: typedef struct",
          "1951:  TSELActionType act_type;",
          "1952:  GF_ISOTrackID trackID;",
          "1954:  GF_ISOTrackID refTrackID;",
          "1955:  u32 criteria[30];",
          "1956:  u32 nb_criteria;",
          "1957:  Bool is_switchGroup;",
          "1958:  u32 switchGroupID;",
          "1959: } TSELAction;",
          "1961: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "1962: static Bool parse_tsel_args(TSELAction **__tsel_list, char *opts, u32 *nb_tsel_act, TSELActionType act)",
          "1963: {",
          "1964:  GF_ISOTrackID refTrackID = 0;",
          "1965:  Bool has_switch_id;",
          "1966:  u32 switch_id = 0;",
          "1971:  TSELAction *tsel_list;",
          "1979:   if (!opts || !opts[0]) return 1;",
          "",
          "[Added Lines]",
          "1825:  return 0;",
          "1830: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "1831: static Bool parse_tsel_args(char *opts, TSELActionType act)",
          "1833:  GF_ISOTrackID refTrackID = 0;",
          "1834:  Bool has_switch_id;",
          "1835:  u32 switch_id = 0;",
          "1846:   if (!opts || !opts[0]) return 0;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2007:    }",
          "2008:   }",
          "2009:   else if (!strnicmp(szSlot, \"trackID=\", 8) || !strchr(szSlot, '=') ) {",
          "2014:    memset(tsel_act, 0, sizeof(TSELAction));",
          "2015:    tsel_act->act_type = act;",
          "2016:    tsel_act->trackID = strchr(szSlot, '=') ? atoi(szSlot+8) : atoi(szSlot);",
          "",
          "[Removed Lines]",
          "2011:    tsel_list = *__tsel_list;",
          "2013:    tsel_act = &tsel_list[*nb_tsel_act];",
          "",
          "[Added Lines]",
          "1877:    tsel_acts = gf_realloc(tsel_acts, sizeof(TSELAction) * (nb_tsel_acts + 1));",
          "1878:    if (!tsel_acts) return 2;",
          "1880:    tsel_act = &tsel_acts[nb_tsel_acts];",
          "1881:    nb_tsel_acts++;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2023:    if (!refTrackID)",
          "2024:     refTrackID = tsel_act->trackID;",
          "2027:   }",
          "2028:   opts += strlen(szSlot);",
          "2029:  }",
          "2031: }",
          "2032: #endif // GPAC_DISABLE_ISOM_WRITE",
          "2098: GF_DashSegmenterInput *set_dash_input(GF_DashSegmenterInput *dash_inputs, char *name, u32 *nb_dash_inputs)",
          "2099: {",
          "2100:  GF_DashSegmenterInput *di;",
          "",
          "[Removed Lines]",
          "2026:    (*nb_tsel_act) ++;",
          "2030:  return 1;",
          "2035: #define CHECK_NEXT_ARG if (i+1==(u32)argc) {\\",
          "2036:   fprintf(stderr, \"Missing arg - please check usage\\n\"); return mp4box_cleanup(1);\\",
          "2037:  } else { \\",
          "2038:   has_next_arg = GF_TRUE;\\",
          "2039:  }",
          "2042: typedef enum {",
          "2043:  TRAC_ACTION_REM_TRACK  = 0,",
          "2044:  TRAC_ACTION_SET_LANGUAGE = 1,",
          "2045:  TRAC_ACTION_SET_DELAY  = 2,",
          "2046:  TRAC_ACTION_SET_KMS_URI  = 3,",
          "2047:  TRAC_ACTION_SET_PAR   = 4,",
          "2048:  TRAC_ACTION_SET_HANDLER_NAME= 5,",
          "2049:  TRAC_ACTION_ENABLE   = 6,",
          "2050:  TRAC_ACTION_DISABLE   = 7,",
          "2051:  TRAC_ACTION_REFERENCE  = 8,",
          "2052:  TRAC_ACTION_RAW_EXTRACT  = 9,",
          "2053:  TRAC_ACTION_REM_NON_RAP  = 10,",
          "2054:  TRAC_ACTION_SET_KIND  = 11,",
          "2055:  TRAC_ACTION_REM_KIND  = 12,",
          "2056:  TRAC_ACTION_SET_ID   = 13,",
          "2057:  TRAC_ACTION_SET_UDTA  = 14,",
          "2058:  TRAC_ACTION_SWAP_ID   = 15,",
          "2059:  TRAC_ACTION_REM_NON_REFS = 16,",
          "2060:  TRAC_ACTION_SET_CLAP  = 17,",
          "2061:  TRAC_ACTION_SET_MX   = 18,",
          "2062:  TRAC_ACTION_SET_EDITS  = 19,",
          "2063: } TrackActionType;",
          "2065: typedef struct",
          "2066: {",
          "2067:  TrackActionType act_type;",
          "2068:  GF_ISOTrackID trackID;",
          "2069:  char lang[10];",
          "2070:  GF_Fraction delay;",
          "2071:  const char *kms;",
          "2072:  const char *hdl_name;",
          "2073:  s32 par_num, par_den;",
          "2074:  u8 force_par, rewrite_bs;",
          "2075:  u32 dump_type, sample_num;",
          "2076:  char *out_name;",
          "2077:  char *src_name;",
          "2078:  char *string;",
          "2079:  u32 udta_type;",
          "2080:  char *kind_scheme, *kind_value;",
          "2081:  u32 newTrackID;",
          "2082:  s32 clap_wnum, clap_wden, clap_hnum, clap_hden, clap_honum, clap_hoden, clap_vonum, clap_voden;",
          "2083:  s32 mx[9];",
          "2084: } TrackAction;",
          "2086: enum",
          "2087: {",
          "2088:  GF_ISOM_CONV_TYPE_ISMA = 1,",
          "2089:  GF_ISOM_CONV_TYPE_ISMA_EX,",
          "2090:  GF_ISOM_CONV_TYPE_3GPP,",
          "2091:  GF_ISOM_CONV_TYPE_IPOD,",
          "2092:  GF_ISOM_CONV_TYPE_PSP,",
          "2093:  GF_ISOM_CONV_TYPE_MOV",
          "2094: };",
          "",
          "[Added Lines]",
          "1895:    open_edit = GF_TRUE;",
          "1899:  return 0;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2207:  return dash_inputs;",
          "2208: }",
          "2211: {",
          "2215:  while (param) {",
          "2216:   param = gf_url_colon_suffix(param);",
          "",
          "[Removed Lines]",
          "2210: static GF_Err parse_track_action_params(char *string, TrackAction *action)",
          "2212:  char *param = string;",
          "2213:  if (!action || !string) return GF_BAD_PARAM;",
          "",
          "[Added Lines]",
          "2016: static Bool create_new_track_action(char *arg_val, u32 act_type, u32 dump_type)",
          "2018:  TrackAction *tka;",
          "2019:  char *param = arg_val;",
          "2020:  tracks = (TrackAction *)gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act+1));",
          "2021:  if (!tracks) return GF_FALSE;",
          "2023:  tka = & tracks[nb_track_act];",
          "2024:  nb_track_act++;",
          "2026:  memset(tka, 0, sizeof(TrackAction) );",
          "2027:  tka->act_type = act_type;",
          "2028:  tka->dump_type = dump_type;",
          "2029:  if (act_type != TRAC_ACTION_RAW_EXTRACT) {",
          "2030:   open_edit = GF_TRUE;",
          "2031:   do_save = GF_TRUE;",
          "2032:  }",
          "2034:  if ((act_type==TRAC_ACTION_SET_ID) || (act_type==TRAC_ACTION_SWAP_ID)) {",
          "2035:   if (sscanf(param, \"%d:%u\", &tka->trackID, &tka->newTrackID) != 2) {",
          "2036:    fprintf(stderr, \"Bad format for -set-track-id - expecting \\\"id1:id2\\\" got \\\"%s\\\"\\n\", param);",
          "2037:    return GF_FALSE;",
          "2038:   }",
          "2039:   return GF_TRUE;",
          "2040:  }",
          "2041:  if (act_type==TRAC_ACTION_SET_PAR) {",
          "2042:   char *ext;",
          "2043:   ext = strchr(param, '=');",
          "2044:   if (!ext) {",
          "2045:    fprintf(stderr, \"Bad format for track par - expecting tkID=none or tkID=PAR_NUM:PAR_DEN got %s\\n\", param);",
          "2046:    return GF_FALSE;",
          "2047:   }",
          "2048:   ext[0] = 0;",
          "2049:   tka->trackID = atoi(param);",
          "2050:   ext[0] = '=';",
          "2052:   if (!stricmp(ext+1, \"none\"))",
          "2053:    tka->par_num = tka->par_den = 0;",
          "2054:   else if (!stricmp(ext+1, \"auto\")) {",
          "2055:    tka->par_num = tka->par_den = -1;",
          "2056:    tka->force_par = 1;",
          "2057:   }",
          "2058:   else if (!stricmp(ext+1, \"force\")) {",
          "2059:    tka->par_num = tka->par_den = 1;",
          "2060:    tka->force_par = 1;",
          "2061:   }",
          "2062:   else {",
          "2063:    if (ext[1]=='w') {",
          "2064:     tka->rewrite_bs = 1;",
          "2065:     ext++;",
          "2066:    }",
          "2067:    if (sscanf(ext+1, \"%d:%d\", &tka->par_num, &tka->par_den) != 2) {",
          "2068:     fprintf(stderr, \"Bad format for track par - expecting tkID=PAR_NUM:PAR_DEN got %s\\n\", param);",
          "2069:     return GF_FALSE;",
          "2070:    }",
          "2071:   }",
          "2072:   return GF_TRUE;",
          "2073:  }",
          "2074:  if (act_type==TRAC_ACTION_SET_CLAP) {",
          "2075:   char *ext = strchr(param, '=');",
          "2076:   if (!ext) {",
          "2077:    fprintf(stderr, \"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param);",
          "2078:    return GF_FALSE;",
          "2079:   }",
          "2080:   ext[0] = 0;",
          "2081:   tka->trackID = atoi(param);",
          "2082:   ext[0] = '=';",
          "2083:   if (stricmp(ext + 1, \"none\")) {",
          "2084:    if (sscanf(ext + 1, \"%d,%d,%d,%d,%d,%d,%d,%d\", &tka->clap_wnum, &tka->clap_wden, &tka->clap_hnum, &tka->clap_hden, &tka->clap_honum, &tka->clap_hoden, &tka->clap_vonum, &tka->clap_voden) != 8) {",
          "2086:     fprintf(stderr, \"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param);",
          "2087:     return GF_FALSE;",
          "2088:    }",
          "2089:   }",
          "2090:   return GF_TRUE;",
          "2091:  }",
          "2093:  if (act_type==TRAC_ACTION_SET_MX) {",
          "2094:   char *ext = strchr(param, '=');",
          "2095:   if (!ext) {",
          "2096:    fprintf(stderr, \"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param);",
          "2097:    return GF_FALSE;",
          "2098:   }",
          "2099:   ext[0] = 0;",
          "2100:   tka->trackID = atoi(param);",
          "2101:   ext[0] = '=';",
          "2102:   if (!stricmp(ext + 1, \"none\")) {",
          "2103:    memset(tka->mx, 0, sizeof(s32)*9);",
          "2104:    tka->mx[0] = tka->mx[4] = tka->mx[8] = 1;",
          "2105:   } else {",
          "2106:    s32 res;",
          "2107:    if (strstr(ext+1, \"0x\")) {",
          "2108:     res = sscanf(ext + 1, \"0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);",
          "2109:    } else {",
          "2110:     res = sscanf(ext + 1, \"%d:%d:%d:%d:%d:%d:%d:%d:%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);",
          "2111:    }",
          "2112:    if (res != 9) {",
          "2113:     fprintf(stderr, \"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param);",
          "2114:     return GF_FALSE;",
          "2115:    }",
          "2116:   }",
          "2117:   return GF_TRUE;",
          "2118:  }",
          "2119:  if (act_type==TRAC_ACTION_SET_EDITS) {",
          "2120:   char *ext = strchr(param, '=');",
          "2121:   if (!ext) {",
          "2122:    fprintf(stderr, \"Bad format for track edits - expecting ID=EDITS got %s\\n\", param);",
          "2123:    return GF_FALSE;",
          "2124:   }",
          "2125:   ext[0] = 0;",
          "2126:   tka->trackID = atoi(param);",
          "2127:   ext[0] = '=';",
          "2128:   tka->string = gf_strdup(ext+1);",
          "2129:   return GF_TRUE;",
          "2130:  }",
          "2131:  if (act_type==TRAC_ACTION_SET_LANGUAGE) {",
          "2132:   char *ext = strchr(param, '=');",
          "2133:   if (!strnicmp(param, \"all=\", 4)) {",
          "2134:    strncpy(tka->lang, param + 4, 10-1);",
          "2135:   }",
          "2136:   else if (!ext) {",
          "2137:    strncpy(tka->lang, param, 10-1);",
          "2138:   } else {",
          "2139:    strncpy(tka->lang, ext + 1, 10-1);",
          "2140:    ext[0] = 0;",
          "2141:    tka->trackID = atoi(param);",
          "2142:    ext[0] = '=';",
          "2143:   }",
          "2144:   return GF_TRUE;",
          "2145:  }",
          "2146:  if ((act_type==TRAC_ACTION_SET_KIND) || (act_type==TRAC_ACTION_REM_KIND)) {",
          "2147:   char *ext;",
          "2148:   char *scheme_start = NULL;",
          "2151:   if (!strnicmp(param, \"all=\", 4)) {",
          "2152:    scheme_start = param + 4;",
          "2153:   } else {",
          "2154:    ext = strchr(param, '=');",
          "2155:    if (ext) {",
          "2156:     ext[0] = 0;",
          "2157:     if (sscanf(param, \"%d\", &tka->trackID) == 1) {",
          "2158:      scheme_start = ext + 1;",
          "2159:     } else {",
          "2160:      scheme_start = param;",
          "2161:     }",
          "2162:     ext[0] = '=';",
          "2163:    } else {",
          "2164:     scheme_start = param;",
          "2165:    }",
          "2166:   }",
          "2169:   if (!scheme_start || !scheme_start[0]) {",
          "2170:    fprintf(stderr, \"Missing kind scheme - expecting ID=schemeURI=value got %s\\n\", param);",
          "2171:    return GF_FALSE;",
          "2172:   } else {",
          "2173:    ext = strchr(scheme_start, '=');",
          "2174:    if (!ext) {",
          "2175:     tka->kind_scheme = gf_strdup(scheme_start);",
          "2176:    } else {",
          "2177:     ext[0] = 0;",
          "2178:     tka->kind_scheme = gf_strdup(scheme_start);",
          "2179:     ext[0] = '=';",
          "2180:     tka->kind_value = gf_strdup(ext + 1);",
          "2181:    }",
          "2182:   }",
          "2183:   return GF_TRUE;",
          "2184:  }",
          "2185:  if (act_type==TRAC_ACTION_SET_DELAY) {",
          "2186:   char *ext = strchr(param, '=');",
          "2187:   if (!ext) {",
          "2188:    fprintf(stderr, \"Bad format for track delay - expecting tkID=DLAY got %s\\n\", param);",
          "2189:    return GF_FALSE;",
          "2190:   }",
          "2191:   ext[0] = 0;",
          "2192:   tka->trackID = atoi(param);",
          "2193:   ext[0] = '=';",
          "2194:   if (sscanf(ext+1, \"%d/%u\", &tka->delay.num, &tka->delay.den) != 2) {",
          "2195:    tka->delay.num = atoi(ext + 1);",
          "2196:    tka->delay.den = 1000;",
          "2197:   }",
          "2198:   return GF_TRUE;",
          "2199:  }",
          "2200:  if (act_type==TRAC_ACTION_REFERENCE) {",
          "2201:   char *ext = strchr(param, '=');",
          "2202:   if (!ext) ext = strchr(param, ':');",
          "2203:   if (!ext) {",
          "2204:    fprintf(stderr, \"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param);",
          "2205:    return GF_FALSE;",
          "2206:   }",
          "2207:   ext[0] = 0;",
          "2208:   tka->trackID = atoi(param);",
          "2209:   ext[0] = '=';",
          "2211:   char *ext2 = strchr(ext, ':');",
          "2212:   if (!ext2) {",
          "2213:    fprintf(stderr, \"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param);",
          "2214:    return GF_FALSE;",
          "2215:   }",
          "2216:   ext2[0] = 0;",
          "2217:   strncpy(tka->lang, ext+1, 9);",
          "2218:   ext2[0] = ':';",
          "2219:   tka->newTrackID = (s32) atoi(ext2 + 1);",
          "2220:   return GF_TRUE;",
          "2221:  }",
          "2222:  if (act_type==TRAC_ACTION_SET_HANDLER_NAME) {",
          "2223:   char *ext = strchr(param, '=');",
          "2224:   if (!ext) {",
          "2225:    fprintf(stderr, \"Bad format for track name - expecting tkID=name got %s\\n\", param);",
          "2226:    return GF_FALSE;",
          "2227:   }",
          "2228:   ext[0] = 0;",
          "2229:   tka->trackID = atoi(param);",
          "2230:   ext[0] = '=';",
          "2231:   tka->hdl_name = ext + 1;",
          "2232:   return GF_TRUE;",
          "2233:  }",
          "2234:  if (act_type==TRAC_ACTION_SET_HANDLER_NAME) {",
          "2235:   char *ext = strchr(param, '=');",
          "2237:   if (!strnicmp(param, \"all=\", 4)) {",
          "2238:    tka->kms = param + 4;",
          "2239:   } else if (!ext) {",
          "2240:    tka->kms = param;",
          "2241:   } else {",
          "2242:    tka->kms = ext + 1;",
          "2243:    ext[0] = 0;",
          "2244:    tka->trackID = atoi(param);",
          "2245:    ext[0] = '=';",
          "2246:   }",
          "2247:   return GF_TRUE;",
          "2248:  }",
          "2249:  if (act_type==TRAC_ACTION_SET_TIME) {",
          "2250:   struct tm time;",
          "2251:   char *ext = strchr(arg_val, '=');",
          "2252:   if (ext) {",
          "2253:    ext[0] = 0;",
          "2254:    tka->trackID = atoi(arg_val);",
          "2255:    ext[0] = '=';",
          "2256:    arg_val = ext+1;",
          "2257:   }",
          "2258:   memset(&time, 0, sizeof(struct tm));",
          "2259:   sscanf(arg_val, \"%d/%d/%d-%d:%d:%d\", &time.tm_mday, &time.tm_mon, &time.tm_year, &time.tm_hour, &time.tm_min, &time.tm_sec);",
          "2260:   time.tm_isdst = 0;",
          "2261:   time.tm_year -= 1900;",
          "2262:   time.tm_mon -= 1;",
          "2263:   tka->time = 2082758400;",
          "2264:   tka->time += mktime(&time);",
          "2265:   return GF_TRUE;",
          "2266:  }",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2219:    param++;",
          "2220: #ifndef GPAC_DISABLE_MEDIA_EXPORT",
          "2221:    if (!strncmp(\"vttnomerge\", param, 10)) {",
          "2223:    } else if (!strncmp(\"layer\", param, 5)) {",
          "2225:    } else if (!strncmp(\"full\", param, 4)) {",
          "2227:    } else if (!strncmp(\"embedded\", param, 8)) {",
          "2229:    } else if (!strncmp(\"output=\", param, 7)) {",
          "2231:    } else if (!strncmp(\"src=\", param, 4)) {",
          "2233:    } else if (!strncmp(\"str=\", param, 4)) {",
          "2235:    } else if (!strncmp(\"box=\", param, 4)) {",
          "2238:    } else if (!strncmp(\"type=\", param, 4)) {",
          "2242:    }",
          "2243: #endif",
          "2244:   }",
          "2245:  }",
          "2250:  }",
          "2252: }",
          "2255: {",
          "2263: }",
          "2267: {",
          "2279:  }",
          "2284:  }",
          "2292:  }",
          "2296:  } else {",
          "2316:  }",
          "2319: }",
          "2323: {",
          "2357:  }",
          "2362: }",
          "2365: {",
          "2390:  }",
          "2432:   }",
          "2438:   }",
          "2463:   }",
          "2464:  }",
          "2493:   }",
          "2542:  }",
          "2566:  }",
          "2590:   }",
          "2607:  } else {",
          "2615: }",
          "2618: {",
          "2619:  u32 i;",
          "2859:   char *arg = argv[i];",
          "2894:     }",
          "2895:    }",
          "2916:    }",
          "2955:     }",
          "2956:     else {",
          "2960:     }",
          "2961:    }",
          "2962:    else {",
          "2965:    }",
          "3011:   }",
          "3018:   }",
          "3022:    i++;",
          "3023:   }",
          "3036:   }",
          "3044:   }",
          "3056:   }",
          "3066:     return 2;",
          "3067:    }",
          "3076:   }",
          "3217:   }",
          "3227:    }",
          "3230:   }",
          "3257:   }",
          "3301:    }",
          "3307:    }",
          "3311:   }",
          "3337:   }",
          "3359:    }",
          "3367:   }",
          "3380:    }",
          "3389:   }",
          "3411:    }",
          "3433:   }",
          "3550:   }",
          "3557:   }",
          "3562:   }",
          "3568:   }",
          "3592:    }",
          "3652:   }",
          "3658:   }",
          "3664:   }",
          "3679:    }",
          "3697:   }",
          "3703:   }",
          "3714:    }",
          "3716:   }",
          "3785:    }",
          "3792:   }",
          "3909:   }",
          "3910:  }",
          "3913: }",
          "3916: {",
          "3917:  u32 i;",
          "4396:   }",
          "4401:   }",
          "4408:    }",
          "4466:    }",
          "4489:    }",
          "4496:    }",
          "4624:    }",
          "4636:    }",
          "4637:   }",
          "4671:  }",
          "4673: }",
          "4675: int mp4boxMain(int argc, char **argv)",
          "4676: {",
          "4677:  u32 i, j;",
          "4678:  const char *gpac_profile = \"0\";",
          "4679:  GF_Err e = GF_OK;",
          "4728: #endif",
          "4732:  for (i = 1; i < (u32) argc ; i++) {",
          "4733:   if (!strcmp(argv[i], \"-mem-track\") || !strcmp(argv[i], \"-mem-track-stack\")) {",
          "",
          "[Removed Lines]",
          "2222:     action->dump_type |= GF_EXPORT_WEBVTT_NOMERGE;",
          "2224:     action->dump_type |= GF_EXPORT_SVC_LAYER;",
          "2226:     action->dump_type |= GF_EXPORT_NHML_FULL;",
          "2228:     action->dump_type |= GF_EXPORT_WEBVTT_META_EMBEDDED;",
          "2230:     action->out_name = gf_strdup(param+7);",
          "2232:     action->src_name = gf_strdup(param+4);",
          "2234:     action->string = gf_strdup(param+4);",
          "2236:     action->src_name = gf_strdup(param+4);",
          "2237:     action->sample_num = 1;",
          "2239:     action->udta_type = GF_4CC(param[5], param[6], param[7], param[8]);",
          "2240:    } else if (action->dump_type == GF_EXPORT_RAW_SAMPLES) {",
          "2241:     action->sample_num = atoi(param);",
          "2246:  if (!strcmp(string, \"*\")) {",
          "2247:   action->trackID = (u32) -1;",
          "2248:  } else {",
          "2249:   action->trackID = atoi(string);",
          "2251:  return GF_OK;",
          "2254: static u32 create_new_track_action(char *string, TrackAction **actions, u32 *nb_track_act, u32 dump_type)",
          "2257:  memset(&(*actions)[*nb_track_act], 0, sizeof(TrackAction) );",
          "2258:  (*actions)[*nb_track_act].act_type = TRAC_ACTION_RAW_EXTRACT;",
          "2259:  (*actions)[*nb_track_act].dump_type = dump_type;",
          "2260:  parse_track_action_params(string, &(*actions)[*nb_track_act]);",
          "2261:  (*nb_track_act)++;",
          "2262:  return dump_type;",
          "2265: #ifndef GPAC_DISABLE_CORE_TOOLS",
          "2266: static GF_Err xml_bs_to_bin(char *inName, char *outName, u32 dump_std)",
          "2268:  GF_Err e;",
          "2269:  GF_XMLNode *root;",
          "2270:  u8 *data = NULL;",
          "2271:  u32 data_size;",
          "2273:  GF_DOMParser *dom = gf_xml_dom_new();",
          "2274:  e = gf_xml_dom_parse(dom, inName, NULL, NULL);",
          "2275:  if (e) {",
          "2276:   gf_xml_dom_del(dom);",
          "2277:   fprintf(stderr, \"Failed to parse XML file: %s\\n\", gf_error_to_string(e));",
          "2278:   return e;",
          "2280:  root = gf_xml_dom_get_root_idx(dom, 0);",
          "2281:  if (!root) {",
          "2282:   gf_xml_dom_del(dom);",
          "2283:   return GF_OK;",
          "2286:  e = gf_xml_parse_bit_sequence(root, inName, &data, &data_size);",
          "2287:  gf_xml_dom_del(dom);",
          "2289:  if (e) {",
          "2290:   fprintf(stderr, \"Failed to parse binary sequence: %s\\n\", gf_error_to_string(e));",
          "2291:   return e;",
          "2294:  if (dump_std) {",
          "2295:   gf_fwrite(data, data_size, stdout);",
          "2297:   FILE *t;",
          "2298:   char szFile[GF_MAX_PATH];",
          "2299:   if (outName) {",
          "2300:    strcpy(szFile, outName);",
          "2301:   } else {",
          "2302:    strcpy(szFile, inName);",
          "2303:    strcat(szFile, \".bin\");",
          "2304:   }",
          "2305:   t = gf_fopen(szFile, \"wb\");",
          "2306:   if (!t) {",
          "2307:    fprintf(stderr, \"Failed to open file %s\\n\", szFile);",
          "2308:    e = GF_IO_ERR;",
          "2309:   } else {",
          "2310:    if (gf_fwrite(data, data_size, t) != data_size) {",
          "2311:     fprintf(stderr, \"Failed to write output to file %s\\n\", szFile);",
          "2312:     e = GF_IO_ERR;",
          "2313:    }",
          "2314:    gf_fclose(t);",
          "2315:   }",
          "2317:  gf_free(data);",
          "2318:  return e;",
          "2322: static u64 do_size_top_boxes(char *inName, char *compress_top_boxes, u32 mode)",
          "2324:  FILE *in;",
          "2325:  u64 top_size = 0;",
          "2326:  Bool do_all = GF_FALSE;",
          "2327:  GF_BitStream *bs_in;",
          "2328:  if (!compress_top_boxes) return GF_BAD_PARAM;",
          "2329:  if (!strcmp(compress_top_boxes, \"all\"))",
          "2330:   do_all = GF_TRUE;",
          "2332:  in = gf_fopen(inName, \"rb\");",
          "2333:  if (!in) return GF_URL_ERROR;",
          "2334:  bs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);",
          "2335:  while (gf_bs_available(bs_in)) {",
          "2336:   const char *stype;",
          "2337:   u32 hdr_size = 8;",
          "2338:   u64 lsize = gf_bs_read_u32(bs_in);",
          "2339:   u32 type = gf_bs_read_u32(bs_in);",
          "2341:   if (lsize==1) {",
          "2342:    lsize = gf_bs_read_u64(bs_in);",
          "2343:    hdr_size = 16;",
          "2344:   } else if (lsize==0) {",
          "2345:    lsize = gf_bs_available(bs_in) + 8;",
          "2346:   }",
          "2347:   stype = gf_4cc_to_str(type);",
          "2348:   if (do_all || strstr(compress_top_boxes, stype)) {",
          "2350:    if (mode==2) {",
          "2351:     top_size += 1;",
          "2352:    } else {",
          "2353:     top_size += lsize;",
          "2354:    }",
          "2355:   }",
          "2356:   gf_bs_skip_bytes(bs_in, lsize - hdr_size);",
          "2358:  gf_bs_del(bs_in);",
          "2359:  gf_fclose(in);",
          "2360:  return top_size;",
          "2364: static GF_Err do_compress_top_boxes(char *inName, char *outName, char *compress_top_boxes, u32 comp_top_box_version, Bool use_lzma)",
          "2366:  FILE *in, *out;",
          "2367:  u8 *buf;",
          "2368:  u32 buf_alloc, comp_size, start_offset;",
          "2369:  s32 bytes_comp=0;",
          "2370:  s32 bytes_uncomp=0;",
          "2371:  GF_Err e = GF_OK;",
          "2372:  u64 source_size, dst_size;",
          "2373:  u32 orig_box_overhead;",
          "2374:  u32 final_box_overhead;",
          "2375:  u32 gzip_code = use_lzma ? GF_4CC('l','z','m','a') : GF_4CC('g','z','i','p') ;",
          "2376:  u32 nb_added_box_bytes=0;",
          "2377:  Bool has_mov = GF_FALSE;",
          "2378:  u32 range_idx, nb_ranges=0;",
          "2379:  Bool replace_all = !strcmp(compress_top_boxes, \"*\");",
          "2380:  Bool requires_byte_ranges=GF_FALSE;",
          "2381:  GF_BitStream *bs_in, *bs_out;",
          "2382:  u32 idx_size=0, nb_moof;",
          "2383:  struct _ranges {",
          "2384:   u32 size, csize;",
          "2385:  } *ranges=NULL;",
          "2387:  if (!outName) {",
          "2388:   fprintf(stderr, \"Missing output file name\\n\");",
          "2389:   return GF_BAD_PARAM;",
          "2392:  in = gf_fopen(inName, \"rb\");",
          "2393:  if (!in) return GF_URL_ERROR;",
          "2394:  out = gf_fopen(outName, \"wb\");",
          "2395:  if (!out) return GF_IO_ERR;",
          "2397:  buf_alloc = 4096;",
          "2398:  buf = gf_malloc(buf_alloc);",
          "2400:  bs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);",
          "2401:  source_size = gf_bs_get_size(bs_in);",
          "2403:  bs_out = gf_bs_from_file(out, GF_BITSTREAM_WRITE);",
          "2405:  start_offset = 0;",
          "2406:  nb_moof = 0;",
          "2407:  if (comp_top_box_version==2) {",
          "2408:   u32 i;",
          "2409:   while (gf_bs_available(bs_in)) {",
          "2410:    u32 size = gf_bs_read_u32(bs_in);",
          "2411:    u32 type = gf_bs_read_u32(bs_in);",
          "2412:    const char *b4cc = gf_4cc_to_str(type);",
          "2413:    const char *replace = strstr(compress_top_boxes, b4cc);",
          "2415:    if (start_offset) {",
          "2416:     Bool compress = (replace || replace_all) ? 1 : 0;",
          "2417:     ranges = gf_realloc(ranges, sizeof(struct _ranges)*(nb_ranges+1));",
          "2418:     ranges[nb_ranges].csize = compress;",
          "2419:     ranges[nb_ranges].size = size-8;",
          "2420:     nb_ranges++;",
          "2421:    }",
          "2422:    if (!strcmp(b4cc, \"ftyp\") || !strcmp(b4cc, \"styp\")) {",
          "2423:     if (!start_offset) start_offset = (u32) gf_bs_get_position(bs_in) + size-8;",
          "2424:    }",
          "2425:    if (!strcmp(b4cc, \"sidx\") || !strcmp(b4cc, \"ssix\")) {",
          "2426:     requires_byte_ranges = GF_TRUE;",
          "2427:    }",
          "2428:    if (!strcmp(b4cc, \"moof\"))",
          "2429:     nb_moof++;",
          "2431:    gf_bs_skip_bytes(bs_in, size-8);",
          "2434:   gf_bs_seek(bs_in, 0);",
          "2435:   if (buf_alloc<start_offset) {",
          "2436:    buf_alloc = start_offset;",
          "2437:    buf = gf_realloc(buf, buf_alloc);",
          "2439:   gf_bs_read_data(bs_in, buf, start_offset);",
          "2440:   gf_bs_write_data(bs_out, buf, start_offset);",
          "2442:   if (!requires_byte_ranges) {",
          "2443:    nb_ranges = 0;",
          "2444:    gf_free(ranges);",
          "2445:    ranges = NULL;",
          "2446:   }",
          "2447:   idx_size = 8 + 4 + 4;",
          "2448:   for (i=0; i<nb_ranges; i++) {",
          "2449:    idx_size += 1;",
          "2450:    if (ranges[i].size<0xFFFF) {",
          "2451:     idx_size += 2;",
          "2452:     if (ranges[i].csize) idx_size += 2;",
          "2453:    } else {",
          "2454:     idx_size += 4;",
          "2455:     if (ranges[i].csize) idx_size += 4;",
          "2456:    }",
          "2457:    ranges[i].csize = 0;",
          "2458:   }",
          "2459:   i=idx_size;",
          "2460:   while (i) {",
          "2461:    gf_bs_write_u8(bs_out, 0);",
          "2462:    i--;",
          "2466:  range_idx = 0;",
          "2467:  orig_box_overhead = 0;",
          "2468:  final_box_overhead = 0;",
          "2469:  while (gf_bs_available(bs_in)) {",
          "2470:   u32 size = gf_bs_read_u32(bs_in);",
          "2471:   u32 type = gf_bs_read_u32(bs_in);",
          "2472:   const char *b4cc = gf_4cc_to_str(type);",
          "2473:   const u8 *replace = (const u8 *) strstr(compress_top_boxes, b4cc);",
          "2474:   if (!strcmp(b4cc, \"moov\")) has_mov = GF_TRUE;",
          "2476:   if (!replace && !replace_all) {",
          "2477:    if (ranges) {",
          "2478:     assert(! ranges[range_idx].csize);",
          "2479:     range_idx++;",
          "2480:    }",
          "2481:    gf_bs_write_u32(bs_out, size);",
          "2482:    gf_bs_write_u32(bs_out, type);",
          "2484:    size-=8;",
          "2485:    while (size) {",
          "2486:     u32 nbytes = size;",
          "2487:     if (nbytes>buf_alloc) nbytes=buf_alloc;",
          "2488:     gf_bs_read_data(bs_in, buf, nbytes);",
          "2489:     gf_bs_write_data(bs_out, buf, nbytes);",
          "2490:     size-=nbytes;",
          "2491:    }",
          "2492:    continue;",
          "2494:   orig_box_overhead += size;",
          "2496:   if (comp_top_box_version != 1)",
          "2497:    size-=8;",
          "2499:   if (size>buf_alloc) {",
          "2500:    buf_alloc = size;",
          "2501:    buf = gf_realloc(buf, buf_alloc);",
          "2502:   }",
          "2503:   gf_bs_read_data(bs_in, buf, size);",
          "2505:   if (comp_top_box_version != 1)",
          "2506:    replace+=5;",
          "2508:   comp_size = buf_alloc;",
          "2510:   if (use_lzma) {",
          "2511:    e = gf_lz_compress_payload(&buf, size, &comp_size);",
          "2512:   } else {",
          "2513:    e = gf_gz_compress_payload(&buf, size, &comp_size);",
          "2514:   }",
          "2515:   if (e) break;",
          "2517:   if (comp_size>buf_alloc) {",
          "2518:    buf_alloc = comp_size;",
          "2519:   }",
          "2520:   bytes_uncomp += size;",
          "2521:   bytes_comp += comp_size;",
          "2522:   if (comp_top_box_version==1)",
          "2523:    nb_added_box_bytes +=8;",
          "2526:   gf_bs_write_u32(bs_out, comp_size+8);",
          "2528:   if (comp_top_box_version==1)",
          "2529:    gf_bs_write_u32(bs_out, gzip_code);",
          "2530:   else",
          "2531:    gf_bs_write_data(bs_out, replace, 4);",
          "2533:   gf_bs_write_data(bs_out, buf, comp_size);",
          "2535:   final_box_overhead += 8+comp_size;",
          "2537:   if (ranges) {",
          "2538:    assert(ranges[range_idx].size == size);",
          "2539:    ranges[range_idx].csize = comp_size;",
          "2540:    range_idx++;",
          "2541:   }",
          "2543:  dst_size = gf_bs_get_position(bs_out);",
          "2545:  if (comp_top_box_version==2) {",
          "2546:   u32 i;",
          "2547:   gf_bs_seek(bs_out, start_offset);",
          "2548:   gf_bs_write_u32(bs_out, idx_size);",
          "2549:   gf_bs_write_u32(bs_out, GF_4CC('c','m','a','p'));",
          "2550:   gf_bs_write_u32(bs_out, gzip_code);",
          "2551:   gf_bs_write_u32(bs_out, nb_ranges);",
          "2552:   for (i=0; i<nb_ranges; i++) {",
          "2553:    u32 large_size = ranges[i].size>0xFFFF ? 1 : 0;",
          "2554:    gf_bs_write_int(bs_out, ranges[i].csize ? 1 : 0, 1);",
          "2555:    gf_bs_write_int(bs_out, large_size ? 1 : 0, 1);",
          "2556:    gf_bs_write_int(bs_out, 0, 6);",
          "2557:    large_size = large_size ? 32 : 16;",
          "2559:    gf_bs_write_int(bs_out, ranges[i].size, large_size);",
          "2560:    if (ranges[i].csize)",
          "2561:     gf_bs_write_int(bs_out, ranges[i].csize, large_size);",
          "2562:   }",
          "2563:   final_box_overhead += idx_size;",
          "2564:   nb_added_box_bytes += idx_size;",
          "2567:  if (buf) gf_free(buf);",
          "2568:  gf_bs_del(bs_in);",
          "2569:  gf_bs_del(bs_out);",
          "2570:  gf_fclose(in);",
          "2571:  gf_fclose(out);",
          "2572:  if (e) {",
          "2573:   fprintf(stderr, \"Error compressing: %s\\n\", gf_error_to_string(e));",
          "2574:   return e;",
          "2575:  }",
          "2577:  if (has_mov) {",
          "2578:   u32 i, nb_tracks, nb_samples;",
          "2579:   GF_ISOFile *mov;",
          "2580:   Double rate, new_rate, duration;",
          "2582:   mov = gf_isom_open(inName, GF_ISOM_OPEN_READ, NULL);",
          "2583:   duration = (Double) gf_isom_get_duration(mov);",
          "2584:   duration /= gf_isom_get_timescale(mov);",
          "2586:   nb_samples = 0;",
          "2587:   nb_tracks = gf_isom_get_track_count(mov);",
          "2588:   for (i=0; i<nb_tracks; i++) {",
          "2589:    nb_samples += gf_isom_get_sample_count(mov, i+1);",
          "2591:   gf_isom_close(mov);",
          "2593:   rate = (Double) source_size;",
          "2594:   rate /= duration;",
          "2595:   rate /= 1000;",
          "2597:   new_rate = (Double) dst_size;",
          "2598:   new_rate /= duration;",
          "2599:   new_rate /= 1000;",
          "2602:   fprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\torate\\tcrate\\tsamples\\tduration\\tobbps\\tcbbps\\n\");",
          "2603:   fprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\t%g\\t%g\\t%d\\t%g\\t%g\\t%g\\n\", inName, bytes_uncomp, bytes_comp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, nb_samples, duration, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );",
          "2605:   fprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d original rate %g kbps new rate %g kbps, orig %g box bytes/sample final %g bytes/sample\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );",
          "2608:   fprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\n\");",
          "2609:   fprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\n\", inName, bytes_uncomp, bytes_comp, ((Double) (bytes_uncomp - bytes_comp)*100)/(bytes_uncomp), nb_added_box_bytes);",
          "2611:   fprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes);",
          "2613:  }",
          "2614:  return GF_OK;",
          "2617: static GF_Err hash_file(char *name, u32 dump_std)",
          "2620:  u8 hash[20];",
          "2621:  GF_Err e = gf_media_get_file_hash(name, hash);",
          "2622:  if (e) return e;",
          "2623:  if (dump_std==2) {",
          "2624:   gf_fwrite(hash, 20, stdout);",
          "2625:  } else if (dump_std==1) {",
          "2626:   for (i=0; i<20; i++) fprintf(stdout, \"%02X\", hash[i]);",
          "2627:  }",
          "2628:  fprintf(stderr, \"File hash (SHA-1): \");",
          "2629:  for (i=0; i<20; i++) fprintf(stderr, \"%02X\", hash[i]);",
          "2630:  fprintf(stderr, \"\\n\");",
          "2632:  return GF_OK;",
          "2633: }",
          "2636: char outfile[GF_MAX_PATH];",
          "2637: #ifndef GPAC_DISABLE_SCENE_ENCODER",
          "2638: GF_SMEncodeOptions smenc_opts;",
          "2639: #endif",
          "2640: SDPLine *sdp_lines = NULL;",
          "2641: Double interleaving_time, split_duration, split_start, dash_duration, dash_subduration;",
          "2642: GF_Fraction import_fps;",
          "2643: Bool dash_duration_strict;",
          "2644: MetaAction *metas = NULL;",
          "2645: TrackAction *tracks = NULL;",
          "2646: TSELAction *tsel_acts = NULL;",
          "2647: u64 movie_time, initial_tfdt;",
          "2648: s32 subsegs_per_sidx;",
          "2649: u32 *brand_add = NULL;",
          "2650: u32 *brand_rem = NULL;",
          "2651: const char *split_range_str = NULL;",
          "2652: GF_DashSwitchingMode bitstream_switching_mode = GF_DASH_BSMODE_DEFAULT;",
          "2653: u32 stat_level, hint_flags, info_track_id, import_flags, nb_add, nb_cat, crypt, agg_samples, nb_sdp_ex, max_ptime, split_size, nb_meta_act, nb_track_act, rtp_rate, major_brand, nb_alt_brand_add, nb_alt_brand_rem, old_interleave, car_dur, minor_version, conv_type, nb_tsel_acts, program_number, dump_nal, time_shift_depth, initial_moof_sn, dump_std, import_subtitle, dump_saps, dump_saps_mode, force_new;",
          "2654: GF_DashDynamicMode dash_mode=GF_DASH_STATIC;",
          "2655: #ifndef GPAC_DISABLE_SCENE_DUMP",
          "2656: GF_SceneDumpFormat dump_mode;",
          "2657: #endif",
          "2658: Double mpd_live_duration = 0;",
          "2659: Bool HintIt, needSave, FullInter, Frag, HintInter, dump_rtp, regular_iod, remove_sys_tracks, remove_hint, remove_root_od;",
          "2660: Bool print_sdp, open_edit, dump_cr, force_ocr, encode, do_scene_log, dump_srt, dump_ttxt, do_saf, dump_m2ts, dump_cart, do_hash, verbose, force_cat, align_cat, pack_wgt, single_group, clean_groups, dash_live, no_fragments_defaults, single_traf_per_moof, tfdt_per_traf, hls_clock, do_mpd_rip, merge_vtt_cues, compress_moov, get_nb_tracks;",
          "2661: static char *inName, *outName, *mediaSource, *tmpdir, *input_ctx, *output_ctx, *drm_file, *avi2raw, *cprt, *chap_file, *pes_dump, *itunes_tags, *pack_file, *raw_cat, *seg_name, *dash_ctx_file, *compress_top_boxes, *high_dynamc_range_filename, *use_init_seg, *box_patch_filename;",
          "2662: u32 track_dump_type, dump_isom, dump_timestamps, dump_nal_type;",
          "2663: GF_ISOTrackID trackID;",
          "2664: u32 do_flat, box_patch_trackID=0, print_info;",
          "2665: Bool comp_lzma=GF_FALSE;",
          "2666: Bool no_inplace = GF_FALSE;",
          "2667: Bool merge_last_seg=GF_FALSE;",
          "2668: Bool freeze_box_order=GF_FALSE;",
          "2669: Bool chap_qt=GF_FALSE;",
          "2670: Bool no_odf_conf=GF_FALSE;",
          "2671: Double min_buffer = 1.5;",
          "2672: u32 comp_top_box_version = 0;",
          "2673: u32 size_top_box = 0;",
          "2674: s32 ast_offset_ms = 0;",
          "2675: u32 fs_dump_flags = 0;",
          "2676: u32 dump_chap = 0;",
          "2677: u32 dump_udta_type = 0;",
          "2678: u32 dump_udta_track = 0;",
          "2679: char **mpd_base_urls = NULL;",
          "2680: u32 nb_mpd_base_urls = 0;",
          "2681: u32 dash_scale = 1000;",
          "2682: u32 moov_pading = 0;",
          "2683: Bool insert_utc = GF_FALSE;",
          "2684: const char *udp_dest = NULL;",
          "2685: #ifndef GPAC_DISABLE_MPD",
          "2686: Bool do_mpd = GF_FALSE;",
          "2687: #endif",
          "2688: #ifndef GPAC_DISABLE_SCENE_ENCODER",
          "2689: Bool chunk_mode = GF_FALSE;",
          "2690: #endif",
          "2691: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "2692: Bool HintCopy = GF_FALSE;",
          "2693: Bool hint_no_offset = GF_FALSE;",
          "2694: u32 MTUSize = 1450;",
          "2695: #endif",
          "2696: #ifndef GPAC_DISABLE_CORE_TOOLS",
          "2697: Bool do_bin_xml = GF_FALSE;",
          "2698: #endif",
          "2699: GF_ISOFile *file;",
          "2700: Bool frag_real_time = GF_FALSE;",
          "2701: const char *dash_start_date=NULL;",
          "2702: GF_DASH_ContentLocationMode cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;",
          "2703: Double mpd_update_time = GF_FALSE;",
          "2704: Bool force_co64 = GF_FALSE;",
          "2705: Bool live_scene = GF_FALSE;",
          "2706: Bool use_mfra = GF_FALSE;",
          "2707: GF_MemTrackerType mem_track = GF_MemTrackerNone;",
          "2709: Bool dump_iod = GF_FALSE;",
          "2710: GF_DASHPSSHMode pssh_mode = 0;",
          "2711: Bool samplegroups_in_traf = GF_FALSE;",
          "2712: Bool mvex_after_traks = GF_FALSE;",
          "2713: u32 sdtp_in_traf = 0;",
          "2714: Bool daisy_chain_sidx = GF_FALSE;",
          "2715: Bool use_ssix = GF_FALSE;",
          "2716: Bool single_segment = GF_FALSE;",
          "2717: Bool single_file = GF_FALSE;",
          "2718: Bool segment_timeline = GF_FALSE;",
          "2719: u32 segment_marker = GF_FALSE;",
          "2720: GF_DashProfile dash_profile = GF_DASH_PROFILE_AUTO;",
          "2721: const char *dash_profile_extension = NULL;",
          "2722: const char *dash_cues = NULL;",
          "2723: Bool strict_cues = GF_FALSE;",
          "2724: Bool use_url_template = GF_FALSE;",
          "2725: Bool seg_at_rap = GF_FALSE;",
          "2726: Bool frag_at_rap = GF_FALSE;",
          "2727: Bool adjust_split_end = GF_FALSE;",
          "2728: Bool memory_frags = GF_TRUE;",
          "2729: Bool keep_utc = GF_FALSE;",
          "2730: u32 timescale = 0;",
          "2731: Bool has_next_arg=GF_FALSE;",
          "2732: const char *do_wget = NULL;",
          "2733: GF_DashSegmenterInput *dash_inputs = NULL;",
          "2734: u32 nb_dash_inputs = 0;",
          "2735: char *seg_ext = NULL;",
          "2736: char *init_seg_ext = NULL;",
          "2737: const char *dash_title = NULL;",
          "2738: const char *dash_source = NULL;",
          "2739: const char *dash_more_info = NULL;",
          "2741: FILE *logfile = NULL;",
          "2742: static u32 run_for=0;",
          "2743: static u32 dash_cumulated_time,dash_prev_time,dash_now_time;",
          "2744: static Bool no_cache=GF_FALSE;",
          "2745: static Bool no_loop=GF_FALSE;",
          "2746: static GF_DASH_SplitMode dash_split_mode = GF_DASH_SPLIT_OUT;",
          "2748: u32 mp4box_cleanup(u32 ret_code) {",
          "2749:  if (mpd_base_urls) {",
          "2750:   gf_free(mpd_base_urls);",
          "2751:   mpd_base_urls = NULL;",
          "2752:  }",
          "2753:  if (sdp_lines) {",
          "2754:   gf_free(sdp_lines);",
          "2755:   sdp_lines = NULL;",
          "2756:  }",
          "2757:  if (metas) {",
          "2758:   u32 i;",
          "2759:   for (i=0; i<nb_meta_act; i++) {",
          "2760:    if (metas[i].enc_type) gf_free(metas[i].enc_type);",
          "2761:    if (metas[i].mime_type) gf_free(metas[i].mime_type);",
          "2762:    if (metas[i].szName) gf_free(metas[i].szName);",
          "2763:    if (metas[i].szPath) gf_free(metas[i].szPath);",
          "2764:   }",
          "2765:   gf_free(metas);",
          "2766:   metas = NULL;",
          "2767:  }",
          "2768:  if (tracks) {",
          "2769:   u32 i;",
          "2770:   for (i = 0; i<nb_track_act; i++) {",
          "2771:    if (tracks[i].out_name)",
          "2772:     gf_free(tracks[i].out_name);",
          "2773:    if (tracks[i].src_name)",
          "2774:     gf_free(tracks[i].src_name);",
          "2775:    if (tracks[i].string)",
          "2776:     gf_free(tracks[i].string);",
          "2777:    if (tracks[i].kind_scheme)",
          "2778:     gf_free(tracks[i].kind_scheme);",
          "2779:    if (tracks[i].kind_value)",
          "2780:     gf_free(tracks[i].kind_value);",
          "2781:   }",
          "2782:   gf_free(tracks);",
          "2783:   tracks = NULL;",
          "2784:  }",
          "2785:  if (tsel_acts) {",
          "2786:   gf_free(tsel_acts);",
          "2787:   tsel_acts = NULL;",
          "2788:  }",
          "2789:  if (brand_add) {",
          "2790:   gf_free(brand_add);",
          "2791:   brand_add = NULL;",
          "2792:  }",
          "2793:  if (brand_rem) {",
          "2794:   gf_free(brand_rem);",
          "2795:   brand_rem = NULL;",
          "2796:  }",
          "2797:  if (dash_inputs) {",
          "2798:   u32 i, j;",
          "2799:   for (i = 0; i<nb_dash_inputs; i++) {",
          "2800:    GF_DashSegmenterInput *di = &dash_inputs[i];",
          "2801:    if (di->nb_baseURL) {",
          "2802:     for (j = 0; j<di->nb_baseURL; j++) {",
          "2803:      gf_free(di->baseURL[j]);",
          "2804:     }",
          "2805:     gf_free(di->baseURL);",
          "2806:    }",
          "2807:    if (di->rep_descs) {",
          "2808:     for (j = 0; j<di->nb_rep_descs; j++) {",
          "2809:      gf_free(di->rep_descs[j]);",
          "2810:     }",
          "2811:     gf_free(di->rep_descs);",
          "2812:    }",
          "2813:    if (di->as_descs) {",
          "2814:     for (j = 0; j<di->nb_as_descs; j++) {",
          "2815:      gf_free(di->as_descs[j]);",
          "2816:     }",
          "2817:     gf_free(di->as_descs);",
          "2818:    }",
          "2819:    if (di->as_c_descs) {",
          "2820:     for (j = 0; j<di->nb_as_c_descs; j++) {",
          "2821:      gf_free(di->as_c_descs[j]);",
          "2822:     }",
          "2823:     gf_free(di->as_c_descs);",
          "2824:    }",
          "2825:    if (di->p_descs) {",
          "2826:     for (j = 0; j<di->nb_p_descs; j++) {",
          "2827:      gf_free(di->p_descs[j]);",
          "2828:     }",
          "2829:     gf_free(di->p_descs);",
          "2830:    }",
          "2831:    if (di->representationID) gf_free(di->representationID);",
          "2832:    if (di->periodID) gf_free(di->periodID);",
          "2833:    if (di->xlink) gf_free(di->xlink);",
          "2834:    if (di->seg_template) gf_free(di->seg_template);",
          "2835:    if (di->hls_pl) gf_free(di->hls_pl);",
          "2836:    if (di->source_opts) gf_free(di->source_opts);",
          "2837:    if (di->filter_chain) gf_free(di->filter_chain);",
          "2839:    if (di->roles) {",
          "2840:     for (j = 0; j<di->nb_roles; j++) {",
          "2841:      gf_free(di->roles[j]);",
          "2842:     }",
          "2843:     gf_free(di->roles);",
          "2844:    }",
          "2845:   }",
          "2846:   gf_free(dash_inputs);",
          "2847:   dash_inputs = NULL;",
          "2848:  }",
          "2849:  if (logfile) gf_fclose(logfile);",
          "2850:  gf_sys_close();",
          "2851:  return ret_code;",
          "2852: }",
          "2854: u32 mp4box_parse_args_continue(int argc, char **argv, u32 *current_index)",
          "2855: {",
          "2856:  u32 i = *current_index;",
          "2858:  {",
          "2860:   if (!stricmp(arg, \"-itags\")) {",
          "2861:    CHECK_NEXT_ARG",
          "2862:    itunes_tags = argv[i + 1];",
          "2863:    i++;",
          "2864:    open_edit = GF_TRUE;",
          "2865:   }",
          "2866: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "2867:   else if (!stricmp(arg, \"-hint\")) {",
          "2868:    open_edit = GF_TRUE;",
          "2869:    HintIt = 1;",
          "2870:   }",
          "2871:   else if (!stricmp(arg, \"-unhint\")) {",
          "2872:    open_edit = GF_TRUE;",
          "2873:    remove_hint = 1;",
          "2874:   }",
          "2875:   else if (!stricmp(arg, \"-copy\")) HintCopy = 1;",
          "2876:   else if (!stricmp(arg, \"-no-offset\")) hint_no_offset = GF_TRUE;",
          "2877:   else if (!stricmp(arg, \"-tight\")) {",
          "2878:    FullInter = 1;",
          "2879:    open_edit = GF_TRUE;",
          "2880:    needSave = GF_TRUE;",
          "2881:   }",
          "2882:   else if (!stricmp(arg, \"-ocr\")) force_ocr = 1;",
          "2883:   else if (!stricmp(arg, \"-latm\")) hint_flags |= GP_RTP_PCK_USE_LATM_AAC;",
          "2884:   else if (!stricmp(arg, \"-rap\") || !stricmp(arg, \"-refonly\")) {",
          "2885:    if ((i + 1 < (u32)argc) && (argv[i + 1][0] != '-')) {",
          "2886:     if (sscanf(argv[i + 1], \"%d\", &trackID) == 1) {",
          "2887:      tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "2888:      memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "2889:      tracks[nb_track_act].act_type = !stricmp(arg, \"-rap\") ? TRAC_ACTION_REM_NON_RAP : TRAC_ACTION_REM_NON_REFS;",
          "2890:      tracks[nb_track_act].trackID = trackID;",
          "2891:      nb_track_act++;",
          "2892:      i++;",
          "2893:      open_edit = GF_TRUE;",
          "2896:    hint_flags |= GP_RTP_PCK_SIGNAL_RAP;",
          "2897:    seg_at_rap = 1;",
          "2898:   }",
          "2899:   else if (!stricmp(arg, \"-frag-rap\")) {",
          "2900:    frag_at_rap = 1;",
          "2901:   }",
          "2902:   else if (!stricmp(arg, \"-mfra\")) {",
          "2903:    use_mfra = GF_TRUE;",
          "2904:   }",
          "2905:   else if (!stricmp(arg, \"-ts\")) hint_flags |= GP_RTP_PCK_SIGNAL_TS;",
          "2906:   else if (!stricmp(arg, \"-size\")) hint_flags |= GP_RTP_PCK_SIGNAL_SIZE;",
          "2907:   else if (!stricmp(arg, \"-idx\")) hint_flags |= GP_RTP_PCK_SIGNAL_AU_IDX;",
          "2908:   else if (!stricmp(arg, \"-static\")) hint_flags |= GP_RTP_PCK_USE_STATIC_ID;",
          "2909:   else if (!stricmp(arg, \"-multi\")) {",
          "2910:    hint_flags |= GP_RTP_PCK_USE_MULTI;",
          "2911:    if ((i + 1 < (u32)argc) && (sscanf(argv[i + 1], \"%u\", &max_ptime) == 1)) {",
          "2912:     char szPt[20];",
          "2913:     sprintf(szPt, \"%u\", max_ptime);",
          "2914:     if (!strcmp(szPt, argv[i + 1])) i++;",
          "2915:     else max_ptime = 0;",
          "2917:   }",
          "2918: #endif",
          "2919:   else if (!stricmp(arg, \"-mpeg4\")) {",
          "2920: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "2921:    hint_flags |= GP_RTP_PCK_FORCE_MPEG4;",
          "2922: #endif",
          "2923: #ifndef GPAC_DISABLE_MEDIA_IMPORT",
          "2924:    import_flags |= GF_IMPORT_FORCE_MPEG4;",
          "2925: #endif",
          "2926:   }",
          "2927: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "2928:   else if (!stricmp(arg, \"-mtu\")) {",
          "2929:    CHECK_NEXT_ARG",
          "2930:    MTUSize = atoi(argv[i + 1]);",
          "2931:    i++;",
          "2932:   }",
          "2933:   else if (!stricmp(arg, \"-cardur\")) {",
          "2934:    CHECK_NEXT_ARG",
          "2935:    car_dur = atoi(argv[i + 1]);",
          "2936:    i++;",
          "2937:   }",
          "2938:   else if (!stricmp(arg, \"-rate\")) {",
          "2939:    CHECK_NEXT_ARG",
          "2940:    rtp_rate = atoi(argv[i + 1]);",
          "2941:    i++;",
          "2942:   }",
          "2943: #ifndef GPAC_DISABLE_SENG",
          "2944:   else if (!stricmp(arg, \"-add-sdp\") || !stricmp(arg, \"-sdp_ex\")) {",
          "2945:    char *id;",
          "2946:    CHECK_NEXT_ARG",
          "2947:    sdp_lines = gf_realloc(sdp_lines, sizeof(SDPLine) * (nb_sdp_ex + 1));",
          "2949:    id = strchr(argv[i + 1], ':');",
          "2950:    if (id) {",
          "2951:     id[0] = 0;",
          "2952:     if (sscanf(argv[i + 1], \"%u\", &sdp_lines[0].trackID) == 1) {",
          "2953:      id[0] = ':';",
          "2954:      sdp_lines[nb_sdp_ex].line = id + 1;",
          "2957:      id[0] = ':';",
          "2958:      sdp_lines[nb_sdp_ex].line = argv[i + 1];",
          "2959:      sdp_lines[nb_sdp_ex].trackID = 0;",
          "2963:     sdp_lines[nb_sdp_ex].line = argv[i + 1];",
          "2964:     sdp_lines[nb_sdp_ex].trackID = 0;",
          "2966:    open_edit = GF_TRUE;",
          "2967:    nb_sdp_ex++;",
          "2968:    i++;",
          "2969:   }",
          "2973:   else if (!stricmp(arg, \"-single\")) {",
          "2974: #ifndef GPAC_DISABLE_MEDIA_EXPORT",
          "2975:    CHECK_NEXT_ARG",
          "2976:    track_dump_type = GF_EXPORT_MP4;",
          "2977:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "2978:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "2979:    tracks[nb_track_act].act_type = TRAC_ACTION_RAW_EXTRACT;",
          "2980:    tracks[nb_track_act].trackID = atoi(argv[i + 1]);",
          "2981:    tracks[nb_track_act].dump_type = GF_EXPORT_MP4;",
          "2982:    nb_track_act++;",
          "2983:    i++;",
          "2984: #endif",
          "2985:   }",
          "2986:   else if (!stricmp(arg, \"-iod\")) regular_iod = 1;",
          "2987:   else if (!stricmp(arg, \"-flat\")) {",
          "2988:    open_edit = GF_TRUE;",
          "2989:    no_inplace = GF_TRUE;",
          "2990:    do_flat = 1;",
          "2991:   }",
          "2992:   else if (!stricmp(arg, \"-keep-utc\")) keep_utc = GF_TRUE;",
          "2993:   else if (!stricmp(arg, \"-new\")) force_new = 1;",
          "2994:   else if (!stricmp(arg, \"-newfs\")) {",
          "2995:    force_new = 2;",
          "2996:    interleaving_time = 0.5;",
          "2997:    do_flat = 1;",
          "2998:   }",
          "2999:   else if (!stricmp(arg, \"-timescale\")) {",
          "3000:    CHECK_NEXT_ARG",
          "3001:    timescale = atoi(argv[i + 1]);",
          "3002:    open_edit = GF_TRUE;",
          "3003:    i++;",
          "3004:   }",
          "3005:   else if (!stricmp(arg, \"-udta\")) {",
          "3006:    CHECK_NEXT_ARG",
          "3007:    create_new_track_action(argv[i + 1], &tracks, &nb_track_act, 0);",
          "3008:    tracks[nb_track_act - 1].act_type = TRAC_ACTION_SET_UDTA;",
          "3009:    open_edit = GF_TRUE;",
          "3010:    i++;",
          "3012:   else if (!stricmp(arg, \"-add\") || !stricmp(arg, \"-import\") || !stricmp(arg, \"-convert\")) {",
          "3013:    CHECK_NEXT_ARG",
          "3014:    if (!stricmp(arg, \"-import\")) fprintf(stderr, \"\\tWARNING: \\\"-import\\\" is deprecated - use \\\"-add\\\"\\n\");",
          "3015:    else if (!stricmp(arg, \"-convert\")) fprintf(stderr, \"\\tWARNING: \\\"-convert\\\" is deprecated - use \\\"-add\\\"\\n\");",
          "3016:    nb_add++;",
          "3017:    i++;",
          "3019:   else if (!stricmp(arg, \"-cat\") || !stricmp(arg, \"-catx\") || !stricmp(arg, \"-catpl\")) {",
          "3020:    CHECK_NEXT_ARG",
          "3021:    nb_cat++;",
          "3024:   else if (!stricmp(arg, \"-time\")) {",
          "3025:    struct tm time;",
          "3026:    CHECK_NEXT_ARG",
          "3027:    memset(&time, 0, sizeof(struct tm));",
          "3028:    sscanf(argv[i + 1], \"%d/%d/%d-%d:%d:%d\", &time.tm_mday, &time.tm_mon, &time.tm_year, &time.tm_hour, &time.tm_min, &time.tm_sec);",
          "3029:    time.tm_isdst = 0;",
          "3030:    time.tm_year -= 1900;",
          "3031:    time.tm_mon -= 1;",
          "3032:    open_edit = GF_TRUE;",
          "3033:    movie_time = 2082758400;",
          "3034:    movie_time += mktime(&time);",
          "3035:    i++;",
          "3037:   else if (!stricmp(arg, \"-force-cat\")) force_cat = 1;",
          "3038:   else if (!stricmp(arg, \"-align-cat\")) align_cat = 1;",
          "3039:   else if (!stricmp(arg, \"-unalign-cat\")) align_cat = 0;",
          "3040:   else if (!stricmp(arg, \"-raw-cat\")) {",
          "3041:    CHECK_NEXT_ARG",
          "3042:    raw_cat = argv[i + 1];",
          "3043:    i++;",
          "3045:   else if (!stricmp(arg, \"-rem\") || !stricmp(arg, \"-disable\") || !stricmp(arg, \"-enable\")) {",
          "3046:    CHECK_NEXT_ARG",
          "3047:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3048:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3049:    if (!stricmp(arg, \"-enable\")) tracks[nb_track_act].act_type = TRAC_ACTION_ENABLE;",
          "3050:    else if (!stricmp(arg, \"-disable\")) tracks[nb_track_act].act_type = TRAC_ACTION_DISABLE;",
          "3051:    else tracks[nb_track_act].act_type = TRAC_ACTION_REM_TRACK;",
          "3052:    tracks[nb_track_act].trackID = atoi(argv[i + 1]);",
          "3053:    open_edit = GF_TRUE;",
          "3054:    nb_track_act++;",
          "3055:    i++;",
          "3057:   else if (!stricmp(arg, \"-set-track-id\") || !stricmp(arg, \"-swap-track-id\")) {",
          "3058:    char *sep;",
          "3059:    CHECK_NEXT_ARG",
          "3060:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3061:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3062:    tracks[nb_track_act].act_type = !stricmp(arg, \"-set-track-id\") ? TRAC_ACTION_SET_ID : TRAC_ACTION_SWAP_ID;",
          "3063:    sep = strchr(argv[i + 1], ':');",
          "3064:    if (!sep) {",
          "3065:     fprintf(stderr, \"Bad format for -set-track-id - expecting \\\"id1:id2\\\" got \\\"%s\\\"\\n\", argv[i + 1]);",
          "3069:    tracks[nb_track_act].trackID = atoi(argv[i + 1]);",
          "3071:    sep++;",
          "3072:    tracks[nb_track_act].newTrackID = atoi(sep);",
          "3073:    open_edit = GF_TRUE;",
          "3074:    nb_track_act++;",
          "3075:    i++;",
          "3077:   else if (!stricmp(arg, \"-par\")) {",
          "3078:    char szTK[20], *ext;",
          "3079:    CHECK_NEXT_ARG",
          "3080:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3081:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3083:    tracks[nb_track_act].act_type = TRAC_ACTION_SET_PAR;",
          "3084:    assert(strlen(argv[i + 1]) + 1 <= sizeof(szTK));",
          "3085:    strncpy(szTK, argv[i + 1], sizeof(szTK)-1);",
          "3086:    ext = strchr(szTK, '=');",
          "3087:    if (!ext) {",
          "3088:     fprintf(stderr, \"Bad format for track par - expecting tkID=none or tkID=PAR_NUM:PAR_DEN got %s\\n\", argv[i + 1]);",
          "3089:     return 2;",
          "3090:    }",
          "3091:    if (!stricmp(ext + 1, \"none\")) {",
          "3092:     tracks[nb_track_act].par_num = tracks[nb_track_act].par_den = 0;",
          "3093:    }",
          "3094:    else if (!stricmp(ext + 1, \"auto\")) {",
          "3095:     tracks[nb_track_act].par_num = tracks[nb_track_act].par_den = -1;",
          "3096:     tracks[nb_track_act].force_par = 1;",
          "3097:    }",
          "3098:    else if (!stricmp(ext + 1, \"force\")) {",
          "3099:     tracks[nb_track_act].par_num = tracks[nb_track_act].par_den = 1;",
          "3100:     tracks[nb_track_act].force_par = 1;",
          "3101:    }",
          "3102:    else {",
          "3103:     if (ext[1]=='w') {",
          "3104:      tracks[nb_track_act].rewrite_bs = 1;",
          "3105:      ext++;",
          "3106:     }",
          "3107:     sscanf(ext + 1, \"%d\", &tracks[nb_track_act].par_num);",
          "3108:     ext = strchr(ext + 1, ':');",
          "3109:     if (!ext) {",
          "3110:      fprintf(stderr, \"Bad format for track par - expecting tkID=PAR_NUM:PAR_DEN got %s\\n\", argv[i + 1]);",
          "3111:      return 2;",
          "3112:     }",
          "3113:     sscanf(ext + 1, \"%d\", &tracks[nb_track_act].par_den);",
          "3114:    }",
          "3115:    ext[0] = 0;",
          "3116:    tracks[nb_track_act].trackID = atoi(szTK);",
          "3117:    open_edit = GF_TRUE;",
          "3118:    nb_track_act++;",
          "3119:    i++;",
          "3120:   }",
          "3121:   else if (!stricmp(arg, \"-clap\")) {",
          "3122:    char szTK[200], *ext;",
          "3123:    TrackAction *tka;",
          "3124:    CHECK_NEXT_ARG",
          "3125:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3126:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3128:    tracks[nb_track_act].act_type = TRAC_ACTION_SET_CLAP;",
          "3129:    assert(strlen(argv[i + 1]) + 1 <= sizeof(szTK));",
          "3130:    strncpy(szTK, argv[i + 1], sizeof(szTK)-1);",
          "3131:    ext = strchr(szTK, '=');",
          "3132:    if (!ext) {",
          "3133:     fprintf(stderr, \"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", argv[i + 1]);",
          "3134:     return 2;",
          "3135:    }",
          "3136:    tka = &tracks[nb_track_act];",
          "3137:    if (!stricmp(ext + 1, \"none\")) {",
          "3138:     tka->clap_wnum= tka->clap_wden = tka->clap_hnum = tka->clap_hden = tka->clap_honum = tka->clap_hoden = tka->clap_vonum = tka->clap_voden = 0;",
          "3139:    } else {",
          "3140:     if (sscanf(ext + 1, \"%d,%d,%d,%d,%d,%d,%d,%d\", &tka->clap_wnum, &tka->clap_wden, &tka->clap_hnum, &tka->clap_hden, &tka->clap_honum, &tka->clap_hoden, &tka->clap_vonum, &tka->clap_voden) != 8) {",
          "3142:      fprintf(stderr, \"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", argv[i + 1]);",
          "3143:      return 2;",
          "3144:     }",
          "3145:    }",
          "3146:    ext[0] = 0;",
          "3147:    tracks[nb_track_act].trackID = atoi(szTK);",
          "3148:    open_edit = GF_TRUE;",
          "3149:    nb_track_act++;",
          "3150:    i++;",
          "3151:   }",
          "3152:   else if (!stricmp(arg, \"-mx\")) {",
          "3153:    char szTK[200], *ext;",
          "3154:    TrackAction *tka;",
          "3155:    CHECK_NEXT_ARG",
          "3156:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3157:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3159:    tracks[nb_track_act].act_type = TRAC_ACTION_SET_MX;",
          "3160:    assert(strlen(argv[i + 1]) + 1 <= sizeof(szTK));",
          "3161:    strncpy(szTK, argv[i + 1], sizeof(szTK)-1);",
          "3162:    ext = strchr(szTK, '=');",
          "3163:    if (!ext) {",
          "3164:     fprintf(stderr, \"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", argv[i + 1]);",
          "3165:     return 2;",
          "3166:    }",
          "3167:    tka = &tracks[nb_track_act];",
          "3168:    if (!stricmp(ext + 1, \"none\")) {",
          "3169:     memset(tka->mx, 0, sizeof(s32)*9);",
          "3170:    } else {",
          "3171:     s32 res;",
          "3172:     if (strstr(ext+1, \"0x\")) {",
          "3173:      res = sscanf(ext + 1, \"0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);",
          "3174:     } else {",
          "3175:      res = sscanf(ext + 1, \"%d:%d:%d:%d:%d:%d:%d:%d:%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);",
          "3176:     }",
          "3177:     if (res != 9) {",
          "3178:      fprintf(stderr, \"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", argv[i + 1]);",
          "3179:      return 2;",
          "3180:     }",
          "3181:    }",
          "3182:    ext[0] = 0;",
          "3183:    tracks[nb_track_act].trackID = atoi(szTK);",
          "3184:    open_edit = GF_TRUE;",
          "3185:    nb_track_act++;",
          "3186:    i++;",
          "3187:   }",
          "3189:   else if (!stricmp(arg, \"-edits\")) {",
          "3190:    char *edits;",
          "3191:    CHECK_NEXT_ARG",
          "3193:    edits = strchr(argv[i+1], '=');",
          "3194:    if (!edits) {",
          "3195:     fprintf(stderr, \"Bad format for track edits - expecting ID=EDITS got %s\\n\", argv[i + 1]);",
          "3196:     return 2;",
          "3197:    }",
          "3198:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3199:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3200:    tracks[nb_track_act].act_type = TRAC_ACTION_SET_EDITS;",
          "3201:    edits[0] = 0;",
          "3202:    tracks[nb_track_act].trackID = atoi(argv[i + 1]);",
          "3203:    edits[0] = '=';",
          "3204:    tracks[nb_track_act].string = gf_strdup(edits+1);",
          "3205:    open_edit = GF_TRUE;",
          "3206:    nb_track_act++;",
          "3207:    i++;",
          "3208:   }",
          "3210:   else if (!stricmp(arg, \"-hdr\")) {",
          "3211:    CHECK_NEXT_ARG",
          "3212:    high_dynamc_range_filename = argv[i + 1];",
          "3213:    i++;",
          "3214:   }",
          "3215:   else if (!stricmp(arg, \"-bo\")) {",
          "3216:    freeze_box_order = GF_TRUE;",
          "3218:   else if (!stricmp(arg, \"-patch\")) {",
          "3219:    CHECK_NEXT_ARG",
          "3220:    box_patch_filename = argv[i + 1];",
          "3221:    char *sep = strchr(box_patch_filename, '=');",
          "3222:    if (sep) {",
          "3223:     sep[0] = 0;",
          "3224:     box_patch_trackID = atoi(box_patch_filename);",
          "3225:     sep[0] = '=';",
          "3226:     box_patch_filename = sep+1;",
          "3228:     open_edit = GF_TRUE;",
          "3229:    i++;",
          "3231:   else if (!stricmp(arg, \"-lang\")) {",
          "3232:    char szTK[20], *ext;",
          "3233:    CHECK_NEXT_ARG",
          "3234:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3235:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3237:    tracks[nb_track_act].act_type = TRAC_ACTION_SET_LANGUAGE;",
          "3238:    tracks[nb_track_act].trackID = 0;",
          "3239:    strncpy(szTK, argv[i + 1], sizeof(szTK)-1);",
          "3240:    szTK[sizeof(szTK)-1] = 0;",
          "3241:    ext = strchr(szTK, '=');",
          "3242:    if (!strnicmp(argv[i + 1], \"all=\", 4)) {",
          "3243:     strncpy(tracks[nb_track_act].lang, argv[i + 1] + 4, 10-1);",
          "3244:    }",
          "3245:    else if (!ext) {",
          "3246:     strncpy(tracks[nb_track_act].lang, argv[i + 1], 10-1);",
          "3247:    }",
          "3248:    else {",
          "3249:     strncpy(tracks[nb_track_act].lang, ext + 1, 10-1);",
          "3250:     ext[0] = 0;",
          "3251:     tracks[nb_track_act].trackID = atoi(szTK);",
          "3252:     ext[0] = '=';",
          "3253:    }",
          "3254:    open_edit = GF_TRUE;",
          "3255:    nb_track_act++;",
          "3256:    i++;",
          "3258:   else if (!stricmp(arg, \"-kind\") || !stricmp(arg, \"-kind-rem\")) {",
          "3259:    char szTK[200], *ext;",
          "3260:    char *scheme_start = NULL;",
          "3261:    Bool has_track_id = GF_FALSE;",
          "3262:    CHECK_NEXT_ARG",
          "3263:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3264:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3266:    if (!stricmp(arg, \"-kind\")) {",
          "3267:     tracks[nb_track_act].act_type = TRAC_ACTION_SET_KIND;",
          "3268:    }",
          "3269:    else {",
          "3270:     tracks[nb_track_act].act_type = TRAC_ACTION_REM_KIND;",
          "3271:    }",
          "3272:    tracks[nb_track_act].trackID = 0;",
          "3273:    if (!strnicmp(argv[i + 1], \"all=\", 4)) {",
          "3274:     scheme_start = argv[i + 1] + 4;",
          "3275:     has_track_id = GF_TRUE;",
          "3276:    }",
          "3277:    if (!scheme_start) {",
          "3278:     if (strlen(argv[i + 1]) > 200) {",
          "3279:      GF_LOG(GF_LOG_WARNING, GF_LOG_ALL, (\"Warning: track kind parameter is too long!\"));",
          "3280:     }",
          "3281:     strncpy(szTK, argv[i + 1], 200-1);",
          "3282:     ext = strchr(szTK, '=');",
          "3283:     if (ext && !has_track_id) {",
          "3284:      ext[0] = 0;",
          "3285:      has_track_id = (sscanf(szTK, \"%d\", &tracks[nb_track_act].trackID) == 1 ? GF_TRUE : GF_FALSE);",
          "3286:      if (has_track_id) {",
          "3287:       scheme_start = ext + 1;",
          "3288:      }",
          "3289:      else {",
          "3290:       scheme_start = szTK;",
          "3291:      }",
          "3292:      ext[0] = '=';",
          "3293:     }",
          "3294:     else {",
          "3295:      scheme_start = szTK;",
          "3296:     }",
          "3297:    }",
          "3298:    ext = strchr(scheme_start, '=');",
          "3299:    if (!ext) {",
          "3300:     tracks[nb_track_act].kind_scheme = gf_strdup(scheme_start);",
          "3302:    else {",
          "3303:     ext[0] = 0;",
          "3304:     tracks[nb_track_act].kind_scheme = gf_strdup(scheme_start);",
          "3305:     ext[0] = '=';",
          "3306:     tracks[nb_track_act].kind_value = gf_strdup(ext + 1);",
          "3308:    open_edit = GF_TRUE;",
          "3309:    nb_track_act++;",
          "3310:    i++;",
          "3312:   else if (!stricmp(arg, \"-delay\")) {",
          "3313:    char szTK[20], *ext;",
          "3314:    TrackAction *tka;",
          "3315:    CHECK_NEXT_ARG",
          "3316:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3317:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3319:    strncpy(szTK, argv[i + 1], sizeof(szTK)-1);",
          "3320:    szTK[sizeof(szTK)-1] = 0;",
          "3321:    ext = strchr(szTK, '=');",
          "3322:    if (!ext) {",
          "3323:     fprintf(stderr, \"Bad format for track delay - expecting tkID=DLAY got %s\\n\", argv[i + 1]);",
          "3324:     return 2;",
          "3325:    }",
          "3326:    tka = &tracks[nb_track_act];",
          "3327:    tka->act_type = TRAC_ACTION_SET_DELAY;",
          "3328:    if (sscanf(ext+1, \"%d/%u\", &tka->delay.num, &tka->delay.den) != 2) {",
          "3329:     tka->delay.num = atoi(ext + 1);",
          "3330:     tka->delay.den = 1000;",
          "3331:    }",
          "3332:    ext[0] = 0;",
          "3333:    tka->trackID = atoi(szTK);",
          "3334:    open_edit = GF_TRUE;",
          "3335:    nb_track_act++;",
          "3336:    i++;",
          "3338:   else if (!stricmp(arg, \"-ref\")) {",
          "3339:    char *szTK, *ext;",
          "3340:    CHECK_NEXT_ARG",
          "3341:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3342:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3344:    szTK = argv[i + 1];",
          "3345:    ext = strchr(szTK, ':');",
          "3346:    if (!ext) {",
          "3347:     fprintf(stderr, \"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", argv[i + 1]);",
          "3348:     return 2;",
          "3349:    }",
          "3350:    tracks[nb_track_act].act_type = TRAC_ACTION_REFERENCE;",
          "3351:    ext[0] = 0;",
          "3352:    tracks[nb_track_act].trackID = atoi(szTK);",
          "3353:    ext[0] = ':';",
          "3354:    szTK = ext + 1;",
          "3355:    ext = strchr(szTK, ':');",
          "3356:    if (!ext) {",
          "3357:     fprintf(stderr, \"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", argv[i + 1]);",
          "3358:     return 2;",
          "3360:    ext[0] = 0;",
          "3361:    strncpy(tracks[nb_track_act].lang, szTK, 9);",
          "3362:    ext[0] = ':';",
          "3363:    tracks[nb_track_act].newTrackID = (s32)atoi(ext + 1);",
          "3364:    open_edit = GF_TRUE;",
          "3365:    nb_track_act++;",
          "3366:    i++;",
          "3368:   else if (!stricmp(arg, \"-name\")) {",
          "3369:    char szTK[GF_MAX_PATH], *ext;",
          "3370:    CHECK_NEXT_ARG",
          "3371:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3372:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3374:    strncpy(szTK, argv[i + 1], sizeof(szTK)-1);",
          "3375:    szTK[sizeof(szTK)-1] = 0;",
          "3376:    ext = strchr(szTK, '=');",
          "3377:    if (!ext) {",
          "3378:     fprintf(stderr, \"Bad format for track name - expecting tkID=name got %s\\n\", argv[i + 1]);",
          "3379:     return 2;",
          "3381:    tracks[nb_track_act].act_type = TRAC_ACTION_SET_HANDLER_NAME;",
          "3382:    tracks[nb_track_act].hdl_name = strchr(argv[i + 1], '=') + 1;",
          "3383:    ext[0] = 0;",
          "3384:    tracks[nb_track_act].trackID = atoi(szTK);",
          "3385:    ext[0] = '=';",
          "3386:    open_edit = GF_TRUE;",
          "3387:    nb_track_act++;",
          "3388:    i++;",
          "3390: #if !defined(GPAC_DISABLE_MEDIA_EXPORT) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "3391:   else if (!stricmp(arg, \"-dref\")) import_flags |= GF_IMPORT_USE_DATAREF;",
          "3392:   else if (!stricmp(arg, \"-no-drop\") || !stricmp(arg, \"-nodrop\")) import_flags |= GF_IMPORT_NO_FRAME_DROP;",
          "3393:   else if (!stricmp(arg, \"-packed\")) import_flags |= GF_IMPORT_FORCE_PACKED;",
          "3394:   else if (!stricmp(arg, \"-sbr\")) import_flags |= GF_IMPORT_SBR_IMPLICIT;",
          "3395:   else if (!stricmp(arg, \"-sbrx\")) import_flags |= GF_IMPORT_SBR_EXPLICIT;",
          "3396:   else if (!stricmp(arg, \"-ps\")) import_flags |= GF_IMPORT_PS_IMPLICIT;",
          "3397:   else if (!stricmp(arg, \"-psx\")) import_flags |= GF_IMPORT_PS_EXPLICIT;",
          "3398:   else if (!stricmp(arg, \"-ovsbr\")) import_flags |= GF_IMPORT_OVSBR;",
          "3399:   else if (!stricmp(arg, \"-fps\")) {",
          "3400:    CHECK_NEXT_ARG",
          "3401:    if (!strcmp(argv[i + 1], \"auto\")) { fprintf(stderr, \"Warning, fps=auto option is deprecated\\n\"); }",
          "3402:    else if (strchr(argv[i + 1], '-')) {",
          "3403:     u32 ticks, dts_inc;",
          "3404:     sscanf(argv[i + 1], \"%u-%u\", &ticks, &dts_inc);",
          "3405:     if (!dts_inc) dts_inc = 1;",
          "3406:     import_fps.num = ticks;",
          "3407:     import_fps.den = dts_inc;",
          "3408:    } else {",
          "3409:     import_fps.num = (s32) (1000 * atof(argv[i + 1]));",
          "3410:     import_fps.den = 1000;",
          "3412:    i++;",
          "3413:   }",
          "3414:   else if (!stricmp(arg, \"-agg\")) {",
          "3415:    CHECK_NEXT_ARG agg_samples = atoi(argv[i + 1]);",
          "3416:    i++;",
          "3417:   }",
          "3419:   else if (!stricmp(arg, \"-keep-sys\") || !stricmp(arg, \"-keepsys\")) keep_sys_tracks = 1;",
          "3420:   else if (!stricmp(arg, \"-ms\")) {",
          "3421:    CHECK_NEXT_ARG mediaSource = argv[i + 1];",
          "3422:    i++;",
          "3423:   }",
          "3424:   else if (!stricmp(arg, \"-mp4\")) {",
          "3425:    encode = GF_TRUE;",
          "3426:    open_edit = GF_TRUE;",
          "3427:   }",
          "3428:   else if (!stricmp(arg, \"-saf\")) {",
          "3429:    do_saf = GF_TRUE;",
          "3430:   }",
          "3431:   else if (!stricmp(arg, \"-sclog\")) {",
          "3432:    do_scene_log = GF_TRUE;",
          "3434: #ifndef GPAC_DISABLE_MPD",
          "3435:   else if (!stricmp(arg, \"-mpd\")) {",
          "3436:    do_mpd = GF_TRUE;",
          "3437:    CHECK_NEXT_ARG",
          "3438:    inName = argv[i + 1];",
          "3439:    i++;",
          "3440:   }",
          "3441: #endif",
          "3443: #ifndef GPAC_DISABLE_SCENE_ENCODER",
          "3444:   else if (!stricmp(arg, \"-def\")) smenc_opts.flags |= GF_SM_ENCODE_USE_NAMES;",
          "3445:   else if (!stricmp(arg, \"-sync\")) {",
          "3446:    CHECK_NEXT_ARG",
          "3447:    smenc_opts.flags |= GF_SM_ENCODE_RAP_INBAND;",
          "3448:    smenc_opts.rap_freq = atoi(argv[i + 1]);",
          "3449:    i++;",
          "3450:   }",
          "3451:   else if (!stricmp(arg, \"-shadow\")) {",
          "3452:    CHECK_NEXT_ARG",
          "3453:    smenc_opts.flags &= ~GF_SM_ENCODE_RAP_INBAND;",
          "3454:    smenc_opts.flags |= GF_SM_ENCODE_RAP_SHADOW;",
          "3455:    smenc_opts.rap_freq = atoi(argv[i + 1]);",
          "3456:    i++;",
          "3457:   }",
          "3458:   else if (!stricmp(arg, \"-carousel\")) {",
          "3459:    CHECK_NEXT_ARG",
          "3460:    smenc_opts.flags &= ~(GF_SM_ENCODE_RAP_INBAND | GF_SM_ENCODE_RAP_SHADOW);",
          "3461:    smenc_opts.rap_freq = atoi(argv[i + 1]);",
          "3462:    i++;",
          "3463:   }",
          "3465:   else if (!stricmp(arg, \"-resolution\")) {",
          "3466:    CHECK_NEXT_ARG",
          "3467:    smenc_opts.resolution = atoi(argv[i + 1]);",
          "3468:    i++;",
          "3469:   }",
          "3470: #ifndef GPAC_DISABLE_SCENE_STATS",
          "3471:   else if (!stricmp(arg, \"-auto-quant\")) {",
          "3472:    CHECK_NEXT_ARG",
          "3473:    smenc_opts.resolution = atoi(argv[i + 1]);",
          "3474:    smenc_opts.auto_quant = 1;",
          "3475:    i++;",
          "3476:   }",
          "3477: #endif",
          "3478:   else if (!stricmp(arg, \"-coord-bits\")) {",
          "3479:    CHECK_NEXT_ARG",
          "3480:    smenc_opts.coord_bits = atoi(argv[i + 1]);",
          "3481:    i++;",
          "3482:   }",
          "3483:   else if (!stricmp(arg, \"-scale-bits\")) {",
          "3484:    CHECK_NEXT_ARG",
          "3485:    smenc_opts.scale_bits = atoi(argv[i + 1]);",
          "3486:    i++;",
          "3487:   }",
          "3488:   else if (!stricmp(arg, \"-global-quant\")) {",
          "3489:    CHECK_NEXT_ARG",
          "3490:    smenc_opts.resolution = atoi(argv[i + 1]);",
          "3491:    smenc_opts.auto_quant = 2;",
          "3492:    i++;",
          "3493:   }",
          "3495:   else if (!stricmp(arg, \"-ctx-out\") || !stricmp(arg, \"-outctx\")) {",
          "3496:    CHECK_NEXT_ARG",
          "3497:    output_ctx = argv[i + 1];",
          "3498:    i++;",
          "3499:   }",
          "3500:   else if (!stricmp(arg, \"-ctx-in\") || !stricmp(arg, \"-inctx\")) {",
          "3501:    CHECK_NEXT_ARG",
          "3502:    chunk_mode = GF_TRUE;",
          "3503:    input_ctx = argv[i + 1];",
          "3504:    i++;",
          "3505:   }",
          "3508: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "3509:   else if (!strcmp(arg, \"-crypt\")) {",
          "3510:    CHECK_NEXT_ARG",
          "3511:    crypt = 1;",
          "3512:    drm_file = argv[i + 1];",
          "3513:    open_edit = GF_TRUE;",
          "3514:    i += 1;",
          "3515:   }",
          "3516:   else if (!strcmp(arg, \"-decrypt\")) {",
          "3517:    CHECK_NEXT_ARG",
          "3518:    crypt = 2;",
          "3519:    if (get_file_type_by_ext(argv[i + 1]) != 1) {",
          "3520:     drm_file = argv[i + 1];",
          "3521:     i += 1;",
          "3522:    }",
          "3523:    open_edit = GF_TRUE;",
          "3524:   }",
          "3525:   else if (!stricmp(arg, \"-set-kms\")) {",
          "3526:    char szTK[20], *ext;",
          "3527:    CHECK_NEXT_ARG",
          "3528:    tracks = gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act + 1));",
          "3529:    memset(&tracks[nb_track_act], 0, sizeof(TrackAction));",
          "3531:    strncpy(szTK, argv[i + 1], 19);",
          "3532:    ext = strchr(szTK, '=');",
          "3533:    tracks[nb_track_act].act_type = TRAC_ACTION_SET_KMS_URI;",
          "3534:    tracks[nb_track_act].trackID = 0;",
          "3535:    if (!strnicmp(argv[i + 1], \"all=\", 4)) {",
          "3536:     tracks[nb_track_act].kms = argv[i + 1] + 4;",
          "3537:    }",
          "3538:    else if (!ext) {",
          "3539:     tracks[nb_track_act].kms = argv[i + 1];",
          "3540:    }",
          "3541:    else {",
          "3542:     tracks[nb_track_act].kms = ext + 1;",
          "3543:     ext[0] = 0;",
          "3544:     tracks[nb_track_act].trackID = atoi(szTK);",
          "3545:     ext[0] = '=';",
          "3546:    }",
          "3547:    open_edit = GF_TRUE;",
          "3548:    nb_track_act++;",
          "3549:    i++;",
          "3551:   else if (!stricmp(arg, \"-split\")) {",
          "3552:    CHECK_NEXT_ARG",
          "3553:    split_duration = atof(argv[i + 1]);",
          "3554:    if (split_duration < 0) split_duration = 0;",
          "3555:    i++;",
          "3556:    split_size = 0;",
          "3558:   else if (!stricmp(arg, \"-split-rap\") || !stricmp(arg, \"-splitr\")) {",
          "3559:    CHECK_NEXT_ARG",
          "3560:    split_duration = -1;",
          "3561:    split_size = -1;",
          "3563:   else if (!stricmp(arg, \"-split-size\") || !stricmp(arg, \"-splits\")) {",
          "3564:    CHECK_NEXT_ARG",
          "3565:    split_size = (u32)atoi(argv[i + 1]);",
          "3566:    i++;",
          "3567:    split_duration = 0;",
          "3569:   else if (!stricmp(arg, \"-split-chunk\") || !stricmp(arg, \"-splitx\") || !stricmp(arg, \"-splitz\")) {",
          "3570:    CHECK_NEXT_ARG",
          "3571:    if (!strstr(argv[i + 1], \":\")) {",
          "3572:     fprintf(stderr, \"Chunk extraction usage: \\\"-splitx start:end\\\" expressed in seconds\\n\");",
          "3573:     return 2;",
          "3574:    }",
          "3575:    if (strstr(argv[i + 1], \"end\")) {",
          "3576:     if (strstr(argv[i + 1], \"end-\")) {",
          "3577:      Double dur_end=0;",
          "3578:      sscanf(argv[i + 1], \"%lf:end-%lf\", &split_start, &dur_end);",
          "3579:      split_duration = -2 - dur_end;",
          "3580:     } else {",
          "3581:      sscanf(argv[i + 1], \"%lf:end\", &split_start);",
          "3582:      split_duration = -2;",
          "3583:     }",
          "3584:    }",
          "3585:    else {",
          "3586:     if (strchr(argv[i + 1], '-')) {",
          "3587:      split_range_str = argv[i + 1];",
          "3588:     } else {",
          "3589:      sscanf(argv[i + 1], \"%lf:%lf\", &split_start, &split_duration);",
          "3590:      split_duration -= split_start;",
          "3591:     }",
          "3593:    split_size = 0;",
          "3594:    if (!stricmp(arg, \"-splitz\")) adjust_split_end = 1;",
          "3595:    i++;",
          "3596:   }",
          "3598:   else if (!stricmp(arg, \"-set-meta\")) {",
          "3599:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3600:    parse_meta_args(&metas[nb_meta_act], META_ACTION_SET_TYPE, argv[i + 1]);",
          "3601:    nb_meta_act++;",
          "3602:    open_edit = GF_TRUE;",
          "3603:    i++;",
          "3604:   }",
          "3605:   else if (!stricmp(arg, \"-add-item\")) {",
          "3606:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3607:    parse_meta_args(&metas[nb_meta_act], META_ACTION_ADD_ITEM, argv[i + 1]);",
          "3608:    nb_meta_act++;",
          "3609:    open_edit = GF_TRUE;",
          "3610:    i++;",
          "3611:   }",
          "3612:   else if (!stricmp(arg, \"-add-image\")) {",
          "3613:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3614:    parse_meta_args(&metas[nb_meta_act], META_ACTION_ADD_IMAGE_ITEM, argv[i + 1]);",
          "3615:    nb_meta_act++;",
          "3616:    open_edit = GF_TRUE;",
          "3617:    i++;",
          "3618:   }",
          "3619:   else if (!stricmp(arg, \"-add-image-grid\")) {",
          "3620:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3621:    parse_meta_args(&metas[nb_meta_act], META_ACTION_ADD_IMAGE_GRID, argv[i + 1]);",
          "3622:    nb_meta_act++;",
          "3623:    open_edit = GF_TRUE;",
          "3624:    i++;",
          "3625:   }",
          "3626:   else if (!stricmp(arg, \"-rem-item\")) {",
          "3627:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3628:    parse_meta_args(&metas[nb_meta_act], META_ACTION_REM_ITEM, argv[i + 1]);",
          "3629:    nb_meta_act++;",
          "3630:    open_edit = GF_TRUE;",
          "3631:    i++;",
          "3632:   }",
          "3633:   else if (!stricmp(arg, \"-set-primary\")) {",
          "3634:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3635:    parse_meta_args(&metas[nb_meta_act], META_ACTION_SET_PRIMARY_ITEM, argv[i + 1]);",
          "3636:    nb_meta_act++;",
          "3637:    open_edit = GF_TRUE;",
          "3638:    i++;",
          "3639:   }",
          "3640:   else if (!stricmp(arg, \"-set-xml\")) {",
          "3641:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3642:    parse_meta_args(&metas[nb_meta_act], META_ACTION_SET_XML, argv[i + 1]);",
          "3643:    nb_meta_act++;",
          "3644:    open_edit = GF_TRUE;",
          "3645:    i++;",
          "3646:   }",
          "3647:   else if (!stricmp(arg, \"-rem-xml\")) {",
          "3648:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3649:    if (parse_meta_args(&metas[nb_meta_act], META_ACTION_REM_XML, argv[i + 1])) i++;",
          "3650:    nb_meta_act++;",
          "3651:    open_edit = GF_TRUE;",
          "3653:   else if (!stricmp(arg, \"-dump-xml\")) {",
          "3654:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3655:    parse_meta_args(&metas[nb_meta_act], META_ACTION_DUMP_XML, argv[i + 1]);",
          "3656:    nb_meta_act++;",
          "3657:    i++;",
          "3659:   else if (!stricmp(arg, \"-dump-item\")) {",
          "3660:    metas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));",
          "3661:    parse_meta_args(&metas[nb_meta_act], META_ACTION_DUMP_ITEM, argv[i + 1]);",
          "3662:    nb_meta_act++;",
          "3663:    i++;",
          "3665:   else if (!stricmp(arg, \"-group-add\") || !stricmp(arg, \"-group-rem-track\") || !stricmp(arg, \"-group-rem\") ) {",
          "3666:    TSELActionType act_type;",
          "3667:    if (!stricmp(arg, \"-group-rem\")) {",
          "3668:     act_type = TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP;",
          "3669:    }",
          "3670:    else if (!stricmp(arg, \"-group-rem-track\")) {",
          "3671:     act_type = TSEL_ACTION_REMOVE_TSEL;",
          "3672:    }",
          "3673:    else {",
          "3674:     act_type = TSEL_ACTION_SET_PARAM;",
          "3675:    }",
          "3676:    if (parse_tsel_args(&tsel_acts, argv[i + 1], &nb_tsel_acts, act_type) == 0) {",
          "3677:     fprintf(stderr, \"Invalid group syntax - check usage\\n\");",
          "3678:     return 2;",
          "3680:    open_edit = GF_TRUE;",
          "3681:    i++;",
          "3682:   }",
          "3683:   else if (!stricmp(arg, \"-group-clean\")) {",
          "3684:    clean_groups = 1;",
          "3685:    open_edit = GF_TRUE;",
          "3686:   }",
          "3687:   else if (!stricmp(arg, \"-group-single\")) {",
          "3688:    single_group = 1;",
          "3689:   }",
          "3690:   else if (!stricmp(arg, \"-package\")) {",
          "3691:    CHECK_NEXT_ARG",
          "3692:    pack_file = argv[i + 1];",
          "3693:    i++;",
          "3694:   }",
          "3695:   else if (!stricmp(arg, \"-zmov\")) {",
          "3696:    compress_moov = GF_TRUE;",
          "3698:   else if (!stricmp(arg, \"-mgt\")) {",
          "3699:    CHECK_NEXT_ARG",
          "3700:    pack_file = argv[i + 1];",
          "3701:    pack_wgt = GF_TRUE;",
          "3702:    i++;",
          "3704:   else if (!stricmp(arg, \"-brand\")) {",
          "3705:    char *b = argv[i + 1];",
          "3706:    CHECK_NEXT_ARG",
          "3707:    major_brand = GF_4CC(b[0], b[1], b[2], b[3]);",
          "3708:    open_edit = GF_TRUE;",
          "3709:    if (b[4] == ':') {",
          "3710:     if (!strncmp(b+5, \"0x\", 2))",
          "3711:      sscanf(b+5, \"0x%x\", &minor_version);",
          "3712:     else",
          "3713:      minor_version = atoi(b + 5);",
          "3715:    i++;",
          "3717:   else if (!stricmp(arg, \"-ab\")) {",
          "3718:    char *b = argv[i + 1];",
          "3719:    CHECK_NEXT_ARG",
          "3720:    brand_add = (u32*)gf_realloc(brand_add, sizeof(u32) * (nb_alt_brand_add + 1));",
          "3721:    brand_add[nb_alt_brand_add] = GF_4CC(b[0], b[1], b[2], b[3]);",
          "3722:    nb_alt_brand_add++;",
          "3723:    open_edit = GF_TRUE;",
          "3724:    i++;",
          "3725:   }",
          "3726:   else if (!stricmp(arg, \"-rb\")) {",
          "3727:    char *b = argv[i + 1];",
          "3728:    CHECK_NEXT_ARG",
          "3729:    brand_rem = (u32*)gf_realloc(brand_rem, sizeof(u32) * (nb_alt_brand_rem + 1));",
          "3730:    brand_rem[nb_alt_brand_rem] = GF_4CC(b[0], b[1], b[2], b[3]);",
          "3731:    nb_alt_brand_rem++;",
          "3732:    open_edit = GF_TRUE;",
          "3733:    i++;",
          "3734:   }",
          "3735: #endif",
          "3736:   else if (!stricmp(arg, \"-languages\")) {",
          "3737:    PrintLanguages();",
          "3738:    return 1;",
          "3739:   }",
          "3740:   else if (!stricmp(arg, \"-h\")) {",
          "3741:    gf_sys_set_args(argc, (const char**) argv);",
          "3743:    if (i + 1 == (u32)argc) PrintUsage();",
          "3744:    else if (!strcmp(argv[i + 1], \"general\")) PrintGeneralUsage();",
          "3745:    else if (!strcmp(argv[i + 1], \"extract\")) PrintExtractUsage();",
          "3746:    else if (!strcmp(argv[i + 1], \"split\")) PrintSplitUsage();",
          "3747:    else if (!strcmp(argv[i + 1], \"dash\")) PrintDASHUsage();",
          "3748:    else if (!strcmp(argv[i + 1], \"dump\")) PrintDumpUsage();",
          "3749:    else if (!strcmp(argv[i + 1], \"import\")) PrintImportUsage();",
          "3750:    else if (!strcmp(argv[i + 1], \"format\")) fprintf(stderr, \"deprectaed, see [filters documentation](Filters)\\n\");",
          "3751:    else if (!strcmp(argv[i + 1], \"hint\")) PrintHintUsage();",
          "3752:    else if (!strcmp(argv[i + 1], \"encode\")) PrintEncodeUsage();",
          "3753:    else if (!strcmp(argv[i + 1], \"crypt\")) PrintEncryptUsage();",
          "3754:    else if (!strcmp(argv[i + 1], \"meta\")) PrintMetaUsage();",
          "3755:    else if (!strcmp(argv[i + 1], \"swf\")) PrintSWFUsage();",
          "3756: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "3757:    else if (!strcmp(argv[i + 1], \"rtp\")) fprintf(stderr, \"RTP streaming deprecated in MP4Box, use gpac application\\n\");",
          "3758:    else if (!strcmp(argv[i + 1], \"live\")) PrintLiveUsage();",
          "3759: #endif",
          "3760:    else if (!strcmp(argv[i + 1], \"core\")) PrintCoreUsage();",
          "3761:    else if (!strcmp(argv[i + 1], \"tags\")) PrintTags();",
          "3762:    else if (!strcmp(argv[i + 1], \"cicp\")) PrintCICP();",
          "3763:    else if (!strcmp(argv[i + 1], \"all\")) {",
          "3764:     PrintGeneralUsage();",
          "3765:     PrintExtractUsage();",
          "3766:     PrintDASHUsage();",
          "3767:     PrintSplitUsage();",
          "3768:     PrintDumpUsage();",
          "3769:     PrintImportUsage();",
          "3770:     PrintHintUsage();",
          "3771:     PrintEncodeUsage();",
          "3772:     PrintEncryptUsage();",
          "3773:     PrintMetaUsage();",
          "3774:     PrintSWFUsage();",
          "3775: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "3776:     PrintLiveUsage();",
          "3777: #endif",
          "3778:     PrintCoreUsage();",
          "3779:     PrintTags();",
          "3780:     PrintCICP();",
          "3781:    } else if (!strcmp(argv[i + 1], \"opts\")) {",
          "3782:     PrintHelp(\"@\", GF_FALSE, GF_FALSE);",
          "3783:    } else {",
          "3784:     PrintHelp(argv[i+1], GF_FALSE, GF_FALSE);",
          "3786:    return 1;",
          "3787:   }",
          "3788:   else if (!stricmp(arg, \"-hx\")) {",
          "3789:    if (i + 1 == (u32)argc) PrintUsage();",
          "3790:    else PrintHelp(argv[i+1], GF_TRUE, GF_FALSE);",
          "3791:    return 1;",
          "3793:   else if (!strcmp(arg, \"-genmd\")) {",
          "3794:    help_flags = GF_PRINTARG_MD | GF_PRINTARG_IS_APP;",
          "3795:    helpout = gf_fopen(\"mp4box-gen-opts.md\", \"w\");",
          "3797:     fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb General\");",
          "3798:     fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "3799:    fprintf(helpout, \"# Syntax\\n\");",
          "3800:    gf_sys_format_help(helpout, help_flags, \"MP4Box [option] input [option] [other_dash_inputs]\\n\"",
          "3801:     \"  \\n\"",
          "3802:    );",
          "3803:    PrintGeneralUsage();",
          "3804:    PrintEncryptUsage();",
          "3805:    fprintf(helpout, \"# Help Options\\n\");",
          "3806:    while (m4b_usage_args[i].name) {",
          "3807:     GF_GPACArg *g_arg = &m4b_usage_args[i];",
          "3808:     i++;",
          "3809:     gf_sys_print_arg(helpout, help_flags, g_arg, \"mp4box-general\");",
          "3810:    }",
          "3812:    gf_fclose(helpout);",
          "3814:    helpout = gf_fopen(\"mp4box-import-opts.md\", \"w\");",
          "3815:     fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Import\");",
          "3816:     fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "3817:    PrintImportUsage();",
          "3818:    gf_fclose(helpout);",
          "3820:    helpout = gf_fopen(\"mp4box-dash-opts.md\", \"w\");",
          "3821:     fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media DASH\");",
          "3822:     fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "3823:    PrintDASHUsage();",
          "3824:    gf_fclose(helpout);",
          "3826:    helpout = gf_fopen(\"mp4box-dump-opts.md\", \"w\");",
          "3827:     fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Dump and Export\");",
          "3828:     fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "3829:    PrintExtractUsage();",
          "3830:    PrintDumpUsage();",
          "3831:    gf_fclose(helpout);",
          "3833:    helpout = gf_fopen(\"mp4box-meta-opts.md\", \"w\");",
          "3834:     fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Meta and HEIF/IFF\");",
          "3835:     fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "3836:    PrintMetaUsage();",
          "3837:    gf_fclose(helpout);",
          "3840:    helpout = gf_fopen(\"mp4box-scene-opts.md\", \"w\");",
          "3841:     fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Scene Description\");",
          "3842:     fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "3843:    PrintEncodeUsage();",
          "3844: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "3845:    PrintLiveUsage();",
          "3846: #endif",
          "3847:    PrintSWFUsage();",
          "3848:    gf_fclose(helpout);",
          "3850:    helpout = gf_fopen(\"mp4box-other-opts.md\", \"w\");",
          "3851:     fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Other Features\");",
          "3852:     fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "3853:    PrintHintUsage();",
          "3854:    PrintTags();",
          "3855:    gf_fclose(helpout);",
          "3857:    gf_sys_close();",
          "3858:    return 1;",
          "3859:   } else if (!strcmp(arg, \"-genman\")) {",
          "3860:    help_flags = GF_PRINTARG_MAN;",
          "3861:    helpout = gf_fopen(\"mp4box.1\", \"w\");",
          "3864:     fprintf(helpout, \".TH MP4Box 1 2019 MP4Box GPAC\\n\");",
          "3865:    fprintf(helpout, \".\\n.SH NAME\\n.LP\\nMP4Box \\\\- GPAC command-line media packager\\n.SH SYNOPSIS\\n.LP\\n.B MP4Box\\n.RI [options] \\\\ [file] \\\\ [options]\\n.br\\n.\\n\");",
          "3867:    PrintGeneralUsage();",
          "3868:    PrintExtractUsage();",
          "3869:    PrintDASHUsage();",
          "3870:    PrintSplitUsage();",
          "3871:    PrintDumpUsage();",
          "3872:    PrintImportUsage();",
          "3873:    PrintHintUsage();",
          "3874:    PrintEncodeUsage();",
          "3875:    PrintEncryptUsage();",
          "3876:    PrintMetaUsage();",
          "3877:    PrintSWFUsage();",
          "3878:    PrintTags();",
          "3879: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "3880:    PrintLiveUsage();",
          "3881: #endif",
          "3883:    fprintf(helpout, \".SH EXAMPLES\\n.TP\\nBasic and advanced examples are available at https://wiki.gpac.io/MP4Box\\n\");",
          "3884:    fprintf(helpout, \".SH MORE\\n.LP\\nAuthors: GPAC developers, see git repo history (-log)\\n\"",
          "3885:    \".br\\nFor bug reports, feature requests, more information and source code, visit https://github.com/gpac/gpac\\n\"",
          "3886:    \".br\\nbuild: %s\\n\"",
          "3887:    \".br\\nCopyright: %s\\n.br\\n\"",
          "3888:    \".SH SEE ALSO\\n\"",
          "3889:    \".LP\\ngpac(1), MP4Client(1)\\n\", gf_gpac_version(), gf_gpac_copyright());",
          "3891:    gf_fclose(helpout);",
          "3892:    gf_sys_close();",
          "3893:    return 1;",
          "3894:   }",
          "3896:   else if (!stricmp(arg, \"-v\")) verbose++;",
          "3897:   else if (!stricmp(arg, \"-tag-list\")) {",
          "3898:    fprintf(stderr, \"Deprecated, use -h tags.\\n\");",
          "3899:    return 1;",
          "3900:   }",
          "3901:   else if (!live_scene) {",
          "3902:    u32 res = gf_sys_is_gpac_arg(arg);",
          "3903:    if (res==0) {",
          "3904:     PrintHelp(arg, GF_FALSE, GF_TRUE);",
          "3905:     return 2;",
          "3906:    } else if (res==2) {",
          "3907:     i++;",
          "3908:    }",
          "3912:  return 0;",
          "3915: Bool mp4box_parse_args(int argc, char **argv)",
          "3919:  for (i = 1; i < (u32)argc; i++) {",
          "3920:   char *arg = argv[i];",
          "3922:   if ((arg[0] != '-') || !stricmp(arg, \"--\")) {",
          "3923:    char *arg_val = arg;",
          "3924:    if (!stricmp(arg, \"--\")) {",
          "3925:     CHECK_NEXT_ARG",
          "3926:     arg_val = argv[i + 1];",
          "3927:     i++;",
          "3928:    }",
          "3929:    if (argc < 3) {",
          "3930:     fprintf(stderr, \"Error - only one input file found as argument, please check usage\\n\");",
          "3931:     return 2;",
          "3932:    }",
          "3933:    else if (inName) {",
          "3934:     if (dash_duration) {",
          "3935:      if (!nb_dash_inputs) {",
          "3936:       dash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);",
          "3937:      }",
          "3938:      dash_inputs = set_dash_input(dash_inputs, arg_val, &nb_dash_inputs);",
          "3939:     }",
          "3940:     else {",
          "3941:      fprintf(stderr, \"Error - 2 input names specified, please check usage\\n\");",
          "3942:      return 2;",
          "3943:     }",
          "3944:    }",
          "3945:    else {",
          "3946:     inName = arg_val;",
          "3947:    }",
          "3948:   }",
          "3949:   else if (!stricmp(arg, \"-?\")) {",
          "3950:    PrintUsage();",
          "3951:    return 1;",
          "3952:   }",
          "3953:   else if (!stricmp(arg, \"-version\")) {",
          "3954:    PrintVersion();",
          "3955:    return 1;",
          "3956:   }",
          "3957:   else if (!stricmp(arg, \"-sdp\")) print_sdp = 1;",
          "3958:         else if (!strcmp(argv[i], \"-mem-track\")) continue;",
          "3959:         else if (!strcmp(argv[i], \"-mem-track-stack\")) continue;",
          "3960:         else if (!strcmp(argv[i], \"-p\")) {",
          "3961:          i++;",
          "3962:          continue;",
          "3963:   }",
          "3964:         else if (!strncmp(argv[i], \"-p=\", 3)) continue;",
          "3965:   else if (!stricmp(arg, \"-logs\") || !strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {",
          "3966:    i++;",
          "3967:   }",
          "3968:   else if (!stricmp(arg, \"-tracks\")) get_nb_tracks = 1;",
          "3969:   else if (!stricmp(arg, \"-info\") || !stricmp(arg, \"-infon\")) {",
          "3970:    print_info = 1;",
          "3971:    if ((i + 1<(u32)argc) && (sscanf(argv[i + 1], \"%u\", &info_track_id) == 1)) {",
          "3972:     char szTk[20];",
          "3973:     sprintf(szTk, \"%u\", info_track_id);",
          "3974:     if (!strcmp(szTk, argv[i + 1])) i++;",
          "3975:     else info_track_id = 0;",
          "3977:     if (!stricmp(arg, \"-infon\")) print_info = 2;",
          "3978:    }",
          "3979:    else {",
          "3980:     info_track_id = 0;",
          "3981:    }",
          "3982:   }",
          "3983:   else if (!stricmp(arg, \"-grab-ts\")) {",
          "3984:    fprintf(stderr, \"Deprecated option - use gpac application\\n\");",
          "3985:    return mp4box_cleanup(2);",
          "3986:   }",
          "3987:   else if (!stricmp(arg, \"-atsc\")) {",
          "3988:    fprintf(stderr, \"Deprecated option - use gpac application\\n\");",
          "3989:    return mp4box_cleanup(2);",
          "3990:   }",
          "3991: #if !defined(GPAC_DISABLE_CORE_TOOLS)",
          "3992:   else if (!stricmp(arg, \"-wget\")) {",
          "3993:    CHECK_NEXT_ARG",
          "3994:    do_wget = argv[i + 1];",
          "3995:    i++;",
          "3996:   }",
          "3997: #endif",
          "3999:   else if (!stricmp(arg, \"-dvbhdemux\")) {",
          "4000:    dvbhdemux = GF_TRUE;",
          "4001:   }",
          "4003: #ifndef GPAC_DISABLE_MEDIA_EXPORT",
          "4004:   else if (!stricmp(arg, \"-raw\")) {",
          "4005:    CHECK_NEXT_ARG",
          "4006:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_NATIVE);",
          "4007:    i++;",
          "4008:   }",
          "4009:   else if (!stricmp(arg, \"-raw-layer\")) {",
          "4010:    CHECK_NEXT_ARG",
          "4011:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_NATIVE | GF_EXPORT_SVC_LAYER);",
          "4012:    i++;",
          "4013:   }",
          "4014:   else if (!stricmp(arg, \"-qcp\")) {",
          "4015:    CHECK_NEXT_ARG",
          "4016:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_NATIVE | GF_EXPORT_USE_QCP);",
          "4017:    i++;",
          "4018:   }",
          "4019:   else if (!stricmp(arg, \"-aviraw\")) {",
          "4020:    CHECK_NEXT_ARG",
          "4021:    if (argv[i + 1] && !stricmp(argv[i + 1], \"video\")) trackID = 1;",
          "4022:    else if (argv[i + 1] && !stricmp(argv[i + 1], \"audio\")) {",
          "4023:     if (strlen(argv[i + 1]) == 5) trackID = 2;",
          "4024:     else trackID = 1 + atoi(argv[i + 1] + 5);",
          "4025:    } else {",
          "4026:     fprintf(stderr, \"Usage: \\\"-aviraw video\\\" or \\\"-aviraw audio\\\"\\n\");",
          "4027:     return 2;",
          "4028:    }",
          "4029:    track_dump_type = GF_EXPORT_AVI_NATIVE;",
          "4030:    i++;",
          "4031:   }",
          "4032:   else if (!stricmp(arg, \"-raws\")) {",
          "4033:    CHECK_NEXT_ARG",
          "4034:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_RAW_SAMPLES);",
          "4035:    i++;",
          "4036:   }",
          "4037:   else if (!stricmp(arg, \"-nhnt\")) {",
          "4038:    CHECK_NEXT_ARG",
          "4039:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_NHNT);",
          "4040:    i++;",
          "4041:   }",
          "4042:   else if (!stricmp(arg, \"-nhml\")) {",
          "4043:    CHECK_NEXT_ARG",
          "4044:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_NHML);",
          "4045:    i++;",
          "4046:   }",
          "4047:   else if (!stricmp(arg, \"-webvtt-raw\")) {",
          "4048:    CHECK_NEXT_ARG",
          "4049:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_WEBVTT_META);",
          "4050:    i++;",
          "4051:   }",
          "4052:   else if (!stricmp(arg, \"-six\")) {",
          "4053:    CHECK_NEXT_ARG",
          "4054:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_SIX);",
          "4055:    i++;",
          "4056:   }",
          "4057:   else if (!stricmp(arg, \"-avi\")) {",
          "4058:    CHECK_NEXT_ARG",
          "4059:    track_dump_type = create_new_track_action(argv[i + 1], &tracks, &nb_track_act, GF_EXPORT_AVI);",
          "4060:    if (tracks[nb_track_act-1].trackID)",
          "4061:     i++;",
          "4062:   }",
          "4064: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "4065:   else if (!stricmp(arg, \"-rtp\")) {",
          "4066:    fprintf(stderr, \"Deprecated option - use gpac application\\n\");",
          "4067:    return mp4box_cleanup(2);",
          "4068:   }",
          "4069:   else if (!stricmp(arg, \"-live\")) {",
          "4070:    live_scene = GF_TRUE;",
          "4071:   }",
          "4072: #endif",
          "4073:   else if (!stricmp(arg, \"-diod\")) {",
          "4074:    dump_iod = GF_TRUE;",
          "4075:   }",
          "4076: #ifndef GPAC_DISABLE_VRML",
          "4077:   else if (!stricmp(arg, \"-node\")) {",
          "4078:    CHECK_NEXT_ARG",
          "4079:    PrintNode(argv[i + 1], 0);",
          "4080:    return 1;",
          "4081:   }",
          "4082:   else if (!stricmp(arg, \"-xnode\")) {",
          "4083:    CHECK_NEXT_ARG",
          "4084:    PrintNode(argv[i + 1], 1);",
          "4085:    return 1;",
          "4086:   }",
          "4087:   else if (!stricmp(arg, \"-nodes\") || !stricmp(arg, \"-nodex\")) {",
          "4088:    PrintBuiltInNodes(0, !stricmp(arg, \"-nodex\") ? GF_TRUE : GF_FALSE);",
          "4089:    return 1;",
          "4090:   }",
          "4091:   else if (!stricmp(arg, \"-xnodes\") || !stricmp(arg, \"-xnodex\")) {",
          "4092:    PrintBuiltInNodes(1, !stricmp(arg, \"-xnodex\") ? GF_TRUE : GF_FALSE);",
          "4093:    return 1;",
          "4094:   }",
          "4095: #endif",
          "4096: #ifndef GPAC_DISABLE_SVG",
          "4097:   else if (!stricmp(arg, \"-snodes\")) {",
          "4098:    PrintBuiltInNodes(2, GF_FALSE);",
          "4099:    return 1;",
          "4100:   }",
          "4101: #endif",
          "4102:   else if (!stricmp(arg, \"-boxcov\")) {",
          "4103:    gf_sys_set_args(argc, (const char **) argv);",
          "4104:             PrintBuiltInBoxes(GF_TRUE);",
          "4105:    return 1;",
          "4106:   } else if (!stricmp(arg, \"-boxes\")) {",
          "4107:    PrintBuiltInBoxes(GF_FALSE);",
          "4108:    return 1;",
          "4109:   }",
          "4110:   else if (!stricmp(arg, \"-std\")) dump_std = 2;",
          "4111:   else if (!stricmp(arg, \"-stdb\")) dump_std = 1;",
          "4112:   else if (!stricmp(arg, \"-fstat\")) fs_dump_flags |= 1;",
          "4113:   else if (!stricmp(arg, \"-fgraph\")) fs_dump_flags |= 1<<1;",
          "4115: #if !defined(GPAC_DISABLE_MEDIA_EXPORT) && !defined(GPAC_DISABLE_SCENE_DUMP)",
          "4116:   else if (!stricmp(arg, \"-keep-ods\")) no_odf_conf = GF_TRUE;",
          "4117:   else if (!stricmp(arg, \"-bt\")) dump_mode = GF_SM_DUMP_BT;",
          "4118:   else if (!stricmp(arg, \"-xmt\")) dump_mode = GF_SM_DUMP_XMTA;",
          "4119:   else if (!stricmp(arg, \"-wrl\")) dump_mode = GF_SM_DUMP_VRML;",
          "4120:   else if (!stricmp(arg, \"-x3dv\")) dump_mode = GF_SM_DUMP_X3D_VRML;",
          "4121:   else if (!stricmp(arg, \"-x3d\")) dump_mode = GF_SM_DUMP_X3D_XML;",
          "4122:   else if (!stricmp(arg, \"-lsr\")) dump_mode = GF_SM_DUMP_LASER;",
          "4123:   else if (!stricmp(arg, \"-svg\")) dump_mode = GF_SM_DUMP_SVG;",
          "4126:   else if (!stricmp(arg, \"-stat\")) stat_level = 1;",
          "4127:   else if (!stricmp(arg, \"-stats\")) stat_level = 2;",
          "4128:   else if (!stricmp(arg, \"-statx\")) stat_level = 3;",
          "4129:   else if (!stricmp(arg, \"-diso\")) dump_isom = 1;",
          "4130:   else if (!stricmp(arg, \"-dxml\")) dump_isom = 2;",
          "4131:   else if (!stricmp(arg, \"-disox\")) dump_isom = 3;",
          "4132:   else if (!stricmp(arg, \"-mergevtt\")) merge_vtt_cues = GF_TRUE;",
          "4133:   else if (!stricmp(arg, \"-dump-cover\")) dump_cart = 1;",
          "4134:   else if (!stricmp(arg, \"-dump-chap\")) dump_chap = 1;",
          "4135:   else if (!stricmp(arg, \"-dump-chap-ogg\")) dump_chap = 2;",
          "4136:   else if (!stricmp(arg, \"-dump-chap-zoom\")) dump_chap = 3;",
          "4137:   else if (!stricmp(arg, \"-hash\")) do_hash = GF_TRUE;",
          "4138:   else if (!strnicmp(arg, \"-comp\", 5)) {",
          "4139:    CHECK_NEXT_ARG",
          "4141:    if (strchr(arg, 'x')) comp_top_box_version = 1;",
          "4142:    else if (strchr(arg, 'f')) comp_top_box_version = 2;",
          "4144:    if (strchr(arg, 'l')) comp_lzma = GF_TRUE;",
          "4146:    compress_top_boxes = argv[i + 1];",
          "4147:    i++;",
          "4148:   }",
          "4149:   else if (!strnicmp(arg, \"-topsize\", 8)) {",
          "4150:    CHECK_NEXT_ARG",
          "4151:    size_top_box = 1;",
          "4152:    compress_top_boxes = argv[i + 1];",
          "4153:    i++;",
          "4154:   }",
          "4155:   else if (!strnicmp(arg, \"-topcount\", 8)) {",
          "4156:    CHECK_NEXT_ARG",
          "4157:    size_top_box = 2;",
          "4158:    compress_top_boxes = argv[i + 1];",
          "4159:    i++;",
          "4160:   }",
          "4161:   else if (!stricmp(arg, \"-mpd-rip\")) do_mpd_rip = GF_TRUE;",
          "4162:   else if (!strcmp(arg, \"-init-seg\")) {",
          "4163:    CHECK_NEXT_ARG",
          "4164:    use_init_seg = argv[i + 1];",
          "4165:    i += 1;",
          "4166:   }",
          "4168: #ifndef GPAC_DISABLE_CORE_TOOLS",
          "4169:   else if (!stricmp(arg, \"-bin\")) do_bin_xml = GF_TRUE;",
          "4170: #endif",
          "4171:   else if (!stricmp(arg, \"-dump-udta\")) {",
          "4172:    char *sep, *code;",
          "4173:    CHECK_NEXT_ARG",
          "4174:    sep = strchr(argv[i + 1], ':');",
          "4175:    if (sep) {",
          "4176:     sep[0] = 0;",
          "4177:     dump_udta_track = atoi(argv[i + 1]);",
          "4178:     sep[0] = ':';",
          "4179:     code = &sep[1];",
          "4180:    }",
          "4181:    else {",
          "4182:     code = argv[i + 1];",
          "4183:    }",
          "4184:    if (strlen(code) == 4) {",
          "4185:     dump_udta_type = GF_4CC(code[0], code[1], code[2], code[3]);",
          "4186:    } else if (strlen(code) == 8) {",
          "4188:     u32 hex1, hex2, hex3, hex4;",
          "4189:     if (sscanf(code, \"%02x%02x%02x%02x\", &hex1, &hex2, &hex3, &hex4) != 4) {",
          "4190:      fprintf(stderr, \"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\");",
          "4191:      return mp4box_cleanup(1);",
          "4192:     }",
          "4193:     dump_udta_type = GF_4CC(hex1, hex2, hex3, hex4);",
          "4194:    } else {",
          "4195:     fprintf(stderr, \"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\");",
          "4196:     return mp4box_cleanup(1);",
          "4197:    }",
          "4198:    i++;",
          "4199:   }",
          "4200:   else if (!stricmp(arg, \"-dmp4\")) {",
          "4201:    dump_isom = 1;",
          "4202:    fprintf(stderr, \"WARNING: \\\"-dmp4\\\" is deprecated - use \\\"-diso\\\" option\\n\");",
          "4203:   }",
          "4204:   else if (!stricmp(arg, \"-drtp\")) dump_rtp = 1;",
          "4205:   else if (!stricmp(arg, \"-dts\")) {",
          "4206:    dump_timestamps = 1;",
          "4207:    if (((i + 1<(u32)argc) && inName) || (i + 2<(u32)argc)) {",
          "4208:     if (isdigit(argv[i + 1][0])) {",
          "4209:      program_number = atoi(argv[i + 1]);",
          "4210:      i++;",
          "4211:     }",
          "4212:    }",
          "4213:   }",
          "4214:   else if (!stricmp(arg, \"-dtsx\")) {",
          "4215:    dump_timestamps = 2;",
          "4216:   }",
          "4217:   else if (!stricmp(arg, \"-dtsc\")) {",
          "4218:    dump_timestamps = 3;",
          "4219:   }",
          "4220:   else if (!stricmp(arg, \"-dtsxc\")) {",
          "4221:    dump_timestamps = 4;",
          "4222:   }",
          "4223:   else if (!strnicmp(arg, \"-dnal\", 5)) {",
          "4224:    CHECK_NEXT_ARG",
          "4225:    dump_nal = atoi(argv[i + 1]);",
          "4226:    if (arg[5] == 'c') dump_nal_type |= 1;",
          "4227:    else if (arg[5] == 'd') dump_nal_type |= 2;",
          "4228:    else if (arg[5] == 'x') dump_nal_type |= 2|1;",
          "4229:    i++;",
          "4230:   }",
          "4231:   else if (!strnicmp(arg, \"-dsap\", 5)) {",
          "4232:    CHECK_NEXT_ARG",
          "4233:    dump_saps = atoi(argv[i + 1]);",
          "4234:    if (!stricmp(arg, \"-dsaps\")) dump_saps_mode = 1;",
          "4235:    else if (!stricmp(arg, \"-dsapc\")) dump_saps_mode = 2;",
          "4236:    else if (!stricmp(arg, \"-dsapd\")) dump_saps_mode = 3;",
          "4237:    else if (!stricmp(arg, \"-dsapp\")) dump_saps_mode = 4;",
          "4238:    else dump_saps_mode = 0;",
          "4239:    i++;",
          "4240:   }",
          "4241:   else if (!stricmp(arg, \"-dcr\")) dump_cr = 1;",
          "4242:   else if (!stricmp(arg, \"-ttxt\") || !stricmp(arg, \"-srt\")) {",
          "4243:    if ((i + 1<(u32)argc) && (sscanf(argv[i + 1], \"%u\", &trackID) == 1)) {",
          "4244:     char szTk[20];",
          "4245:     sprintf(szTk, \"%d\", trackID);",
          "4246:     if (!strcmp(szTk, argv[i + 1])) i++;",
          "4247:     else trackID = 0;",
          "4248:    }",
          "4249:    else if ((i + 1<(u32)argc) && !strcmp(argv[i + 1], \"*\")) {",
          "4250:     trackID = (u32)-1;",
          "4251:     i++;",
          "4252:    }",
          "4253:    else {",
          "4254:     trackID = 0;",
          "4255:    }",
          "4256: #ifdef GPAC_DISABLE_ISOM_WRITE",
          "4257:    if (trackID) {",
          "4258:     fprintf(stderr, \"Error: Read-Only version - subtitle conversion not available\\n\");",
          "4259:     return 2;",
          "4260:    }",
          "4261: #endif //GPAC_DISABLE_ISOM_WRITE",
          "4262:    if (!stricmp(arg, \"-ttxt\")) dump_ttxt = GF_TRUE;",
          "4263:    else dump_srt = GF_TRUE;",
          "4264:    import_subtitle = 1;",
          "4265:   }",
          "4266:   else if (!stricmp(arg, \"-dm2ts\")) {",
          "4267:    dump_m2ts = 1;",
          "4268:    if (((i + 1<(u32)argc) && inName) || (i + 2<(u32)argc)) {",
          "4269:     if (argv[i + 1][0] != '-') pes_dump = argv[i + 1];",
          "4270:     i++;",
          "4271:    }",
          "4272:   }",
          "4274: #ifndef GPAC_DISABLE_SWF_IMPORT",
          "4276:   else if (!stricmp(arg, \"-global\")) swf_flags |= GF_SM_SWF_STATIC_DICT;",
          "4277:   else if (!stricmp(arg, \"-no-ctrl\")) swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE;",
          "4278:   else if (!stricmp(arg, \"-no-text\")) swf_flags |= GF_SM_SWF_NO_TEXT;",
          "4279:   else if (!stricmp(arg, \"-no-font\")) swf_flags |= GF_SM_SWF_NO_FONT;",
          "4280:   else if (!stricmp(arg, \"-no-line\")) swf_flags |= GF_SM_SWF_NO_LINE;",
          "4281:   else if (!stricmp(arg, \"-no-grad\")) swf_flags |= GF_SM_SWF_NO_GRADIENT;",
          "4282:   else if (!stricmp(arg, \"-quad\")) swf_flags |= GF_SM_SWF_QUAD_CURVE;",
          "4283:   else if (!stricmp(arg, \"-xlp\")) swf_flags |= GF_SM_SWF_SCALABLE_LINE;",
          "4284:   else if (!stricmp(arg, \"-ic2d\")) swf_flags |= GF_SM_SWF_USE_IC2D;",
          "4285:   else if (!stricmp(arg, \"-same-app\")) swf_flags |= GF_SM_SWF_REUSE_APPEARANCE;",
          "4286:   else if (!stricmp(arg, \"-flatten\")) {",
          "4287:    CHECK_NEXT_ARG",
          "4288:    swf_flatten_angle = (Float)atof(argv[i + 1]);",
          "4289:    i++;",
          "4290:   }",
          "4291: #endif",
          "4292: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "4293:   else if (!stricmp(arg, \"-isma\")) {",
          "4294:    conv_type = GF_ISOM_CONV_TYPE_ISMA;",
          "4295:    open_edit = GF_TRUE;",
          "4296:   }",
          "4297:   else if (!stricmp(arg, \"-3gp\")) {",
          "4298:    conv_type = GF_ISOM_CONV_TYPE_3GPP;",
          "4299:    open_edit = GF_TRUE;",
          "4300:   }",
          "4301:   else if (!stricmp(arg, \"-ipod\")) {",
          "4302:    conv_type = GF_ISOM_CONV_TYPE_IPOD;",
          "4303:    open_edit = GF_TRUE;",
          "4304:   }",
          "4305:   else if (!stricmp(arg, \"-psp\")) {",
          "4306:    conv_type = GF_ISOM_CONV_TYPE_PSP;",
          "4307:    open_edit = GF_TRUE;",
          "4308:   }",
          "4309:   else if (!stricmp(arg, \"-ismax\")) {",
          "4310:    conv_type = GF_ISOM_CONV_TYPE_ISMA_EX;",
          "4311:    open_edit = GF_TRUE;",
          "4312:   }",
          "4314:   else if (!stricmp(arg, \"-no-sys\") || !stricmp(arg, \"-nosys\")) {",
          "4315:    remove_sys_tracks = 1;",
          "4316:    open_edit = GF_TRUE;",
          "4317:   }",
          "4318:   else if (!stricmp(arg, \"-no-iod\")) {",
          "4319:    remove_root_od = 1;",
          "4320:    open_edit = GF_TRUE;",
          "4321:   }",
          "4322:   else if (!stricmp(arg, \"-out\")) {",
          "4323:    CHECK_NEXT_ARG outName = argv[i + 1];",
          "4324:    i++;",
          "4325:   }",
          "4326:   else if (!stricmp(arg, \"-tmp\")) {",
          "4327:    CHECK_NEXT_ARG tmpdir = argv[i + 1];",
          "4328:    i++;",
          "4329:   }",
          "4330:   else if (!stricmp(arg, \"-co64\")) {",
          "4331:    force_co64 = GF_TRUE;",
          "4332:    open_edit = GF_TRUE;",
          "4333:   }",
          "4334:   else if (!stricmp(arg, \"-write-buffer\")) {",
          "4335:    CHECK_NEXT_ARG",
          "4336:    fprintf(stderr, \"\\tWARNING: \\\"-write-buffer\\\" deprecated and will soon be removed, use -bs-cache-size=%s\\n\", argv[i + 1]);",
          "4337:    gf_opts_set_key(\"temp\", \"bs-cache-size\", argv[i + 1]);",
          "4338:    i++;",
          "4339:   }",
          "4340:   else if (!stricmp(arg, \"-cprt\")) {",
          "4341:    CHECK_NEXT_ARG cprt = argv[i + 1];",
          "4342:    i++;",
          "4343:    if (!dash_duration) open_edit = GF_TRUE;",
          "4344:   }",
          "4345:   else if (!stricmp(arg, \"-chap\") || !stricmp(arg, \"-chapqt\")) {",
          "4346:    CHECK_NEXT_ARG",
          "4347:    chap_file = argv[i + 1];",
          "4348:    i++;",
          "4349:    open_edit = GF_TRUE;",
          "4350:    if (!stricmp(arg, \"-chapqt\")) chap_qt = GF_TRUE;",
          "4351:   }",
          "4352:   else if (!stricmp(arg, \"-inter\") || !stricmp(arg, \"-old-inter\")) {",
          "4353:    CHECK_NEXT_ARG",
          "4354:    interleaving_time = atof(argv[i + 1]) / 1000;",
          "4355:    if (!interleaving_time) do_flat = 2;",
          "4356:    open_edit = GF_TRUE;",
          "4357:    needSave = GF_TRUE;",
          "4358:    no_inplace = GF_TRUE;",
          "4359:    if (!stricmp(arg, \"-old-inter\")) old_interleave = 1;",
          "4360:    i++;",
          "4361:   }",
          "4362:   else if (!stricmp(arg, \"-moovpad\")) {",
          "4363:    CHECK_NEXT_ARG",
          "4364:    moov_pading = atoi(argv[i+1]);",
          "4365:    needSave = GF_TRUE;",
          "4366:    i++;",
          "4367:   }",
          "4368:   else if (!stricmp(arg, \"-no-inplace\")) {",
          "4369:    no_inplace = GF_TRUE;",
          "4370:   }",
          "4371:   else if (!stricmp(arg, \"-frag\")) {",
          "4372:    CHECK_NEXT_ARG",
          "4373:    interleaving_time = atof(argv[i + 1]) / 1000;",
          "4374:    needSave = GF_TRUE;",
          "4375:    i++;",
          "4376:    Frag = GF_TRUE;",
          "4377:   }",
          "4378:   else if (!stricmp(arg, \"-dash\")) {",
          "4379:    CHECK_NEXT_ARG",
          "4380:    dash_duration = atof(argv[i + 1]) / 1000;",
          "4381:    if (dash_duration == 0.0) {",
          "4382:     fprintf(stderr, \"\\tERROR: \\\"-dash-dash_duration\\\": invalid parameter %s\\n\", argv[i + 1]);",
          "4383:     return 2;",
          "4384:    }",
          "4385:    i++;",
          "4386:   }",
          "4387:   else if (!stricmp(arg, \"-dash-strict\")) {",
          "4388:    CHECK_NEXT_ARG",
          "4389:    dash_duration = atof(argv[i + 1]) / 1000;",
          "4390:    if (dash_duration == 0.0) {",
          "4391:     fprintf(stderr, \"\\tERROR: \\\"-dash-dash_duration\\\": invalid parameter %s\\n\", argv[i + 1]);",
          "4392:     return 2;",
          "4393:    }",
          "4394:    GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] -dash-strict is deprecated, will behave like -dash\\n\"));",
          "4395:    i++;",
          "4397:   else if (!stricmp(arg, \"-subdur\")) {",
          "4398:    CHECK_NEXT_ARG",
          "4399:    dash_subduration = atof(argv[i + 1]) / 1000;",
          "4400:    i++;",
          "4402:   else if (!stricmp(arg, \"-dash-scale\")) {",
          "4403:    CHECK_NEXT_ARG",
          "4404:    dash_scale = atoi(argv[i + 1]);",
          "4405:    if (!dash_scale) {",
          "4406:     fprintf(stderr, \"\\tERROR: \\\"-dash-scale\\\": invalid parameter %s\\n\", argv[i + 1]);",
          "4407:     return 2;",
          "4409:    i++;",
          "4410:   }",
          "4411:   else if (!stricmp(arg, \"-dash-ts-prog\")) {",
          "4412:    CHECK_NEXT_ARG",
          "4413:    program_number = atoi(argv[i + 1]);",
          "4414:    i++;",
          "4415:   }",
          "4416:   else if (!stricmp(arg, \"-subsegs-per-sidx\") || !stricmp(arg, \"-frags-per-sidx\")) {",
          "4417:    CHECK_NEXT_ARG",
          "4418:    subsegs_per_sidx = atoi(argv[i + 1]);",
          "4419:    i++;",
          "4420:   }",
          "4421:   else if (!stricmp(arg, \"-segment-name\")) {",
          "4422:    CHECK_NEXT_ARG",
          "4423:    seg_name = argv[i + 1];",
          "4424:    i++;",
          "4425:   }",
          "4426:   else if (!stricmp(arg, \"-run-for\")) {",
          "4427:    CHECK_NEXT_ARG",
          "4428:    run_for = atoi(argv[i + 1]);",
          "4429:    i++;",
          "4430:   }",
          "4431:   else if (!stricmp(arg, \"-no-cache\")) {",
          "4432:    no_cache = GF_TRUE;",
          "4433:   }",
          "4434:   else if (!stricmp(arg, \"-no-loop\")) {",
          "4435:    no_loop = GF_TRUE;",
          "4436:   }",
          "4437:   else if (!stricmp(arg, \"-hlsc\")) {",
          "4438:    hls_clock = GF_TRUE;",
          "4439:   }",
          "4440:   else if (!stricmp(arg, \"-bound\")) {",
          "4441:    dash_split_mode = GF_DASH_SPLIT_IN;",
          "4442:   }",
          "4443:   else if (!stricmp(arg, \"-closest\")) {",
          "4444:    dash_split_mode = GF_DASH_SPLIT_CLOSEST;",
          "4445:   }",
          "4446:   else if (!stricmp(arg, \"-segment-ext\")) {",
          "4447:    CHECK_NEXT_ARG",
          "4448:    seg_ext = argv[i + 1];",
          "4449:    i++;",
          "4450:   }",
          "4451:   else if (!stricmp(arg, \"-init-segment-ext\")) {",
          "4452:    CHECK_NEXT_ARG",
          "4453:    init_seg_ext = argv[i + 1];",
          "4454:    i++;",
          "4455:   }",
          "4456:   else if (!stricmp(arg, \"-bs-switching\")) {",
          "4457:    CHECK_NEXT_ARG",
          "4458:    if (!stricmp(argv[i + 1], \"no\") || !stricmp(argv[i + 1], \"off\")) bitstream_switching_mode = GF_DASH_BSMODE_NONE;",
          "4459:    else if (!stricmp(argv[i + 1], \"merge\"))  bitstream_switching_mode = GF_DASH_BSMODE_MERGED;",
          "4460:    else if (!stricmp(argv[i + 1], \"multi\"))  bitstream_switching_mode = GF_DASH_BSMODE_MULTIPLE_ENTRIES;",
          "4461:    else if (!stricmp(argv[i + 1], \"single\"))  bitstream_switching_mode = GF_DASH_BSMODE_SINGLE;",
          "4462:    else if (!stricmp(argv[i + 1], \"inband\"))  bitstream_switching_mode = GF_DASH_BSMODE_INBAND;",
          "4463:    else {",
          "4464:     fprintf(stderr, \"\\tWARNING: Unrecognized bitstream switchin mode \\\"%s\\\" - please check usage\\n\", argv[i + 1]);",
          "4465:     return 2;",
          "4467:    i++;",
          "4468:   }",
          "4469:   else if (!stricmp(arg, \"-dynamic\")) {",
          "4470:    dash_mode = GF_DASH_DYNAMIC;",
          "4471:   }",
          "4472:   else if (!stricmp(arg, \"-last-dynamic\")) {",
          "4473:    dash_mode = GF_DASH_DYNAMIC_LAST;",
          "4474:   }",
          "4475:   else if (!stricmp(arg, \"-frag-rt\")) {",
          "4476:    frag_real_time = GF_TRUE;",
          "4477:   }",
          "4478:   else if (!stricmp(arg, \"-start-date\")) {",
          "4479:    dash_start_date = argv[i+1];",
          "4480:    i++;",
          "4481:   }",
          "4482:   else if (!strnicmp(arg, \"-cp-location=\", 13)) {",
          "4483:    if (strcmp(arg+13, \"both\")) cp_location_mode = GF_DASH_CPMODE_BOTH;",
          "4484:    else if (strcmp(arg+13, \"as\")) cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;",
          "4485:    else if (strcmp(arg+13, \"rep\")) cp_location_mode = GF_DASH_CPMODE_REPRESENTATION;",
          "4486:    else {",
          "4487:     fprintf(stderr, \"\\tWARNING: Unrecognized ContentProtection loction mode \\\"%s\\\" - please check usage\\n\", argv[i + 13]);",
          "4488:     return 2;",
          "4490:   }",
          "4491:   else if (!strnicmp(arg, \"-dash-live\", 10) || !strnicmp(arg, \"-ddbg-live\", 10)) {",
          "4492:    dash_mode = !strnicmp(arg, \"-ddbg-live\", 10) ? GF_DASH_DYNAMIC_DEBUG : GF_DASH_DYNAMIC;",
          "4493:    dash_live = 1;",
          "4494:    if (arg[10] == '=') {",
          "4495:     dash_ctx_file = arg + 11;",
          "4497:    CHECK_NEXT_ARG",
          "4498:    dash_duration = atof(argv[i + 1]) / 1000;",
          "4499:    i++;",
          "4500:   }",
          "4501:   else if (!stricmp(arg, \"-mpd-duration\")) {",
          "4502:    CHECK_NEXT_ARG mpd_live_duration = atof(argv[i + 1]);",
          "4503:    i++;",
          "4504:   }",
          "4505:   else if (!stricmp(arg, \"-mpd-refresh\")) {",
          "4506:    CHECK_NEXT_ARG mpd_update_time = atof(argv[i + 1]);",
          "4507:    i++;",
          "4508:   }",
          "4509:   else if (!stricmp(arg, \"-time-shift\")) {",
          "4510:    CHECK_NEXT_ARG",
          "4511:    time_shift_depth = (u32)atoi(argv[i + 1]);",
          "4512:    i++;",
          "4513:   }",
          "4514:   else if (!stricmp(arg, \"-min-buffer\")) {",
          "4515:    CHECK_NEXT_ARG",
          "4516:    min_buffer = atoi(argv[i + 1]);",
          "4517:    min_buffer /= 1000;",
          "4518:    i++;",
          "4519:   }",
          "4520:   else if (!stricmp(arg, \"-ast-offset\")) {",
          "4521:    CHECK_NEXT_ARG",
          "4522:    ast_offset_ms = atoi(argv[i + 1]);",
          "4523:    i++;",
          "4524:   }",
          "4525:   else if (!stricmp(arg, \"-moof-sn\")) {",
          "4526:    CHECK_NEXT_ARG",
          "4527:    initial_moof_sn = (u32)atoi(argv[i + 1]);",
          "4528:    i++;",
          "4529:   }",
          "4530:   else if (!stricmp(arg, \"-tfdt\")) {",
          "4531:    CHECK_NEXT_ARG",
          "4532:    sscanf(argv[i + 1], LLU, &initial_tfdt);",
          "4533:    i++;",
          "4534:   }",
          "4535:   else if (!stricmp(arg, \"-no-frags-default\")) {",
          "4536:    no_fragments_defaults = 1;",
          "4537:   }",
          "4538:   else if (!stricmp(arg, \"-single-traf\")) {",
          "4539:    single_traf_per_moof = 1;",
          "4540:   }",
          "4541:         else if (!stricmp(arg, \"-tfdt-traf\")) {",
          "4542:             tfdt_per_traf = 1;",
          "4543:         }",
          "4544:   else if (!stricmp(arg, \"-merge-last-seg\")) {",
          "4545:    merge_last_seg = GF_TRUE;",
          "4546:   }",
          "4547:   else if (!stricmp(arg, \"-mpd-title\")) {",
          "4548:    CHECK_NEXT_ARG dash_title = argv[i + 1];",
          "4549:    i++;",
          "4550:   }",
          "4551:   else if (!stricmp(arg, \"-mpd-source\")) {",
          "4552:    CHECK_NEXT_ARG dash_source = argv[i + 1];",
          "4553:    i++;",
          "4554:   }",
          "4555:   else if (!stricmp(arg, \"-mpd-info-url\")) {",
          "4556:    CHECK_NEXT_ARG dash_more_info = argv[i + 1];",
          "4557:    i++;",
          "4558:   }",
          "4559:   else if (!stricmp(arg, \"-base-url\")) {",
          "4560:    CHECK_NEXT_ARG",
          "4561:    dash_more_info = argv[i + 1];",
          "4562:    mpd_base_urls = gf_realloc(mpd_base_urls, (nb_mpd_base_urls + 1)*sizeof(char**));",
          "4563:    mpd_base_urls[nb_mpd_base_urls] = argv[i + 1];",
          "4564:    nb_mpd_base_urls++;",
          "4565:    i++;",
          "4566:   }",
          "4567:   else if (!stricmp(arg, \"-dash-ctx\")) {",
          "4568:    CHECK_NEXT_ARG",
          "4569:    dash_ctx_file = argv[i + 1];",
          "4570:    i++;",
          "4571:   }",
          "4572:   else if (!stricmp(arg, \"-ssix\")) {",
          "4573:    use_ssix = 1;",
          "4574:   }",
          "4575:   else if (!stricmp(arg, \"-daisy-chain\")) {",
          "4576:    daisy_chain_sidx = 1;",
          "4577:   }",
          "4578:   else if (!stricmp(arg, \"-single-segment\")) {",
          "4579:    single_segment = 1;",
          "4580:   }",
          "4581:   else if (!stricmp(arg, \"-single-file\")) {",
          "4582:    single_file = 1;",
          "4583:   }",
          "4584:   else if (!stricmp(arg, \"-pssh-moof\")) {",
          "4585:    pssh_mode = GF_DASH_PSSH_MOOF;",
          "4586:   }",
          "4587:   else if (!strnicmp(arg, \"-pssh=\", 6)) {",
          "4588:    if (!strcmp(arg+6, \"f\")) pssh_mode = GF_DASH_PSSH_MOOF;",
          "4589:    else if (!strcmp(arg+6, \"v\")) pssh_mode = GF_DASH_PSSH_MOOV;",
          "4590:    else if (!strcmp(arg+6, \"m\")) pssh_mode = GF_DASH_PSSH_MPD;",
          "4591:    else if (!strcmp(arg+6, \"mf\") || !strcmp(arg+6, \"fm\")) pssh_mode = GF_DASH_PSSH_MOOF_MPD;",
          "4592:    else if (!strcmp(arg+6, \"mv\") || !strcmp(arg+6, \"vm\")) pssh_mode = GF_DASH_PSSH_MOOV_MPD;",
          "4593:    else pssh_mode = GF_DASH_PSSH_MOOV;",
          "4594:   }",
          "4595:   else if (!stricmp(arg, \"-sample-groups-traf\")) {",
          "4596:    samplegroups_in_traf = 1;",
          "4597:   }",
          "4598:   else if (!stricmp(arg, \"-mvex-after-traks\")) {",
          "4599:    mvex_after_traks = GF_TRUE;",
          "4600:   }",
          "4601:   else if (!stricmp(arg, \"-sdtp-traf\")) {",
          "4602:    CHECK_NEXT_ARG",
          "4603:    if (!stricmp(argv[i + 1], \"both\")) sdtp_in_traf = 2;",
          "4604:    else if (!stricmp(argv[i + 1], \"sdtp\")) sdtp_in_traf = 1;",
          "4605:    else sdtp_in_traf = 0;",
          "4606:    i++;",
          "4607:   }",
          "4608:   else if (!stricmp(arg, \"-dash-profile\") || !stricmp(arg, \"-profile\")) {",
          "4609:    CHECK_NEXT_ARG",
          "4610:    if (!stricmp(argv[i + 1], \"live\") || !stricmp(argv[i + 1], \"simple\")) dash_profile = GF_DASH_PROFILE_LIVE;",
          "4611:    else if (!stricmp(argv[i + 1], \"onDemand\")) dash_profile = GF_DASH_PROFILE_ONDEMAND;",
          "4612:    else if (!stricmp(argv[i + 1], \"hbbtv1.5:live\") || !stricmp(argv[i + 1], \"hbbtv1.5.live\"))",
          "4613:     dash_profile = GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE;",
          "4614:    else if (!stricmp(argv[i + 1], \"dashavc264:live\") || !stricmp(argv[i + 1], \"dashavc264.live\"))",
          "4615:     dash_profile = GF_DASH_PROFILE_AVC264_LIVE;",
          "4616:    else if (!stricmp(argv[i + 1], \"dashavc264:onDemand\") || !stricmp(argv[i + 1], \"dashavc264.onDemand\"))",
          "4617:     dash_profile = GF_DASH_PROFILE_AVC264_ONDEMAND;",
          "4618:    else if (!stricmp(argv[i + 1], \"dashif.ll\")) dash_profile = GF_DASH_PROFILE_DASHIF_LL;",
          "4619:    else if (!stricmp(argv[i + 1], \"main\")) dash_profile = GF_DASH_PROFILE_MAIN;",
          "4620:    else if (!stricmp(argv[i + 1], \"full\")) dash_profile = GF_DASH_PROFILE_FULL;",
          "4621:    else {",
          "4622:     fprintf(stderr, \"\\tWARNING: Unrecognized DASH profile \\\"%s\\\" - please check usage\\n\", argv[i + 1]);",
          "4623:     return 2;",
          "4625:    i++;",
          "4626:   }",
          "4627:   else if (!stricmp(arg, \"-profile-ext\")) {",
          "4628:    CHECK_NEXT_ARG",
          "4629:    dash_profile_extension = argv[i + 1];",
          "4630:    i++;",
          "4631:   }",
          "4632:   else if (!strnicmp(arg, \"-url-template\", 13)) {",
          "4633:    use_url_template = 1;",
          "4634:    if ((arg[13] == '=') && arg[14]) {",
          "4635:     if (!strcmp(&arg[14], \"simulate\")) use_url_template = 2;",
          "4638:   else if (!stricmp(arg, \"-segment-timeline\")) {",
          "4639:    segment_timeline = 1;",
          "4640:   }",
          "4641:   else if (!stricmp(arg, \"-mem-frags\")) {",
          "4642:    memory_frags = 1;",
          "4643:   }",
          "4644:   else if (!stricmp(arg, \"-segment-marker\")) {",
          "4645:    char *m;",
          "4646:    CHECK_NEXT_ARG",
          "4647:    m = argv[i + 1];",
          "4648:    segment_marker = GF_4CC(m[0], m[1], m[2], m[3]);",
          "4649:    i++;",
          "4650:   }",
          "4651:   else if (!stricmp(arg, \"-cues\")) {",
          "4652:    CHECK_NEXT_ARG",
          "4653:    dash_cues = argv[i + 1];",
          "4654:    i++;",
          "4655:   }",
          "4656:   else if (!stricmp(arg, \"-strict-cues\")) {",
          "4657:    strict_cues = GF_TRUE;",
          "4658:   }",
          "4659:   else if (!stricmp(arg, \"-insert-utc\")) {",
          "4660:    insert_utc = GF_TRUE;",
          "4661:   }",
          "4662: #endif //GPAC_DISABLE_ISOM_WRITE",
          "4663:   else if (!stricmp(arg, \"-udp-write\")) {",
          "4664:    udp_dest = argv[i+1];",
          "4665:    i++;",
          "4666:   }",
          "4667:   else {",
          "4668:    u32 ret = mp4box_parse_args_continue(argc, argv, &i);",
          "4669:    if (ret) return ret;",
          "4670:   }",
          "4672:  return 0;",
          "4680:  nb_tsel_acts = nb_add = nb_cat = nb_track_act = nb_sdp_ex = max_ptime = nb_meta_act = rtp_rate = major_brand = nb_alt_brand_add = nb_alt_brand_rem = car_dur = minor_version = 0;",
          "4682:  split_duration = 0.0;",
          "4683:  split_start = -1.0;",
          "4684:  interleaving_time = 0;",
          "4685:  dash_duration = dash_subduration = 0.0;",
          "4686:  import_fps.num = import_fps.den = 0;",
          "4687:  import_flags = 0;",
          "4688:  split_size = 0;",
          "4689:  movie_time = 0;",
          "4690:  dump_nal = dump_saps = dump_saps_mode = force_new = 0;",
          "4691:  FullInter = HintInter = encode = do_scene_log = old_interleave = do_saf = do_hash = verbose = do_mpd_rip = merge_vtt_cues = get_nb_tracks = GF_FALSE;",
          "4692: #ifndef GPAC_DISABLE_SCENE_DUMP",
          "4693:  dump_mode = GF_SM_DUMP_NONE;",
          "4694: #endif",
          "4695:  Frag = force_ocr = remove_sys_tracks = agg_samples = remove_hint = keep_sys_tracks = remove_root_od = single_group = clean_groups = compress_moov = GF_FALSE;",
          "4696:  conv_type = HintIt = needSave = print_sdp = regular_iod = dump_std = open_edit = dump_rtp = dump_cr = dump_srt = dump_ttxt = dump_m2ts = dump_cart = import_subtitle = force_cat = pack_wgt = dash_live = GF_FALSE;",
          "4697:  no_fragments_defaults = GF_FALSE;",
          "4698:  single_traf_per_moof = hls_clock = GF_FALSE;",
          "4699:     tfdt_per_traf = GF_FALSE;",
          "4700:  dump_nal_type = 0;",
          "4701:  dump_isom = 0;",
          "4702:  print_info = 0;",
          "4704:  align_cat = GF_TRUE;",
          "4705:  subsegs_per_sidx = 0;",
          "4706:  track_dump_type = 0;",
          "4707:  crypt = 0;",
          "4708:  time_shift_depth = 0;",
          "4709:  file = NULL;",
          "4710:  itunes_tags = pes_dump = NULL;",
          "4711:  seg_name = dash_ctx_file = NULL;",
          "4712:  compress_top_boxes = NULL;",
          "4713:  initial_moof_sn = 0;",
          "4714:  initial_tfdt = 0;",
          "4716: #ifndef GPAC_DISABLE_SCENE_ENCODER",
          "4717:  memset(&smenc_opts, 0, sizeof(smenc_opts));",
          "4718: #endif",
          "4720:  trackID = stat_level = hint_flags = 0;",
          "4721:  program_number = 0;",
          "4722:  info_track_id = 0;",
          "4723:  do_flat = 0;",
          "4724:  inName = outName = mediaSource = input_ctx = output_ctx = drm_file = avi2raw = cprt = chap_file = pack_file = raw_cat = high_dynamc_range_filename = use_init_seg = box_patch_filename = NULL;",
          "4726: #ifndef GPAC_DISABLE_SWF_IMPORT",
          "4727:  swf_flags = GF_SM_SWF_SPLIT_TIMELINE;",
          "4729:  swf_flatten_angle = 0.0f;",
          "4730:  tmpdir = NULL;",
          "",
          "[Added Lines]",
          "2275:     tka->dump_type |= GF_EXPORT_WEBVTT_NOMERGE;",
          "2277:     tka->dump_type |= GF_EXPORT_SVC_LAYER;",
          "2279:     tka->dump_type |= GF_EXPORT_NHML_FULL;",
          "2281:     tka->dump_type |= GF_EXPORT_WEBVTT_META_EMBEDDED;",
          "2283:     tka->out_name = gf_strdup(param+7);",
          "2285:     tka->src_name = gf_strdup(param+4);",
          "2287:     tka->string = gf_strdup(param+4);",
          "2289:     tka->src_name = gf_strdup(param+4);",
          "2290:     tka->sample_num = 1;",
          "2292:     tka->udta_type = GF_4CC(param[5], param[6], param[7], param[8]);",
          "2293:    } else if (tka->dump_type == GF_EXPORT_RAW_SAMPLES) {",
          "2294:     tka->sample_num = atoi(param);",
          "2299:  if (arg_val) {",
          "2300:   if (!strcmp(arg_val, \"*\")) {",
          "2301:    tka->trackID = (u32) -1;",
          "2302:   } else {",
          "2303:    tka->trackID = atoi(arg_val);",
          "2304:   }",
          "2306:  return GF_TRUE;",
          "2309: static u32 parse_track_dump(char *arg, u32 dump_type)",
          "2310: {",
          "2311:  if (!create_new_track_action(arg, TRAC_ACTION_RAW_EXTRACT, dump_type))",
          "2312:   return 2;",
          "2313:  track_dump_type = dump_type;",
          "2314:  return 0;",
          "2315: }",
          "2316: static u32 parse_track_action(char *arg, u32 act_type)",
          "2318:  if (!create_new_track_action(arg, act_type, 0)) {",
          "2319:   return 2;",
          "2320:  }",
          "2321:  return 0;",
          "2324: u32 parse_comp_box(char *arg_val, u32 opt)",
          "2326:  compress_top_boxes = arg_val;",
          "2327:  size_top_box = opt;",
          "2328:  return 0;",
          "2329: }",
          "2330: u32 parse_dnal(char *arg_val, u32 opt)",
          "2331: {",
          "2332:  dump_nal = atoi(arg_val);",
          "2333:  dump_nal_type = opt;",
          "2334:  return 0;",
          "2335: }",
          "2336: u32 parse_dsap(char *arg_val, u32 opt)",
          "2337: {",
          "2338:  dump_saps = atoi(arg_val);",
          "2339:  dump_saps_mode = opt;",
          "2340:  return 0;",
          "2341: }",
          "2343: u32 parse_bs_switch(char *arg_val, u32 opt)",
          "2344: {",
          "2345:  if (!stricmp(arg_val, \"no\") || !stricmp(arg_val, \"off\")) bitstream_switching_mode = GF_DASH_BSMODE_NONE;",
          "2346:  else if (!stricmp(arg_val, \"merge\"))  bitstream_switching_mode = GF_DASH_BSMODE_MERGED;",
          "2347:  else if (!stricmp(arg_val, \"multi\"))  bitstream_switching_mode = GF_DASH_BSMODE_MULTIPLE_ENTRIES;",
          "2348:  else if (!stricmp(arg_val, \"single\"))  bitstream_switching_mode = GF_DASH_BSMODE_SINGLE;",
          "2349:  else if (!stricmp(arg_val, \"inband\"))  bitstream_switching_mode = GF_DASH_BSMODE_INBAND;",
          "2350:  else {",
          "2351:   fprintf(stderr, \"Unrecognized bitstream switching mode \\\"%s\\\" - please check usage\\n\", arg_val);",
          "2352:   return 2;",
          "2354:  return 0;",
          "2355: }",
          "2357: u32 parse_cp_loc(char *arg_val, u32 opt)",
          "2358: {",
          "2359:  if (!strcmp(arg_val, \"both\")) cp_location_mode = GF_DASH_CPMODE_BOTH;",
          "2360:  else if (!strcmp(arg_val, \"as\")) cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;",
          "2361:  else if (!strcmp(arg_val, \"rep\")) cp_location_mode = GF_DASH_CPMODE_REPRESENTATION;",
          "2362:  else {",
          "2363:   fprintf(stderr, \"Unrecognized ContentProtection loction mode \\\"%s\\\" - please check usage\\n\", arg_val);",
          "2364:   return 2;",
          "2366:  return 0;",
          "2367: }",
          "2369: u32 parse_pssh(char *arg_val, u32 opt)",
          "2370: {",
          "2371:  if (!strcmp(arg_val, \"f\")) pssh_mode = GF_DASH_PSSH_MOOF;",
          "2372:  else if (!strcmp(arg_val, \"v\")) pssh_mode = GF_DASH_PSSH_MOOV;",
          "2373:  else if (!strcmp(arg_val, \"m\")) pssh_mode = GF_DASH_PSSH_MPD;",
          "2374:  else if (!strcmp(arg_val, \"mf\") || !strcmp(arg_val, \"fm\")) pssh_mode = GF_DASH_PSSH_MOOF_MPD;",
          "2375:  else if (!strcmp(arg_val, \"mv\") || !strcmp(arg_val, \"vm\")) pssh_mode = GF_DASH_PSSH_MOOV_MPD;",
          "2376:  else pssh_mode = GF_DASH_PSSH_MOOV;",
          "2377:  return 0;",
          "2378: }",
          "2379: u32 parse_sdtp(char *arg_val, u32 opt)",
          "2380: {",
          "2381:  if (!stricmp(arg_val, \"both\")) sdtp_in_traf = 2;",
          "2382:  else if (!stricmp(arg_val, \"sdtp\")) sdtp_in_traf = 1;",
          "2383:  else sdtp_in_traf = 0;",
          "2384:  return 0;",
          "2385: }",
          "2387: u32 parse_rap_ref(char *arg_val, u32 opt)",
          "2388: {",
          "2389:  if (arg_val) {",
          "2390:   if (sscanf(arg_val, \"%d\", &trackID) == 1) {",
          "2391:    parse_track_action(arg_val, opt ? TRAC_ACTION_REM_NON_REFS : TRAC_ACTION_REM_NON_RAP);",
          "2392:   }",
          "2394:  hint_flags |= GP_RTP_PCK_SIGNAL_RAP;",
          "2395:  seg_at_rap = 1;",
          "2396:  return 0;",
          "2397: }",
          "2398: u32 parse_store_mode(char *arg_val, u32 opt)",
          "2399: {",
          "2400:  do_save = GF_TRUE;",
          "2401:  if ((opt == 0) || (opt == 1)) {",
          "2402:   interleaving_time = atof(arg_val) / 1000;",
          "2403:   if (!interleaving_time) do_flat = 2;",
          "2404:   open_edit = GF_TRUE;",
          "2405:   no_inplace = GF_TRUE;",
          "2406:   if (opt==1) old_interleave = 1;",
          "2407:  } else if (opt==2) {",
          "2408:   interleaving_time = atof(arg_val) / 1000;",
          "2409:   do_frag = GF_TRUE;",
          "2411:   force_new = 2;",
          "2412:   interleaving_time = 0.5;",
          "2413:   do_flat = 1;",
          "2415:  return 0;",
          "2417: u32 parse_base_url(char *arg_val, u32 opt)",
          "2419:  mpd_base_urls = gf_realloc(mpd_base_urls, (nb_mpd_base_urls + 1)*sizeof(char**));",
          "2420:  if (!mpd_base_urls) return 2;",
          "2421:  mpd_base_urls[nb_mpd_base_urls] = arg_val;",
          "2422:  nb_mpd_base_urls++;",
          "2423:  return 0;",
          "2424: }",
          "2425: u32 parse_multi_rtp(char *arg_val, u32 opt)",
          "2426: {",
          "2427:  hint_flags |= GP_RTP_PCK_USE_MULTI;",
          "2428:  if (arg_val)",
          "2429:   max_ptime = atoi(arg_val);",
          "2430:  return 0;",
          "2431: }",
          "2434: u32 parse_senc_param(char *arg_val, u32 opt)",
          "2435: {",
          "2436:  switch (opt) {",
          "2437:  case 0: //-sync",
          "2438:   smenc_opts.flags |= GF_SM_ENCODE_RAP_INBAND;",
          "2439:   smenc_opts.rap_freq = atoi(arg_val);",
          "2440:   break;",
          "2441:  case 1: //-shadow",
          "2442:   smenc_opts.flags &= ~GF_SM_ENCODE_RAP_INBAND;",
          "2443:   smenc_opts.flags |= GF_SM_ENCODE_RAP_SHADOW;",
          "2444:   smenc_opts.rap_freq = atoi(arg_val);",
          "2445:   break;",
          "2446:  case 2: //-carousel",
          "2447:   smenc_opts.flags &= ~(GF_SM_ENCODE_RAP_INBAND | GF_SM_ENCODE_RAP_SHADOW);",
          "2448:   smenc_opts.rap_freq = atoi(arg_val);",
          "2449:   break;",
          "2450:  case 3: //-auto-quant",
          "2451:   smenc_opts.resolution = atoi(arg_val);",
          "2452:   smenc_opts.auto_quant = 1;",
          "2453:   break;",
          "2454:  case 4: //-global-quant",
          "2455:   smenc_opts.resolution = atoi(arg_val);",
          "2456:   smenc_opts.auto_quant = 2;",
          "2457:   break;",
          "2458:  case 5: //-ctx-in or -inctx",
          "2459:   chunk_mode = GF_TRUE;",
          "2460:   input_ctx = arg_val;",
          "2462:  return 0;",
          "2463: }",
          "2464: u32 parse_cryp(char *arg_val, u32 opt)",
          "2465: {",
          "2466:  open_edit = GF_TRUE;",
          "2467:  if (!opt) {",
          "2468:   crypt = 1;",
          "2469:   drm_file = arg_val;",
          "2470:   open_edit = GF_TRUE;",
          "2471:   return 0;",
          "2472:  }",
          "2473:  crypt = 2;",
          "2474:  if (arg_val && get_file_type_by_ext(arg_val) != 1) {",
          "2475:   drm_file = arg_val;",
          "2476:   return 0;",
          "2477:  }",
          "2478:  return 3;",
          "2481: u32 parse_dash_profile(char *arg_val, u32 opt)",
          "2483:  if (!stricmp(arg_val, \"live\") || !stricmp(arg_val, \"simple\")) dash_profile = GF_DASH_PROFILE_LIVE;",
          "2484:  else if (!stricmp(arg_val, \"onDemand\")) dash_profile = GF_DASH_PROFILE_ONDEMAND;",
          "2485:  else if (!stricmp(arg_val, \"hbbtv1.5:live\") || !stricmp(arg_val, \"hbbtv1.5.live\"))",
          "2486:   dash_profile = GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE;",
          "2487:  else if (!stricmp(arg_val, \"dashavc264:live\") || !stricmp(arg_val, \"dashavc264.live\"))",
          "2488:   dash_profile = GF_DASH_PROFILE_AVC264_LIVE;",
          "2489:  else if (!stricmp(arg_val, \"dashavc264:onDemand\") || !stricmp(arg_val, \"dashavc264.onDemand\"))",
          "2490:   dash_profile = GF_DASH_PROFILE_AVC264_ONDEMAND;",
          "2491:  else if (!stricmp(arg_val, \"dashif.ll\")) dash_profile = GF_DASH_PROFILE_DASHIF_LL;",
          "2492:  else if (!stricmp(arg_val, \"main\")) dash_profile = GF_DASH_PROFILE_MAIN;",
          "2493:  else if (!stricmp(arg_val, \"full\")) dash_profile = GF_DASH_PROFILE_FULL;",
          "2494:  else {",
          "2495:   fprintf(stderr, \"\\tUnrecognized DASH profile \\\"%s\\\" - please check usage\\n\", arg_val);",
          "2496:   return 2;",
          "2497:  }",
          "2498:  return 0;",
          "2499: }",
          "2501: u32 parse_fps(char *arg_val, u32 opt)",
          "2502: {",
          "2503:  u32 ticks, dts_inc;",
          "2504:  if (!strcmp(arg_val, \"auto\")) {",
          "2505:   fprintf(stderr, \"Warning, fps=auto option is deprecated\\n\");",
          "2507:  else if ((sscanf(arg_val, \"%u-%u\", &ticks, &dts_inc)==2) || (sscanf(arg_val, \"%u/%u\", &ticks, &dts_inc)==2) ) {",
          "2508:   if (!dts_inc) dts_inc = 1;",
          "2509:   import_fps.num = ticks;",
          "2510:   import_fps.den = dts_inc;",
          "2511:  } else {",
          "2512:   import_fps.num = (s32) (1000 * atof(arg_val));",
          "2513:   import_fps.den = 1000;",
          "2514:  }",
          "2515:  return 0;",
          "2516: }",
          "2518: u32 parse_split(char *arg_val, u32 opt)",
          "2519: {",
          "2520:  switch (opt) {",
          "2521:  case 0://-split",
          "2522:   split_duration = atof(arg_val);",
          "2523:   if (split_duration < 0) split_duration = 0;",
          "2524:   split_size = 0;",
          "2525:   break;",
          "2526:  case 1: //-split-rap, -splitr",
          "2527:   split_duration = -1;",
          "2528:   split_size = -1;",
          "2529:   break;",
          "2530:  case 2: //-split-size, -splits",
          "2531:   split_size = (u32)atoi(arg_val);",
          "2532:   split_duration = 0;",
          "2533:   break;",
          "2534:  case 4: //-splitz",
          "2535:   adjust_split_end = 1;",
          "2537:  case 3: //-split-chunk, -splitx",
          "2538:   if (!strstr(arg_val, \":\")) {",
          "2539:    fprintf(stderr, \"Chunk extraction usage: \\\"-splitx start:end\\\" expressed in seconds\\n\");",
          "2540:    return 2;",
          "2541:   }",
          "2542:   if (strstr(arg_val, \"end\")) {",
          "2543:    if (strstr(arg_val, \"end-\")) {",
          "2544:     Double dur_end=0;",
          "2545:     sscanf(arg_val, \"%lf:end-%lf\", &split_start, &dur_end);",
          "2546:     split_duration = -2 - dur_end;",
          "2547:    } else {",
          "2548:     sscanf(arg_val, \"%lf:end\", &split_start);",
          "2549:     split_duration = -2;",
          "2550:    }",
          "2551:   } else {",
          "2552:    if (strchr(arg_val, '-')) {",
          "2553:     split_range_str = arg_val;",
          "2554:    } else {",
          "2555:     sscanf(arg_val, \"%lf:%lf\", &split_start, &split_duration);",
          "2556:     split_duration -= split_start;",
          "2557:    }",
          "2558:   }",
          "2559:   split_size = 0;",
          "2560:   break;",
          "2561:  }",
          "2562:  return 0;",
          "2563: }",
          "2565: u32 parse_brand(char *b, u32 opt)",
          "2566: {",
          "2567:  open_edit = GF_TRUE;",
          "2568:  switch (opt) {",
          "2569:  case 0: //-brand",
          "2570:   major_brand = GF_4CC(b[0], b[1], b[2], b[3]);",
          "2571:   if (b[4] == ':') {",
          "2572:    if (!strncmp(b+5, \"0x\", 2))",
          "2573:     sscanf(b+5, \"0x%x\", &minor_version);",
          "2574:    else",
          "2575:     minor_version = atoi(b + 5);",
          "2576:   }",
          "2577:   break;",
          "2578:  case 1: //-ab",
          "2579:   brand_add = (u32*)gf_realloc(brand_add, sizeof(u32) * (nb_alt_brand_add + 1));",
          "2580:   if (!brand_add) return 2;",
          "2581:   brand_add[nb_alt_brand_add] = GF_4CC(b[0], b[1], b[2], b[3]);",
          "2582:   nb_alt_brand_add++;",
          "2583:   break;",
          "2584:  case 2: //-rb",
          "2585:   brand_rem = (u32*)gf_realloc(brand_rem, sizeof(u32) * (nb_alt_brand_rem + 1));",
          "2586:   if (!brand_rem) return 2;",
          "2587:   brand_rem[nb_alt_brand_rem] = GF_4CC(b[0], b[1], b[2], b[3]);",
          "2588:   nb_alt_brand_rem++;",
          "2589:   break;",
          "2590:  }",
          "2591:  return 0;",
          "2592: }",
          "2594: u32 parse_mpegu(char *arg_val, u32 opt)",
          "2595: {",
          "2596:  pack_file = arg_val;",
          "2597:  pack_wgt = GF_TRUE;",
          "2598:  return 0;",
          "2599: }",
          "2601: u32 parse_file_info(char *arg_val, u32 opt)",
          "2602: {",
          "2603:  print_info = opt ? 2 : 1;",
          "2604:  if (arg_val) {",
          "2605:   if (sscanf(arg_val, \"%u\", &info_track_id) == 1) {",
          "2606:    char szTk[20];",
          "2607:    sprintf(szTk, \"%u\", info_track_id);",
          "2608:    if (strcmp(szTk, arg_val)) info_track_id = 0;",
          "2609:   }",
          "2610:   if (!info_track_id) return 3;",
          "2611:  }",
          "2612:  return 0;",
          "2613: }",
          "2614: u32 parse_boxpatch(char *arg_val, u32 opt)",
          "2615: {",
          "2616:  box_patch_filename = arg_val;",
          "2617:  char *sep = strchr(box_patch_filename, '=');",
          "2618:  if (sep) {",
          "2619:   sep[0] = 0;",
          "2620:   box_patch_trackID = atoi(box_patch_filename);",
          "2621:   sep[0] = '=';",
          "2622:   box_patch_filename = sep+1;",
          "2623:  }",
          "2624:  open_edit = GF_TRUE;",
          "2625:  return 0;",
          "2626: }",
          "2628: u32 parse_aviraw(char *arg_val, u32 opt)",
          "2629: {",
          "2630:  if (arg_val && !stricmp(arg_val, \"video\")) trackID = 1;",
          "2631:  else if (arg_val && !stricmp(arg_val, \"audio\")) {",
          "2632:   if (strlen(arg_val) == 5) trackID = 2;",
          "2633:   else trackID = 1 + atoi(arg_val + 5);",
          "2634:  } else {",
          "2635:   fprintf(stderr, \"Usage: \\\"-aviraw video\\\" or \\\"-aviraw audio\\\"\\n\");",
          "2636:   return 2;",
          "2637:  }",
          "2638:  track_dump_type = GF_EXPORT_AVI_NATIVE;",
          "2639:  return 0;",
          "2640: }",
          "2642: u32 parse_dump_udta(char *code, u32 opt)",
          "2643: {",
          "2644:  char *sep;",
          "2645:  sep = strchr(code, ':');",
          "2646:  if (sep) {",
          "2647:   sep[0] = 0;",
          "2648:   dump_udta_track = atoi(code);",
          "2649:   sep[0] = ':';",
          "2650:   code = sep + 1;",
          "2651:  }",
          "2653:  if (strlen(code) == 4) {",
          "2654:   dump_udta_type = GF_4CC(code[0], code[1], code[2], code[3]);",
          "2655:  } else if (strlen(code) == 8) {",
          "2657:   u32 hex1, hex2, hex3, hex4;",
          "2658:   if (sscanf(code, \"%02x%02x%02x%02x\", &hex1, &hex2, &hex3, &hex4) != 4) {",
          "2659:    fprintf(stderr, \"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\");",
          "2660:    return 2;",
          "2662:   dump_udta_type = GF_4CC(hex1, hex2, hex3, hex4);",
          "2663:  } else {",
          "2664:   fprintf(stderr, \"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\");",
          "2665:   return 2;",
          "2666:  }",
          "2667:  return 0;",
          "2668: }",
          "2670: u32 parse_dump_ts(char *arg_val, u32 opt)",
          "2671: {",
          "2672:  dump_timestamps = 1;",
          "2673:  if (arg_val) {",
          "2674:   if (isdigit(arg_val[0])) {",
          "2675:    program_number = atoi(arg_val);",
          "2676:   } else {",
          "2677:    return 3;",
          "2679:  }",
          "2680:  return 0;",
          "2681: }",
          "2683: u32 parse_ttxt(char *arg_val, u32 opt)",
          "2684: {",
          "2685:  if (opt) //-srt",
          "2686:   dump_srt = GF_TRUE;",
          "2687:  else",
          "2688:   dump_ttxt = GF_TRUE;",
          "2690:  import_subtitle = 1;",
          "2691:  trackID = 0;",
          "2693:  if (arg_val && (!strcmp(arg_val, \"*\") || !strcmp(arg_val, \"@\") || !strcmp(arg_val, \"all\")) ) {",
          "2694:   trackID = (u32)-1;",
          "2695:  } else if (arg_val) {",
          "2696:   if (sscanf(arg_val, \"%u\", &trackID) == 1) {",
          "2697:    char szTk[20];",
          "2698:    sprintf(szTk, \"%d\", trackID);",
          "2699:    if (strcmp(szTk, arg_val))",
          "2700:     trackID = 0;",
          "2702:   if (!trackID) return 3;",
          "2704:  return 0;",
          "2705: }",
          "2707: u32 parse_dashlive(char *arg, char *arg_val, u32 opt)",
          "2708: {",
          "2709:  dash_mode = opt ? GF_DASH_DYNAMIC_DEBUG : GF_DASH_DYNAMIC;",
          "2710:  dash_live = 1;",
          "2711:  if (arg[10] == '=') {",
          "2712:   dash_ctx_file = arg + 11;",
          "2713:  }",
          "2714:  dash_duration = atof(arg_val) / 1000;",
          "2715:  return 0;",
          "2716: }",
          "2718: u32 parse_help(char *arg_val, u32 opt)",
          "2719: {",
          "2720:  if (!arg_val) PrintUsage();",
          "2721:  else if (opt) PrintHelp(arg_val, GF_TRUE, GF_FALSE);",
          "2722:  else if (!strcmp(arg_val, \"general\")) PrintGeneralUsage();",
          "2723:  else if (!strcmp(arg_val, \"extract\")) PrintExtractUsage();",
          "2724:  else if (!strcmp(arg_val, \"split\")) PrintSplitUsage();",
          "2725:  else if (!strcmp(arg_val, \"dash\")) PrintDASHUsage();",
          "2726:  else if (!strcmp(arg_val, \"dump\")) PrintDumpUsage();",
          "2727:  else if (!strcmp(arg_val, \"import\")) PrintImportUsage();",
          "2728:  else if (!strcmp(arg_val, \"format\")) fprintf(stderr, \"deprecated, see [filters documentation](Filters)\\n\");",
          "2729:  else if (!strcmp(arg_val, \"hint\")) PrintHintUsage();",
          "2730:  else if (!strcmp(arg_val, \"encode\")) PrintEncodeUsage();",
          "2731:  else if (!strcmp(arg_val, \"crypt\")) PrintEncryptUsage();",
          "2732:  else if (!strcmp(arg_val, \"meta\")) PrintMetaUsage();",
          "2733:  else if (!strcmp(arg_val, \"swf\")) PrintSWFUsage();",
          "2734: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "2735:  else if (!strcmp(arg_val, \"rtp\")) fprintf(stderr, \"RTP streaming deprecated in MP4Box, use gpac application\\n\");",
          "2736:  else if (!strcmp(arg_val, \"live\")) PrintLiveUsage();",
          "2737: #endif",
          "2738:  else if (!strcmp(arg_val, \"core\")) PrintCoreUsage();",
          "2739:  else if (!strcmp(arg_val, \"tags\")) PrintTags();",
          "2740:  else if (!strcmp(arg_val, \"cicp\")) PrintCICP();",
          "2741:  else if (!strcmp(arg_val, \"all\")) {",
          "2742:   PrintGeneralUsage();",
          "2743:   PrintExtractUsage();",
          "2744:   PrintDASHUsage();",
          "2745:   PrintSplitUsage();",
          "2746:   PrintDumpUsage();",
          "2747:   PrintImportUsage();",
          "2748:   PrintHintUsage();",
          "2749:   PrintEncodeUsage();",
          "2750:   PrintEncryptUsage();",
          "2751:   PrintMetaUsage();",
          "2752:   PrintSWFUsage();",
          "2753: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "2754:   PrintLiveUsage();",
          "2755: #endif",
          "2756:   PrintCoreUsage();",
          "2757:   PrintTags();",
          "2758:   PrintCICP();",
          "2759:  } else if (!strcmp(arg_val, \"opts\")) {",
          "2760:   PrintHelp(\"@\", GF_FALSE, GF_FALSE);",
          "2761:  } else {",
          "2762:   PrintHelp(arg_val, GF_FALSE, GF_FALSE);",
          "2763:  }",
          "2764:  return 1;",
          "2765: }",
          "2767: u32 parse_gendoc(char *name, u32 opt)",
          "2768: {",
          "2769:  u32 i=0;",
          "2771:  if (!opt) {",
          "2772:   help_flags = GF_PRINTARG_MD | GF_PRINTARG_IS_APP;",
          "2773:   helpout = gf_fopen(\"mp4box-gen-opts.md\", \"w\");",
          "2775:   fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb General\");",
          "2776:   fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "2777:   fprintf(helpout, \"# Syntax\\n\");",
          "2778:   gf_sys_format_help(helpout, help_flags, \"MP4Box [option] input [option] [other_dash_inputs]\\n\"",
          "2779:    \"  \\n\"",
          "2780:   );",
          "2781:   PrintGeneralUsage();",
          "2782:   PrintEncryptUsage();",
          "2783:   fprintf(helpout, \"# Help Options\\n\");",
          "2784:   while (m4b_usage_args[i].name) {",
          "2785:    GF_GPACArg *g_arg = (GF_GPACArg *) &m4b_usage_args[i];",
          "2786:    i++;",
          "2787:    gf_sys_print_arg(helpout, help_flags, g_arg, \"mp4box-general\");",
          "2790:   gf_fclose(helpout);",
          "2792:   helpout = gf_fopen(\"mp4box-import-opts.md\", \"w\");",
          "2793:   fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Import\");",
          "2794:   fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "2795:   PrintImportUsage();",
          "2796:   gf_fclose(helpout);",
          "2798:   helpout = gf_fopen(\"mp4box-dash-opts.md\", \"w\");",
          "2799:   fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media DASH\");",
          "2800:   fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "2801:   PrintDASHUsage();",
          "2802:   gf_fclose(helpout);",
          "2804:   helpout = gf_fopen(\"mp4box-dump-opts.md\", \"w\");",
          "2805:   fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Dump and Export\");",
          "2806:   fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "2807:   PrintExtractUsage();",
          "2808:   PrintDumpUsage();",
          "2809:   gf_fclose(helpout);",
          "2811:   helpout = gf_fopen(\"mp4box-meta-opts.md\", \"w\");",
          "2812:   fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Meta and HEIF/IFF\");",
          "2813:   fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "2814:   PrintMetaUsage();",
          "2815:   gf_fclose(helpout);",
          "2818:   helpout = gf_fopen(\"mp4box-scene-opts.md\", \"w\");",
          "2819:   fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Scene Description\");",
          "2820:   fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "2821:   PrintEncodeUsage();",
          "2822: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "2823:   PrintLiveUsage();",
          "2824: #endif",
          "2825:   PrintSWFUsage();",
          "2826:   gf_fclose(helpout);",
          "2828:   helpout = gf_fopen(\"mp4box-other-opts.md\", \"w\");",
          "2829:   fprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Other Features\");",
          "2830:   fprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");",
          "2831:   PrintHintUsage();",
          "2832:   PrintTags();",
          "2833:   gf_fclose(helpout);",
          "2834:  }",
          "2836:  else {",
          "2837:   help_flags = GF_PRINTARG_MAN;",
          "2838:   helpout = gf_fopen(\"mp4box.1\", \"w\");",
          "2841:   fprintf(helpout, \".TH MP4Box 1 2019 MP4Box GPAC\\n\");",
          "2842:   fprintf(helpout, \".\\n.SH NAME\\n.LP\\nMP4Box \\\\- GPAC command-line media packager\\n.SH SYNOPSIS\\n.LP\\n.B MP4Box\\n.RI [options] \\\\ [file] \\\\ [options]\\n.br\\n.\\n\");",
          "2844:   PrintGeneralUsage();",
          "2845:   PrintExtractUsage();",
          "2846:   PrintDASHUsage();",
          "2847:   PrintSplitUsage();",
          "2848:   PrintDumpUsage();",
          "2849:   PrintImportUsage();",
          "2850:   PrintHintUsage();",
          "2851:   PrintEncodeUsage();",
          "2852:   PrintEncryptUsage();",
          "2853:   PrintMetaUsage();",
          "2854:   PrintSWFUsage();",
          "2855:   PrintTags();",
          "2856: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "2857:   PrintLiveUsage();",
          "2858: #endif",
          "2860:   fprintf(helpout, \".SH EXAMPLES\\n.TP\\nBasic and advanced examples are available at https://wiki.gpac.io/MP4Box\\n\");",
          "2861:   fprintf(helpout, \".SH MORE\\n.LP\\nAuthors: GPAC developers, see git repo history (-log)\\n\"",
          "2862:   \".br\\nFor bug reports, feature requests, more information and source code, visit https://github.com/gpac/gpac\\n\"",
          "2863:   \".br\\nbuild: %s\\n\"",
          "2864:   \".br\\nCopyright: %s\\n.br\\n\"",
          "2865:   \".SH SEE ALSO\\n\"",
          "2866:   \".LP\\ngpac(1), MP4Client(1)\\n\", gf_gpac_version(), gf_gpac_copyright());",
          "2868:   gf_fclose(helpout);",
          "2870:  return 1;",
          "2871: }",
          "2873: static Bool arg_parse_res = 0;",
          "2874: u32 mp4box_parse_single_arg_class(int argc, char **argv, char *arg, u32 *arg_index, MP4BoxArg *arg_class)",
          "2875: {",
          "2876:  MP4BoxArg *arg_desc = NULL;",
          "2877:  char *arg_val = NULL;",
          "2878:  u32 i=0;",
          "2879:  while (arg_class[i].name) {",
          "2880:   arg_desc = (MP4BoxArg *) &arg_class[i];",
          "2881:   i++;",
          "2883: #ifdef TEST_ARGS",
          "2884:   char *sep = strchr(arg_desc->name, ' ');",
          "2885:   if (sep) {",
          "2886:    fprintf(stderr, \"invalid arg %s, space not allowed\\n\", arg_desc->name);",
          "2887:    exit(1);",
          "2888:   }",
          "2889: #endif",
          "2890:   if (!strcmp(arg_desc->name, arg+1))",
          "2891:    break;",
          "2892:   if (arg_desc->altname && !strcmp(arg_desc->altname, arg+1))",
          "2893:    break;",
          "2895:   if (arg_desc->parse_flags & ARG_IS_FUN2) {",
          "2896:    if (!strncmp(arg_desc->name, arg+1, strlen(arg_desc->name) ))",
          "2897:     break;",
          "2898:   }",
          "2899:   arg_desc = NULL;",
          "2901:  if (!arg_desc)",
          "2902:   return GF_FALSE;",
          "2904:  if (arg_desc->parse_flags & ARG_OPEN_EDIT) open_edit = GF_TRUE;",
          "2905:  if (arg_desc->parse_flags & ARG_NEED_SAVE) do_save = GF_TRUE;",
          "2906:  if (arg_desc->parse_flags & ARG_NO_INPLACE) no_inplace = GF_TRUE;",
          "2908:  if (arg_desc->type != GF_ARG_BOOL) {",
          "2909:   Bool has_next = GF_TRUE;",
          "2910:   if (*arg_index + 1 == (u32) argc)",
          "2911:    has_next = GF_FALSE;",
          "2912:   else if (argv[*arg_index + 1][0] == '-') {",
          "2913:    s32 v;",
          "2914:    if (sscanf(argv[*arg_index + 1], \"%d\", &v)!=1)",
          "2915:     has_next = GF_FALSE;",
          "2916:   }",
          "2917:   if (!has_next && ! (arg_desc->parse_flags & ARG_EMPTY) ) {",
          "2918:    fprintf(stderr, \"Missing argument value for %s - please check usage\\n\", arg);",
          "2919:    arg_parse_res = 2;",
          "2920:    return GF_TRUE;",
          "2921:   }",
          "2923:   if (has_next && (arg_desc->parse_flags & ARG_EMPTY) && (arg_desc->type==GF_ARG_INT)) {",
          "2924:    s32 ival;",
          "2925:    if (sscanf(argv[*arg_index + 1], \"%d\", &ival) != 1) {",
          "2926:     has_next = GF_FALSE;",
          "2927:     arg_val = NULL;",
          "2928:    }",
          "2930:   if (has_next) {",
          "2931:    has_next_arg = GF_TRUE;",
          "2933:    arg_val = argv[*arg_index];",
          "2934:   }",
          "2935:  }",
          "2936:  if (!arg_desc->arg_ptr) return GF_TRUE;",
          "2938:  if (arg_desc->parse_flags & (ARG_IS_FUN|ARG_IS_FUN2) ) {",
          "2939:   Bool res;",
          "2940:   if (arg_desc->parse_flags & ARG_PUSH_SYSARGS)",
          "2941:    gf_sys_set_args(argc, (const char**) argv);",
          "2943:   if (arg_desc->parse_flags & ARG_IS_FUN) {",
          "2944:    parse_arg_fun fun = (parse_arg_fun) arg_desc->arg_ptr;",
          "2945:    res = fun(arg_val, arg_desc->argv_val);",
          "2946:   } else {",
          "2947:    parse_arg_fun2 fun2 = (parse_arg_fun2) arg_desc->arg_ptr;",
          "2948:    res = fun2(arg, arg_val, arg_desc->argv_val);",
          "2949:   }",
          "2951:   if ((res==3) && argv) {",
          "2953:    res = 0;",
          "2954:   }",
          "2955:   arg_parse_res = res;",
          "2956:   return GF_TRUE;",
          "2957:  }",
          "2959:  if (arg_desc->parse_flags & ARG_INT_INC) {",
          "2961:   return GF_TRUE;",
          "2962:  }",
          "2964:  if (arg_desc->type == GF_ARG_BOOL) {",
          "2965:   if (!arg_desc->parse_flags) {",
          "2966:    if (arg_desc->argv_val) {",
          "2968:    } else {",
          "2970:    }",
          "2971:   } else if (arg_desc->parse_flags & ARG_BOOL_REV) {",
          "2973:   } else if (arg_desc->parse_flags & ARG_HAS_VALUE) {",
          "2975:   } else if (arg_desc->parse_flags & ARG_BIT_MASK) {",
          "2977:   } else if (arg_desc->parse_flags & ARG_BIT_MASK_REM) {",
          "2979:   } else if (arg_desc->argv_val) {",
          "2981:   } else {",
          "2983:   }",
          "2984:   return GF_TRUE;",
          "2985:  }",
          "2987:  if (arg_desc->type == GF_ARG_STRING) {",
          "2988:   if (arg_desc->parse_flags & ARG_IS_4CC) {",
          "2989:    u32 alen = strlen(arg_val);",
          "2990:    if ((alen<3) || (alen>4)) {",
          "2991:     fprintf(stderr, \"Value for %s must be a 4CC, %s is not - please check usage\\n\", arg, arg_val);",
          "2992:     arg_parse_res = 2;",
          "2993:     return GF_TRUE;",
          "2994:    }",
          "2996:    return GF_TRUE;",
          "2997:   }",
          "3000:   return GF_TRUE;",
          "3001:  }",
          "3002:  if (arg_desc->type == GF_ARG_DOUBLE) {",
          "3003:   Double v = atof(arg_val);",
          "3004:   if (arg_desc->parse_flags & ARG_DIV_1000) {",
          "3005:    v /= 1000;",
          "3006:   }",
          "3007:   if ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {",
          "3008:    fprintf(stderr, \"Value for %s shall not be 0 - please check usage\\n\", arg);",
          "3009:    arg_parse_res = 2;",
          "3010:    return GF_TRUE;",
          "3011:   }",
          "3013:   return GF_TRUE;",
          "3014:  }",
          "3016:  if (arg_desc->type != GF_ARG_INT) {",
          "3017:   fprintf(stderr, \"Unsupported argument type for %s - please report to gpac devs\\n\", arg);",
          "3018:   arg_parse_res = 2;",
          "3019:   return GF_TRUE;",
          "3020:  }",
          "3021:  if (arg_desc->parse_flags & ARG_64BITS) {",
          "3022:   u64 v;",
          "3023:   sscanf(arg_val, LLU, &v);",
          "3024:   if (arg_desc->parse_flags & ARG_DIV_1000) {",
          "3025:    v /= 1000;",
          "3026:   }",
          "3027:   if ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {",
          "3028:    fprintf(stderr, \"Value for %s shall not be 0 - please check usage\\n\", arg);",
          "3029:    arg_parse_res = 2;",
          "3030:    return GF_TRUE;",
          "3031:   }",
          "3034:   u32 v = atoi(arg_val);",
          "3035:   if (arg_desc->parse_flags & ARG_DIV_1000) {",
          "3036:    v /= 1000;",
          "3037:   }",
          "3038:   if ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {",
          "3039:    fprintf(stderr, \"Value for %s shall not be 0 - please check usage\\n\", arg);",
          "3040:    arg_parse_res = 2;",
          "3041:    return GF_TRUE;",
          "3042:   }",
          "3044:  }",
          "3045:  return GF_TRUE;",
          "3046: }",
          "3048: Bool mp4box_parse_single_arg(int argc, char **argv, char *arg, u32 *arg_index)",
          "3049: {",
          "3050:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_gen_args)) return GF_TRUE;",
          "3051:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_split_args)) return GF_TRUE;",
          "3052:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_dash_args)) return GF_TRUE;",
          "3053:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_imp_args)) return GF_TRUE;",
          "3054:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_senc_args)) return GF_TRUE;",
          "3055:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_crypt_args)) return GF_TRUE;",
          "3056:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_hint_args)) return GF_TRUE;",
          "3057:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_extr_args)) return GF_TRUE;",
          "3058:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_dump_args)) return GF_TRUE;",
          "3059:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_meta_args)) return GF_TRUE;",
          "3060:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_swf_args)) return GF_TRUE;",
          "3061:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_liveenc_args)) return GF_TRUE;",
          "3062:  if (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_usage_args)) return GF_TRUE;",
          "3064:  return GF_FALSE;",
          "3068: u32 mp4box_parse_args(int argc, char **argv)",
          "3072:  for (i = 1; i < (u32)argc; i++) {",
          "3075:   if ((arg[0] != '-') || !stricmp(arg, \"--\")) {",
          "3076:    char *arg_val = arg;",
          "3077:    if (!stricmp(arg, \"--\")) {",
          "3078:     if (i+1==(u32)argc) {",
          "3079:      fprintf(stderr, \"Missing arg for `--` - please check usage\\n\"); return mp4box_cleanup(1);",
          "3080:      return 2;",
          "3082:     has_next_arg = GF_TRUE;",
          "3083:     arg_val = argv[i + 1];",
          "3084:     i++;",
          "3086:    if (argc < 3) {",
          "3087:     fprintf(stderr, \"Error - only one input file found as argument, please check usage\\n\");",
          "3088:     return 2;",
          "3090:    else if (inName) {",
          "3091:     if (dash_duration) {",
          "3092:      if (!nb_dash_inputs) {",
          "3093:       dash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);",
          "3094:      }",
          "3095:      dash_inputs = set_dash_input(dash_inputs, arg_val, &nb_dash_inputs);",
          "3098:      fprintf(stderr, \"Error - 2 input names specified, please check usage\\n\");",
          "3099:      return 2;",
          "3103:     inName = arg_val;",
          "3107:   else if (!stricmp(arg, \"-grab-ts\") || !stricmp(arg, \"-atsc\") || !stricmp(arg, \"-rtp\")) {",
          "3108:    fprintf(stderr, \"Deprecated fuctionnality `%s` - use gpac application\\n\", arg);",
          "3109:    return mp4box_cleanup(2);",
          "3111:   else if (!stricmp(arg, \"-write-buffer\")) {",
          "3112:    fprintf(stderr, \"`%s` option deprecated, use `-bs-cache-size`\", arg);",
          "3113:    gf_opts_set_key(\"temp\", \"bs-cache-size\", argv[i + 1]);",
          "3116:   else if (!stricmp(arg, \"-pssh-moof\")) {",
          "3117:    fprintf(stderr, \"`-pssh-moof` option deprecated , use `-pssh` option\\n\");",
          "3118:    return mp4box_cleanup(2);",
          "3120:   else if (!stricmp(arg, \"-tag-list\")) {",
          "3121:    fprintf(stderr, \"`-tag-list`option deprecated, use `-h tags`\\n\");",
          "3122:    return 1;",
          "3126:   else if (mp4box_parse_single_arg(argc, argv, arg, &i)) {",
          "3127:    if (arg_parse_res)",
          "3128:     return mp4box_cleanup(arg_parse_res);",
          "3131:   else {",
          "3132:    u32 res = gf_sys_is_gpac_arg(arg);",
          "3133:    if (res==0) {",
          "3134:     PrintHelp(arg, GF_FALSE, GF_TRUE);",
          "3136:    } else if (res==2) {",
          "3137:     i++;",
          "3141:   if (live_scene) return 0;",
          "3142:  }",
          "3143:  return 0;",
          "3144: }",
          "3147:  END OF OPTION PARSING CODE",
          "3152: void scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist)",
          "3153: {",
          "3154:  FILE *logs = cbk;",
          "3155:  if (log_tool != GF_LOG_CODING) return;",
          "3156:  vfprintf(logs, fmt, vlist);",
          "3157:  fflush(logs);",
          "3158: }",
          "3161: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "3164:   MP4 File Hinting",
          "3167: void SetupClockReferences(GF_ISOFile *file)",
          "3168: {",
          "3169:  u32 i, count, ocr_id;",
          "3170:  count = gf_isom_get_track_count(file);",
          "3171:  if (count==1) return;",
          "3172:  ocr_id = 0;",
          "3173:  for (i=0; i<count; i++) {",
          "3174:   if (!gf_isom_is_track_in_root_od(file, i+1)) continue;",
          "3175:   ocr_id = gf_isom_get_track_id(file, i+1);",
          "3176:   break;",
          "3177:  }",
          "3179:  if (!ocr_id) return;",
          "3180:  for (i=0; i<count; i++) {",
          "3181:   GF_ESD *esd = gf_isom_get_esd(file, i+1, 1);",
          "3182:   if (esd) {",
          "3183:    esd->OCRESID = ocr_id;",
          "3184:    gf_isom_change_mpeg4_description(file, i+1, 1, esd);",
          "3185:    gf_odf_desc_del((GF_Descriptor *) esd);",
          "3187:  }",
          "3188: }",
          "3191: #define BASE_PAYT  96",
          "3193: GF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)",
          "3194: {",
          "3195:  GF_ESD *esd;",
          "3196:  GF_InitialObjectDescriptor *iod;",
          "3197:  u32 i, val, res, streamType;",
          "3198:  u32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;",
          "3199:  GF_Err e;",
          "3200:  char szPayload[30];",
          "3201:  GF_RTPHinter *hinter;",
          "3202:  Bool copy, has_iod, single_av;",
          "3203:  u8 init_payt = BASE_PAYT;",
          "3204:  u32 mtype;",
          "3205:  GF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;",
          "3206:  u32 media_group = 0;",
          "3207:  u8 media_prio = 0;",
          "3209:  tot_bw = 0;",
          "3210:  prev_ocr = 0;",
          "3211:  single_ocr = 1;",
          "3213:  has_iod = 1;",
          "3214:  iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);",
          "3215:  if (!iod) has_iod = 0;",
          "3216:  else {",
          "3217:   if (!gf_list_count(iod->ESDescriptors)) has_iod = 0;",
          "3218:   gf_odf_desc_del((GF_Descriptor *) iod);",
          "3219:  }",
          "3221:  spec_type = gf_isom_guess_specification(file);",
          "3222:  single_av = single_group ? 1 : gf_isom_is_single_av(file);",
          "3225:  for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "3226:   res = gf_isom_get_media_type(file, i+1);",
          "3227:   if ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {",
          "3228:    if (gf_isom_is_track_in_root_od(file, i+1)) {",
          "3229:     gf_isom_set_default_sync_track(file, i+1);",
          "3230:     break;",
          "3233:  }",
          "3235:  nb_done = 0;",
          "3236:  for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "3237:   sl_mode = base_flags;",
          "3238:   copy = copy_data;",
          "3240:   if (!gf_isom_get_sample_count(file, i+1)) continue;",
          "3241:   if (!gf_isom_is_track_enabled(file, i+1)) {",
          "3242:    fprintf(stderr, \"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) );",
          "3243:    continue;",
          "3246:   mtype = gf_isom_get_media_type(file, i+1);",
          "3247:   switch (mtype) {",
          "3248:   case GF_ISOM_MEDIA_VISUAL:",
          "3249:    if (single_av) {",
          "3250:     media_group = 2;",
          "3251:     media_prio = 2;",
          "3253:    break;",
          "3254:         case GF_ISOM_MEDIA_AUXV:",
          "3255:             if (single_av) {",
          "3256:                 media_group = 2;",
          "3257:                 media_prio = 3;",
          "3258:             }",
          "3259:             break;",
          "3260:         case GF_ISOM_MEDIA_PICT:",
          "3261:             if (single_av) {",
          "3262:                 media_group = 2;",
          "3263:                 media_prio = 4;",
          "3264:             }",
          "3265:             break;",
          "3266:   case GF_ISOM_MEDIA_AUDIO:",
          "3267:    if (single_av) {",
          "3268:     media_group = 2;",
          "3269:     media_prio = 1;",
          "3271:    break;",
          "3272:   case GF_ISOM_MEDIA_HINT:",
          "3273:    continue;",
          "3274:   default:",
          "3276:    if (spec_type==GF_ISOM_BRAND_ISMA) continue;",
          "3278:   mtype = gf_isom_get_media_subtype(file, i+1, 1);",
          "3279:   if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);",
          "3281:   if (!single_av) {",
          "3283:    media_group ++;",
          "3284:    media_prio = 1;",
          "3287:   streamType = 0;",
          "3288:   esd = gf_isom_get_esd(file, i+1, 1);",
          "3289:   if (esd) {",
          "3290:    streamType = esd->decoderConfig->streamType;",
          "3291:    if (!prev_ocr) {",
          "3292:     prev_ocr = esd->OCRESID;",
          "3293:     if (!esd->OCRESID) prev_ocr = esd->ESID;",
          "3294:    } else if (esd->OCRESID && prev_ocr != esd->OCRESID) {",
          "3295:     single_ocr = 0;",
          "3298:    if (streamType==1) copy = 1;",
          "3300:   gf_odf_desc_del((GF_Descriptor *) esd);",
          "3302:   if (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {",
          "3304:    if (gf_isom_get_sample_count(file, i+1)==1) {",
          "3305:     GF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);",
          "3306:     if (streamType) {",
          "3307:      res = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);",
          "3308:     } else {",
          "3310:      res = 0;",
          "3311:     }",
          "3312:     if (samp) gf_isom_sample_del(&samp);",
          "3313:     if (res) continue;",
          "3316:   if (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;",
          "3318:   hinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);",
          "3320:   if (!hinter) {",
          "3321:    if (e) {",
          "3322:     fprintf(stderr, \"Cannot create hinter (%s)\\n\", gf_error_to_string(e));",
          "3323:     if (!nb_done) return e;",
          "3325:    continue;",
          "3328:   if (hint_no_offset)",
          "3329:    gf_hinter_track_force_no_offsets(hinter);",
          "3331:   bw = gf_hinter_track_get_bandwidth(hinter);",
          "3332:   tot_bw += bw;",
          "3333:   flags = gf_hinter_track_get_flags(hinter);",
          "3336:   gf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);",
          "3338:   gf_hinter_track_get_payload_name(hinter, szPayload);",
          "3339:   fprintf(stderr, \"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw);",
          "3340:   if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) fprintf(stderr, \"\\tMPEG-4 Systems stream carousel enabled\\n\");",
          "3342:     if (flags & GP_RTP_PCK_FORCE_MPEG4) fprintf(stderr, \"\\tMPEG4 transport forced\\n\");",
          "3343:     if (flags & GP_RTP_PCK_USE_MULTI) fprintf(stderr, \"\\tRTP aggregation enabled\\n\");",
          "3345:   e = gf_hinter_track_process(hinter);",
          "3347:   if (!e) e = gf_hinter_track_finalize(hinter, has_iod);",
          "3348:   gf_hinter_track_del(hinter);",
          "3350:   if (e) {",
          "3351:    fprintf(stderr, \"Error while hinting (%s)\\n\", gf_error_to_string(e));",
          "3352:    if (!nb_done) return e;",
          "3354:   init_payt++;",
          "3355:   nb_done ++;",
          "3356:  }",
          "3358:  if (has_iod) {",
          "3359:   iod_mode = GF_SDP_IOD_ISMA;",
          "3360:   if (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;",
          "3361:  } else {",
          "3362:   iod_mode = GF_SDP_IOD_NONE;",
          "3363:  }",
          "3364:  gf_hinter_finalize(file, iod_mode, tot_bw);",
          "3366:  if (!single_ocr)",
          "3367:   fprintf(stderr, \"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\");",
          "3369:  return GF_OK;",
          "3370: }",
          "3374: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_AV_PARSERS)",
          "3376: static void check_media_profile(GF_ISOFile *file, u32 track)",
          "3377: {",
          "3378:  u8 PL;",
          "3379:  GF_ESD *esd = gf_isom_get_esd(file, track, 1);",
          "3380:  if (!esd) return;",
          "3382:  switch (esd->decoderConfig->streamType) {",
          "3383:  case 0x04:",
          "3384:   PL = gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL);",
          "3385:   if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {",
          "3386:    GF_M4VDecSpecInfo vdsi;",
          "3387:    gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &vdsi);",
          "3388:    if (vdsi.VideoPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, vdsi.VideoPL);",
          "3389:   } else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {",
          "3390:    gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0x15);",
          "3391:   } else if (!PL) {",
          "3392:    gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFE);",
          "3394:   break;",
          "3395:  case 0x05:",
          "3396:   PL = gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO);",
          "3397:   switch (esd->decoderConfig->objectTypeIndication) {",
          "3398:   case GF_CODECID_AAC_MPEG2_MP:",
          "3399:   case GF_CODECID_AAC_MPEG2_LCP:",
          "3400:   case GF_CODECID_AAC_MPEG2_SSRP:",
          "3401:   case GF_CODECID_AAC_MPEG4:",
          "3402:   {",
          "3403:    GF_M4ADecSpecInfo adsi;",
          "3404:    gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &adsi);",
          "3405:    if (adsi.audioPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, adsi.audioPL);",
          "3407:    break;",
          "3408:   default:",
          "3409:    if (!PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFE);",
          "3411:   break;",
          "3412:  }",
          "3413:  gf_odf_desc_del((GF_Descriptor *) esd);",
          "3414: }",
          "3415: void remove_systems_tracks(GF_ISOFile *file)",
          "3416: {",
          "3417:  u32 i, count;",
          "3419:  count = gf_isom_get_track_count(file);",
          "3420:  if (count==1) return;",
          "3423:  gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0);",
          "3424:  gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0);",
          "3427:  for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "3428:   switch (gf_isom_get_media_type(file, i+1)) {",
          "3429:   case GF_ISOM_MEDIA_VISUAL:",
          "3430:         case GF_ISOM_MEDIA_AUXV:",
          "3431:         case GF_ISOM_MEDIA_PICT:",
          "3432:   case GF_ISOM_MEDIA_AUDIO:",
          "3433:   case GF_ISOM_MEDIA_TEXT:",
          "3434:   case GF_ISOM_MEDIA_SUBT:",
          "3435:    gf_isom_remove_track_from_root_od(file, i+1);",
          "3436:    check_media_profile(file, i+1);",
          "3437:    break;",
          "3440:   case GF_ISOM_MEDIA_SCENE:",
          "3441:    switch (gf_isom_get_media_subtype(file, i+1, 1)) {",
          "3442:    case GF_ISOM_MEDIA_DIMS:",
          "3443:     gf_isom_remove_track_from_root_od(file, i+1);",
          "3444:     continue;",
          "3445:    default:",
          "3446:     break;",
          "3448:   case GF_ISOM_MEDIA_OD:",
          "3449:   case GF_ISOM_MEDIA_OCR:",
          "3450:   case GF_ISOM_MEDIA_MPEGJ:",
          "3451:    gf_isom_remove_track(file, i+1);",
          "3452:    i--;",
          "3453:    break;",
          "3454:   default:",
          "3455:    break;",
          "3457:  }",
          "3459:  if (!gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO)) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFF);",
          "3460:  if (!gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL)) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFF);",
          "3462:  gf_isom_set_pl_indication(file, GF_ISOM_PL_OD, 0xFF);",
          "3463:  gf_isom_set_pl_indication(file, GF_ISOM_PL_SCENE, 0xFF);",
          "3464:  gf_isom_set_pl_indication(file, GF_ISOM_PL_GRAPHICS, 0xFF);",
          "3465:  gf_isom_set_pl_indication(file, GF_ISOM_PL_INLINE, 0);",
          "3466: }",
          "3470: GF_FileType get_file_type_by_ext(char *inName)",
          "3471: {",
          "3472:  GF_FileType type = GF_FILE_TYPE_NOT_SUPPORTED;",
          "3473:  char *ext = strrchr(inName, '.');",
          "3474:  if (ext) {",
          "3475:   char *sep;",
          "3476:   if (!strcmp(ext, \".gz\")) ext = strrchr(ext-1, '.');",
          "3477:   ext+=1;",
          "3478:   sep = strchr(ext, '.');",
          "3479:   if (sep) sep[0] = 0;",
          "3481:   if (!stricmp(ext, \"mp4\") || !stricmp(ext, \"3gp\") || !stricmp(ext, \"mov\") || !stricmp(ext, \"3g2\") || !stricmp(ext, \"3gs\")) {",
          "3482:    type = GF_FILE_TYPE_ISO_MEDIA;",
          "3483:   } else if (!stricmp(ext, \"bt\") || !stricmp(ext, \"wrl\") || !stricmp(ext, \"x3dv\")) {",
          "3484:    type = GF_FILE_TYPE_BT_WRL_X3DV;",
          "3485:   } else if (!stricmp(ext, \"xmt\") || !stricmp(ext, \"x3d\")) {",
          "3486:    type = GF_FILE_TYPE_XMT_X3D;",
          "3487:   } else if (!stricmp(ext, \"lsr\") || !stricmp(ext, \"saf\")) {",
          "3488:    type = GF_FILE_TYPE_LSR_SAF;",
          "3489:   } else if (!stricmp(ext, \"svg\") || !stricmp(ext, \"xsr\") || !stricmp(ext, \"xml\")) {",
          "3490:    type = GF_FILE_TYPE_SVG;",
          "3491:   } else if (!stricmp(ext, \"swf\")) {",
          "3492:    type = GF_FILE_TYPE_SWF;",
          "3493:   } else if (!stricmp(ext, \"jp2\")) {",
          "3494:    if (sep) sep[0] = '.';",
          "3495:    return GF_FILE_TYPE_NOT_SUPPORTED;",
          "3497:   else type = GF_FILE_TYPE_NOT_SUPPORTED;",
          "3499:   if (sep) sep[0] = '.';",
          "3500:  }",
          "3504:  if (!type && gf_isom_probe_file(inName)) type = GF_FILE_TYPE_ISO_MEDIA;",
          "3505:  return type;",
          "3506: }",
          "3509: #ifndef GPAC_DISABLE_CORE_TOOLS",
          "3510: static GF_Err xml_bs_to_bin(char *inName, char *outName, u32 dump_std)",
          "3511: {",
          "3512:  GF_Err e;",
          "3513:  GF_XMLNode *root;",
          "3514:  u8 *data = NULL;",
          "3515:  u32 data_size;",
          "3517:  GF_DOMParser *dom = gf_xml_dom_new();",
          "3518:  e = gf_xml_dom_parse(dom, inName, NULL, NULL);",
          "3519:  if (e) {",
          "3520:   gf_xml_dom_del(dom);",
          "3521:   fprintf(stderr, \"Failed to parse XML file: %s\\n\", gf_error_to_string(e));",
          "3522:   return e;",
          "3523:  }",
          "3524:  root = gf_xml_dom_get_root_idx(dom, 0);",
          "3525:  if (!root) {",
          "3526:   gf_xml_dom_del(dom);",
          "3527:   return GF_OK;",
          "3528:  }",
          "3530:  e = gf_xml_parse_bit_sequence(root, inName, &data, &data_size);",
          "3531:  gf_xml_dom_del(dom);",
          "3533:  if (e) {",
          "3534:   fprintf(stderr, \"Failed to parse binary sequence: %s\\n\", gf_error_to_string(e));",
          "3535:   return e;",
          "3536:  }",
          "3538:  if (dump_std) {",
          "3539:   gf_fwrite(data, data_size, stdout);",
          "3540:  } else {",
          "3541:   FILE *t;",
          "3542:   char szFile[GF_MAX_PATH];",
          "3543:   if (outName) {",
          "3544:    strcpy(szFile, outName);",
          "3545:   } else {",
          "3546:    strcpy(szFile, inName);",
          "3547:    strcat(szFile, \".bin\");",
          "3549:   t = gf_fopen(szFile, \"wb\");",
          "3550:   if (!t) {",
          "3551:    fprintf(stderr, \"Failed to open file %s\\n\", szFile);",
          "3552:    e = GF_IO_ERR;",
          "3553:   } else {",
          "3554:    if (gf_fwrite(data, data_size, t) != data_size) {",
          "3555:     fprintf(stderr, \"Failed to write output to file %s\\n\", szFile);",
          "3556:     e = GF_IO_ERR;",
          "3558:    gf_fclose(t);",
          "3560:  }",
          "3561:  gf_free(data);",
          "3562:  return e;",
          "3563: }",
          "3566: static u64 do_size_top_boxes(char *inName, char *compress_top_boxes, u32 mode)",
          "3567: {",
          "3568:  FILE *in;",
          "3569:  u64 top_size = 0;",
          "3570:  Bool do_all = GF_FALSE;",
          "3571:  GF_BitStream *bs_in;",
          "3572:  if (!compress_top_boxes) return GF_BAD_PARAM;",
          "3573:  if (!strcmp(compress_top_boxes, \"all\") || !strcmp(compress_top_boxes, \"*\") || !strcmp(compress_top_boxes, \"@\"))",
          "3574:   do_all = GF_TRUE;",
          "3576:  in = gf_fopen(inName, \"rb\");",
          "3577:  if (!in) return GF_URL_ERROR;",
          "3578:  bs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);",
          "3579:  while (gf_bs_available(bs_in)) {",
          "3580:   const char *stype;",
          "3581:   u32 hdr_size = 8;",
          "3582:   u64 lsize = gf_bs_read_u32(bs_in);",
          "3583:   u32 type = gf_bs_read_u32(bs_in);",
          "3585:   if (lsize==1) {",
          "3586:    lsize = gf_bs_read_u64(bs_in);",
          "3587:    hdr_size = 16;",
          "3588:   } else if (lsize==0) {",
          "3589:    lsize = gf_bs_available(bs_in) + 8;",
          "3591:   stype = gf_4cc_to_str(type);",
          "3592:   if (do_all || strstr(compress_top_boxes, stype)) {",
          "3594:    if (mode==2) {",
          "3595:     top_size += 1;",
          "3596:    } else {",
          "3597:     top_size += lsize;",
          "3600:   gf_bs_skip_bytes(bs_in, lsize - hdr_size);",
          "3601:  }",
          "3602:  gf_bs_del(bs_in);",
          "3603:  gf_fclose(in);",
          "3604:  return top_size;",
          "3606: }",
          "3608: static GF_Err do_compress_top_boxes(char *inName, char *outName)",
          "3609: {",
          "3610:  FILE *in, *out;",
          "3611:  u8 *buf;",
          "3612:  u32 buf_alloc, comp_size, start_offset;",
          "3613:  s32 bytes_comp=0;",
          "3614:  s32 bytes_uncomp=0;",
          "3615:  GF_Err e = GF_OK;",
          "3616:  u64 source_size, dst_size;",
          "3617:  u32 orig_box_overhead;",
          "3618:  u32 final_box_overhead;",
          "3619:  u32 nb_added_box_bytes=0;",
          "3620:  Bool has_mov = GF_FALSE;",
          "3621:  u32 range_idx;",
          "3622:  Bool replace_all = !strcmp(compress_top_boxes, \"*\");",
          "3623:  GF_BitStream *bs_in, *bs_out;",
          "3624:  u32 nb_moof;",
          "3626:  if (!outName) {",
          "3627:   fprintf(stderr, \"Missing output file name\\n\");",
          "3628:   return GF_BAD_PARAM;",
          "3629:  }",
          "3631:  in = gf_fopen(inName, \"rb\");",
          "3632:  if (!in) return GF_URL_ERROR;",
          "3633:  out = gf_fopen(outName, \"wb\");",
          "3634:  if (!out) return GF_IO_ERR;",
          "3636:  buf_alloc = 4096;",
          "3637:  buf = gf_malloc(buf_alloc);",
          "3639:  bs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);",
          "3640:  source_size = gf_bs_get_size(bs_in);",
          "3642:  bs_out = gf_bs_from_file(out, GF_BITSTREAM_WRITE);",
          "3644:  start_offset = 0;",
          "3645:  nb_moof = 0;",
          "3647:  range_idx = 0;",
          "3648:  orig_box_overhead = 0;",
          "3649:  final_box_overhead = 0;",
          "3650:  while (gf_bs_available(bs_in)) {",
          "3651:   u32 size = gf_bs_read_u32(bs_in);",
          "3652:   u32 type = gf_bs_read_u32(bs_in);",
          "3653:   const char *b4cc = gf_4cc_to_str(type);",
          "3654:   const u8 *replace = (const u8 *) strstr(compress_top_boxes, b4cc);",
          "3655:   if (!strcmp(b4cc, \"moov\")) has_mov = GF_TRUE;",
          "3657:   if (!replace && !replace_all) {",
          "3658:    gf_bs_write_u32(bs_out, size);",
          "3659:    gf_bs_write_u32(bs_out, type);",
          "3661:    size-=8;",
          "3662:    while (size) {",
          "3663:     u32 nbytes = size;",
          "3664:     if (nbytes>buf_alloc) nbytes=buf_alloc;",
          "3665:     gf_bs_read_data(bs_in, buf, nbytes);",
          "3666:     gf_bs_write_data(bs_out, buf, nbytes);",
          "3667:     size-=nbytes;",
          "3669:    continue;",
          "3671:   orig_box_overhead += size;",
          "3673:   size-=8;",
          "3675:   if (size>buf_alloc) {",
          "3676:    buf_alloc = size;",
          "3677:    buf = gf_realloc(buf, buf_alloc);",
          "3678:   }",
          "3679:   gf_bs_read_data(bs_in, buf, size);",
          "3681:   replace+=5;",
          "3683:   comp_size = buf_alloc;",
          "3685:   e = gf_gz_compress_payload(&buf, size, &comp_size);",
          "3686:   if (e) break;",
          "3688:   if (comp_size>buf_alloc) {",
          "3689:    buf_alloc = comp_size;",
          "3690:   }",
          "3691:   bytes_uncomp += size;",
          "3692:   bytes_comp += comp_size;",
          "3695:   gf_bs_write_u32(bs_out, comp_size+8);",
          "3697:   gf_bs_write_data(bs_out, replace, 4);",
          "3699:   gf_bs_write_data(bs_out, buf, comp_size);",
          "3701:   final_box_overhead += 8+comp_size;",
          "3702:  }",
          "3703:  dst_size = gf_bs_get_position(bs_out);",
          "3705:  if (buf) gf_free(buf);",
          "3706:  gf_bs_del(bs_in);",
          "3707:  gf_bs_del(bs_out);",
          "3708:  gf_fclose(in);",
          "3709:  gf_fclose(out);",
          "3710:  if (e) {",
          "3711:   fprintf(stderr, \"Error compressing: %s\\n\", gf_error_to_string(e));",
          "3712:   return e;",
          "3713:  }",
          "3715:  if (has_mov) {",
          "3716:   u32 i, nb_tracks, nb_samples;",
          "3717:   GF_ISOFile *mov;",
          "3718:   Double rate, new_rate, duration;",
          "3720:   mov = gf_isom_open(inName, GF_ISOM_OPEN_READ, NULL);",
          "3721:   duration = (Double) gf_isom_get_duration(mov);",
          "3722:   duration /= gf_isom_get_timescale(mov);",
          "3724:   nb_samples = 0;",
          "3725:   nb_tracks = gf_isom_get_track_count(mov);",
          "3726:   for (i=0; i<nb_tracks; i++) {",
          "3727:    nb_samples += gf_isom_get_sample_count(mov, i+1);",
          "3729:   gf_isom_close(mov);",
          "3731:   rate = (Double) source_size;",
          "3732:   rate /= duration;",
          "3733:   rate /= 1000;",
          "3735:   new_rate = (Double) dst_size;",
          "3736:   new_rate /= duration;",
          "3737:   new_rate /= 1000;",
          "3740:   fprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\torate\\tcrate\\tsamples\\tduration\\tobbps\\tcbbps\\n\");",
          "3741:   fprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\t%g\\t%g\\t%d\\t%g\\t%g\\t%g\\n\", inName, bytes_uncomp, bytes_comp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, nb_samples, duration, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );",
          "3743:   fprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d original rate %g kbps new rate %g kbps, orig %g box bytes/sample final %g bytes/sample\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );",
          "3745:  } else {",
          "3746:   fprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\n\");",
          "3747:   fprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\n\", inName, bytes_uncomp, bytes_comp, ((Double) (bytes_uncomp - bytes_comp)*100)/(bytes_uncomp), nb_added_box_bytes);",
          "3749:   fprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes);",
          "3752:  return GF_OK;",
          "3755: static GF_Err hash_file(char *name, u32 dump_std)",
          "3758:  u8 hash[20];",
          "3759:  GF_Err e = gf_media_get_file_hash(name, hash);",
          "3760:  if (e) return e;",
          "3761:  if (dump_std==2) {",
          "3762:   gf_fwrite(hash, 20, stdout);",
          "3763:  } else if (dump_std==1) {",
          "3764:   for (i=0; i<20; i++) fprintf(stdout, \"%02X\", hash[i]);",
          "3765:  }",
          "3766:  fprintf(stderr, \"File hash (SHA-1): \");",
          "3767:  for (i=0; i<20; i++) fprintf(stderr, \"%02X\", hash[i]);",
          "3768:  fprintf(stderr, \"\\n\");",
          "3770:  return GF_OK;",
          "3771: }",
          "3775: static u32 mp4box_cleanup(u32 ret_code) {",
          "3776:  if (mpd_base_urls) {",
          "3777:   gf_free(mpd_base_urls);",
          "3778:   mpd_base_urls = NULL;",
          "3779:  }",
          "3780:  if (sdp_lines) {",
          "3781:   gf_free(sdp_lines);",
          "3782:   sdp_lines = NULL;",
          "3783:  }",
          "3784:  if (metas) {",
          "3785:   u32 i;",
          "3786:   for (i=0; i<nb_meta_act; i++) {",
          "3787:    if (metas[i].enc_type) gf_free(metas[i].enc_type);",
          "3788:    if (metas[i].mime_type) gf_free(metas[i].mime_type);",
          "3789:    if (metas[i].szName) gf_free(metas[i].szName);",
          "3790:    if (metas[i].szPath) gf_free(metas[i].szPath);",
          "3792:   gf_free(metas);",
          "3793:   metas = NULL;",
          "3794:  }",
          "3795:  if (tracks) {",
          "3796:   u32 i;",
          "3797:   for (i = 0; i<nb_track_act; i++) {",
          "3798:    if (tracks[i].out_name)",
          "3799:     gf_free(tracks[i].out_name);",
          "3800:    if (tracks[i].src_name)",
          "3801:     gf_free(tracks[i].src_name);",
          "3802:    if (tracks[i].string)",
          "3803:     gf_free(tracks[i].string);",
          "3804:    if (tracks[i].kind_scheme)",
          "3805:     gf_free(tracks[i].kind_scheme);",
          "3806:    if (tracks[i].kind_value)",
          "3807:     gf_free(tracks[i].kind_value);",
          "3809:   gf_free(tracks);",
          "3810:   tracks = NULL;",
          "3811:  }",
          "3812:  if (tsel_acts) {",
          "3813:   gf_free(tsel_acts);",
          "3814:   tsel_acts = NULL;",
          "3815:  }",
          "3816:  if (brand_add) {",
          "3817:   gf_free(brand_add);",
          "3818:   brand_add = NULL;",
          "3819:  }",
          "3820:  if (brand_rem) {",
          "3821:   gf_free(brand_rem);",
          "3822:   brand_rem = NULL;",
          "3823:  }",
          "3824:  if (dash_inputs) {",
          "3825:   u32 i, j;",
          "3826:   for (i = 0; i<nb_dash_inputs; i++) {",
          "3827:    GF_DashSegmenterInput *di = &dash_inputs[i];",
          "3828:    if (di->nb_baseURL) {",
          "3829:     for (j = 0; j<di->nb_baseURL; j++) {",
          "3830:      gf_free(di->baseURL[j]);",
          "3831:     }",
          "3832:     gf_free(di->baseURL);",
          "3834:    if (di->rep_descs) {",
          "3835:     for (j = 0; j<di->nb_rep_descs; j++) {",
          "3836:      gf_free(di->rep_descs[j]);",
          "3837:     }",
          "3838:     gf_free(di->rep_descs);",
          "3840:    if (di->as_descs) {",
          "3841:     for (j = 0; j<di->nb_as_descs; j++) {",
          "3842:      gf_free(di->as_descs[j]);",
          "3843:     }",
          "3844:     gf_free(di->as_descs);",
          "3846:    if (di->as_c_descs) {",
          "3847:     for (j = 0; j<di->nb_as_c_descs; j++) {",
          "3848:      gf_free(di->as_c_descs[j]);",
          "3849:     }",
          "3850:     gf_free(di->as_c_descs);",
          "3852:    if (di->p_descs) {",
          "3853:     for (j = 0; j<di->nb_p_descs; j++) {",
          "3854:      gf_free(di->p_descs[j]);",
          "3855:     }",
          "3856:     gf_free(di->p_descs);",
          "3858:    if (di->representationID) gf_free(di->representationID);",
          "3859:    if (di->periodID) gf_free(di->periodID);",
          "3860:    if (di->xlink) gf_free(di->xlink);",
          "3861:    if (di->seg_template) gf_free(di->seg_template);",
          "3862:    if (di->hls_pl) gf_free(di->hls_pl);",
          "3863:    if (di->source_opts) gf_free(di->source_opts);",
          "3864:    if (di->filter_chain) gf_free(di->filter_chain);",
          "3866:    if (di->roles) {",
          "3867:     for (j = 0; j<di->nb_roles; j++) {",
          "3868:      gf_free(di->roles[j]);",
          "3869:     }",
          "3870:     gf_free(di->roles);",
          "3873:   gf_free(dash_inputs);",
          "3874:   dash_inputs = NULL;",
          "3876:  if (logfile) gf_fclose(logfile);",
          "3877:  gf_sys_close();",
          "3878:  return ret_code;",
          "3889: #ifdef TEST_ARGS",
          "3890:  i=0;",
          "3891:  mp4box_parse_single_arg(argc, argv, \"\", &i);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "4770:  if (i) {",
          "4771:   return mp4box_cleanup(i - 1);",
          "4772:  }",
          "4774:  if (!inName && dump_std)",
          "4775:   inName = \"std\";",
          "4777:  if (!inName) {",
          "4778:   if (has_next_arg) {",
          "4779:    fprintf(stderr, \"Broken argument specifier or file name missing - check usage with -h\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3935: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "3936:  if (live_scene) {",
          "3937:   int ret = live_session(argc, argv);",
          "3938:   return mp4box_cleanup(ret);",
          "3939:  }",
          "3940: #endif",
          "3942:  if (do_mpd_conv) inName = do_mpd_conv;",
          "3944:  if (import_flags & GF_IMPORT_FORCE_MPEG4)",
          "3945:   hint_flags |= GP_RTP_PCK_FORCE_MPEG4;",
          "3950:  if (!dash_duration && cprt)",
          "3951:   open_edit = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "4812:   }",
          "4813:  }",
          "4822:  GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO;",
          "4823:  gf_log_set_tool_level(GF_LOG_CONTAINER, level);",
          "4824:  gf_log_set_tool_level(GF_LOG_SCENE, level);",
          "",
          "[Removed Lines]",
          "4815: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "4816:  if (live_scene) {",
          "4817:   int ret = live_session(argc, argv);",
          "4818:   return mp4box_cleanup(ret);",
          "4819:  }",
          "4820: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "4870:    fprintf(stdout, LLU\"\\n\", top_size);",
          "4871:    return mp4box_cleanup(e ? 1 : 0);",
          "4872:   } else {",
          "4874:    return mp4box_cleanup(e ? 1 : 0);",
          "4875:   }",
          "4876:  }",
          "",
          "[Removed Lines]",
          "4873:    e = do_compress_top_boxes(inName, outName, compress_top_boxes, comp_top_box_version, comp_lzma);",
          "",
          "[Added Lines]",
          "4042:    e = do_compress_top_boxes(inName, outName);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "4911:  }",
          "4913: #ifndef GPAC_DISABLE_MPD",
          "4915:   Bool remote = GF_FALSE;",
          "4916:   GF_MPD *mpd;",
          "4917:   char *mpd_base_url = NULL;",
          "",
          "[Removed Lines]",
          "4914:  if (do_mpd) {",
          "",
          "[Added Lines]",
          "4083:  if (do_mpd_conv) {",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "5261: #ifndef GPAC_DISABLE_AV_PARSERS",
          "5262:   if (!keep_sys_tracks) remove_systems_tracks(file);",
          "5263: #endif",
          "5265:  }",
          "",
          "[Removed Lines]",
          "5264:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "4433:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "5303:   e = EncodeFile(inName, file, &smenc_opts, logs);",
          "5304:   if (logs) gf_fclose(logs);",
          "5305:   if (e) goto err_exit;",
          "5307:   if (do_saf) {",
          "5309:    open_edit = GF_FALSE;",
          "5310:   }",
          "5311: #endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "",
          "[Removed Lines]",
          "5306:   needSave = GF_TRUE;",
          "5308:    needSave = GF_FALSE;",
          "",
          "[Added Lines]",
          "4475:   do_save = GF_TRUE;",
          "4477:    do_save = GF_FALSE;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "5326:    }",
          "5327:   }",
          "5328:   if (!outName) outName = inName;",
          "5330:   open_edit = GF_TRUE;",
          "5331:  }",
          "5332: #endif //GPAC_DISABLE_ISOM_WRITE",
          "",
          "[Removed Lines]",
          "5329:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "4498:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "5390:    fprintf(stderr, \"Using default MPD refresh of %g seconds\\n\", mpd_update_time);",
          "5391:   }",
          "5394:    gf_isom_close(file);",
          "5395:    file = NULL;",
          "5396:    del_file = GF_TRUE;",
          "",
          "[Removed Lines]",
          "5393:   if (file && needSave) {",
          "",
          "[Added Lines]",
          "4562:   if (file && do_save) {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "5659:     if (dump_m2ts) {",
          "5660: #ifndef GPAC_DISABLE_MPEG2TS",
          "5662: #endif",
          "5663:     } else if (dump_timestamps) {",
          "5664: #ifndef GPAC_DISABLE_MPEG2TS",
          "5666: #endif",
          "5667: #ifndef GPAC_DISABLE_CORE_TOOLS",
          "5668:     } else if (do_bin_xml) {",
          "",
          "[Removed Lines]",
          "5661:      dump_mpeg2_ts(inName, pes_dump, program_number);",
          "5665:      dump_mpeg2_ts(inName, pes_dump, program_number);",
          "",
          "[Added Lines]",
          "4830:      dump_mpeg2_ts(inName, outName, program_number);",
          "4834:      dump_mpeg2_ts(inName, outName, program_number);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "5795: #endif",
          "5797: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "5799: #endif",
          "5800:  if (get_nb_tracks) {",
          "5801:   fprintf(stdout, \"%d\\n\", gf_isom_get_track_count(file));",
          "",
          "[Removed Lines]",
          "5798:  if (!HintIt && print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);",
          "",
          "[Added Lines]",
          "4967:  if (!do_hint && print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "5891:   open_edit = GF_FALSE;",
          "5893:  }",
          "5894: #endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "",
          "[Removed Lines]",
          "5892:   needSave = GF_FALSE;",
          "",
          "[Added Lines]",
          "5061:   do_save = GF_FALSE;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "5962:    e = gf_isom_set_meta_type(file, meta->root_meta, tk, meta->meta_4cc);",
          "5963:    gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO2, GF_TRUE);",
          "5965:    break;",
          "5966:   case META_ACTION_ADD_ITEM:",
          "5967:    self_ref = !stricmp(meta->szPath, \"NULL\") || !stricmp(meta->szPath, \"this\") || !stricmp(meta->szPath, \"self\");",
          "",
          "[Removed Lines]",
          "5964:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5133:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "5980:      e = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);",
          "5981:     }",
          "5982:    }",
          "5984:    break;",
          "5985:   case META_ACTION_ADD_IMAGE_ITEM:",
          "5986:   {",
          "",
          "[Removed Lines]",
          "5983:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5152:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "6067:      e = GF_NOT_SUPPORTED;",
          "6068:     }",
          "6069:    }",
          "6071:   }",
          "6072:    break;",
          "6073:   case META_ACTION_ADD_IMAGE_GRID:",
          "",
          "[Removed Lines]",
          "6070:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5239:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "6102:       }",
          "6103:      }",
          "6104:     }",
          "6106:    }",
          "6107:    break;",
          "6108:   case META_ACTION_REM_ITEM:",
          "6109:    e = gf_isom_remove_meta_item(file, meta->root_meta, tk, meta->item_id);",
          "6111:    break;",
          "6112:   case META_ACTION_SET_PRIMARY_ITEM:",
          "6113:    e = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);",
          "6115:    break;",
          "6116:   case META_ACTION_SET_XML:",
          "6117:   case META_ACTION_SET_BINARY_XML:",
          "6118:    e = gf_isom_set_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL, 0, (meta->act_type==META_ACTION_SET_BINARY_XML) ? 1 : 0);",
          "6120:    break;",
          "6121:   case META_ACTION_REM_XML:",
          "6122:    if (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {",
          "6123:     e = gf_isom_remove_meta_xml(file, meta->root_meta, tk);",
          "6125:    } else {",
          "6126:     fprintf(stderr, \"No meta box in input file\\n\");",
          "6127:    }",
          "",
          "[Removed Lines]",
          "6105:     needSave = GF_TRUE;",
          "6110:    needSave = GF_TRUE;",
          "6114:    needSave = GF_TRUE;",
          "6119:    needSave = GF_TRUE;",
          "6124:     needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5274:     do_save = GF_TRUE;",
          "5279:    do_save = GF_TRUE;",
          "5283:    do_save = GF_TRUE;",
          "5288:    do_save = GF_TRUE;",
          "5293:     do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "6158:   }",
          "6159:   if (e) goto err_exit;",
          "6160:  }",
          "6162:   if (file) gf_isom_delete(file);",
          "6163:   goto exit;",
          "6164:  }",
          "",
          "[Removed Lines]",
          "6161:  if (!open_edit && !needSave) {",
          "",
          "[Added Lines]",
          "5330:  if (!open_edit && !do_save) {",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "6168:  if (clean_groups) {",
          "6169:   e = gf_isom_reset_switch_parameters(file);",
          "6170:   if (e) goto err_exit;",
          "6172:  }",
          "6174:  for (i=0; i<nb_tsel_acts; i++) {",
          "",
          "[Removed Lines]",
          "6171:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5340:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "6189:      fprintf(stderr, \"Hint: for creates a new grouping information, using -group-add -trackID=ID1:[criteria:]trackID=ID2\\n\");",
          "6190:    }",
          "6191:    if (e) goto err_exit;",
          "6193:    break;",
          "6194:   case TSEL_ACTION_REMOVE_TSEL:",
          "6195:    e = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 0);",
          "6196:    if (e) goto err_exit;",
          "6198:    break;",
          "6199:   case TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP:",
          "6200:    e = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 1);",
          "6201:    if (e) goto err_exit;",
          "6203:    break;",
          "6204:   default:",
          "6205:    break;",
          "",
          "[Removed Lines]",
          "6192:    needSave = GF_TRUE;",
          "6197:    needSave = GF_TRUE;",
          "6202:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5361:    do_save = GF_TRUE;",
          "5366:    do_save = GF_TRUE;",
          "5371:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "6210: #ifndef GPAC_DISABLE_AV_PARSERS",
          "6211:   remove_systems_tracks(file);",
          "6212: #endif",
          "6214:   if (conv_type < GF_ISOM_CONV_TYPE_ISMA_EX) conv_type = 0;",
          "6215:  }",
          "6216:  if (remove_root_od) {",
          "6217:   gf_isom_remove_root_od(file);",
          "6219:  }",
          "6220: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "6221:  if (remove_hint) {",
          "",
          "[Removed Lines]",
          "6213:   needSave = GF_TRUE;",
          "6218:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5382:   do_save = GF_TRUE;",
          "5387:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "6227:    }",
          "6228:   }",
          "6229:   gf_isom_sdp_clean(file);",
          "6231:  }",
          "6232: #endif // GPAC_DISABLE_ISOM_HINTING",
          "6234:  if (timescale && (timescale != gf_isom_get_timescale(file))) {",
          "6235:   gf_isom_set_timescale(file, timescale);",
          "6237:  }",
          "6239:  if (!encode) {",
          "",
          "[Removed Lines]",
          "6230:   needSave = GF_TRUE;",
          "6236:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5399:   do_save = GF_TRUE;",
          "5405:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "6269:    e = gf_media_make_isma(file, crypt ? 1 : 0, GF_FALSE, (conv_type==GF_ISOM_CONV_TYPE_ISMA_EX) ? 1 : 0);",
          "6270:    if (e) goto err_exit;",
          "6272:   }",
          "6273:   if (conv_type == GF_ISOM_CONV_TYPE_3GPP) {",
          "6274:    fprintf(stderr, \"Converting to 3GP file...\\n\");",
          "6275:    e = gf_media_make_3gpp(file);",
          "6276:    if (e) goto err_exit;",
          "6278:   }",
          "6279:   if (conv_type == GF_ISOM_CONV_TYPE_PSP) {",
          "6280:    fprintf(stderr, \"Converting to PSP file...\\n\");",
          "6281:    e = gf_media_make_psp(file);",
          "6282:    if (e) goto err_exit;",
          "6284:   }",
          "6285:   if (conv_type == GF_ISOM_CONV_TYPE_MOV) {",
          "6286:    e = gf_media_check_qt_prores(file);",
          "6287:    if (e) goto err_exit;",
          "6289:    if (interleaving_time) interleaving_time = 0.5;",
          "6290:   }",
          "",
          "[Removed Lines]",
          "6271:    needSave = GF_TRUE;",
          "6277:    needSave = GF_TRUE;",
          "6283:    needSave = GF_TRUE;",
          "6288:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5440:    do_save = GF_TRUE;",
          "5446:    do_save = GF_TRUE;",
          "5452:    do_save = GF_TRUE;",
          "5457:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "6334:    }",
          "6335:    gf_isom_set_brand_info(file, ipod_major_brand, 1);",
          "6336:    gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MP42, GF_TRUE);",
          "6338:   }",
          "6340:  } else if (outName) {",
          "",
          "[Removed Lines]",
          "6337:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5506:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "6354:    } else {",
          "6355:     fprintf(stderr, \"Removing track ID %d\\n\", tka->trackID);",
          "6356:    }",
          "6358:    break;",
          "6359:   case TRAC_ACTION_SET_LANGUAGE:",
          "6360:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "6361:     if (track && (track != i+1)) continue;",
          "6362:     e = gf_isom_set_media_language(file, i+1, tka->lang);",
          "6363:     if (e) goto err_exit;",
          "6365:    }",
          "6367:    break;",
          "6368:   case TRAC_ACTION_SET_KIND:",
          "6369:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "6370:     if (track && (track != i+1)) continue;",
          "6371:     e = gf_isom_add_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "6372:     if (e) goto err_exit;",
          "6374:    }",
          "6376:    break;",
          "6377:   case TRAC_ACTION_REM_KIND:",
          "6378:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "6379:     if (track && (track != i+1)) continue;",
          "6380:     e = gf_isom_remove_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "6381:     if (e) goto err_exit;",
          "6383:    }",
          "6385:    break;",
          "6386:   case TRAC_ACTION_SET_DELAY:",
          "6387:    if (tka->delay.num && tka->delay.den) {",
          "",
          "[Removed Lines]",
          "6357:    needSave = GF_TRUE;",
          "6364:     needSave = GF_TRUE;",
          "6366:    needSave = GF_TRUE;",
          "6373:     needSave = GF_TRUE;",
          "6375:    needSave = GF_TRUE;",
          "6382:     needSave = GF_TRUE;",
          "6384:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5526:    do_save = GF_TRUE;",
          "5533:     do_save = GF_TRUE;",
          "5535:    do_save = GF_TRUE;",
          "5542:     do_save = GF_TRUE;",
          "5544:    do_save = GF_TRUE;",
          "5551:     do_save = GF_TRUE;",
          "5553:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "6390:     gf_isom_remove_edits(file, track);",
          "6391:     tk_dur = gf_isom_get_track_duration(file, track);",
          "6392:     if (gf_isom_get_edits_count(file, track))",
          "6394:     if (tka->delay.num>0) {",
          "6396:      gf_isom_append_edit(file, track, ((u64) tka->delay.num) * timescale / tka->delay.den, 0, GF_ISOM_EDIT_EMPTY);",
          "6397:      gf_isom_append_edit(file, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);",
          "6399:     } else {",
          "6401:      u64 to_skip = ((u64) -tka->delay.num) * timescale / tka->delay.den;",
          "",
          "[Removed Lines]",
          "6393:      needSave = GF_TRUE;",
          "6398:      needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5562:      do_save = GF_TRUE;",
          "5567:      do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "6404:       u64 media_time = ((u64) -tka->delay.num) * gf_isom_get_media_timescale(file, track) / tka->delay.den;",
          "6405:       gf_isom_append_edit(file, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);",
          "6407:      } else {",
          "6408:       fprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");",
          "6409:      }",
          "6410:     }",
          "6411:    } else if (gf_isom_get_edits_count(file, track)) {",
          "6412:     gf_isom_remove_edits(file, track);",
          "6414:    }",
          "6415:    break;",
          "6416:   case TRAC_ACTION_SET_KMS_URI:",
          "",
          "[Removed Lines]",
          "6406:       needSave = GF_TRUE;",
          "6413:     needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5575:       do_save = GF_TRUE;",
          "5582:     do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "6420:     if (!gf_isom_is_ismacryp_media(file, i+1, 1)) continue;",
          "6421:     e = gf_isom_change_ismacryp_protection(file, i+1, 1, NULL, (char *) tka->kms);",
          "6422:     if (e) goto err_exit;",
          "6424:    }",
          "6425:    break;",
          "6426:   case TRAC_ACTION_SET_ID:",
          "",
          "[Removed Lines]",
          "6423:     needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5592:     do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "6435:      fprintf(stderr, \"Error: Cannot set track id with value %d because a track already exists - ignoring\", tka->newTrackID);",
          "6436:     } else {",
          "6437:      e = gf_isom_set_track_id(file, track, tka->newTrackID);",
          "6439:     }",
          "6440:    } else {",
          "6441:     fprintf(stderr, \"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID);",
          "",
          "[Removed Lines]",
          "6438:      needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5607:      do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "6452:      e = gf_isom_set_track_id(file, tk2, 0);",
          "6453:      if (!e) e = gf_isom_set_track_id(file, tk1, tka->newTrackID);",
          "6454:      if (!e) e = gf_isom_set_track_id(file, tk2, tka->trackID);",
          "6456:     }",
          "6457:    } else {",
          "6458:     fprintf(stderr, \"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID);",
          "",
          "[Removed Lines]",
          "6455:      needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5624:      do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "6460:    break;",
          "6461:   case TRAC_ACTION_SET_PAR:",
          "6462:    e = gf_media_change_par(file, track, tka->par_num, tka->par_den, tka->force_par, tka->rewrite_bs);",
          "6464:    break;",
          "6465:   case TRAC_ACTION_SET_CLAP:",
          "6466:    e = gf_isom_set_clean_aperture(file, track, 1, tka->clap_wnum, tka->clap_wden, tka->clap_hnum, tka->clap_hden, tka->clap_honum, tka->clap_hoden, tka->clap_vonum, tka->clap_voden);",
          "6468:    break;",
          "6469:   case TRAC_ACTION_SET_MX:",
          "6470:    e = gf_isom_set_track_matrix(file, track, tka->mx);",
          "6472:    break;",
          "6473:   case TRAC_ACTION_SET_HANDLER_NAME:",
          "6474:    e = gf_isom_set_handler_name(file, track, tka->hdl_name);",
          "6476:    break;",
          "6477:   case TRAC_ACTION_ENABLE:",
          "6478:    if (!gf_isom_is_track_enabled(file, track)) {",
          "6479:     e = gf_isom_set_track_enabled(file, track, GF_TRUE);",
          "6481:    }",
          "6482:    break;",
          "6483:   case TRAC_ACTION_DISABLE:",
          "6484:    if (gf_isom_is_track_enabled(file, track)) {",
          "6485:     e = gf_isom_set_track_enabled(file, track, GF_FALSE);",
          "6487:    }",
          "6488:    break;",
          "6489:   case TRAC_ACTION_REFERENCE:",
          "6490:    e = gf_isom_set_track_reference(file, track, GF_4CC(tka->lang[0], tka->lang[1], tka->lang[2], tka->lang[3]), tka->newTrackID);",
          "6492:    break;",
          "6493:   case TRAC_ACTION_REM_NON_RAP:",
          "6494:    fprintf(stderr, \"Removing non-rap samples from track %d\\n\", tka->trackID);",
          "6495:    e = gf_media_remove_non_rap(file, track, GF_FALSE);",
          "6497:    break;",
          "6498:   case TRAC_ACTION_REM_NON_REFS:",
          "6499:    fprintf(stderr, \"Removing non-reference samples from track %d\\n\", tka->trackID);",
          "6500:    e = gf_media_remove_non_rap(file, track, GF_TRUE);",
          "6502:    break;",
          "6503:   case TRAC_ACTION_SET_UDTA:",
          "6504:    fprintf(stderr, \"Assigning udta box\\n\");",
          "6505:    e = set_file_udta(file, track, tka->udta_type, tka->string ? tka->string : tka->src_name , tka->sample_num ? GF_TRUE : GF_FALSE, tka->string ? GF_TRUE : GF_FALSE);",
          "6506:    if (e) goto err_exit;",
          "6508:    break;",
          "6509:   case TRAC_ACTION_SET_EDITS:",
          "6510:    e = apply_edits(file, track, tka->string);",
          "6512:    break;",
          "6513:   default:",
          "6514:    break;",
          "",
          "[Removed Lines]",
          "6463:    needSave = GF_TRUE;",
          "6467:    needSave = GF_TRUE;",
          "6471:    needSave = GF_TRUE;",
          "6475:    needSave = GF_TRUE;",
          "6480:     needSave = GF_TRUE;",
          "6486:     needSave = GF_TRUE;",
          "6491:    needSave = GF_TRUE;",
          "6496:    needSave = GF_TRUE;",
          "6501:    needSave = GF_TRUE;",
          "6507:    needSave = GF_TRUE;",
          "6511:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5632:    do_save = GF_TRUE;",
          "5636:    do_save = GF_TRUE;",
          "5640:    do_save = GF_TRUE;",
          "5644:    do_save = GF_TRUE;",
          "5649:     do_save = GF_TRUE;",
          "5655:     do_save = GF_TRUE;",
          "5660:    do_save = GF_TRUE;",
          "5665:    do_save = GF_TRUE;",
          "5670:    do_save = GF_TRUE;",
          "5676:    do_save = GF_TRUE;",
          "5680:    do_save = GF_TRUE;",
          "5681:    break;",
          "5682:   case TRAC_ACTION_SET_TIME:",
          "5683:    if (!tka->trackID) {",
          "5684:     e = gf_isom_set_creation_time(file, tka->time, tka->time);",
          "5685:     if (e) goto err_exit;",
          "5686:     for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5687:      e = gf_isom_set_track_creation_time(file, i+1, tka->time, tka->time);",
          "5688:      if (e) goto err_exit;",
          "5689:     }",
          "5690:    } else {",
          "5691:     e = gf_isom_set_track_creation_time(file, track, tka->time, tka->time);",
          "5692:     if (e) goto err_exit;",
          "5693:    }",
          "5694:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "6595:     fprintf(stderr, \"Error assigning tag %s: %s\\n\", tags, gf_error_to_string(e) );",
          "6596:    }",
          "6600:    if (sep) {",
          "6601:     sep[0] = itunes_data ? '\\n' : ':';",
          "",
          "[Removed Lines]",
          "6598:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5781:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "6607:   if (itunes_data) gf_free(itunes_data);",
          "6608:  }",
          "6618:  if (cprt) {",
          "6619:   e = gf_isom_set_copyright(file, \"und\", cprt);",
          "6621:   if (e) goto err_exit;",
          "6622:  }",
          "6624: #ifndef GPAC_DISABLE_MEDIA_IMPORT",
          "6625:   e = gf_media_import_chapters(file, chap_file, import_fps, chap_qt);",
          "6627: #else",
          "6628:   fprintf(stderr, \"Warning: GPAC compiled without Media Import, chapters can't be imported\\n\");",
          "6629:   e = GF_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "6610:  if (movie_time) {",
          "6611:   gf_isom_set_creation_time(file, movie_time, movie_time);",
          "6612:   for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "6613:    gf_isom_set_track_creation_time(file, i+1, movie_time, movie_time);",
          "6614:   }",
          "6615:   needSave = GF_TRUE;",
          "6616:  }",
          "6620:   needSave = GF_TRUE;",
          "6623:  if (chap_file) {",
          "6626:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5795:   do_save = GF_TRUE;",
          "5798:  if (chap_file || chap_file_qt) {",
          "5800:   Bool chap_qt = GF_FALSE;",
          "5801:   if (chap_file_qt) {",
          "5802:    chap_file = chap_file_qt;",
          "5803:    chap_qt = GF_TRUE;",
          "5804:   }",
          "5806:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "6634:  if (major_brand) {",
          "6635:   gf_isom_set_brand_info(file, major_brand, minor_version);",
          "6637:  }",
          "6638:  for (i=0; i<nb_alt_brand_add; i++) {",
          "6639:   gf_isom_modify_alternate_brand(file, brand_add[i], GF_TRUE);",
          "6641:  }",
          "6642:  for (i=0; i<nb_alt_brand_rem; i++) {",
          "6643:   gf_isom_modify_alternate_brand(file, brand_rem[i], GF_FALSE);",
          "6645:  }",
          "6646:  if (box_patch_filename) {",
          "6647:   e = gf_isom_apply_box_patch(file, box_patch_trackID, box_patch_filename, GF_FALSE);",
          "",
          "[Removed Lines]",
          "6636:   needSave = GF_TRUE;",
          "6640:   needSave = GF_TRUE;",
          "6644:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5816:   do_save = GF_TRUE;",
          "5820:   do_save = GF_TRUE;",
          "5824:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "6649:    fprintf(stderr, \"Failed to apply box patch %s: %s\\n\", box_patch_filename, gf_error_to_string(e) );",
          "6650:    goto err_exit;",
          "6651:   }",
          "6653:  }",
          "6655: #ifndef GPAC_DISABLE_CRYPTO",
          "",
          "[Removed Lines]",
          "6652:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5832:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "6678:    }",
          "6679:   }",
          "6680:   if (e) goto err_exit;",
          "6684:    char szName[GF_MAX_PATH];",
          "6685:    strcpy(szName, gf_isom_get_filename(file) );",
          "6686:    gf_isom_delete(file);",
          "",
          "[Removed Lines]",
          "6681:   needSave = outName ? GF_FALSE : GF_TRUE;",
          "6683:   if (!Frag && !HintIt && !FullInter && !force_co64) {",
          "",
          "[Added Lines]",
          "5861:   do_save = outName ? GF_FALSE : GF_TRUE;",
          "5863:   if (!do_frag && !do_hint && !full_interleave && !force_co64) {",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "6697: #ifndef GPAC_DISABLE_ISOM_FRAGMENTS",
          "6699:   if (!interleaving_time) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC;",
          "6701:   fprintf(stderr, \"Fragmenting file (%.3f seconds fragments)\\n\", interleaving_time);",
          "6702:   e = gf_media_fragment_file(file, outfile, interleaving_time, use_mfra);",
          "6703:   if (e) fprintf(stderr, \"Error while fragmenting file: %s\\n\", gf_error_to_string(e));",
          "",
          "[Removed Lines]",
          "6698:  if (Frag) {",
          "6700:   if (HintIt) fprintf(stderr, \"Warning: cannot hint and fragment - ignoring hint\\n\");",
          "",
          "[Added Lines]",
          "5878:  if (do_frag) {",
          "5880:   if (do_hint) fprintf(stderr, \"Warning: cannot hint and fragment - ignoring hint\\n\");",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "6712: #endif",
          "6714: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "6716:   if (force_ocr) SetupClockReferences(file);",
          "6717:   fprintf(stderr, \"Hinting file with Path-MTU %d Bytes\\n\", MTUSize);",
          "6718:   MTUSize -= 12;",
          "6720:   if (e) goto err_exit;",
          "6722:   if (print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);",
          "6723:  }",
          "6724: #endif",
          "",
          "[Removed Lines]",
          "6715:  if (HintIt) {",
          "6719:   e = HintFile(file, MTUSize, max_ptime, rtp_rate, hint_flags, HintCopy, HintInter, regular_iod, single_group, hint_no_offset);",
          "6721:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5895:  if (do_hint) {",
          "5899:   e = HintFile(file, MTUSize, max_ptime, rtp_rate, hint_flags, HintCopy, hint_interleave, regular_iod, single_group, hint_no_offset);",
          "5901:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "6746:     }",
          "6747:    }",
          "6748:    gf_isom_sdp_add_track_line(file, track, sdp_lines[i].line);",
          "6750:   } else {",
          "6751:    gf_isom_sdp_add_line(file, sdp_lines[i].line);",
          "6753:   }",
          "6754:  }",
          "",
          "[Removed Lines]",
          "6749:    needSave = GF_TRUE;",
          "6752:    needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5929:    do_save = GF_TRUE;",
          "5932:    do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "6780:   e = gf_isom_set_storage_mode(file, GF_ISOM_STORE_TIGHT);",
          "6781:  } else if (do_flat) {",
          "6782:   e = gf_isom_set_storage_mode(file, (do_flat==1) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE);",
          "6784:  }",
          "6786:  else if (!is_inplace) {",
          "",
          "[Removed Lines]",
          "6779:  if (FullInter) {",
          "6783:   needSave = GF_TRUE;",
          "",
          "[Added Lines]",
          "5959:  if (full_interleave) {",
          "5963:   do_save = GF_TRUE;",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "6791:  if (e) goto err_exit;",
          "6796:   if (!gf_sys_is_quiet()) {",
          "6797:    if (outName) {",
          "",
          "[Removed Lines]",
          "6794:  if (needSave) {",
          "",
          "[Added Lines]",
          "5974:  if (do_save) {",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "6801:     fprintf(stderr, \"Saving %s: \", inName);",
          "6802:    }",
          "6803:    if (is_inplace) fprintf(stderr, \"In-place rewrite\\n\");",
          "6806:    else if ((force_new==2) && interleaving_time) fprintf(stderr, \"Fast-start interleaved storage\\n\");",
          "6807:    else if (do_flat || !interleaving_time) fprintf(stderr, \"Flat storage\\n\");",
          "6808:    else fprintf(stderr, \"%.3f secs Interleaving%s\\n\", interleaving_time, old_interleave ? \" - no drift control\" : \"\");",
          "",
          "[Removed Lines]",
          "6804:    else if (HintIt && FullInter) fprintf(stderr, \"Hinted file - Full Interleaving\\n\");",
          "6805:    else if (FullInter) fprintf(stderr, \"Full Interleaving\\n\");",
          "",
          "[Added Lines]",
          "5984:    else if (do_hint && full_interleave) fprintf(stderr, \"Hinted file - Full Interleaving\\n\");",
          "5985:    else if (full_interleave) fprintf(stderr, \"Full Interleaving\\n\");",
          "",
          "---------------"
        ],
        "applications/mp4box/mp4box.h||applications/mp4box/mp4box.h": [
          "File: applications/mp4box/mp4box.h -> applications/mp4box/mp4box.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "93: #ifndef GPAC_DISABLE_SCENE_STATS",
          "94: void dump_isom_scene_stats(char *file, char *inName, Bool is_final_name, u32 stat_level);",
          "95: #endif",
          "100: #ifndef GPAC_DISABLE_ISOM_DUMP",
          "101: GF_Err dump_isom_xml(GF_ISOFile *file, char *inName, Bool is_final_name, Bool do_track_dump, Bool merge_vtt_cues, Bool skip_init, Bool skip_samples);",
          "",
          "[Removed Lines]",
          "96: void PrintNode(const char *name, u32 graph_type);",
          "97: void PrintBuiltInNodes(u32 graph_type, Bool dump_all);",
          "98: void PrintBuiltInBoxes(Bool do_cov);",
          "",
          "[Added Lines]",
          "96: u32 PrintNode(const char *name, u32 graph_type);",
          "97: u32 PrintBuiltInNodes(char *arg_val, u32 dump_type);",
          "98: u32 PrintBuiltInBoxes(char *arg_val, u32 do_cov);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122: void DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys);",
          "123: void DumpMovieInfo(GF_ISOFile *file);",
          "126: #ifndef GPAC_DISABLE_MPEG2TS",
          "127: void dump_mpeg2_ts(char *mpeg2ts_file, char *pes_out_name, Bool prog_num);",
          "",
          "[Removed Lines]",
          "124: void PrintLanguages();",
          "",
          "[Added Lines]",
          "124: u32 PrintLanguages(char *argv, u32 opt);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144: GF_Err cat_playlist(GF_ISOFile *dest, char *playlistName, u32 import_flags, GF_Fraction force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command);",
          "146: #endif // _MP4BOX_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147: static u32 parse_track_dump(char *arg, u32 dump_type);",
          "148: static u32 parse_track_action(char *arg, u32 act_type);",
          "149: static u32 parse_sdp_ext(char *arg_val, u32 param);",
          "150: u32 parse_help(char *arg_val, u32 opt);",
          "151: u32 parse_gendoc(char *name, u32 opt);",
          "152: u32 parse_comp_box(char *arg_val, u32 opt);",
          "153: u32 parse_dnal(char *arg_val, u32 opt);",
          "154: u32 parse_dsap(char *arg_val, u32 opt);",
          "155: u32 parse_bs_switch(char *arg_val, u32 opt);",
          "156: u32 parse_cp_loc(char *arg_val, u32 opt);",
          "157: u32 parse_pssh(char *arg_val, u32 opt);",
          "158: u32 parse_sdtp(char *arg_val, u32 opt);",
          "159: u32 parse_dash_profile(char *arg_val, u32 opt);",
          "160: u32 parse_rap_ref(char *arg_val, u32 opt);",
          "161: u32 parse_store_mode(char *arg_val, u32 opt);",
          "162: u32 parse_base_url(char *arg_val, u32 opt);",
          "163: u32 parse_multi_rtp(char *arg_val, u32 opt);",
          "164: u32 parse_senc_param(char *arg_val, u32 opt);",
          "165: u32 parse_cryp(char *arg_val, u32 opt);",
          "166: u32 parse_fps(char *arg_val, u32 opt);",
          "167: u32 parse_split(char *arg_val, u32 opt);",
          "168: u32 parse_brand(char *b, u32 opt);",
          "169: u32 parse_mpegu(char *arg_val, u32 opt);",
          "170: u32 parse_file_info(char *arg_val, u32 opt);",
          "171: u32 parse_boxpatch(char *arg_val, u32 opt);",
          "172: u32 parse_aviraw(char *arg_val, u32 opt);",
          "173: u32 parse_dump_udta(char *code, u32 opt);",
          "174: u32 parse_dump_ts(char *arg_val, u32 opt);",
          "175: u32 parse_ttxt(char *arg_val, u32 opt);",
          "176: u32 parse_dashlive(char *arg, char *arg_val, u32 opt);",
          "",
          "---------------"
        ],
        "include/gpac/main.h||include/gpac/main.h": [
          "File: include/gpac/main.h -> include/gpac/main.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "91: #endif //win32",
          "94: typedef struct",
          "95: {",
          "110: } GF_GPACArg;",
          "",
          "[Removed Lines]",
          "97:  const char *name;",
          "99:  const char *altname;",
          "101:  const char *description;",
          "103:  const char *val;",
          "105:  const char *values;",
          "107:  u16 type;",
          "109:  u16 flags;",
          "",
          "[Added Lines]",
          "94: #define GF_GPAC_ARG_BASE \\",
          "96:  const char *name; \\",
          "98:  const char *altname; \\",
          "100:  const char *description; \\",
          "102:  const char *val; \\",
          "104:  const char *values; \\",
          "106:  u16 type; \\",
          "108:  u16 flags; \\",
          "115:  GF_GPAC_ARG_BASE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146: #define GF_ARG_STRING 3",
          "148: #define GF_ARG_STRINGS 4",
          "151: #define GF_DEF_ARG(_a, _b, _c, _d, _e, _f, _g) {_a, _b, _c, _d, _e, _f, _g}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156: #define GF_ARG_CUSTOM 5",
          "",
          "---------------"
        ],
        "src/filter_core/filter_session.c||src/filter_core/filter_session.c": [
          "File: src/filter_core/filter_session.c -> src/filter_core/filter_session.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2247:    }",
          "2248:   }",
          "2251:  }",
          "2252: }",
          "",
          "[Removed Lines]",
          "2250:   GF_LOG(GF_LOG_WARNING, GF_LOG_APP, (\"Arg %s set but not used\\n\", argname));",
          "",
          "[Added Lines]",
          "2250:   GF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Arg %s set but not used\\n\", argname));",
          "",
          "---------------"
        ],
        "src/utils/os_config_init.c||src/utils/os_config_init.c": [
          "File: src/utils/os_config_init.c -> src/utils/os_config_init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1637:   gf_free(arg_name);",
          "1638:  }",
          "1641:   gf_sys_format_help(helpout, flags, \" (Enum\");",
          "1642:   if (arg->val)",
          "1643:    gf_sys_format_help(helpout, flags, \", default: **%s**\", arg->val);",
          "",
          "[Removed Lines]",
          "1640:  if (arg->type==GF_ARG_INT && arg->values && strchr(arg->values, '|')) {",
          "",
          "[Added Lines]",
          "1640:  if (arg->type==GF_ARG_CUSTOM) {",
          "1641:   if (arg->val)",
          "1642:    gf_sys_format_help(helpout, flags, \" `%s`\", arg->val);",
          "1643:  } else if (arg->type==GF_ARG_INT && arg->values && strchr(arg->values, '|')) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
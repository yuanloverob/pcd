{
  "cve_id": "CVE-2011-1023",
  "cve_desc": "The Reliable Datagram Sockets (RDS) subsystem in the Linux kernel before 2.6.38 does not properly handle congestion map updates, which allows local users to cause a denial of service (BUG_ON and system crash) via vectors involving (1) a loopback (aka loop) transmit operation or (2) an InfiniBand (aka ib) transmit operation.",
  "repo": "torvalds/linux",
  "patch_hash": "6094628bfd94323fc1cea05ec2c6affd98c18f7f",
  "patch_info": {
    "commit_hash": "6094628bfd94323fc1cea05ec2c6affd98c18f7f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6094628bfd94323fc1cea05ec2c6affd98c18f7f",
    "files": [
      "net/rds/ib_send.c",
      "net/rds/loop.c"
    ],
    "message": "rds: prevent BUG_ON triggering on congestion map updates\n\nRecently had this bug halt reported to me:\n\nkernel BUG at net/rds/send.c:329!\nOops: Exception in kernel mode, sig: 5 [#1]\nSMP NR_CPUS=1024 NUMA pSeries\nModules linked in: rds sunrpc ipv6 dm_mirror dm_region_hash dm_log ibmveth sg\next4 jbd2 mbcache sd_mod crc_t10dif ibmvscsic scsi_transport_srp scsi_tgt\ndm_mod [last unloaded: scsi_wait_scan]\nNIP: d000000003ca68f4 LR: d000000003ca67fc CTR: d000000003ca8770\nREGS: c000000175cab980 TRAP: 0700   Not tainted  (2.6.32-118.el6.ppc64)\nMSR: 8000000000029032 <EE,ME,CE,IR,DR>  CR: 44000022  XER: 00000000\nTASK = c00000017586ec90[1896] 'krdsd' THREAD: c000000175ca8000 CPU: 0\nGPR00: 0000000000000150 c000000175cabc00 d000000003cb7340 0000000000002030\nGPR04: ffffffffffffffff 0000000000000030 0000000000000000 0000000000000030\nGPR08: 0000000000000001 0000000000000001 c0000001756b1e30 0000000000010000\nGPR12: d000000003caac90 c000000000fa2500 c0000001742b2858 c0000001742b2a00\nGPR16: c0000001742b2a08 c0000001742b2820 0000000000000001 0000000000000001\nGPR20: 0000000000000040 c0000001742b2814 c000000175cabc70 0800000000000000\nGPR24: 0000000000000004 0200000000000000 0000000000000000 c0000001742b2860\nGPR28: 0000000000000000 c0000001756b1c80 d000000003cb68e8 c0000001742b27b8\nNIP [d000000003ca68f4] .rds_send_xmit+0x4c4/0x8a0 [rds]\nLR [d000000003ca67fc] .rds_send_xmit+0x3cc/0x8a0 [rds]\nCall Trace:\n[c000000175cabc00] [d000000003ca67fc] .rds_send_xmit+0x3cc/0x8a0 [rds]\n(unreliable)\n[c000000175cabd30] [d000000003ca7e64] .rds_send_worker+0x54/0x100 [rds]\n[c000000175cabdb0] [c0000000000b475c] .worker_thread+0x1dc/0x3c0\n[c000000175cabed0] [c0000000000baa9c] .kthread+0xbc/0xd0\n[c000000175cabf90] [c000000000032114] .kernel_thread+0x54/0x70\nInstruction dump:\n4bfffd50 60000000 60000000 39080001 935f004c f91f0040 41820024 813d017c\n7d094a78 7d290074 7929d182 394a0020 <0b090000> 40e2ff68 4bffffa4 39200000\nKernel panic - not syncing: Fatal exception\nCall Trace:\n[c000000175cab560] [c000000000012e04] .show_stack+0x74/0x1c0 (unreliable)\n[c000000175cab610] [c0000000005a365c] .panic+0x80/0x1b4\n[c000000175cab6a0] [c00000000002fbcc] .die+0x21c/0x2a0\n[c000000175cab750] [c000000000030000] ._exception+0x110/0x220\n[c000000175cab910] [c000000000004b9c] program_check_common+0x11c/0x180\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/rds/ib_send.c||net/rds/ib_send.c",
      "net/rds/loop.c||net/rds/loop.c"
    ]
  },
  "patch_diff": {
    "net/rds/ib_send.c||net/rds/ib_send.c": [
      "File: net/rds/ib_send.c -> net/rds/ib_send.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "551:  if (conn->c_loopback",
      "552:      && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {",
      "553:   rds_cong_map_updated(conn->c_fcong, ~(u64) 0);",
      "555:  }",
      "",
      "[Removed Lines]",
      "554:   return sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;",
      "",
      "[Added Lines]",
      "554:   scat = &rm->data.op_sg[sg];",
      "555:   ret = sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;",
      "556:   ret = min_t(int, ret, scat->length - conn->c_xmit_data_off);",
      "557:   return ret;",
      "",
      "---------------"
    ],
    "net/rds/loop.c||net/rds/loop.c": [
      "File: net/rds/loop.c -> net/rds/loop.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "61:     unsigned int hdr_off, unsigned int sg,",
      "62:     unsigned int off)",
      "63: {",
      "65:  if (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {",
      "66:   rds_cong_map_updated(conn->c_fcong, ~(u64) 0);",
      "68:  }",
      "70:  BUG_ON(hdr_off || sg || off);",
      "",
      "[Removed Lines]",
      "67:   return sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;",
      "",
      "[Added Lines]",
      "64:  struct scatterlist *sgp = &rm->data.op_sg[sg];",
      "65:  int ret = sizeof(struct rds_header) +",
      "66:    be32_to_cpu(rm->m_inc.i_hdr.h_len);",
      "71:   ret = min_t(int, ret, sgp->length - conn->c_xmit_data_off);",
      "72:   goto out;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "80:        NULL);",
      "82:  rds_inc_put(&rm->m_inc);",
      "85: }",
      "",
      "[Removed Lines]",
      "84:  return sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);",
      "",
      "[Added Lines]",
      "88: out:",
      "89:  return ret;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "725a97e43ee945cc813fffd9e628e50d703b973b",
      "candidate_info": {
        "commit_hash": "725a97e43ee945cc813fffd9e628e50d703b973b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/725a97e43ee945cc813fffd9e628e50d703b973b",
        "files": [
          "drivers/block/drbd/drbd_bitmap.c"
        ],
        "message": "drbd: fix potential access of on-stack wait_queue_head_t after return\n\nI run into something declaring itself as \"spinlock deadlock\",\n BUG: spinlock lockup on CPU#1, kjournald/27816, ffff88000ad6bca0\n Pid: 27816, comm: kjournald Tainted: G        W 2.6.34.6 #2\n Call Trace:\n  <IRQ>  [<ffffffff811ba0aa>] do_raw_spin_lock+0x11e/0x14d\n  [<ffffffff81340fde>] _raw_spin_lock_irqsave+0x6a/0x81\n  [<ffffffff8103b694>] ? __wake_up+0x22/0x50\n  [<ffffffff8103b694>] __wake_up+0x22/0x50\n  [<ffffffffa07ff661>] bm_async_io_complete+0x258/0x299 [drbd]\nbut the call traces do not fit at all,\nall other cpus are cpu_idle.\n\nI think it may be this race:\n\ndrbd_bm_write_page\n wait_queue_head_t io_wait;\n atomic_t in_flight;\n bm_async_io\n  submit_bio\n\t\t\t\t\tbm_async_io_complete\n\t\t\t\t\t  if (atomic_dec_and_test(in_flight))\n wait_event(io_wait,\n\tatomic_read(in_flight) == 0)\n return\n\t\t\t\t\t    wake_up(io_wait)\n\nThe wake_up now accesses the wait_queue_head_t spinlock, which is no\nlonger valid, since the stack frame of drbd_bm_write_page has been\nclobbered now.\n\nFix this by using struct completion, which does both the condition test\nas well as the wake_up inside its spinlock, so this race cannot happen.\n\nSigned-off-by: Philipp Reisner <philipp.reisner@linbit.com>\nSigned-off-by: Lars Ellenberg <lars.ellenberg@linbit.com>",
        "before_after_code_files": [
          "drivers/block/drbd/drbd_bitmap.c||drivers/block/drbd/drbd_bitmap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/block/drbd/drbd_bitmap.c||drivers/block/drbd/drbd_bitmap.c": [
          "File: drivers/block/drbd/drbd_bitmap.c -> drivers/block/drbd/drbd_bitmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "897: struct bm_aio_ctx {",
          "898:  struct drbd_conf *mdev;",
          "899:  atomic_t in_flight;",
          "901:  unsigned flags;",
          "902: #define BM_AIO_COPY_PAGES 1",
          "903:  int error;",
          "",
          "[Removed Lines]",
          "900:  wait_queue_head_t io_wait;",
          "",
          "[Added Lines]",
          "900:  struct completion done;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "948:  bio_put(bio);",
          "950:  if (atomic_dec_and_test(&ctx->in_flight))",
          "952: }",
          "954: static void bm_page_io_async(struct bm_aio_ctx *ctx, int page_nr, int rw) __must_hold(local)",
          "",
          "[Removed Lines]",
          "951:   wake_up(&ctx->io_wait);",
          "",
          "[Added Lines]",
          "951:   complete(&ctx->done);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1010: static int bm_rw(struct drbd_conf *mdev, int rw, unsigned lazy_writeout_upper_idx) __must_hold(local)",
          "1011: {",
          "1014:  struct drbd_bitmap *b = mdev->bitmap;",
          "1015:  int num_pages, i, count = 0;",
          "1016:  unsigned long now;",
          "",
          "[Removed Lines]",
          "1012:  struct bm_aio_ctx ctx =",
          "1013:   { .flags = lazy_writeout_upper_idx ? BM_AIO_COPY_PAGES : 0 };",
          "",
          "[Added Lines]",
          "1012:  struct bm_aio_ctx ctx = {",
          "1013:   .mdev = mdev,",
          "1014:   .in_flight = ATOMIC_INIT(1),",
          "1015:   .done = COMPLETION_INITIALIZER_ONSTACK(ctx.done),",
          "1016:   .flags = lazy_writeout_upper_idx ? BM_AIO_COPY_PAGES : 0,",
          "1017:  };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1031:  num_pages = b->bm_number_of_pages;",
          "1033:  now = jiffies;",
          "1040:  for (i = 0; i < num_pages; i++) {",
          "",
          "[Removed Lines]",
          "1034:  ctx.mdev = mdev;",
          "1036:  init_waitqueue_head(&ctx.io_wait);",
          "1037:  ctx.error = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1060:   cond_resched();",
          "1061:  }",
          "1065:  dev_info(DEV, \"bitmap %s of %u pages took %lu jiffies\\n\",",
          "1066:    rw == WRITE ? \"WRITE\" : \"READ\",",
          "1067:    count, jiffies - now);",
          "",
          "[Removed Lines]",
          "1064:  wait_event(ctx.io_wait, atomic_read(&ctx.in_flight) == 0);",
          "",
          "[Added Lines]",
          "1068:  if (!atomic_dec_and_test(&ctx.in_flight))",
          "1069:   wait_for_completion(&ctx.done);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1134: int drbd_bm_write_page(struct drbd_conf *mdev, unsigned int idx) __must_hold(local)",
          "1135: {",
          "1138:  if (bm_test_page_unchanged(mdev->bitmap->bm_pages[idx])) {",
          "1139:   dynamic_dev_dbg(DEV, \"skipped bm page write for idx %u\\n\", idx);",
          "1140:   return 0;",
          "1141:  }",
          "1147:  bm_page_io_async(&ctx, idx, WRITE_SYNC);",
          "1150:  if (ctx.error)",
          "1151:   drbd_chk_io_error(mdev, 1, true);",
          "",
          "[Removed Lines]",
          "1136:  struct bm_aio_ctx ctx = { .flags = BM_AIO_COPY_PAGES, };",
          "1143:  ctx.mdev = mdev;",
          "1144:  atomic_set(&ctx.in_flight, 1);",
          "1145:  init_waitqueue_head(&ctx.io_wait);",
          "1148:  wait_event(ctx.io_wait, atomic_read(&ctx.in_flight) == 0);",
          "",
          "[Added Lines]",
          "1141:  struct bm_aio_ctx ctx = {",
          "1142:   .mdev = mdev,",
          "1143:   .in_flight = ATOMIC_INIT(1),",
          "1144:   .done = COMPLETION_INITIALIZER_ONSTACK(ctx.done),",
          "1145:   .flags = BM_AIO_COPY_PAGES,",
          "1146:  };",
          "1154:  wait_for_completion(&ctx.done);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9063f1f15eec35e5fd608879cef8be5728f2d12a",
      "candidate_info": {
        "commit_hash": "9063f1f15eec35e5fd608879cef8be5728f2d12a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9063f1f15eec35e5fd608879cef8be5728f2d12a",
        "files": [
          "drivers/mfd/ucb1x00-ts.c"
        ],
        "message": "mfd: Fix NULL pointer due to non-initialized ucb1x00-ts absinfo\n\nCall input_set_abs_params instead of manually setting absbit only.\nThis fixes this oops:\n\nUnable to handle kernel NULL pointer dereference at virtual address 00000024\nInternal error: Oops: 41b67017 [#1]\nCPU: 0    Not tainted  (2.6.37 #4)\npc : [<c016d1fc>]    lr : [<00000000>]    psr: 20000093\nsp : c19e5f30  ip : c19e5e6c  fp : c19e5f58\nr10: 00000000  r9 : c19e4000  r8 : 00000003\nr7 : 000001e4  r6 : 00000001  r5 : c1854400  r4 : 00000003\nr3 : 00000018  r2 : 00000018  r1 : 00000018  r0 : c185447c\nFlags: nzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel\nControl: c1b6717f  Table: c1b6717f  DAC: 00000017\nStack: (0xc19e5f30 to 0xc19e6000)\n5f20:                                     00000003 00000003 c1854400 00000013\n5f40: 00000001 000001e4 000001c5 c19e5f80 c19e5f5c c016d5e8 c016cf5c 000001e4\n5f60: c1854400 c18b5860 00000000 00000171 000001e4 c19e5fc4 c19e5f84 c01559a4\n5f80: c016d584 c18b5868 00000000 c1bb5c40 c0035afc c18b5868 c18b5868 c1a55d54\n5fa0: c18b5860 c0155750 00000013 00000000 00000000 00000000 c19e5ff4 c19e5fc8\n5fc0: c0050174 c015575c 00000000 c18b5860 00000000 c19e5fd4 c19e5fd4 c1a55d54\n5fe0: c00500f0 c003b464 00000000 c19e5ff8 c003b464 c00500fc 04000400 04000400\nBacktrace:\nFunction entered at [<c016cf50>] from [<c016d5e8>]\nFunction entered at [<c016d578>] from [<c01559a4>]\n r8:000001e4 r7:00000171 r6:00000000 r5:c18b5860 r4:c1854400\nFunction entered at [<c0155750>] from [<c0050174>]\nFunction entered at [<c00500f0>] from [<c003b464>]\n r6:c003b464 r5:c00500f0 r4:c1a55d54\nCode: e59520fc e1a03286 e0433186 e0822003 (e592000c)\n\n>>PC;  c016d1fc <input_handle_event+2ac/5a0>   <=====\n\nTrace; c016cf50 <input_handle_event+0/5a0>\nTrace; c016d5e8 <input_event+70/88>\nTrace; c016d578 <input_event+0/88>\nTrace; c01559a4 <ucb1x00_thread+254/2dc>\nTrace; c0155750 <ucb1x00_thread+0/2dc>\nTrace; c0050174 <kthread+84/8c>\nTrace; c00500f0 <kthread+0/8c>\nTrace; c003b464 <do_exit+0/624>\n\nSigned-off-by: Jochen Friedrich <jochen@scram.de>\nCC: stable@kernel.org\nSigned-off-by: Samuel Ortiz <sameo@linux.intel.com>",
        "before_after_code_files": [
          "drivers/mfd/ucb1x00-ts.c||drivers/mfd/ucb1x00-ts.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mfd/ucb1x00-ts.c||drivers/mfd/ucb1x00-ts.c": [
          "File: drivers/mfd/ucb1x00-ts.c -> drivers/mfd/ucb1x00-ts.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "385:  idev->close      = ucb1x00_ts_close;",
          "387:  __set_bit(EV_ABS, idev->evbit);",
          "392:  input_set_drvdata(idev, ts);",
          "394:  err = input_register_device(idev);",
          "395:  if (err)",
          "396:   goto fail;",
          "",
          "[Removed Lines]",
          "388:  __set_bit(ABS_X, idev->absbit);",
          "389:  __set_bit(ABS_Y, idev->absbit);",
          "390:  __set_bit(ABS_PRESSURE, idev->absbit);",
          "",
          "[Added Lines]",
          "391:  ucb1x00_adc_enable(ts->ucb);",
          "392:  ts->x_res = ucb1x00_ts_read_xres(ts);",
          "393:  ts->y_res = ucb1x00_ts_read_yres(ts);",
          "394:  ucb1x00_adc_disable(ts->ucb);",
          "396:  input_set_abs_params(idev, ABS_X, 0, ts->x_res, 0, 0);",
          "397:  input_set_abs_params(idev, ABS_Y, 0, ts->y_res, 0, 0);",
          "398:  input_set_abs_params(idev, ABS_PRESSURE, 0, 0, 0, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a0b1665db09cf2da9ad7d0f12da386373c10bfa",
      "candidate_info": {
        "commit_hash": "4a0b1665db09cf2da9ad7d0f12da386373c10bfa",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4a0b1665db09cf2da9ad7d0f12da386373c10bfa",
        "files": [
          "kernel/trace/trace.c"
        ],
        "message": "tracing: Fix irqoff selftest expanding max buffer\n\nIf the kernel command line declares a tracer \"ftrace=sometracer\" and\nthat tracer is either not defined or is enabled after irqsoff,\nthen the irqs off selftest will fail with the following error:\n\nTesting tracer irqsoff:\n------------[ cut here ]------------\nWARNING: at /home/rostedt/work/autotest/nobackup/linux-test.git/kernel/trace/tra\nce.c:713 update_max_tr_single+0xfa/0x11b()\nHardware name:\nModules linked in:\nPid: 1, comm: swapper Not tainted 2.6.38-rc8-test #1\nCall Trace:\n [<c0441d9d>] ? warn_slowpath_common+0x65/0x7a\n [<c049adb2>] ? update_max_tr_single+0xfa/0x11b\n [<c0441dc1>] ? warn_slowpath_null+0xf/0x13\n [<c049adb2>] ? update_max_tr_single+0xfa/0x11b\n [<c049e454>] ? stop_critical_timing+0x154/0x204\n [<c049b54b>] ? trace_selftest_startup_irqsoff+0x5b/0xc1\n [<c049b54b>] ? trace_selftest_startup_irqsoff+0x5b/0xc1\n [<c049b54b>] ? trace_selftest_startup_irqsoff+0x5b/0xc1\n [<c049e529>] ? time_hardirqs_on+0x25/0x28\n [<c0468bca>] ? trace_hardirqs_on_caller+0x18/0x12f\n [<c0468cec>] ? trace_hardirqs_on+0xb/0xd\n [<c049b54b>] ? trace_selftest_startup_irqsoff+0x5b/0xc1\n [<c049b6b8>] ? register_tracer+0xf8/0x1a3\n [<c14e93fe>] ? init_irqsoff_tracer+0xd/0x11\n [<c040115e>] ? do_one_initcall+0x71/0x121\n [<c14e93f1>] ? init_irqsoff_tracer+0x0/0x11\n [<c14ce3a9>] ? kernel_init+0x13a/0x1b6\n [<c14ce26f>] ? kernel_init+0x0/0x1b6\n [<c0403842>] ? kernel_thread_helper+0x6/0x10\n---[ end trace e93713a9d40cd06c ]---\n.. no entries found ..FAILED!\n\nWhat happens is the \"ftrace=...\" will expand the ring buffer to its\ndefault size (from its minimum size) but it will not expand the\nmax ring buffer (the ring buffer to store maximum latencies).\nWhen the irqsoff test runs, it will call the ring buffer swap routine\nthat checks if the max ring buffer is the same size as the normal\nring buffer, and will fail if it is not. This causes the test to fail.\n\nThe solution is to expand the max ring buffer before running the self\ntest if the max ring buffer is used by that tracer and the normal ring\nbuffer is expanded. The max ring buffer should be shrunk again after\nthe test is done to save space.\n\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>",
        "before_after_code_files": [
          "kernel/trace/trace.c||kernel/trace/trace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/trace/trace.c||kernel/trace/trace.c": [
          "File: kernel/trace/trace.c -> kernel/trace/trace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "779:   tracing_reset_online_cpus(tr);",
          "781:   current_trace = type;",
          "783:   pr_info(\"Testing tracer %s: \", type->name);",
          "784:   ret = type->selftest(type, tr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "784:   if (ring_buffer_expanded && type->use_max_tr)",
          "785:    ring_buffer_resize(max_tr.buffer, trace_buf_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "792:   tracing_reset_online_cpus(tr);",
          "794:   printk(KERN_CONT \"PASSED\\n\");",
          "795:  }",
          "796: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "800:   if (ring_buffer_expanded && type->use_max_tr)",
          "801:    ring_buffer_resize(max_tr.buffer, 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3b28cf32cc32594710590685ee478f697ed4f328",
      "candidate_info": {
        "commit_hash": "3b28cf32cc32594710590685ee478f697ed4f328",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3b28cf32cc32594710590685ee478f697ed4f328",
        "files": [
          "arch/x86/mm/numa_64.c"
        ],
        "message": "x86, numa: Fix numa_emulation code with memory-less node0\n\nThis crash happens on a system that does not have RAM on node0.\n\nWhen numa_emulation is compiled in, and:\n\n 1. we boot the system without numa=fake...\n 2. or we boot the system with numa=fake=128 to make emulation fail\n\nwe will get:\n\n[    0.076025] ------------[ cut here ]------------\n[    0.080004] kernel BUG at arch/x86/mm/numa_64.c:788!\n[    0.080004] invalid opcode: 0000 [#1] SMP\n[...]\n\nneed to use early_cpu_to_node() directly, because cpu_to_apicid\nand apicid_to_node will return node0 that is not onlined.\n\nSigned-off-by: Yinghai Lu <yinghai@kernel.org>\nAcked-by: Tejun Heo <tj@kernel.org>\nCc: David Rientjes <rientjes@google.com>\nLKML-Reference: <4D6ECF72.5010308@kernel.org>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>",
        "before_after_code_files": [
          "arch/x86/mm/numa_64.c||arch/x86/mm/numa_64.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/mm/numa_64.c||arch/x86/mm/numa_64.c": [
          "File: arch/x86/mm/numa_64.c -> arch/x86/mm/numa_64.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "780:  int physnid;",
          "781:  int nid = NUMA_NO_NODE;",
          "788:  BUG_ON(nid == NUMA_NO_NODE || !node_online(nid));",
          "",
          "[Removed Lines]",
          "783:  apicid = early_per_cpu(x86_cpu_to_apicid, cpu);",
          "784:  if (apicid != BAD_APICID)",
          "785:   nid = apicid_to_node[apicid];",
          "786:  if (nid == NUMA_NO_NODE)",
          "787:   nid = early_cpu_to_node(cpu);",
          "",
          "[Added Lines]",
          "783:  nid = early_cpu_to_node(cpu);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eeb2036b8a148629b762ae6d85cff0be8106f081",
      "candidate_info": {
        "commit_hash": "eeb2036b8a148629b762ae6d85cff0be8106f081",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/eeb2036b8a148629b762ae6d85cff0be8106f081",
        "files": [
          "fs/xfs/linux-2.6/xfs_ioctl.c"
        ],
        "message": "xfs: zero proper structure size for geometry calls\n\nCommit 493f3358cb289ccf716c5a14fa5bb52ab75943e5 added this call to\nxfs_fs_geometry() in order to avoid passing kernel stack data back\nto user space:\n\n+       memset(geo, 0, sizeof(*geo));\n\nUnfortunately, one of the callers of that function passes the\naddress of a smaller data type, cast to fit the type that\nxfs_fs_geometry() requires.  As a result, this can happen:\n\nKernel panic - not syncing: stack-protector: Kernel stack is corrupted\nin: f87aca93\n\nPid: 262, comm: xfs_fsr Not tainted 2.6.38-rc6-493f3358cb2+ #1\nCall Trace:\n\n[<c12991ac>] ? panic+0x50/0x150\n[<c102ed71>] ? __stack_chk_fail+0x10/0x18\n[<f87aca93>] ? xfs_ioc_fsgeometry_v1+0x56/0x5d [xfs]\n\nFix this by fixing that one caller to pass the right type and then\ncopy out the subset it is interested in.\n\nNote: This patch is an alternative to one originally proposed by\nEric Sandeen.\n\nReported-by: Jeffrey Hundstad <jeffrey.hundstad@mnsu.edu>\nSigned-off-by: Alex Elder <aelder@sgi.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nTested-by: Jeffrey Hundstad <jeffrey.hundstad@mnsu.edu>",
        "before_after_code_files": [
          "fs/xfs/linux-2.6/xfs_ioctl.c||fs/xfs/linux-2.6/xfs_ioctl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/xfs/linux-2.6/xfs_ioctl.c||fs/xfs/linux-2.6/xfs_ioctl.c": [
          "File: fs/xfs/linux-2.6/xfs_ioctl.c -> fs/xfs/linux-2.6/xfs_ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "695:  xfs_mount_t  *mp,",
          "696:  void   __user *arg)",
          "697: {",
          "699:  int   error;",
          "702:  if (error)",
          "703:   return -error;",
          "706:   return -XFS_ERROR(EFAULT);",
          "707:  return 0;",
          "708: }",
          "",
          "[Removed Lines]",
          "698:  xfs_fsop_geom_v1_t fsgeo;",
          "701:  error = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3);",
          "705:  if (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))",
          "",
          "[Added Lines]",
          "698:  xfs_fsop_geom_t         fsgeo;",
          "701:  error = xfs_fs_geometry(mp, &fsgeo, 3);",
          "710:  if (copy_to_user(arg, &fsgeo, sizeof(xfs_fsop_geom_v1_t)))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
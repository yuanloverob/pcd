{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "189aa7dc96bb7552607065276170b3e02ea6bd2d",
      "candidate_info": {
        "commit_hash": "189aa7dc96bb7552607065276170b3e02ea6bd2d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/189aa7dc96bb7552607065276170b3e02ea6bd2d",
        "files": [
          "ext/fts5/test/fts5corrupt3.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Fix a test script problem in fts5corrupt3.test.\n\nFossilOrigin-Name: 734192d876e0489cb34e454aaa4a9c6858145791a49959b31dee2917a8e41a7d",
        "before_after_code_files": [
          "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test": [
          "File: ext/fts5/test/fts5corrupt3.test -> ext/fts5/test/fts5corrupt3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "8007:   if {$res==\"1 {constraint failed}\"} {",
          "8008:     set res \"1 {database disk image is malformed}\"",
          "8009:   }",
          "8010: } {1 {database disk image is malformed}}",
          "8012: #-------------------------------------------------------------------------",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8010:   set res",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 0bab4ece6e81916d0f7255a8e553b8ca040cb8a96ab21e294212e232119f8ddc",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3db3d12cd11b60c47e52050eb3e83a67b7664d0f",
      "candidate_info": {
        "commit_hash": "3db3d12cd11b60c47e52050eb3e83a67b7664d0f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/3db3d12cd11b60c47e52050eb3e83a67b7664d0f",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/pragma.c",
          "test/vtab1.test",
          "test/without_rowid1.test",
          "test/without_rowid6.test",
          "test/without_rowid7.test"
        ],
        "message": "Fix the WITHOUT ROWID table logic so that it generates a correct KeyInfo object for tables that have a PRIMARY KEY containing the same column used more than once with different collating sequences.  Enhance the index_xinfo pragma to assist in testing the above. Fix for ticket [fd3aec0c7e3e2998].\n\nFossilOrigin-Name: 84a51a755c18ac8253080db6eec505df894ee3b1e97cfa8e61039ac38001e270",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/pragma.c||src/pragma.c",
          "test/vtab1.test||test/vtab1.test",
          "test/without_rowid1.test||test/without_rowid1.test",
          "test/without_rowid6.test||test/without_rowid6.test",
          "test/without_rowid7.test||test/without_rowid7.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/pragma.c||src/pragma.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/pragma.c||src/pragma.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: fe014288ac03cdf0dc5410b7d45cad4768759b52746c0a22bce2fc03779c5d5a",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1831:   Index *pIdx;",
          "1832:   Index *pPk;",
          "1833:   int nPk;",
          "1834:   int i, j;",
          "1835:   sqlite3 *db = pParse->db;",
          "1836:   Vdbe *v = pParse->pVdbe;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1834:   int nExtra;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1873:                        SQLITE_IDXTYPE_PRIMARYKEY);",
          "1874:     if( db->mallocFailed || pParse->nErr ) return;",
          "1875:     pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1876:   }else{",
          "1877:     pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1878:     assert( pPk!=0 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1877:     assert( pPk->nKeyCol==1 );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1887:         pPk->nColumn--;",
          "1888:       }else{",
          "1889:         testcase( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) );",
          "1890:         pPk->aiColumn[j++] = pPk->aiColumn[i];",
          "1891:       }",
          "1892:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1892:         pPk->azColl[j] = pPk->azColl[i];",
          "1893:         pPk->aSortOrder[j] = pPk->aSortOrder[i];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1895:   assert( pPk!=0 );",
          "1896:   pPk->isCovering = 1;",
          "1897:   if( !db->init.imposterTable ) pPk->uniqNotNull = 1;",
          "",
          "[Removed Lines]",
          "1898:   nPk = pPk->nKeyCol;",
          "",
          "[Added Lines]",
          "1902:   nPk = pPk->nColumn = pPk->nKeyCol;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1957:     }",
          "1962:   }",
          "1963:   recomputeColumnsNotIndexed(pPk);",
          "1964: }",
          "",
          "[Removed Lines]",
          "1948:   if( nPk<pTab->nCol ){",
          "1949:     if( resizeIndexObject(db, pPk, pTab->nCol) ) return;",
          "1950:     for(i=0, j=nPk; i<pTab->nCol; i++){",
          "1951:       if( !hasColumn(pPk->aiColumn, j, i) ){",
          "1952:         assert( j<pPk->nColumn );",
          "1953:         pPk->aiColumn[j] = i;",
          "1954:         pPk->azColl[j] = sqlite3StrBINARY;",
          "1955:         j++;",
          "1956:       }",
          "1958:     assert( pPk->nColumn==j );",
          "1959:     assert( pTab->nCol==j );",
          "1960:   }else{",
          "1961:     pPk->nColumn = pTab->nCol;",
          "",
          "[Added Lines]",
          "1952:   nExtra = 0;",
          "1953:   for(i=0; i<pTab->nCol; i++){",
          "1954:     if( !hasColumn(pPk->aiColumn, nPk, i) ) nExtra++;",
          "1955:   }",
          "1956:   if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;",
          "1957:   for(i=0, j=nPk; i<pTab->nCol; i++){",
          "1958:     if( !hasColumn(pPk->aiColumn, j, i) ){",
          "1959:       assert( j<pPk->nColumn );",
          "1960:       pPk->aiColumn[j] = i;",
          "1961:       pPk->azColl[j] = sqlite3StrBINARY;",
          "1962:       j++;",
          "1965:   assert( pPk->nColumn==j );",
          "1966:   assert( pTab->nCol<=j );",
          "",
          "---------------"
        ],
        "src/pragma.c||src/pragma.c": [
          "File: src/pragma.c -> src/pragma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1157:     Index *pIdx;",
          "1158:     Table *pTab;",
          "1159:     pIdx = sqlite3FindIndex(db, zRight, zDb);",
          "1160:     if( pIdx ){",
          "1161:       int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);",
          "1162:       int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1160:     if( pIdx==0 ){",
          "1164:       pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);",
          "1165:       if( pTab && !HasRowid(pTab) ){",
          "1166:         pIdx = sqlite3PrimaryKeyIndex(pTab);",
          "1167:       }",
          "1168:     }",
          "",
          "---------------"
        ],
        "test/vtab1.test||test/vtab1.test": [
          "File: test/vtab1.test -> test/vtab1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "875:   }",
          "876: } {}",
          "878: ifcapable attach {",
          "879:   do_test vtab1.8-1 {",
          "880:     set echo_module \"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878: # PRAGMA index_info and index_xinfo are no-ops on a virtual table",
          "879: do_test vtab1.7-14 {",
          "880:   execsql {",
          "881:     PRAGMA index_info('echo_abc');",
          "882:     PRAGMA index_xinfo('echo_abc');",
          "883:   }",
          "884: } {}",
          "",
          "---------------"
        ],
        "test/without_rowid1.test||test/without_rowid1.test": [
          "File: test/without_rowid1.test -> test/without_rowid1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: integrity_check without_rowid1-1.0ic",
          "34: do_execsql_test without_rowid1-1.1 {",
          "35:   SELECT *, '|' FROM t1 ORDER BY +c, a;",
          "36: } {arctic sleep ammonia helena | journal sherman ammonia helena | dynamic juliet flipper command | journal sherman gamma patriot |}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: do_execsql_test without_rowid1-1.0ixi {",
          "35:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "36: } {c 1 a 1 b 0 d 0}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:   UPDATE t4 SET a = 'ABC';",
          "121:   SELECT * FROM t4;",
          "122: } {ABC def}",
          "124: do_execsql_test 2.2.1 {",
          "125:   DROP TABLE t4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "127: do_execsql_test 2.1.3 {",
          "128:   SELECT name, coll, key FROM pragma_index_xinfo('t4');",
          "129: } {a nocase 1 b BINARY 0}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "133:   SELECT * FROM t4;",
          "134: } {xyz ABC}",
          "136: do_execsql_test 2.3.1 {",
          "137:   CREATE TABLE t5 (a, b, PRIMARY KEY(b, a)) WITHOUT ROWID;",
          "138:   INSERT INTO t5(a, b) VALUES('abc', 'def');",
          "139:   UPDATE t5 SET a='abc', b='def';",
          "140: } {}",
          "142: do_execsql_test 2.4.1 {",
          "143:   CREATE TABLE t6 (",
          "144:     a COLLATE nocase, b, c UNIQUE, PRIMARY KEY(b, a)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "143: do_execsql_test 2.2.3 {",
          "144:   SELECT name, coll, key FROM pragma_index_xinfo('t4');",
          "145: } {a nocase 1 b BINARY 0}",
          "154: do_execsql_test 2.3.2 {",
          "155:   SELECT name, coll, key FROM pragma_index_xinfo('t5');",
          "156: } {b BINARY 1 a BINARY 1}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "153:   SELECT * FROM t6 ORDER BY c;",
          "154: } {ABC def ghi ABC def ghi}",
          "156: #-------------------------------------------------------------------------",
          "157: # Unless the destination table is completely empty, the xfer optimization",
          "158: # is disabled for WITHOUT ROWID tables. The following tests check for",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173: do_execsql_test 2.4.3 {",
          "174:   SELECT name, coll, key FROM pragma_index_xinfo('t6');",
          "175: } {b BINARY 1 a nocase 1 c BINARY 0}",
          "",
          "---------------"
        ],
        "test/without_rowid6.test||test/without_rowid6.test": [
          "File: test/without_rowid6.test -> test/without_rowid6.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:   INSERT INTO t1(a,b,c,d,e) SELECT i, i+1000, printf('x%dy',i), 0, 0 FROM c;",
          "25:   ANALYZE;",
          "26: } {}",
          "27: do_execsql_test without_rowid6-110 {",
          "28:   SELECT c FROM t1 WHERE a=123;",
          "29: } {x123y}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: do_execsql_test without_rowid6-101 {",
          "28:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "29: } {a 1 b 1 c 1 d 1 e 0}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51:   INSERT INTO t1(a,b,c) VALUES(1,8,3),(4,5,6),(7,2,9);",
          "52:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "53: } {4 1}",
          "54: do_execsql_test without_rowid6-210 {",
          "55:   EXPLAIN QUERY PLAN",
          "56:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: do_execsql_test without_rowid6-201 {",
          "58:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "59: } {b 1 a 0 c 0}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:   INSERT INTO t1(a,b,c) VALUES(1,8,3),(4,5,6),(7,2,9);",
          "106:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "107: } {4 1}",
          "108: do_execsql_test without_rowid6-510 {",
          "109:   EXPLAIN QUERY PLAN",
          "110:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114: do_execsql_test without_rowid6-501 {",
          "115:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "116: } {b 1 c 1 a 0}",
          "",
          "---------------"
        ],
        "test/without_rowid7.test||test/without_rowid7.test": [
          "File: test/without_rowid7.test -> test/without_rowid7.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 July 17",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #*************************************************************************",
          "11: # This file implements regression tests for SQLite library.",
          "12: #",
          "14: set testdir [file dirname $argv0]",
          "15: source $testdir/tester.tcl",
          "16: set testprefix without_rowid7",
          "18: do_execsql_test 1.0 {",
          "19:   CREATE TABLE t1(a, b COLLATE nocase, PRIMARY KEY(a, a, b)) WITHOUT ROWID;",
          "20: }",
          "22: do_catchsql_test 1.1 {",
          "23:   INSERT INTO t1 VALUES(1, 'one'), (1, 'ONE');",
          "24: } {1 {UNIQUE constraint failed: t1.a, t1.b}}",
          "27: do_execsql_test 2.0 {",
          "28:   CREATE TABLE t2(a, b, PRIMARY KEY(a COLLATE nocase, a)) WITHOUT ROWID;",
          "29: }",
          "31: do_execsql_test 2.1 {",
          "32:   INSERT INTO t2 VALUES(1, 'one');",
          "33:   SELECT b FROM t2;",
          "34: } {one}",
          "36: do_execsql_test 2.2a {",
          "37:   PRAGMA index_info(t2);",
          "38: } {0 0 a 1 0 a}",
          "39: do_execsql_test 2.2b {",
          "40:   SELECT *, '|' FROM pragma_index_info('t2');",
          "41: } {0 0 a | 1 0 a |}",
          "42: do_execsql_test 2.3a {",
          "43:   PRAGMA index_xinfo(t2);",
          "44: } {0 0 a 0 nocase 1 1 0 a 0 BINARY 1 2 1 b 0 BINARY 0}",
          "45: do_execsql_test 2.3b {",
          "46:   SELECT *, '|' FROM pragma_index_xinfo('t2');",
          "47: } {0 0 a 0 nocase 1 | 1 0 a 0 BINARY 1 | 2 1 b 0 BINARY 0 |}",
          "49: do_execsql_test 2.4 {",
          "50:   CREATE TABLE t3(a, b, PRIMARY KEY(a COLLATE nocase, a));",
          "51:   PRAGMA index_info(t3);",
          "52: } {}",
          "56: finish_test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "480c572f2da02cb6446a55df6c8b2df271446a66",
      "candidate_info": {
        "commit_hash": "480c572f2da02cb6446a55df6c8b2df271446a66",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/480c572f2da02cb6446a55df6c8b2df271446a66",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "test/indexfault.test"
        ],
        "message": "In sqlite3NestedParse() be sure to detect all SQLITE_NOMEM and SQLITE_TOOBIG errors and to distinguish between them.\n\nFossilOrigin-Name: 73056b314bd63288c662752e9bd469b70264c38031c1c857460e64fdb1ed4e2e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "test/indexfault.test||test/indexfault.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: e7144ffd21294d7aebbfa6aa5a262797a6d16de11193f1bf6b75f5f27b04c940",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "260:   zSql = sqlite3VMPrintf(db, zFormat, ap);",
          "261:   va_end(ap);",
          "262:   if( zSql==0 ){",
          "264:   }",
          "265:   pParse->nested++;",
          "266:   memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266:     if( !db->mallocFailed ) pParse->rc = SQLITE_TOOBIG;",
          "267:     return;",
          "",
          "---------------"
        ],
        "test/indexfault.test||test/indexfault.test": [
          "File: test/indexfault.test -> test/indexfault.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "337:   faultsim_test_result {0 {}}",
          "338: }",
          "340: uninstall_custom_faultsim",
          "342: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "340: do_faultsim_test 5 -prep {",
          "341:   reset_db",
          "342: } -body {",
          "343:   execsql {",
          "344:  CREATE TABLE reallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallylongname(a PRIMARY KEY) WITHOUT ROWID;",
          "345:   }",
          "346: } -test {",
          "347:   faultsim_test_result {0 {}}",
          "348: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ca7a26b5a16dfa0c1b4fdfcadb67397428a2e90a",
      "candidate_info": {
        "commit_hash": "ca7a26b5a16dfa0c1b4fdfcadb67397428a2e90a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ca7a26b5a16dfa0c1b4fdfcadb67397428a2e90a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "test/join.test"
        ],
        "message": "Do not allow a term in the WHERE clause of the query to qualify a partial index on the right table of a LEFT JOIN.  Ticket [7f39060a24b47353]\n\nFossilOrigin-Name: 4066a34da7bcdcece6c438c27f3a11bc49b8c8373b7e1603f30f6225e2bc800a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "test/join.test||test/join.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 2c4f714892327a1a9a303267b1f9685e310cca5dcea9c61287d95e26291b0506",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2794:   int i;",
          "2795:   WhereTerm *pTerm;",
          "2796:   Parse *pParse = pWC->pWInfo->pParse;",
          "2797:   while( pWhere->op==TK_AND ){",
          "2799:     pWhere = pWhere->pRight;",
          "2800:   }",
          "2801:   if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;",
          "",
          "[Removed Lines]",
          "2793: static int whereUsablePartialIndex(int iTab, WhereClause *pWC, Expr *pWhere){",
          "2798:     if( !whereUsablePartialIndex(iTab,pWC,pWhere->pLeft) ) return 0;",
          "",
          "[Added Lines]",
          "2793: static int whereUsablePartialIndex(",
          "2798: ){",
          "2803:     if( !whereUsablePartialIndex(iTab,isLeft,pWC,pWhere->pLeft) ) return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2803:     Expr *pExpr;",
          "2804:     pExpr = pTerm->pExpr;",
          "2805:     if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)",
          "2806:      && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)",
          "2807:     ){",
          "2808:       return 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2811:      && (isLeft==0 || ExprHasProperty(pExpr, EP_FromJoin))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2965:   for(; rc==SQLITE_OK && pProbe;",
          "2966:       pProbe=(pSrc->pIBIndex ? 0 : pProbe->pNext), iSortIdx++",
          "2967:   ){",
          "2968:     if( pProbe->pPartIdxWhere!=0",
          "2972:     }",
          "",
          "[Removed Lines]",
          "2969:      && !whereUsablePartialIndex(pSrc->iCursor, pWC, pProbe->pPartIdxWhere) ){",
          "",
          "[Added Lines]",
          "2974:     int isLeft = (pSrc->fg.jointype & JT_OUTER)!=0;",
          "2976:      && !whereUsablePartialIndex(pSrc->iCursor, isLeft, pWC,",
          "2977:                                  pProbe->pPartIdxWhere)",
          "2978:     ){",
          "",
          "---------------"
        ],
        "test/join.test||test/join.test": [
          "File: test/join.test -> test/join.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "953:   SELECT * FROM t0 LEFT JOIN t1 WHERE NULL IN (c1);",
          "954: } {}",
          "956: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "956: # 2019-11-30 ticket 7f39060a24b47353",
          "957: # Do not allow a WHERE clause term to qualify a partial index on the",
          "958: # right table of a LEFT JOIN.",
          "959: #",
          "960: do_execsql_test join-21.10 {",
          "961:   DROP TABLE t0;",
          "962:   DROP TABLE t1;",
          "963:   CREATE TABLE t0(aa);",
          "964:   CREATE TABLE t1(bb);",
          "965:   INSERT INTO t0(aa) VALUES (1);",
          "966:   INSERT INTO t1(bb) VALUES (1);",
          "967:   SELECT 11, * FROM t1 LEFT JOIN t0 WHERE aa ISNULL;",
          "968:   SELECT 12, * FROM t1 LEFT JOIN t0 WHERE +aa ISNULL;",
          "969:   SELECT 13, * FROM t1 LEFT JOIN t0 ON aa ISNULL;",
          "970:   SELECT 14, * FROM t1 LEFT JOIN t0 ON +aa ISNULL;",
          "971:   CREATE INDEX i0 ON t0(aa) WHERE aa ISNULL;",
          "972:   SELECT 21, * FROM t1 LEFT JOIN t0 WHERE aa ISNULL;",
          "973:   SELECT 22, * FROM t1 LEFT JOIN t0 WHERE +aa ISNULL;",
          "974:   SELECT 23, * FROM t1 LEFT JOIN t0 ON aa ISNULL;",
          "975:   SELECT 24, * FROM t1 LEFT JOIN t0 ON +aa ISNULL;",
          "976: } {13 1 {} 14 1 {} 23 1 {} 24 1 {}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94e02d9c2cabefe2ebcef47c4fb68cdb88d3e47a",
      "candidate_info": {
        "commit_hash": "94e02d9c2cabefe2ebcef47c4fb68cdb88d3e47a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/94e02d9c2cabefe2ebcef47c4fb68cdb88d3e47a",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/shmlock.test"
        ],
        "message": "Fix the shmlock.test script so that it works with the Windows restriction that UnlockFile must exactly correspond to a prior LockFile.\n\nFossilOrigin-Name: df939c89fa90b7f9ccf961027ca4eca4f987c49eabf530b5719a83e5ab0d346d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/shmlock.test||test/shmlock.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: fbcd72565f4425016cebbbf5dfd6aa510234cfb31c785cf364f04fff444aacae",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/shmlock.test||test/shmlock.test": [
          "File: test/shmlock.test -> test/shmlock.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "114: sqlite3 db1 test.db",
          "115: do_test 3.1 { execsql { SELECT * FROM t1 } db0 } {1 2}",
          "116: do_test 3.2 { execsql { SELECT * FROM t1 } db1 } {1 2}",
          "118: set L(0) {n n n n n n n n}",
          "119: set L(1) {n n n n n n n n}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117: if {$tcl_platform(platform)==\"windows\"} {",
          "118:   set isWindows 1",
          "119: } else {",
          "120:   set isWindows 0",
          "121: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134:       if {$locktype==\"e\"} {",
          "135:         for {set l $iSlot} {$l<8 && [lindex $L($idx) $l]==\"n\"} {incr l} {}",
          "136:         set n [expr int(rand()*($l-$iSlot))+1]",
          "137:         # puts \"iSlot=$iSlot l=$l L=$L($idx)\"",
          "138:         # puts \"$iSlot $n\"",
          "139:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142:         # The LockFile() and UnlockFile() apis on windows require that",
          "143:         # every unlock correspond exactly to a prior lock.  Hence, we cannot",
          "144:         # lock arbitrary ranges in this test on windows.",
          "145:         if {$::isWindows} {set n 1}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-2179",
  "cve_desc": "The DTLS implementation in OpenSSL before 1.1.0 does not properly restrict the lifetime of queue entries associated with unused out-of-order messages, which allows remote attackers to cause a denial of service (memory consumption) by maintaining many crafted DTLS sessions simultaneously, related to d1_lib.c, statem_dtls.c, statem_lib.c, and statem_srvr.c.",
  "repo": "openssl/openssl",
  "patch_hash": "f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d",
  "patch_info": {
    "commit_hash": "f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d",
    "files": [
      "ssl/d1_lib.c",
      "ssl/ssl_locl.h",
      "ssl/statem/statem_dtls.c",
      "ssl/statem/statem_lib.c",
      "ssl/statem/statem_srvr.c"
    ],
    "message": "Fix DTLS buffered message DoS attack\n\nDTLS can handle out of order record delivery. Additionally since\nhandshake messages can be bigger than will fit into a single packet, the\nmessages can be fragmented across multiple records (as with normal TLS).\nThat means that the messages can arrive mixed up, and we have to\nreassemble them. We keep a queue of buffered messages that are \"from the\nfuture\", i.e. messages we're not ready to deal with yet but have arrived\nearly. The messages held there may not be full yet - they could be one\nor more fragments that are still in the process of being reassembled.\n\nThe code assumes that we will eventually complete the reassembly and\nwhen that occurs the complete message is removed from the queue at the\npoint that we need to use it.\n\nHowever, DTLS is also tolerant of packet loss. To get around that DTLS\nmessages can be retransmitted. If we receive a full (non-fragmented)\nmessage from the peer after previously having received a fragment of\nthat message, then we ignore the message in the queue and just use the\nnon-fragmented version. At that point the queued message will never get\nremoved.\n\nAdditionally the peer could send \"future\" messages that we never get to\nin order to complete the handshake. Each message has a sequence number\n(starting from 0). We will accept a message fragment for the current\nmessage sequence number, or for any sequence up to 10 into the future.\nHowever if the Finished message has a sequence number of 2, anything\ngreater than that in the queue is just left there.\n\nSo, in those two ways we can end up with \"orphaned\" data in the queue\nthat will never get removed - except when the connection is closed. At\nthat point all the queues are flushed.\n\nAn attacker could seek to exploit this by filling up the queues with\nlots of large messages that are never going to be used in order to\nattempt a DoS by memory exhaustion.\n\nI will assume that we are only concerned with servers here. It does not\nseem reasonable to be concerned about a memory exhaustion attack on a\nclient. They are unlikely to process enough connections for this to be\nan issue.\n\nA \"long\" handshake with many messages might be 5 messages long (in the\nincoming direction), e.g. ClientHello, Certificate, ClientKeyExchange,\nCertificateVerify, Finished. So this would be message sequence numbers 0\nto 4. Additionally we can buffer up to 10 messages in the future.\nTherefore the maximum number of messages that an attacker could send\nthat could get orphaned would typically be 15.\n\nThe maximum size that a DTLS message is allowed to be is defined by\nmax_cert_list, which by default is 100k. Therefore the maximum amount of\n\"orphaned\" memory per connection is 1500k.\n\nMessage sequence numbers get reset after the Finished message, so\nrenegotiation will not extend the maximum number of messages that can be\norphaned per connection.\n\nAs noted above, the queues do get cleared when the connection is closed.\nTherefore in order to mount an effective attack, an attacker would have\nto open many simultaneous connections.\n\nIssue reported by Quan Luo.\n\nCVE-2016-2179\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
    "before_after_code_files": [
      "ssl/d1_lib.c||ssl/d1_lib.c",
      "ssl/ssl_locl.h||ssl/ssl_locl.h",
      "ssl/statem/statem_dtls.c||ssl/statem/statem_dtls.c",
      "ssl/statem/statem_lib.c||ssl/statem/statem_lib.c",
      "ssl/statem/statem_srvr.c||ssl/statem/statem_srvr.c"
    ]
  },
  "patch_diff": {
    "ssl/d1_lib.c||ssl/d1_lib.c": [
      "File: ssl/d1_lib.c -> ssl/d1_lib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "114: }",
      "116: static void dtls1_clear_queues(SSL *s)",
      "117: {",
      "118:     pitem *item = NULL;",
      "119:     hm_fragment *frag = NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "117: {",
      "118:     dtls1_clear_received_buffer(s);",
      "119:     dtls1_clear_sent_buffer(s);",
      "120: }",
      "122: void dtls1_clear_received_buffer(SSL *s)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "123:         dtls1_hm_fragment_free(frag);",
      "124:         pitem_free(item);",
      "125:     }",
      "127:     while ((item = pqueue_pop(s->d1->sent_messages)) != NULL) {",
      "128:         frag = (hm_fragment *)item->data;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "132: }",
      "134: void dtls1_clear_sent_buffer(SSL *s)",
      "135: {",
      "136:     pitem *item = NULL;",
      "137:     hm_fragment *frag = NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "325:     BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,",
      "326:              &(s->d1->next_timeout));",
      "329: }",
      "331: int dtls1_check_timeout_num(SSL *s)",
      "",
      "[Removed Lines]",
      "328:     dtls1_clear_record_buffer(s);",
      "",
      "[Added Lines]",
      "341:     dtls1_clear_sent_buffer(s);",
      "",
      "---------------"
    ],
    "ssl/ssl_locl.h||ssl/ssl_locl.h": [
      "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1923: __owur int dtls1_retransmit_message(SSL *s, unsigned short seq, int *found);",
      "1924: __owur int dtls1_get_queue_priority(unsigned short seq, int is_ccs);",
      "1925: int dtls1_retransmit_buffered_messages(SSL *s);",
      "1927: void dtls1_get_message_header(unsigned char *data,",
      "1928:                               struct hm_header_st *msg_hdr);",
      "1929: __owur long dtls1_default_timeout(void);",
      "",
      "[Removed Lines]",
      "1926: void dtls1_clear_record_buffer(SSL *s);",
      "",
      "[Added Lines]",
      "1926: void dtls1_clear_received_buffer(SSL *s);",
      "1927: void dtls1_clear_sent_buffer(SSL *s);",
      "",
      "---------------"
    ],
    "ssl/statem/statem_dtls.c||ssl/statem/statem_dtls.c": [
      "File: ssl/statem/statem_dtls.c -> ssl/statem/statem_dtls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "442:     int al;",
      "452:     if (frag->reassembly != NULL)",
      "",
      "[Removed Lines]",
      "445:     item = pqueue_peek(s->d1->buffered_messages);",
      "446:     if (item == NULL)",
      "447:         return 0;",
      "449:     frag = (hm_fragment *)item->data;",
      "",
      "[Added Lines]",
      "446:     do {",
      "447:         item = pqueue_peek(s->d1->buffered_messages);",
      "448:         if (item == NULL)",
      "449:             return 0;",
      "451:         frag = (hm_fragment *)item->data;",
      "453:         if (frag->msg_header.seq < s->d1->handshake_read_seq) {",
      "455:             pqueue_pop(s->d1->buffered_messages);",
      "456:             dtls1_hm_fragment_free(frag);",
      "457:             pitem_free(item);",
      "458:             item = NULL;",
      "459:             frag = NULL;",
      "460:         }",
      "461:     } while (item == NULL);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1117:     return ret;",
      "1118: }",
      "1132: void dtls1_set_message_header(SSL *s,",
      "1133:                               unsigned char mt, unsigned long len,",
      "1134:                               unsigned long frag_off, unsigned long frag_len)",
      "",
      "[Removed Lines]",
      "1121: void dtls1_clear_record_buffer(SSL *s)",
      "1122: {",
      "1123:     pitem *item;",
      "1125:     for (item = pqueue_pop(s->d1->sent_messages);",
      "1126:          item != NULL; item = pqueue_pop(s->d1->sent_messages)) {",
      "1127:         dtls1_hm_fragment_free((hm_fragment *)item->data);",
      "1128:         pitem_free(item);",
      "1129:     }",
      "1130: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "ssl/statem/statem_lib.c||ssl/statem/statem_lib.c": [
      "File: ssl/statem/statem_lib.c -> ssl/statem/statem_lib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "331:             s->d1->handshake_read_seq = 0;",
      "332:             s->d1->handshake_write_seq = 0;",
      "333:             s->d1->next_handshake_write_seq = 0;",
      "334:         }",
      "335:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "334:             dtls1_clear_received_buffer(s);",
      "",
      "---------------"
    ],
    "ssl/statem/statem_srvr.c||ssl/statem/statem_srvr.c": [
      "File: ssl/statem/statem_srvr.c -> ssl/statem/statem_srvr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "433:     case TLS_ST_SW_HELLO_REQ:",
      "434:         s->shutdown = 0;",
      "435:         if (SSL_IS_DTLS(s))",
      "437:         break;",
      "439:     case DTLS_ST_SW_HELLO_VERIFY_REQUEST:",
      "440:         s->shutdown = 0;",
      "441:         if (SSL_IS_DTLS(s)) {",
      "444:             st->use_timer = 0;",
      "445:         }",
      "",
      "[Removed Lines]",
      "436:             dtls1_clear_record_buffer(s);",
      "442:             dtls1_clear_record_buffer(s);",
      "",
      "[Added Lines]",
      "436:             dtls1_clear_sent_buffer(s);",
      "442:             dtls1_clear_sent_buffer(s);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "00a4c1421407b6ac796688871b0a49a179c694d9",
      "candidate_info": {
        "commit_hash": "00a4c1421407b6ac796688871b0a49a179c694d9",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/00a4c1421407b6ac796688871b0a49a179c694d9",
        "files": [
          "ssl/d1_both.c",
          "ssl/d1_clnt.c",
          "ssl/d1_lib.c",
          "ssl/d1_srvr.c",
          "ssl/ssl_locl.h"
        ],
        "message": "Fix DTLS buffered message DoS attack\n\nDTLS can handle out of order record delivery. Additionally since\nhandshake messages can be bigger than will fit into a single packet, the\nmessages can be fragmented across multiple records (as with normal TLS).\nThat means that the messages can arrive mixed up, and we have to\nreassemble them. We keep a queue of buffered messages that are \"from the\nfuture\", i.e. messages we're not ready to deal with yet but have arrived\nearly. The messages held there may not be full yet - they could be one\nor more fragments that are still in the process of being reassembled.\n\nThe code assumes that we will eventually complete the reassembly and\nwhen that occurs the complete message is removed from the queue at the\npoint that we need to use it.\n\nHowever, DTLS is also tolerant of packet loss. To get around that DTLS\nmessages can be retransmitted. If we receive a full (non-fragmented)\nmessage from the peer after previously having received a fragment of\nthat message, then we ignore the message in the queue and just use the\nnon-fragmented version. At that point the queued message will never get\nremoved.\n\nAdditionally the peer could send \"future\" messages that we never get to\nin order to complete the handshake. Each message has a sequence number\n(starting from 0). We will accept a message fragment for the current\nmessage sequence number, or for any sequence up to 10 into the future.\nHowever if the Finished message has a sequence number of 2, anything\ngreater than that in the queue is just left there.\n\nSo, in those two ways we can end up with \"orphaned\" data in the queue\nthat will never get removed - except when the connection is closed. At\nthat point all the queues are flushed.\n\nAn attacker could seek to exploit this by filling up the queues with\nlots of large messages that are never going to be used in order to\nattempt a DoS by memory exhaustion.\n\nI will assume that we are only concerned with servers here. It does not\nseem reasonable to be concerned about a memory exhaustion attack on a\nclient. They are unlikely to process enough connections for this to be\nan issue.\n\nA \"long\" handshake with many messages might be 5 messages long (in the\nincoming direction), e.g. ClientHello, Certificate, ClientKeyExchange,\nCertificateVerify, Finished. So this would be message sequence numbers 0\nto 4. Additionally we can buffer up to 10 messages in the future.\nTherefore the maximum number of messages that an attacker could send\nthat could get orphaned would typically be 15.\n\nThe maximum size that a DTLS message is allowed to be is defined by\nmax_cert_list, which by default is 100k. Therefore the maximum amount of\n\"orphaned\" memory per connection is 1500k.\n\nMessage sequence numbers get reset after the Finished message, so\nrenegotiation will not extend the maximum number of messages that can be\norphaned per connection.\n\nAs noted above, the queues do get cleared when the connection is closed.\nTherefore in order to mount an effective attack, an attacker would have\nto open many simultaneous connections.\n\nIssue reported by Quan Luo.\n\nCVE-2016-2179\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "ssl/d1_both.c||ssl/d1_both.c",
          "ssl/d1_clnt.c||ssl/d1_clnt.c",
          "ssl/d1_lib.c||ssl/d1_lib.c",
          "ssl/d1_srvr.c||ssl/d1_srvr.c",
          "ssl/ssl_locl.h||ssl/ssl_locl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "ssl/d1_lib.c||ssl/d1_lib.c",
            "ssl/ssl_locl.h||ssl/ssl_locl.h"
          ],
          "candidate": [
            "ssl/d1_lib.c||ssl/d1_lib.c",
            "ssl/ssl_locl.h||ssl/ssl_locl.h"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_both.c||ssl/d1_both.c": [
          "File: ssl/d1_both.c -> ssl/d1_both.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "614:     int al;",
          "624:     if (frag->reassembly != NULL)",
          "",
          "[Removed Lines]",
          "617:     item = pqueue_peek(s->d1->buffered_messages);",
          "618:     if (item == NULL)",
          "619:         return 0;",
          "621:     frag = (hm_fragment *)item->data;",
          "",
          "[Added Lines]",
          "617:     do {",
          "618:         item = pqueue_peek(s->d1->buffered_messages);",
          "619:         if (item == NULL)",
          "620:             return 0;",
          "622:         frag = (hm_fragment *)item->data;",
          "624:         if (frag->msg_header.seq < s->d1->handshake_read_seq) {",
          "626:             pqueue_pop(s->d1->buffered_messages);",
          "627:             dtls1_hm_fragment_free(frag);",
          "628:             pitem_free(item);",
          "629:             item = NULL;",
          "630:             frag = NULL;",
          "631:         }",
          "632:     } while (item == NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1416:     return ret;",
          "1417: }",
          "1431: unsigned char *dtls1_set_message_header(SSL *s, unsigned char *p,",
          "1432:                                         unsigned char mt, unsigned long len,",
          "1433:                                         unsigned long frag_off,",
          "",
          "[Removed Lines]",
          "1420: void dtls1_clear_record_buffer(SSL *s)",
          "1421: {",
          "1422:     pitem *item;",
          "1424:     for (item = pqueue_pop(s->d1->sent_messages);",
          "1425:          item != NULL; item = pqueue_pop(s->d1->sent_messages)) {",
          "1426:         dtls1_hm_fragment_free((hm_fragment *)item->data);",
          "1427:         pitem_free(item);",
          "1428:     }",
          "1429: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ssl/d1_clnt.c||ssl/d1_clnt.c": [
          "File: ssl/d1_clnt.c -> ssl/d1_clnt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "752:             s->d1->handshake_read_seq = 0;",
          "753:             s->d1->next_handshake_write_seq = 0;",
          "754:             goto end;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:             dtls1_clear_received_buffer(s);",
          "",
          "---------------"
        ],
        "ssl/d1_lib.c||ssl/d1_lib.c": [
          "File: ssl/d1_lib.c -> ssl/d1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "144: static void dtls1_clear_queues(SSL *s)",
          "145: {",
          "146:     pitem *item = NULL;",
          "148:     DTLS1_RECORD_DATA *rdata;",
          "150:     while ((item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL) {",
          "",
          "[Removed Lines]",
          "147:     hm_fragment *frag = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "165:         pitem_free(item);",
          "166:     }",
          "168:     while ((item = pqueue_pop(s->d1->buffered_messages)) != NULL) {",
          "169:         frag = (hm_fragment *)item->data;",
          "170:         dtls1_hm_fragment_free(frag);",
          "171:         pitem_free(item);",
          "172:     }",
          "174:     while ((item = pqueue_pop(s->d1->sent_messages)) != NULL) {",
          "175:         frag = (hm_fragment *)item->data;",
          "176:         dtls1_hm_fragment_free(frag);",
          "177:         pitem_free(item);",
          "178:     }",
          "188: }",
          "190: void dtls1_free(SSL *s)",
          "191: {",
          "192:     ssl3_free(s);",
          "",
          "[Removed Lines]",
          "180:     while ((item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) {",
          "181:         rdata = (DTLS1_RECORD_DATA *)item->data;",
          "182:         if (rdata->rbuf.buf) {",
          "183:             OPENSSL_free(rdata->rbuf.buf);",
          "184:         }",
          "185:         OPENSSL_free(item->data);",
          "186:         pitem_free(item);",
          "187:     }",
          "",
          "[Added Lines]",
          "167:     while ((item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) {",
          "168:         rdata = (DTLS1_RECORD_DATA *)item->data;",
          "169:         if (rdata->rbuf.buf) {",
          "170:             OPENSSL_free(rdata->rbuf.buf);",
          "171:         }",
          "172:         OPENSSL_free(item->data);",
          "173:         pitem_free(item);",
          "174:     }",
          "176:     dtls1_clear_received_buffer(s);",
          "177:     dtls1_clear_sent_buffer(s);",
          "178: }",
          "180: void dtls1_clear_received_buffer(SSL *s)",
          "181: {",
          "182:     pitem *item = NULL;",
          "183:     hm_fragment *frag = NULL;",
          "190: }",
          "192: void dtls1_clear_sent_buffer(SSL *s)",
          "193: {",
          "194:     pitem *item = NULL;",
          "195:     hm_fragment *frag = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:     BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,",
          "421:              &(s->d1->next_timeout));",
          "424: }",
          "426: int dtls1_check_timeout_num(SSL *s)",
          "",
          "[Removed Lines]",
          "423:     dtls1_clear_record_buffer(s);",
          "",
          "[Added Lines]",
          "438:     dtls1_clear_sent_buffer(s);",
          "",
          "---------------"
        ],
        "ssl/d1_srvr.c||ssl/d1_srvr.c": [
          "File: ssl/d1_srvr.c -> ssl/d1_srvr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "295:         case SSL3_ST_SW_HELLO_REQ_B:",
          "297:             s->shutdown = 0;",
          "299:             dtls1_start_timer(s);",
          "300:             ret = dtls1_send_hello_request(s);",
          "301:             if (ret <= 0)",
          "",
          "[Removed Lines]",
          "298:             dtls1_clear_record_buffer(s);",
          "",
          "[Added Lines]",
          "298:             dtls1_clear_sent_buffer(s);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "867:             s->d1->handshake_write_seq = 0;",
          "868:             s->d1->next_handshake_write_seq = 0;",
          "869:             goto end;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "869:             dtls1_clear_received_buffer(s);",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1026:                              unsigned long frag_off, int *found);",
          "1027: int dtls1_get_queue_priority(unsigned short seq, int is_ccs);",
          "1028: int dtls1_retransmit_buffered_messages(SSL *s);",
          "1030: void dtls1_get_message_header(unsigned char *data,",
          "1031:                               struct hm_header_st *msg_hdr);",
          "1032: void dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr);",
          "",
          "[Removed Lines]",
          "1029: void dtls1_clear_record_buffer(SSL *s);",
          "",
          "[Added Lines]",
          "1029: void dtls1_clear_received_buffer(SSL *s);",
          "1030: void dtls1_clear_sent_buffer(SSL *s);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "26f2c5774f117aea588e8f31fad38bcf14e83bec",
      "candidate_info": {
        "commit_hash": "26f2c5774f117aea588e8f31fad38bcf14e83bec",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/26f2c5774f117aea588e8f31fad38bcf14e83bec",
        "files": [
          "ssl/d1_both.c",
          "ssl/d1_clnt.c",
          "ssl/d1_lib.c",
          "ssl/d1_srvr.c",
          "ssl/ssl_locl.h"
        ],
        "message": "Fix DTLS buffered message DoS attack\n\nDTLS can handle out of order record delivery. Additionally since\nhandshake messages can be bigger than will fit into a single packet, the\nmessages can be fragmented across multiple records (as with normal TLS).\nThat means that the messages can arrive mixed up, and we have to\nreassemble them. We keep a queue of buffered messages that are \"from the\nfuture\", i.e. messages we're not ready to deal with yet but have arrived\nearly. The messages held there may not be full yet - they could be one\nor more fragments that are still in the process of being reassembled.\n\nThe code assumes that we will eventually complete the reassembly and\nwhen that occurs the complete message is removed from the queue at the\npoint that we need to use it.\n\nHowever, DTLS is also tolerant of packet loss. To get around that DTLS\nmessages can be retransmitted. If we receive a full (non-fragmented)\nmessage from the peer after previously having received a fragment of\nthat message, then we ignore the message in the queue and just use the\nnon-fragmented version. At that point the queued message will never get\nremoved.\n\nAdditionally the peer could send \"future\" messages that we never get to\nin order to complete the handshake. Each message has a sequence number\n(starting from 0). We will accept a message fragment for the current\nmessage sequence number, or for any sequence up to 10 into the future.\nHowever if the Finished message has a sequence number of 2, anything\ngreater than that in the queue is just left there.\n\nSo, in those two ways we can end up with \"orphaned\" data in the queue\nthat will never get removed - except when the connection is closed. At\nthat point all the queues are flushed.\n\nAn attacker could seek to exploit this by filling up the queues with\nlots of large messages that are never going to be used in order to\nattempt a DoS by memory exhaustion.\n\nI will assume that we are only concerned with servers here. It does not\nseem reasonable to be concerned about a memory exhaustion attack on a\nclient. They are unlikely to process enough connections for this to be\nan issue.\n\nA \"long\" handshake with many messages might be 5 messages long (in the\nincoming direction), e.g. ClientHello, Certificate, ClientKeyExchange,\nCertificateVerify, Finished. So this would be message sequence numbers 0\nto 4. Additionally we can buffer up to 10 messages in the future.\nTherefore the maximum number of messages that an attacker could send\nthat could get orphaned would typically be 15.\n\nThe maximum size that a DTLS message is allowed to be is defined by\nmax_cert_list, which by default is 100k. Therefore the maximum amount of\n\"orphaned\" memory per connection is 1500k.\n\nMessage sequence numbers get reset after the Finished message, so\nrenegotiation will not extend the maximum number of messages that can be\norphaned per connection.\n\nAs noted above, the queues do get cleared when the connection is closed.\nTherefore in order to mount an effective attack, an attacker would have\nto open many simultaneous connections.\n\nIssue reported by Quan Luo.\n\nCVE-2016-2179\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "ssl/d1_both.c||ssl/d1_both.c",
          "ssl/d1_clnt.c||ssl/d1_clnt.c",
          "ssl/d1_lib.c||ssl/d1_lib.c",
          "ssl/d1_srvr.c||ssl/d1_srvr.c",
          "ssl/ssl_locl.h||ssl/ssl_locl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "ssl/d1_lib.c||ssl/d1_lib.c",
            "ssl/ssl_locl.h||ssl/ssl_locl.h"
          ],
          "candidate": [
            "ssl/d1_lib.c||ssl/d1_lib.c",
            "ssl/ssl_locl.h||ssl/ssl_locl.h"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_both.c||ssl/d1_both.c": [
          "File: ssl/d1_both.c -> ssl/d1_both.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "618:     int al;",
          "628:     if (frag->reassembly != NULL)",
          "",
          "[Removed Lines]",
          "621:     item = pqueue_peek(s->d1->buffered_messages);",
          "622:     if (item == NULL)",
          "623:         return 0;",
          "625:     frag = (hm_fragment *)item->data;",
          "",
          "[Added Lines]",
          "621:     do {",
          "622:         item = pqueue_peek(s->d1->buffered_messages);",
          "623:         if (item == NULL)",
          "624:             return 0;",
          "626:         frag = (hm_fragment *)item->data;",
          "628:         if (frag->msg_header.seq < s->d1->handshake_read_seq) {",
          "630:             pqueue_pop(s->d1->buffered_messages);",
          "631:             dtls1_hm_fragment_free(frag);",
          "632:             pitem_free(item);",
          "633:             item = NULL;",
          "634:             frag = NULL;",
          "635:         }",
          "636:     } while (item == NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1296:     return ret;",
          "1297: }",
          "1311: unsigned char *dtls1_set_message_header(SSL *s, unsigned char *p,",
          "1312:                                         unsigned char mt, unsigned long len,",
          "1313:                                         unsigned long frag_off,",
          "",
          "[Removed Lines]",
          "1300: void dtls1_clear_record_buffer(SSL *s)",
          "1301: {",
          "1302:     pitem *item;",
          "1304:     for (item = pqueue_pop(s->d1->sent_messages);",
          "1305:          item != NULL; item = pqueue_pop(s->d1->sent_messages)) {",
          "1306:         dtls1_hm_fragment_free((hm_fragment *)item->data);",
          "1307:         pitem_free(item);",
          "1308:     }",
          "1309: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ssl/d1_clnt.c||ssl/d1_clnt.c": [
          "File: ssl/d1_clnt.c -> ssl/d1_clnt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "770:             s->d1->handshake_read_seq = 0;",
          "771:             s->d1->next_handshake_write_seq = 0;",
          "772:             goto end;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "772:             dtls1_clear_received_buffer(s);",
          "",
          "---------------"
        ],
        "ssl/d1_lib.c||ssl/d1_lib.c": [
          "File: ssl/d1_lib.c -> ssl/d1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170: static void dtls1_clear_queues(SSL *s)",
          "171: {",
          "172:     pitem *item = NULL;",
          "174:     DTLS1_RECORD_DATA *rdata;",
          "176:     while ((item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL) {",
          "",
          "[Removed Lines]",
          "173:     hm_fragment *frag = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191:         pitem_free(item);",
          "192:     }",
          "194:     while ((item = pqueue_pop(s->d1->buffered_messages)) != NULL) {",
          "195:         frag = (hm_fragment *)item->data;",
          "196:         dtls1_hm_fragment_free(frag);",
          "197:         pitem_free(item);",
          "198:     }",
          "200:     while ((item = pqueue_pop(s->d1->sent_messages)) != NULL) {",
          "201:         frag = (hm_fragment *)item->data;",
          "202:         dtls1_hm_fragment_free(frag);",
          "203:         pitem_free(item);",
          "204:     }",
          "214: }",
          "216: void dtls1_free(SSL *s)",
          "217: {",
          "218:     ssl3_free(s);",
          "",
          "[Removed Lines]",
          "206:     while ((item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) {",
          "207:         rdata = (DTLS1_RECORD_DATA *)item->data;",
          "208:         if (rdata->rbuf.buf) {",
          "209:             OPENSSL_free(rdata->rbuf.buf);",
          "210:         }",
          "211:         OPENSSL_free(item->data);",
          "212:         pitem_free(item);",
          "213:     }",
          "",
          "[Added Lines]",
          "193:     while ((item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) {",
          "194:         rdata = (DTLS1_RECORD_DATA *)item->data;",
          "195:         if (rdata->rbuf.buf) {",
          "196:             OPENSSL_free(rdata->rbuf.buf);",
          "197:         }",
          "198:         OPENSSL_free(item->data);",
          "199:         pitem_free(item);",
          "200:     }",
          "202:     dtls1_clear_received_buffer(s);",
          "203:     dtls1_clear_sent_buffer(s);",
          "204: }",
          "206: void dtls1_clear_received_buffer(SSL *s)",
          "207: {",
          "208:     pitem *item = NULL;",
          "209:     hm_fragment *frag = NULL;",
          "216: }",
          "218: void dtls1_clear_sent_buffer(SSL *s)",
          "219: {",
          "220:     pitem *item = NULL;",
          "221:     hm_fragment *frag = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "456:     BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,",
          "457:              &(s->d1->next_timeout));",
          "460: }",
          "462: int dtls1_check_timeout_num(SSL *s)",
          "",
          "[Removed Lines]",
          "459:     dtls1_clear_record_buffer(s);",
          "",
          "[Added Lines]",
          "474:     dtls1_clear_sent_buffer(s);",
          "",
          "---------------"
        ],
        "ssl/d1_srvr.c||ssl/d1_srvr.c": [
          "File: ssl/d1_srvr.c -> ssl/d1_srvr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:         case SSL3_ST_SW_HELLO_REQ_B:",
          "315:             s->shutdown = 0;",
          "317:             dtls1_start_timer(s);",
          "318:             ret = ssl3_send_hello_request(s);",
          "319:             if (ret <= 0)",
          "",
          "[Removed Lines]",
          "316:             dtls1_clear_record_buffer(s);",
          "",
          "[Added Lines]",
          "316:             dtls1_clear_sent_buffer(s);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "895:             s->d1->handshake_write_seq = 0;",
          "896:             s->d1->next_handshake_write_seq = 0;",
          "897:             goto end;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "897:             dtls1_clear_received_buffer(s);",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1248:                              unsigned long frag_off, int *found);",
          "1249: int dtls1_get_queue_priority(unsigned short seq, int is_ccs);",
          "1250: int dtls1_retransmit_buffered_messages(SSL *s);",
          "1252: void dtls1_get_message_header(unsigned char *data,",
          "1253:                               struct hm_header_st *msg_hdr);",
          "1254: void dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr);",
          "",
          "[Removed Lines]",
          "1251: void dtls1_clear_record_buffer(SSL *s);",
          "",
          "[Added Lines]",
          "1251: void dtls1_clear_received_buffer(SSL *s);",
          "1252: void dtls1_clear_sent_buffer(SSL *s);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
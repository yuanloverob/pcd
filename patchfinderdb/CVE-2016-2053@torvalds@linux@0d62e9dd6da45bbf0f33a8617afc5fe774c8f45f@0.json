{
  "cve_id": "CVE-2016-2053",
  "cve_desc": "The asn1_ber_decoder function in lib/asn1_decoder.c in the Linux kernel before 4.3 allows attackers to cause a denial of service (panic) via an ASN.1 BER file that lacks a public key, leading to mishandling by the public_key_verify_signature function in crypto/asymmetric_keys/public_key.c.",
  "repo": "torvalds/linux",
  "patch_hash": "0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
  "patch_info": {
    "commit_hash": "0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
    "files": [
      "lib/asn1_decoder.c"
    ],
    "message": "ASN.1: Fix non-match detection failure on data overrun\n\nIf the ASN.1 decoder is asked to parse a sequence of objects, non-optional\nmatches get skipped if there's no more data to be had rather than a\ndata-overrun error being reported.\n\nThis is due to the code segment that decides whether to skip optional\nmatches (ie. matches that could get ignored because an element is marked\nOPTIONAL in the grammar) due to a lack of data also skips non-optional\nelements if the data pointer has reached the end of the buffer.\n\nThis can be tested with the data decoder for the new RSA akcipher algorithm\nthat takes three non-optional integers.  Currently, it skips the last\ninteger if there is insufficient data.\n\nWithout the fix, #defining DEBUG in asn1_decoder.c will show something\nlike:\n\n\tnext_op: pc=0/13 dp=0/270 C=0 J=0\n\t- match? 30 30 00\n\t- TAG: 30 266 CONS\n\tnext_op: pc=2/13 dp=4/270 C=1 J=0\n\t- match? 02 02 00\n\t- TAG: 02 257\n\t- LEAF: 257\n\tnext_op: pc=5/13 dp=265/270 C=1 J=0\n\t- match? 02 02 00\n\t- TAG: 02 3\n\t- LEAF: 3\n\tnext_op: pc=8/13 dp=270/270 C=1 J=0\n\tnext_op: pc=11/13 dp=270/270 C=1 J=0\n\t- end cons t=4 dp=270 l=270/270\n\nThe next_op line for pc=8/13 should be followed by a match line.\n\nThis is not exploitable for X.509 certificates by means of shortening the\nmessage and fixing up the ASN.1 CONS tags because:\n\n (1) The relevant records being built up are cleared before use.\n\n (2) If the message is shortened sufficiently to remove the public key, the\n     ASN.1 parse of the RSA key will fail quickly due to a lack of data.\n\n (3) Extracted signature data is either turned into MPIs (which cope with a\n     0 length) or is simpler integers specifying algoritms and suchlike\n     (which can validly be 0); and\n\n (4) The AKID and SKID extensions are optional and their removal is handled\n     without risking passing a NULL to asymmetric_key_generate_id().\n\n (5) If the certificate is truncated sufficiently to remove the subject,\n     issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons\n     stack underflow' return.\n\nThis is not exploitable for PKCS#7 messages by means of removal of elements\nfrom such a message from the tail end of a sequence:\n\n (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable\n     as detailed above.\n\n (2) The message digest content isn't used if it shows a NULL pointer,\n     similarly, the authattrs aren't used if that shows a NULL pointer.\n\n (3) A missing signature results in a NULL MPI - which the MPI routines deal\n     with.\n\n (4) If data is NULL, it is expected that the message has detached content and\n     that is handled appropriately.\n\n (5) If the serialNumber is excised, the unconditional action associated\n     with it will pick up the containing SEQUENCE instead, so no NULL\n     pointer will be seen here.\n\n     If both the issuer and the serialNumber are excised, the ASN.1 decode\n     will fail with an 'Unexpected tag' return.\n\n     In either case, there's no way to get to asymmetric_key_generate_id()\n     with a NULL pointer.\n\n (6) Other fields are decoded to simple integers.  Shortening the message\n     to omit an algorithm ID field will cause checks on this to fail early\n     in the verification process.\n\n\nThis can also be tested by snipping objects off of the end of the ASN.1 stream\nsuch that mandatory tags are removed - or even from the end of internal\nSEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be\nproduced.  Without this patch ERANGE or ENOPKG might be produced or the parse\nmay apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced\nlater, depending on what gets snipped.\n\nJust snipping off the final BIT_STRING or OCTET_STRING from either sample\nshould be a start since both are mandatory and neither will cause an EBADMSG\nwithout the patches\n\nReported-by: Marcel Holtmann <marcel@holtmann.org>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Marcel Holtmann <marcel@holtmann.org>\nReviewed-by: David Woodhouse <David.Woodhouse@intel.com>",
    "before_after_code_files": [
      "lib/asn1_decoder.c||lib/asn1_decoder.c"
    ]
  },
  "patch_diff": {
    "lib/asn1_decoder.c||lib/asn1_decoder.c": [
      "File: lib/asn1_decoder.c -> lib/asn1_decoder.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "210:   unsigned char tmp;",
      "216:    flags &= ~FLAG_LAST_MATCHED;",
      "217:    pc += asn1_op_lengths[op];",
      "218:    goto next_op;",
      "",
      "[Removed Lines]",
      "213:   if ((op & ASN1_OP_MATCH__COND &&",
      "214:        flags & FLAG_MATCHED) ||",
      "215:       dp == datalen) {",
      "",
      "[Added Lines]",
      "213:   if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||",
      "214:       (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bc1c373dd2a5113800360f7152be729c9da996cc",
      "candidate_info": {
        "commit_hash": "bc1c373dd2a5113800360f7152be729c9da996cc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bc1c373dd2a5113800360f7152be729c9da996cc",
        "files": [
          "include/crypto/public_key.h",
          "scripts/sign-file.c"
        ],
        "message": "MODSIGN: Provide a utility to append a PKCS#7 signature to a module\n\nProvide a utility that:\n\n (1) Digests a module using the specified hash algorithm (typically sha256).\n\n     [The digest can be dumped into a file by passing the '-d' flag]\n\n (2) Generates a PKCS#7 message that:\n\n     (a) Has detached data (ie. the module content).\n\n     (b) Is signed with the specified private key.\n\n     (c) Refers to the specified X.509 certificate.\n\n     (d) Has an empty X.509 certificate list.\n\n     [The PKCS#7 message can be dumped into a file by passing the '-p' flag]\n\n (3) Generates a signed module by concatenating the old module, the PKCS#7\n     message, a descriptor and a magic string.  The descriptor contains the\n     size of the PKCS#7 message and indicates the id_type as PKEY_ID_PKCS7.\n\n (4) Either writes the signed module to the specified destination or renames\n     it over the source module.\n\nThis allows module signing to reuse the PKCS#7 handling code that was added\nfor PE file parsing for signed kexec.\n\nNote that the utility is written in C and must be linked against the OpenSSL\ncrypto library.\n\nNote further that I have temporarily dropped support for handling externally\ncreated signatures until we can work out the best way to do those.  Hopefully,\nwhoever creates the signature can give me a PKCS#7 certificate.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Vivek Goyal <vgoyal@redhat.com>",
        "before_after_code_files": [
          "include/crypto/public_key.h||include/crypto/public_key.h",
          "scripts/sign-file.c||scripts/sign-file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/crypto/public_key.h||include/crypto/public_key.h": [
          "File: include/crypto/public_key.h -> include/crypto/public_key.h"
        ],
        "scripts/sign-file.c||scripts/sign-file.c": [
          "File: scripts/sign-file.c -> scripts/sign-file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #define _GNU_SOURCE",
          "12: #include <stdio.h>",
          "13: #include <stdlib.h>",
          "14: #include <stdint.h>",
          "15: #include <stdbool.h>",
          "16: #include <string.h>",
          "17: #include <getopt.h>",
          "18: #include <err.h>",
          "19: #include <arpa/inet.h>",
          "20: #include <openssl/bio.h>",
          "21: #include <openssl/evp.h>",
          "22: #include <openssl/pem.h>",
          "23: #include <openssl/pkcs7.h>",
          "24: #include <openssl/err.h>",
          "26: struct module_signature {",
          "32:  uint8_t  __pad[3];",
          "34: };",
          "36: #define PKEY_ID_PKCS7 2",
          "38: static char magic_number[] = \"~Module signature appended~\\n\";",
          "40: static __attribute__((noreturn))",
          "41: void format(void)",
          "42: {",
          "43:  fprintf(stderr,",
          "44:   \"Usage: scripts/sign-file [-dp] <hash algo> <key> <x509> <module> [<dest>]\\n\");",
          "45:  exit(2);",
          "46: }",
          "48: static void display_openssl_errors(int l)",
          "49: {",
          "50:  const char *file;",
          "51:  char buf[120];",
          "52:  int e, line;",
          "54:  if (ERR_peek_error() == 0)",
          "55:   return;",
          "56:  fprintf(stderr, \"At main.c:%d:\\n\", l);",
          "58:  while ((e = ERR_get_error_line(&file, &line))) {",
          "59:   ERR_error_string(e, buf);",
          "60:   fprintf(stderr, \"- SSL %s: %s:%d\\n\", buf, file, line);",
          "61:  }",
          "62: }",
          "64: static void drain_openssl_errors(void)",
          "65: {",
          "66:  const char *file;",
          "67:  int line;",
          "69:  if (ERR_peek_error() == 0)",
          "70:   return;",
          "71:  while (ERR_get_error_line(&file, &line)) {}",
          "72: }",
          "74: #define ERR(cond, fmt, ...)    \\",
          "75:  do {      \\",
          "76:   bool __cond = (cond);   \\",
          "77:   display_openssl_errors(__LINE__); \\",
          "78:   if (__cond) {    \\",
          "79:    err(1, fmt, ## __VA_ARGS__); \\",
          "80:   }     \\",
          "81:  } while(0)",
          "83: int main(int argc, char **argv)",
          "84: {",
          "85:  struct module_signature sig_info = { .id_type = PKEY_ID_PKCS7 };",
          "86:  char *hash_algo = NULL;",
          "87:  char *private_key_name, *x509_name, *module_name, *dest_name;",
          "88:  bool save_pkcs7 = false, replace_orig;",
          "89:  unsigned char buf[4096];",
          "90:  unsigned long module_size, pkcs7_size;",
          "91:  const EVP_MD *digest_algo;",
          "92:  EVP_PKEY *private_key;",
          "93:  PKCS7 *pkcs7;",
          "94:  X509 *x509;",
          "95:  BIO *b, *bd, *bm;",
          "96:  int opt, n;",
          "98:  ERR_load_crypto_strings();",
          "99:  ERR_clear_error();",
          "101:  do {",
          "102:   opt = getopt(argc, argv, \"dp\");",
          "103:   switch (opt) {",
          "104:   case 'p': save_pkcs7 = true; break;",
          "105:   case -1: break;",
          "106:   default: format();",
          "107:   }",
          "108:  } while (opt != -1);",
          "110:  argc -= optind;",
          "111:  argv += optind;",
          "112:  if (argc < 4 || argc > 5)",
          "113:   format();",
          "115:  hash_algo = argv[0];",
          "116:  private_key_name = argv[1];",
          "117:  x509_name = argv[2];",
          "118:  module_name = argv[3];",
          "119:  if (argc == 5) {",
          "120:   dest_name = argv[4];",
          "121:   replace_orig = false;",
          "122:  } else {",
          "123:   ERR(asprintf(&dest_name, \"%s.~signed~\", module_name) < 0,",
          "124:       \"asprintf\");",
          "125:   replace_orig = true;",
          "126:  }",
          "131:  b = BIO_new_file(private_key_name, \"rb\");",
          "132:  ERR(!b, \"%s\", private_key_name);",
          "133:         private_key = PEM_read_bio_PrivateKey(b, NULL, NULL, NULL);",
          "134:  BIO_free(b);",
          "136:  b = BIO_new_file(x509_name, \"rb\");",
          "137:  ERR(!b, \"%s\", x509_name);",
          "139:  if (!x509) {",
          "140:   BIO_reset(b);",
          "142:   if (x509)",
          "143:    drain_openssl_errors();",
          "144:  }",
          "145:  BIO_free(b);",
          "146:  ERR(!x509, \"%s\", x509_name);",
          "151:  bd = BIO_new_file(dest_name, \"wb\");",
          "152:  ERR(!bd, \"%s\", dest_name);",
          "155:  OpenSSL_add_all_digests();",
          "156:  display_openssl_errors(__LINE__);",
          "157:  digest_algo = EVP_get_digestbyname(hash_algo);",
          "158:  ERR(!digest_algo, \"EVP_get_digestbyname\");",
          "160:  bm = BIO_new_file(module_name, \"rb\");",
          "161:  ERR(!bm, \"%s\", module_name);",
          "164:  pkcs7 = PKCS7_sign(NULL, NULL, NULL, NULL,",
          "165:       PKCS7_NOCERTS | PKCS7_PARTIAL | PKCS7_BINARY | PKCS7_DETACHED | PKCS7_STREAM);",
          "166:  ERR(!pkcs7, \"PKCS7_sign\");",
          "168:  ERR(!PKCS7_sign_add_signer(pkcs7, x509, private_key, digest_algo, PKCS7_NOCERTS | PKCS7_BINARY),",
          "169:      \"PKCS7_sign_add_signer\");",
          "170:  ERR(PKCS7_final(pkcs7, bm, PKCS7_NOCERTS | PKCS7_BINARY) < 0,",
          "171:      \"PKCS7_final\");",
          "173:  if (save_pkcs7) {",
          "174:   char *pkcs7_name;",
          "176:   ERR(asprintf(&pkcs7_name, \"%s.pkcs7\", module_name) < 0, \"asprintf\");",
          "177:   b = BIO_new_file(pkcs7_name, \"wb\");",
          "178:   ERR(!b, \"%s\", pkcs7_name);",
          "179:   ERR(i2d_PKCS7_bio_stream(b, pkcs7, NULL, 0) < 0, \"%s\", pkcs7_name);",
          "180:   BIO_free(b);",
          "181:  }",
          "184:  ERR(BIO_reset(bm) < 0, \"%s\", module_name);",
          "185:  while ((n = BIO_read(bm, buf, sizeof(buf))),",
          "186:         n > 0) {",
          "187:   ERR(BIO_write(bd, buf, n) < 0, \"%s\", dest_name);",
          "188:  }",
          "189:  ERR(n < 0, \"%s\", module_name);",
          "190:  module_size = BIO_number_written(bd);",
          "192:  ERR(i2d_PKCS7_bio_stream(bd, pkcs7, NULL, 0) < 0, \"%s\", dest_name);",
          "193:  pkcs7_size = BIO_number_written(bd) - module_size;",
          "194:  sig_info.sig_len = htonl(pkcs7_size);",
          "195:  ERR(BIO_write(bd, &sig_info, sizeof(sig_info)) < 0, \"%s\", dest_name);",
          "196:  ERR(BIO_write(bd, magic_number, sizeof(magic_number) - 1) < 0, \"%s\", dest_name);",
          "198:  ERR(BIO_free(bd) < 0, \"%s\", dest_name);",
          "201:  if (replace_orig)",
          "202:   ERR(rename(dest_name, module_name) < 0, \"%s\", dest_name);",
          "204:  return 0;",
          "205: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "233ce79db4b23a174bcf30bde5d6ad913d5f46d3",
      "candidate_info": {
        "commit_hash": "233ce79db4b23a174bcf30bde5d6ad913d5f46d3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/233ce79db4b23a174bcf30bde5d6ad913d5f46d3",
        "files": [
          "include/linux/asn1_ber_bytecode.h",
          "lib/asn1_decoder.c",
          "scripts/asn1_compiler.c"
        ],
        "message": "ASN.1: Handle 'ANY OPTIONAL' in grammar\n\nAn ANY object in an ASN.1 grammar that is marked OPTIONAL should be skipped\nif there is no more data to be had.\n\nThis can be tested by editing X.509 certificates or PKCS#7 messages to\nremove the NULL from subobjects that look like the following:\n\n\tSEQUENCE {\n\t  OBJECT(2a864886f70d01010b);\n\t  NULL();\n\t}\n\nThis is an algorithm identifier plus an optional parameter.\n\nThe modified DER can be passed to one of:\n\n\tkeyctl padd asymmetric \"\" @s </tmp/modified.x509\n\tkeyctl padd pkcs7_test foo @s </tmp/modified.pkcs7\n\nIt should work okay with the patch and produce EBADMSG without.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Marcel Holtmann <marcel@holtmann.org>\nReviewed-by: David Woodhouse <David.Woodhouse@intel.com>",
        "before_after_code_files": [
          "include/linux/asn1_ber_bytecode.h||include/linux/asn1_ber_bytecode.h",
          "lib/asn1_decoder.c||lib/asn1_decoder.c",
          "scripts/asn1_compiler.c||scripts/asn1_compiler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "lib/asn1_decoder.c||lib/asn1_decoder.c"
          ],
          "candidate": [
            "lib/asn1_decoder.c||lib/asn1_decoder.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/asn1_ber_bytecode.h||include/linux/asn1_ber_bytecode.h": [
          "File: include/linux/asn1_ber_bytecode.h -> include/linux/asn1_ber_bytecode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:  ASN1_OP_MATCH_JUMP  = 0x04,",
          "46:  ASN1_OP_MATCH_JUMP_OR_SKIP = 0x05,",
          "47:  ASN1_OP_MATCH_ANY  = 0x08,",
          "48:  ASN1_OP_MATCH_ANY_ACT  = 0x0a,",
          "51:  ASN1_OP_COND_MATCH_OR_SKIP = 0x11,",
          "52:  ASN1_OP_COND_MATCH_ACT_OR_SKIP = 0x13,",
          "53:  ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 0x15,",
          "54:  ASN1_OP_COND_MATCH_ANY  = 0x18,",
          "55:  ASN1_OP_COND_MATCH_ANY_ACT = 0x1a,",
          "68:  ASN1_OP_END_SEQ   = 0x20,",
          "",
          "[Removed Lines]",
          "58: #define ASN1_OP__MATCHES_TAG ASN1_OP_COND_MATCH_ANY_ACT",
          "61:  ASN1_OP_COND_FAIL  = 0x1b,",
          "62:  ASN1_OP_COMPLETE  = 0x1c,",
          "63:  ASN1_OP_ACT   = 0x1d,",
          "64:  ASN1_OP_MAYBE_ACT  = 0x1e,",
          "65:  ASN1_OP_RETURN   = 0x1f,",
          "",
          "[Added Lines]",
          "48:  ASN1_OP_MATCH_ANY_OR_SKIP = 0x09,",
          "50:  ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 0x0b,",
          "57:  ASN1_OP_COND_MATCH_ANY_OR_SKIP = 0x19,",
          "59:  ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 0x1b,",
          "62: #define ASN1_OP__MATCHES_TAG ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP",
          "65:  ASN1_OP_COND_FAIL  = 0x1c,",
          "66:  ASN1_OP_COMPLETE  = 0x1d,",
          "67:  ASN1_OP_ACT   = 0x1e,",
          "68:  ASN1_OP_MAYBE_ACT  = 0x1f,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77: #define ASN1_OP_END__OF     0x02",
          "78: #define ASN1_OP_END__ACT    0x04",
          "80:  ASN1_OP__NR",
          "81: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:  ASN1_OP_RETURN   = 0x28,",
          "",
          "---------------"
        ],
        "lib/asn1_decoder.c||lib/asn1_decoder.c": [
          "File: lib/asn1_decoder.c -> lib/asn1_decoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:  [ASN1_OP_MATCH_JUMP]   = 1 + 1 + 1,",
          "25:  [ASN1_OP_MATCH_JUMP_OR_SKIP]  = 1 + 1 + 1,",
          "26:  [ASN1_OP_MATCH_ANY]   = 1,",
          "27:  [ASN1_OP_MATCH_ANY_ACT]   = 1         + 1,",
          "28:  [ASN1_OP_COND_MATCH_OR_SKIP]  = 1 + 1,",
          "29:  [ASN1_OP_COND_MATCH_ACT_OR_SKIP] = 1 + 1     + 1,",
          "30:  [ASN1_OP_COND_MATCH_JUMP_OR_SKIP] = 1 + 1 + 1,",
          "31:  [ASN1_OP_COND_MATCH_ANY]  = 1,",
          "32:  [ASN1_OP_COND_MATCH_ANY_ACT]  = 1         + 1,",
          "33:  [ASN1_OP_COND_FAIL]   = 1,",
          "34:  [ASN1_OP_COMPLETE]   = 1,",
          "35:  [ASN1_OP_ACT]    = 1         + 1,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27:  [ASN1_OP_MATCH_ANY_OR_SKIP]  = 1,",
          "29:  [ASN1_OP_MATCH_ANY_ACT_OR_SKIP]  = 1         + 1,",
          "34:  [ASN1_OP_COND_MATCH_ANY_OR_SKIP] = 1,",
          "36:  [ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP] = 1         + 1,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "305:  switch (op) {",
          "306:  case ASN1_OP_MATCH_ANY_ACT:",
          "307:  case ASN1_OP_COND_MATCH_ANY_ACT:",
          "308:   ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);",
          "309:   if (ret < 0)",
          "310:    return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "311:  case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:",
          "313:  case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "321:  case ASN1_OP_MATCH:",
          "322:  case ASN1_OP_MATCH_OR_SKIP:",
          "323:  case ASN1_OP_MATCH_ANY:",
          "324:  case ASN1_OP_COND_MATCH_OR_SKIP:",
          "325:  case ASN1_OP_COND_MATCH_ANY:",
          "326:  skip_data:",
          "327:   if (!(flags & FLAG_CONS)) {",
          "328:    if (flags & FLAG_INDEFINITE_LENGTH) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "330:  case ASN1_OP_MATCH_ANY_OR_SKIP:",
          "333:  case ASN1_OP_COND_MATCH_ANY_OR_SKIP:",
          "",
          "---------------"
        ],
        "scripts/asn1_compiler.c||scripts/asn1_compiler.c": [
          "File: scripts/asn1_compiler.c -> scripts/asn1_compiler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1401:  act = e->action ? \"_ACT\" : \"\";",
          "1402:  switch (e->compound) {",
          "1403:  case ANY:",
          "1405:   if (e->name)",
          "1406:    render_more(out, \"\\t\\t// %*.*s\",",
          "1407:         (int)e->name->size, (int)e->name->size,",
          "",
          "[Removed Lines]",
          "1404:   render_opcode(out, \"ASN1_OP_%sMATCH_ANY%s,\", cond, act);",
          "",
          "[Added Lines]",
          "1404:   render_opcode(out, \"ASN1_OP_%sMATCH_ANY%s%s,\",",
          "1405:          cond, act, skippable ? \"_OR_SKIP\" : \"\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4ebdb76f7da662346267384440492bb9d87c2aa3",
      "candidate_info": {
        "commit_hash": "4ebdb76f7da662346267384440492bb9d87c2aa3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4ebdb76f7da662346267384440492bb9d87c2aa3",
        "files": [
          "crypto/asymmetric_keys/pkcs7_verify.c",
          "include/crypto/pkcs7.h"
        ],
        "message": "PKCS#7: Allow detached data to be supplied for signature checking purposes\n\nIt is possible for a PKCS#7 message to have detached data.  However, to verify\nthe signatures on a PKCS#7 message, we have to be able to digest the data.\nProvide a function to supply that data.  An error is given if the PKCS#7\nmessage included embedded data.\n\nThis is used in a subsequent patch to supply the data to module signing where\nthe signature is in the form of a PKCS#7 message with detached data, whereby\nthe detached data is the module content that is signed.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Vivek Goyal <vgoyal@redhat.com>",
        "before_after_code_files": [
          "crypto/asymmetric_keys/pkcs7_verify.c||crypto/asymmetric_keys/pkcs7_verify.c",
          "include/crypto/pkcs7.h||include/crypto/pkcs7.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/asymmetric_keys/pkcs7_verify.c||crypto/asymmetric_keys/pkcs7_verify.c": [
          "File: crypto/asymmetric_keys/pkcs7_verify.c -> crypto/asymmetric_keys/pkcs7_verify.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "382:  return enopkg;",
          "383: }",
          "384: EXPORT_SYMBOL_GPL(pkcs7_verify);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "399: int pkcs7_supply_detached_data(struct pkcs7_message *pkcs7,",
          "400:           const void *data, size_t datalen)",
          "401: {",
          "402:  if (pkcs7->data) {",
          "403:   pr_debug(\"Data already supplied\\n\");",
          "404:   return -EINVAL;",
          "405:  }",
          "406:  pkcs7->data = data;",
          "407:  pkcs7->data_len = datalen;",
          "408:  return 0;",
          "409: }",
          "",
          "---------------"
        ],
        "include/crypto/pkcs7.h||include/crypto/pkcs7.h": [
          "File: include/crypto/pkcs7.h -> include/crypto/pkcs7.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: extern int pkcs7_verify(struct pkcs7_message *pkcs7);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: extern int pkcs7_supply_detached_data(struct pkcs7_message *pkcs7,",
          "39:           const void *data, size_t datalen);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ecf5fc6e9654cd7a268c782a523f072b2f1959f9",
      "candidate_info": {
        "commit_hash": "ecf5fc6e9654cd7a268c782a523f072b2f1959f9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ecf5fc6e9654cd7a268c782a523f072b2f1959f9",
        "files": [
          "mm/vmscan.c"
        ],
        "message": "mm, vmscan: Do not wait for page writeback for GFP_NOFS allocations\n\nNikolay has reported a hang when a memcg reclaim got stuck with the\nfollowing backtrace:\n\nPID: 18308  TASK: ffff883d7c9b0a30  CPU: 1   COMMAND: \"rsync\"\n  #0 __schedule at ffffffff815ab152\n  #1 schedule at ffffffff815ab76e\n  #2 schedule_timeout at ffffffff815ae5e5\n  #3 io_schedule_timeout at ffffffff815aad6a\n  #4 bit_wait_io at ffffffff815abfc6\n  #5 __wait_on_bit at ffffffff815abda5\n  #6 wait_on_page_bit at ffffffff8111fd4f\n  #7 shrink_page_list at ffffffff81135445\n  #8 shrink_inactive_list at ffffffff81135845\n  #9 shrink_lruvec at ffffffff81135ead\n #10 shrink_zone at ffffffff811360c3\n #11 shrink_zones at ffffffff81136eff\n #12 do_try_to_free_pages at ffffffff8113712f\n #13 try_to_free_mem_cgroup_pages at ffffffff811372be\n #14 try_charge at ffffffff81189423\n #15 mem_cgroup_try_charge at ffffffff8118c6f5\n #16 __add_to_page_cache_locked at ffffffff8112137d\n #17 add_to_page_cache_lru at ffffffff81121618\n #18 pagecache_get_page at ffffffff8112170b\n #19 grow_dev_page at ffffffff811c8297\n #20 __getblk_slow at ffffffff811c91d6\n #21 __getblk_gfp at ffffffff811c92c1\n #22 ext4_ext_grow_indepth at ffffffff8124565c\n #23 ext4_ext_create_new_leaf at ffffffff81246ca8\n #24 ext4_ext_insert_extent at ffffffff81246f09\n #25 ext4_ext_map_blocks at ffffffff8124a848\n #26 ext4_map_blocks at ffffffff8121a5b7\n #27 mpage_map_one_extent at ffffffff8121b1fa\n #28 mpage_map_and_submit_extent at ffffffff8121f07b\n #29 ext4_writepages at ffffffff8121f6d5\n #30 do_writepages at ffffffff8112c490\n #31 __filemap_fdatawrite_range at ffffffff81120199\n #32 filemap_flush at ffffffff8112041c\n #33 ext4_alloc_da_blocks at ffffffff81219da1\n #34 ext4_rename at ffffffff81229b91\n #35 ext4_rename2 at ffffffff81229e32\n #36 vfs_rename at ffffffff811a08a5\n #37 SYSC_renameat2 at ffffffff811a3ffc\n #38 sys_renameat2 at ffffffff811a408e\n #39 sys_rename at ffffffff8119e51e\n #40 system_call_fastpath at ffffffff815afa89\n\nDave Chinner has properly pointed out that this is a deadlock in the\nreclaim code because ext4 doesn't submit pages which are marked by\nPG_writeback right away.\n\nThe heuristic was introduced by commit e62e384e9da8 (\"memcg: prevent OOM\nwith too many dirty pages\") and it was applied only when may_enter_fs\nwas specified.  The code has been changed by c3b94f44fcb0 (\"memcg:\nfurther prevent OOM with too many dirty pages\") which has removed the\n__GFP_FS restriction with a reasoning that we do not get into the fs\ncode.  But this is not sufficient apparently because the fs doesn't\nnecessarily submit pages marked PG_writeback for IO right away.\n\next4_bio_write_page calls io_submit_add_bh but that doesn't necessarily\nsubmit the bio.  Instead it tries to map more pages into the bio and\nmpage_map_one_extent might trigger memcg charge which might end up\nwaiting on a page which is marked PG_writeback but hasn't been submitted\nyet so we would end up waiting for something that never finishes.\n\nFix this issue by replacing __GFP_IO by may_enter_fs check (for case 2)\nbefore we go to wait on the writeback.  The page fault path, which is\nthe only path that triggers memcg oom killer since 3.12, shouldn't\nrequire GFP_NOFS and so we shouldn't reintroduce the premature OOM\nkiller issue which was originally addressed by the heuristic.\n\nAs per David Chinner the xfs is doing similar thing since 2.6.15 already\nso ext4 is not the only affected filesystem.  Moreover he notes:\n\n: For example: IO completion might require unwritten extent conversion\n: which executes filesystem transactions and GFP_NOFS allocations. The\n: writeback flag on the pages can not be cleared until unwritten\n: extent conversion completes. Hence memory reclaim cannot wait on\n: page writeback to complete in GFP_NOFS context because it is not\n: safe to do so, memcg reclaim or otherwise.\n\nCc: stable@vger.kernel.org # 3.9+\n[tytso@mit.edu: corrected the control flow]\nFixes: c3b94f44fcb0 (\"memcg: further prevent OOM with too many dirty pages\")\nReported-by: Nikolay Borisov <kernel@kyup.com>\nSigned-off-by: Michal Hocko <mhocko@suse.cz>\nSigned-off-by: Hugh Dickins <hughd@google.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/vmscan.c||mm/vmscan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/vmscan.c||mm/vmscan.c": [
          "File: mm/vmscan.c -> mm/vmscan.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1007:    } else if (sane_reclaim(sc) ||",
          "",
          "[Removed Lines]",
          "1008:        !PageReclaim(page) || !(sc->gfp_mask & __GFP_IO)) {",
          "",
          "[Added Lines]",
          "1004:        !PageReclaim(page) || !may_enter_fs) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3f1e1bea34740069f70c6bc92d0f712345d5c28e",
      "candidate_info": {
        "commit_hash": "3f1e1bea34740069f70c6bc92d0f712345d5c28e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3f1e1bea34740069f70c6bc92d0f712345d5c28e",
        "files": [
          "Makefile",
          "init/Kconfig",
          "kernel/module_signing.c",
          "scripts/Makefile",
          "scripts/sign-file"
        ],
        "message": "MODSIGN: Use PKCS#7 messages as module signatures\n\nMove to using PKCS#7 messages as module signatures because:\n\n (1) We have to be able to support the use of X.509 certificates that don't\n     have a subjKeyId set.  We're currently relying on this to look up the\n     X.509 certificate in the trusted keyring list.\n\n (2) PKCS#7 message signed information blocks have a field that supplies the\n     data required to match with the X.509 certificate that signed it.\n\n (3) The PKCS#7 certificate carries fields that specify the digest algorithm\n     used to generate the signature in a standardised way and the X.509\n     certificates specify the public key algorithm in a standardised way - so\n     we don't need our own methods of specifying these.\n\n (4) We now have PKCS#7 message support in the kernel for signed kexec purposes\n     and we can make use of this.\n\nTo make this work, the old sign-file script has been replaced with a program\nthat needs compiling in a previous patch.  The rules to build it are added\nhere.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Vivek Goyal <vgoyal@redhat.com>",
        "before_after_code_files": [
          "kernel/module_signing.c||kernel/module_signing.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/module_signing.c||kernel/module_signing.c": [
          "File: kernel/module_signing.c -> kernel/module_signing.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <linux/kernel.h>",
          "13: #include <linux/err.h>",
          "17: #include <keys/system_keyring.h>",
          "18: #include \"module-internal.h\"",
          "",
          "[Removed Lines]",
          "14: #include <crypto/public_key.h>",
          "15: #include <crypto/hash.h>",
          "16: #include <keys/asymmetric-type.h>",
          "",
          "[Added Lines]",
          "15: #include <crypto/public_key.h>",
          "16: #include <crypto/pkcs7.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: struct module_signature {",
          "36:  u8 __pad[3];",
          "38: };",
          "46: {",
          "51:  int ret;",
          "82:  if (ret < 0)",
          "83:   goto error;",
          "86:  if (ret < 0)",
          "87:   goto error;",
          "93: error:",
          "97:  pr_devel(\"<==%s() = %d\\n\", __func__, ret);",
          "182: }",
          "",
          "[Removed Lines]",
          "43: static struct public_key_signature *mod_make_digest(enum hash_algo hash,",
          "44:           const void *mod,",
          "45:           unsigned long modlen)",
          "47:  struct public_key_signature *pks;",
          "48:  struct crypto_shash *tfm;",
          "49:  struct shash_desc *desc;",
          "50:  size_t digest_size, desc_size;",
          "53:  pr_devel(\"==>%s()\\n\", __func__);",
          "58:  tfm = crypto_alloc_shash(hash_algo_name[hash], 0, 0);",
          "59:  if (IS_ERR(tfm))",
          "60:   return (PTR_ERR(tfm) == -ENOENT) ? ERR_PTR(-ENOPKG) : ERR_CAST(tfm);",
          "62:  desc_size = crypto_shash_descsize(tfm) + sizeof(*desc);",
          "63:  digest_size = crypto_shash_digestsize(tfm);",
          "68:  ret = -ENOMEM;",
          "69:  pks = kzalloc(digest_size + sizeof(*pks) + desc_size, GFP_KERNEL);",
          "70:  if (!pks)",
          "71:   goto error_no_pks;",
          "73:  pks->pkey_hash_algo = hash;",
          "74:  pks->digest  = (u8 *)pks + sizeof(*pks) + desc_size;",
          "75:  pks->digest_size = digest_size;",
          "77:  desc = (void *)pks + sizeof(*pks);",
          "78:  desc->tfm   = tfm;",
          "79:  desc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;",
          "81:  ret = crypto_shash_init(desc);",
          "85:  ret = crypto_shash_finup(desc, mod, modlen, pks->digest);",
          "89:  crypto_free_shash(tfm);",
          "90:  pr_devel(\"<==%s() = ok\\n\", __func__);",
          "91:  return pks;",
          "94:  kfree(pks);",
          "95: error_no_pks:",
          "96:  crypto_free_shash(tfm);",
          "98:  return ERR_PTR(ret);",
          "99: }",
          "108: static int mod_extract_mpi_array(struct public_key_signature *pks,",
          "109:      const void *data, size_t len)",
          "110: {",
          "111:  size_t nbytes;",
          "112:  MPI mpi;",
          "114:  if (len < 3)",
          "115:   return -EBADMSG;",
          "116:  nbytes = ((const u8 *)data)[0] << 8 | ((const u8 *)data)[1];",
          "117:  data += 2;",
          "118:  len -= 2;",
          "119:  if (len != nbytes)",
          "120:   return -EBADMSG;",
          "122:  mpi = mpi_read_raw_data(data, nbytes);",
          "123:  if (!mpi)",
          "124:   return -ENOMEM;",
          "125:  pks->mpi[0] = mpi;",
          "126:  pks->nr_mpi = 1;",
          "127:  return 0;",
          "128: }",
          "133: static struct key *request_asymmetric_key(const char *signer, size_t signer_len,",
          "134:        const u8 *key_id, size_t key_id_len)",
          "135: {",
          "136:  key_ref_t key;",
          "137:  size_t i;",
          "138:  char *id, *q;",
          "140:  pr_devel(\"==>%s(,%zu,,%zu)\\n\", __func__, signer_len, key_id_len);",
          "143:  id = kmalloc(signer_len + 2 + key_id_len * 2 + 1, GFP_KERNEL);",
          "144:  if (!id)",
          "145:   return ERR_PTR(-ENOKEY);",
          "147:  memcpy(id, signer, signer_len);",
          "149:  q = id + signer_len;",
          "152:  for (i = 0; i < key_id_len; i++) {",
          "155:  }",
          "159:  pr_debug(\"Look up: \\\"%s\\\"\\n\", id);",
          "161:  key = keyring_search(make_key_ref(system_trusted_keyring, 1),",
          "162:         &key_type_asymmetric, id);",
          "163:  if (IS_ERR(key))",
          "164:   pr_warn(\"Request for unknown module key '%s' err %ld\\n\",",
          "165:    id, PTR_ERR(key));",
          "166:  kfree(id);",
          "168:  if (IS_ERR(key)) {",
          "169:   switch (PTR_ERR(key)) {",
          "171:   case -EACCES:",
          "172:   case -ENOTDIR:",
          "173:   case -EAGAIN:",
          "174:    return ERR_PTR(-ENOKEY);",
          "175:   default:",
          "176:    return ERR_CAST(key);",
          "177:   }",
          "178:  }",
          "180:  pr_devel(\"<==%s() = 0 [%x]\\n\", __func__, key_serial(key_ref_to_ptr(key)));",
          "181:  return key_ref_to_ptr(key);",
          "",
          "[Added Lines]",
          "42: static int mod_verify_pkcs7(const void *mod, unsigned long modlen,",
          "43:        const void *raw_pkcs7, size_t pkcs7_len)",
          "45:  struct pkcs7_message *pkcs7;",
          "46:  bool trusted;",
          "49:  pkcs7 = pkcs7_parse_message(raw_pkcs7, pkcs7_len);",
          "50:  if (IS_ERR(pkcs7))",
          "51:   return PTR_ERR(pkcs7);",
          "54:  if (pkcs7_supply_detached_data(pkcs7, mod, modlen) < 0) {",
          "55:   pr_err(\"PKCS#7 signature with non-detached data\\n\");",
          "56:   ret = -EBADMSG;",
          "57:   goto error;",
          "58:  }",
          "60:  ret = pkcs7_verify(pkcs7);",
          "64:  ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);",
          "68:  if (!trusted) {",
          "69:   pr_err(\"PKCS#7 signature not signed with a trusted key\\n\");",
          "70:   ret = -ENOKEY;",
          "71:  }",
          "74:  pkcs7_free_message(pkcs7);",
          "76:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "187: int mod_verify_sig(const void *mod, unsigned long *_modlen)",
          "188: {",
          "190:  struct module_signature ms;",
          "193:  size_t modlen = *_modlen, sig_len;",
          "196:  pr_devel(\"==>%s(,%zu)\\n\", __func__, modlen);",
          "",
          "[Removed Lines]",
          "189:  struct public_key_signature *pks;",
          "191:  struct key *key;",
          "192:  const void *sig;",
          "194:  int ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "205:  if (sig_len >= modlen)",
          "206:   return -EBADMSG;",
          "207:  modlen -= sig_len;",
          "222:   return -ENOPKG;",
          "233:  }",
          "250: }",
          "",
          "[Removed Lines]",
          "208:  if ((size_t)ms.signer_len + ms.key_id_len >= modlen)",
          "209:   return -EBADMSG;",
          "210:  modlen -= (size_t)ms.signer_len + ms.key_id_len;",
          "213:  sig = mod + modlen;",
          "216:  if (ms.algo != PKEY_ALGO_RSA ||",
          "217:      ms.id_type != PKEY_ID_X509)",
          "218:   return -ENOPKG;",
          "220:  if (ms.hash >= PKEY_HASH__LAST ||",
          "221:      !hash_algo_name[ms.hash])",
          "224:  key = request_asymmetric_key(sig, ms.signer_len,",
          "225:          sig + ms.signer_len, ms.key_id_len);",
          "226:  if (IS_ERR(key))",
          "227:   return PTR_ERR(key);",
          "229:  pks = mod_make_digest(ms.hash, mod, modlen);",
          "230:  if (IS_ERR(pks)) {",
          "231:   ret = PTR_ERR(pks);",
          "232:   goto error_put_key;",
          "235:  ret = mod_extract_mpi_array(pks, sig + ms.signer_len + ms.key_id_len,",
          "236:         sig_len);",
          "237:  if (ret < 0)",
          "238:   goto error_free_pks;",
          "240:  ret = verify_signature(key, pks);",
          "241:  pr_devel(\"verify_signature() = %d\\n\", ret);",
          "243: error_free_pks:",
          "244:  mpi_free(pks->rsa.s);",
          "245:  kfree(pks);",
          "246: error_put_key:",
          "247:  key_put(key);",
          "248:  pr_devel(\"<==%s() = %d\\n\", __func__, ret);",
          "249:  return ret;",
          "",
          "[Added Lines]",
          "101:  if (ms.id_type != PKEY_ID_PKCS7) {",
          "102:   pr_err(\"Module is not signed with expected PKCS#7 message\\n\");",
          "106:  if (ms.algo != 0 ||",
          "107:      ms.hash != 0 ||",
          "108:      ms.signer_len != 0 ||",
          "109:      ms.key_id_len != 0 ||",
          "110:      ms.__pad[0] != 0 ||",
          "111:      ms.__pad[1] != 0 ||",
          "112:      ms.__pad[2] != 0) {",
          "113:   pr_err(\"PKCS#7 signature info has unexpected non-zero params\\n\");",
          "114:   return -EBADMSG;",
          "115:  }",
          "117:  return mod_verify_pkcs7(mod, modlen, mod + modlen, sig_len);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
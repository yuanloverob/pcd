{
  "cve_id": "CVE-2013-0857",
  "cve_desc": "The decode_frame_ilbm function in libavcodec/iff.c in FFmpeg before 1.1 allows remote attackers to have an unspecified impact via a crafted height value in IFF PBM/ILBM bitmap data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "2fbb37b51bbea891392ad357baf8f3dff00bac05",
  "patch_info": {
    "commit_hash": "2fbb37b51bbea891392ad357baf8f3dff00bac05",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2fbb37b51bbea891392ad357baf8f3dff00bac05",
    "files": [
      "libavcodec/iff.c"
    ],
    "message": "iff/ilbm: check remaining buffer size.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/iff.c||libavcodec/iff.c"
    ]
  },
  "patch_diff": {
    "libavcodec/iff.c||libavcodec/iff.c": [
      "File: libavcodec/iff.c -> libavcodec/iff.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "575:         }",
      "576:     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
      "577:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
      "579:                 uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
      "580:                 memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
      "581:                 buf += avctx->width + (avctx->width % 2); // padding if odd",
      "582:             }",
      "583:         } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
      "585:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
      "586:                 memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
      "587:                 buf += avctx->width + (avctx->width & 1); // padding if odd",
      "",
      "[Removed Lines]",
      "578:             for(y = 0; y < avctx->height; y++ ) {",
      "584:             for (y = 0; y < avctx->height; y++) {",
      "",
      "[Added Lines]",
      "578:             for(y = 0; y < avctx->height && buf_end > buf; y++ ) {",
      "584:             for (y = 0; y < avctx->height && buf_end > buf; y++) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "112d4c400f0e0d5d1621fc8db515907cffaae259",
      "candidate_info": {
        "commit_hash": "112d4c400f0e0d5d1621fc8db515907cffaae259",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/112d4c400f0e0d5d1621fc8db515907cffaae259",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "iff/ilbm: check remaining buffer size.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 2fbb37b51bbea891392ad357baf8f3dff00bac05)\n\nConflicts:\n\n\tlibavcodec/iff.c",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "562:         }",
          "563:     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "564:         if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {",
          "566:                 uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "567:                 memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
          "568:                 buf += avctx->width + (avctx->width % 2); // padding if odd",
          "569:             }",
          "570:         } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32",
          "572:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "573:                 memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
          "574:                 buf += avctx->width + (avctx->width & 1); // padding if odd",
          "",
          "[Removed Lines]",
          "565:             for(y = 0; y < avctx->height; y++ ) {",
          "571:             for (y = 0; y < avctx->height; y++) {",
          "",
          "[Added Lines]",
          "565:             for(y = 0; y < avctx->height && buf_end > buf; y++ ) {",
          "571:             for (y = 0; y < avctx->height && buf_end > buf; y++) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "929a24efff9a208a52748605eb412ffb915c1403",
      "candidate_info": {
        "commit_hash": "929a24efff9a208a52748605eb412ffb915c1403",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/929a24efff9a208a52748605eb412ffb915c1403",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "iff decoder: merge iff ilbm and byterun1 decoders\n\nSigned-off-by: Peter Ross <pross@xvid.org>\nReviewed-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "479:     return buf - buf_start;",
          "480: }",
          "483:                             void *data, int *data_size,",
          "484:                             AVPacket *avpkt)",
          "485: {",
          "",
          "[Removed Lines]",
          "482: static int decode_frame_ilbm(AVCodecContext *avctx,",
          "",
          "[Added Lines]",
          "491: static void decode_deep_rle32(uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)",
          "492: {",
          "493:     const uint8_t *src_end = src + src_size;",
          "494:     int x = 0, y = 0, i;",
          "495:     while (src + 5 <= src_end) {",
          "496:         int opcode;",
          "497:         opcode = *(int8_t *)src++;",
          "498:         if (opcode >= 0) {",
          "499:             int size = opcode + 1;",
          "500:             for (i = 0; i < size; i++) {",
          "501:                 int length = FFMIN(size - i, width);",
          "502:                 memcpy(dst + y*linesize + x * 4, src, length * 4);",
          "503:                 src += length * 4;",
          "504:                 x += length;",
          "505:                 i += length;",
          "506:                 if (x >= width) {",
          "507:                     x = 0;",
          "508:                     y += 1;",
          "509:                     if (y >= height)",
          "510:                         return;",
          "511:                 }",
          "512:             }",
          "513:         } else {",
          "514:             int size = -opcode + 1;",
          "515:             uint32_t pixel = AV_RL32(src);",
          "516:             for (i = 0; i < size; i++) {",
          "518:                 x += 1;",
          "519:                 if (x >= width) {",
          "520:                     x = 0;",
          "521:                     y += 1;",
          "522:                     if (y >= height)",
          "523:                         return;",
          "524:                 }",
          "525:             }",
          "526:             src += 4;",
          "527:         }",
          "528:     }",
          "529: }",
          "531: static int unsupported(AVCodecContext *avctx)",
          "532: {",
          "533:     IffContext *s = avctx->priv_data;",
          "534:     av_log_ask_for_sample(avctx, \"unsupported bitmap (compression %i, bpp %i, ham %i)\\n\", s->compression, s->bpp, s->ham);",
          "535:     return AVERROR_INVALIDDATA;",
          "536: }",
          "538: static int decode_frame(AVCodecContext *avctx,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "503:     } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt == AV_PIX_FMT_PAL8) {",
          "504:         if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)",
          "505:             return res;",
          "506:     }",
          "507:     s->init = 1;",
          "509:     if (avctx->codec_tag == MKTAG('A','C','B','M')) {",
          "510:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "511:             memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "561:     } else if (avctx->pix_fmt == AV_PIX_FMT_RGB32 && avctx->bits_per_coded_sample <= 8) {",
          "562:         if ((res = ff_cmap_read_palette(avctx, s->mask_palbuf)) < 0)",
          "563:             return res;",
          "567:     switch (s->compression) {",
          "568:     case 0:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "529:                 }",
          "530:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "531:             }",
          "533:     } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {",
          "534:         const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "535:         int raw_width = avctx->width * (av_get_bits_per_pixel(desc) >> 3);",
          "",
          "[Removed Lines]",
          "532:         }",
          "",
          "[Added Lines]",
          "592:         } else",
          "593:             return unsupported(avctx);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "587:                 buf += avctx->width + (avctx->width & 1); // padding if odd",
          "588:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "589:             }",
          "647:     }",
          "679:     if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved",
          "680:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "681:             for(y = 0; y < avctx->height ; y++ ) {",
          "",
          "[Removed Lines]",
          "590:         } else {",
          "591:             av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");",
          "592:             return AVERROR_INVALIDDATA;",
          "593:         }",
          "594:     }",
          "598:     return buf_size;",
          "599: }",
          "610: static void decode_deep_rle32(uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)",
          "611: {",
          "612:     const uint8_t *src_end = src + src_size;",
          "613:     int x = 0, y = 0, i;",
          "614:     while (src + 5 <= src_end) {",
          "615:         int opcode;",
          "616:         opcode = *(int8_t *)src++;",
          "617:         if (opcode >= 0) {",
          "618:             int size = opcode + 1;",
          "619:             for (i = 0; i < size; i++) {",
          "620:                 int length = FFMIN(size - i, width);",
          "621:                 memcpy(dst + y*linesize + x * 4, src, length * 4);",
          "622:                 src += length * 4;",
          "623:                 x += length;",
          "624:                 i += length;",
          "625:                 if (x >= width) {",
          "626:                     x = 0;",
          "627:                     y += 1;",
          "628:                     if (y >= height)",
          "629:                         return;",
          "630:                 }",
          "631:             }",
          "632:         } else {",
          "633:             int size = -opcode + 1;",
          "634:             uint32_t pixel = AV_RL32(src);",
          "635:             for (i = 0; i < size; i++) {",
          "637:                 x += 1;",
          "638:                 if (x >= width) {",
          "639:                     x = 0;",
          "640:                     y += 1;",
          "641:                     if (y >= height)",
          "642:                         return;",
          "643:                 }",
          "644:             }",
          "645:             src += 4;",
          "646:         }",
          "648: }",
          "650: static int decode_frame_byterun1(AVCodecContext *avctx,",
          "651:                             void *data, int *data_size,",
          "652:                             AVPacket *avpkt)",
          "653: {",
          "654:     IffContext *s = avctx->priv_data;",
          "655:     const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;",
          "656:     const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;",
          "657:     const uint8_t *buf_end = buf+buf_size;",
          "658:     int y, plane, res;",
          "660:     if ((res = extract_header(avctx, avpkt)) < 0)",
          "661:         return res;",
          "662:     if (s->init) {",
          "663:         if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {",
          "664:             av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");",
          "665:             return res;",
          "666:         }",
          "667:     } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {",
          "668:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "669:         return res;",
          "670:     } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {",
          "671:         if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)",
          "672:             return res;",
          "673:     } else if (avctx->pix_fmt == AV_PIX_FMT_RGB32 && avctx->bits_per_coded_sample <= 8) {",
          "674:         if ((res = ff_cmap_read_palette(avctx, s->mask_palbuf)) < 0)",
          "675:             return res;",
          "676:     }",
          "677:     s->init = 1;",
          "",
          "[Added Lines]",
          "651:         } else",
          "652:             return unsupported(avctx);",
          "654:     break;",
          "655:     case 1:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "728:                 buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);",
          "729:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "730:             }",
          "735:     } else if (avctx->codec_tag == MKTAG('D','E','E','P')) { // IFF-DEEP",
          "736:         const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "737:         if (av_get_bits_per_pixel(desc) == 32)",
          "738:             decode_deep_rle32(s->frame.data[0], buf, buf_size, avctx->width, avctx->height, s->frame.linesize[0]);",
          "743:     }",
          "",
          "[Removed Lines]",
          "731:         } else {",
          "732:             av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");",
          "733:             return AVERROR_INVALIDDATA;",
          "734:         }",
          "739:         else {",
          "740:             av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");",
          "741:             return AVERROR_INVALIDDATA;",
          "742:         }",
          "",
          "[Added Lines]",
          "708:         } else",
          "709:             return unsupported(avctx);",
          "714:         else",
          "715:             return unsupported(avctx);",
          "716:     }",
          "717:         break;",
          "718:     default:",
          "719:         return unsupported(avctx);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "761: #if CONFIG_IFF_ILBM_DECODER",
          "762: AVCodec ff_iff_ilbm_decoder = {",
          "764:     .type           = AVMEDIA_TYPE_VIDEO,",
          "765:     .id             = AV_CODEC_ID_IFF_ILBM,",
          "766:     .priv_data_size = sizeof(IffContext),",
          "767:     .init           = decode_init,",
          "768:     .close          = decode_end,",
          "770:     .capabilities   = CODEC_CAP_DR1,",
          "772: };",
          "773: #endif",
          "774: #if CONFIG_IFF_BYTERUN1_DECODER",
          "775: AVCodec ff_iff_byterun1_decoder = {",
          "777:     .type           = AVMEDIA_TYPE_VIDEO,",
          "778:     .id             = AV_CODEC_ID_IFF_BYTERUN1,",
          "779:     .priv_data_size = sizeof(IffContext),",
          "780:     .init           = decode_init,",
          "781:     .close          = decode_end,",
          "783:     .capabilities   = CODEC_CAP_DR1,",
          "785: };",
          "786: #endif",
          "",
          "[Removed Lines]",
          "763:     .name           = \"iff_ilbm\",",
          "769:     .decode         = decode_frame_ilbm,",
          "771:     .long_name      = NULL_IF_CONFIG_SMALL(\"IFF ILBM\"),",
          "776:     .name           = \"iff_byterun1\",",
          "782:     .decode         = decode_frame_byterun1,",
          "784:     .long_name      = NULL_IF_CONFIG_SMALL(\"IFF ByteRun1\"),",
          "",
          "[Added Lines]",
          "740:     .name           = \"iff\",",
          "746:     .decode         = decode_frame,",
          "748:     .long_name      = NULL_IF_CONFIG_SMALL(\"IFF\"),",
          "753:     .name           = \"iff\",",
          "759:     .decode         = decode_frame,",
          "761:     .long_name      = NULL_IF_CONFIG_SMALL(\"IFF\"),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ed27ed9f4f72564f3653ac230cf57697de77f804",
      "candidate_info": {
        "commit_hash": "ed27ed9f4f72564f3653ac230cf57697de77f804",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/ed27ed9f4f72564f3653ac230cf57697de77f804",
        "files": [
          "libavcodec/iff.c",
          "libavformat/iff.c"
        ],
        "message": "iff: DEEP RLE 32-bit decoder\n\nFixes ticket #1046.\n\nSigned-off-by: Peter Ross <pross@xvid.org>",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c",
          "libavformat/iff.c||libavformat/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "598:     return buf_size;",
          "599: }",
          "601: static int decode_frame_byterun1(AVCodecContext *avctx,",
          "602:                             void *data, int *data_size,",
          "603:                             AVPacket *avpkt)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "610: static void decode_deep_rle32(uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)",
          "611: {",
          "612:     const uint8_t *src_end = src + src_size;",
          "613:     int x = 0, y = 0, i;",
          "614:     while (src + 5 <= src_end) {",
          "615:         int opcode;",
          "616:         opcode = *(int8_t *)src++;",
          "617:         if (opcode >= 0) {",
          "618:             int size = opcode + 1;",
          "619:             for (i = 0; i < size; i++) {",
          "620:                 int length = FFMIN(size - i, width);",
          "621:                 memcpy(dst + y*linesize + x * 4, src, length * 4);",
          "622:                 src += length * 4;",
          "623:                 x += length;",
          "624:                 i += length;",
          "625:                 if (x >= width) {",
          "626:                     x = 0;",
          "627:                     y += 1;",
          "628:                     if (y >= height)",
          "629:                         return;",
          "630:                 }",
          "631:             }",
          "632:         } else {",
          "633:             int size = -opcode + 1;",
          "634:             uint32_t pixel = AV_RL32(src);",
          "635:             for (i = 0; i < size; i++) {",
          "637:                 x += 1;",
          "638:                 if (x >= width) {",
          "639:                     x = 0;",
          "640:                     y += 1;",
          "641:                     if (y >= height)",
          "642:                         return;",
          "643:                 }",
          "644:             }",
          "645:             src += 4;",
          "646:         }",
          "647:     }",
          "648: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "683:             av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");",
          "684:             return AVERROR_INVALIDDATA;",
          "685:         }",
          "686:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "735:     } else if (avctx->codec_tag == MKTAG('D','E','E','P')) { // IFF-DEEP",
          "736:         const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "737:         if (av_get_bits_per_pixel(desc) == 32)",
          "738:             decode_deep_rle32(s->frame.data[0], buf, buf_size, avctx->width, avctx->height, s->frame.linesize[0]);",
          "739:         else {",
          "740:             av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");",
          "741:             return AVERROR_INVALIDDATA;",
          "742:         }",
          "",
          "---------------"
        ],
        "libavformat/iff.c||libavformat/iff.c": [
          "File: libavformat/iff.c -> libavformat/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:             st->codec->width                 = avio_rb16(pb);",
          "273:             st->codec->height                = avio_rb16(pb);",
          "274:             iff->bitmap_compression          = avio_rb16(pb);",
          "276:                 av_log(s, AV_LOG_ERROR,",
          "277:                        \"compression %i not supported\\n\", iff->bitmap_compression);",
          "278:                 return AVERROR_PATCHWELCOME;",
          "",
          "[Removed Lines]",
          "275:             if (iff->bitmap_compression != 0) {",
          "",
          "[Added Lines]",
          "275:             if (iff->bitmap_compression > 1) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dda713f8707ee291670092fe808552246bade728",
      "candidate_info": {
        "commit_hash": "dda713f8707ee291670092fe808552246bade728",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/dda713f8707ee291670092fe808552246bade728",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "iff: Fix decode_ham_plane32() buf_size.\n\nThe wrong variable was passed into decode_ham_plane32()\nFixes: Ticket922\n\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "544:             uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "545:             memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
          "546:             buf += avctx->width + (avctx->width & 1); // padding if odd",
          "548:         }",
          "549:     }",
          "",
          "[Removed Lines]",
          "547:             decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);",
          "",
          "[Added Lines]",
          "547:             decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "631:         for (y = 0; y < avctx->height ; y++) {",
          "632:             uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "633:             buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);",
          "635:         }",
          "636:     }",
          "",
          "[Removed Lines]",
          "634:             decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);",
          "",
          "[Added Lines]",
          "634:             decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "86b6e49d921b0debca9be66732fd61ac43f7b08d",
      "candidate_info": {
        "commit_hash": "86b6e49d921b0debca9be66732fd61ac43f7b08d",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/86b6e49d921b0debca9be66732fd61ac43f7b08d",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "iff: check for pbm tag\n\nmore robust\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "541:                 }",
          "542:             }",
          "543:         }",
          "556:         }",
          "557:     }",
          "",
          "[Removed Lines]",
          "544:     } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM",
          "545:         for(y = 0; y < avctx->height; y++ ) {",
          "546:             uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "547:             memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
          "548:             buf += avctx->width + (avctx->width % 2); // padding if odd",
          "549:         }",
          "550:     } else { // IFF-PBM: HAM to PIX_FMT_BGR32",
          "551:         for (y = 0; y < avctx->height; y++) {",
          "552:             uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "553:             memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
          "554:             buf += avctx->width + (avctx->width & 1); // padding if odd",
          "555:             decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "",
          "[Added Lines]",
          "544:     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "545:         if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {",
          "546:             for(y = 0; y < avctx->height; y++ ) {",
          "547:                 uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "548:                 memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
          "549:                 buf += avctx->width + (avctx->width % 2); // padding if odd",
          "550:             }",
          "551:         } else { // IFF-PBM: HAM to PIX_FMT_BGR32",
          "552:             for (y = 0; y < avctx->height; y++) {",
          "553:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "554:                 memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
          "555:                 buf += avctx->width + (avctx->width & 1); // padding if odd",
          "556:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "557:             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "630:                 }",
          "631:             }",
          "632:         }",
          "643:         }",
          "644:     }",
          "",
          "[Removed Lines]",
          "633:     } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM",
          "634:         for(y = 0; y < avctx->height ; y++ ) {",
          "635:             uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "636:             buf += decode_byterun(row, avctx->width, buf, buf_end);",
          "637:         }",
          "638:     } else { // IFF-PBM: HAM to PIX_FMT_BGR32",
          "639:         for (y = 0; y < avctx->height ; y++) {",
          "640:             uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "641:             buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);",
          "642:             decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "",
          "[Added Lines]",
          "635:     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "636:         if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {",
          "637:             for(y = 0; y < avctx->height ; y++ ) {",
          "638:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "639:                 buf += decode_byterun(row, avctx->width, buf, buf_end);",
          "640:             }",
          "641:         } else { // IFF-PBM: HAM to PIX_FMT_BGR32",
          "642:             for (y = 0; y < avctx->height ; y++) {",
          "643:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "644:                 buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);",
          "645:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "646:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-32675",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. When parsing an incoming Redis Standard Protocol (RESP) request, Redis allocates memory according to user-specified values which determine the number of elements (in the multi-bulk header) and size of each element (in the bulk header). An attacker delivering specially crafted requests over multiple connections can cause the server to allocate significant amount of memory. Because the same parsing mechanism is used to handle authentication requests, this vulnerability can also be exploited by unauthenticated users. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate this problem without patching the redis-server executable is to block access to prevent unauthenticated users from connecting to Redis. This can be done in different ways: Using network access control tools like firewalls, iptables, security groups, etc. or Enabling TLS and requiring users to authenticate using client side certificates.",
  "repo": "redis/redis",
  "patch_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
  "patch_info": {
    "commit_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
    "files": [
      "src/networking.c",
      "src/server.c",
      "src/server.h",
      "tests/unit/auth.tcl"
    ],
    "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
    "before_after_code_files": [
      "src/networking.c||src/networking.c",
      "src/server.c||src/server.c",
      "src/server.h||src/server.h",
      "tests/unit/auth.tcl||tests/unit/auth.tcl"
    ]
  },
  "patch_diff": {
    "src/networking.c||src/networking.c": [
      "File: src/networking.c -> src/networking.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "97:     raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);",
      "98: }",
      "100: client *createClient(connection *conn) {",
      "101:     client *c = zmalloc(sizeof(client));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "100: int authRequired(client *c) {",
      "103:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
      "104:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
      "105:                         !c->authenticated;",
      "106:     return auth_required;",
      "107: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1744:             addReplyError(c,\"Protocol error: invalid multibulk length\");",
      "1745:             setProtocolError(\"invalid mbulk count\",c);",
      "1746:             return C_ERR;",
      "1747:         }",
      "1749:         c->qb_pos = (newline-c->querybuf)+2;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1756:         } else if (ll > 10 && authRequired(c)) {",
      "1757:             addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
      "1758:             setProtocolError(\"unauth mbulk count\", c);",
      "1759:             return C_ERR;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1791:                 addReplyError(c,\"Protocol error: invalid bulk length\");",
      "1792:                 setProtocolError(\"invalid bulk length\",c);",
      "1793:                 return C_ERR;",
      "1794:             }",
      "1796:             c->qb_pos = newline-c->querybuf+2;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1807:             } else if (ll > 16384 && authRequired(c)) {",
      "1808:                 addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
      "1809:                 setProtocolError(\"unauth bulk length\", c);",
      "1810:                 return C_ERR;",
      "",
      "---------------"
    ],
    "src/server.c||src/server.c": [
      "File: src/server.c -> src/server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3590:     int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||",
      "3591:                                  (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));",
      "3601:         if (!(c->cmd->flags & CMD_NO_AUTH)) {",
      "3602:             rejectCommand(c,shared.noautherr);",
      "",
      "[Removed Lines]",
      "3595:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
      "3596:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
      "3597:                         !c->authenticated;",
      "3598:     if (auth_required) {",
      "",
      "[Added Lines]",
      "3593:     if (authRequired(c)) {",
      "",
      "---------------"
    ],
    "src/server.h||src/server.h": [
      "File: src/server.h -> src/server.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1743: void unprotectClient(client *c);",
      "1744: void initThreadedIO(void);",
      "1745: client *lookupClientByID(uint64_t id);",
      "1747: #ifdef __GNUC__",
      "1748: void addReplyErrorFormat(client *c, const char *fmt, ...)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1746: int authRequired(client *c);",
      "",
      "---------------"
    ],
    "tests/unit/auth.tcl||tests/unit/auth.tcl": [
      "File: tests/unit/auth.tcl -> tests/unit/auth.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "24:         r set foo 100",
      "25:         r incr foo",
      "26:     } {101}",
      "27: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "28:     test {For unauthenticated clients multibulk and bulk length are limited} {",
      "29:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
      "30:         $rr write \"*100\\r\\n\"",
      "31:         $rr flush",
      "32:         catch {[$rr read]} e",
      "33:         assert_match {*unauthenticated multibulk length*} $e",
      "34:         $rr close",
      "36:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
      "37:         $rr write \"*1\\r\\n\\$100000000\\r\\n\"",
      "38:         $rr flush",
      "39:         catch {[$rr read]} e",
      "40:         assert_match {*unauthenticated bulk length*} $e",
      "41:         $rr close",
      "42:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
      "candidate_info": {
        "commit_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
        "files": [
          "src/intset.c",
          "src/rdb.c",
          "src/t_set.c"
        ],
        "message": "Fix Integer overflow issue with intsets (CVE-2021-32687)\n\nThe vulnerability involves changing the default set-max-intset-entries\nconfiguration parameter to a very large value and constructing specially\ncrafted commands to manipulate sets",
        "before_after_code_files": [
          "src/intset.c||src/intset.c",
          "src/rdb.c||src/rdb.c",
          "src/t_set.c||src/t_set.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/intset.c||src/intset.c": [
          "File: src/intset.c -> src/intset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"intset.h\"",
          "35: #include \"zmalloc.h\"",
          "36: #include \"endianconv.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"redisassert.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105: static intset *intsetResize(intset *is, uint32_t len) {",
          "107:     is = zrealloc(is,sizeof(intset)+size);",
          "108:     return is;",
          "109: }",
          "",
          "[Removed Lines]",
          "106:     uint32_t size = len*intrev32ifbe(is->encoding);",
          "",
          "[Added Lines]",
          "107:     uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);",
          "108:     assert(size <= SIZE_MAX - sizeof(intset));",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1518:         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "1522:             o = createSetObject();",
          "",
          "[Removed Lines]",
          "1521:         if (len > server.set_max_intset_entries) {",
          "",
          "[Added Lines]",
          "1521:         size_t max_entries = server.set_max_intset_entries;",
          "1522:         if (max_entries >= 1<<30) max_entries = 1<<30;",
          "1523:         if (len > max_entries) {",
          "",
          "---------------"
        ],
        "src/t_set.c||src/t_set.c": [
          "File: src/t_set.c -> src/t_set.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:             if (success) {",
          "70:                     setTypeConvert(subject,OBJ_ENCODING_HT);",
          "71:                 return 1;",
          "72:             }",
          "",
          "[Removed Lines]",
          "69:                 if (intsetLen(subject->ptr) > server.set_max_intset_entries)",
          "",
          "[Added Lines]",
          "69:                 size_t max_entries = server.set_max_intset_entries;",
          "71:                 if (max_entries >= 1<<30) max_entries = 1<<30;",
          "72:                 if (intsetLen(subject->ptr) > max_entries)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bb7597f46ee7798531e236a20f41729d5a056050",
      "candidate_info": {
        "commit_hash": "bb7597f46ee7798531e236a20f41729d5a056050",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/bb7597f46ee7798531e236a20f41729d5a056050",
        "files": [
          "deps/hiredis/hiredis.c",
          "deps/hiredis/test.c"
        ],
        "message": "Fix redis-cli / redis-sential overflow on some platforms (CVE-2021-32762)\n\nThe redis-cli command line tool and redis-sentinel service may be vulnerable\nto integer overflow when parsing specially crafted large multi-bulk network\nreplies. This is a result of a vulnerability in the underlying hiredis\nlibrary which does not perform an overflow check before calling the calloc()\nheap allocation function.\n\nThis issue only impacts systems with heap allocators that do not perform their\nown overflow checks. Most modern systems do and are therefore not likely to\nbe affected. Furthermore, by default redis-sentinel uses the jemalloc allocator\nwhich is also not vulnerable.",
        "before_after_code_files": [
          "deps/hiredis/hiredis.c||deps/hiredis/hiredis.c",
          "deps/hiredis/test.c||deps/hiredis/test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/hiredis/hiredis.c||deps/hiredis/hiredis.c": [
          "File: deps/hiredis/hiredis.c -> deps/hiredis/hiredis.c"
        ],
        "deps/hiredis/test.c||deps/hiredis/test.c": [
          "File: deps/hiredis/test.c -> deps/hiredis/test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "400:     freeReplyObject(reply);",
          "401:     redisReaderFree(reader);",
          "403: #if LLONG_MAX > SIZE_MAX",
          "404:     test(\"Set error when array > SIZE_MAX: \");",
          "405:     reader = redisReaderCreate();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "403:     test(\"Multi-bulk never overflows regardless of maxelements: \");",
          "404:     size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;",
          "405:     char bad_mbulk_reply[100];",
          "406:     snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",",
          "407:         (unsigned long long) bad_mbulk_len);",
          "409:     reader = redisReaderCreate();",
          "411:     redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));",
          "412:     ret = redisReaderGetReply(reader,&reply);",
          "413:     test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\") == 0);",
          "414:     freeReplyObject(reply);",
          "415:     redisReaderFree(reader);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71be97294abf3657710a044157ebbc8a21489da3",
      "candidate_info": {
        "commit_hash": "71be97294abf3657710a044157ebbc8a21489da3",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/71be97294abf3657710a044157ebbc8a21489da3",
        "files": [
          "src/networking.c",
          "tests/unit/auth.tcl"
        ],
        "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)\n\n(cherry picked from commit 3d221e81f3b680543e34942579af190b049ff283)",
        "before_after_code_files": [
          "src/networking.c||src/networking.c",
          "tests/unit/auth.tcl||tests/unit/auth.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/networking.c||src/networking.c",
            "tests/unit/auth.tcl||tests/unit/auth.tcl"
          ],
          "candidate": [
            "src/networking.c||src/networking.c",
            "tests/unit/auth.tcl||tests/unit/auth.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/networking.c||src/networking.c": [
          "File: src/networking.c -> src/networking.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1309:             addReplyError(c,\"Protocol error: invalid multibulk length\");",
          "1310:             setProtocolError(\"invalid mbulk count\",c);",
          "1311:             return C_ERR;",
          "1312:         }",
          "1314:         c->qb_pos = (newline-c->querybuf)+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1312:         } else if (ll > 10 && server.requirepass && !c->authenticated) {",
          "1313:             addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
          "1314:             setProtocolError(\"unauth mbulk count\", c);",
          "1315:             return C_ERR;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1354:                 addReplyError(c,\"Protocol error: invalid bulk length\");",
          "1355:                 setProtocolError(\"invalid bulk length\",c);",
          "1356:                 return C_ERR;",
          "1357:             }",
          "1359:             c->qb_pos = newline-c->querybuf+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1361:             } else if (ll > 16384 && server.requirepass && !c->authenticated) {",
          "1362:                 addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
          "1363:                 setProtocolError(\"unauth bulk length\", c);",
          "1364:                 return C_ERR;",
          "",
          "---------------"
        ],
        "tests/unit/auth.tcl||tests/unit/auth.tcl": [
          "File: tests/unit/auth.tcl -> tests/unit/auth.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:         r set foo 100",
          "25:         r incr foo",
          "26:     } {101}",
          "27: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:     test {For unauthenticated clients multibulk and bulk length are limited} {",
          "29:         set rr [redis [srv \"host\"] [srv \"port\"] 0]",
          "30:         $rr write \"*100\\r\\n\"",
          "31:         $rr flush",
          "32:         catch {[$rr read]} e",
          "33:         assert_match {*unauthenticated multibulk length*} $e",
          "34:         $rr close",
          "36:         set rr [redis [srv \"host\"] [srv \"port\"] 0]",
          "37:         $rr write \"*1\\r\\n\\$100000000\\r\\n\"",
          "38:         $rr flush",
          "39:         catch {[$rr read]} e",
          "40:         assert_match {*unauthenticated bulk length*} $e",
          "41:         $rr close",
          "42:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "757f8f771eaa6ed5bf3dcae8fe1ece3fa0de2746",
      "candidate_info": {
        "commit_hash": "757f8f771eaa6ed5bf3dcae8fe1ece3fa0de2746",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/757f8f771eaa6ed5bf3dcae8fe1ece3fa0de2746",
        "files": [
          "src/networking.c",
          "src/server.c",
          "src/server.h",
          "tests/unit/auth.tcl"
        ],
        "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
        "before_after_code_files": [
          "src/networking.c||src/networking.c",
          "src/server.c||src/server.c",
          "src/server.h||src/server.h",
          "tests/unit/auth.tcl||tests/unit/auth.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/networking.c||src/networking.c",
            "src/server.c||src/server.c",
            "src/server.h||src/server.h",
            "tests/unit/auth.tcl||tests/unit/auth.tcl"
          ],
          "candidate": [
            "src/networking.c||src/networking.c",
            "src/server.c||src/server.c",
            "src/server.h||src/server.h",
            "tests/unit/auth.tcl||tests/unit/auth.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/networking.c||src/networking.c": [
          "File: src/networking.c -> src/networking.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:                        !(c->user->flags & USER_FLAG_DISABLED);",
          "108: }",
          "110: client *createClient(connection *conn) {",
          "111:     client *c = zmalloc(sizeof(client));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110: int authRequired(client *c) {",
          "113:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "114:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "115:                         !c->authenticated;",
          "116:     return auth_required;",
          "117: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1860:             addReplyError(c,\"Protocol error: invalid multibulk length\");",
          "1861:             setProtocolError(\"invalid mbulk count\",c);",
          "1862:             return C_ERR;",
          "1863:         }",
          "1865:         c->qb_pos = (newline-c->querybuf)+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1872:         } else if (ll > 10 && authRequired(c)) {",
          "1873:             addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
          "1874:             setProtocolError(\"unauth mbulk count\", c);",
          "1875:             return C_ERR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1907:                 addReplyError(c,\"Protocol error: invalid bulk length\");",
          "1908:                 setProtocolError(\"invalid bulk length\",c);",
          "1909:                 return C_ERR;",
          "1910:             }",
          "1912:             c->qb_pos = newline-c->querybuf+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1923:             } else if (ll > 16384 && authRequired(c)) {",
          "1924:                 addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
          "1925:                 setProtocolError(\"unauth bulk length\", c);",
          "1926:                 return C_ERR;",
          "",
          "---------------"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4001:     int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||",
          "4002:                                    (c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));",
          "4012:         if (!(c->cmd->flags & CMD_NO_AUTH)) {",
          "4013:             rejectCommand(c,shared.noautherr);",
          "",
          "[Removed Lines]",
          "4006:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "4007:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "4008:                         !c->authenticated;",
          "4009:     if (auth_required) {",
          "",
          "[Added Lines]",
          "4004:     if (authRequired(c)) {",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1897: void unprotectClient(client *c);",
          "1898: void initThreadedIO(void);",
          "1899: client *lookupClientByID(uint64_t id);",
          "1901: #ifdef __GNUC__",
          "1902: void addReplyErrorFormat(client *c, const char *fmt, ...)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1900: int authRequired(client *c);",
          "",
          "---------------"
        ],
        "tests/unit/auth.tcl||tests/unit/auth.tcl": [
          "File: tests/unit/auth.tcl -> tests/unit/auth.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:         r set foo 100",
          "25:         r incr foo",
          "26:     } {101}",
          "27: }",
          "29: start_server {tags {\"auth_binary_password\"}} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:     test {For unauthenticated clients multibulk and bulk length are limited} {",
          "29:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "30:         $rr write \"*100\\r\\n\"",
          "31:         $rr flush",
          "32:         catch {[$rr read]} e",
          "33:         assert_match {*unauthenticated multibulk length*} $e",
          "34:         $rr close",
          "36:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "37:         $rr write \"*1\\r\\n\\$100000000\\r\\n\"",
          "38:         $rr flush",
          "39:         catch {[$rr read]} e",
          "40:         assert_match {*unauthenticated bulk length*} $e",
          "41:         $rr close",
          "42:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fba15850e5c31666e4c3560a3be7fd034fa7e2b6",
      "candidate_info": {
        "commit_hash": "fba15850e5c31666e4c3560a3be7fd034fa7e2b6",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/fba15850e5c31666e4c3560a3be7fd034fa7e2b6",
        "files": [
          "src/networking.c",
          "src/server.c",
          "src/server.h",
          "tests/unit/auth.tcl"
        ],
        "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675) (#9588)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
        "before_after_code_files": [
          "src/networking.c||src/networking.c",
          "src/server.c||src/server.c",
          "src/server.h||src/server.h",
          "tests/unit/auth.tcl||tests/unit/auth.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/networking.c||src/networking.c",
            "src/server.c||src/server.c",
            "src/server.h||src/server.h",
            "tests/unit/auth.tcl||tests/unit/auth.tcl"
          ],
          "candidate": [
            "src/networking.c||src/networking.c",
            "src/server.c||src/server.c",
            "src/server.h||src/server.h",
            "tests/unit/auth.tcl||tests/unit/auth.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/networking.c||src/networking.c": [
          "File: src/networking.c -> src/networking.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:                        !(c->user->flags & USER_FLAG_DISABLED);",
          "108: }",
          "110: client *createClient(connection *conn) {",
          "111:     client *c = zmalloc(sizeof(client));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110: int authRequired(client *c) {",
          "113:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "114:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "115:                         !c->authenticated;",
          "116:     return auth_required;",
          "117: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1913:             addReplyError(c,\"Protocol error: invalid multibulk length\");",
          "1914:             setProtocolError(\"invalid mbulk count\",c);",
          "1915:             return C_ERR;",
          "1916:         }",
          "1918:         c->qb_pos = (newline-c->querybuf)+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1925:         } else if (ll > 10 && authRequired(c)) {",
          "1926:             addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
          "1927:             setProtocolError(\"unauth mbulk count\", c);",
          "1928:             return C_ERR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1961:                 addReplyError(c,\"Protocol error: invalid bulk length\");",
          "1962:                 setProtocolError(\"invalid bulk length\",c);",
          "1963:                 return C_ERR;",
          "1964:             }",
          "1966:             c->qb_pos = newline-c->querybuf+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1977:             } else if (ll > 16384 && authRequired(c)) {",
          "1978:                 addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
          "1979:                 setProtocolError(\"unauth bulk length\", c);",
          "1980:                 return C_ERR;",
          "",
          "---------------"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4623:     int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||",
          "4624:                                    (c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));",
          "4634:         if (!(c->cmd->flags & CMD_NO_AUTH)) {",
          "4635:             rejectCommand(c,shared.noautherr);",
          "",
          "[Removed Lines]",
          "4628:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "4629:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "4630:                         !c->authenticated;",
          "4631:     if (auth_required) {",
          "",
          "[Added Lines]",
          "4626:     if (authRequired(c)) {",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2091: void unprotectClient(client *c);",
          "2092: void initThreadedIO(void);",
          "2093: client *lookupClientByID(uint64_t id);",
          "2095: #ifdef __GNUC__",
          "2096: void addReplyErrorFormat(client *c, const char *fmt, ...)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2094: int authRequired(client *c);",
          "",
          "---------------"
        ],
        "tests/unit/auth.tcl||tests/unit/auth.tcl": [
          "File: tests/unit/auth.tcl -> tests/unit/auth.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:         r set foo 100",
          "25:         r incr foo",
          "26:     } {101}",
          "27: }",
          "29: start_server {tags {\"auth_binary_password external:skip\"}} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:     test {For unauthenticated clients multibulk and bulk length are limited} {",
          "29:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "30:         $rr write \"*100\\r\\n\"",
          "31:         $rr flush",
          "32:         catch {[$rr read]} e",
          "33:         assert_match {*unauthenticated multibulk length*} $e",
          "34:         $rr close",
          "36:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "37:         $rr write \"*1\\r\\n\\$100000000\\r\\n\"",
          "38:         $rr flush",
          "39:         catch {[$rr read]} e",
          "40:         assert_match {*unauthenticated bulk length*} $e",
          "41:         $rr close",
          "42:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
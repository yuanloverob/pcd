{
  "cve_id": "CVE-2016-7097",
  "cve_desc": "The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",
  "repo": "torvalds/linux",
  "patch_hash": "073931017b49d9458aa351605b43a7e34598caef",
  "patch_info": {
    "commit_hash": "073931017b49d9458aa351605b43a7e34598caef",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef",
    "files": [
      "fs/9p/acl.c",
      "fs/btrfs/acl.c",
      "fs/ceph/acl.c",
      "fs/ext2/acl.c",
      "fs/ext4/acl.c",
      "fs/f2fs/acl.c",
      "fs/gfs2/acl.c",
      "fs/hfsplus/posix_acl.c",
      "fs/jffs2/acl.c",
      "fs/jfs/acl.c",
      "fs/ocfs2/acl.c",
      "fs/orangefs/acl.c",
      "fs/posix_acl.c",
      "fs/reiserfs/xattr_acl.c",
      "fs/xfs/xfs_acl.c",
      "include/linux/posix_acl.h"
    ],
    "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>",
    "before_after_code_files": [
      "fs/9p/acl.c||fs/9p/acl.c",
      "fs/btrfs/acl.c||fs/btrfs/acl.c",
      "fs/ceph/acl.c||fs/ceph/acl.c",
      "fs/ext2/acl.c||fs/ext2/acl.c",
      "fs/ext4/acl.c||fs/ext4/acl.c",
      "fs/f2fs/acl.c||fs/f2fs/acl.c",
      "fs/gfs2/acl.c||fs/gfs2/acl.c",
      "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c",
      "fs/jffs2/acl.c||fs/jffs2/acl.c",
      "fs/jfs/acl.c||fs/jfs/acl.c",
      "fs/ocfs2/acl.c||fs/ocfs2/acl.c",
      "fs/orangefs/acl.c||fs/orangefs/acl.c",
      "fs/posix_acl.c||fs/posix_acl.c",
      "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c",
      "fs/xfs/xfs_acl.c||fs/xfs/xfs_acl.c",
      "include/linux/posix_acl.h||include/linux/posix_acl.h"
    ]
  },
  "patch_diff": {
    "fs/9p/acl.c||fs/9p/acl.c": [
      "File: fs/9p/acl.c -> fs/9p/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "276:  switch (handler->flags) {",
      "277:  case ACL_TYPE_ACCESS:",
      "278:   if (acl) {",
      "282:     goto err_out;",
      "304:    }",
      "305:   }",
      "306:   break;",
      "307:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "279:    umode_t mode = inode->i_mode;",
      "280:    retval = posix_acl_equiv_mode(acl, &mode);",
      "281:    if (retval < 0)",
      "283:    else {",
      "284:     struct iattr iattr;",
      "285:     if (retval == 0) {",
      "291:      acl = NULL;",
      "292:      value = NULL;",
      "293:      size = 0;",
      "294:     }",
      "296:     iattr.ia_mode = ((mode & S_IALLUGO) |",
      "297:        (inode->i_mode & ~S_IALLUGO));",
      "298:     iattr.ia_valid = ATTR_MODE;",
      "303:     v9fs_vfs_setattr_dotl(dentry, &iattr);",
      "",
      "[Added Lines]",
      "279:    struct iattr iattr;",
      "281:    retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);",
      "282:    if (retval)",
      "284:    if (!acl) {",
      "290:     value = NULL;",
      "291:     size = 0;",
      "293:    iattr.ia_valid = ATTR_MODE;",
      "298:    v9fs_vfs_setattr_dotl(dentry, &iattr);",
      "",
      "---------------"
    ],
    "fs/btrfs/acl.c||fs/btrfs/acl.c": [
      "File: fs/btrfs/acl.c -> fs/btrfs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:  case ACL_TYPE_ACCESS:",
      "80:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "81:   if (acl) {",
      "84:     return ret;",
      "87:   }",
      "88:   ret = 0;",
      "89:   break;",
      "",
      "[Removed Lines]",
      "82:    ret = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "83:    if (ret < 0)",
      "85:    if (ret == 0)",
      "86:     acl = NULL;",
      "",
      "[Added Lines]",
      "82:    ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "83:    if (ret)",
      "",
      "---------------"
    ],
    "fs/ceph/acl.c||fs/ceph/acl.c": [
      "File: fs/ceph/acl.c -> fs/ceph/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "95:  case ACL_TYPE_ACCESS:",
      "96:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "97:   if (acl) {",
      "100:     goto out;",
      "103:   }",
      "104:   break;",
      "105:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "98:    ret = posix_acl_equiv_mode(acl, &new_mode);",
      "99:    if (ret < 0)",
      "101:    if (ret == 0)",
      "102:     acl = NULL;",
      "",
      "[Added Lines]",
      "98:    ret = posix_acl_update_mode(inode, &new_mode, &acl);",
      "99:    if (ret)",
      "",
      "---------------"
    ],
    "fs/ext2/acl.c||fs/ext2/acl.c": [
      "File: fs/ext2/acl.c -> fs/ext2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "190:   case ACL_TYPE_ACCESS:",
      "191:    name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "192:    if (acl) {",
      "195:      return error;",
      "202:    }",
      "203:    break;",
      "",
      "[Removed Lines]",
      "193:     error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "194:     if (error < 0)",
      "196:     else {",
      "197:      inode->i_ctime = CURRENT_TIME_SEC;",
      "198:      mark_inode_dirty(inode);",
      "199:      if (error == 0)",
      "200:       acl = NULL;",
      "201:     }",
      "",
      "[Added Lines]",
      "193:     error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "194:     if (error)",
      "196:     inode->i_ctime = CURRENT_TIME_SEC;",
      "197:     mark_inode_dirty(inode);",
      "",
      "---------------"
    ],
    "fs/ext4/acl.c||fs/ext4/acl.c": [
      "File: fs/ext4/acl.c -> fs/ext4/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "193:  case ACL_TYPE_ACCESS:",
      "194:   name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "195:   if (acl) {",
      "198:     return error;",
      "205:   }",
      "206:   break;",
      "",
      "[Removed Lines]",
      "196:    error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "197:    if (error < 0)",
      "199:    else {",
      "200:     inode->i_ctime = ext4_current_time(inode);",
      "201:     ext4_mark_inode_dirty(handle, inode);",
      "202:     if (error == 0)",
      "203:      acl = NULL;",
      "204:    }",
      "",
      "[Added Lines]",
      "196:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "197:    if (error)",
      "199:    inode->i_ctime = ext4_current_time(inode);",
      "200:    ext4_mark_inode_dirty(handle, inode);",
      "",
      "---------------"
    ],
    "fs/f2fs/acl.c||fs/f2fs/acl.c": [
      "File: fs/f2fs/acl.c -> fs/f2fs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "210:  case ACL_TYPE_ACCESS:",
      "211:   name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "212:   if (acl) {",
      "215:     return error;",
      "216:    set_acl_inode(inode, inode->i_mode);",
      "219:   }",
      "220:   break;",
      "",
      "[Removed Lines]",
      "213:    error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "214:    if (error < 0)",
      "217:    if (error == 0)",
      "218:     acl = NULL;",
      "",
      "[Added Lines]",
      "213:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "214:    if (error)",
      "",
      "---------------"
    ],
    "fs/gfs2/acl.c||fs/gfs2/acl.c": [
      "File: fs/gfs2/acl.c -> fs/gfs2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "92:  if (type == ACL_TYPE_ACCESS) {",
      "93:   umode_t mode = inode->i_mode;",
      "97:    return error;",
      "104:    mark_inode_dirty(inode);",
      "106:  }",
      "108:  if (acl) {",
      "",
      "[Removed Lines]",
      "95:   error = posix_acl_equiv_mode(acl, &mode);",
      "96:   if (error < 0)",
      "99:   if (error == 0)",
      "100:    acl = NULL;",
      "102:   if (mode != inode->i_mode) {",
      "103:    inode->i_mode = mode;",
      "105:   }",
      "",
      "[Added Lines]",
      "95:   error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "96:   if (error)",
      "98:   if (mode != inode->i_mode)",
      "",
      "---------------"
    ],
    "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c": [
      "File: fs/hfsplus/posix_acl.c -> fs/hfsplus/posix_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "65:  case ACL_TYPE_ACCESS:",
      "66:   xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "67:   if (acl) {",
      "70:     return err;",
      "71:   }",
      "72:   err = 0;",
      "",
      "[Removed Lines]",
      "68:    err = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "69:    if (err < 0)",
      "",
      "[Added Lines]",
      "68:    err = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "69:    if (err)",
      "",
      "---------------"
    ],
    "fs/jffs2/acl.c||fs/jffs2/acl.c": [
      "File: fs/jffs2/acl.c -> fs/jffs2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "233:  case ACL_TYPE_ACCESS:",
      "234:   xprefix = JFFS2_XPREFIX_ACL_ACCESS;",
      "235:   if (acl) {",
      "239:     return rc;",
      "240:    if (inode->i_mode != mode) {",
      "241:     struct iattr attr;",
      "",
      "[Removed Lines]",
      "236:    umode_t mode = inode->i_mode;",
      "237:    rc = posix_acl_equiv_mode(acl, &mode);",
      "238:    if (rc < 0)",
      "",
      "[Added Lines]",
      "236:    umode_t mode;",
      "238:    rc = posix_acl_update_mode(inode, &mode, &acl);",
      "239:    if (rc)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "247:     if (rc < 0)",
      "248:      return rc;",
      "249:    }",
      "252:   }",
      "253:   break;",
      "254:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "250:    if (rc == 0)",
      "251:     acl = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/jfs/acl.c||fs/jfs/acl.c": [
      "File: fs/jfs/acl.c -> fs/jfs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "78:  case ACL_TYPE_ACCESS:",
      "79:   ea_name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "80:   if (acl) {",
      "83:     return rc;",
      "84:    inode->i_ctime = CURRENT_TIME;",
      "85:    mark_inode_dirty(inode);",
      "88:   }",
      "89:   break;",
      "90:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "81:    rc = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "82:    if (rc < 0)",
      "86:    if (rc == 0)",
      "87:     acl = NULL;",
      "",
      "[Added Lines]",
      "81:    rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "82:    if (rc)",
      "",
      "---------------"
    ],
    "fs/ocfs2/acl.c||fs/ocfs2/acl.c": [
      "File: fs/ocfs2/acl.c -> fs/ocfs2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "241:  case ACL_TYPE_ACCESS:",
      "242:   name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "243:   if (acl) {",
      "252:    ret = ocfs2_acl_set_mode(inode, di_bh,",
      "253:        handle, mode);",
      "",
      "[Removed Lines]",
      "244:    umode_t mode = inode->i_mode;",
      "245:    ret = posix_acl_equiv_mode(acl, &mode);",
      "246:    if (ret < 0)",
      "247:     return ret;",
      "249:    if (ret == 0)",
      "250:     acl = NULL;",
      "",
      "[Added Lines]",
      "244:    umode_t mode;",
      "246:    ret = posix_acl_update_mode(inode, &mode, &acl);",
      "247:    if (ret)",
      "248:     return ret;",
      "",
      "---------------"
    ],
    "fs/orangefs/acl.c||fs/orangefs/acl.c": [
      "File: fs/orangefs/acl.c -> fs/orangefs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "73:  case ACL_TYPE_ACCESS:",
      "74:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "75:   if (acl) {",
      "84:         __func__,",
      "85:         error);",
      "86:     return error;",
      "",
      "[Removed Lines]",
      "76:    umode_t mode = inode->i_mode;",
      "81:    error = posix_acl_equiv_mode(acl, &mode);",
      "82:    if (error < 0) {",
      "83:     gossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",",
      "",
      "[Added Lines]",
      "76:    umode_t mode;",
      "78:    error = posix_acl_update_mode(inode, &mode, &acl);",
      "79:    if (error) {",
      "80:     gossip_err(\"%s: posix_acl_update_mode err: %d\\n\",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "90:     SetModeFlag(orangefs_inode);",
      "91:    inode->i_mode = mode;",
      "92:    mark_inode_dirty_sync(inode);",
      "95:   }",
      "96:   break;",
      "97:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "93:    if (error == 0)",
      "94:     acl = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/posix_acl.c||fs/posix_acl.c": [
      "File: fs/posix_acl.c -> fs/posix_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "626: }",
      "627: EXPORT_SYMBOL_GPL(posix_acl_create);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "641: int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,",
      "642:      struct posix_acl **acl)",
      "643: {",
      "644:  umode_t mode = inode->i_mode;",
      "645:  int error;",
      "647:  error = posix_acl_equiv_mode(*acl, &mode);",
      "648:  if (error < 0)",
      "649:   return error;",
      "650:  if (error == 0)",
      "652:  if (!in_group_p(inode->i_gid) &&",
      "653:      !capable_wrt_inode_uidgid(inode, CAP_FSETID))",
      "654:   mode &= ~S_ISGID;",
      "656:  return 0;",
      "657: }",
      "658: EXPORT_SYMBOL(posix_acl_update_mode);",
      "",
      "---------------"
    ],
    "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c": [
      "File: fs/reiserfs/xattr_acl.c -> fs/reiserfs/xattr_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "242:  case ACL_TYPE_ACCESS:",
      "243:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "244:   if (acl) {",
      "247:     return error;",
      "252:   }",
      "253:   break;",
      "254:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "245:    error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "246:    if (error < 0)",
      "248:    else {",
      "249:     if (error == 0)",
      "250:      acl = NULL;",
      "251:    }",
      "",
      "[Added Lines]",
      "245:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "246:    if (error)",
      "",
      "---------------"
    ],
    "fs/xfs/xfs_acl.c||fs/xfs/xfs_acl.c": [
      "File: fs/xfs/xfs_acl.c -> fs/xfs/xfs_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "257:   return error;",
      "259:  if (type == ACL_TYPE_ACCESS) {",
      "270:   error = xfs_set_mode(inode, mode);",
      "271:   if (error)",
      "272:    return error;",
      "",
      "[Removed Lines]",
      "260:   umode_t mode = inode->i_mode;",
      "261:   error = posix_acl_equiv_mode(acl, &mode);",
      "263:   if (error <= 0) {",
      "264:    acl = NULL;",
      "266:    if (error < 0)",
      "267:     return error;",
      "268:   }",
      "",
      "[Added Lines]",
      "260:   umode_t mode;",
      "262:   error = posix_acl_update_mode(inode, &mode, &acl);",
      "263:   if (error)",
      "264:    return error;",
      "",
      "---------------"
    ],
    "include/linux/posix_acl.h||include/linux/posix_acl.h": [
      "File: include/linux/posix_acl.h -> include/linux/posix_acl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "93: extern int posix_acl_chmod(struct inode *, umode_t);",
      "94: extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,",
      "95:   struct posix_acl **);",
      "97: extern int simple_set_acl(struct inode *, struct posix_acl *, int);",
      "98: extern int simple_acl_create(struct inode *, struct inode *);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "96: extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "97d79299223baab330b194437e676d301f12d5f6",
      "candidate_info": {
        "commit_hash": "97d79299223baab330b194437e676d301f12d5f6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/97d79299223baab330b194437e676d301f12d5f6",
        "files": [
          "drivers/staging/lustre/lustre/llite/xattr.c",
          "fs/9p/acl.c",
          "fs/btrfs/acl.c",
          "fs/btrfs/inode.c",
          "fs/ceph/acl.c",
          "fs/cifs/xattr.c",
          "fs/gfs2/acl.c",
          "fs/gfs2/acl.h",
          "fs/hfsplus/posix_acl.c",
          "fs/jfs/acl.c",
          "fs/nfs/nfs3acl.c",
          "fs/posix_acl.c",
          "fs/reiserfs/xattr_acl.c",
          "fs/xfs/xfs_xattr.c",
          "include/linux/posix_acl_xattr.h"
        ],
        "message": "posix acls: Remove duplicate xattr name definitions\n\nRemove POSIX_ACL_XATTR_{ACCESS,DEFAULT} and GFS2_POSIX_ACL_{ACCESS,DEFAULT}\nand replace them with the definitions in <include/uapi/linux/xattr.h>.\n\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>\nReviewed-by: James Morris <james.l.morris@oracle.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "drivers/staging/lustre/lustre/llite/xattr.c||drivers/staging/lustre/lustre/llite/xattr.c",
          "fs/9p/acl.c||fs/9p/acl.c",
          "fs/btrfs/acl.c||fs/btrfs/acl.c",
          "fs/btrfs/inode.c||fs/btrfs/inode.c",
          "fs/ceph/acl.c||fs/ceph/acl.c",
          "fs/cifs/xattr.c||fs/cifs/xattr.c",
          "fs/gfs2/acl.c||fs/gfs2/acl.c",
          "fs/gfs2/acl.h||fs/gfs2/acl.h",
          "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c",
          "fs/jfs/acl.c||fs/jfs/acl.c",
          "fs/nfs/nfs3acl.c||fs/nfs/nfs3acl.c",
          "fs/posix_acl.c||fs/posix_acl.c",
          "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c",
          "fs/xfs/xfs_xattr.c||fs/xfs/xfs_xattr.c",
          "include/linux/posix_acl_xattr.h||include/linux/posix_acl_xattr.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/9p/acl.c||fs/9p/acl.c",
            "fs/btrfs/acl.c||fs/btrfs/acl.c",
            "fs/ceph/acl.c||fs/ceph/acl.c",
            "fs/gfs2/acl.c||fs/gfs2/acl.c",
            "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c",
            "fs/jfs/acl.c||fs/jfs/acl.c",
            "fs/posix_acl.c||fs/posix_acl.c",
            "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c"
          ],
          "candidate": [
            "fs/9p/acl.c||fs/9p/acl.c",
            "fs/btrfs/acl.c||fs/btrfs/acl.c",
            "fs/ceph/acl.c||fs/ceph/acl.c",
            "fs/gfs2/acl.c||fs/gfs2/acl.c",
            "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c",
            "fs/jfs/acl.c||fs/jfs/acl.c",
            "fs/posix_acl.c||fs/posix_acl.c",
            "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/staging/lustre/lustre/llite/xattr.c||drivers/staging/lustre/lustre/llite/xattr.c": [
          "File: drivers/staging/lustre/lustre/llite/xattr.c -> drivers/staging/lustre/lustre/llite/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60: static",
          "61: int get_xattr_type(const char *name)",
          "62: {",
          "64:   return XATTR_ACL_ACCESS_T;",
          "67:   return XATTR_ACL_DEFAULT_T;",
          "69:  if (!strncmp(name, XATTR_USER_PREFIX,",
          "",
          "[Removed Lines]",
          "63:  if (!strcmp(name, POSIX_ACL_XATTR_ACCESS))",
          "66:  if (!strcmp(name, POSIX_ACL_XATTR_DEFAULT))",
          "",
          "[Added Lines]",
          "63:  if (!strcmp(name, XATTR_NAME_POSIX_ACL_ACCESS))",
          "66:  if (!strcmp(name, XATTR_NAME_POSIX_ACL_DEFAULT))",
          "",
          "---------------"
        ],
        "fs/9p/acl.c||fs/9p/acl.c": [
          "File: fs/9p/acl.c -> fs/9p/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:   return 0;",
          "68:  }",
          "73:  if (!IS_ERR(dacl) && !IS_ERR(pacl)) {",
          "74:   set_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);",
          "",
          "[Removed Lines]",
          "70:  dacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);",
          "71:  pacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);",
          "",
          "[Added Lines]",
          "70:  dacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_DEFAULT);",
          "71:  pacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_ACCESS);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133:   goto err_free_out;",
          "134:  switch (type) {",
          "135:  case ACL_TYPE_ACCESS:",
          "137:   break;",
          "138:  case ACL_TYPE_DEFAULT:",
          "140:   break;",
          "141:  default:",
          "142:   BUG();",
          "",
          "[Removed Lines]",
          "136:   name = POSIX_ACL_XATTR_ACCESS;",
          "139:   name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "136:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "139:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "328: }",
          "330: const struct xattr_handler v9fs_xattr_acl_access_handler = {",
          "332:  .flags = ACL_TYPE_ACCESS,",
          "333:  .get = v9fs_xattr_get_acl,",
          "334:  .set = v9fs_xattr_set_acl,",
          "335: };",
          "337: const struct xattr_handler v9fs_xattr_acl_default_handler = {",
          "339:  .flags = ACL_TYPE_DEFAULT,",
          "340:  .get = v9fs_xattr_get_acl,",
          "341:  .set = v9fs_xattr_set_acl,",
          "",
          "[Removed Lines]",
          "331:  .prefix = POSIX_ACL_XATTR_ACCESS,",
          "338:  .prefix = POSIX_ACL_XATTR_DEFAULT,",
          "",
          "[Added Lines]",
          "331:  .prefix = XATTR_NAME_POSIX_ACL_ACCESS,",
          "338:  .prefix = XATTR_NAME_POSIX_ACL_DEFAULT,",
          "",
          "---------------"
        ],
        "fs/btrfs/acl.c||fs/btrfs/acl.c": [
          "File: fs/btrfs/acl.c -> fs/btrfs/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:  switch (type) {",
          "39:  case ACL_TYPE_ACCESS:",
          "41:   break;",
          "42:  case ACL_TYPE_DEFAULT:",
          "44:   break;",
          "45:  default:",
          "46:   BUG();",
          "",
          "[Removed Lines]",
          "40:   name = POSIX_ACL_XATTR_ACCESS;",
          "43:   name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "40:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "43:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82:  switch (type) {",
          "83:  case ACL_TYPE_ACCESS:",
          "85:   if (acl) {",
          "86:    ret = posix_acl_equiv_mode(acl, &inode->i_mode);",
          "87:    if (ret < 0)",
          "",
          "[Removed Lines]",
          "84:   name = POSIX_ACL_XATTR_ACCESS;",
          "",
          "[Added Lines]",
          "84:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:  case ACL_TYPE_DEFAULT:",
          "95:   if (!S_ISDIR(inode->i_mode))",
          "96:    return acl ? -EINVAL : 0;",
          "98:   break;",
          "99:  default:",
          "100:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "97:   name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "97:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------"
        ],
        "fs/btrfs/inode.c||fs/btrfs/inode.c": [
          "File: fs/btrfs/inode.c -> fs/btrfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3550:  int scanned = 0;",
          "3552:  if (!xattr_access) {",
          "3557:  }",
          "3559:  slot++;",
          "",
          "[Removed Lines]",
          "3553:   xattr_access = btrfs_name_hash(POSIX_ACL_XATTR_ACCESS,",
          "3554:      strlen(POSIX_ACL_XATTR_ACCESS));",
          "3555:   xattr_default = btrfs_name_hash(POSIX_ACL_XATTR_DEFAULT,",
          "3556:      strlen(POSIX_ACL_XATTR_DEFAULT));",
          "",
          "[Added Lines]",
          "3553:   xattr_access = btrfs_name_hash(XATTR_NAME_POSIX_ACL_ACCESS,",
          "3554:      strlen(XATTR_NAME_POSIX_ACL_ACCESS));",
          "3555:   xattr_default = btrfs_name_hash(XATTR_NAME_POSIX_ACL_DEFAULT,",
          "3556:      strlen(XATTR_NAME_POSIX_ACL_DEFAULT));",
          "",
          "---------------"
        ],
        "fs/ceph/acl.c||fs/ceph/acl.c": [
          "File: fs/ceph/acl.c -> fs/ceph/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:  switch (type) {",
          "51:  case ACL_TYPE_ACCESS:",
          "53:   break;",
          "54:  case ACL_TYPE_DEFAULT:",
          "56:   break;",
          "57:  default:",
          "58:   BUG();",
          "",
          "[Removed Lines]",
          "52:   name = POSIX_ACL_XATTR_ACCESS;",
          "55:   name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "52:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "55:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:  switch (type) {",
          "94:  case ACL_TYPE_ACCESS:",
          "96:   if (acl) {",
          "97:    ret = posix_acl_equiv_mode(acl, &new_mode);",
          "98:    if (ret < 0)",
          "",
          "[Removed Lines]",
          "95:   name = POSIX_ACL_XATTR_ACCESS;",
          "",
          "[Added Lines]",
          "95:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "106:    ret = acl ? -EINVAL : 0;",
          "107:    goto out;",
          "108:   }",
          "110:   break;",
          "111:  default:",
          "112:   ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "109:   name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "109:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "202:  ceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);",
          "204:  if (acl) {",
          "206:   err = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);",
          "207:   if (err)",
          "208:    goto out_err;",
          "210:          len);",
          "211:   err = posix_acl_to_xattr(&init_user_ns, acl,",
          "212:       tmp_buf, val_size1);",
          "",
          "[Removed Lines]",
          "205:   size_t len = strlen(POSIX_ACL_XATTR_ACCESS);",
          "209:   ceph_pagelist_encode_string(pagelist, POSIX_ACL_XATTR_ACCESS,",
          "",
          "[Added Lines]",
          "205:   size_t len = strlen(XATTR_NAME_POSIX_ACL_ACCESS);",
          "209:   ceph_pagelist_encode_string(pagelist, XATTR_NAME_POSIX_ACL_ACCESS,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "216:   ceph_pagelist_append(pagelist, tmp_buf, val_size1);",
          "217:  }",
          "218:  if (default_acl) {",
          "220:   err = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);",
          "221:   if (err)",
          "222:    goto out_err;",
          "223:   err = ceph_pagelist_encode_string(pagelist,",
          "225:   err = posix_acl_to_xattr(&init_user_ns, default_acl,",
          "226:       tmp_buf, val_size2);",
          "227:   if (err < 0)",
          "",
          "[Removed Lines]",
          "219:   size_t len = strlen(POSIX_ACL_XATTR_DEFAULT);",
          "224:         POSIX_ACL_XATTR_DEFAULT, len);",
          "",
          "[Added Lines]",
          "219:   size_t len = strlen(XATTR_NAME_POSIX_ACL_DEFAULT);",
          "224:         XATTR_NAME_POSIX_ACL_DEFAULT, len);",
          "",
          "---------------"
        ],
        "fs/cifs/xattr.c||fs/cifs/xattr.c": [
          "File: fs/cifs/xattr.c -> fs/cifs/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:  } else {",
          "192:   int temp;",
          "195:   if (temp == 0) {",
          "196: #ifdef CONFIG_CIFS_POSIX",
          "197:    if (sb->s_flags & MS_POSIXACL)",
          "",
          "[Removed Lines]",
          "193:   temp = strncmp(ea_name, POSIX_ACL_XATTR_ACCESS,",
          "194:    strlen(POSIX_ACL_XATTR_ACCESS));",
          "",
          "[Added Lines]",
          "193:   temp = strncmp(ea_name, XATTR_NAME_POSIX_ACL_ACCESS,",
          "194:    strlen(XATTR_NAME_POSIX_ACL_ACCESS));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "203: #else",
          "204:    cifs_dbg(FYI, \"set POSIX ACL not supported\\n\");",
          "205: #endif",
          "208: #ifdef CONFIG_CIFS_POSIX",
          "209:    if (sb->s_flags & MS_POSIXACL)",
          "210:     rc = CIFSSMBSetPosixACL(xid, pTcon, full_path,",
          "",
          "[Removed Lines]",
          "206:   } else if (strncmp(ea_name, POSIX_ACL_XATTR_DEFAULT,",
          "207:        strlen(POSIX_ACL_XATTR_DEFAULT)) == 0) {",
          "",
          "[Added Lines]",
          "206:   } else if (strncmp(ea_name, XATTR_NAME_POSIX_ACL_DEFAULT,",
          "207:        strlen(XATTR_NAME_POSIX_ACL_DEFAULT)) == 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "292:    rc = pTcon->ses->server->ops->query_all_EAs(xid, pTcon,",
          "293:     full_path, ea_name, ea_value, buf_size,",
          "294:     cifs_sb->local_nls, cifs_remap(cifs_sb));",
          "297: #ifdef CONFIG_CIFS_POSIX",
          "298:   if (sb->s_flags & MS_POSIXACL)",
          "299:    rc = CIFSSMBGetPosixACL(xid, pTcon, full_path,",
          "",
          "[Removed Lines]",
          "295:  } else if (strncmp(ea_name, POSIX_ACL_XATTR_ACCESS,",
          "296:      strlen(POSIX_ACL_XATTR_ACCESS)) == 0) {",
          "",
          "[Added Lines]",
          "295:  } else if (strncmp(ea_name, XATTR_NAME_POSIX_ACL_ACCESS,",
          "296:      strlen(XATTR_NAME_POSIX_ACL_ACCESS)) == 0) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "303: #else",
          "304:   cifs_dbg(FYI, \"Query POSIX ACL not supported yet\\n\");",
          "308: #ifdef CONFIG_CIFS_POSIX",
          "309:   if (sb->s_flags & MS_POSIXACL)",
          "310:    rc = CIFSSMBGetPosixACL(xid, pTcon, full_path,",
          "",
          "[Removed Lines]",
          "306:  } else if (strncmp(ea_name, POSIX_ACL_XATTR_DEFAULT,",
          "307:      strlen(POSIX_ACL_XATTR_DEFAULT)) == 0) {",
          "",
          "[Added Lines]",
          "306:  } else if (strncmp(ea_name, XATTR_NAME_POSIX_ACL_DEFAULT,",
          "307:      strlen(XATTR_NAME_POSIX_ACL_DEFAULT)) == 0) {",
          "",
          "---------------"
        ],
        "fs/gfs2/acl.c||fs/gfs2/acl.c": [
          "File: fs/gfs2/acl.c -> fs/gfs2/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: {",
          "32:  switch (type) {",
          "33:  case ACL_TYPE_ACCESS:",
          "35:  case ACL_TYPE_DEFAULT:",
          "37:  }",
          "38:  return NULL;",
          "39: }",
          "",
          "[Removed Lines]",
          "34:   return GFS2_POSIX_ACL_ACCESS;",
          "36:   return GFS2_POSIX_ACL_DEFAULT;",
          "",
          "[Added Lines]",
          "34:   return XATTR_POSIX_ACL_ACCESS;",
          "36:   return XATTR_POSIX_ACL_DEFAULT;",
          "",
          "---------------"
        ],
        "fs/gfs2/acl.h||fs/gfs2/acl.h": [
          "File: fs/gfs2/acl.h -> fs/gfs2/acl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include \"incore.h\"",
          "17: #define GFS2_ACL_MAX_ENTRIES(sdp) ((300 << (sdp)->sd_sb.sb_bsize_shift) >> 12)",
          "19: extern struct posix_acl *gfs2_get_acl(struct inode *inode, int type);",
          "",
          "[Removed Lines]",
          "15: #define GFS2_POSIX_ACL_ACCESS  \"posix_acl_access\"",
          "16: #define GFS2_POSIX_ACL_DEFAULT  \"posix_acl_default\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c": [
          "File: fs/hfsplus/posix_acl.c -> fs/hfsplus/posix_acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:  switch (type) {",
          "23:  case ACL_TYPE_ACCESS:",
          "25:   break;",
          "26:  case ACL_TYPE_DEFAULT:",
          "28:   break;",
          "29:  default:",
          "30:   return ERR_PTR(-EINVAL);",
          "",
          "[Removed Lines]",
          "24:   xattr_name = POSIX_ACL_XATTR_ACCESS;",
          "27:   xattr_name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "24:   xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "27:   xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:  switch (type) {",
          "68:  case ACL_TYPE_ACCESS:",
          "70:   if (acl) {",
          "71:    err = posix_acl_equiv_mode(acl, &inode->i_mode);",
          "72:    if (err < 0)",
          "",
          "[Removed Lines]",
          "69:   xattr_name = POSIX_ACL_XATTR_ACCESS;",
          "",
          "[Added Lines]",
          "69:   xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76:   break;",
          "78:  case ACL_TYPE_DEFAULT:",
          "80:   if (!S_ISDIR(inode->i_mode))",
          "81:    return acl ? -EACCES : 0;",
          "82:   break;",
          "",
          "[Removed Lines]",
          "79:   xattr_name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "79:   xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------"
        ],
        "fs/jfs/acl.c||fs/jfs/acl.c": [
          "File: fs/jfs/acl.c -> fs/jfs/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:  switch(type) {",
          "42:   case ACL_TYPE_ACCESS:",
          "44:    break;",
          "45:   case ACL_TYPE_DEFAULT:",
          "47:    break;",
          "48:   default:",
          "49:    return ERR_PTR(-EINVAL);",
          "",
          "[Removed Lines]",
          "43:    ea_name = POSIX_ACL_XATTR_ACCESS;",
          "46:    ea_name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "43:    ea_name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "46:    ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:  switch (type) {",
          "84:  case ACL_TYPE_ACCESS:",
          "86:   if (acl) {",
          "87:    rc = posix_acl_equiv_mode(acl, &inode->i_mode);",
          "88:    if (rc < 0)",
          "",
          "[Removed Lines]",
          "85:   ea_name = POSIX_ACL_XATTR_ACCESS;",
          "",
          "[Added Lines]",
          "85:   ea_name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:   }",
          "95:   break;",
          "96:  case ACL_TYPE_DEFAULT:",
          "98:   break;",
          "99:  default:",
          "100:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "97:   ea_name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "97:   ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------"
        ],
        "fs/nfs/nfs3acl.c||fs/nfs/nfs3acl.c": [
          "File: fs/nfs/nfs3acl.c -> fs/nfs/nfs3acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "284:  int error;",
          "286:  error = nfs3_list_one_acl(inode, ACL_TYPE_ACCESS,",
          "288:  if (error)",
          "289:   return error;",
          "291:  error = nfs3_list_one_acl(inode, ACL_TYPE_DEFAULT,",
          "293:  if (error)",
          "294:   return error;",
          "295:  return result;",
          "",
          "[Removed Lines]",
          "287:    POSIX_ACL_XATTR_ACCESS, data, size, &result);",
          "292:    POSIX_ACL_XATTR_DEFAULT, data, size, &result);",
          "",
          "[Added Lines]",
          "287:    XATTR_NAME_POSIX_ACL_ACCESS, data, size, &result);",
          "292:    XATTR_NAME_POSIX_ACL_DEFAULT, data, size, &result);",
          "",
          "---------------"
        ],
        "fs/posix_acl.c||fs/posix_acl.c": [
          "File: fs/posix_acl.c -> fs/posix_acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "845: }",
          "847: const struct xattr_handler posix_acl_access_xattr_handler = {",
          "849:  .flags = ACL_TYPE_ACCESS,",
          "850:  .list = posix_acl_xattr_list,",
          "851:  .get = posix_acl_xattr_get,",
          "",
          "[Removed Lines]",
          "848:  .prefix = POSIX_ACL_XATTR_ACCESS,",
          "",
          "[Added Lines]",
          "848:  .prefix = XATTR_NAME_POSIX_ACL_ACCESS,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "854: EXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);",
          "856: const struct xattr_handler posix_acl_default_xattr_handler = {",
          "858:  .flags = ACL_TYPE_DEFAULT,",
          "859:  .list = posix_acl_xattr_list,",
          "860:  .get = posix_acl_xattr_get,",
          "",
          "[Removed Lines]",
          "857:  .prefix = POSIX_ACL_XATTR_DEFAULT,",
          "",
          "[Added Lines]",
          "857:  .prefix = XATTR_NAME_POSIX_ACL_DEFAULT,",
          "",
          "---------------"
        ],
        "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c": [
          "File: fs/reiserfs/xattr_acl.c -> fs/reiserfs/xattr_acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:  switch (type) {",
          "188:  case ACL_TYPE_ACCESS:",
          "190:   break;",
          "191:  case ACL_TYPE_DEFAULT:",
          "193:   break;",
          "194:  default:",
          "195:   BUG();",
          "",
          "[Removed Lines]",
          "189:   name = POSIX_ACL_XATTR_ACCESS;",
          "192:   name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "189:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "192:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "245:  switch (type) {",
          "246:  case ACL_TYPE_ACCESS:",
          "248:   if (acl) {",
          "249:    error = posix_acl_equiv_mode(acl, &inode->i_mode);",
          "250:    if (error < 0)",
          "",
          "[Removed Lines]",
          "247:   name = POSIX_ACL_XATTR_ACCESS;",
          "",
          "[Added Lines]",
          "247:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "256:   }",
          "257:   break;",
          "258:  case ACL_TYPE_DEFAULT:",
          "260:   if (!S_ISDIR(inode->i_mode))",
          "261:    return acl ? -EACCES : 0;",
          "262:   break;",
          "",
          "[Removed Lines]",
          "259:   name = POSIX_ACL_XATTR_DEFAULT;",
          "",
          "[Added Lines]",
          "259:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_xattr.c||fs/xfs/xfs_xattr.c": [
          "File: fs/xfs/xfs_xattr.c -> fs/xfs/xfs_xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "255:  if (posix_acl_access_exists(inode)) {",
          "258:     data, size, &context.count);",
          "259:   if (error)",
          "260:    return error;",
          "261:  }",
          "263:  if (posix_acl_default_exists(inode)) {",
          "266:     data, size, &context.count);",
          "267:   if (error)",
          "268:    return error;",
          "",
          "[Removed Lines]",
          "256:   error = list_one_attr(POSIX_ACL_XATTR_ACCESS,",
          "257:     strlen(POSIX_ACL_XATTR_ACCESS) + 1,",
          "264:   error = list_one_attr(POSIX_ACL_XATTR_DEFAULT,",
          "265:     strlen(POSIX_ACL_XATTR_DEFAULT) + 1,",
          "",
          "[Added Lines]",
          "256:   error = list_one_attr(XATTR_NAME_POSIX_ACL_ACCESS,",
          "257:     strlen(XATTR_NAME_POSIX_ACL_ACCESS) + 1,",
          "264:   error = list_one_attr(XATTR_NAME_POSIX_ACL_DEFAULT,",
          "265:     strlen(XATTR_NAME_POSIX_ACL_DEFAULT) + 1,",
          "",
          "---------------"
        ],
        "include/linux/posix_acl_xattr.h||include/linux/posix_acl_xattr.h": [
          "File: include/linux/posix_acl_xattr.h -> include/linux/posix_acl_xattr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #ifndef _POSIX_ACL_XATTR_H",
          "10: #define _POSIX_ACL_XATTR_H",
          "12: #include <linux/posix_acl.h>",
          "19: #define POSIX_ACL_XATTR_VERSION 0x0002",
          "23: #define ACL_UNDEFINED_ID (-1)",
          "",
          "[Removed Lines]",
          "15: #define POSIX_ACL_XATTR_ACCESS \"system.posix_acl_access\"",
          "16: #define POSIX_ACL_XATTR_DEFAULT \"system.posix_acl_default\"",
          "",
          "[Added Lines]",
          "12: #include <uapi/linux/xattr.h>",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5db11c21a929cd9d8c0484006efb1014fc723c93",
      "candidate_info": {
        "commit_hash": "5db11c21a929cd9d8c0484006efb1014fc723c93",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5db11c21a929cd9d8c0484006efb1014fc723c93",
        "files": [
          "fs/orangefs/acl.c",
          "fs/orangefs/dcache.c",
          "fs/orangefs/devpvfs2-req.c",
          "fs/orangefs/dir.c",
          "fs/orangefs/file.c",
          "fs/orangefs/inode.c"
        ],
        "message": "Orangefs: kernel client part 2\n\nSigned-off-by: Mike Marshall <hubcap@omnibond.com>",
        "before_after_code_files": [
          "fs/orangefs/acl.c||fs/orangefs/acl.c",
          "fs/orangefs/dcache.c||fs/orangefs/dcache.c",
          "fs/orangefs/devpvfs2-req.c||fs/orangefs/devpvfs2-req.c",
          "fs/orangefs/dir.c||fs/orangefs/dir.c",
          "fs/orangefs/file.c||fs/orangefs/file.c",
          "fs/orangefs/inode.c||fs/orangefs/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/orangefs/acl.c||fs/orangefs/acl.c"
          ],
          "candidate": [
            "fs/orangefs/acl.c||fs/orangefs/acl.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/orangefs/acl.c||fs/orangefs/acl.c": [
          "File: fs/orangefs/acl.c -> fs/orangefs/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include \"protocol.h\"",
          "8: #include \"pvfs2-kernel.h\"",
          "9: #include \"pvfs2-bufmap.h\"",
          "10: #include <linux/posix_acl_xattr.h>",
          "11: #include <linux/fs_struct.h>",
          "13: struct posix_acl *pvfs2_get_acl(struct inode *inode, int type)",
          "14: {",
          "15:  struct posix_acl *acl;",
          "16:  int ret;",
          "17:  char *key = NULL, *value = NULL;",
          "19:  switch (type) {",
          "20:  case ACL_TYPE_ACCESS:",
          "21:   key = PVFS2_XATTR_NAME_ACL_ACCESS;",
          "22:   break;",
          "23:  case ACL_TYPE_DEFAULT:",
          "24:   key = PVFS2_XATTR_NAME_ACL_DEFAULT;",
          "25:   break;",
          "26:  default:",
          "27:   gossip_err(\"pvfs2_get_acl: bogus value of type %d\\n\", type);",
          "28:   return ERR_PTR(-EINVAL);",
          "29:  }",
          "37:  value = kmalloc(PVFS_MAX_XATTR_VALUELEN, GFP_KERNEL);",
          "38:  if (value == NULL)",
          "39:   return ERR_PTR(-ENOMEM);",
          "41:  gossip_debug(GOSSIP_ACL_DEBUG,",
          "42:        \"inode %pU, key %s, type %d\\n\",",
          "43:        get_khandle_from_ino(inode),",
          "44:        key,",
          "45:        type);",
          "46:  ret = pvfs2_inode_getxattr(inode,",
          "47:        \"\",",
          "48:        key,",
          "49:        value,",
          "50:        PVFS_MAX_XATTR_VALUELEN);",
          "52:  if (ret > 0) {",
          "53:   acl = posix_acl_from_xattr(&init_user_ns, value, ret);",
          "54:  } else if (ret == -ENODATA || ret == -ENOSYS) {",
          "55:   acl = NULL;",
          "56:  } else {",
          "57:   gossip_err(\"inode %pU retrieving acl's failed with error %d\\n\",",
          "58:       get_khandle_from_ino(inode),",
          "59:       ret);",
          "60:   acl = ERR_PTR(ret);",
          "61:  }",
          "63:  kfree(value);",
          "64:  return acl;",
          "65: }",
          "67: int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)",
          "68: {",
          "69:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "70:  int error = 0;",
          "71:  void *value = NULL;",
          "72:  size_t size = 0;",
          "73:  const char *name = NULL;",
          "75:  switch (type) {",
          "76:  case ACL_TYPE_ACCESS:",
          "77:   name = PVFS2_XATTR_NAME_ACL_ACCESS;",
          "78:   if (acl) {",
          "79:    umode_t mode = inode->i_mode;",
          "84:    error = posix_acl_equiv_mode(acl, &mode);",
          "85:    if (error < 0) {",
          "86:     gossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",",
          "87:         __func__,",
          "88:         error);",
          "89:     return error;",
          "90:    }",
          "92:    if (inode->i_mode != mode)",
          "93:     SetModeFlag(pvfs2_inode);",
          "94:    inode->i_mode = mode;",
          "95:    mark_inode_dirty_sync(inode);",
          "96:    if (error == 0)",
          "97:     acl = NULL;",
          "98:   }",
          "99:   break;",
          "100:  case ACL_TYPE_DEFAULT:",
          "101:   name = PVFS2_XATTR_NAME_ACL_DEFAULT;",
          "102:   break;",
          "103:  default:",
          "104:   gossip_err(\"%s: invalid type %d!\\n\", __func__, type);",
          "105:   return -EINVAL;",
          "106:  }",
          "108:  gossip_debug(GOSSIP_ACL_DEBUG,",
          "109:        \"%s: inode %pU, key %s type %d\\n\",",
          "110:        __func__, get_khandle_from_ino(inode),",
          "111:        name,",
          "112:        type);",
          "114:  if (acl) {",
          "115:   size = posix_acl_xattr_size(acl->a_count);",
          "116:   value = kmalloc(size, GFP_KERNEL);",
          "117:   if (!value)",
          "118:    return -ENOMEM;",
          "120:   error = posix_acl_to_xattr(&init_user_ns, acl, value, size);",
          "121:   if (error < 0)",
          "122:    goto out;",
          "123:  }",
          "125:  gossip_debug(GOSSIP_ACL_DEBUG,",
          "126:        \"%s: name %s, value %p, size %zd, acl %p\\n\",",
          "127:        __func__, name, value, size, acl);",
          "134:  error = pvfs2_inode_setxattr(inode, \"\", name, value, size, 0);",
          "136: out:",
          "137:  kfree(value);",
          "138:  if (!error)",
          "139:   set_cached_acl(inode, type, acl);",
          "140:  return error;",
          "141: }",
          "143: int pvfs2_init_acl(struct inode *inode, struct inode *dir)",
          "144: {",
          "145:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "146:  struct posix_acl *default_acl, *acl;",
          "147:  umode_t mode = inode->i_mode;",
          "148:  int error = 0;",
          "150:  ClearModeFlag(pvfs2_inode);",
          "152:  error = posix_acl_create(dir, &mode, &default_acl, &acl);",
          "153:  if (error)",
          "154:   return error;",
          "156:  if (default_acl) {",
          "157:   error = pvfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);",
          "158:   posix_acl_release(default_acl);",
          "159:  }",
          "161:  if (acl) {",
          "162:   if (!error)",
          "163:    error = pvfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);",
          "164:   posix_acl_release(acl);",
          "165:  }",
          "168:  if (mode != inode->i_mode) {",
          "169:   SetModeFlag(pvfs2_inode);",
          "170:   inode->i_mode = mode;",
          "171:   pvfs2_flush_inode(inode);",
          "172:  }",
          "174:  return error;",
          "175: }",
          "",
          "---------------"
        ],
        "fs/orangefs/dcache.c||fs/orangefs/dcache.c": [
          "File: fs/orangefs/dcache.c -> fs/orangefs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"protocol.h\"",
          "12: #include \"pvfs2-kernel.h\"",
          "15: static int pvfs2_revalidate_lookup(struct dentry *dentry)",
          "16: {",
          "17:  struct dentry *parent_dentry = dget_parent(dentry);",
          "18:  struct inode *parent_inode = parent_dentry->d_inode;",
          "19:  struct pvfs2_inode_s *parent = PVFS2_I(parent_inode);",
          "20:  struct inode *inode = dentry->d_inode;",
          "21:  struct pvfs2_kernel_op_s *new_op;",
          "22:  int ret = 0;",
          "23:  int err = 0;",
          "25:  gossip_debug(GOSSIP_DCACHE_DEBUG, \"%s: attempting lookup.\\n\", __func__);",
          "27:  new_op = op_alloc(PVFS2_VFS_OP_LOOKUP);",
          "28:  if (!new_op)",
          "29:   goto out_put_parent;",
          "31:  new_op->upcall.req.lookup.sym_follow = PVFS2_LOOKUP_LINK_NO_FOLLOW;",
          "32:  new_op->upcall.req.lookup.parent_refn = parent->refn;",
          "33:  strncpy(new_op->upcall.req.lookup.d_name,",
          "34:   dentry->d_name.name,",
          "35:   PVFS2_NAME_LEN);",
          "37:  gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "38:        \"%s:%s:%d interrupt flag [%d]\\n\",",
          "39:        __FILE__,",
          "40:        __func__,",
          "41:        __LINE__,",
          "42:        get_interruptible_flag(parent_inode));",
          "44:  err = service_operation(new_op, \"pvfs2_lookup\",",
          "45:    get_interruptible_flag(parent_inode));",
          "46:  if (err)",
          "47:   goto out_drop;",
          "49:  if (new_op->downcall.status != 0 ||",
          "50:      !match_handle(new_op->downcall.resp.lookup.refn.khandle, inode)) {",
          "51:   gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "52:    \"%s:%s:%d \"",
          "53:    \"lookup failure |%s| or no match |%s|.\\n\",",
          "54:    __FILE__,",
          "55:    __func__,",
          "56:    __LINE__,",
          "57:    new_op->downcall.status ? \"true\" : \"false\",",
          "58:    match_handle(new_op->downcall.resp.lookup.refn.khandle,",
          "59:      inode) ? \"false\" : \"true\");",
          "60:   gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "61:         \"%s:%s:%d revalidate failed\\n\",",
          "62:         __FILE__, __func__, __LINE__);",
          "63:   goto out_drop;",
          "64:  }",
          "66:  ret = 1;",
          "67: out_release_op:",
          "68:  op_release(new_op);",
          "69: out_put_parent:",
          "70:  dput(parent_dentry);",
          "71:  return ret;",
          "72: out_drop:",
          "73:  d_drop(dentry);",
          "74:  goto out_release_op;",
          "75: }",
          "82: static int pvfs2_d_revalidate(struct dentry *dentry, unsigned int flags)",
          "83: {",
          "84:  struct inode *inode;",
          "85:  int ret = 0;",
          "87:  if (flags & LOOKUP_RCU)",
          "88:   return -ECHILD;",
          "90:  gossip_debug(GOSSIP_DCACHE_DEBUG, \"%s: called on dentry %p.\\n\",",
          "91:        __func__, dentry);",
          "94:  if (!dentry->d_inode) {",
          "95:   gossip_debug(GOSSIP_DCACHE_DEBUG, \"%s: negative dentry.\\n\",",
          "96:         __func__);",
          "97:   goto invalid_exit;",
          "98:  }",
          "100:  gossip_debug(GOSSIP_DCACHE_DEBUG, \"%s: inode valid.\\n\", __func__);",
          "101:  inode = dentry->d_inode;",
          "107:  if (!is_root_handle(inode)) {",
          "108:   if (!pvfs2_revalidate_lookup(dentry))",
          "109:    goto invalid_exit;",
          "110:  } else {",
          "111:   gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "112:         \"%s: root handle, lookup skipped.\\n\",",
          "113:         __func__);",
          "114:  }",
          "117:  gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "118:        \"%s: doing getattr: inode: %p, handle: %pU\\n\",",
          "119:        __func__,",
          "120:        inode,",
          "121:        get_khandle_from_ino(inode));",
          "122:  ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "123:  gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "124:        \"%s: getattr %s (ret = %d), returning %s for dentry i_count=%d\\n\",",
          "125:        __func__,",
          "126:        (ret == 0 ? \"succeeded\" : \"failed\"),",
          "127:        ret,",
          "128:        (ret == 0 ? \"valid\" : \"INVALID\"),",
          "129:        atomic_read(&inode->i_count));",
          "130:  if (ret != 0)",
          "131:   goto invalid_exit;",
          "134:  return 1;",
          "136: invalid_exit:",
          "137:  return 0;",
          "138: }",
          "140: const struct dentry_operations pvfs2_dentry_operations = {",
          "141:  .d_revalidate = pvfs2_d_revalidate,",
          "142: };",
          "",
          "---------------"
        ],
        "fs/orangefs/devpvfs2-req.c||fs/orangefs/devpvfs2-req.c": [
          "File: fs/orangefs/devpvfs2-req.c -> fs/orangefs/devpvfs2-req.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include \"protocol.h\"",
          "11: #include \"pvfs2-kernel.h\"",
          "12: #include \"pvfs2-dev-proto.h\"",
          "13: #include \"pvfs2-bufmap.h\"",
          "15: #include <linux/debugfs.h>",
          "16: #include <linux/slab.h>",
          "20: static int open_access_count;",
          "22: #define DUMP_DEVICE_ERROR()                                                   \\",
          "23: do {                                                                          \\",
          "24:  gossip_err(\"*****************************************************\\n\");\\",
          "25:  gossip_err(\"PVFS2 Device Error:  You cannot open the device file \");  \\",
          "26:  gossip_err(\"\\n/dev/%s more than once.  Please make sure that\\nthere \" \\",
          "27:      \"are no \", PVFS2_REQDEVICE_NAME);                          \\",
          "28:  gossip_err(\"instances of a program using this device\\ncurrently \"     \\",
          "29:      \"running. (You must verify this!)\\n\");                     \\",
          "30:  gossip_err(\"For example, you can use the lsof program as follows:\\n\");\\",
          "31:  gossip_err(\"'lsof | grep %s' (run this as root)\\n\",                   \\",
          "32:      PVFS2_REQDEVICE_NAME);                                     \\",
          "33:  gossip_err(\"  open_access_count = %d\\n\", open_access_count);          \\",
          "34:  gossip_err(\"*****************************************************\\n\");\\",
          "35: } while (0)",
          "37: static int hash_func(__u64 tag, int table_size)",
          "38: {",
          "39:  return tag % ((unsigned int)table_size);",
          "40: }",
          "42: static void pvfs2_devreq_add_op(struct pvfs2_kernel_op_s *op)",
          "43: {",
          "44:  int index = hash_func(op->tag, hash_table_size);",
          "46:  spin_lock(&htable_ops_in_progress_lock);",
          "47:  list_add_tail(&op->list, &htable_ops_in_progress[index]);",
          "48:  spin_unlock(&htable_ops_in_progress_lock);",
          "49: }",
          "51: static struct pvfs2_kernel_op_s *pvfs2_devreq_remove_op(__u64 tag)",
          "52: {",
          "53:  struct pvfs2_kernel_op_s *op, *next;",
          "54:  int index;",
          "56:  index = hash_func(tag, hash_table_size);",
          "58:  spin_lock(&htable_ops_in_progress_lock);",
          "59:  list_for_each_entry_safe(op,",
          "60:      next,",
          "61:      &htable_ops_in_progress[index],",
          "62:      list) {",
          "63:   if (op->tag == tag) {",
          "64:    list_del(&op->list);",
          "65:    spin_unlock(&htable_ops_in_progress_lock);",
          "66:    return op;",
          "67:   }",
          "68:  }",
          "70:  spin_unlock(&htable_ops_in_progress_lock);",
          "71:  return NULL;",
          "72: }",
          "74: static int pvfs2_devreq_open(struct inode *inode, struct file *file)",
          "75: {",
          "76:  int ret = -EINVAL;",
          "78:  if (!(file->f_flags & O_NONBLOCK)) {",
          "79:   gossip_err(\"pvfs2: device cannot be opened in blocking mode\\n\");",
          "80:   goto out;",
          "81:  }",
          "82:  ret = -EACCES;",
          "83:  gossip_debug(GOSSIP_DEV_DEBUG, \"pvfs2-client-core: opening device\\n\");",
          "84:  mutex_lock(&devreq_mutex);",
          "86:  if (open_access_count == 0) {",
          "87:   ret = generic_file_open(inode, file);",
          "88:   if (ret == 0)",
          "89:    open_access_count++;",
          "90:  } else {",
          "91:   DUMP_DEVICE_ERROR();",
          "92:  }",
          "93:  mutex_unlock(&devreq_mutex);",
          "95: out:",
          "97:  gossip_debug(GOSSIP_DEV_DEBUG,",
          "98:        \"pvfs2-client-core: open device complete (ret = %d)\\n\",",
          "99:        ret);",
          "100:  return ret;",
          "101: }",
          "103: static ssize_t pvfs2_devreq_read(struct file *file,",
          "104:      char __user *buf,",
          "105:      size_t count, loff_t *offset)",
          "106: {",
          "107:  int ret = 0;",
          "108:  ssize_t len = 0;",
          "109:  struct pvfs2_kernel_op_s *cur_op = NULL;",
          "110:  static __s32 magic = PVFS2_DEVREQ_MAGIC;",
          "111:  __s32 proto_ver = PVFS_KERNEL_PROTO_VERSION;",
          "113:  if (!(file->f_flags & O_NONBLOCK)) {",
          "115:   gossip_err(\"pvfs2: blocking reads are not supported! (pvfs2-client-core bug)\\n\");",
          "116:   return -EINVAL;",
          "117:  } else {",
          "118:   struct pvfs2_kernel_op_s *op = NULL, *temp = NULL;",
          "120:   spin_lock(&pvfs2_request_list_lock);",
          "121:   list_for_each_entry_safe(op, temp, &pvfs2_request_list, list) {",
          "122:    __s32 fsid = fsid_of_op(op);",
          "127:    if (fsid != PVFS_FS_ID_NULL &&",
          "128:        fs_mount_pending(fsid) == 1) {",
          "129:     gossip_debug(GOSSIP_DEV_DEBUG,",
          "130:           \"Skipping op tag %llu %s\\n\",",
          "131:           llu(op->tag),",
          "132:           get_opname_string(op));",
          "133:     continue;",
          "134:    } else {",
          "139:     cur_op = op;",
          "140:     spin_lock(&cur_op->lock);",
          "141:     list_del(&cur_op->list);",
          "142:     cur_op->op_linger_tmp--;",
          "147:     if (cur_op->op_linger == 2 &&",
          "148:         cur_op->op_linger_tmp == 1) {",
          "149:      if (cur_op->upcall.trailer_size <= 0 ||",
          "150:          cur_op->upcall.trailer_buf == NULL)",
          "151:       gossip_err(\"BUG:trailer_size is %ld and trailer buf is %p\\n\", (long)cur_op->upcall.trailer_size, cur_op->upcall.trailer_buf);",
          "153:      list_add(&cur_op->list,",
          "154:        &pvfs2_request_list);",
          "155:     }",
          "156:     spin_unlock(&cur_op->lock);",
          "157:     break;",
          "158:    }",
          "159:   }",
          "160:   spin_unlock(&pvfs2_request_list_lock);",
          "161:  }",
          "163:  if (cur_op) {",
          "164:   spin_lock(&cur_op->lock);",
          "166:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "167:         \"client-core: reading op tag %llu %s\\n\",",
          "168:         llu(cur_op->tag), get_opname_string(cur_op));",
          "169:   if (op_state_in_progress(cur_op) || op_state_serviced(cur_op)) {",
          "170:    if (cur_op->op_linger == 1)",
          "171:     gossip_err(\"WARNING: Current op already queued...skipping\\n\");",
          "172:   } else if (cur_op->op_linger == 1 ||",
          "173:       (cur_op->op_linger == 2 &&",
          "174:        cur_op->op_linger_tmp == 0)) {",
          "179:    set_op_state_inprogress(cur_op);",
          "180:    pvfs2_devreq_add_op(cur_op);",
          "181:   }",
          "183:   spin_unlock(&cur_op->lock);",
          "190:   if (cur_op->op_linger == 1 ||",
          "191:      (cur_op->op_linger == 2 && cur_op->op_linger_tmp == 1)) {",
          "192:    len = MAX_ALIGNED_DEV_REQ_UPSIZE;",
          "193:    if ((size_t) len <= count) {",
          "194:        ret = copy_to_user(buf,",
          "195:             &proto_ver,",
          "196:             sizeof(__s32));",
          "197:        if (ret == 0) {",
          "198:     ret = copy_to_user(buf + sizeof(__s32),",
          "199:          &magic,",
          "200:          sizeof(__s32));",
          "201:     if (ret == 0) {",
          "202:         ret = copy_to_user(buf+2 * sizeof(__s32),",
          "203:              &cur_op->tag,",
          "204:              sizeof(__u64));",
          "205:         if (ret == 0) {",
          "206:      ret = copy_to_user(",
          "207:       buf +",
          "208:         2 *",
          "209:         sizeof(__s32) +",
          "210:         sizeof(__u64),",
          "211:       &cur_op->upcall,",
          "212:       sizeof(struct pvfs2_upcall_s));",
          "213:         }",
          "214:     }",
          "215:        }",
          "217:        if (ret) {",
          "218:     gossip_err(\"Failed to copy data to user space\\n\");",
          "219:     len = -EFAULT;",
          "220:        }",
          "221:    } else {",
          "222:     gossip_err",
          "223:         (\"Failed to copy data to user space\\n\");",
          "224:     len = -EIO;",
          "225:    }",
          "226:   }",
          "228:   else if (cur_op->op_linger == 2 && cur_op->op_linger_tmp == 0) {",
          "229:    len = cur_op->upcall.trailer_size;",
          "230:    if ((size_t) len <= count) {",
          "231:     ret = copy_to_user(buf,",
          "232:          cur_op->upcall.trailer_buf,",
          "233:          len);",
          "234:     if (ret) {",
          "235:      gossip_err(\"Failed to copy trailer to user space\\n\");",
          "236:      len = -EFAULT;",
          "237:     }",
          "238:    } else {",
          "239:     gossip_err(\"Read buffer for trailer is too small (%ld as opposed to %ld)\\n\",",
          "240:      (long)count,",
          "241:      (long)len);",
          "242:     len = -EIO;",
          "243:    }",
          "244:   } else {",
          "245:    gossip_err(\"cur_op: %p (op_linger %d), (op_linger_tmp %d), erroneous request list?\\n\",",
          "246:     cur_op,",
          "247:     cur_op->op_linger,",
          "248:     cur_op->op_linger_tmp);",
          "249:    len = 0;",
          "250:   }",
          "251:  } else if (file->f_flags & O_NONBLOCK) {",
          "256:   len = -EAGAIN;",
          "257:  }",
          "258:  return len;",
          "259: }",
          "262: static ssize_t pvfs2_devreq_writev(struct file *file,",
          "263:        const struct iovec *iov,",
          "264:        size_t count,",
          "265:        loff_t *offset)",
          "266: {",
          "267:  struct pvfs2_kernel_op_s *op = NULL;",
          "268:  void *buffer = NULL;",
          "269:  void *ptr = NULL;",
          "270:  unsigned long i = 0;",
          "271:  static int max_downsize = MAX_ALIGNED_DEV_REQ_DOWNSIZE;",
          "272:  int ret = 0, num_remaining = max_downsize;",
          "274:  int payload_size = 0;",
          "275:  __s32 magic = 0;",
          "276:  __s32 proto_ver = 0;",
          "277:  __u64 tag = 0;",
          "278:  ssize_t total_returned_size = 0;",
          "281:  if (count != notrailer_count && count != (notrailer_count + 1)) {",
          "282:   gossip_err(\"Error: Number of iov vectors is (%ld) and notrailer count is %d\\n\",",
          "283:    count,",
          "284:    notrailer_count);",
          "285:   return -EPROTO;",
          "286:  }",
          "287:  buffer = dev_req_alloc();",
          "288:  if (!buffer)",
          "289:   return -ENOMEM;",
          "290:  ptr = buffer;",
          "292:  for (i = 0; i < notrailer_count; i++) {",
          "293:   if (iov[i].iov_len > num_remaining) {",
          "294:    gossip_err",
          "295:        (\"writev error: Freeing buffer and returning\\n\");",
          "296:    dev_req_release(buffer);",
          "297:    return -EMSGSIZE;",
          "298:   }",
          "299:   ret = copy_from_user(ptr, iov[i].iov_base, iov[i].iov_len);",
          "300:   if (ret) {",
          "301:    gossip_err(\"Failed to copy data from user space\\n\");",
          "302:    dev_req_release(buffer);",
          "303:    return -EIO;",
          "304:   }",
          "305:   num_remaining -= iov[i].iov_len;",
          "306:   ptr += iov[i].iov_len;",
          "307:   payload_size += iov[i].iov_len;",
          "308:  }",
          "309:  total_returned_size = payload_size;",
          "315:  ptr = buffer;",
          "316:  proto_ver = *((__s32 *) ptr);",
          "317:  ptr += sizeof(__s32);",
          "319:  magic = *((__s32 *) ptr);",
          "320:  ptr += sizeof(__s32);",
          "322:  tag = *((__u64 *) ptr);",
          "323:  ptr += sizeof(__u64);",
          "325:  if (magic != PVFS2_DEVREQ_MAGIC) {",
          "326:   gossip_err(\"Error: Device magic number does not match.\\n\");",
          "327:   dev_req_release(buffer);",
          "328:   return -EPROTO;",
          "329:  }",
          "335:  op = pvfs2_devreq_remove_op(tag);",
          "336:  if (op) {",
          "338:   get_op(op);",
          "340:   payload_size -= (2 * sizeof(__s32) + sizeof(__u64));",
          "341:   if (payload_size <= sizeof(struct pvfs2_downcall_s))",
          "343:    memcpy(&op->downcall,",
          "344:           ptr,",
          "345:           sizeof(struct pvfs2_downcall_s));",
          "346:   else",
          "347:    gossip_debug(GOSSIP_DEV_DEBUG,",
          "348:          \"writev: Ignoring %d bytes\\n\",",
          "349:          payload_size);",
          "354:   if (op->downcall.status == 0 && op->downcall.trailer_size > 0) {",
          "355:    gossip_debug(GOSSIP_DEV_DEBUG,",
          "356:          \"writev: trailer size %ld\\n\",",
          "357:          (unsigned long)op->downcall.trailer_size);",
          "358:    if (count != (notrailer_count + 1)) {",
          "359:     gossip_err(\"Error: trailer size (%ld) is non-zero, no trailer elements though? (%ld)\\n\", (unsigned long)op->downcall.trailer_size, count);",
          "360:     dev_req_release(buffer);",
          "361:     put_op(op);",
          "362:     return -EPROTO;",
          "363:    }",
          "364:    if (iov[notrailer_count].iov_len >",
          "365:        op->downcall.trailer_size) {",
          "366:     gossip_err(\"writev error: trailer size (%ld) != iov_len (%ld)\\n\", (unsigned long)op->downcall.trailer_size, (unsigned long)iov[notrailer_count].iov_len);",
          "367:     dev_req_release(buffer);",
          "368:     put_op(op);",
          "369:     return -EMSGSIZE;",
          "370:    }",
          "374:    op->downcall.trailer_buf =",
          "375:        vmalloc(op->downcall.trailer_size);",
          "376:    if (op->downcall.trailer_buf != NULL) {",
          "377:     gossip_debug(GOSSIP_DEV_DEBUG, \"vmalloc: %p\\n\",",
          "378:           op->downcall.trailer_buf);",
          "379:     ret = copy_from_user(op->downcall.trailer_buf,",
          "380:            iov[notrailer_count].",
          "381:            iov_base,",
          "382:            iov[notrailer_count].",
          "383:            iov_len);",
          "384:     if (ret) {",
          "385:      gossip_err(\"Failed to copy trailer data from user space\\n\");",
          "386:      dev_req_release(buffer);",
          "387:      gossip_debug(GOSSIP_DEV_DEBUG,",
          "388:            \"vfree: %p\\n\",",
          "389:            op->downcall.trailer_buf);",
          "390:      vfree(op->downcall.trailer_buf);",
          "391:      op->downcall.trailer_buf = NULL;",
          "392:      put_op(op);",
          "393:      return -EIO;",
          "394:     }",
          "395:    } else {",
          "397:     op->downcall.status = -ENOMEM;",
          "398:     gossip_err(\"writev: could not vmalloc for trailer!\\n\");",
          "399:    }",
          "400:   }",
          "414:   if ((op->upcall.type == PVFS2_VFS_OP_FILE_IO &&",
          "415:        op->upcall.req.io.async_vfs_io == PVFS_VFS_SYNC_IO) ||",
          "416:        op->upcall.type == PVFS2_VFS_OP_FILE_IOX) {",
          "417:    int timed_out = 0;",
          "418:    DECLARE_WAITQUEUE(wait_entry, current);",
          "423:    spin_lock(&op->lock);",
          "424:    set_op_state_serviced(op);",
          "425:    spin_unlock(&op->lock);",
          "427:    add_wait_queue_exclusive(&op->io_completion_waitq,",
          "428:        &wait_entry);",
          "429:    wake_up_interruptible(&op->waitq);",
          "431:    while (1) {",
          "432:     set_current_state(TASK_INTERRUPTIBLE);",
          "434:     spin_lock(&op->lock);",
          "435:     if (op->io_completed) {",
          "436:      spin_unlock(&op->lock);",
          "437:      break;",
          "438:     }",
          "439:     spin_unlock(&op->lock);",
          "441:     if (!signal_pending(current)) {",
          "442:      int timeout =",
          "443:          MSECS_TO_JIFFIES(1000 *",
          "444:             op_timeout_secs);",
          "445:      if (!schedule_timeout(timeout)) {",
          "446:       gossip_debug(GOSSIP_DEV_DEBUG, \"*** I/O wait time is up\\n\");",
          "447:       timed_out = 1;",
          "448:       break;",
          "449:      }",
          "450:      continue;",
          "451:     }",
          "453:     gossip_debug(GOSSIP_DEV_DEBUG, \"*** signal on I/O wait -- aborting\\n\");",
          "454:     break;",
          "455:    }",
          "457:    set_current_state(TASK_RUNNING);",
          "458:    remove_wait_queue(&op->io_completion_waitq,",
          "459:        &wait_entry);",
          "467:    if (!timed_out)",
          "468:     op_release(op);",
          "469:   } else {",
          "475:    spin_lock(&op->lock);",
          "476:    set_op_state_serviced(op);",
          "477:    spin_unlock(&op->lock);",
          "479:       for every other operation (i.e. non-I/O), we need to",
          "480:       wake up the callers for downcall completion",
          "481:       notification",
          "483:    wake_up_interruptible(&op->waitq);",
          "484:   }",
          "485:  } else {",
          "487:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "488:         \"WARNING: No one's waiting for tag %llu\\n\",",
          "489:         llu(tag));",
          "490:  }",
          "491:  dev_req_release(buffer);",
          "493:  return total_returned_size;",
          "494: }",
          "496: static ssize_t pvfs2_devreq_write_iter(struct kiocb *iocb,",
          "497:           struct iov_iter *iter)",
          "498: {",
          "499:  return pvfs2_devreq_writev(iocb->ki_filp,",
          "500:        iter->iov,",
          "501:        iter->nr_segs,",
          "502:        &iocb->ki_pos);",
          "503: }",
          "506: static int mark_all_pending_mounts(void)",
          "507: {",
          "508:  int unmounted = 1;",
          "509:  struct pvfs2_sb_info_s *pvfs2_sb = NULL;",
          "511:  spin_lock(&pvfs2_superblocks_lock);",
          "512:  list_for_each_entry(pvfs2_sb, &pvfs2_superblocks, list) {",
          "514:   pvfs2_sb->mount_pending = 1;",
          "515:   unmounted = 0;",
          "516:  }",
          "517:  spin_unlock(&pvfs2_superblocks_lock);",
          "518:  return unmounted;",
          "519: }",
          "527: int fs_mount_pending(__s32 fsid)",
          "528: {",
          "529:  int mount_pending = -1;",
          "530:  struct pvfs2_sb_info_s *pvfs2_sb = NULL;",
          "532:  spin_lock(&pvfs2_superblocks_lock);",
          "533:  list_for_each_entry(pvfs2_sb, &pvfs2_superblocks, list) {",
          "534:   if (pvfs2_sb->fs_id == fsid) {",
          "535:    mount_pending = pvfs2_sb->mount_pending;",
          "536:    break;",
          "537:   }",
          "538:  }",
          "539:  spin_unlock(&pvfs2_superblocks_lock);",
          "540:  return mount_pending;",
          "541: }",
          "551: static int pvfs2_devreq_release(struct inode *inode, struct file *file)",
          "552: {",
          "553:  int unmounted = 0;",
          "555:  gossip_debug(GOSSIP_DEV_DEBUG,",
          "556:        \"%s:pvfs2-client-core: exiting, closing device\\n\",",
          "557:        __func__);",
          "559:  mutex_lock(&devreq_mutex);",
          "560:  pvfs_bufmap_finalize();",
          "562:  open_access_count--;",
          "564:  unmounted = mark_all_pending_mounts();",
          "565:  gossip_debug(GOSSIP_DEV_DEBUG, \"PVFS2 Device Close: Filesystem(s) %s\\n\",",
          "566:        (unmounted ? \"UNMOUNTED\" : \"MOUNTED\"));",
          "567:  mutex_unlock(&devreq_mutex);",
          "573:  purge_waiting_ops();",
          "578:  purge_inprogress_ops();",
          "579:  gossip_debug(GOSSIP_DEV_DEBUG,",
          "580:        \"pvfs2-client-core: device close complete\\n\");",
          "581:  return 0;",
          "582: }",
          "584: int is_daemon_in_service(void)",
          "585: {",
          "586:  int in_service;",
          "592:  mutex_lock(&devreq_mutex);",
          "593:  in_service = open_access_count == 1 ? 0 : -EIO;",
          "594:  mutex_unlock(&devreq_mutex);",
          "595:  return in_service;",
          "596: }",
          "598: static inline long check_ioctl_command(unsigned int command)",
          "599: {",
          "601:  if (_IOC_TYPE(command) != PVFS_DEV_MAGIC) {",
          "602:   gossip_err(\"device ioctl magic numbers don't match! Did you rebuild pvfs2-client-core/libpvfs2? [cmd %x, magic %x != %x]\\n\",",
          "603:    command,",
          "604:    _IOC_TYPE(command),",
          "605:    PVFS_DEV_MAGIC);",
          "606:   return -EINVAL;",
          "607:  }",
          "609:  if (_IOC_NR(command) >= PVFS_DEV_MAXNR || _IOC_NR(command) <= 0) {",
          "610:   gossip_err(\"Invalid ioctl command number [%d >= %d]\\n\",",
          "611:       _IOC_NR(command), PVFS_DEV_MAXNR);",
          "612:   return -ENOIOCTLCMD;",
          "613:  }",
          "614:  return 0;",
          "615: }",
          "617: static long dispatch_ioctl_command(unsigned int command, unsigned long arg)",
          "618: {",
          "619:  static __s32 magic = PVFS2_DEVREQ_MAGIC;",
          "620:  static __s32 max_up_size = MAX_ALIGNED_DEV_REQ_UPSIZE;",
          "621:  static __s32 max_down_size = MAX_ALIGNED_DEV_REQ_DOWNSIZE;",
          "622:  struct PVFS_dev_map_desc user_desc;",
          "623:  int ret = 0;",
          "624:  struct dev_mask_info_s mask_info = { 0 };",
          "625:  struct dev_mask2_info_s mask2_info = { 0, 0 };",
          "626:  int upstream_kmod = 1;",
          "627:  struct list_head *tmp = NULL;",
          "628:  struct pvfs2_sb_info_s *pvfs2_sb = NULL;",
          "632:  switch (command) {",
          "633:  case PVFS_DEV_GET_MAGIC:",
          "634:   return ((put_user(magic, (__s32 __user *) arg) == -EFAULT) ?",
          "635:    -EIO :",
          "636:    0);",
          "637:  case PVFS_DEV_GET_MAX_UPSIZE:",
          "638:   return ((put_user(max_up_size,",
          "639:       (__s32 __user *) arg) == -EFAULT) ?",
          "640:      -EIO :",
          "641:      0);",
          "642:  case PVFS_DEV_GET_MAX_DOWNSIZE:",
          "643:   return ((put_user(max_down_size,",
          "644:       (__s32 __user *) arg) == -EFAULT) ?",
          "645:      -EIO :",
          "646:      0);",
          "647:  case PVFS_DEV_MAP:",
          "648:   ret = copy_from_user(&user_desc,",
          "649:          (struct PVFS_dev_map_desc __user *)",
          "650:          arg,",
          "651:          sizeof(struct PVFS_dev_map_desc));",
          "652:   return ret ? -EIO : pvfs_bufmap_initialize(&user_desc);",
          "653:  case PVFS_DEV_REMOUNT_ALL:",
          "654:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "655:         \"pvfs2_devreq_ioctl: got PVFS_DEV_REMOUNT_ALL\\n\");",
          "666:   ret = mutex_lock_interruptible(&request_mutex);",
          "667:   if (ret < 0)",
          "668:    return ret;",
          "669:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "670:         \"pvfs2_devreq_ioctl: priority remount in progress\\n\");",
          "671:   list_for_each(tmp, &pvfs2_superblocks) {",
          "672:    pvfs2_sb =",
          "673:     list_entry(tmp, struct pvfs2_sb_info_s, list);",
          "674:    if (pvfs2_sb && (pvfs2_sb->sb)) {",
          "675:     gossip_debug(GOSSIP_DEV_DEBUG,",
          "676:           \"Remounting SB %p\\n\",",
          "677:           pvfs2_sb);",
          "679:     ret = pvfs2_remount(pvfs2_sb->sb);",
          "680:     if (ret) {",
          "681:      gossip_debug(GOSSIP_DEV_DEBUG,",
          "682:            \"SB %p remount failed\\n\",",
          "683:            pvfs2_sb);",
          "684:       break;",
          "685:     }",
          "686:    }",
          "687:   }",
          "688:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "689:         \"pvfs2_devreq_ioctl: priority remount complete\\n\");",
          "690:   mutex_unlock(&request_mutex);",
          "691:   return ret;",
          "693:  case PVFS_DEV_UPSTREAM:",
          "694:   ret = copy_to_user((void __user *)arg,",
          "695:         &upstream_kmod,",
          "696:         sizeof(upstream_kmod));",
          "698:   if (ret != 0)",
          "699:    return -EIO;",
          "700:   else",
          "701:    return ret;",
          "703:  case PVFS_DEV_CLIENT_MASK:",
          "704:   ret = copy_from_user(&mask2_info,",
          "705:          (void __user *)arg,",
          "706:          sizeof(struct dev_mask2_info_s));",
          "708:   if (ret != 0)",
          "709:    return -EIO;",
          "711:   client_debug_mask.mask1 = mask2_info.mask1_value;",
          "712:   client_debug_mask.mask2 = mask2_info.mask2_value;",
          "714:   pr_info(\"%s: client debug mask has been been received \"",
          "715:    \":%llx: :%llx:\\n\",",
          "716:    __func__,",
          "717:    (unsigned long long)client_debug_mask.mask1,",
          "718:    (unsigned long long)client_debug_mask.mask2);",
          "720:   return ret;",
          "722:  case PVFS_DEV_CLIENT_STRING:",
          "723:   ret = copy_from_user(&client_debug_array_string,",
          "724:          (void __user *)arg,",
          "725:          PVFS2_MAX_DEBUG_STRING_LEN);",
          "726:   if (ret != 0) {",
          "727:    pr_info(\"%s: \"",
          "728:     \"PVFS_DEV_CLIENT_STRING: copy_from_user failed\"",
          "729:     \"\\n\",",
          "730:     __func__);",
          "731:    return -EIO;",
          "732:   }",
          "734:   pr_info(\"%s: client debug array string has been been received.\"",
          "735:    \"\\n\",",
          "736:    __func__);",
          "738:   if (!help_string_initialized) {",
          "741:    kfree(debug_help_string);",
          "744:    if (orangefs_prepare_debugfs_help_string(0)) {",
          "745:     gossip_err(\"%s: \"",
          "746:         \"prepare_debugfs_help_string failed\"",
          "747:         \"\\n\",",
          "748:         __func__);",
          "749:     return -EIO;",
          "750:    }",
          "753:    debugfs_remove(help_file_dentry);",
          "755:    help_file_dentry =",
          "756:     debugfs_create_file(",
          "757:      ORANGEFS_KMOD_DEBUG_HELP_FILE,",
          "758:      0444,",
          "759:      debug_dir,",
          "760:      debug_help_string,",
          "761:      &debug_help_fops);",
          "763:    if (!help_file_dentry) {",
          "764:     gossip_err(\"%s: debugfs_create_file failed for\"",
          "765:         \" :%s:!\\n\",",
          "766:         __func__,",
          "767:         ORANGEFS_KMOD_DEBUG_HELP_FILE);",
          "768:     return -EIO;",
          "769:    }",
          "770:   }",
          "772:   debug_mask_to_string(&client_debug_mask, 1);",
          "774:   debugfs_remove(client_debug_dentry);",
          "776:   pvfs2_client_debug_init();",
          "778:   help_string_initialized++;",
          "780:   return ret;",
          "782:  case PVFS_DEV_DEBUG:",
          "783:   ret = copy_from_user(&mask_info,",
          "784:          (void __user *)arg,",
          "785:          sizeof(mask_info));",
          "787:   if (ret != 0)",
          "788:    return -EIO;",
          "790:   if (mask_info.mask_type == KERNEL_MASK) {",
          "791:    if ((mask_info.mask_value == 0)",
          "792:        && (kernel_mask_set_mod_init)) {",
          "799:     return 0;",
          "800:    }",
          "801:    debug_mask_to_string(&mask_info.mask_value,",
          "802:           mask_info.mask_type);",
          "803:    gossip_debug_mask = mask_info.mask_value;",
          "804:    pr_info(\"PVFS: kernel debug mask has been modified to \"",
          "805:     \":%s: :%llx:\\n\",",
          "806:     kernel_debug_string,",
          "807:     (unsigned long long)gossip_debug_mask);",
          "808:   } else if (mask_info.mask_type == CLIENT_MASK) {",
          "809:    debug_mask_to_string(&mask_info.mask_value,",
          "810:           mask_info.mask_type);",
          "811:    pr_info(\"PVFS: client debug mask has been modified to\"",
          "812:     \":%s: :%llx:\\n\",",
          "813:     client_debug_string,",
          "814:     llu(mask_info.mask_value));",
          "815:   } else {",
          "816:    gossip_lerr(\"Invalid mask type....\\n\");",
          "817:    return -EINVAL;",
          "818:   }",
          "820:   return ret;",
          "822:  default:",
          "823:   return -ENOIOCTLCMD;",
          "824:  }",
          "825:  return -ENOIOCTLCMD;",
          "826: }",
          "828: static long pvfs2_devreq_ioctl(struct file *file,",
          "829:           unsigned int command, unsigned long arg)",
          "830: {",
          "831:  long ret;",
          "834:  ret = check_ioctl_command(command);",
          "835:  if (ret < 0)",
          "836:   return (int)ret;",
          "838:  return (int)dispatch_ioctl_command(command, arg);",
          "839: }",
          "844: struct PVFS_dev_map_desc32 {",
          "845:  compat_uptr_t ptr;",
          "846:  __s32 total_size;",
          "847:  __s32 size;",
          "848:  __s32 count;",
          "849: };",
          "851: static unsigned long translate_dev_map26(unsigned long args, long *error)",
          "852: {",
          "853:  struct PVFS_dev_map_desc32 __user *p32 = (void __user *)args;",
          "858:  struct PVFS_dev_map_desc __user *p =",
          "859:      compat_alloc_user_space(sizeof(*p));",
          "860:  u32 addr;",
          "864:  if (get_user(addr, &p32->ptr))",
          "865:   goto err;",
          "867:  if (put_user(compat_ptr(addr), &p->ptr))",
          "868:   goto err;",
          "870:  if (copy_in_user(&p->total_size, &p32->total_size, sizeof(__s32)))",
          "871:   goto err;",
          "872:  if (copy_in_user(&p->size, &p32->size, sizeof(__s32)))",
          "873:   goto err;",
          "874:  if (copy_in_user(&p->count, &p32->count, sizeof(__s32)))",
          "875:   goto err;",
          "876:  return (unsigned long)p;",
          "877: err:",
          "879:  return 0;",
          "880: }",
          "886: static long pvfs2_devreq_compat_ioctl(struct file *filp, unsigned int cmd,",
          "887:           unsigned long args)",
          "888: {",
          "889:  long ret;",
          "890:  unsigned long arg = args;",
          "893:  ret = check_ioctl_command(cmd);",
          "894:  if (ret < 0)",
          "895:   return ret;",
          "896:  if (cmd == PVFS_DEV_MAP) {",
          "901:   arg = translate_dev_map26(args, &ret);",
          "902:   if (ret < 0) {",
          "903:    gossip_err(\"Could not translate dev map\\n\");",
          "904:    return ret;",
          "905:   }",
          "906:  }",
          "908:  return dispatch_ioctl_command(cmd, arg);",
          "909: }",
          "911: static int pvfs2_ioctl32_init(void)",
          "912: {",
          "913:  return 0;",
          "914: }",
          "916: static void pvfs2_ioctl32_cleanup(void)",
          "917: {",
          "918:  return;",
          "919: }",
          "924: static int pvfs2_dev_major;",
          "930: int pvfs2_dev_init(void)",
          "931: {",
          "932:  int ret;",
          "935:  ret = pvfs2_ioctl32_init();",
          "936:  if (ret < 0)",
          "937:   return ret;",
          "940:  pvfs2_dev_major = register_chrdev(0,",
          "941:        PVFS2_REQDEVICE_NAME,",
          "942:        &pvfs2_devreq_file_operations);",
          "943:  if (pvfs2_dev_major < 0) {",
          "944:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "945:         \"Failed to register /dev/%s (error %d)\\n\",",
          "946:         PVFS2_REQDEVICE_NAME, pvfs2_dev_major);",
          "947:   pvfs2_ioctl32_cleanup();",
          "948:   return pvfs2_dev_major;",
          "949:  }",
          "951:  gossip_debug(GOSSIP_DEV_DEBUG,",
          "952:        \"*** /dev/%s character device registered ***\\n\",",
          "953:        PVFS2_REQDEVICE_NAME);",
          "954:  gossip_debug(GOSSIP_DEV_DEBUG, \"'mknod /dev/%s c %d 0'.\\n\",",
          "955:        PVFS2_REQDEVICE_NAME, pvfs2_dev_major);",
          "956:  return 0;",
          "957: }",
          "959: void pvfs2_dev_cleanup(void)",
          "960: {",
          "961:  unregister_chrdev(pvfs2_dev_major, PVFS2_REQDEVICE_NAME);",
          "962:  gossip_debug(GOSSIP_DEV_DEBUG,",
          "963:        \"*** /dev/%s character device unregistered ***\\n\",",
          "964:        PVFS2_REQDEVICE_NAME);",
          "966:  pvfs2_ioctl32_cleanup();",
          "967: }",
          "969: static unsigned int pvfs2_devreq_poll(struct file *file,",
          "970:           struct poll_table_struct *poll_table)",
          "971: {",
          "972:  int poll_revent_mask = 0;",
          "974:  if (open_access_count == 1) {",
          "975:   poll_wait(file, &pvfs2_request_list_waitq, poll_table);",
          "977:   spin_lock(&pvfs2_request_list_lock);",
          "978:   if (!list_empty(&pvfs2_request_list))",
          "979:    poll_revent_mask |= POLL_IN;",
          "980:   spin_unlock(&pvfs2_request_list_lock);",
          "981:  }",
          "982:  return poll_revent_mask;",
          "983: }",
          "985: const struct file_operations pvfs2_devreq_file_operations = {",
          "986:  .owner = THIS_MODULE,",
          "987:  .read = pvfs2_devreq_read,",
          "988:  .write_iter = pvfs2_devreq_write_iter,",
          "989:  .open = pvfs2_devreq_open,",
          "990:  .release = pvfs2_devreq_release,",
          "991:  .unlocked_ioctl = pvfs2_devreq_ioctl,",
          "994:  .compat_ioctl = pvfs2_devreq_compat_ioctl,",
          "995: #endif",
          "996:  .poll = pvfs2_devreq_poll",
          "997: };",
          "",
          "---------------"
        ],
        "fs/orangefs/dir.c||fs/orangefs/dir.c": [
          "File: fs/orangefs/dir.c -> fs/orangefs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include \"protocol.h\"",
          "8: #include \"pvfs2-kernel.h\"",
          "9: #include \"pvfs2-bufmap.h\"",
          "11: struct readdir_handle_s {",
          "12:  int buffer_index;",
          "13:  struct pvfs2_readdir_response_s readdir_response;",
          "14:  void *dents_buf;",
          "15: };",
          "20: static long decode_dirents(char *ptr, struct pvfs2_readdir_response_s *readdir)",
          "21: {",
          "22:  int i;",
          "23:  struct pvfs2_readdir_response_s *rd =",
          "24:   (struct pvfs2_readdir_response_s *) ptr;",
          "25:  char *buf = ptr;",
          "26:  char **pptr = &buf;",
          "28:  readdir->token = rd->token;",
          "29:  readdir->pvfs_dirent_outcount = rd->pvfs_dirent_outcount;",
          "30:  readdir->dirent_array = kmalloc(readdir->pvfs_dirent_outcount *",
          "31:      sizeof(*readdir->dirent_array),",
          "32:      GFP_KERNEL);",
          "33:  if (readdir->dirent_array == NULL)",
          "34:   return -ENOMEM;",
          "36:  for (i = 0; i < readdir->pvfs_dirent_outcount; i++) {",
          "37:   dec_string(pptr, &readdir->dirent_array[i].d_name,",
          "38:       &readdir->dirent_array[i].d_length);",
          "39:   readdir->dirent_array[i].khandle =",
          "42:  }",
          "43:  return (unsigned long)*pptr - (unsigned long)ptr;",
          "44: }",
          "46: static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,",
          "47:     int buffer_index)",
          "48: {",
          "49:  long ret;",
          "51:  if (buf == NULL) {",
          "52:   gossip_err",
          "53:       (\"Invalid NULL buffer specified in readdir_handle_ctor\\n\");",
          "54:   return -ENOMEM;",
          "55:  }",
          "56:  if (buffer_index < 0) {",
          "57:   gossip_err",
          "58:       (\"Invalid buffer index specified in readdir_handle_ctor\\n\");",
          "59:   return -EINVAL;",
          "60:  }",
          "61:  rhandle->buffer_index = buffer_index;",
          "62:  rhandle->dents_buf = buf;",
          "63:  ret = decode_dirents(buf, &rhandle->readdir_response);",
          "64:  if (ret < 0) {",
          "65:   gossip_err(\"Could not decode readdir from buffer %ld\\n\", ret);",
          "66:   rhandle->buffer_index = -1;",
          "67:   gossip_debug(GOSSIP_DIR_DEBUG, \"vfree %p\\n\", buf);",
          "68:   vfree(buf);",
          "69:   rhandle->dents_buf = NULL;",
          "70:  }",
          "71:  return ret;",
          "72: }",
          "74: static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,",
          "75:   struct readdir_handle_s *rhandle)",
          "76: {",
          "77:  if (rhandle == NULL)",
          "78:   return;",
          "81:  kfree(rhandle->readdir_response.dirent_array);",
          "82:  rhandle->readdir_response.dirent_array = NULL;",
          "84:  if (rhandle->buffer_index >= 0) {",
          "85:   readdir_index_put(bufmap, rhandle->buffer_index);",
          "86:   rhandle->buffer_index = -1;",
          "87:  }",
          "88:  if (rhandle->dents_buf) {",
          "89:   gossip_debug(GOSSIP_DIR_DEBUG, \"vfree %p\\n\",",
          "90:         rhandle->dents_buf);",
          "91:   vfree(rhandle->dents_buf);",
          "92:   rhandle->dents_buf = NULL;",
          "93:  }",
          "94: }",
          "114: static int pvfs2_readdir(struct file *file, struct dir_context *ctx)",
          "115: {",
          "116:  struct pvfs2_bufmap *bufmap = NULL;",
          "117:  int ret = 0;",
          "118:  int buffer_index;",
          "119:  __u64 *ptoken = file->private_data;",
          "120:  __u64 pos = 0;",
          "121:  ino_t ino = 0;",
          "122:  struct dentry *dentry = file->f_path.dentry;",
          "123:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "124:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(dentry->d_inode);",
          "125:  int buffer_full = 0;",
          "126:  struct readdir_handle_s rhandle;",
          "127:  int i = 0;",
          "128:  int len = 0;",
          "129:  ino_t current_ino = 0;",
          "130:  char *current_entry = NULL;",
          "131:  long bytes_decoded;",
          "133:  gossip_ldebug(GOSSIP_DIR_DEBUG,",
          "134:         \"%s: ctx->pos:%lld, token = %llu\\n\",",
          "135:         __func__,",
          "136:         lld(ctx->pos),",
          "137:         llu(*ptoken));",
          "139:  pos = (__u64) ctx->pos;",
          "142:  if (pos == PVFS_READDIR_END) {",
          "143:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "144:         \"Skipping to termination path\\n\");",
          "145:   return 0;",
          "146:  }",
          "148:  gossip_debug(GOSSIP_DIR_DEBUG,",
          "149:        \"pvfs2_readdir called on %s (pos=%llu)\\n\",",
          "150:        dentry->d_name.name, llu(pos));",
          "152:  rhandle.buffer_index = -1;",
          "153:  rhandle.dents_buf = NULL;",
          "154:  memset(&rhandle.readdir_response, 0, sizeof(rhandle.readdir_response));",
          "156:  new_op = op_alloc(PVFS2_VFS_OP_READDIR);",
          "157:  if (!new_op)",
          "158:   return -ENOMEM;",
          "160:  new_op->uses_shared_memory = 1;",
          "161:  new_op->upcall.req.readdir.refn = pvfs2_inode->refn;",
          "162:  new_op->upcall.req.readdir.max_dirent_count = MAX_DIRENT_COUNT_READDIR;",
          "164:  gossip_debug(GOSSIP_DIR_DEBUG,",
          "165:        \"%s: upcall.req.readdir.refn.khandle: %pU\\n\",",
          "166:        __func__,",
          "167:        &new_op->upcall.req.readdir.refn.khandle);",
          "179:  new_op->upcall.req.readdir.token = *ptoken;",
          "181: get_new_buffer_index:",
          "182:  ret = readdir_index_get(&bufmap, &buffer_index);",
          "183:  if (ret < 0) {",
          "184:   gossip_lerr(\"pvfs2_readdir: readdir_index_get() failure (%d)\\n\",",
          "185:        ret);",
          "186:   goto out_free_op;",
          "187:  }",
          "188:  new_op->upcall.req.readdir.buf_index = buffer_index;",
          "190:  ret = service_operation(new_op,",
          "191:     \"pvfs2_readdir\",",
          "192:     get_interruptible_flag(dentry->d_inode));",
          "194:  gossip_debug(GOSSIP_DIR_DEBUG,",
          "195:        \"Readdir downcall status is %d.  ret:%d\\n\",",
          "196:        new_op->downcall.status,",
          "197:        ret);",
          "199:  if (ret == -EAGAIN && op_state_purged(new_op)) {",
          "205:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "206:    \"%s: Getting new buffer_index for retry of readdir..\\n\",",
          "207:     __func__);",
          "208:   readdir_index_put(bufmap, buffer_index);",
          "209:   goto get_new_buffer_index;",
          "210:  }",
          "212:  if (ret == -EIO && op_state_purged(new_op)) {",
          "213:   gossip_err(\"%s: Client is down. Aborting readdir call.\\n\",",
          "214:    __func__);",
          "215:   readdir_index_put(bufmap, buffer_index);",
          "216:   goto out_free_op;",
          "217:  }",
          "219:  if (ret < 0 || new_op->downcall.status != 0) {",
          "220:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "221:         \"Readdir request failed.  Status:%d\\n\",",
          "222:         new_op->downcall.status);",
          "223:   readdir_index_put(bufmap, buffer_index);",
          "224:   if (ret >= 0)",
          "225:    ret = new_op->downcall.status;",
          "226:   goto out_free_op;",
          "227:  }",
          "229:  bytes_decoded =",
          "230:   readdir_handle_ctor(&rhandle,",
          "231:         new_op->downcall.trailer_buf,",
          "232:         buffer_index);",
          "233:  if (bytes_decoded < 0) {",
          "234:   gossip_err(\"pvfs2_readdir: Could not decode trailer buffer into a readdir response %d\\n\",",
          "235:    ret);",
          "236:   ret = bytes_decoded;",
          "237:   readdir_index_put(bufmap, buffer_index);",
          "238:   goto out_free_op;",
          "239:  }",
          "241:  if (bytes_decoded != new_op->downcall.trailer_size) {",
          "242:   gossip_err(\"pvfs2_readdir: # bytes decoded (%ld) != trailer size (%ld)\\n\",",
          "243:    bytes_decoded,",
          "244:    (long)new_op->downcall.trailer_size);",
          "245:   ret = -EINVAL;",
          "246:   goto out_destroy_handle;",
          "247:  }",
          "249:  if (pos == 0) {",
          "250:   ino = get_ino_from_khandle(dentry->d_inode);",
          "251:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "252:         \"%s: calling dir_emit of \\\".\\\" with pos = %llu\\n\",",
          "253:         __func__,",
          "254:         llu(pos));",
          "255:   ret = dir_emit(ctx, \".\", 1, ino, DT_DIR);",
          "256:   if (ret < 0)",
          "257:    goto out_destroy_handle;",
          "258:   ctx->pos++;",
          "259:   gossip_ldebug(GOSSIP_DIR_DEBUG,",
          "260:          \"%s: ctx->pos:%lld\\n\",",
          "261:          __func__,",
          "262:          lld(ctx->pos));",
          "263:   pos++;",
          "264:  }",
          "266:  if (pos == 1) {",
          "267:   ino = get_parent_ino_from_dentry(dentry);",
          "268:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "269:         \"%s: calling dir_emit of \\\"..\\\" with pos = %llu\\n\",",
          "270:         __func__,",
          "271:         llu(pos));",
          "272:   ret = dir_emit(ctx, \"..\", 2, ino, DT_DIR);",
          "273:   if (ret < 0)",
          "274:    goto out_destroy_handle;",
          "275:   ctx->pos++;",
          "276:   gossip_ldebug(GOSSIP_DIR_DEBUG,",
          "277:          \"%s: ctx->pos:%lld\\n\",",
          "278:          __func__,",
          "279:          lld(ctx->pos));",
          "280:   pos++;",
          "281:  }",
          "283:  for (i = 0; i < rhandle.readdir_response.pvfs_dirent_outcount; i++) {",
          "284:   len = rhandle.readdir_response.dirent_array[i].d_length;",
          "285:   current_entry = rhandle.readdir_response.dirent_array[i].d_name;",
          "286:   current_ino = pvfs2_khandle_to_ino(",
          "287:    &(rhandle.readdir_response.dirent_array[i].khandle));",
          "289:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "290:         \"calling dir_emit for %s with len %d, pos %ld\\n\",",
          "291:         current_entry,",
          "292:         len,",
          "293:         (unsigned long)pos);",
          "294:   ret =",
          "295:       dir_emit(ctx, current_entry, len, current_ino, DT_UNKNOWN);",
          "296:   if (ret < 0) {",
          "297:    gossip_debug(GOSSIP_DIR_DEBUG,",
          "298:          \"dir_emit() failed. ret:%d\\n\",",
          "299:          ret);",
          "300:    if (i < 2) {",
          "301:     gossip_err(\"dir_emit failed on one of the first two true PVFS directory entries.\\n\");",
          "302:     gossip_err(\"Duplicate entries may appear.\\n\");",
          "303:    }",
          "304:    buffer_full = 1;",
          "305:    break;",
          "306:   }",
          "307:   ctx->pos++;",
          "308:   gossip_ldebug(GOSSIP_DIR_DEBUG,",
          "309:          \"%s: ctx->pos:%lld\\n\",",
          "310:          __func__,",
          "311:          lld(ctx->pos));",
          "313:   pos++;",
          "314:  }",
          "317:  if (i == rhandle.readdir_response.pvfs_dirent_outcount) {",
          "320:  } else {",
          "322:   if (rhandle.readdir_response.token == PVFS_READDIR_END) {",
          "330:    ctx->pos -= 3;",
          "331:   } else {",
          "336:    pos -= (i - 1);",
          "337:    ctx->pos -= (i - 1);",
          "338:   }",
          "339:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "340:    \"at least one dir_emit call failed. Setting ctx->pos to: %lld\\n\",",
          "341:    lld(ctx->pos));",
          "342:  }",
          "347:  if (rhandle.readdir_response.token == PVFS_READDIR_END &&",
          "348:      !buffer_full) {",
          "349:   gossip_debug(GOSSIP_DIR_DEBUG, \"End of dir detected; setting ctx->pos to PVFS_READDIR_END.\\n\");",
          "350:   ctx->pos = PVFS_READDIR_END;",
          "351:  }",
          "353:  gossip_debug(GOSSIP_DIR_DEBUG,",
          "354:        \"pos = %llu, token = %llu\"",
          "355:        \", ctx->pos should have been %lld\\n\",",
          "356:        llu(pos),",
          "357:        llu(*ptoken),",
          "358:        lld(ctx->pos));",
          "360: out_destroy_handle:",
          "361:  readdir_handle_dtor(bufmap, &rhandle);",
          "362: out_free_op:",
          "363:  op_release(new_op);",
          "364:  gossip_debug(GOSSIP_DIR_DEBUG, \"pvfs2_readdir returning %d\\n\", ret);",
          "365:  return ret;",
          "366: }",
          "368: static int pvfs2_dir_open(struct inode *inode, struct file *file)",
          "369: {",
          "370:  __u64 *ptoken;",
          "372:  file->private_data = kmalloc(sizeof(__u64), GFP_KERNEL);",
          "373:  if (!file->private_data)",
          "374:   return -ENOMEM;",
          "376:  ptoken = file->private_data;",
          "378:  return 0;",
          "379: }",
          "381: static int pvfs2_dir_release(struct inode *inode, struct file *file)",
          "382: {",
          "383:  pvfs2_flush_inode(inode);",
          "384:  kfree(file->private_data);",
          "385:  return 0;",
          "386: }",
          "389: const struct file_operations pvfs2_dir_operations = {",
          "390:  .read = generic_read_dir,",
          "391:  .iterate = pvfs2_readdir,",
          "392:  .open = pvfs2_dir_open,",
          "393:  .release = pvfs2_dir_release,",
          "394: };",
          "",
          "---------------"
        ],
        "fs/orangefs/file.c||fs/orangefs/file.c": [
          "File: fs/orangefs/file.c -> fs/orangefs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"protocol.h\"",
          "12: #include \"pvfs2-kernel.h\"",
          "13: #include \"pvfs2-bufmap.h\"",
          "14: #include <linux/fs.h>",
          "15: #include <linux/pagemap.h>",
          "17: #define wake_up_daemon_for_return(op)   \\",
          "18: do {       \\",
          "19:  spin_lock(&op->lock);                           \\",
          "20:  op->io_completed = 1;                           \\",
          "21:  spin_unlock(&op->lock);                         \\",
          "22:  wake_up_interruptible(&op->io_completion_waitq);\\",
          "23: } while (0)",
          "32: static int precopy_buffers(struct pvfs2_bufmap *bufmap,",
          "33:       int buffer_index,",
          "34:       const struct iovec *vec,",
          "35:       unsigned long nr_segs,",
          "36:       size_t total_size,",
          "37:       int from_user)",
          "38: {",
          "39:  int ret = 0;",
          "46:  if (from_user)",
          "47:   ret = pvfs_bufmap_copy_iovec_from_user(",
          "48:    bufmap,",
          "49:    buffer_index,",
          "50:    vec,",
          "51:    nr_segs,",
          "52:    total_size);",
          "54:  else",
          "55:   ret = pvfs_bufmap_copy_iovec_from_kernel(",
          "56:    bufmap,",
          "57:    buffer_index,",
          "58:    vec,",
          "59:    nr_segs,",
          "60:    total_size);",
          "61:  if (ret < 0)",
          "62:   gossip_err(\"%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\\n\",",
          "63:    __func__,",
          "64:    (long)ret);",
          "65:  return ret;",
          "66: }",
          "75: static int postcopy_buffers(struct pvfs2_bufmap *bufmap,",
          "76:        int buffer_index,",
          "77:        const struct iovec *vec,",
          "78:        int nr_segs,",
          "79:        size_t total_size,",
          "80:        int to_user)",
          "81: {",
          "82:  int ret = 0;",
          "89:  if (total_size) {",
          "91:   if (to_user)",
          "92:    ret = pvfs_bufmap_copy_to_user_iovec(",
          "93:     bufmap,",
          "94:     buffer_index,",
          "95:     vec,",
          "96:     nr_segs,",
          "97:     total_size);",
          "99:   else",
          "100:    ret = pvfs_bufmap_copy_to_kernel_iovec(",
          "101:     bufmap,",
          "102:     buffer_index,",
          "103:     vec,",
          "104:     nr_segs,",
          "105:     total_size);",
          "106:   if (ret < 0)",
          "107:    gossip_err(\"%s: Failed to copy-out buffers.  Please make sure that the pvfs2-client is running (%ld)\\n\",",
          "108:     __func__,",
          "109:     (long)ret);",
          "110:  }",
          "111:  return ret;",
          "112: }",
          "117: static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,",
          "118:   loff_t *offset, struct iovec *vec, unsigned long nr_segs,",
          "119:   size_t total_size, loff_t readahead_size, int to_user)",
          "120: {",
          "121:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "122:  struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;",
          "123:  struct pvfs2_bufmap *bufmap = NULL;",
          "124:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "125:  int buffer_index = -1;",
          "126:  ssize_t ret;",
          "128:  new_op = op_alloc(PVFS2_VFS_OP_FILE_IO);",
          "129:  if (!new_op) {",
          "130:   ret = -ENOMEM;",
          "131:   goto out;",
          "132:  }",
          "134:  new_op->upcall.req.io.async_vfs_io = PVFS_VFS_SYNC_IO;",
          "135:  new_op->upcall.req.io.readahead_size = readahead_size;",
          "136:  new_op->upcall.req.io.io_type = type;",
          "137:  new_op->upcall.req.io.refn = pvfs2_inode->refn;",
          "139: populate_shared_memory:",
          "141:  ret = pvfs_bufmap_get(&bufmap, &buffer_index);",
          "142:  if (ret < 0) {",
          "143:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "144:         \"%s: pvfs_bufmap_get failure (%ld)\\n\",",
          "145:         __func__, (long)ret);",
          "146:   goto out;",
          "147:  }",
          "148:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "149:        \"%s(%pU): GET op %p -> buffer_index %d\\n\",",
          "150:        __func__,",
          "151:        handle,",
          "152:        new_op,",
          "153:        buffer_index);",
          "155:  new_op->uses_shared_memory = 1;",
          "156:  new_op->upcall.req.io.buf_index = buffer_index;",
          "157:  new_op->upcall.req.io.count = total_size;",
          "158:  new_op->upcall.req.io.offset = *offset;",
          "160:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "161:        \"%s(%pU): copy_to_user %d nr_segs %lu, offset: %llu total_size: %zd\\n\",",
          "162:        __func__,",
          "163:        handle,",
          "164:        to_user,",
          "165:        nr_segs,",
          "166:        llu(*offset),",
          "167:        total_size);",
          "172:  if (type == PVFS_IO_WRITE) {",
          "173:   ret = precopy_buffers(bufmap,",
          "174:           buffer_index,",
          "175:           vec,",
          "176:           nr_segs,",
          "177:           total_size,",
          "178:           to_user);",
          "179:   if (ret < 0)",
          "180:    goto out;",
          "181:  }",
          "183:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "184:        \"%s(%pU): Calling post_io_request with tag (%llu)\\n\",",
          "185:        __func__,",
          "186:        handle,",
          "187:        llu(new_op->tag));",
          "190:  ret = service_operation(new_op,",
          "191:     type == PVFS_IO_WRITE ?",
          "192:      \"file_write\" :",
          "193:      \"file_read\",",
          "194:     get_interruptible_flag(inode));",
          "205:  if (ret == -EAGAIN && op_state_purged(new_op)) {",
          "206:   pvfs_bufmap_put(bufmap, buffer_index);",
          "207:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "208:         \"%s:going to repopulate_shared_memory.\\n\",",
          "209:         __func__);",
          "210:   goto populate_shared_memory;",
          "211:  }",
          "213:  if (ret < 0) {",
          "216:      don't write an error to syslog on signaled operation",
          "217:      termination unless we've got debugging turned on, as",
          "218:      this can happen regularly (i.e. ctrl-c)",
          "220:   if (ret == -EINTR)",
          "221:    gossip_debug(GOSSIP_FILE_DEBUG,",
          "222:          \"%s: returning error %ld\\n\", __func__,",
          "223:          (long)ret);",
          "224:   else",
          "225:    gossip_err(\"%s: error in %s handle %pU, returning %zd\\n\",",
          "226:     __func__,",
          "227:     type == PVFS_IO_READ ?",
          "228:      \"read from\" : \"write to\",",
          "229:     handle, ret);",
          "230:   goto out;",
          "231:  }",
          "237:  if (type == PVFS_IO_READ) {",
          "238:   ret = postcopy_buffers(bufmap,",
          "239:            buffer_index,",
          "240:            vec,",
          "241:            nr_segs,",
          "242:            new_op->downcall.resp.io.amt_complete,",
          "243:            to_user);",
          "244:   if (ret < 0) {",
          "249:    new_op->downcall.status = ret;",
          "250:    handle_io_error();",
          "251:    goto out;",
          "252:   }",
          "253:  }",
          "254:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "255:      \"%s(%pU): Amount written as returned by the sys-io call:%d\\n\",",
          "256:      __func__,",
          "257:      handle,",
          "258:      (int)new_op->downcall.resp.io.amt_complete);",
          "260:  ret = new_op->downcall.resp.io.amt_complete;",
          "263:     tell the device file owner waiting on I/O that this read has",
          "264:     completed and it can return now.  in this exact case, on",
          "265:     wakeup the daemon will free the op, so we *cannot* touch it",
          "266:     after this.",
          "268:  wake_up_daemon_for_return(new_op);",
          "269:  new_op = NULL;",
          "271: out:",
          "272:  if (buffer_index >= 0) {",
          "273:   pvfs_bufmap_put(bufmap, buffer_index);",
          "274:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "275:         \"%s(%pU): PUT buffer_index %d\\n\",",
          "276:         __func__, handle, buffer_index);",
          "277:   buffer_index = -1;",
          "278:  }",
          "279:  if (new_op) {",
          "280:   op_release(new_op);",
          "281:   new_op = NULL;",
          "282:  }",
          "283:  return ret;",
          "284: }",
          "308: {",
          "309:  unsigned long seg;",
          "310:  unsigned long count = 0;",
          "311:  unsigned long begin_seg;",
          "312:  unsigned long tmpnew_nr_segs = 0;",
          "313:  struct iovec *new_iovec = NULL;",
          "314:  struct iovec *orig_iovec;",
          "315:  unsigned long *sizes = NULL;",
          "316:  unsigned long sizes_count = 0;",
          "318:  if (nr_segs <= 0 ||",
          "319:      original_iovec == NULL ||",
          "320:      new_nr_segs == NULL ||",
          "321:      new_vec == NULL ||",
          "322:      seg_count == NULL ||",
          "323:      seg_array == NULL ||",
          "324:      max_new_nr_segs <= 0) {",
          "325:   gossip_err(\"Invalid parameters to split_iovecs\\n\");",
          "326:   return -EINVAL;",
          "327:  }",
          "333:  orig_iovec = kmalloc_array(nr_segs,",
          "334:        sizeof(*orig_iovec),",
          "335:        PVFS2_BUFMAP_GFP_FLAGS);",
          "336:  if (orig_iovec == NULL) {",
          "337:   gossip_err(",
          "338:       \"split_iovecs: Could not allocate memory for %lu bytes!\\n\",",
          "339:       (unsigned long)(nr_segs * sizeof(*orig_iovec)));",
          "340:   return -ENOMEM;",
          "341:  }",
          "342:  new_iovec = kcalloc(max_new_nr_segs,",
          "343:        sizeof(*new_iovec),",
          "344:        PVFS2_BUFMAP_GFP_FLAGS);",
          "345:  if (new_iovec == NULL) {",
          "346:   kfree(orig_iovec);",
          "347:   gossip_err(",
          "348:       \"split_iovecs: Could not allocate memory for %lu bytes!\\n\",",
          "349:       (unsigned long)(max_new_nr_segs * sizeof(*new_iovec)));",
          "350:   return -ENOMEM;",
          "351:  }",
          "352:  sizes = kcalloc(max_new_nr_segs,",
          "353:    sizeof(*sizes),",
          "354:    PVFS2_BUFMAP_GFP_FLAGS);",
          "355:  if (sizes == NULL) {",
          "356:   kfree(new_iovec);",
          "357:   kfree(orig_iovec);",
          "358:   gossip_err(",
          "359:       \"split_iovecs: Could not allocate memory for %lu bytes!\\n\",",
          "360:       (unsigned long)(max_new_nr_segs * sizeof(*sizes)));",
          "361:   return -ENOMEM;",
          "362:  }",
          "364:  memcpy(orig_iovec, original_iovec, nr_segs * sizeof(*orig_iovec));",
          "365:  begin_seg = 0;",
          "366: repeat:",
          "367:  for (seg = begin_seg; seg < nr_segs; seg++) {",
          "368:   if (tmpnew_nr_segs >= max_new_nr_segs ||",
          "369:       sizes_count >= max_new_nr_segs) {",
          "370:    kfree(sizes);",
          "371:    kfree(orig_iovec);",
          "372:    kfree(new_iovec);",
          "373:    gossip_err",
          "374:        (\"split_iovecs: exceeded the index limit (%lu)\\n\",",
          "375:        tmpnew_nr_segs);",
          "376:    return -EINVAL;",
          "377:   }",
          "378:   if (count + orig_iovec[seg].iov_len <",
          "379:       pvfs_bufmap_size_query()) {",
          "380:    count += orig_iovec[seg].iov_len;",
          "381:    memcpy(&new_iovec[tmpnew_nr_segs],",
          "382:           &orig_iovec[seg],",
          "383:           sizeof(*new_iovec));",
          "384:    tmpnew_nr_segs++;",
          "385:    sizes[sizes_count]++;",
          "386:   } else {",
          "387:    new_iovec[tmpnew_nr_segs].iov_base =",
          "388:        orig_iovec[seg].iov_base;",
          "389:    new_iovec[tmpnew_nr_segs].iov_len =",
          "390:        (pvfs_bufmap_size_query() - count);",
          "391:    tmpnew_nr_segs++;",
          "392:    sizes[sizes_count]++;",
          "393:    sizes_count++;",
          "394:    begin_seg = seg;",
          "395:    orig_iovec[seg].iov_base +=",
          "396:        (pvfs_bufmap_size_query() - count);",
          "397:    orig_iovec[seg].iov_len -=",
          "398:        (pvfs_bufmap_size_query() - count);",
          "399:    count = 0;",
          "400:    break;",
          "401:   }",
          "402:  }",
          "403:  if (seg != nr_segs)",
          "404:   goto repeat;",
          "405:  else",
          "406:   sizes_count++;",
          "414:  kfree(orig_iovec);",
          "415:  return 0;",
          "416: }",
          "418: static long bound_max_iovecs(const struct iovec *curr, unsigned long nr_segs,",
          "419:         ssize_t *total_count)",
          "420: {",
          "421:  unsigned long i;",
          "422:  long max_nr_iovecs;",
          "423:  ssize_t total;",
          "424:  ssize_t count;",
          "426:  total = 0;",
          "427:  count = 0;",
          "428:  max_nr_iovecs = 0;",
          "429:  for (i = 0; i < nr_segs; i++) {",
          "430:   const struct iovec *iv = &curr[i];",
          "432:   count += iv->iov_len;",
          "433:   if (unlikely((ssize_t) (count | iv->iov_len) < 0))",
          "434:    return -EINVAL;",
          "435:   if (total + iv->iov_len < pvfs_bufmap_size_query()) {",
          "436:    total += iv->iov_len;",
          "437:    max_nr_iovecs++;",
          "438:   } else {",
          "439:    total =",
          "440:        (total + iv->iov_len - pvfs_bufmap_size_query());",
          "441:    max_nr_iovecs += (total / pvfs_bufmap_size_query() + 2);",
          "442:   }",
          "443:  }",
          "445:  return max_nr_iovecs;",
          "446: }",
          "455: static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,",
          "456:   loff_t *offset, const struct iovec *iov, unsigned long nr_segs)",
          "457: {",
          "458:  struct inode *inode = file->f_mapping->host;",
          "459:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "460:  struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;",
          "461:  ssize_t ret;",
          "462:  ssize_t total_count;",
          "463:  unsigned int to_free;",
          "464:  size_t count;",
          "465:  unsigned long seg;",
          "466:  unsigned long new_nr_segs = 0;",
          "467:  unsigned long max_new_nr_segs = 0;",
          "468:  unsigned long seg_count = 0;",
          "469:  unsigned long *seg_array = NULL;",
          "470:  struct iovec *iovecptr = NULL;",
          "471:  struct iovec *ptr = NULL;",
          "473:  total_count = 0;",
          "474:  ret = -EINVAL;",
          "475:  count = 0;",
          "476:  to_free = 0;",
          "479:  max_new_nr_segs = bound_max_iovecs(iov, nr_segs, &count);",
          "480:  if (max_new_nr_segs < 0) {",
          "481:   gossip_lerr(\"%s: could not bound iovec %lu\\n\",",
          "482:        __func__,",
          "483:        max_new_nr_segs);",
          "484:   goto out;",
          "485:  }",
          "487:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "488:   \"%s-BEGIN(%pU): count(%d) after estimate_max_iovecs.\\n\",",
          "489:   __func__,",
          "490:   handle,",
          "491:   (int)count);",
          "493:  if (type == PVFS_IO_WRITE) {",
          "494:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "495:         \"%s(%pU): proceeding with offset : %llu, \"",
          "496:         \"size %d\\n\",",
          "497:         __func__,",
          "498:         handle,",
          "499:         llu(*offset),",
          "500:         (int)count);",
          "501:  }",
          "503:  if (count == 0) {",
          "504:   ret = 0;",
          "505:   goto out;",
          "506:  }",
          "514:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "515:        \"%s: pvfs_bufmap_size:%d\\n\",",
          "516:        __func__,",
          "517:        pvfs_bufmap_size_query());",
          "519:  if (count > pvfs_bufmap_size_query()) {",
          "535:   if (ret < 0) {",
          "536:    gossip_err(\"%s: Failed to split iovecs to satisfy larger than blocksize readv/writev request %zd\\n\",",
          "537:     __func__,",
          "538:     ret);",
          "539:    goto out;",
          "540:   }",
          "541:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "542:         \"%s: Splitting iovecs from %lu to %lu\"",
          "543:         \" [max_new %lu]\\n\",",
          "544:         __func__,",
          "545:         nr_segs,",
          "546:         new_nr_segs,",
          "547:         max_new_nr_segs);",
          "549:   to_free = 1;",
          "550:  } else {",
          "551:   new_nr_segs = nr_segs;",
          "553:   iovecptr = (struct iovec *)iov;",
          "555:   seg_count = 1;",
          "557:   seg_array = &nr_segs;",
          "559:   to_free = 0;",
          "560:  }",
          "561:  ptr = iovecptr;",
          "563:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "564:        \"%s(%pU) %zd@%llu\\n\",",
          "565:        __func__,",
          "566:        handle,",
          "567:        count,",
          "568:        llu(*offset));",
          "569:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "570:        \"%s(%pU): new_nr_segs: %lu, seg_count: %lu\\n\",",
          "571:        __func__,",
          "572:        handle,",
          "573:        new_nr_segs, seg_count);",
          "576: #ifdef PVFS2_KERNEL_DEBUG",
          "577:  for (seg = 0; seg < new_nr_segs; seg++)",
          "578:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "579:         \"%s: %d) %p to %p [%d bytes]\\n\",",
          "580:         __func__,",
          "581:         (int)seg + 1,",
          "582:         iovecptr[seg].iov_base,",
          "583:         iovecptr[seg].iov_base + iovecptr[seg].iov_len,",
          "584:         (int)iovecptr[seg].iov_len);",
          "585:  for (seg = 0; seg < seg_count; seg++)",
          "586:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "587:         \"%s: %zd) %lu\\n\",",
          "588:         __func__,",
          "589:         seg + 1,",
          "590:         seg_array[seg]);",
          "591: #endif",
          "592:  seg = 0;",
          "593:  while (total_count < count) {",
          "594:   size_t each_count;",
          "595:   size_t amt_complete;",
          "598:   each_count =",
          "599:      (((count - total_count) > pvfs_bufmap_size_query()) ?",
          "600:    pvfs_bufmap_size_query() :",
          "601:    (count - total_count));",
          "603:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "604:         \"%s(%pU): size of each_count(%d)\\n\",",
          "605:         __func__,",
          "606:         handle,",
          "607:         (int)each_count);",
          "608:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "609:         \"%s(%pU): BEFORE wait_for_io: offset is %d\\n\",",
          "610:         __func__,",
          "611:         handle,",
          "612:         (int)*offset);",
          "614:   ret = wait_for_direct_io(type, inode, offset, ptr,",
          "615:     seg_array[seg], each_count, 0, 1);",
          "616:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "617:         \"%s(%pU): return from wait_for_io:%d\\n\",",
          "618:         __func__,",
          "619:         handle,",
          "620:         (int)ret);",
          "622:   if (ret < 0)",
          "623:    goto out;",
          "626:   ptr += seg_array[seg];",
          "627:   seg++;",
          "629:   total_count += ret;",
          "630:   amt_complete = ret;",
          "632:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "633:         \"%s(%pU): AFTER wait_for_io: offset is %d\\n\",",
          "634:         __func__,",
          "635:         handle,",
          "636:         (int)*offset);",
          "642:   if (amt_complete < each_count)",
          "643:    break;",
          "646:  if (total_count > 0)",
          "647:   ret = total_count;",
          "648: out:",
          "649:  if (to_free) {",
          "650:   kfree(iovecptr);",
          "651:   kfree(seg_array);",
          "652:  }",
          "653:  if (ret > 0) {",
          "654:   if (type == PVFS_IO_READ) {",
          "655:    file_accessed(file);",
          "656:   } else {",
          "657:    SetMtimeFlag(pvfs2_inode);",
          "658:    inode->i_mtime = CURRENT_TIME;",
          "659:    mark_inode_dirty_sync(inode);",
          "660:   }",
          "661:  }",
          "663:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "664:        \"%s(%pU): Value(%d) returned.\\n\",",
          "665:        __func__,",
          "666:        handle,",
          "667:        (int)ret);",
          "669:  return ret;",
          "670: }",
          "676: ssize_t pvfs2_inode_read(struct inode *inode,",
          "677:     char __user *buf,",
          "678:     size_t count,",
          "679:     loff_t *offset,",
          "680:     loff_t readahead_size)",
          "681: {",
          "682:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "683:  size_t bufmap_size;",
          "684:  struct iovec vec;",
          "685:  ssize_t ret = -EINVAL;",
          "687:  g_pvfs2_stats.reads++;",
          "689:  vec.iov_base = buf;",
          "690:  vec.iov_len = count;",
          "692:  bufmap_size = pvfs_bufmap_size_query();",
          "693:  if (count > bufmap_size) {",
          "694:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "695:         \"%s: count is too large (%zd/%zd)!\\n\",",
          "696:         __func__, count, bufmap_size);",
          "697:   return -EINVAL;",
          "698:  }",
          "700:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "701:        \"%s(%pU) %zd@%llu\\n\",",
          "702:        __func__,",
          "703:        &pvfs2_inode->refn.khandle,",
          "704:        count,",
          "705:        llu(*offset));",
          "707:  ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, &vec, 1,",
          "708:    count, readahead_size, 0);",
          "709:  if (ret > 0)",
          "712:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "713:        \"%s(%pU): Value(%zd) returned.\\n\",",
          "714:        __func__,",
          "715:        &pvfs2_inode->refn.khandle,",
          "716:        ret);",
          "718:  return ret;",
          "719: }",
          "721: static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)",
          "722: {",
          "723:  struct file *file = iocb->ki_filp;",
          "724:  loff_t pos = *(&iocb->ki_pos);",
          "725:  ssize_t rc = 0;",
          "726:  unsigned long nr_segs = iter->nr_segs;",
          "728:  BUG_ON(iocb->private);",
          "730:  gossip_debug(GOSSIP_FILE_DEBUG, \"pvfs2_file_read_iter\\n\");",
          "732:  g_pvfs2_stats.reads++;",
          "734:  rc = do_readv_writev(PVFS_IO_READ,",
          "735:         file,",
          "736:         &pos,",
          "737:         iter->iov,",
          "738:         nr_segs);",
          "739:  iocb->ki_pos = pos;",
          "741:  return rc;",
          "742: }",
          "744: static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)",
          "745: {",
          "746:  struct file *file = iocb->ki_filp;",
          "747:  loff_t pos = *(&iocb->ki_pos);",
          "748:  unsigned long nr_segs = iter->nr_segs;",
          "749:  ssize_t rc;",
          "751:  BUG_ON(iocb->private);",
          "753:  gossip_debug(GOSSIP_FILE_DEBUG, \"pvfs2_file_write_iter\\n\");",
          "755:  mutex_lock(&file->f_mapping->host->i_mutex);",
          "758:  if (file->f_flags & O_APPEND) {",
          "759:   rc = pvfs2_inode_getattr(file->f_mapping->host,",
          "760:       PVFS_ATTR_SYS_SIZE);",
          "761:   if (rc) {",
          "762:    gossip_err(\"%s: pvfs2_inode_getattr failed, rc:%zd:.\\n\",",
          "763:        __func__, rc);",
          "764:    goto out;",
          "765:   }",
          "766:  }",
          "768:  if (file->f_pos > i_size_read(file->f_mapping->host))",
          "769:   pvfs2_i_size_write(file->f_mapping->host, file->f_pos);",
          "771:  rc = generic_write_checks(iocb, iter);",
          "773:  if (rc <= 0) {",
          "774:   gossip_err(\"%s: generic_write_checks failed, rc:%zd:.\\n\",",
          "775:       __func__, rc);",
          "776:   goto out;",
          "777:  }",
          "779:  rc = do_readv_writev(PVFS_IO_WRITE,",
          "780:         file,",
          "781:         &pos,",
          "782:         iter->iov,",
          "783:         nr_segs);",
          "784:  if (rc < 0) {",
          "785:   gossip_err(\"%s: do_readv_writev failed, rc:%zd:.\\n\",",
          "786:       __func__, rc);",
          "787:   goto out;",
          "788:  }",
          "790:  iocb->ki_pos = pos;",
          "791:  g_pvfs2_stats.writes++;",
          "793: out:",
          "795:  mutex_unlock(&file->f_mapping->host->i_mutex);",
          "796:  return rc;",
          "797: }",
          "802: long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
          "803: {",
          "804:  int ret = -ENOTTY;",
          "805:  __u64 val = 0;",
          "806:  unsigned long uval;",
          "808:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "809:        \"pvfs2_ioctl: called with cmd %d\\n\",",
          "810:        cmd);",
          "816:  if (cmd == FS_IOC_GETFLAGS) {",
          "817:   val = 0;",
          "818:   ret = pvfs2_xattr_get_default(file->f_path.dentry,",
          "819:            \"user.pvfs2.meta_hint\",",
          "820:            &val,",
          "821:            sizeof(val),",
          "822:            0);",
          "823:   if (ret < 0 && ret != -ENODATA)",
          "824:    return ret;",
          "825:   else if (ret == -ENODATA)",
          "826:    val = 0;",
          "827:   uval = val;",
          "828:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "829:         \"pvfs2_ioctl: FS_IOC_GETFLAGS: %llu\\n\",",
          "830:         (unsigned long long)uval);",
          "831:   return put_user(uval, (int __user *)arg);",
          "832:  } else if (cmd == FS_IOC_SETFLAGS) {",
          "833:   ret = 0;",
          "834:   if (get_user(uval, (int __user *)arg))",
          "835:    return -EFAULT;",
          "843:   if ((uval & ~PVFS_MIRROR_FL) &",
          "844:       (~(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NOATIME_FL))) {",
          "845:    gossip_err(\"pvfs2_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\\n\");",
          "846:    return -EINVAL;",
          "847:   }",
          "848:   val = uval;",
          "849:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "850:         \"pvfs2_ioctl: FS_IOC_SETFLAGS: %llu\\n\",",
          "851:         (unsigned long long)val);",
          "852:   ret = pvfs2_xattr_set_default(file->f_path.dentry,",
          "853:            \"user.pvfs2.meta_hint\",",
          "854:            &val,",
          "855:            sizeof(val),",
          "856:            0,",
          "857:            0);",
          "858:  }",
          "860:  return ret;",
          "861: }",
          "866: static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)",
          "867: {",
          "868:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "869:        \"pvfs2_file_mmap: called on %s\\n\",",
          "870:        (file ?",
          "871:    (char *)file->f_path.dentry->d_name.name :",
          "872:    (char *)\"Unknown\"));",
          "875:  vma->vm_flags |= VM_SEQ_READ;",
          "876:  vma->vm_flags &= ~VM_RAND_READ;",
          "877:  return generic_file_mmap(file, vma);",
          "878: }",
          "880: #define mapping_nrpages(idata) ((idata)->nrpages)",
          "888: int pvfs2_file_release(struct inode *inode, struct file *file)",
          "889: {",
          "890:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "891:        \"pvfs2_file_release: called on %s\\n\",",
          "892:        file->f_path.dentry->d_name.name);",
          "894:  pvfs2_flush_inode(inode);",
          "897:     remove all associated inode pages from the page cache and mmap",
          "898:     readahead cache (if any); this forces an expensive refresh of",
          "899:     data for the next caller of mmap (or 'get_block' accesses)",
          "901:  if (file->f_path.dentry->d_inode &&",
          "902:      file->f_path.dentry->d_inode->i_mapping &&",
          "903:      mapping_nrpages(&file->f_path.dentry->d_inode->i_data))",
          "904:   truncate_inode_pages(file->f_path.dentry->d_inode->i_mapping,",
          "905:          0);",
          "906:  return 0;",
          "907: }",
          "912: int pvfs2_fsync(struct file *file, loff_t start, loff_t end, int datasync)",
          "913: {",
          "914:  int ret = -EINVAL;",
          "915:  struct pvfs2_inode_s *pvfs2_inode =",
          "916:   PVFS2_I(file->f_path.dentry->d_inode);",
          "917:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "920:  filemap_write_and_wait_range(file->f_mapping, start, end);",
          "922:  new_op = op_alloc(PVFS2_VFS_OP_FSYNC);",
          "923:  if (!new_op)",
          "924:   return -ENOMEM;",
          "925:  new_op->upcall.req.fsync.refn = pvfs2_inode->refn;",
          "927:  ret = service_operation(new_op,",
          "928:    \"pvfs2_fsync\",",
          "929:    get_interruptible_flag(file->f_path.dentry->d_inode));",
          "931:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "932:        \"pvfs2_fsync got return value of %d\\n\",",
          "933:        ret);",
          "935:  op_release(new_op);",
          "937:  pvfs2_flush_inode(file->f_path.dentry->d_inode);",
          "938:  return ret;",
          "939: }",
          "950: loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)",
          "951: {",
          "952:  int ret = -EINVAL;",
          "953:  struct inode *inode = file->f_path.dentry->d_inode;",
          "955:  if (!inode) {",
          "956:   gossip_err(\"pvfs2_file_llseek: invalid inode (NULL)\\n\");",
          "957:   return ret;",
          "958:  }",
          "960:  if (origin == PVFS2_SEEK_END) {",
          "966:   ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_SIZE);",
          "967:   if (ret) {",
          "968:    gossip_debug(GOSSIP_FILE_DEBUG,",
          "969:          \"%s:%s:%d calling make bad inode\\n\",",
          "970:          __FILE__,",
          "971:          __func__,",
          "972:          __LINE__);",
          "973:    pvfs2_make_bad_inode(inode);",
          "974:    return ret;",
          "975:   }",
          "976:  }",
          "978:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "979:        \"pvfs2_file_llseek: offset is %ld | origin is %d | \"",
          "980:        \"inode size is %lu\\n\",",
          "981:        (long)offset,",
          "982:        origin,",
          "983:        (unsigned long)file->f_path.dentry->d_inode->i_size);",
          "985:  return generic_file_llseek(file, offset, origin);",
          "986: }",
          "992: int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)",
          "993: {",
          "994:  int rc = -ENOLCK;",
          "996:  if (PVFS2_SB(filp->f_inode->i_sb)->flags & PVFS2_OPT_LOCAL_LOCK) {",
          "997:   if (cmd == F_GETLK) {",
          "998:    rc = 0;",
          "999:    posix_test_lock(filp, fl);",
          "1000:   } else {",
          "1001:    rc = posix_lock_file(filp, fl, NULL);",
          "1002:   }",
          "1003:  }",
          "1005:  return rc;",
          "1006: }",
          "1009: const struct file_operations pvfs2_file_operations = {",
          "1010:  .llseek  = pvfs2_file_llseek,",
          "1011:  .read_iter = pvfs2_file_read_iter,",
          "1012:  .write_iter = pvfs2_file_write_iter,",
          "1013:  .lock  = pvfs2_lock,",
          "1014:  .unlocked_ioctl = pvfs2_ioctl,",
          "1015:  .mmap  = pvfs2_file_mmap,",
          "1016:  .open  = generic_file_open,",
          "1017:  .release = pvfs2_file_release,",
          "1018:  .fsync  = pvfs2_fsync,",
          "1019: };",
          "",
          "---------------"
        ],
        "fs/orangefs/inode.c||fs/orangefs/inode.c": [
          "File: fs/orangefs/inode.c -> fs/orangefs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"protocol.h\"",
          "12: #include \"pvfs2-kernel.h\"",
          "13: #include \"pvfs2-bufmap.h\"",
          "15: static int read_one_page(struct page *page)",
          "16: {",
          "17:  void *page_data;",
          "18:  int ret;",
          "19:  int max_block;",
          "20:  ssize_t bytes_read = 0;",
          "21:  struct inode *inode = page->mapping->host;",
          "25:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "26:       \"pvfs2_readpage called with page %p\\n\",",
          "27:        page);",
          "28:  page_data = pvfs2_kmap(page);",
          "30:  max_block = ((inode->i_size / blocksize) + 1);",
          "32:  if (page->index < max_block) {",
          "33:   loff_t blockptr_offset = (((loff_t) page->index) << blockbits);",
          "35:   bytes_read = pvfs2_inode_read(inode,",
          "36:            page_data,",
          "37:            blocksize,",
          "38:            &blockptr_offset,",
          "39:            inode->i_size);",
          "40:  }",
          "42:  if (bytes_read > 0)",
          "43:   memset(page_data + bytes_read, 0, blocksize - bytes_read);",
          "44:  else",
          "45:   memset(page_data, 0, blocksize);",
          "47:  flush_dcache_page(page);",
          "48:  if (bytes_read < 0) {",
          "49:   ret = bytes_read;",
          "50:   SetPageError(page);",
          "51:  } else {",
          "52:   SetPageUptodate(page);",
          "53:   if (PageError(page))",
          "54:    ClearPageError(page);",
          "55:   ret = 0;",
          "56:  }",
          "57:  pvfs2_kunmap(page);",
          "59:  unlock_page(page);",
          "60:  return ret;",
          "61: }",
          "63: static int pvfs2_readpage(struct file *file, struct page *page)",
          "64: {",
          "65:  return read_one_page(page);",
          "66: }",
          "68: static int pvfs2_readpages(struct file *file,",
          "69:       struct address_space *mapping,",
          "70:       struct list_head *pages,",
          "71:       unsigned nr_pages)",
          "72: {",
          "73:  int page_idx;",
          "74:  int ret;",
          "76:  gossip_debug(GOSSIP_INODE_DEBUG, \"pvfs2_readpages called\\n\");",
          "78:  for (page_idx = 0; page_idx < nr_pages; page_idx++) {",
          "79:   struct page *page;",
          "81:   page = list_entry(pages->prev, struct page, lru);",
          "82:   list_del(&page->lru);",
          "83:   if (!add_to_page_cache(page,",
          "84:            mapping,",
          "85:            page->index,",
          "86:            GFP_KERNEL)) {",
          "87:    ret = read_one_page(page);",
          "88:    gossip_debug(GOSSIP_INODE_DEBUG,",
          "89:     \"failure adding page to cache, read_one_page returned: %d\\n\",",
          "90:     ret);",
          "91:        } else {",
          "92:    page_cache_release(page);",
          "93:        }",
          "94:  }",
          "95:  BUG_ON(!list_empty(pages));",
          "96:  return 0;",
          "97: }",
          "99: static void pvfs2_invalidatepage(struct page *page,",
          "100:      unsigned int offset,",
          "101:      unsigned int length)",
          "102: {",
          "103:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "104:        \"pvfs2_invalidatepage called on page %p \"",
          "105:        \"(offset is %u)\\n\",",
          "106:        page,",
          "107:        offset);",
          "109:  ClearPageUptodate(page);",
          "110:  ClearPageMappedToDisk(page);",
          "111:  return;",
          "113: }",
          "115: static int pvfs2_releasepage(struct page *page, gfp_t foo)",
          "116: {",
          "117:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "118:        \"pvfs2_releasepage called on page %p\\n\",",
          "119:        page);",
          "120:  return 0;",
          "121: }",
          "131: static ssize_t pvfs2_direct_IO(int rw,",
          "132:    struct kiocb *iocb,",
          "133:    struct iov_iter *iter,",
          "134:    loff_t offset)",
          "135: {",
          "136:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "137:        \"pvfs2_direct_IO: %s\\n\",",
          "138:        iocb->ki_filp->f_path.dentry->d_name.name);",
          "140:  return -EINVAL;",
          "141: }",
          "144: struct backing_dev_info pvfs2_backing_dev_info = {",
          "145:  .name = \"pvfs2\",",
          "146:  .ra_pages = 0,",
          "147:  .capabilities = BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK,",
          "148: };",
          "151: const struct address_space_operations pvfs2_address_operations = {",
          "152:  .readpage = pvfs2_readpage,",
          "153:  .readpages = pvfs2_readpages,",
          "154:  .invalidatepage = pvfs2_invalidatepage,",
          "155:  .releasepage = pvfs2_releasepage,",
          "157: };",
          "159: static int pvfs2_setattr_size(struct inode *inode, struct iattr *iattr)",
          "160: {",
          "161:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "162:  struct pvfs2_kernel_op_s *new_op;",
          "163:  loff_t orig_size = i_size_read(inode);",
          "164:  int ret = -EINVAL;",
          "166:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "167:        \"%s: %pU: Handle is %pU | fs_id %d | size is %llu\\n\",",
          "168:        __func__,",
          "169:        get_khandle_from_ino(inode),",
          "170:        &pvfs2_inode->refn.khandle,",
          "171:        pvfs2_inode->refn.fs_id,",
          "172:        iattr->ia_size);",
          "174:  truncate_setsize(inode, iattr->ia_size);",
          "176:  new_op = op_alloc(PVFS2_VFS_OP_TRUNCATE);",
          "177:  if (!new_op)",
          "178:   return -ENOMEM;",
          "180:  new_op->upcall.req.truncate.refn = pvfs2_inode->refn;",
          "181:  new_op->upcall.req.truncate.size = (__s64) iattr->ia_size;",
          "183:  ret = service_operation(new_op, __func__,",
          "184:     get_interruptible_flag(inode));",
          "190:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "191:        \"pvfs2: pvfs2_truncate got return value of %d\\n\",",
          "192:        ret);",
          "194:  op_release(new_op);",
          "196:  if (ret != 0)",
          "197:   return ret;",
          "209:  if (orig_size != i_size_read(inode) &&",
          "210:      !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {",
          "211:   iattr->ia_ctime = iattr->ia_mtime =",
          "212:    current_fs_time(inode->i_sb);",
          "213:   iattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;",
          "214:  }",
          "216:  return ret;",
          "217: }",
          "222: int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr)",
          "223: {",
          "224:  int ret = -EINVAL;",
          "225:  struct inode *inode = dentry->d_inode;",
          "227:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "228:        \"pvfs2_setattr: called on %s\\n\",",
          "229:        dentry->d_name.name);",
          "231:  ret = inode_change_ok(inode, iattr);",
          "232:  if (ret)",
          "233:   goto out;",
          "235:  if ((iattr->ia_valid & ATTR_SIZE) &&",
          "236:      iattr->ia_size != i_size_read(inode)) {",
          "237:   ret = pvfs2_setattr_size(inode, iattr);",
          "238:   if (ret)",
          "239:    goto out;",
          "240:  }",
          "242:  setattr_copy(inode, iattr);",
          "243:  mark_inode_dirty(inode);",
          "245:  ret = pvfs2_inode_setattr(inode, iattr);",
          "246:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "247:        \"pvfs2_setattr: inode_setattr returned %d\\n\",",
          "248:        ret);",
          "250:  if (!ret && (iattr->ia_valid & ATTR_MODE))",
          "252:   ret = posix_acl_chmod(inode, inode->i_mode);",
          "254: out:",
          "255:  gossip_debug(GOSSIP_INODE_DEBUG, \"pvfs2_setattr: returning %d\\n\", ret);",
          "256:  return ret;",
          "257: }",
          "262: int pvfs2_getattr(struct vfsmount *mnt,",
          "263:     struct dentry *dentry,",
          "264:     struct kstat *kstat)",
          "265: {",
          "266:  int ret = -ENOENT;",
          "267:  struct inode *inode = dentry->d_inode;",
          "268:  struct pvfs2_inode_s *pvfs2_inode = NULL;",
          "270:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "271:        \"pvfs2_getattr: called on %s\\n\",",
          "272:        dentry->d_name.name);",
          "279:  ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "280:  if (ret == 0) {",
          "281:   generic_fillattr(inode, kstat);",
          "283:   pvfs2_inode = PVFS2_I(inode);",
          "284:   kstat->blksize = pvfs2_inode->blksize;",
          "285:  } else {",
          "287:   gossip_debug(GOSSIP_INODE_DEBUG,",
          "288:         \"%s:%s:%d calling make bad inode\\n\",",
          "289:         __FILE__,",
          "290:         __func__,",
          "291:         __LINE__);",
          "292:   pvfs2_make_bad_inode(inode);",
          "293:  }",
          "294:  return ret;",
          "295: }",
          "298: struct inode_operations pvfs2_file_inode_operations = {",
          "299:  .get_acl = pvfs2_get_acl,",
          "300:  .set_acl = pvfs2_set_acl,",
          "301:  .setattr = pvfs2_setattr,",
          "302:  .getattr = pvfs2_getattr,",
          "303:  .setxattr = generic_setxattr,",
          "304:  .getxattr = generic_getxattr,",
          "305:  .listxattr = pvfs2_listxattr,",
          "306:  .removexattr = generic_removexattr,",
          "307: };",
          "309: static int pvfs2_init_iops(struct inode *inode)",
          "310: {",
          "311:  inode->i_mapping->a_ops = &pvfs2_address_operations;",
          "313:  switch (inode->i_mode & S_IFMT) {",
          "314:  case S_IFREG:",
          "315:   inode->i_op = &pvfs2_file_inode_operations;",
          "316:   inode->i_fop = &pvfs2_file_operations;",
          "317:   inode->i_blkbits = PAGE_CACHE_SHIFT;",
          "318:   break;",
          "319:  case S_IFLNK:",
          "320:   inode->i_op = &pvfs2_symlink_inode_operations;",
          "321:   break;",
          "322:  case S_IFDIR:",
          "323:   inode->i_op = &pvfs2_dir_inode_operations;",
          "324:   inode->i_fop = &pvfs2_dir_operations;",
          "325:   break;",
          "326:  default:",
          "327:   gossip_debug(GOSSIP_INODE_DEBUG,",
          "328:         \"%s: unsupported mode\\n\",",
          "329:         __func__);",
          "330:   return -EINVAL;",
          "331:  }",
          "333:  return 0;",
          "334: }",
          "341: static inline ino_t pvfs2_handle_hash(struct pvfs2_object_kref *ref)",
          "342: {",
          "343:  if (!ref)",
          "344:   return 0;",
          "345:  return pvfs2_khandle_to_ino(&(ref->khandle));",
          "346: }",
          "351: static int pvfs2_set_inode(struct inode *inode, void *data)",
          "352: {",
          "353:  struct pvfs2_object_kref *ref = (struct pvfs2_object_kref *) data;",
          "354:  struct pvfs2_inode_s *pvfs2_inode = NULL;",
          "357:  if (!data || !inode)",
          "358:   return 0;",
          "359:  pvfs2_inode = PVFS2_I(inode);",
          "360:  if (!pvfs2_inode)",
          "361:   return 0;",
          "362:  pvfs2_inode->refn.fs_id = ref->fs_id;",
          "363:  pvfs2_inode->refn.khandle = ref->khandle;",
          "364:  return 0;",
          "365: }",
          "370: static int pvfs2_test_inode(struct inode *inode, void *data)",
          "371: {",
          "372:  struct pvfs2_object_kref *ref = (struct pvfs2_object_kref *) data;",
          "373:  struct pvfs2_inode_s *pvfs2_inode = NULL;",
          "375:  pvfs2_inode = PVFS2_I(inode);",
          "376:  return (!PVFS_khandle_cmp(&(pvfs2_inode->refn.khandle), &(ref->khandle))",
          "377:   && pvfs2_inode->refn.fs_id == ref->fs_id);",
          "378: }",
          "387: struct inode *pvfs2_iget(struct super_block *sb, struct pvfs2_object_kref *ref)",
          "388: {",
          "389:  struct inode *inode = NULL;",
          "390:  unsigned long hash;",
          "391:  int error;",
          "393:  hash = pvfs2_handle_hash(ref);",
          "394:  inode = iget5_locked(sb, hash, pvfs2_test_inode, pvfs2_set_inode, ref);",
          "395:  if (!inode || !(inode->i_state & I_NEW))",
          "396:   return inode;",
          "398:  error = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "399:  if (error) {",
          "400:   iget_failed(inode);",
          "401:   return ERR_PTR(error);",
          "402:  }",
          "405:  pvfs2_init_iops(inode);",
          "406:  unlock_new_inode(inode);",
          "408:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "409:        \"iget handle %pU, fsid %d hash %ld i_ino %lu\\n\",",
          "410:        &ref->khandle,",
          "411:        ref->fs_id,",
          "412:        hash,",
          "413:        inode->i_ino);",
          "415:  return inode;",
          "416: }",
          "421: struct inode *pvfs2_new_inode(struct super_block *sb, struct inode *dir,",
          "422:   int mode, dev_t dev, struct pvfs2_object_kref *ref)",
          "423: {",
          "424:  unsigned long hash = pvfs2_handle_hash(ref);",
          "425:  struct inode *inode;",
          "426:  int error;",
          "428:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "429:        \"pvfs2_get_custom_inode_common: called\\n\"",
          "430:        \"(sb is %p | MAJOR(dev)=%u | MINOR(dev)=%u mode=%o)\\n\",",
          "431:        sb,",
          "432:        MAJOR(dev),",
          "433:        MINOR(dev),",
          "434:        mode);",
          "436:  inode = new_inode(sb);",
          "437:  if (!inode)",
          "438:   return NULL;",
          "440:  pvfs2_set_inode(inode, ref);",
          "443:  error = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "444:  if (error)",
          "445:   goto out_iput;",
          "447:  pvfs2_init_iops(inode);",
          "449:  inode->i_mode = mode;",
          "450:  inode->i_uid = current_fsuid();",
          "451:  inode->i_gid = current_fsgid();",
          "452:  inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;",
          "453:  inode->i_size = PAGE_CACHE_SIZE;",
          "454:  inode->i_rdev = dev;",
          "456:  error = insert_inode_locked4(inode, hash, pvfs2_test_inode, ref);",
          "457:  if (error < 0)",
          "458:   goto out_iput;",
          "460:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "461:        \"Initializing ACL's for inode %pU\\n\",",
          "462:        get_khandle_from_ino(inode));",
          "463:  pvfs2_init_acl(inode, dir);",
          "464:  return inode;",
          "466: out_iput:",
          "467:  iput(inode);",
          "468:  return ERR_PTR(error);",
          "469: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-16643",
  "cve_desc": "The functions ReadDCMImage in coders/dcm.c, ReadPWPImage in coders/pwp.c, ReadCALSImage in coders/cals.c, and ReadPICTImage in coders/pict.c in ImageMagick 7.0.8-4 do not check the return value of the fputc function, which allows remote attackers to cause a denial of service via a crafted image file.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "6b6bff054d569a77973f2140c0e86366e6168a6c",
  "patch_info": {
    "commit_hash": "6b6bff054d569a77973f2140c0e86366e6168a6c",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c",
    "files": [
      "coders/cals.c",
      "coders/dcm.c",
      "coders/pict.c",
      "coders/pwp.c"
    ],
    "message": "https://github.com/ImageMagick/ImageMagick/issues/1199",
    "before_after_code_files": [
      "coders/cals.c||coders/cals.c",
      "coders/dcm.c||coders/dcm.c",
      "coders/pict.c||coders/pict.c",
      "coders/pwp.c||coders/pwp.c"
    ]
  },
  "patch_diff": {
    "coders/cals.c||coders/cals.c": [
      "File: coders/cals.c -> coders/cals.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "257:   file=(FILE *) NULL;",
      "258:   unique_file=AcquireUniqueFileResource(filename);",
      "259:   if (unique_file != -1)",
      "261:   if ((unique_file == -1) || (file == (FILE *) NULL))",
      "262:     ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");",
      "263:   while ((c=ReadBlobByte(image)) != EOF)",
      "",
      "[Removed Lines]",
      "260:     file=fdopen(unique_file,\"wb\");",
      "",
      "[Added Lines]",
      "260:     file=fdopen(unique_file,\"wb\");",
      "261:   if ((unique_file == -1) || (file == (FILE *) NULL))",
      "",
      "---------------"
    ],
    "coders/dcm.c||coders/dcm.c": [
      "File: coders/dcm.c -> coders/dcm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3228:       length=1;",
      "3229:       if (datum != 0)",
      "3230:         {",
      "3232:               (strncmp(implicit_vr,\"SS\",2) == 0) ||",
      "3233:               (strncmp(implicit_vr,\"US\",2) == 0))",
      "3234:             quantum=2;",
      "3235:           else",
      "3236:             if ((strncmp(implicit_vr,\"FL\",2) == 0) ||",
      "3238:                 (strncmp(implicit_vr,\"SL\",2) == 0) ||",
      "3239:                 (strncmp(implicit_vr,\"UL\",2) == 0))",
      "3240:               quantum=4;",
      "",
      "[Removed Lines]",
      "3231:           if ((strncmp(implicit_vr,\"OW\",2) == 0) ||",
      "3237:                 (strncmp(implicit_vr,\"OF\",2) == 0) ||",
      "",
      "[Added Lines]",
      "3231:           if ((strncmp(implicit_vr,\"OW\",2) == 0) ||",
      "3237:                 (strncmp(implicit_vr,\"OF\",2) == 0) ||",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3880:             c=ReadBlobByte(image);",
      "3881:             if (c == EOF)",
      "3882:               {",
      "3884:                   \"UnexpectedEndOfFile\",image->filename);",
      "3885:                 break;",
      "3886:               }",
      "",
      "[Removed Lines]",
      "3883:                 ThrowFileException(exception,CorruptImageError,",
      "",
      "[Added Lines]",
      "3883:                 ThrowFileException(exception,CorruptImageError,",
      "3884:                   \"UnexpectedEndOfFile\",image->filename);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3936:           Compute pixel scaling table.",
      "3938:         length=(size_t) (GetQuantumRange(info.depth)+1);",
      "3939:         if (length > (size_t) GetBlobSize(image))",
      "3940:           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "coders/pict.c||coders/pict.c": [
      "File: coders/pict.c -> coders/pict.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1472:               }",
      "1473:             for (i=0; i < 122; i++)",
      "1474:               if (ReadBlobByte(image) == EOF)",
      "1476:             for (i=0; i < (ssize_t) (length-154); i++)",
      "1477:             {",
      "1478:               c=ReadBlobByte(image);",
      "",
      "[Removed Lines]",
      "1475:                 break;",
      "",
      "[Added Lines]",
      "1475:                 break;",
      "1476:             for (i=0; i < (ssize_t) (length-154); i++)",
      "",
      "---------------"
    ],
    "coders/pwp.c||coders/pwp.c": [
      "File: coders/pwp.c -> coders/pwp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "233:     filesize=65535UL*magick[2]+256L*magick[1]+magick[0];",
      "234:     for (i=0; i < (ssize_t) filesize; i++)",
      "235:     {",
      "237:       if (c == EOF)",
      "238:         break;",
      "239:       (void) fputc(c,file);",
      "",
      "[Removed Lines]",
      "236:       c=ReadBlobByte(pwp_image);",
      "",
      "[Added Lines]",
      "236:       c=ReadBlobByte(pwp_image);",
      "237:       if (c == EOF)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c1b09bbec148f6ae11d0b686fdb89ac6dc0ab14e",
      "candidate_info": {
        "commit_hash": "c1b09bbec148f6ae11d0b686fdb89ac6dc0ab14e",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c1b09bbec148f6ae11d0b686fdb89ac6dc0ab14e",
        "files": [
          "coders/pict.c"
        ],
        "message": "https://github.com/ImageMagick/ImageMagick/issues/577",
        "before_after_code_files": [
          "coders/pict.c||coders/pict.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/pict.c||coders/pict.c"
          ],
          "candidate": [
            "coders/pict.c||coders/pict.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/pict.c||coders/pict.c": [
          "File: coders/pict.c -> coders/pict.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1744:     Allocate memory.",
          "1746:   bytes_per_line=image->columns;",
          "1748:     bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;",
          "1749:   buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));",
          "1750:   packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)",
          "",
          "[Removed Lines]",
          "1747:   if (storage_class == DirectClass)",
          "",
          "[Added Lines]",
          "1747:   if (storage_class == DirectClass)",
          "1748:     bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;",
          "1749:   buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));",
          "1750:   packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)",
          "1751:    (row_bytes+MaxCount),sizeof(*packed_scanline));",
          "1752:   scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));",
          "1753:   if ((buffer == (unsigned char *) NULL) ||",
          "1754:       (packed_scanline == (unsigned char *) NULL) ||",
          "1755:       (scanline == (unsigned char *) NULL))",
          "1756:     {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d44af3cc2a2623fe4d9b942248bdd2bde7b7153",
      "candidate_info": {
        "commit_hash": "6d44af3cc2a2623fe4d9b942248bdd2bde7b7153",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/6d44af3cc2a2623fe4d9b942248bdd2bde7b7153",
        "files": [
          "coders/dcm.c"
        ],
        "message": "https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=34265",
        "before_after_code_files": [
          "coders/dcm.c||coders/dcm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/dcm.c||coders/dcm.c"
          ],
          "candidate": [
            "coders/dcm.c||coders/dcm.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/dcm.c||coders/dcm.c": [
          "File: coders/dcm.c -> coders/dcm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:     { 0x0008, 0x0021, \"DA\", \"Series Date\" },",
          "191:     { 0x0008, 0x0022, \"DA\", \"Acquisition Date\" },",
          "192:     { 0x0008, 0x0023, \"DA\", \"Image Date\" },",
          "193:     { 0x0008, 0x0024, \"DA\", \"Overlay Date\" },",
          "194:     { 0x0008, 0x0025, \"DA\", \"Curve Date\" },",
          "195:     { 0x0008, 0x0030, \"TM\", \"Study Time\" },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:     { 0x0008, 0x0024, \"DA\", \"Overlay Date\" },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2021:     { 0x0070, 0x0080, \"CS\", \"Presentation Label\" },",
          "2022:     { 0x0070, 0x0081, \"LO\", \"Presentation Description\" },",
          "2023:     { 0x0070, 0x0082, \"DA\", \"Presentation Creation Date\" },",
          "2024:     { 0x0070, 0x0083, \"TM\", \"Presentation Creation Time\" },",
          "2025:     { 0x0070, 0x0084, \"PN\", \"Presentation Creator's Name\" },",
          "2026:     { 0x0087, 0x0010, \"CS\", \"Media Type\" },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2025:     { 0x0070, 0x0083, \"TM\", \"Presentation Creation Time\" },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2579:     { 0x7003, 0x0010, \"LT\", \"Info\" },",
          "2580:     { 0x7005, 0x0010, \"LT\", \"Dummy\" },",
          "2581:     { 0x7000, 0x0004, \"ST\", \"TextAnnotation\" },",
          "2582:     { 0x7000, 0x0005, \"IS\", \"Box\" },",
          "2583:     { 0x7000, 0x0007, \"IS\", \"ArrowEnd\" },",
          "2584:     { 0x7fe0, 0x0000, \"UL\", \"Pixel Data Group Length\" },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2584:     { 0x7000, 0x0005, \"IS\", \"Box\" },",
          "2585:     { 0x7000, 0x0007, \"IS\", \"ArrowEnd\" },",
          "2586:     { 0x7001, 0x0001, \"SL\", \"Private Group Length To End\" },",
          "2587:     { 0x7001, 0x0002, \"OB\", \"Unknown\" },",
          "2588:     { 0x7001, 0x0011, \"SL\", \"Private Creator\" },",
          "2589:     { 0x7001, 0x0021, \"SL\", \"Private Creator\" },",
          "2590:     { 0x7001, 0x0022, \"SQ\", \"Private Creator\" },",
          "2591:     { 0x7001, 0x0041, \"SL\", \"Private Creator\" },",
          "2592:     { 0x7001, 0x0042, \"SL\", \"Private Creator\" },",
          "2593:     { 0x7001, 0x0051, \"SL\", \"Private Creator\" },",
          "2594:     { 0x7001, 0x0052, \"SL\", \"Private Creator\" },",
          "2595:     { 0x7001, 0x0075, \"SL\", \"Private Creator\" },",
          "2596:     { 0x7001, 0x0076, \"SL\", \"Private Creator\" },",
          "2597:     { 0x7001, 0x0077, \"OB\", \"Private Creator\" },",
          "2598:     { 0x7001, 0x0101, \"SL\", \"Unknown\" },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2777:   return(ReadBlobByte(image));",
          "2778: }",
          "2781: {",
          "2782:   int",
          "2783:     shift,",
          "",
          "[Removed Lines]",
          "2780: static unsigned short ReadDCMShort(DCMStreamInfo *stream_info,Image *image)",
          "",
          "[Added Lines]",
          "2797: static unsigned short ReadDCMShort(DCMStreamInfo *stream_info,Image *image)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2786:   unsigned short",
          "2787:     value;",
          "2791:   shift=image->depth < 16 ? 4 : 8;",
          "2793:   val=ReadDCMByte(stream_info,image);",
          "2794:   if (val < 0)",
          "2795:     return(0);",
          "",
          "[Removed Lines]",
          "2789:   if (image->compression != RLECompression)",
          "2790:     return(ReadBlobLSBShort(image));",
          "2792:   value=ReadDCMByte(stream_info,image);",
          "",
          "[Added Lines]",
          "2806:   if (image->compression != RLECompression)",
          "2807:     return(ReadBlobLSBShort(image));",
          "2809:   value=(unsigned short) ReadDCMByte(stream_info,image);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3125:   bluemap=(int *) NULL;",
          "3126:   graymap=(int *) NULL;",
          "3127:   height=0;",
          "3129:   use_explicit=MagickFalse;",
          "3130:   explicit_retry = MagickFalse;",
          "3147:       Find corresponding VR for this group and element.",
          "3195:           datum=ReadBlobSignedLong(image);",
          "3196:       }",
          "3198:       if (quantum == 2)",
          "3200:           if (group == 0x0002)",
          "3223:               quantum=1;",
          "3224:         if (datum != ~0)",
          "3229:               Sequence and item of undefined length.",
          "3263:     if ((length == 1) && (quantum == 1))",
          "3266:       if ((length == 1) && (quantum == 2))",
          "3268:           if (group == 0x0002)",
          "3269:             datum=ReadBlobLSBSignedShort(image);",
          "3271:             datum=ReadBlobSignedShort(image);",
          "3272:         }",
          "3274:         if ((length == 1) && (quantum == 4))",
          "3276:             if (group == 0x0002)",
          "3277:               datum=ReadBlobLSBSignedLong(image);",
          "3279:               datum=ReadBlobSignedLong(image);",
          "3299:                    ThrowDCMException(CorruptImageError,",
          "3309:       }",
          "3311:     {",
          "3313:       {",
          "3343:               {",
          "3355:                       ThrowDCMException(CorruptImageError,",
          "3367:                     image->endian=MSBEndian;",
          "3374:                     else",
          "3381:                   case 5:",
          "3382:                   {",
          "3385:                   }",
          "3388:             break;",
          "3394:       }",
          "3406:               ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3407:             break;",
          "3586:             (void) memset(redmap,0,MagickMax(colors,65536)*",
          "3593:               else",
          "3618:             (void) memset(greenmap,0,MagickMax(colors,65536)*",
          "3625:               else",
          "3650:             (void) memset(bluemap,0,MagickMax(colors,65536)*",
          "3657:               else",
          "3688:     if (data != (unsigned char *) NULL)",
          "3699:             attribute=AcquireString(\"dcm:\");",
          "3701:             for (i=0; i < (ssize_t) MagickMax(length,4); i++)",
          "3705:               {",
          "3720:               Display group data.",
          "3722:             for (i=0; i < (ssize_t) MagickMax(length,4); i++)",
          "3730:                 datum=0;",
          "3735:             else",
          "3738:                   (void) FormatLocaleFile(stdout,\"%c\",data[i]);",
          "3739:                 else",
          "3780:       if (length > GetBlobSize(image))",
          "3793:             stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);",
          "3794:           offset=TellBlob(image);",
          "3801:       read_info=CloneImageInfo(image_info);",
          "3812:         FILE",
          "3819:           unique_file;",
          "3822:           tag;",
          "3835:         unique_file=AcquireUniqueFileResource(filename);",
          "3840:             (void) RelinquishUniqueFileResource(filename);",
          "3842:               \"UnableToCreateTemporaryFile\",filename);",
          "3845:         for (c=EOF; length != 0; length--)",
          "3848:           if (c == EOF)",
          "3849:             {",
          "3862:           (void) FormatLocaleString(read_info->filename,MagickPathExtent,",
          "3866:           {",
          "3869:             while (property != (const char *) NULL)",
          "3870:             {",
          "3953:           }",
          "3969:     image->colorspace=RGBColorspace;",
          "3975:           index;",
          "3980:         one=1;",
          "4019:             image->colormap[i].red=(MagickRealType) index;",
          "4020:             image->colormap[i].green=(MagickRealType) index;",
          "4021:             image->colormap[i].blue=(MagickRealType) index;",
          "",
          "[Removed Lines]",
          "3128:   number_scenes=1;",
          "3131:   width=0;",
          "3132:   for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )",
          "3133:   {",
          "3135:       Read a group.",
          "3137:     image->offset=(ssize_t) TellBlob(image);",
          "3138:     group=ReadBlobLSBShort(image);",
          "3139:     element=ReadBlobLSBShort(image);",
          "3140:     if ((group != 0x0002) && (image->endian == MSBEndian))",
          "3141:       {",
          "3142:         group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));",
          "3143:         element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));",
          "3144:       }",
          "3145:     quantum=0;",
          "3149:     for (i=0; dicom_info[i].group < 0xffff; i++)",
          "3150:       if ((group == dicom_info[i].group) && (element == dicom_info[i].element))",
          "3151:         break;",
          "3152:     (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);",
          "3153:     count=ReadBlob(image,2,(unsigned char *) explicit_vr);",
          "3154:     if (count != 2)",
          "3155:       ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3157:       Check for \"explicitness\", but meta-file headers always explicit.",
          "3159:     if ((explicit_file == MagickFalse) && (group != 0x0002))",
          "3160:       explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&",
          "3161:         (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?",
          "3162:         MagickTrue : MagickFalse;",
          "3163:     use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||",
          "3164:       (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;",
          "3165:     if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))",
          "3166:       (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);",
          "3167:     if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))",
          "3168:       {",
          "3169:         offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);",
          "3170:         if (offset < 0)",
          "3171:           ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3172:         quantum=4;",
          "3173:       }",
          "3174:     else",
          "3175:       {",
          "3177:           Assume explicit type.",
          "3179:         quantum=2;",
          "3180:         if ((strncmp(explicit_vr,\"OB\",2) == 0) ||",
          "3181:             (strncmp(explicit_vr,\"UN\",2) == 0) ||",
          "3182:             (strncmp(explicit_vr,\"OW\",2) == 0) ||",
          "3183:             (strncmp(explicit_vr,\"SQ\",2) == 0))",
          "3184:           {",
          "3185:             (void) ReadBlobLSBShort(image);",
          "3186:             quantum=4;",
          "3187:           }",
          "3188:       }",
          "3189:     datum=0;",
          "3190:     if (quantum == 4)",
          "3191:       {",
          "3192:         if (group == 0x0002)",
          "3193:           datum=ReadBlobLSBSignedLong(image);",
          "3194:         else",
          "3197:     else",
          "3199:         {",
          "3201:             datum=ReadBlobLSBSignedShort(image);",
          "3202:           else",
          "3203:             datum=ReadBlobSignedShort(image);",
          "3204:         }",
          "3205:     quantum=0;",
          "3206:     length=1;",
          "3207:     if (datum != 0)",
          "3208:       {",
          "3209:         if ((strncmp(implicit_vr,\"OW\",2) == 0) ||",
          "3210:             (strncmp(implicit_vr,\"SS\",2) == 0) ||",
          "3211:             (strncmp(implicit_vr,\"US\",2) == 0))",
          "3212:           quantum=2;",
          "3213:         else",
          "3214:           if ((strncmp(implicit_vr,\"FL\",2) == 0) ||",
          "3215:               (strncmp(implicit_vr,\"OF\",2) == 0) ||",
          "3216:               (strncmp(implicit_vr,\"SL\",2) == 0) ||",
          "3217:               (strncmp(implicit_vr,\"UL\",2) == 0))",
          "3218:             quantum=4;",
          "3219:           else",
          "3220:             if (strncmp(implicit_vr,\"FD\",2) == 0)",
          "3221:               quantum=8;",
          "3222:             else",
          "3225:           length=(size_t) datum/quantum;",
          "3226:         else",
          "3227:           {",
          "3231:             quantum=0;",
          "3232:             length=0;",
          "3233:           }",
          "3234:       }",
          "3235:     if (image_info->verbose != MagickFalse)",
          "3236:       {",
          "3238:           Display Dicom info.",
          "3240:         if (use_explicit == MagickFalse)",
          "3241:           explicit_vr[0]='\\0';",
          "3242:         for (i=0; dicom_info[i].description != (char *) NULL; i++)",
          "3243:           if ((group == dicom_info[i].group) &&",
          "3244:               (element == dicom_info[i].element))",
          "3245:             break;",
          "3246:         (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",",
          "3247:           (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,",
          "3248:           (unsigned long) group,(unsigned long) element);",
          "3249:         if (dicom_info[i].description != (char *) NULL)",
          "3250:           (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);",
          "3251:         (void) FormatLocaleFile(stdout,\": \");",
          "3252:       }",
          "3253:     if ((group == 0x7FE0) && (element == 0x0010))",
          "3254:       {",
          "3255:         if (image_info->verbose != MagickFalse)",
          "3256:           (void) FormatLocaleFile(stdout,\"\\n\");",
          "3257:         break;",
          "3258:       }",
          "3260:       Allocate space and read an array.",
          "3262:     data=(unsigned char *) NULL;",
          "3264:       datum=ReadBlobByte(image);",
          "3265:     else",
          "3267:         {",
          "3270:           else",
          "3273:       else",
          "3275:           {",
          "3278:             else",
          "3280:           }",
          "3281:         else",
          "3282:           if ((quantum != 0) && (length != 0))",
          "3283:             {",
          "3284:               if (length > GetBlobSize(image))",
          "3285:                 ThrowDCMException(CorruptImageError,",
          "3286:                   \"InsufficientImageDataInFile\");",
          "3287:               if (~length >= 1)",
          "3288:                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*",
          "3289:                   sizeof(*data));",
          "3290:               if (data == (unsigned char *) NULL)",
          "3291:                 ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3292:               count=ReadBlob(image,(size_t) quantum*length,data);",
          "3293:               if (count != (ssize_t) (quantum*length))",
          "3294:                 {",
          "3295:                   if (image_info->verbose != MagickFalse)",
          "3296:                     (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"",
          "3297:                       \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)",
          "3298:                       length,(int) group);",
          "3300:                      \"InsufficientImageDataInFile\");",
          "3301:                 }",
          "3302:               data[length*quantum]='\\0';",
          "3303:             }",
          "3304:     if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)",
          "3305:       {",
          "3306:         if (data != (unsigned char *) NULL)",
          "3307:           data=(unsigned char *) RelinquishMagickMemory(data);",
          "3308:         continue;",
          "3310:     switch (group)",
          "3312:       case 0x0002:",
          "3314:         switch (element)",
          "3315:         {",
          "3316:           case 0x0010:",
          "3317:           {",
          "3318:             char",
          "3319:               transfer_syntax[MagickPathExtent];",
          "3322:               Transfer Syntax.",
          "3324:             if ((datum == 0) && (explicit_retry == MagickFalse))",
          "3325:               {",
          "3326:                 explicit_retry=MagickTrue;",
          "3327:                 (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);",
          "3328:                 group=0;",
          "3329:                 element=0;",
          "3330:                 if (image_info->verbose != MagickFalse)",
          "3331:                   (void) FormatLocaleFile(stdout,",
          "3332:                     \"Corrupted image - trying explicit format\\n\");",
          "3333:                 break;",
          "3334:               }",
          "3336:             if (data != (unsigned char *) NULL)",
          "3337:               (void) CopyMagickString(transfer_syntax,(char *) data,",
          "3338:                 MagickPathExtent);",
          "3339:             if (image_info->verbose != MagickFalse)",
          "3340:               (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",",
          "3341:                 (const char *) transfer_syntax);",
          "3342:             if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)",
          "3344:                 int",
          "3345:                   subtype,",
          "3346:                   type;",
          "3348:                 type=1;",
          "3349:                 subtype=0;",
          "3350:                 if (strlen(transfer_syntax) > 17)",
          "3351:                   {",
          "3352:                     count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,",
          "3353:                       &subtype);",
          "3354:                     if (count < 1)",
          "3356:                         \"ImproperImageHeader\");",
          "3357:                   }",
          "3358:                 switch (type)",
          "3359:                 {",
          "3360:                   case 1:",
          "3361:                   {",
          "3362:                     image->endian=LSBEndian;",
          "3363:                     break;",
          "3364:                   }",
          "3365:                   case 2:",
          "3366:                   {",
          "3368:                     break;",
          "3369:                   }",
          "3370:                   case 4:",
          "3371:                   {",
          "3372:                     if ((subtype >= 80) && (subtype <= 81))",
          "3373:                       image->compression=JPEGCompression;",
          "3375:                       if ((subtype >= 90) && (subtype <= 93))",
          "3376:                         image->compression=JPEG2000Compression;",
          "3377:                       else",
          "3378:                         image->compression=JPEGCompression;",
          "3379:                     break;",
          "3380:                   }",
          "3383:                     image->compression=RLECompression;",
          "3384:                     break;",
          "3386:                 }",
          "3387:               }",
          "3389:           }",
          "3390:           default:",
          "3391:             break;",
          "3392:         }",
          "3393:         break;",
          "3395:       case 0x0028:",
          "3396:       {",
          "3397:         switch (element)",
          "3398:         {",
          "3399:           case 0x0002:",
          "3400:           {",
          "3402:               Samples per pixel.",
          "3404:             info.samples_per_pixel=(size_t) datum;",
          "3405:             if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))",
          "3408:           }",
          "3409:           case 0x0004:",
          "3410:           {",
          "3412:               Photometric interpretation.",
          "3414:             if (data == (unsigned char *) NULL)",
          "3415:               break;",
          "3416:             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)",
          "3417:               photometric[i]=(char) data[i];",
          "3418:             photometric[i]='\\0';",
          "3419:             info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?",
          "3420:               MagickTrue : MagickFalse;",
          "3421:             break;",
          "3422:           }",
          "3423:           case 0x0006:",
          "3424:           {",
          "3426:               Planar configuration.",
          "3428:             if (datum == 1)",
          "3429:               image->interlace=PlaneInterlace;",
          "3430:             break;",
          "3431:           }",
          "3432:           case 0x0008:",
          "3433:           {",
          "3435:               Number of frames.",
          "3437:             if (data == (unsigned char *) NULL)",
          "3438:               break;",
          "3439:             number_scenes=StringToUnsignedLong((char *) data);",
          "3440:             break;",
          "3441:           }",
          "3442:           case 0x0010:",
          "3443:           {",
          "3445:               Image rows.",
          "3447:             height=(size_t) datum;",
          "3448:             break;",
          "3449:           }",
          "3450:           case 0x0011:",
          "3451:           {",
          "3453:               Image columns.",
          "3455:             width=(size_t) datum;",
          "3456:             break;",
          "3457:           }",
          "3458:           case 0x0100:",
          "3459:           {",
          "3461:               Bits allocated.",
          "3463:             info.bits_allocated=(size_t) datum;",
          "3464:             info.bytes_per_pixel=1;",
          "3465:             if (datum > 8)",
          "3466:               info.bytes_per_pixel=2;",
          "3467:             info.depth=info.bits_allocated;",
          "3468:             if ((info.depth == 0) || (info.depth > 32))",
          "3469:               ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3470:             info.max_value=(1UL << info.bits_allocated)-1;",
          "3471:             image->depth=info.depth;",
          "3472:             break;",
          "3473:           }",
          "3474:           case 0x0101:",
          "3475:           {",
          "3477:               Bits stored.",
          "3479:             info.significant_bits=(size_t) datum;",
          "3480:             info.bytes_per_pixel=1;",
          "3481:             if (info.significant_bits > 8)",
          "3482:               info.bytes_per_pixel=2;",
          "3483:             info.depth=info.significant_bits;",
          "3484:             if ((info.depth == 0) || (info.depth > 16))",
          "3485:               ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3486:             info.max_value=(1UL << info.significant_bits)-1;",
          "3487:             info.mask=(size_t) GetQuantumRange(info.significant_bits);",
          "3488:             image->depth=info.depth;",
          "3489:             break;",
          "3490:           }",
          "3491:           case 0x0102:",
          "3492:           {",
          "3494:               High bit.",
          "3496:             break;",
          "3497:           }",
          "3498:           case 0x0103:",
          "3499:           {",
          "3501:               Pixel representation.",
          "3503:             info.signed_data=(size_t) datum;",
          "3504:             break;",
          "3505:           }",
          "3506:           case 0x1050:",
          "3507:           {",
          "3509:               Visible pixel range: center.",
          "3511:             if (data != (unsigned char *) NULL)",
          "3512:               info.window_center=StringToDouble((char *) data, (char **) NULL);",
          "3513:             break;",
          "3514:           }",
          "3515:           case 0x1051:",
          "3516:           {",
          "3518:               Visible pixel range: width.",
          "3520:             if (data != (unsigned char *) NULL)",
          "3521:               info.window_width=StringToDouble((char *) data, (char **) NULL);",
          "3522:             break;",
          "3523:           }",
          "3524:           case 0x1052:",
          "3525:           {",
          "3527:               Rescale intercept",
          "3529:             if (data != (unsigned char *) NULL)",
          "3530:               info.rescale_intercept=StringToDouble((char *) data,",
          "3531:                 (char **) NULL);",
          "3532:             break;",
          "3533:           }",
          "3534:           case 0x1053:",
          "3535:           {",
          "3537:               Rescale slope",
          "3539:             if (data != (unsigned char *) NULL)",
          "3540:               info.rescale_slope=StringToDouble((char *) data, (char **) NULL);",
          "3541:             break;",
          "3542:           }",
          "3543:           case 0x1200:",
          "3544:           case 0x3006:",
          "3545:           {",
          "3547:               Populate graymap.",
          "3549:             if (data == (unsigned char *) NULL)",
          "3550:               break;",
          "3551:             colors=(size_t) (length/info.bytes_per_pixel);",
          "3552:             datum=(int) colors;",
          "3553:             if (graymap != (int *) NULL)",
          "3554:               graymap=(int *) RelinquishMagickMemory(graymap);",
          "3555:             graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3556:               sizeof(*graymap));",
          "3557:             if (graymap == (int *) NULL)",
          "3558:               ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3559:             (void) memset(graymap,0,MagickMax(colors,65536)*",
          "3560:               sizeof(*graymap));",
          "3561:             for (i=0; i < (ssize_t) colors; i++)",
          "3562:               if (info.bytes_per_pixel == 1)",
          "3563:                 graymap[i]=(int) data[i];",
          "3564:               else",
          "3565:                 graymap[i]=(int) ((short *) data)[i];",
          "3566:             break;",
          "3567:           }",
          "3568:           case 0x1201:",
          "3569:           {",
          "3570:             unsigned short",
          "3571:               index;",
          "3574:               Populate redmap.",
          "3576:             if (data == (unsigned char *) NULL)",
          "3577:               break;",
          "3578:             colors=(size_t) (length/2);",
          "3579:             datum=(int) colors;",
          "3580:             if (redmap != (int *) NULL)",
          "3581:               redmap=(int *) RelinquishMagickMemory(redmap);",
          "3582:             redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3583:               sizeof(*redmap));",
          "3584:             if (redmap == (int *) NULL)",
          "3585:               ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3587:               sizeof(*redmap));",
          "3588:             p=data;",
          "3589:             for (i=0; i < (ssize_t) colors; i++)",
          "3590:             {",
          "3591:               if (image->endian == MSBEndian)",
          "3592:                 index=(unsigned short) ((*p << 8) | *(p+1));",
          "3594:                 index=(unsigned short) (*p | (*(p+1) << 8));",
          "3595:               redmap[i]=(int) index;",
          "3596:               p+=2;",
          "3597:             }",
          "3598:             break;",
          "3599:           }",
          "3600:           case 0x1202:",
          "3601:           {",
          "3602:             unsigned short",
          "3603:               index;",
          "3606:               Populate greenmap.",
          "3608:             if (data == (unsigned char *) NULL)",
          "3609:               break;",
          "3610:             colors=(size_t) (length/2);",
          "3611:             datum=(int) colors;",
          "3612:             if (greenmap != (int *) NULL)",
          "3613:               greenmap=(int *) RelinquishMagickMemory(greenmap);",
          "3614:             greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3615:               sizeof(*greenmap));",
          "3616:             if (greenmap == (int *) NULL)",
          "3617:               ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3619:               sizeof(*greenmap));",
          "3620:             p=data;",
          "3621:             for (i=0; i < (ssize_t) colors; i++)",
          "3622:             {",
          "3623:               if (image->endian == MSBEndian)",
          "3624:                 index=(unsigned short) ((*p << 8) | *(p+1));",
          "3626:                 index=(unsigned short) (*p | (*(p+1) << 8));",
          "3627:               greenmap[i]=(int) index;",
          "3628:               p+=2;",
          "3629:             }",
          "3630:             break;",
          "3631:           }",
          "3632:           case 0x1203:",
          "3633:           {",
          "3634:             unsigned short",
          "3635:               index;",
          "3638:               Populate bluemap.",
          "3640:             if (data == (unsigned char *) NULL)",
          "3641:               break;",
          "3642:             colors=(size_t) (length/2);",
          "3643:             datum=(int) colors;",
          "3644:             if (bluemap != (int *) NULL)",
          "3645:               bluemap=(int *) RelinquishMagickMemory(bluemap);",
          "3646:             bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3647:               sizeof(*bluemap));",
          "3648:             if (bluemap == (int *) NULL)",
          "3649:               ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3651:               sizeof(*bluemap));",
          "3652:             p=data;",
          "3653:             for (i=0; i < (ssize_t) colors; i++)",
          "3654:             {",
          "3655:               if (image->endian == MSBEndian)",
          "3656:                 index=(unsigned short) ((*p << 8) | *(p+1));",
          "3658:                 index=(unsigned short) (*p | (*(p+1) << 8));",
          "3659:               bluemap[i]=(int) index;",
          "3660:               p+=2;",
          "3661:             }",
          "3662:             break;",
          "3663:           }",
          "3664:           default:",
          "3665:             break;",
          "3666:         }",
          "3667:         break;",
          "3668:       }",
          "3669:       case 0x2050:",
          "3670:       {",
          "3671:         switch (element)",
          "3672:         {",
          "3673:           case 0x0020:",
          "3674:           {",
          "3675:             if ((data != (unsigned char *) NULL) &&",
          "3676:                 (strncmp((char *) data,\"INVERSE\",7) == 0))",
          "3677:               info.polarity=MagickTrue;",
          "3678:             break;",
          "3679:           }",
          "3680:           default:",
          "3681:             break;",
          "3682:         }",
          "3683:         break;",
          "3684:       }",
          "3685:       default:",
          "3686:         break;",
          "3687:     }",
          "3689:       {",
          "3690:         char",
          "3693:         for (i=0; dicom_info[i].description != (char *) NULL; i++)",
          "3694:           if ((group == dicom_info[i].group) &&",
          "3695:               (element == dicom_info[i].element))",
          "3696:             break;",
          "3697:         if (dicom_info[i].description != (char *) NULL)",
          "3698:           {",
          "3700:             (void) ConcatenateString(&attribute,dicom_info[i].description);",
          "3702:               if (isprint((int) data[i]) == MagickFalse)",
          "3703:                 break;",
          "3704:             if ((i == (ssize_t) length) || (length > 4))",
          "3706:                 (void) SubstituteString(&attribute,\" \",\"\");",
          "3707:                 (void) SetImageProperty(image,attribute,(char *) data,",
          "3708:                   exception);",
          "3709:               }",
          "3710:             attribute=DestroyString(attribute);",
          "3711:           }",
          "3712:       }",
          "3713:     if (image_info->verbose != MagickFalse)",
          "3714:       {",
          "3715:         if (data == (unsigned char *) NULL)",
          "3716:           (void) FormatLocaleFile(stdout,\"%d\\n\",datum);",
          "3717:         else",
          "3718:           {",
          "3723:               if (isprint((int) data[i]) == MagickFalse)",
          "3724:                 break;",
          "3725:             if ((i != (ssize_t) length) && (length <= 4))",
          "3726:               {",
          "3727:                 ssize_t",
          "3728:                   j;",
          "3731:                 for (j=(ssize_t) length-1; j >= 0; j--)",
          "3732:                   datum=(256*datum+data[j]);",
          "3733:                 (void) FormatLocaleFile(stdout,\"%d\",datum);",
          "3734:               }",
          "3736:               for (i=0; i < (ssize_t) length; i++)",
          "3737:                 if (isprint((int) data[i]) != MagickFalse)",
          "3740:                   (void) FormatLocaleFile(stdout,\"%c\",'.');",
          "3741:             (void) FormatLocaleFile(stdout,\"\\n\");",
          "3742:           }",
          "3743:       }",
          "3744:     if (data != (unsigned char *) NULL)",
          "3745:       data=(unsigned char *) RelinquishMagickMemory(data);",
          "3746:     if (EOFBlob(image) != MagickFalse)",
          "3747:       {",
          "3748:         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "3749:           image->filename);",
          "3750:         break;",
          "3751:       }",
          "3752:   }",
          "3753:   if ((width == 0) || (height == 0))",
          "3754:     ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3755:   image->columns=(size_t) width;",
          "3756:   image->rows=(size_t) height;",
          "3757:   if (info.signed_data == 0xffff)",
          "3758:     info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);",
          "3759:   if ((image->compression == JPEGCompression) ||",
          "3760:       (image->compression == JPEG2000Compression))",
          "3761:     {",
          "3762:       Image",
          "3765:       ImageInfo",
          "3768:       int",
          "3769:         c;",
          "3772:         Read offset table.",
          "3774:       for (i=0; i < (ssize_t) stream_info->remaining; i++)",
          "3775:         if (ReadBlobByte(image) == EOF)",
          "3776:           break;",
          "3777:       (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |",
          "3778:         ReadBlobLSBShort(image));",
          "3779:       length=(size_t) ReadBlobLSBLong(image);",
          "3781:         ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");",
          "3782:       stream_info->offset_count=length >> 2;",
          "3783:       if (stream_info->offset_count != 0)",
          "3784:         {",
          "3785:           if (stream_info->offsets != (ssize_t *) NULL)",
          "3786:             stream_info->offsets=(ssize_t *) RelinquishMagickMemory(",
          "3787:               stream_info->offsets);",
          "3788:           stream_info->offsets=(ssize_t *) AcquireQuantumMemory(",
          "3789:             stream_info->offset_count,sizeof(*stream_info->offsets));",
          "3790:           if (stream_info->offsets == (ssize_t *) NULL)",
          "3791:             ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3792:           for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3795:           for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3796:             stream_info->offsets[i]+=offset;",
          "3797:         }",
          "3799:         Handle non-native image formats.",
          "3802:       SetImageInfoBlob(read_info,(void *) NULL,0);",
          "3803:       images=NewImageList();",
          "3804:       for (scene=0; scene < (ssize_t) number_scenes; scene++)",
          "3805:       {",
          "3806:         char",
          "3807:           filename[MagickPathExtent];",
          "3809:         const char",
          "3815:         Image",
          "3818:         int",
          "3821:         unsigned int",
          "3824:         tag=((unsigned int) ReadBlobLSBShort(image) << 16) |",
          "3825:           ReadBlobLSBShort(image);",
          "3826:         length=(size_t) ReadBlobLSBLong(image);",
          "3827:         if (tag == 0xFFFEE0DD)",
          "3829:         if (tag != 0xFFFEE000)",
          "3830:           {",
          "3831:             read_info=DestroyImageInfo(read_info);",
          "3832:             ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3833:           }",
          "3834:         file=(FILE *) NULL;",
          "3836:         if (unique_file != -1)",
          "3837:           file=fdopen(unique_file,\"wb\");",
          "3838:         if (file == (FILE *) NULL)",
          "3839:           {",
          "3841:             ThrowFileException(exception,FileOpenError,",
          "3843:             break;",
          "3844:           }",
          "3846:         {",
          "3847:           c=ReadBlobByte(image);",
          "3850:               ThrowFileException(exception,CorruptImageError,",
          "3851:                 \"UnexpectedEndOfFile\",image->filename);",
          "3852:               break;",
          "3853:             }",
          "3854:           (void) fputc(c,file);",
          "3855:         }",
          "3856:         (void) fclose(file);",
          "3857:         if (c == EOF)",
          "3858:           break;",
          "3859:         (void) FormatLocaleString(read_info->filename,MagickPathExtent,",
          "3860:           \"jpeg:%s\",filename);",
          "3861:         if (image->compression == JPEG2000Compression)",
          "3863:             \"j2k:%s\",filename);",
          "3864:         jpeg_image=ReadImage(read_info,exception);",
          "3865:         if (jpeg_image != (Image *) NULL)",
          "3867:             ResetImagePropertyIterator(image);",
          "3868:             property=GetNextImageProperty(image);",
          "3871:               (void) SetImageProperty(jpeg_image,property,",
          "3872:                 GetImageProperty(image,property,exception),exception);",
          "3873:               property=GetNextImageProperty(image);",
          "3874:             }",
          "3875:             AppendImageToList(&images,jpeg_image);",
          "3876:           }",
          "3877:         (void) RelinquishUniqueFileResource(filename);",
          "3878:       }",
          "3879:       read_info=DestroyImageInfo(read_info);",
          "3880:       if (stream_info->offsets != (ssize_t *) NULL)",
          "3881:         stream_info->offsets=(ssize_t *)",
          "3882:           RelinquishMagickMemory(stream_info->offsets);",
          "3883:       stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);",
          "3884:       if (info.scale != (Quantum *) NULL)",
          "3885:         info.scale=(Quantum *) RelinquishMagickMemory(info.scale);",
          "3886:       if (graymap != (int *) NULL)",
          "3887:         graymap=(int *) RelinquishMagickMemory(graymap);",
          "3888:       if (bluemap != (int *) NULL)",
          "3889:         bluemap=(int *) RelinquishMagickMemory(bluemap);",
          "3890:       if (greenmap != (int *) NULL)",
          "3891:         greenmap=(int *) RelinquishMagickMemory(greenmap);",
          "3892:       if (redmap != (int *) NULL)",
          "3893:         redmap=(int *) RelinquishMagickMemory(redmap);",
          "3894:       image=DestroyImage(image);",
          "3895:       return(GetFirstImageInList(images));",
          "3896:     }",
          "3897:   if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))",
          "3898:     {",
          "3899:       QuantumAny",
          "3900:         range;",
          "3903:         Compute pixel scaling table.",
          "3905:       length=(size_t) (GetQuantumRange(info.depth)+1);",
          "3906:       if (length > GetBlobSize(image))",
          "3907:         ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");",
          "3908:       info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),",
          "3909:         sizeof(*info.scale));",
          "3910:       if (info.scale == (Quantum *) NULL)",
          "3911:         ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3912:       (void) memset(info.scale,0,MagickMax(length,256)*",
          "3913:         sizeof(*info.scale));",
          "3914:       range=GetQuantumRange(info.depth);",
          "3915:       for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)",
          "3916:         info.scale[i]=ScaleAnyToQuantum((size_t) i,range);",
          "3917:     }",
          "3918:   if (image->compression == RLECompression)",
          "3919:     {",
          "3920:       unsigned int",
          "3921:         tag;",
          "3924:         Read RLE offset table.",
          "3926:       for (i=0; i < (ssize_t) stream_info->remaining; i++)",
          "3927:       {",
          "3928:         int",
          "3929:           c;",
          "3931:         c=ReadBlobByte(image);",
          "3932:         if (c == EOF)",
          "3933:           break;",
          "3934:       }",
          "3935:       tag=((unsigned int) ReadBlobLSBShort(image) << 16) |",
          "3936:         ReadBlobLSBShort(image);",
          "3937:       (void) tag;",
          "3938:       length=(size_t) ReadBlobLSBLong(image);",
          "3939:       if (length > GetBlobSize(image))",
          "3940:         ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");",
          "3941:       stream_info->offset_count=length >> 2;",
          "3942:       if (stream_info->offset_count != 0)",
          "3943:         {",
          "3944:           stream_info->offsets=(ssize_t *) AcquireQuantumMemory(",
          "3945:             stream_info->offset_count,sizeof(*stream_info->offsets));",
          "3946:           if (stream_info->offsets == (ssize_t *) NULL)",
          "3947:             ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3948:           for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3949:           {",
          "3950:             stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);",
          "3951:             if (EOFBlob(image) != MagickFalse)",
          "3952:               break;",
          "3954:           offset=TellBlob(image)+8;",
          "3955:           for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3956:             stream_info->offsets[i]+=offset;",
          "3957:         }",
          "3958:     }",
          "3959:   for (scene=0; scene < (ssize_t) number_scenes; scene++)",
          "3960:   {",
          "3961:     if (image_info->ping != MagickFalse)",
          "3962:       break;",
          "3963:     image->columns=(size_t) width;",
          "3964:     image->rows=(size_t) height;",
          "3965:     image->depth=info.depth;",
          "3966:     status=SetImageExtent(image,image->columns,image->rows,exception);",
          "3967:     if (status == MagickFalse)",
          "3968:       break;",
          "3970:     (void) SetImageBackgroundColor(image,exception);",
          "3971:     if ((image->colormap == (PixelInfo *) NULL) &&",
          "3972:         (info.samples_per_pixel == 1))",
          "3973:       {",
          "3974:         int",
          "3977:         size_t",
          "3978:           one;",
          "3981:         if (colors == 0)",
          "3982:           colors=one << info.depth;",
          "3983:         if (AcquireImageColormap(image,colors,exception) == MagickFalse)",
          "3984:           ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3985:         if (redmap != (int *) NULL)",
          "3986:           for (i=0; i < (ssize_t) colors; i++)",
          "3987:           {",
          "3988:             index=redmap[i];",
          "3989:             if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "3990:                 (index <= (int) info.max_value))",
          "3991:               index=(int) info.scale[index];",
          "3992:             image->colormap[i].red=(MagickRealType) index;",
          "3993:           }",
          "3994:         if (greenmap != (int *) NULL)",
          "3995:           for (i=0; i < (ssize_t) colors; i++)",
          "3996:           {",
          "3997:             index=greenmap[i];",
          "3998:             if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "3999:                 (index <= (int) info.max_value))",
          "4000:               index=(int) info.scale[index];",
          "4001:             image->colormap[i].green=(MagickRealType) index;",
          "4002:           }",
          "4003:         if (bluemap != (int *) NULL)",
          "4004:           for (i=0; i < (ssize_t) colors; i++)",
          "4005:           {",
          "4006:             index=bluemap[i];",
          "4007:             if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "4008:                 (index <= (int) info.max_value))",
          "4009:               index=(int) info.scale[index];",
          "4010:             image->colormap[i].blue=(MagickRealType) index;",
          "4011:           }",
          "4012:         if (graymap != (int *) NULL)",
          "4013:           for (i=0; i < (ssize_t) colors; i++)",
          "4014:           {",
          "4015:             index=graymap[i];",
          "4016:             if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "4017:                 (index <= (int) info.max_value))",
          "4018:               index=(int) info.scale[index];",
          "",
          "[Added Lines]",
          "3145:   number_scenes=1;",
          "3147:   explicit_retry = MagickFalse;",
          "3148:   width=0;",
          "3149:   while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))",
          "3150:   {",
          "3151:     for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )",
          "3152:     {",
          "3154:         Read a group.",
          "3157:       group=ReadBlobLSBShort(image);",
          "3158:       element=ReadBlobLSBShort(image);",
          "3159:       if ((group == 0xfffc) && (element == 0xfffc))",
          "3160:         break;",
          "3161:       if ((group != 0x0002) && (image->endian == MSBEndian))",
          "3162:         {",
          "3163:           group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));",
          "3164:           element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));",
          "3165:         }",
          "3166:       quantum=0;",
          "3168:         Find corresponding VR for this group and element.",
          "3170:       for (i=0; dicom_info[i].group < 0xffff; i++)",
          "3171:         if ((group == dicom_info[i].group) &&",
          "3172:             (element == dicom_info[i].element))",
          "3173:           break;",
          "3174:       (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);",
          "3175:       count=ReadBlob(image,2,(unsigned char *) explicit_vr);",
          "3176:       if (count != 2)",
          "3177:         ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3179:         Check for \"explicitness\", but meta-file headers always explicit.",
          "3181:       if ((explicit_file == MagickFalse) && (group != 0x0002))",
          "3182:         explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&",
          "3183:           (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?",
          "3184:           MagickTrue : MagickFalse;",
          "3185:       use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||",
          "3186:         (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;",
          "3187:       if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))",
          "3188:         (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);",
          "3189:       if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))",
          "3190:         {",
          "3191:           offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);",
          "3192:           if (offset < 0)",
          "3193:             ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3194:           quantum=4;",
          "3195:         }",
          "3196:       else",
          "3197:         {",
          "3199:             Assume explicit type.",
          "3201:           quantum=2;",
          "3202:           if ((strncmp(explicit_vr,\"OB\",2) == 0) ||",
          "3203:               (strncmp(explicit_vr,\"UN\",2) == 0) ||",
          "3204:               (strncmp(explicit_vr,\"OW\",2) == 0) ||",
          "3205:               (strncmp(explicit_vr,\"SQ\",2) == 0))",
          "3206:             {",
          "3207:               (void) ReadBlobLSBShort(image);",
          "3208:               quantum=4;",
          "3211:       datum=0;",
          "3213:         {",
          "3215:             datum=ReadBlobLSBSignedLong(image);",
          "3216:           else",
          "3218:         }",
          "3219:       else",
          "3220:         if (quantum == 2)",
          "3221:           {",
          "3223:               datum=ReadBlobLSBSignedShort(image);",
          "3224:             else",
          "3225:               datum=ReadBlobSignedShort(image);",
          "3227:       quantum=0;",
          "3228:       length=1;",
          "3229:       if (datum != 0)",
          "3230:         {",
          "3231:           if ((strncmp(implicit_vr,\"OW\",2) == 0) ||",
          "3232:               (strncmp(implicit_vr,\"SS\",2) == 0) ||",
          "3233:               (strncmp(implicit_vr,\"US\",2) == 0))",
          "3234:             quantum=2;",
          "3235:           else",
          "3236:             if ((strncmp(implicit_vr,\"FL\",2) == 0) ||",
          "3237:                 (strncmp(implicit_vr,\"OF\",2) == 0) ||",
          "3238:                 (strncmp(implicit_vr,\"SL\",2) == 0) ||",
          "3239:                 (strncmp(implicit_vr,\"UL\",2) == 0))",
          "3240:               quantum=4;",
          "3241:             else",
          "3242:               if (strncmp(implicit_vr,\"FD\",2) == 0)",
          "3243:                 quantum=8;",
          "3245:                 quantum=1;",
          "3246:           if (datum != ~0)",
          "3247:             length=(size_t) datum/quantum;",
          "3248:           else",
          "3249:             {",
          "3251:                 Sequence and item of undefined length.",
          "3253:               quantum=0;",
          "3254:               length=0;",
          "3255:             }",
          "3256:         }",
          "3257:       if (image_info->verbose != MagickFalse)",
          "3258:         {",
          "3260:             Display Dicom info.",
          "3262:           if (use_explicit == MagickFalse)",
          "3263:             explicit_vr[0]='\\0';",
          "3264:           for (i=0; dicom_info[i].description != (char *) NULL; i++)",
          "3265:             if ((group == dicom_info[i].group) &&",
          "3266:                 (element == dicom_info[i].element))",
          "3267:               break;",
          "3268:           (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",",
          "3269:             (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,",
          "3270:             (unsigned long) group,(unsigned long) element);",
          "3271:           if (dicom_info[i].description != (char *) NULL)",
          "3272:             (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);",
          "3273:           (void) FormatLocaleFile(stdout,\": \");",
          "3274:         }",
          "3275:       if ((group == 0x7FE0) && (element == 0x0010))",
          "3278:             (void) FormatLocaleFile(stdout,\"\\n\");",
          "3279:           break;",
          "3280:         }",
          "3282:         Allocate space and read an array.",
          "3284:       data=(unsigned char *) NULL;",
          "3287:       else",
          "3289:           {",
          "3292:             else",
          "3294:           }",
          "3295:         else",
          "3296:           if ((length == 1) && (quantum == 4))",
          "3297:             {",
          "3299:                 datum=ReadBlobLSBSignedLong(image);",
          "3300:               else",
          "3301:                 datum=ReadBlobSignedLong(image);",
          "3302:             }",
          "3303:           else",
          "3304:             if ((quantum != 0) && (length != 0))",
          "3305:               {",
          "3306:                 if (length > (size_t) GetBlobSize(image))",
          "3307:                   ThrowDCMException(CorruptImageError,",
          "3308:                     \"InsufficientImageDataInFile\");",
          "3309:                 if (~length >= 1)",
          "3310:                   data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*",
          "3311:                     sizeof(*data));",
          "3312:                 if (data == (unsigned char *) NULL)",
          "3313:                   ThrowDCMException(ResourceLimitError,",
          "3314:                     \"MemoryAllocationFailed\");",
          "3315:                 count=ReadBlob(image,(size_t) quantum*length,data);",
          "3316:                 if (count != (ssize_t) (quantum*length))",
          "3317:                   {",
          "3318:                     if (image_info->verbose != MagickFalse)",
          "3319:                       (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"",
          "3320:                         \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)",
          "3321:                         length,(int) group);",
          "3322:                      ThrowDCMException(CorruptImageError,",
          "3323:                        \"InsufficientImageDataInFile\");",
          "3324:                   }",
          "3325:                 data[length*quantum]='\\0';",
          "3326:               }",
          "3327:       if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)",
          "3328:         {",
          "3329:           if (data != (unsigned char *) NULL)",
          "3331:           continue;",
          "3333:       switch (group)",
          "3335:         case 0x0002:",
          "3336:         {",
          "3337:           switch (element)",
          "3338:           {",
          "3341:               char",
          "3342:                 transfer_syntax[MagickPathExtent];",
          "3345:                 Transfer Syntax.",
          "3347:               if ((datum == 0) && (explicit_retry == MagickFalse))",
          "3348:                 {",
          "3349:                   explicit_retry=MagickTrue;",
          "3350:                   (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);",
          "3351:                   group=0;",
          "3352:                   element=0;",
          "3353:                   if (image_info->verbose != MagickFalse)",
          "3354:                     (void) FormatLocaleFile(stdout,",
          "3355:                       \"Corrupted image - trying explicit format\\n\");",
          "3356:                   break;",
          "3357:                 }",
          "3359:               if (data != (unsigned char *) NULL)",
          "3360:                 (void) CopyMagickString(transfer_syntax,(char *) data,",
          "3361:                   MagickPathExtent);",
          "3362:               if (image_info->verbose != MagickFalse)",
          "3363:                 (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",",
          "3364:                   (const char *) transfer_syntax);",
          "3365:               if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)",
          "3366:                 {",
          "3367:                   int",
          "3368:                     subtype,",
          "3369:                     type;",
          "3371:                   type=1;",
          "3372:                   subtype=0;",
          "3373:                   if (strlen(transfer_syntax) > 17)",
          "3374:                     {",
          "3375:                       count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,",
          "3376:                         &subtype);",
          "3377:                       if (count < 1)",
          "3379:                           \"ImproperImageHeader\");",
          "3380:                     }",
          "3381:                   switch (type)",
          "3382:                   {",
          "3383:                     case 1:",
          "3384:                     {",
          "3385:                       image->endian=LSBEndian;",
          "3386:                       break;",
          "3387:                     }",
          "3388:                     case 2:",
          "3389:                     {",
          "3390:                       image->endian=MSBEndian;",
          "3391:                       break;",
          "3393:                     case 4:",
          "3394:                     {",
          "3395:                       if ((subtype >= 80) && (subtype <= 81))",
          "3396:                         image->compression=JPEGCompression;",
          "3397:                       else",
          "3398:                         if ((subtype >= 90) && (subtype <= 93))",
          "3399:                           image->compression=JPEG2000Compression;",
          "3400:                         else",
          "3401:                           image->compression=JPEGCompression;",
          "3402:                       break;",
          "3403:                     }",
          "3404:                     case 5:",
          "3407:                       break;",
          "3408:                     }",
          "3409:                   }",
          "3410:                 }",
          "3412:             }",
          "3414:               break;",
          "3416:           break;",
          "3418:         case 0x0028:",
          "3419:         {",
          "3420:           switch (element)",
          "3421:           {",
          "3422:             case 0x0002:",
          "3423:             {",
          "3425:                 Samples per pixel.",
          "3427:               info.samples_per_pixel=(size_t) datum;",
          "3428:               if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))",
          "3429:                 ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3430:               break;",
          "3431:             }",
          "3432:             case 0x0004:",
          "3433:             {",
          "3435:                 Photometric interpretation.",
          "3437:               if (data == (unsigned char *) NULL)",
          "3438:                 break;",
          "3439:               for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)",
          "3441:               photometric[i]='\\0';",
          "3442:               info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?",
          "3443:                 MagickTrue : MagickFalse;",
          "3444:               break;",
          "3445:             }",
          "3446:             case 0x0006:",
          "3447:             {",
          "3451:               if (datum == 1)",
          "3452:                 image->interlace=PlaneInterlace;",
          "3453:               break;",
          "3454:             }",
          "3455:             case 0x0008:",
          "3456:             {",
          "3458:                 Number of frames.",
          "3460:               if (data == (unsigned char *) NULL)",
          "3461:                 break;",
          "3464:             }",
          "3465:             case 0x0010:",
          "3466:             {",
          "3470:               height=(size_t) datum;",
          "3471:               break;",
          "3472:             }",
          "3473:             case 0x0011:",
          "3474:             {",
          "3476:                 Image columns.",
          "3480:             }",
          "3481:             case 0x0100:",
          "3482:             {",
          "3484:                 Bits allocated.",
          "3486:               info.bits_allocated=(size_t) datum;",
          "3487:               info.bytes_per_pixel=1;",
          "3488:               if (datum > 8)",
          "3489:                 info.bytes_per_pixel=2;",
          "3490:               info.depth=info.bits_allocated;",
          "3491:               if ((info.depth == 0) || (info.depth > 32))",
          "3493:               info.max_value=(1UL << info.bits_allocated)-1;",
          "3494:               image->depth=info.depth;",
          "3495:               break;",
          "3496:             }",
          "3497:             case 0x0101:",
          "3498:             {",
          "3500:                 Bits stored.",
          "3502:               info.significant_bits=(size_t) datum;",
          "3503:               info.bytes_per_pixel=1;",
          "3504:               if (info.significant_bits > 8)",
          "3505:                 info.bytes_per_pixel=2;",
          "3506:               info.depth=info.significant_bits;",
          "3507:               if ((info.depth == 0) || (info.depth > 16))",
          "3509:               info.max_value=(1UL << info.significant_bits)-1;",
          "3510:               info.mask=(size_t) GetQuantumRange(info.significant_bits);",
          "3513:             }",
          "3514:             case 0x0102:",
          "3515:             {",
          "3517:                 High bit.",
          "3519:               break;",
          "3520:             }",
          "3521:             case 0x0103:",
          "3522:             {",
          "3524:                 Pixel representation.",
          "3526:               info.signed_data=(size_t) datum;",
          "3527:               break;",
          "3528:             }",
          "3529:             case 0x1050:",
          "3530:             {",
          "3532:                 Visible pixel range: center.",
          "3534:               if (data != (unsigned char *) NULL)",
          "3535:                 info.window_center=StringToDouble((char *) data,(char **) NULL);",
          "3536:               break;",
          "3537:             }",
          "3538:             case 0x1051:",
          "3539:             {",
          "3541:                 Visible pixel range: width.",
          "3543:               if (data != (unsigned char *) NULL)",
          "3544:                 info.window_width=StringToDouble((char *) data,(char **) NULL);",
          "3545:               break;",
          "3546:             }",
          "3547:             case 0x1052:",
          "3548:             {",
          "3550:                 Rescale intercept",
          "3552:               if (data != (unsigned char *) NULL)",
          "3553:                 info.rescale_intercept=StringToDouble((char *) data,",
          "3554:                   (char **) NULL);",
          "3555:               break;",
          "3556:             }",
          "3557:             case 0x1053:",
          "3558:             {",
          "3560:                 Rescale slope",
          "3562:               if (data != (unsigned char *) NULL)",
          "3563:                 info.rescale_slope=StringToDouble((char *) data,(char **) NULL);",
          "3564:               break;",
          "3565:             }",
          "3566:             case 0x1200:",
          "3567:             case 0x3006:",
          "3568:             {",
          "3570:                 Populate graymap.",
          "3572:               if (data == (unsigned char *) NULL)",
          "3573:                 break;",
          "3574:               colors=(size_t) (length/info.bytes_per_pixel);",
          "3575:               datum=(int) colors;",
          "3576:               if (graymap != (int *) NULL)",
          "3577:                 graymap=(int *) RelinquishMagickMemory(graymap);",
          "3578:               graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3579:                 sizeof(*graymap));",
          "3580:               if (graymap == (int *) NULL)",
          "3581:                 ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3582:               (void) memset(graymap,0,MagickMax(colors,65536)*",
          "3583:                 sizeof(*graymap));",
          "3584:               for (i=0; i < (ssize_t) colors; i++)",
          "3585:                 if (info.bytes_per_pixel == 1)",
          "3586:                   graymap[i]=(int) data[i];",
          "3587:                 else",
          "3588:                   graymap[i]=(int) ((short *) data)[i];",
          "3589:               break;",
          "3590:             }",
          "3593:               unsigned short",
          "3594:                 index;",
          "3597:                 Populate redmap.",
          "3599:               if (data == (unsigned char *) NULL)",
          "3600:                 break;",
          "3601:               colors=(size_t) (length/2);",
          "3602:               datum=(int) colors;",
          "3603:               if (redmap != (int *) NULL)",
          "3604:                 redmap=(int *) RelinquishMagickMemory(redmap);",
          "3605:               redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3606:                 sizeof(*redmap));",
          "3607:               if (redmap == (int *) NULL)",
          "3608:                 ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3610:                 sizeof(*redmap));",
          "3611:               p=data;",
          "3612:               for (i=0; i < (ssize_t) colors; i++)",
          "3613:               {",
          "3614:                 if (image->endian == MSBEndian)",
          "3615:                   index=(unsigned short) ((*p << 8) | *(p+1));",
          "3617:                   index=(unsigned short) (*p | (*(p+1) << 8));",
          "3618:                 redmap[i]=(int) index;",
          "3619:                 p+=2;",
          "3620:               }",
          "3621:               break;",
          "3622:             }",
          "3623:             case 0x1202:",
          "3624:             {",
          "3625:               unsigned short",
          "3626:                 index;",
          "3629:                 Populate greenmap.",
          "3631:               if (data == (unsigned char *) NULL)",
          "3632:                 break;",
          "3633:               colors=(size_t) (length/2);",
          "3634:               datum=(int) colors;",
          "3635:               if (greenmap != (int *) NULL)",
          "3636:                 greenmap=(int *) RelinquishMagickMemory(greenmap);",
          "3637:               greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3638:                 sizeof(*greenmap));",
          "3639:               if (greenmap == (int *) NULL)",
          "3640:                 ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3642:                 sizeof(*greenmap));",
          "3643:               p=data;",
          "3644:               for (i=0; i < (ssize_t) colors; i++)",
          "3645:               {",
          "3646:                 if (image->endian == MSBEndian)",
          "3647:                   index=(unsigned short) ((*p << 8) | *(p+1));",
          "3649:                   index=(unsigned short) (*p | (*(p+1) << 8));",
          "3650:                 greenmap[i]=(int) index;",
          "3651:                 p+=2;",
          "3652:               }",
          "3653:               break;",
          "3654:             }",
          "3655:             case 0x1203:",
          "3656:             {",
          "3657:               unsigned short",
          "3658:                 index;",
          "3661:                 Populate bluemap.",
          "3663:               if (data == (unsigned char *) NULL)",
          "3664:                 break;",
          "3665:               colors=(size_t) (length/2);",
          "3666:               datum=(int) colors;",
          "3667:               if (bluemap != (int *) NULL)",
          "3668:                 bluemap=(int *) RelinquishMagickMemory(bluemap);",
          "3669:               bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),",
          "3670:                 sizeof(*bluemap));",
          "3671:               if (bluemap == (int *) NULL)",
          "3672:                 ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3673:               (void) memset(bluemap,0,MagickMax(colors,65536)*",
          "3674:                 sizeof(*bluemap));",
          "3675:               p=data;",
          "3677:               {",
          "3678:                 if (image->endian == MSBEndian)",
          "3679:                   index=(unsigned short) ((*p << 8) | *(p+1));",
          "3680:                 else",
          "3681:                   index=(unsigned short) (*p | (*(p+1) << 8));",
          "3682:                 bluemap[i]=(int) index;",
          "3683:                 p+=2;",
          "3684:               }",
          "3686:             }",
          "3687:             default:",
          "3688:               break;",
          "3689:           }",
          "3690:           break;",
          "3691:         }",
          "3692:         case 0x2050:",
          "3693:         {",
          "3694:           switch (element)",
          "3695:           {",
          "3696:             case 0x0020:",
          "3697:             {",
          "3698:               if ((data != (unsigned char *) NULL) &&",
          "3699:                   (strncmp((char *) data,\"INVERSE\",7) == 0))",
          "3700:                 info.polarity=MagickTrue;",
          "3701:               break;",
          "3702:             }",
          "3703:             default:",
          "3704:               break;",
          "3705:           }",
          "3707:         }",
          "3708:         default:",
          "3709:           break;",
          "3710:       }",
          "3712:         {",
          "3713:           char",
          "3716:           for (i=0; dicom_info[i].description != (char *) NULL; i++)",
          "3717:             if ((group == dicom_info[i].group) &&",
          "3718:                 (element == dicom_info[i].element))",
          "3719:               break;",
          "3720:           if (dicom_info[i].description != (char *) NULL)",
          "3721:             {",
          "3722:               attribute=AcquireString(\"dcm:\");",
          "3723:               (void) ConcatenateString(&attribute,dicom_info[i].description);",
          "3724:               for (i=0; i < (ssize_t) MagickMax(length,4); i++)",
          "3725:                 if (isprint((int) data[i]) == MagickFalse)",
          "3726:                   break;",
          "3727:               if ((i == (ssize_t) length) || (length > 4))",
          "3728:                 {",
          "3729:                   (void) SubstituteString(&attribute,\" \",\"\");",
          "3730:                   (void) SetImageProperty(image,attribute,(char *) data,",
          "3731:                     exception);",
          "3732:                 }",
          "3733:               attribute=DestroyString(attribute);",
          "3734:             }",
          "3735:         }",
          "3736:       if (image_info->verbose != MagickFalse)",
          "3737:         {",
          "3738:           if (data == (unsigned char *) NULL)",
          "3739:             (void) FormatLocaleFile(stdout,\"%d\\n\",datum);",
          "3740:           else",
          "3741:             {",
          "3743:                 Display group data.",
          "3745:               for (i=0; i < (ssize_t) MagickMax(length,4); i++)",
          "3746:                 if (isprint((int) data[i]) == MagickFalse)",
          "3747:                   break;",
          "3749:                 {",
          "3750:                   ssize_t",
          "3751:                     j;",
          "3753:                   datum=0;",
          "3754:                   for (j=(ssize_t) length-1; j >= 0; j--)",
          "3755:                     datum=(256*datum+data[j]);",
          "3756:                   (void) FormatLocaleFile(stdout,\"%d\",datum);",
          "3757:                 }",
          "3758:               else",
          "3759:                 for (i=0; i < (ssize_t) length; i++)",
          "3760:                   if (isprint((int) data[i]) != MagickFalse)",
          "3761:                     (void) FormatLocaleFile(stdout,\"%c\",data[i]);",
          "3762:                   else",
          "3763:                     (void) FormatLocaleFile(stdout,\"%c\",'.');",
          "3764:               (void) FormatLocaleFile(stdout,\"\\n\");",
          "3765:             }",
          "3767:       if (data != (unsigned char *) NULL)",
          "3768:         data=(unsigned char *) RelinquishMagickMemory(data);",
          "3769:       if (EOFBlob(image) != MagickFalse)",
          "3771:           ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "3772:             image->filename);",
          "3774:         }",
          "3775:     }",
          "3777:       {",
          "3778:         Image",
          "3781:         last=RemoveLastImageFromList(&image);",
          "3782:         if (last != (Image *) NULL)",
          "3783:           last=DestroyImage(last);",
          "3784:         break;",
          "3785:       }",
          "3786:     if ((width == 0) || (height == 0))",
          "3787:       ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3788:     image->columns=(size_t) width;",
          "3789:     image->rows=(size_t) height;",
          "3790:     if (info.signed_data == 0xffff)",
          "3794:       {",
          "3795:         Image",
          "3798:         ImageInfo",
          "3801:         int",
          "3802:           c;",
          "3805:           Read offset table.",
          "3807:         for (i=0; i < (ssize_t) stream_info->remaining; i++)",
          "3809:             break;",
          "3810:         (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |",
          "3811:           ReadBlobLSBShort(image));",
          "3812:         length=(size_t) ReadBlobLSBLong(image);",
          "3814:           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");",
          "3815:         stream_info->offset_count=length >> 2;",
          "3816:         if (stream_info->offset_count != 0)",
          "3817:           {",
          "3818:             if (stream_info->offsets != (ssize_t *) NULL)",
          "3819:               stream_info->offsets=(ssize_t *) RelinquishMagickMemory(",
          "3820:                 stream_info->offsets);",
          "3821:             stream_info->offsets=(ssize_t *) AcquireQuantumMemory(",
          "3822:               stream_info->offset_count,sizeof(*stream_info->offsets));",
          "3823:             if (stream_info->offsets == (ssize_t *) NULL)",
          "3824:               ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3825:             for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3828:             for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3829:               stream_info->offsets[i]+=offset;",
          "3830:           }",
          "3832:           Handle non-native image formats.",
          "3835:         SetImageInfoBlob(read_info,(void *) NULL,0);",
          "3836:         images=NewImageList();",
          "3837:         for (scene=0; scene < (ssize_t) number_scenes; scene++)",
          "3838:         {",
          "3839:           char",
          "3840:             filename[MagickPathExtent];",
          "3842:           const char",
          "3845:           FILE",
          "3848:           Image",
          "3851:           int",
          "3852:             unique_file;",
          "3854:           unsigned int",
          "3855:             tag;",
          "3857:           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |",
          "3858:             ReadBlobLSBShort(image);",
          "3859:           length=(size_t) ReadBlobLSBLong(image);",
          "3860:           if (tag == 0xFFFEE0DD)",
          "3862:           if (tag != 0xFFFEE000)",
          "3863:             {",
          "3864:               read_info=DestroyImageInfo(read_info);",
          "3865:               ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "3866:             }",
          "3867:           file=(FILE *) NULL;",
          "3869:           if (unique_file != -1)",
          "3870:             file=fdopen(unique_file,\"wb\");",
          "3871:           if (file == (FILE *) NULL)",
          "3874:               ThrowFileException(exception,FileOpenError,",
          "3876:               break;",
          "3877:             }",
          "3878:           for (c=EOF; length != 0; length--)",
          "3879:           {",
          "3880:             c=ReadBlobByte(image);",
          "3881:             if (c == EOF)",
          "3882:               {",
          "3883:                 ThrowFileException(exception,CorruptImageError,",
          "3884:                   \"UnexpectedEndOfFile\",image->filename);",
          "3885:                 break;",
          "3886:               }",
          "3887:             (void) fputc(c,file);",
          "3888:           }",
          "3889:           (void) fclose(file);",
          "3890:           if (c == EOF)",
          "3891:             break;",
          "3892:           (void) FormatLocaleString(read_info->filename,MagickPathExtent,",
          "3893:             \"jpeg:%s\",filename);",
          "3894:           if (image->compression == JPEG2000Compression)",
          "3896:               \"j2k:%s\",filename);",
          "3898:           if (jpeg_image != (Image *) NULL)",
          "3899:             {",
          "3900:               ResetImagePropertyIterator(image);",
          "3901:               property=GetNextImageProperty(image);",
          "3902:               while (property != (const char *) NULL)",
          "3903:               {",
          "3904:                 (void) SetImageProperty(jpeg_image,property,",
          "3906:                 property=GetNextImageProperty(image);",
          "3908:               AppendImageToList(&images,jpeg_image);",
          "3909:             }",
          "3910:           (void) RelinquishUniqueFileResource(filename);",
          "3911:         }",
          "3912:         read_info=DestroyImageInfo(read_info);",
          "3913:         if (stream_info->offsets != (ssize_t *) NULL)",
          "3914:           stream_info->offsets=(ssize_t *)",
          "3915:             RelinquishMagickMemory(stream_info->offsets);",
          "3916:         stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);",
          "3917:         if (info.scale != (Quantum *) NULL)",
          "3918:           info.scale=(Quantum *) RelinquishMagickMemory(info.scale);",
          "3919:         if (graymap != (int *) NULL)",
          "3920:           graymap=(int *) RelinquishMagickMemory(graymap);",
          "3921:         if (bluemap != (int *) NULL)",
          "3922:           bluemap=(int *) RelinquishMagickMemory(bluemap);",
          "3923:         if (greenmap != (int *) NULL)",
          "3924:           greenmap=(int *) RelinquishMagickMemory(greenmap);",
          "3925:         if (redmap != (int *) NULL)",
          "3926:           redmap=(int *) RelinquishMagickMemory(redmap);",
          "3928:         return(GetFirstImageInList(images));",
          "3929:       }",
          "3932:         QuantumAny",
          "3933:           range;",
          "3936:           Compute pixel scaling table.",
          "3938:         length=(size_t) (GetQuantumRange(info.depth)+1);",
          "3939:         if (length > (size_t) GetBlobSize(image))",
          "3941:         info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),",
          "3942:           sizeof(*info.scale));",
          "3943:         if (info.scale == (Quantum *) NULL)",
          "3944:           ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3945:         (void) memset(info.scale,0,MagickMax(length,256)*",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4023:       }",
          "4024:     if (image->compression == RLECompression)",
          "4025:       {",
          "4027:           tag;",
          "",
          "[Removed Lines]",
          "4026:         unsigned int",
          "",
          "[Added Lines]",
          "3953:         unsigned int",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4037:           c=ReadBlobByte(image);",
          "4038:           if (c == EOF)",
          "4054:         for (i=0; i < 15; i++)",
          "4060:             info.depth=8;",
          "4061:             if (stream_info->offset_count > 0)",
          "4069:           x;",
          "4082:           for (y=0; y < (ssize_t) image->rows; y++)",
          "4084:             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);",
          "4086:               break;",
          "4094:                     ReadDCMByte(stream_info,image)),q);",
          "4104:                 {",
          "4106:                     ReadDCMByte(stream_info,image)),q);",
          "4110:                 {",
          "4115:                 default:",
          "4125:                   image->rows);",
          "4126:                 if (status == MagickFalse)",
          "4132:     else",
          "4133:       {",
          "4147:         if (option != (char *) NULL)",
          "4150:               geometry_info;",
          "4187:     if (image_info->number_scenes != 0)",
          "4188:       if (image->scene >= (image_info->scene+image_info->number_scenes-1))",
          "4189:         break;",
          "",
          "[Removed Lines]",
          "4039:             break;",
          "4040:         }",
          "4041:         tag=((unsigned int) ReadBlobLSBShort(image) << 16) |",
          "4042:           ReadBlobLSBShort(image);",
          "4043:         stream_info->remaining=(size_t) ReadBlobLSBLong(image);",
          "4044:         if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||",
          "4045:             (EOFBlob(image) != MagickFalse))",
          "4046:           {",
          "4047:             if (stream_info->offsets != (ssize_t *) NULL)",
          "4048:               stream_info->offsets=(ssize_t *)",
          "4049:                 RelinquishMagickMemory(stream_info->offsets);",
          "4050:             ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "4051:           }",
          "4052:         stream_info->count=0;",
          "4053:         stream_info->segment_count=ReadBlobLSBLong(image);",
          "4055:           stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);",
          "4056:         stream_info->remaining-=64;",
          "4057:         if (stream_info->segment_count > 1)",
          "4058:           {",
          "4059:             info.bytes_per_pixel=1;",
          "4062:               (void) SeekBlob(image,(MagickOffsetType) stream_info->offsets[0]+",
          "4063:                 stream_info->segments[0],SEEK_SET);",
          "4064:           }",
          "4065:       }",
          "4066:     if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))",
          "4067:       {",
          "4068:         register ssize_t",
          "4071:         register Quantum",
          "4074:         ssize_t",
          "4075:           y;",
          "4078:           Convert Planar RGB DCM Medical image to pixel packets.",
          "4080:         for (i=0; i < (ssize_t) info.samples_per_pixel; i++)",
          "4081:         {",
          "4083:           {",
          "4085:             if (q == (Quantum *) NULL)",
          "4087:             for (x=0; x < (ssize_t) image->columns; x++)",
          "4088:             {",
          "4089:               switch ((int) i)",
          "4090:               {",
          "4091:                 case 0:",
          "4092:                 {",
          "4093:                   SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "4095:                   break;",
          "4096:                 }",
          "4097:                 case 1:",
          "4098:                 {",
          "4099:                   SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "4100:                     ReadDCMByte(stream_info,image)),q);",
          "4101:                   break;",
          "4102:                 }",
          "4103:                 case 2:",
          "4105:                   SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "4107:                   break;",
          "4108:                 }",
          "4109:                 case 3:",
          "4111:                   SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "4112:                     ReadDCMByte(stream_info,image)),q);",
          "4113:                   break;",
          "4114:                 }",
          "4116:                   break;",
          "4117:               }",
          "4118:               q+=GetPixelChannels(image);",
          "4119:             }",
          "4120:             if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "4121:               break;",
          "4122:             if (image->previous == (Image *) NULL)",
          "4123:               {",
          "4124:                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,",
          "4127:                   break;",
          "4128:               }",
          "4129:           }",
          "4130:         }",
          "4131:       }",
          "4134:         const char",
          "4138:           Convert DCM Medical image to pixel packets.",
          "4140:         option=GetImageOption(image_info,\"dcm:display-range\");",
          "4141:         if (option != (const char *) NULL)",
          "4142:           {",
          "4143:             if (LocaleCompare(option,\"reset\") == 0)",
          "4144:               info.window_width=0;",
          "4145:           }",
          "4146:         option=GetImageOption(image_info,\"dcm:window\");",
          "4148:           {",
          "4149:             GeometryInfo",
          "4152:             MagickStatusType",
          "4153:               flags;",
          "4155:             flags=ParseGeometry(option,&geometry_info);",
          "4156:             if (flags & RhoValue)",
          "4157:               info.window_center=geometry_info.rho;",
          "4158:             if (flags & SigmaValue)",
          "4159:               info.window_width=geometry_info.sigma;",
          "4160:             info.rescale=MagickTrue;",
          "4161:           }",
          "4162:         option=GetImageOption(image_info,\"dcm:rescale\");",
          "4163:         if (option != (char *) NULL)",
          "4164:           info.rescale=IsStringTrue(option);",
          "4165:         if ((info.window_center != 0) && (info.window_width == 0))",
          "4166:           info.window_width=info.window_center;",
          "4167:         status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);",
          "4168:         if ((status != MagickFalse) && (stream_info->segment_count > 1))",
          "4169:           {",
          "4170:             if (stream_info->offset_count > 0)",
          "4171:               (void) SeekBlob(image,(MagickOffsetType) stream_info->offsets[0]+",
          "4172:                 stream_info->segments[1],SEEK_SET);",
          "4173:             (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,exception);",
          "4174:           }",
          "4175:       }",
          "4176:     if (SetImageGray(image,exception) != MagickFalse)",
          "4177:       (void) SetImageColorspace(image,GRAYColorspace,exception);",
          "4178:     if (EOFBlob(image) != MagickFalse)",
          "4179:       {",
          "4180:         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "4181:           image->filename);",
          "4182:         break;",
          "4183:       }",
          "4185:       Proceed to next image.",
          "",
          "[Added Lines]",
          "3966:             break;",
          "3967:         }",
          "3968:         tag=((unsigned int) ReadBlobLSBShort(image) << 16) |",
          "3969:           ReadBlobLSBShort(image);",
          "3970:         (void) tag;",
          "3971:         length=(size_t) ReadBlobLSBLong(image);",
          "3973:           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");",
          "3974:         stream_info->offset_count=length >> 2;",
          "3975:         if (stream_info->offset_count != 0)",
          "3976:           {",
          "3977:             stream_info->offsets=(ssize_t *) AcquireQuantumMemory(",
          "3978:               stream_info->offset_count,sizeof(*stream_info->offsets));",
          "3979:             if (stream_info->offsets == (ssize_t *) NULL)",
          "3980:               ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3981:             for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3982:             {",
          "3983:               stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);",
          "3984:               if (EOFBlob(image) != MagickFalse)",
          "3985:                 break;",
          "3988:             for (i=0; i < (ssize_t) stream_info->offset_count; i++)",
          "3989:               stream_info->offsets[i]+=offset;",
          "3990:           }",
          "3991:       }",
          "3992:     for (scene=0; scene < (ssize_t) number_scenes; scene++)",
          "3993:     {",
          "3994:       if (image_info->ping != MagickFalse)",
          "3995:         break;",
          "3996:       image->columns=(size_t) width;",
          "3997:       image->rows=(size_t) height;",
          "3998:       image->depth=info.depth;",
          "3999:       status=SetImageExtent(image,image->columns,image->rows,exception);",
          "4000:       if (status == MagickFalse)",
          "4001:         break;",
          "4002:       image->colorspace=RGBColorspace;",
          "4003:       (void) SetImageBackgroundColor(image,exception);",
          "4004:       if ((image->colormap == (PixelInfo *) NULL) &&",
          "4006:         {",
          "4007:           int",
          "4010:           size_t",
          "4011:             one;",
          "4013:           one=1;",
          "4014:           if (colors == 0)",
          "4015:             colors=one << info.depth;",
          "4016:           if (AcquireImageColormap(image,colors,exception) == MagickFalse)",
          "4017:             ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "4018:           if (redmap != (int *) NULL)",
          "4019:             for (i=0; i < (ssize_t) colors; i++)",
          "4020:             {",
          "4021:               index=redmap[i];",
          "4022:               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "4023:                   (index <= (int) info.max_value))",
          "4024:                 index=(int) info.scale[index];",
          "4025:               image->colormap[i].red=(MagickRealType) index;",
          "4026:             }",
          "4027:           if (greenmap != (int *) NULL)",
          "4028:             for (i=0; i < (ssize_t) colors; i++)",
          "4029:             {",
          "4030:               index=greenmap[i];",
          "4031:               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "4032:                   (index <= (int) info.max_value))",
          "4033:                 index=(int) info.scale[index];",
          "4034:               image->colormap[i].green=(MagickRealType) index;",
          "4035:             }",
          "4036:           if (bluemap != (int *) NULL)",
          "4037:             for (i=0; i < (ssize_t) colors; i++)",
          "4038:             {",
          "4039:               index=bluemap[i];",
          "4040:               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "4041:                   (index <= (int) info.max_value))",
          "4042:                 index=(int) info.scale[index];",
          "4043:               image->colormap[i].blue=(MagickRealType) index;",
          "4044:             }",
          "4045:           if (graymap != (int *) NULL)",
          "4046:             for (i=0; i < (ssize_t) colors; i++)",
          "4047:             {",
          "4048:               index=graymap[i];",
          "4049:               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&",
          "4050:                   (index <= (int) info.max_value))",
          "4051:                 index=(int) info.scale[index];",
          "4052:               image->colormap[i].red=(MagickRealType) index;",
          "4053:               image->colormap[i].green=(MagickRealType) index;",
          "4055:             }",
          "4056:         }",
          "4057:       if (image->compression == RLECompression)",
          "4058:         {",
          "4059:           unsigned int",
          "4060:             tag;",
          "4063:             Read RLE segment table.",
          "4065:           for (i=0; i < (ssize_t) stream_info->remaining; i++)",
          "4066:           {",
          "4067:             int",
          "4070:             c=ReadBlobByte(image);",
          "4071:             if (c == EOF)",
          "4072:               break;",
          "4073:           }",
          "4074:           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |",
          "4075:             ReadBlobLSBShort(image);",
          "4076:           stream_info->remaining=(size_t) ReadBlobLSBLong(image);",
          "4077:           if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||",
          "4078:               (EOFBlob(image) != MagickFalse))",
          "4079:             {",
          "4080:               if (stream_info->offsets != (ssize_t *) NULL)",
          "4081:                 stream_info->offsets=(ssize_t *)",
          "4082:                   RelinquishMagickMemory(stream_info->offsets);",
          "4083:               ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");",
          "4084:             }",
          "4085:           stream_info->count=0;",
          "4086:           stream_info->segment_count=ReadBlobLSBLong(image);",
          "4088:             stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);",
          "4089:           stream_info->remaining-=64;",
          "4090:           if (stream_info->segment_count > 1)",
          "4091:             {",
          "4092:               info.bytes_per_pixel=1;",
          "4093:               info.depth=8;",
          "4094:               if (stream_info->offset_count > 0)",
          "4095:                 (void) SeekBlob(image,(MagickOffsetType)",
          "4096:                   stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);",
          "4097:             }",
          "4098:         }",
          "4099:       if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))",
          "4100:         {",
          "4101:           register ssize_t",
          "4102:             x;",
          "4104:           register Quantum",
          "4107:           ssize_t",
          "4108:             y;",
          "4111:             Convert Planar RGB DCM Medical image to pixel packets.",
          "4113:           for (i=0; i < (ssize_t) info.samples_per_pixel; i++)",
          "4114:           {",
          "4115:             for (y=0; y < (ssize_t) image->rows; y++)",
          "4116:             {",
          "4118:               if (q == (Quantum *) NULL)",
          "4120:               for (x=0; x < (ssize_t) image->columns; x++)",
          "4121:               {",
          "4122:                 switch ((int) i)",
          "4123:                 {",
          "4124:                   case 0:",
          "4125:                   {",
          "4126:                     SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "4127:                       ReadDCMByte(stream_info,image)),q);",
          "4128:                     break;",
          "4129:                   }",
          "4130:                   case 1:",
          "4131:                   {",
          "4132:                     SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "4133:                       ReadDCMByte(stream_info,image)),q);",
          "4134:                     break;",
          "4135:                   }",
          "4136:                   case 2:",
          "4137:                   {",
          "4138:                     SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "4139:                       ReadDCMByte(stream_info,image)),q);",
          "4140:                     break;",
          "4141:                   }",
          "4142:                   case 3:",
          "4143:                   {",
          "4144:                     SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "4145:                       ReadDCMByte(stream_info,image)),q);",
          "4147:                   }",
          "4148:                   default:",
          "4149:                     break;",
          "4150:                 }",
          "4151:                 q+=GetPixelChannels(image);",
          "4153:               if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "4154:                 break;",
          "4155:               if (image->previous == (Image *) NULL)",
          "4156:                 {",
          "4161:                 }",
          "4162:             }",
          "4163:           }",
          "4164:         }",
          "4167:           const char",
          "4171:             Convert DCM Medical image to pixel packets.",
          "4173:           option=GetImageOption(image_info,\"dcm:display-range\");",
          "4174:           if (option != (const char *) NULL)",
          "4175:             {",
          "4176:               if (LocaleCompare(option,\"reset\") == 0)",
          "4177:                 info.window_width=0;",
          "4178:             }",
          "4179:           option=GetImageOption(image_info,\"dcm:window\");",
          "4181:             {",
          "4182:               GeometryInfo",
          "4185:               MagickStatusType",
          "4186:                 flags;",
          "4188:               flags=ParseGeometry(option,&geometry_info);",
          "4189:               if (flags & RhoValue)",
          "4190:                 info.window_center=geometry_info.rho;",
          "4191:               if (flags & SigmaValue)",
          "4192:                 info.window_width=geometry_info.sigma;",
          "4193:               info.rescale=MagickTrue;",
          "4194:             }",
          "4195:           option=GetImageOption(image_info,\"dcm:rescale\");",
          "4196:           if (option != (char *) NULL)",
          "4197:             info.rescale=IsStringTrue(option);",
          "4198:           if ((info.window_center != 0) && (info.window_width == 0))",
          "4199:             info.window_width=info.window_center;",
          "4200:           status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);",
          "4201:           if ((status != MagickFalse) && (stream_info->segment_count > 1))",
          "4202:             {",
          "4203:               if (stream_info->offset_count > 0)",
          "4204:                 (void) SeekBlob(image,(MagickOffsetType)",
          "4205:                   stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);",
          "4206:               (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,",
          "4207:                 exception);",
          "4208:             }",
          "4209:         }",
          "4210:       if (SetImageGray(image,exception) != MagickFalse)",
          "4211:         (void) SetImageColorspace(image,GRAYColorspace,exception);",
          "4212:       if (EOFBlob(image) != MagickFalse)",
          "4213:         {",
          "4214:           ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "4215:             image->filename);",
          "4216:           break;",
          "4217:         }",
          "4219:         Proceed to next image.",
          "4221:       if (image_info->number_scenes != 0)",
          "4222:         if (image->scene >= (image_info->scene+image_info->number_scenes-1))",
          "4223:           break;",
          "4224:       if (scene < (ssize_t) (number_scenes-1))",
          "4225:         {",
          "4227:             Allocate next image structure.",
          "4229:           AcquireNextImage(image_info,image,exception);",
          "4230:           if (GetNextImageInList(image) == (Image *) NULL)",
          "4231:             {",
          "4232:               image=DestroyImageList(image);",
          "4233:               return((Image *) NULL);",
          "4234:             }",
          "4235:           image=SyncNextImageInList(image);",
          "4236:           status=SetImageProgress(image,LoadImagesTag,TellBlob(image),",
          "4237:             GetBlobSize(image));",
          "4238:           if (status == MagickFalse)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4199:             return((Image *) NULL);",
          "4200:           }",
          "4201:         image=SyncNextImageInList(image);",
          "4203:           GetBlobSize(image));",
          "4204:         if (status == MagickFalse)",
          "4205:           break;",
          "",
          "[Removed Lines]",
          "4202:         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),",
          "",
          "[Added Lines]",
          "4254:         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),",
          "",
          "---------------"
        ]
      }
    }
  ]
}
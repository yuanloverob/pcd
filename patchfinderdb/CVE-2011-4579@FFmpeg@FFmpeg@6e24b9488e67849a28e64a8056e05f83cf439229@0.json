{
  "cve_id": "CVE-2011-4579",
  "cve_desc": "The svq1_decode_frame function in the SVQ1 decoder (svq1dec.c) in libavcodec in FFmpeg 0.5.x before 0.5.7, 0.6.x before 0.6.4, 0.7.x before 0.7.9, and 0.8.x before 0.8.8; and in Libav 0.5.x before 0.5.6, 0.6.x before 0.6.4, and 0.7.x before 0.7.3 allows remote attackers to cause a denial of service (memory corruption) via a crafted SVQ1 stream, related to \"dimensions changed.\"",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "6e24b9488e67849a28e64a8056e05f83cf439229",
  "patch_info": {
    "commit_hash": "6e24b9488e67849a28e64a8056e05f83cf439229",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/6e24b9488e67849a28e64a8056e05f83cf439229",
    "files": [
      "libavcodec/svq1dec.c"
    ],
    "message": "svq1dec: call avcodec_set_dimensions() after dimensions changed.\n\nFixes NGS00148, CVE-2011-4579\n\nFound-by: Phillip Langlois\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/svq1dec.c||libavcodec/svq1dec.c": [
      "File: libavcodec/svq1dec.c -> libavcodec/svq1dec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "659:     av_dlog(s->avctx, \"Error in svq1_decode_frame_header %i\\n\",result);",
      "660:     return result;",
      "661:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "662:   avcodec_set_dimensions(avctx, s->width, s->height);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8ddc0b491d3c9c11c1e3d638fda51b4b604d32f4",
      "candidate_info": {
        "commit_hash": "8ddc0b491d3c9c11c1e3d638fda51b4b604d32f4",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/8ddc0b491d3c9c11c1e3d638fda51b4b604d32f4",
        "files": [
          "libavcodec/svq1dec.c"
        ],
        "message": "svq1dec: call avcodec_set_dimensions() after dimensions changed.\n\nFixes NGS00148, CVE-2011-4579\n\nFound-by: Phillip Langlois\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n\n(cherry picked from commit 6e24b9488e67849a28e64a8056e05f83cf439229)\n\nSigned-off-by: Reinhard Tartler <siretart@tauware.de>\n(cherry picked from commit 0eca0da06e40b73af495cc05fbcfaa030fcf78ea)\n\nSigned-off-by: Reinhard Tartler <siretart@tauware.de>",
        "before_after_code_files": [
          "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ],
          "candidate": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/svq1dec.c||libavcodec/svq1dec.c": [
          "File: libavcodec/svq1dec.c -> libavcodec/svq1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "678: #endif",
          "679:     return result;",
          "680:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "681:   avcodec_set_dimensions(avctx, s->width, s->height);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "110aff4b2451bf8768523f6c7f054d2c04cd2a26",
      "candidate_info": {
        "commit_hash": "110aff4b2451bf8768523f6c7f054d2c04cd2a26",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/110aff4b2451bf8768523f6c7f054d2c04cd2a26",
        "files": [
          "libavcodec/svq1dec.c"
        ],
        "message": "svq1dec: call avcodec_set_dimensions() after dimensions changed.\n\nFixes NGS00148, CVE-2011-4579\n\nFound-by: Phillip Langlois\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n\n(cherry picked from commit 6e24b9488e67849a28e64a8056e05f83cf439229)\n\nSigned-off-by: Reinhard Tartler <siretart@tauware.de>\n(cherry picked from commit 0eca0da06e40b73af495cc05fbcfaa030fcf78ea)\n\nSigned-off-by: Reinhard Tartler <siretart@tauware.de>\n(cherry picked from commit 8ddc0b491d3c9c11c1e3d638fda51b4b604d32f4)\n\nSigned-off-by: Reinhard Tartler <siretart@tauware.de>",
        "before_after_code_files": [
          "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ],
          "candidate": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/svq1dec.c||libavcodec/svq1dec.c": [
          "File: libavcodec/svq1dec.c -> libavcodec/svq1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "676: #endif",
          "677:     return result;",
          "678:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "679:   avcodec_set_dimensions(avctx, s->width, s->height);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0eca0da06e40b73af495cc05fbcfaa030fcf78ea",
      "candidate_info": {
        "commit_hash": "0eca0da06e40b73af495cc05fbcfaa030fcf78ea",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/0eca0da06e40b73af495cc05fbcfaa030fcf78ea",
        "files": [
          "libavcodec/svq1dec.c"
        ],
        "message": "svq1dec: call avcodec_set_dimensions() after dimensions changed.\n\nFixes NGS00148, CVE-2011-4579\n\nFound-by: Phillip Langlois\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n\n(cherry picked from commit 6e24b9488e67849a28e64a8056e05f83cf439229)\n\nSigned-off-by: Reinhard Tartler <siretart@tauware.de>",
        "before_after_code_files": [
          "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ],
          "candidate": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/svq1dec.c||libavcodec/svq1dec.c": [
          "File: libavcodec/svq1dec.c -> libavcodec/svq1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "658:     av_dlog(s->avctx, \"Error in svq1_decode_frame_header %i\\n\",result);",
          "659:     return result;",
          "660:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "661:   avcodec_set_dimensions(avctx, s->width, s->height);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "48238fd00b22518158999a0aac5d620bc31dc8d7",
      "candidate_info": {
        "commit_hash": "48238fd00b22518158999a0aac5d620bc31dc8d7",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/48238fd00b22518158999a0aac5d620bc31dc8d7",
        "files": [
          "libavcodec/svq1dec.c"
        ],
        "message": "svq1: Fix building with -DDEBUG\n\nSigned-off-by: Martin Storsj\u00f6 <martin@martin.st>",
        "before_after_code_files": [
          "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ],
          "candidate": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/svq1dec.c||libavcodec/svq1dec.c": [
          "File: libavcodec/svq1dec.c -> libavcodec/svq1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "640:     result = svq1_decode_frame_header(avctx, cur);",
          "642:     if (result != 0) {",
          "644:         return result;",
          "645:     }",
          "646:     avcodec_set_dimensions(avctx, s->width, s->height);",
          "",
          "[Removed Lines]",
          "643:         av_dlog(s->avctx, \"Error in svq1_decode_frame_header %i\\n\", result);",
          "",
          "[Added Lines]",
          "643:         av_dlog(avctx, \"Error in svq1_decode_frame_header %i\\n\", result);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "707:                                                      previous, linesize,",
          "708:                                                      pmv, x, y);",
          "709:                     if (result != 0) {",
          "711:                                 \"Error in svq1_decode_delta_block %i\\n\",",
          "712:                                 result);",
          "713:                         goto err;",
          "",
          "[Removed Lines]",
          "710:                         av_dlog(s->avctx,",
          "",
          "[Added Lines]",
          "710:                         av_dlog(avctx,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ada12f836657648271972428b0e4a50c81eb7e15",
      "candidate_info": {
        "commit_hash": "ada12f836657648271972428b0e4a50c81eb7e15",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/ada12f836657648271972428b0e4a50c81eb7e15",
        "files": [
          "libavcodec/svq1.c",
          "libavcodec/svq1.h",
          "libavcodec/svq13.c",
          "libavcodec/svq1_vlc.h",
          "libavcodec/svq1dec.c",
          "libavcodec/svq1enc.c",
          "libavcodec/svq1enc_cb.h"
        ],
        "message": "svq1: K&R formatting cosmetics",
        "before_after_code_files": [
          "libavcodec/svq1.c||libavcodec/svq1.c",
          "libavcodec/svq1.h||libavcodec/svq1.h",
          "libavcodec/svq13.c||libavcodec/svq13.c",
          "libavcodec/svq1_vlc.h||libavcodec/svq1_vlc.h",
          "libavcodec/svq1dec.c||libavcodec/svq1dec.c",
          "libavcodec/svq1enc.c||libavcodec/svq1enc.c",
          "libavcodec/svq1enc_cb.h||libavcodec/svq1enc_cb.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ],
          "candidate": [
            "libavcodec/svq1dec.c||libavcodec/svq1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/svq1.c||libavcodec/svq1.c": [
          "File: libavcodec/svq1.c -> libavcodec/svq1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: const struct svq1_frame_size ff_svq1_frame_size_table[7] = {",
          "43: };",
          "",
          "[Removed Lines]",
          "41:   { 160, 120 }, { 128,  96 }, { 176, 144 }, { 352, 288 },",
          "42:   { 704, 576 }, { 240, 180 }, { 320, 240 }",
          "",
          "[Added Lines]",
          "41:     { 160, 120 }, { 128,  96 }, { 176, 144 }, { 352, 288 },",
          "42:     { 704, 576 }, { 240, 180 }, { 320, 240 }",
          "",
          "---------------"
        ],
        "libavcodec/svq1.h||libavcodec/svq1.h": [
          "File: libavcodec/svq1.h -> libavcodec/svq1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:     uint16_t height;",
          "48: };",
          "56: extern const uint8_t ff_svq1_block_type_vlc[4][2];",
          "57: extern const uint8_t ff_svq1_intra_multistage_vlc[6][8][2];",
          "",
          "[Removed Lines]",
          "50: uint16_t ff_svq1_packet_checksum (const uint8_t *data, const int length,",
          "51:                                   int value);",
          "53: extern const int8_t* const ff_svq1_inter_codebooks[6];",
          "54: extern const int8_t* const ff_svq1_intra_codebooks[6];",
          "",
          "[Added Lines]",
          "50: uint16_t ff_svq1_packet_checksum(const uint8_t *data,",
          "51:                                  const int length, int value);",
          "53: extern const int8_t *const ff_svq1_inter_codebooks[6];",
          "54: extern const int8_t *const ff_svq1_intra_codebooks[6];",
          "",
          "---------------"
        ],
        "libavcodec/svq13.c||libavcodec/svq13.c": [
          "File: libavcodec/svq13.c -> libavcodec/svq13.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"svq1.h\"",
          "25: static const uint16_t checksum_table[256] = {",
          "58: };",
          "68: }",
          "",
          "[Removed Lines]",
          "26:   0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,",
          "27:   0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,",
          "28:   0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,",
          "29:   0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,",
          "30:   0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,",
          "31:   0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,",
          "32:   0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,",
          "33:   0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,",
          "34:   0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,",
          "35:   0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,",
          "36:   0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,",
          "37:   0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,",
          "38:   0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,",
          "39:   0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,",
          "40:   0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,",
          "41:   0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,",
          "42:   0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,",
          "43:   0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,",
          "44:   0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,",
          "45:   0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,",
          "46:   0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,",
          "47:   0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,",
          "48:   0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,",
          "49:   0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,",
          "50:   0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,",
          "51:   0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,",
          "52:   0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,",
          "53:   0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,",
          "54:   0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,",
          "55:   0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,",
          "56:   0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,",
          "57:   0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0",
          "60: uint16_t ff_svq1_packet_checksum (const uint8_t *data, const int length, int value) {",
          "61:   int i;",
          "63:   for (i=0; i < length; i++) {",
          "64:     value = checksum_table[data[i] ^ (value >> 8)] ^ ((value & 0xFF) << 8);",
          "65:   }",
          "67:   return value;",
          "",
          "[Added Lines]",
          "26:     0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,",
          "27:     0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,",
          "28:     0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,",
          "29:     0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,",
          "30:     0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,",
          "31:     0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,",
          "32:     0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,",
          "33:     0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,",
          "34:     0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,",
          "35:     0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,",
          "36:     0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,",
          "37:     0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,",
          "38:     0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,",
          "39:     0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,",
          "40:     0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,",
          "41:     0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,",
          "42:     0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,",
          "43:     0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,",
          "44:     0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,",
          "45:     0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,",
          "46:     0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,",
          "47:     0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,",
          "48:     0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,",
          "49:     0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,",
          "50:     0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,",
          "51:     0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,",
          "52:     0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,",
          "53:     0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,",
          "54:     0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,",
          "55:     0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,",
          "56:     0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,",
          "57:     0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0",
          "60: uint16_t ff_svq1_packet_checksum (const uint8_t *data,",
          "61:                                   const int length, int value)",
          "62: {",
          "63:     int i;",
          "65:     for (i = 0; i < length; i++)",
          "66:         value = checksum_table[data[i] ^ (value >> 8)] ^ ((value & 0xFF) << 8);",
          "68:     return value;",
          "",
          "---------------"
        ],
        "libavcodec/svq1_vlc.h||libavcodec/svq1_vlc.h": [
          "File: libavcodec/svq1_vlc.h -> libavcodec/svq1_vlc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: const uint8_t ff_svq1_block_type_vlc[4][2] = {",
          "29:     { 0x1, 1 },  { 0x1, 2 },  { 0x1, 3 },  { 0x0, 3 }",
          "31: };",
          "34: const uint8_t ff_svq1_intra_multistage_vlc[6][8][2] = {",
          "55: };",
          "58: const uint8_t ff_svq1_inter_multistage_vlc[6][8][2] = {",
          "79: };",
          "82: const uint16_t ff_svq1_intra_mean_vlc[256][2] = {",
          "135:     { 0x19, 10 },  { 0x2A, 10 },  { 0x17, 10 },  { 0x16, 10 },",
          "136:     { 0x15, 10 },  { 0x28, 10 },  { 0x26, 10 },  { 0x25, 10 },",
          "137:     { 0x22, 10 },  { 0x21, 10 },  { 0x18, 10 },  { 0x14, 10 },",
          "140:     { 0x1B, 10 },  { 0x1C, 10 },  { 0x1D, 10 },  { 0x1E, 10 },",
          "141:     { 0x1F, 10 },  { 0x20, 10 },  { 0x13, 10 },  { 0x23, 10 },",
          "148: };",
          "151: const uint16_t ff_svq1_inter_mean_vlc[512][2] = {",
          "153:     { 0x5A, 22 },  { 0xD4, 22 },  { 0xD5, 22 },  { 0xD6, 22 },",
          "154:     { 0xD7, 22 },  { 0xD8, 22 },  { 0xD9, 22 },  { 0xDA, 22 },",
          "155:     { 0xDB, 22 },  { 0xDC, 22 },  { 0xDD, 22 },  { 0xDE, 22 },",
          "",
          "[Removed Lines]",
          "36: {",
          "37:     { 0x1, 5 },  { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },",
          "38:     { 0x3, 4 },  { 0x2, 4 },  { 0x0, 5 },  { 0x1, 4 }",
          "39: },{",
          "40:     { 0x1, 4 },  { 0x3, 2 },  { 0x5, 3 },  { 0x4, 3 },",
          "41:     { 0x3, 3 },  { 0x2, 3 },  { 0x0, 4 },  { 0x1, 3 }",
          "42: },{",
          "43:     { 0x1, 5 },  { 0x1, 1 },  { 0x3, 3 },  { 0x0, 5 },",
          "44:     { 0x3, 4 },  { 0x2, 3 },  { 0x2, 4 },  { 0x1, 4 }",
          "45: },{",
          "46:     { 0x1, 6 },  { 0x1, 1 },  { 0x1, 2 },  { 0x0, 6 },",
          "47:     { 0x3, 4 },  { 0x2, 4 },  { 0x1, 5 },  { 0x1, 4 }",
          "48: },{",
          "49:     { 0x1, 6 },  { 0x1, 1 },  { 0x1, 2 },  { 0x3, 5 },",
          "50:     { 0x2, 5 },  { 0x0, 6 },  { 0x1, 5 },  { 0x1, 3 }",
          "51: },{",
          "52:     { 0x1, 7 },  { 0x1, 1 },  { 0x1, 2 },  { 0x1, 3 },",
          "53:     { 0x1, 4 },  { 0x1, 6 },  { 0x0, 7 },  { 0x1, 5 }",
          "54: }",
          "60: {",
          "61:     { 0x3, 2 },  { 0x5, 3 },  { 0x4, 3 },  { 0x3, 3 },",
          "62:     { 0x2, 3 },  { 0x1, 3 },  { 0x1, 4 },  { 0x0, 4 }",
          "63: },{",
          "64:     { 0x3, 2 },  { 0x5, 3 },  { 0x4, 3 },  { 0x3, 3 },",
          "65:     { 0x2, 3 },  { 0x1, 3 },  { 0x1, 4 },  { 0x0, 4 }",
          "66: },{",
          "67:     { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },  { 0x3, 4 },",
          "68:     { 0x2, 4 },  { 0x1, 4 },  { 0x1, 5 },  { 0x0, 5 }",
          "69: },{",
          "70:     { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },  { 0x3, 4 },",
          "71:     { 0x2, 4 },  { 0x1, 4 },  { 0x1, 5 },  { 0x0, 5 }",
          "72: },{",
          "73:     { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },  { 0x3, 4 },",
          "74:     { 0x2, 4 },  { 0x1, 4 },  { 0x1, 5 },  { 0x0, 5 }",
          "75: },{",
          "76:     { 0x1, 1 },  { 0x1, 2 },  { 0x1, 3 },  { 0x3, 5 },",
          "77:     { 0x2, 5 },  { 0x1, 5 },  { 0x1, 6 },  { 0x0, 6 }",
          "78: }",
          "84:     { 0x37, 6 },  { 0x56, 7 },  { 0x1, 17 },  { 0x1, 20 },",
          "85:     { 0x2, 20 },  { 0x3, 20 },  { 0x0, 20 },  { 0x4, 20 },",
          "86:     { 0x5, 20 },  { 0x3, 19 },  { 0x15, 11 },  { 0x42, 9 },",
          "87:     { 0x14, 11 },  { 0x3, 14 },  { 0x2, 14 },  { 0x1, 15 },",
          "88:     { 0x1, 16 },  { 0x1, 12 },  { 0x2B, 10 },  { 0x18, 11 },",
          "89:     { 0xC, 11 },  { 0x41, 9 },  { 0x78, 8 },  { 0x6C, 8 },",
          "90:     { 0x55, 7 },  { 0xF, 4 },  { 0xE, 4 },  { 0x34, 6 },",
          "91:     { 0x51, 7 },  { 0x72, 8 },  { 0x6E, 8 },  { 0x40, 9 },",
          "92:     { 0x3F, 9 },  { 0x3E, 9 },  { 0x3D, 9 },  { 0x3C, 9 },",
          "93:     { 0x3B, 9 },  { 0x3A, 9 },  { 0x39, 9 },  { 0x38, 9 },",
          "94:     { 0x37, 9 },  { 0x43, 9 },  { 0x46, 9 },  { 0x47, 9 },",
          "95:     { 0x45, 9 },  { 0x44, 9 },  { 0x49, 9 },  { 0x48, 9 },",
          "96:     { 0x4A, 8 },  { 0x79, 8 },  { 0x76, 8 },  { 0x77, 8 },",
          "97:     { 0x71, 8 },  { 0x75, 8 },  { 0x74, 8 },  { 0x73, 8 },",
          "98:     { 0x6A, 8 },  { 0x55, 8 },  { 0x70, 8 },  { 0x6F, 8 },",
          "99:     { 0x52, 8 },  { 0x6D, 8 },  { 0x4C, 8 },  { 0x6B, 8 },",
          "100:     { 0x40, 7 },  { 0x69, 8 },  { 0x68, 8 },  { 0x67, 8 },",
          "101:     { 0x66, 8 },  { 0x65, 8 },  { 0x64, 8 },  { 0x63, 8 },",
          "102:     { 0x62, 8 },  { 0x61, 8 },  { 0x60, 8 },  { 0x5F, 8 },",
          "103:     { 0x5E, 8 },  { 0x5D, 8 },  { 0x5C, 8 },  { 0x5B, 8 },",
          "104:     { 0x5A, 8 },  { 0x59, 8 },  { 0x58, 8 },  { 0x57, 8 },",
          "105:     { 0x56, 8 },  { 0x3D, 7 },  { 0x54, 8 },  { 0x53, 8 },",
          "106:     { 0x3F, 7 },  { 0x51, 8 },  { 0x50, 8 },  { 0x4F, 8 },",
          "107:     { 0x4E, 8 },  { 0x4D, 8 },  { 0x41, 7 },  { 0x4B, 8 },",
          "108:     { 0x53, 7 },  { 0x3E, 7 },  { 0x48, 8 },  { 0x4F, 7 },",
          "109:     { 0x52, 7 },  { 0x45, 8 },  { 0x50, 7 },  { 0x43, 8 },",
          "110:     { 0x42, 8 },  { 0x41, 8 },  { 0x42, 7 },  { 0x43, 7 },",
          "111:     { 0x3E, 8 },  { 0x44, 7 },  { 0x3C, 8 },  { 0x45, 7 },",
          "112:     { 0x46, 7 },  { 0x47, 7 },  { 0x48, 7 },  { 0x49, 7 },",
          "113:     { 0x4A, 7 },  { 0x4B, 7 },  { 0x4C, 7 },  { 0x4D, 7 },",
          "114:     { 0x4E, 7 },  { 0x58, 7 },  { 0x59, 7 },  { 0x5A, 7 },",
          "115:     { 0x5B, 7 },  { 0x5C, 7 },  { 0x5D, 7 },  { 0x44, 8 },",
          "116:     { 0x49, 8 },  { 0x29, 8 },  { 0x3F, 8 },  { 0x3D, 8 },",
          "117:     { 0x3B, 8 },  { 0x2C, 8 },  { 0x28, 8 },  { 0x25, 8 },",
          "118:     { 0x26, 8 },  { 0x5E, 7 },  { 0x57, 7 },  { 0x54, 7 },",
          "119:     { 0x5F, 7 },  { 0x62, 7 },  { 0x63, 7 },  { 0x64, 7 },",
          "120:     { 0x61, 7 },  { 0x65, 7 },  { 0x67, 7 },  { 0x66, 7 },",
          "121:     { 0x35, 6 },  { 0x36, 6 },  { 0x60, 7 },  { 0x39, 8 },",
          "122:     { 0x3A, 8 },  { 0x38, 8 },  { 0x37, 8 },  { 0x36, 8 },",
          "123:     { 0x35, 8 },  { 0x34, 8 },  { 0x33, 8 },  { 0x32, 8 },",
          "124:     { 0x31, 8 },  { 0x30, 8 },  { 0x2D, 8 },  { 0x2B, 8 },",
          "125:     { 0x2A, 8 },  { 0x27, 8 },  { 0x40, 8 },  { 0x46, 8 },",
          "126:     { 0x47, 8 },  { 0x26, 9 },  { 0x25, 9 },  { 0x24, 9 },",
          "127:     { 0x23, 9 },  { 0x22, 9 },  { 0x2E, 8 },  { 0x2F, 8 },",
          "128:     { 0x1F, 9 },  { 0x36, 9 },  { 0x1D, 9 },  { 0x21, 9 },",
          "129:     { 0x1B, 9 },  { 0x1C, 9 },  { 0x19, 9 },  { 0x1A, 9 },",
          "130:     { 0x18, 9 },  { 0x17, 9 },  { 0x16, 9 },  { 0x1E, 9 },",
          "131:     { 0x20, 9 },  { 0x27, 9 },  { 0x28, 9 },  { 0x29, 9 },",
          "132:     { 0x2A, 9 },  { 0x2B, 9 },  { 0x2C, 9 },  { 0x2D, 9 },",
          "133:     { 0x2E, 9 },  { 0x2F, 9 },  { 0x30, 9 },  { 0x35, 9 },",
          "134:     { 0x31, 9 },  { 0x32, 9 },  { 0x33, 9 },  { 0x34, 9 },",
          "138:     { 0x29, 10 },  { 0x12, 10 },  { 0xD, 10 },  { 0xE, 10 },",
          "139:     { 0xF, 10 },  { 0x10, 10 },  { 0x11, 10 },  { 0x1A, 10 },",
          "142:     { 0x24, 10 },  { 0x9, 11 },  { 0x8, 11 },  { 0x7, 11 },",
          "143:     { 0x27, 10 },  { 0x5, 11 },  { 0xB, 11 },  { 0x6, 11 },",
          "144:     { 0x4, 11 },  { 0x3, 11 },  { 0x2, 11 },  { 0x1, 11 },",
          "145:     { 0xA, 11 },  { 0x16, 11 },  { 0x19, 11 },  { 0x17, 11 },",
          "146:     { 0xD, 11 },  { 0xE, 11 },  { 0xF, 11 },  { 0x10, 11 },",
          "147:     { 0x11, 11 },  { 0x12, 11 },  { 0x13, 11 },  { 0x1, 14 }",
          "",
          "[Added Lines]",
          "35:     { { 0x1, 5 },  { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },",
          "36:       { 0x3, 4 },  { 0x2, 4 },  { 0x0, 5 },  { 0x1, 4 } },",
          "37:     { { 0x1, 4 },  { 0x3, 2 },  { 0x5, 3 },  { 0x4, 3 },",
          "38:       { 0x3, 3 },  { 0x2, 3 },  { 0x0, 4 },  { 0x1, 3 } },",
          "39:     { { 0x1, 5 },  { 0x1, 1 },  { 0x3, 3 },  { 0x0, 5 },",
          "40:       { 0x3, 4 },  { 0x2, 3 },  { 0x2, 4 },  { 0x1, 4 } },",
          "41:     { { 0x1, 6 },  { 0x1, 1 },  { 0x1, 2 },  { 0x0, 6 },",
          "42:       { 0x3, 4 },  { 0x2, 4 },  { 0x1, 5 },  { 0x1, 4 } },",
          "43:     { { 0x1, 6 },  { 0x1, 1 },  { 0x1, 2 },  { 0x3, 5 },",
          "44:       { 0x2, 5 },  { 0x0, 6 },  { 0x1, 5 },  { 0x1, 3 } },",
          "45:     { { 0x1, 7 },  { 0x1, 1 },  { 0x1, 2 },  { 0x1, 3 },",
          "46:       { 0x1, 4 },  { 0x1, 6 },  { 0x0, 7 },  { 0x1, 5 } }",
          "52:     { { 0x3, 2 },  { 0x5, 3 },  { 0x4, 3 },  { 0x3, 3 },",
          "53:       { 0x2, 3 },  { 0x1, 3 },  { 0x1, 4 },  { 0x0, 4 } },",
          "54:     { { 0x3, 2 },  { 0x5, 3 },  { 0x4, 3 },  { 0x3, 3 },",
          "55:       { 0x2, 3 },  { 0x1, 3 },  { 0x1, 4 },  { 0x0, 4 } },",
          "56:     { { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },  { 0x3, 4 },",
          "57:       { 0x2, 4 },  { 0x1, 4 },  { 0x1, 5 },  { 0x0, 5 } },",
          "58:     { { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },  { 0x3, 4 },",
          "59:       { 0x2, 4 },  { 0x1, 4 },  { 0x1, 5 },  { 0x0, 5 } },",
          "60:     { { 0x1, 1 },  { 0x3, 3 },  { 0x2, 3 },  { 0x3, 4 },",
          "61:       { 0x2, 4 },  { 0x1, 4 },  { 0x1, 5 },  { 0x0, 5 } },",
          "62:     { { 0x1, 1 },  { 0x1, 2 },  { 0x1, 3 },  { 0x3, 5 },",
          "63:       { 0x2, 5 },  { 0x1, 5 },  { 0x1, 6 },  { 0x0, 6 } }",
          "69:     { 0x37,  6 },  { 0x56,  7 },  { 0x01, 17 },  { 0x01, 20 },",
          "70:     { 0x02, 20 },  { 0x03, 20 },  { 0x00, 20 },  { 0x04, 20 },",
          "71:     { 0x05, 20 },  { 0x03, 19 },  { 0x15, 11 },  { 0x42,  9 },",
          "72:     { 0x14, 11 },  { 0x03, 14 },  { 0x02, 14 },  { 0x01, 15 },",
          "73:     { 0x01, 16 },  { 0x01, 12 },  { 0x2B, 10 },  { 0x18, 11 },",
          "74:     { 0x0C, 11 },  { 0x41,  9 },  { 0x78,  8 },  { 0x6C,  8 },",
          "75:     { 0x55,  7 },  { 0x0F,  4 },  { 0x0E,  4 },  { 0x34,  6 },",
          "76:     { 0x51,  7 },  { 0x72,  8 },  { 0x6E,  8 },  { 0x40,  9 },",
          "77:     { 0x3F,  9 },  { 0x3E,  9 },  { 0x3D,  9 },  { 0x3C,  9 },",
          "78:     { 0x3B,  9 },  { 0x3A,  9 },  { 0x39,  9 },  { 0x38,  9 },",
          "79:     { 0x37,  9 },  { 0x43,  9 },  { 0x46,  9 },  { 0x47,  9 },",
          "80:     { 0x45,  9 },  { 0x44,  9 },  { 0x49,  9 },  { 0x48,  9 },",
          "81:     { 0x4A,  8 },  { 0x79,  8 },  { 0x76,  8 },  { 0x77,  8 },",
          "82:     { 0x71,  8 },  { 0x75,  8 },  { 0x74,  8 },  { 0x73,  8 },",
          "83:     { 0x6A,  8 },  { 0x55,  8 },  { 0x70,  8 },  { 0x6F,  8 },",
          "84:     { 0x52,  8 },  { 0x6D,  8 },  { 0x4C,  8 },  { 0x6B,  8 },",
          "85:     { 0x40,  7 },  { 0x69,  8 },  { 0x68,  8 },  { 0x67,  8 },",
          "86:     { 0x66,  8 },  { 0x65,  8 },  { 0x64,  8 },  { 0x63,  8 },",
          "87:     { 0x62,  8 },  { 0x61,  8 },  { 0x60,  8 },  { 0x5F,  8 },",
          "88:     { 0x5E,  8 },  { 0x5D,  8 },  { 0x5C,  8 },  { 0x5B,  8 },",
          "89:     { 0x5A,  8 },  { 0x59,  8 },  { 0x58,  8 },  { 0x57,  8 },",
          "90:     { 0x56,  8 },  { 0x3D,  7 },  { 0x54,  8 },  { 0x53,  8 },",
          "91:     { 0x3F,  7 },  { 0x51,  8 },  { 0x50,  8 },  { 0x4F,  8 },",
          "92:     { 0x4E,  8 },  { 0x4D,  8 },  { 0x41,  7 },  { 0x4B,  8 },",
          "93:     { 0x53,  7 },  { 0x3E,  7 },  { 0x48,  8 },  { 0x4F,  7 },",
          "94:     { 0x52,  7 },  { 0x45,  8 },  { 0x50,  7 },  { 0x43,  8 },",
          "95:     { 0x42,  8 },  { 0x41,  8 },  { 0x42,  7 },  { 0x43,  7 },",
          "96:     { 0x3E,  8 },  { 0x44,  7 },  { 0x3C,  8 },  { 0x45,  7 },",
          "97:     { 0x46,  7 },  { 0x47,  7 },  { 0x48,  7 },  { 0x49,  7 },",
          "98:     { 0x4A,  7 },  { 0x4B,  7 },  { 0x4C,  7 },  { 0x4D,  7 },",
          "99:     { 0x4E,  7 },  { 0x58,  7 },  { 0x59,  7 },  { 0x5A,  7 },",
          "100:     { 0x5B,  7 },  { 0x5C,  7 },  { 0x5D,  7 },  { 0x44,  8 },",
          "101:     { 0x49,  8 },  { 0x29,  8 },  { 0x3F,  8 },  { 0x3D,  8 },",
          "102:     { 0x3B,  8 },  { 0x2C,  8 },  { 0x28,  8 },  { 0x25,  8 },",
          "103:     { 0x26,  8 },  { 0x5E,  7 },  { 0x57,  7 },  { 0x54,  7 },",
          "104:     { 0x5F,  7 },  { 0x62,  7 },  { 0x63,  7 },  { 0x64,  7 },",
          "105:     { 0x61,  7 },  { 0x65,  7 },  { 0x67,  7 },  { 0x66,  7 },",
          "106:     { 0x35,  6 },  { 0x36,  6 },  { 0x60,  7 },  { 0x39,  8 },",
          "107:     { 0x3A,  8 },  { 0x38,  8 },  { 0x37,  8 },  { 0x36,  8 },",
          "108:     { 0x35,  8 },  { 0x34,  8 },  { 0x33,  8 },  { 0x32,  8 },",
          "109:     { 0x31,  8 },  { 0x30,  8 },  { 0x2D,  8 },  { 0x2B,  8 },",
          "110:     { 0x2A,  8 },  { 0x27,  8 },  { 0x40,  8 },  { 0x46,  8 },",
          "111:     { 0x47,  8 },  { 0x26,  9 },  { 0x25,  9 },  { 0x24,  9 },",
          "112:     { 0x23,  9 },  { 0x22,  9 },  { 0x2E,  8 },  { 0x2F,  8 },",
          "113:     { 0x1F,  9 },  { 0x36,  9 },  { 0x1D,  9 },  { 0x21,  9 },",
          "114:     { 0x1B,  9 },  { 0x1C,  9 },  { 0x19,  9 },  { 0x1A,  9 },",
          "115:     { 0x18,  9 },  { 0x17,  9 },  { 0x16,  9 },  { 0x1E,  9 },",
          "116:     { 0x20,  9 },  { 0x27,  9 },  { 0x28,  9 },  { 0x29,  9 },",
          "117:     { 0x2A,  9 },  { 0x2B,  9 },  { 0x2C,  9 },  { 0x2D,  9 },",
          "118:     { 0x2E,  9 },  { 0x2F,  9 },  { 0x30,  9 },  { 0x35,  9 },",
          "119:     { 0x31,  9 },  { 0x32,  9 },  { 0x33,  9 },  { 0x34,  9 },",
          "123:     { 0x29, 10 },  { 0x12, 10 },  { 0x0D, 10 },  { 0x0E, 10 },",
          "124:     { 0x0F, 10 },  { 0x10, 10 },  { 0x11, 10 },  { 0x1A, 10 },",
          "127:     { 0x24, 10 },  { 0x09, 11 },  { 0x08, 11 },  { 0x07, 11 },",
          "128:     { 0x27, 10 },  { 0x05, 11 },  { 0x0B, 11 },  { 0x06, 11 },",
          "129:     { 0x04, 11 },  { 0x03, 11 },  { 0x02, 11 },  { 0x01, 11 },",
          "130:     { 0x0A, 11 },  { 0x16, 11 },  { 0x19, 11 },  { 0x17, 11 },",
          "131:     { 0x0D, 11 },  { 0x0E, 11 },  { 0x0F, 11 },  { 0x10, 11 },",
          "132:     { 0x11, 11 },  { 0x12, 11 },  { 0x13, 11 },  { 0x01, 14 }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "159:     { 0xE7, 22 },  { 0xEC, 22 },  { 0xED, 22 },  { 0xEE, 22 },",
          "160:     { 0xEF, 22 },  { 0xF0, 22 },  { 0xF1, 22 },  { 0xF2, 22 },",
          "161:     { 0xF3, 22 },  { 0xF4, 22 },  { 0xF5, 22 },  { 0xF6, 22 },",
          "163:     { 0xF9, 22 },  { 0xFC, 22 },  { 0xFD, 22 },  { 0xFE, 22 },",
          "166:     { 0xFF, 22 },  { 0x86, 21 },  { 0xFA, 22 },  { 0x7C, 22 },",
          "168:     { 0x7B, 22 },  { 0x82, 22 },  { 0xD2, 22 },  { 0xD1, 22 },",
          "169:     { 0xD0, 22 },  { 0xCF, 22 },  { 0xCE, 22 },  { 0xCD, 22 },",
          "170:     { 0xCC, 22 },  { 0xC3, 22 },  { 0xCA, 22 },  { 0xC9, 22 },",
          "",
          "[Removed Lines]",
          "162:     { 0xF7, 22 },  { 0xF8, 22 },  { 0x102, 22 },  { 0xEB, 22 },",
          "164:     { 0x100, 22 },  { 0x5C, 22 },  { 0x60, 22 },  { 0x101, 22 },",
          "165:     { 0x71, 22 },  { 0x104, 22 },  { 0x105, 22 },  { 0xFB, 22 },",
          "167:     { 0x75, 22 },  { 0x103, 22 },  { 0x78, 22 },  { 0xD3, 22 },",
          "",
          "[Added Lines]",
          "147:     { 0xF7, 22 },  { 0xF8, 22 },  { 0x102,22 },  { 0xEB, 22 },",
          "149:     { 0x100,22 },  { 0x5C, 22 },  { 0x60, 22 },  { 0x101,22 },",
          "150:     { 0x71, 22 },  { 0x104,22 },  { 0x105,22 },  { 0xFB, 22 },",
          "152:     { 0x75, 22 },  { 0x103,22 },  { 0x78, 22 },  { 0xD3, 22 },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "206:     { 0x21, 14 },  { 0x13, 13 },  { 0x14, 13 },  { 0x15, 13 },",
          "207:     { 0x16, 13 },  { 0x17, 13 },  { 0x18, 13 },  { 0x19, 13 },",
          "208:     { 0x1A, 13 },  { 0x18, 12 },  { 0x17, 12 },  { 0x15, 12 },",
          "210:     { 0x10, 11 },  { 0x12, 11 },  { 0x13, 11 },  { 0x1B, 11 },",
          "222:     { 0x16, 10 },  { 0x15, 10 },  { 0x19, 11 },  { 0x18, 11 },",
          "223:     { 0x17, 11 },  { 0x16, 11 },  { 0x15, 11 },  { 0x14, 11 },",
          "224:     { 0x11, 11 },  { 0x19, 12 },  { 0x1A, 12 },  { 0x16, 12 },",
          "",
          "[Removed Lines]",
          "209:     { 0x14, 12 },  { 0x13, 12 },  { 0x12, 12 },  { 0xF, 11 },",
          "211:     { 0x1A, 11 },  { 0xE, 10 },  { 0x13, 10 },  { 0xF, 10 },",
          "212:     { 0x10, 10 },  { 0x11, 10 },  { 0x12, 10 },  { 0xD, 9 },",
          "213:     { 0x14, 9 },  { 0x15, 9 },  { 0xC, 9 },  { 0x13, 9 },",
          "214:     { 0xF, 8 },  { 0xE, 8 },  { 0x10, 8 },  { 0x11, 8 },",
          "215:     { 0xC, 7 },  { 0x9, 7 },  { 0xA, 7 },  { 0x8, 6 },",
          "216:     { 0x9, 6 },  { 0x9, 5 },  { 0x8, 5 },  { 0x5, 4 },",
          "217:     { 0x1, 1 },  { 0x3, 3 },  { 0x7, 5 },  { 0x6, 5 },",
          "218:     { 0xB, 6 },  { 0xA, 6 },  { 0xE, 7 },  { 0xF, 7 },",
          "219:     { 0xB, 7 },  { 0xD, 7 },  { 0xB, 8 },  { 0xD, 8 },",
          "220:     { 0xC, 8 },  { 0xF, 9 },  { 0x10, 9 },  { 0x11, 9 },",
          "221:     { 0xE, 9 },  { 0x12, 9 },  { 0x17, 10 },  { 0x14, 10 },",
          "",
          "[Added Lines]",
          "194:     { 0x14, 12 },  { 0x13, 12 },  { 0x12, 12 },  { 0x0F, 11 },",
          "196:     { 0x1A, 11 },  { 0x0E, 10 },  { 0x13, 10 },  { 0x0F, 10 },",
          "197:     { 0x10, 10 },  { 0x11, 10 },  { 0x12, 10 },  { 0x0D,  9 },",
          "198:     { 0x14,  9 },  { 0x15,  9 },  { 0x0C,  9 },  { 0x13,  9 },",
          "199:     { 0x0F,  8 },  { 0x0E,  8 },  { 0x10,  8 },  { 0x11,  8 },",
          "200:     { 0x0C,  7 },  { 0x09,  7 },  { 0x0A,  7 },  { 0x08,  6 },",
          "201:     { 0x09,  6 },  { 0x09,  5 },  { 0x08,  5 },  { 0x05,  4 },",
          "202:     { 0x01,  1 },  { 0x03,  3 },  { 0x07,  5 },  { 0x06,  5 },",
          "203:     { 0x0B,  6 },  { 0x0A,  6 },  { 0x0E,  7 },  { 0x0F,  7 },",
          "204:     { 0x0B,  7 },  { 0x0D,  7 },  { 0x0B,  8 },  { 0x0D,  8 },",
          "205:     { 0x0C,  8 },  { 0x0F,  9 },  { 0x10,  9 },  { 0x11,  9 },",
          "206:     { 0x0E,  9 },  { 0x12,  9 },  { 0x17, 10 },  { 0x14, 10 },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "274:     { 0x1B, 22 },  { 0x1A, 22 },  { 0x19, 22 },  { 0x18, 22 },",
          "275:     { 0x17, 22 },  { 0x16, 22 },  { 0x15, 22 },  { 0x14, 22 },",
          "276:     { 0x13, 22 },  { 0x12, 22 },  { 0x11, 22 },  { 0x10, 22 },",
          "281: };",
          "",
          "[Removed Lines]",
          "277:     { 0xF, 22 },  { 0xE, 22 },  { 0xD, 22 },  { 0xC, 22 },",
          "278:     { 0xB, 22 },  { 0xA, 22 },  { 0x9, 22 },  { 0x8, 22 },",
          "279:     { 0x7, 22 },  { 0x6, 22 },  { 0x5, 22 },  { 0x4, 22 },",
          "280:     { 0x3, 22 },  { 0x2, 22 },  { 0x1, 22 },  { 0x0, 22 }",
          "",
          "[Added Lines]",
          "262:     { 0x0F, 22 },  { 0x0E, 22 },  { 0x0D, 22 },  { 0x0C, 22 },",
          "263:     { 0x0B, 22 },  { 0x0A, 22 },  { 0x09, 22 },  { 0x08, 22 },",
          "264:     { 0x07, 22 },  { 0x06, 22 },  { 0x05, 22 },  { 0x04, 22 },",
          "265:     { 0x03, 22 },  { 0x02, 22 },  { 0x01, 22 },  { 0x00, 22 }",
          "",
          "---------------"
        ],
        "libavcodec/svq1dec.c||libavcodec/svq1dec.c": [
          "File: libavcodec/svq1dec.c -> libavcodec/svq1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: typedef struct svq1_pmv_s {",
          "59: } svq1_pmv;",
          "61: static const uint8_t string_table[256] = {",
          "94: };",
          "110:     }",
          "203:     }",
          "210:     }",
          "221:     }",
          "225: }",
          "268: }",
          "282:     }",
          "292: }",
          "307: }",
          "352: }",
          "432:     }",
          "436: }",
          "480:     }",
          "490: }",
          "504: }",
          "554:     }",
          "574:     }",
          "578: }",
          "583: {",
          "607:     }",
          "647:     }",
          "667:         }",
          "690:     }",
          "700: err:",
          "703: }",
          "705: static av_cold int svq1_decode_init(AVCodecContext *avctx)",
          "",
          "[Removed Lines]",
          "57:   int           x;",
          "58:   int           y;",
          "62:   0x00, 0xD5, 0x7F, 0xAA, 0xFE, 0x2B, 0x81, 0x54,",
          "63:   0x29, 0xFC, 0x56, 0x83, 0xD7, 0x02, 0xA8, 0x7D,",
          "64:   0x52, 0x87, 0x2D, 0xF8, 0xAC, 0x79, 0xD3, 0x06,",
          "65:   0x7B, 0xAE, 0x04, 0xD1, 0x85, 0x50, 0xFA, 0x2F,",
          "66:   0xA4, 0x71, 0xDB, 0x0E, 0x5A, 0x8F, 0x25, 0xF0,",
          "67:   0x8D, 0x58, 0xF2, 0x27, 0x73, 0xA6, 0x0C, 0xD9,",
          "68:   0xF6, 0x23, 0x89, 0x5C, 0x08, 0xDD, 0x77, 0xA2,",
          "69:   0xDF, 0x0A, 0xA0, 0x75, 0x21, 0xF4, 0x5E, 0x8B,",
          "70:   0x9D, 0x48, 0xE2, 0x37, 0x63, 0xB6, 0x1C, 0xC9,",
          "71:   0xB4, 0x61, 0xCB, 0x1E, 0x4A, 0x9F, 0x35, 0xE0,",
          "72:   0xCF, 0x1A, 0xB0, 0x65, 0x31, 0xE4, 0x4E, 0x9B,",
          "73:   0xE6, 0x33, 0x99, 0x4C, 0x18, 0xCD, 0x67, 0xB2,",
          "74:   0x39, 0xEC, 0x46, 0x93, 0xC7, 0x12, 0xB8, 0x6D,",
          "75:   0x10, 0xC5, 0x6F, 0xBA, 0xEE, 0x3B, 0x91, 0x44,",
          "76:   0x6B, 0xBE, 0x14, 0xC1, 0x95, 0x40, 0xEA, 0x3F,",
          "77:   0x42, 0x97, 0x3D, 0xE8, 0xBC, 0x69, 0xC3, 0x16,",
          "78:   0xEF, 0x3A, 0x90, 0x45, 0x11, 0xC4, 0x6E, 0xBB,",
          "79:   0xC6, 0x13, 0xB9, 0x6C, 0x38, 0xED, 0x47, 0x92,",
          "80:   0xBD, 0x68, 0xC2, 0x17, 0x43, 0x96, 0x3C, 0xE9,",
          "81:   0x94, 0x41, 0xEB, 0x3E, 0x6A, 0xBF, 0x15, 0xC0,",
          "82:   0x4B, 0x9E, 0x34, 0xE1, 0xB5, 0x60, 0xCA, 0x1F,",
          "83:   0x62, 0xB7, 0x1D, 0xC8, 0x9C, 0x49, 0xE3, 0x36,",
          "84:   0x19, 0xCC, 0x66, 0xB3, 0xE7, 0x32, 0x98, 0x4D,",
          "85:   0x30, 0xE5, 0x4F, 0x9A, 0xCE, 0x1B, 0xB1, 0x64,",
          "86:   0x72, 0xA7, 0x0D, 0xD8, 0x8C, 0x59, 0xF3, 0x26,",
          "87:   0x5B, 0x8E, 0x24, 0xF1, 0xA5, 0x70, 0xDA, 0x0F,",
          "88:   0x20, 0xF5, 0x5F, 0x8A, 0xDE, 0x0B, 0xA1, 0x74,",
          "89:   0x09, 0xDC, 0x76, 0xA3, 0xF7, 0x22, 0x88, 0x5D,",
          "90:   0xD6, 0x03, 0xA9, 0x7C, 0x28, 0xFD, 0x57, 0x82,",
          "91:   0xFF, 0x2A, 0x80, 0x55, 0x01, 0xD4, 0x7E, 0xAB,",
          "92:   0x84, 0x51, 0xFB, 0x2E, 0x7A, 0xAF, 0x05, 0xD0,",
          "93:   0xAD, 0x78, 0xD2, 0x07, 0x53, 0x86, 0x2C, 0xF9",
          "96: #define SVQ1_PROCESS_VECTOR()\\",
          "97:     for (; level > 0; i++) {\\",
          "99:       if (i == m) {\\",
          "100:         m = n;\\",
          "101:         if (--level == 0)\\",
          "102:           break;\\",
          "103:       }\\",
          "105:       if (get_bits1 (bitbuf) == 0)\\",
          "106:         break;\\",
          "108:       list[n++] = list[i];\\",
          "109:       list[n++] = list[i] + (((level & 1) ? pitch : 1) << ((level / 2) + 1));\\",
          "112: #define SVQ1_ADD_CODEBOOK()\\",
          "114:           for (j=0; j < stages; j++) {\\",
          "115:             n3  = codebook[entries[j]] ^ 0x80808080;\\",
          "116:             n1 += ((n3 & 0xFF00FF00) >> 8);\\",
          "117:             n2 +=  (n3 & 0x00FF00FF);\\",
          "118:           }\\",
          "119: \\",
          "121:           if (n1 & 0xFF00FF00) {\\",
          "122:             n3  = ((( n1 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;\\",
          "123:             n1 += 0x7F007F00;\\",
          "124:             n1 |= (((~n1 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;\\",
          "125:             n1 &= (n3 & 0x00FF00FF);\\",
          "126:           }\\",
          "127: \\",
          "128:           if (n2 & 0xFF00FF00) {\\",
          "129:             n3  = ((( n2 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;\\",
          "130:             n2 += 0x7F007F00;\\",
          "131:             n2 |= (((~n2 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;\\",
          "132:             n2 &= (n3 & 0x00FF00FF);\\",
          "133:           }",
          "135: #define SVQ1_DO_CODEBOOK_INTRA()\\",
          "136:       for (y=0; y < height; y++) {\\",
          "137:         for (x=0; x < (width / 4); x++, codebook++) {\\",
          "138:         n1 = n4;\\",
          "139:         n2 = n4;\\",
          "140:         SVQ1_ADD_CODEBOOK()\\",
          "142:         dst[x] = (n1 << 8) | n2;\\",
          "143:         }\\",
          "144:         dst += (pitch / 4);\\",
          "145:       }",
          "147: #define SVQ1_DO_CODEBOOK_NONINTRA()\\",
          "148:       for (y=0; y < height; y++) {\\",
          "149:         for (x=0; x < (width / 4); x++, codebook++) {\\",
          "150:         n3 = dst[x];\\",
          "152:         n1 = ((n3 & 0xFF00FF00) >> 8) + n4;\\",
          "153:         n2 =  (n3 & 0x00FF00FF)          + n4;\\",
          "154:         SVQ1_ADD_CODEBOOK()\\",
          "156:         dst[x] = (n1 << 8) | n2;\\",
          "157:         }\\",
          "158:         dst += (pitch / 4);\\",
          "159:       }",
          "161: #define SVQ1_CALC_CODEBOOK_ENTRIES(cbook)\\",
          "162:       codebook = (const uint32_t *) cbook[level];\\",
          "163:       if (stages > 0)\\",
          "164:         bit_cache = get_bits (bitbuf, 4*stages);\\",
          "166:       for (j=0; j < stages; j++) {\\",
          "167:         entries[j] = (((bit_cache >> (4*(stages - j - 1))) & 0xF) + 16*j) << (level + 1);\\",
          "168:       }\\",
          "169:       mean -= (stages * 128);\\",
          "170:       n4    = ((mean + (mean >> 31)) << 16) | (mean & 0xFFFF);",
          "172: static int svq1_decode_block_intra (GetBitContext *bitbuf, uint8_t *pixels, int pitch ) {",
          "173:   uint32_t    bit_cache;",
          "174:   uint8_t    *list[63];",
          "175:   uint32_t   *dst;",
          "176:   const uint32_t *codebook;",
          "177:   int         entries[6];",
          "178:   int         i, j, m, n;",
          "179:   int         mean, stages;",
          "180:   unsigned    x, y, width, height, level;",
          "181:   uint32_t    n1, n2, n3, n4;",
          "184:   list[0] = pixels;",
          "187:   for (i=0, m=1, n=1, level=5; i < n; i++) {",
          "188:     SVQ1_PROCESS_VECTOR();",
          "191:     dst = (uint32_t *) list[i];",
          "192:     width = 1 << ((4 + level) /2);",
          "193:     height = 1 << ((3 + level) /2);",
          "196:     stages = get_vlc2(bitbuf, svq1_intra_multistage[level].table, 3, 3) - 1;",
          "198:     if (stages == -1) {",
          "199:         for (y=0; y < height; y++) {",
          "200:           memset (&dst[y*(pitch / 4)], 0, width);",
          "201:         }",
          "205:     if ((stages > 0) && (level >= 4)) {",
          "206:       av_dlog(NULL,",
          "207:               \"Error (svq1_decode_block_intra): invalid vector: stages=%i level=%i\\n\",",
          "208:               stages, level);",
          "212:     mean = get_vlc2(bitbuf, svq1_intra_mean.table, 8, 3);",
          "214:     if (stages == 0) {",
          "215:       for (y=0; y < height; y++) {",
          "216:         memset (&dst[y*(pitch / 4)], mean, width);",
          "217:       }",
          "218:     } else {",
          "219:       SVQ1_CALC_CODEBOOK_ENTRIES(ff_svq1_intra_codebooks);",
          "220:       SVQ1_DO_CODEBOOK_INTRA()",
          "222:   }",
          "224:   return 0;",
          "227: static int svq1_decode_block_non_intra (GetBitContext *bitbuf, uint8_t *pixels, int pitch ) {",
          "228:   uint32_t    bit_cache;",
          "229:   uint8_t    *list[63];",
          "230:   uint32_t   *dst;",
          "231:   const uint32_t *codebook;",
          "232:   int         entries[6];",
          "233:   int         i, j, m, n;",
          "234:   int         mean, stages;",
          "235:   int         x, y, width, height, level;",
          "236:   uint32_t    n1, n2, n3, n4;",
          "239:   list[0] = pixels;",
          "242:   for (i=0, m=1, n=1, level=5; i < n; i++) {",
          "243:     SVQ1_PROCESS_VECTOR();",
          "246:     dst = (uint32_t *) list[i];",
          "247:     width = 1 << ((4 + level) /2);",
          "248:     height = 1 << ((3 + level) /2);",
          "251:     stages = get_vlc2(bitbuf, svq1_inter_multistage[level].table, 3, 2) - 1;",
          "255:     if ((stages > 0) && (level >= 4)) {",
          "256:       av_dlog(NULL,",
          "257:               \"Error (svq1_decode_block_non_intra): invalid vector: stages=%i level=%i\\n\",",
          "258:               stages, level);",
          "260:     }",
          "262:     mean = get_vlc2(bitbuf, svq1_inter_mean.table, 9, 3) - 256;",
          "264:     SVQ1_CALC_CODEBOOK_ENTRIES(ff_svq1_inter_codebooks);",
          "265:     SVQ1_DO_CODEBOOK_NONINTRA()",
          "266:   }",
          "267:   return 0;",
          "270: static int svq1_decode_motion_vector (GetBitContext *bitbuf, svq1_pmv *mv, svq1_pmv **pmv) {",
          "271:   int        diff;",
          "272:   int        i;",
          "274:   for (i=0; i < 2; i++) {",
          "277:     diff = get_vlc2(bitbuf, svq1_motion_component.table, 7, 2);",
          "278:     if(diff<0)",
          "279:         return -1;",
          "280:     else if(diff){",
          "281:         if(get_bits1(bitbuf)) diff= -diff;",
          "285:     if (i == 1)",
          "286:       mv->y = sign_extend(diff + mid_pred(pmv[0]->y, pmv[1]->y, pmv[2]->y), 6);",
          "287:     else",
          "288:       mv->x = sign_extend(diff + mid_pred(pmv[0]->x, pmv[1]->x, pmv[2]->x), 6);",
          "289:   }",
          "291:   return 0;",
          "294: static void svq1_skip_block (uint8_t *current, uint8_t *previous, int pitch, int x, int y) {",
          "295:   uint8_t *src;",
          "296:   uint8_t *dst;",
          "297:   int      i;",
          "299:   src = &previous[x + y*pitch];",
          "300:   dst = current;",
          "302:   for (i=0; i < 16; i++) {",
          "303:     memcpy (dst, src, 16);",
          "304:     src += pitch;",
          "305:     dst += pitch;",
          "306:   }",
          "309: static int svq1_motion_inter_block (MpegEncContext *s, GetBitContext *bitbuf,",
          "310:                                uint8_t *current, uint8_t *previous, int pitch,",
          "311:                                svq1_pmv *motion, int x, int y) {",
          "312:   uint8_t    *src;",
          "313:   uint8_t    *dst;",
          "314:   svq1_pmv    mv;",
          "315:   svq1_pmv   *pmv[3];",
          "316:   int         result;",
          "319:   pmv[0] = &motion[0];",
          "320:   if (y == 0) {",
          "321:     pmv[1] =",
          "322:     pmv[2] = pmv[0];",
          "323:   }",
          "324:   else {",
          "325:     pmv[1] = &motion[(x / 8) + 2];",
          "326:     pmv[2] = &motion[(x / 8) + 4];",
          "327:   }",
          "329:   result = svq1_decode_motion_vector (bitbuf, &mv, pmv);",
          "331:   if (result != 0)",
          "332:     return result;",
          "334:   motion[0].x                =",
          "335:   motion[(x / 8) + 2].x      =",
          "336:   motion[(x / 8) + 3].x      = mv.x;",
          "337:   motion[0].y                =",
          "338:   motion[(x / 8) + 2].y      =",
          "339:   motion[(x / 8) + 3].y      = mv.y;",
          "341:   if(y + (mv.y >> 1)<0)",
          "342:      mv.y= 0;",
          "343:   if(x + (mv.x >> 1)<0)",
          "344:      mv.x= 0;",
          "346:   src = &previous[(x + (mv.x >> 1)) + (y + (mv.y >> 1))*pitch];",
          "347:   dst = current;",
          "349:   s->dsp.put_pixels_tab[0][((mv.y & 1) << 1) | (mv.x & 1)](dst,src,pitch,16);",
          "351:   return 0;",
          "354: static int svq1_motion_inter_4v_block (MpegEncContext *s, GetBitContext *bitbuf,",
          "355:                                   uint8_t *current, uint8_t *previous, int pitch,",
          "356:                                   svq1_pmv *motion,int x, int y) {",
          "357:   uint8_t    *src;",
          "358:   uint8_t    *dst;",
          "359:   svq1_pmv    mv;",
          "360:   svq1_pmv   *pmv[4];",
          "361:   int         i, result;",
          "364:   pmv[0] = &motion[0];",
          "365:   if (y == 0) {",
          "366:     pmv[1] =",
          "367:     pmv[2] = pmv[0];",
          "368:   }",
          "369:   else {",
          "370:     pmv[1] = &motion[(x / 8) + 2];",
          "371:     pmv[2] = &motion[(x / 8) + 4];",
          "372:   }",
          "374:   result = svq1_decode_motion_vector (bitbuf, &mv, pmv);",
          "376:   if (result != 0)",
          "377:     return result;",
          "380:   pmv[0] = &mv;",
          "381:   if (y == 0) {",
          "382:     pmv[1] =",
          "383:     pmv[2] = pmv[0];",
          "384:   }",
          "385:   else {",
          "386:     pmv[1] = &motion[(x / 8) + 3];",
          "387:   }",
          "388:   result = svq1_decode_motion_vector (bitbuf, &motion[0], pmv);",
          "390:   if (result != 0)",
          "391:     return result;",
          "394:   pmv[1] = &motion[0];",
          "395:   pmv[2] = &motion[(x / 8) + 1];",
          "397:   result = svq1_decode_motion_vector (bitbuf, &motion[(x / 8) + 2], pmv);",
          "399:   if (result != 0)",
          "400:     return result;",
          "403:   pmv[2] = &motion[(x / 8) + 2];",
          "404:   pmv[3] = &motion[(x / 8) + 3];",
          "406:   result = svq1_decode_motion_vector (bitbuf, pmv[3], pmv);",
          "408:   if (result != 0)",
          "409:     return result;",
          "412:   for (i=0; i < 4; i++) {",
          "413:     int mvx= pmv[i]->x + (i&1)*16;",
          "414:     int mvy= pmv[i]->y + (i>>1)*16;",
          "417:     if(y + (mvy >> 1)<0)",
          "418:        mvy= 0;",
          "419:     if(x + (mvx >> 1)<0)",
          "420:        mvx= 0;",
          "422:     src = &previous[(x + (mvx >> 1)) + (y + (mvy >> 1))*pitch];",
          "423:     dst = current;",
          "425:     s->dsp.put_pixels_tab[1][((mvy & 1) << 1) | (mvx & 1)](dst,src,pitch,8);",
          "428:     if (i & 1) {",
          "429:       current  += 8*(pitch - 1);",
          "430:     } else {",
          "431:       current  += 8;",
          "433:   }",
          "435:   return 0;",
          "438: static int svq1_decode_delta_block (MpegEncContext *s, GetBitContext *bitbuf,",
          "439:                         uint8_t *current, uint8_t *previous, int pitch,",
          "440:                         svq1_pmv *motion, int x, int y) {",
          "441:   uint32_t block_type;",
          "442:   int      result = 0;",
          "445:   block_type = get_vlc2(bitbuf, svq1_block_type.table, 2, 2);",
          "448:   if (block_type == SVQ1_BLOCK_SKIP || block_type == SVQ1_BLOCK_INTRA) {",
          "449:     motion[0].x                 =",
          "450:     motion[0].y                 =",
          "451:     motion[(x / 8) + 2].x =",
          "452:     motion[(x / 8) + 2].y =",
          "453:     motion[(x / 8) + 3].x =",
          "454:     motion[(x / 8) + 3].y = 0;",
          "455:   }",
          "457:   switch (block_type) {",
          "458:   case SVQ1_BLOCK_SKIP:",
          "459:     svq1_skip_block (current, previous, pitch, x, y);",
          "460:     break;",
          "462:   case SVQ1_BLOCK_INTER:",
          "463:     result = svq1_motion_inter_block (s, bitbuf, current, previous, pitch, motion, x, y);",
          "465:     if (result != 0)",
          "466:     {",
          "467:       av_dlog(s->avctx, \"Error in svq1_motion_inter_block %i\\n\", result);",
          "468:       break;",
          "469:     }",
          "470:     result = svq1_decode_block_non_intra (bitbuf, current, pitch);",
          "471:     break;",
          "473:   case SVQ1_BLOCK_INTER_4V:",
          "474:     result = svq1_motion_inter_4v_block (s, bitbuf, current, previous, pitch, motion, x, y);",
          "476:     if (result != 0)",
          "477:     {",
          "478:       av_dlog(s->avctx, \"Error in svq1_motion_inter_4v_block %i\\n\", result);",
          "479:       break;",
          "481:     result = svq1_decode_block_non_intra (bitbuf, current, pitch);",
          "482:     break;",
          "484:   case SVQ1_BLOCK_INTRA:",
          "485:     result = svq1_decode_block_intra (bitbuf, current, pitch);",
          "486:     break;",
          "487:   }",
          "489:   return result;",
          "492: static void svq1_parse_string (GetBitContext *bitbuf, uint8_t *out) {",
          "493:   uint8_t seed;",
          "494:   int     i;",
          "496:   out[0] = get_bits (bitbuf, 8);",
          "498:   seed = string_table[out[0]];",
          "500:   for (i=1; i <= out[0]; i++) {",
          "501:     out[i] = get_bits (bitbuf, 8) ^ seed;",
          "502:     seed   = string_table[out[i] ^ seed];",
          "503:   }",
          "506: static int svq1_decode_frame_header (GetBitContext *bitbuf,MpegEncContext *s) {",
          "507:   int frame_size_code;",
          "512:   s->pict_type= get_bits (bitbuf, 2)+1;",
          "513:   if(s->pict_type==4)",
          "514:       return -1;",
          "516:   if (s->pict_type == AV_PICTURE_TYPE_I) {",
          "519:     if (s->f_code == 0x50 || s->f_code == 0x60) {",
          "520:       int csum = get_bits (bitbuf, 16);",
          "522:       csum = ff_svq1_packet_checksum (bitbuf->buffer, bitbuf->size_in_bits>>3, csum);",
          "524:       av_dlog(s->avctx, \"%s checksum (%02x) for packet data\\n\",",
          "525:               (csum == 0) ? \"correct\" : \"incorrect\", csum);",
          "526:     }",
          "528:     if ((s->f_code ^ 0x10) >= 0x50) {",
          "529:       uint8_t msg[256];",
          "531:       svq1_parse_string (bitbuf, msg);",
          "533:       av_log(s->avctx, AV_LOG_INFO, \"embedded message: \\\"%s\\\"\\n\", (char *) msg);",
          "534:     }",
          "536:     skip_bits (bitbuf, 2);",
          "537:     skip_bits (bitbuf, 2);",
          "538:     skip_bits1 (bitbuf);",
          "541:     frame_size_code = get_bits (bitbuf, 3);",
          "543:     if (frame_size_code == 7) {",
          "545:       s->width = get_bits (bitbuf, 12);",
          "546:       s->height = get_bits (bitbuf, 12);",
          "548:       if (!s->width || !s->height)",
          "549:         return -1;",
          "550:     } else {",
          "552:       s->width = ff_svq1_frame_size_table[frame_size_code].width;",
          "553:       s->height = ff_svq1_frame_size_table[frame_size_code].height;",
          "555:   }",
          "558:   if (get_bits1 (bitbuf) == 1) {",
          "562:     if (get_bits (bitbuf, 2) != 0)",
          "563:       return -1;",
          "564:   }",
          "566:   if (get_bits1 (bitbuf) == 1) {",
          "567:     skip_bits1 (bitbuf);",
          "568:     skip_bits (bitbuf, 4);",
          "569:     skip_bits1 (bitbuf);",
          "570:     skip_bits (bitbuf, 2);",
          "572:     while (get_bits1 (bitbuf) == 1) {",
          "573:       skip_bits (bitbuf, 8);",
          "575:   }",
          "577:   return 0;",
          "580: static int svq1_decode_frame(AVCodecContext *avctx,",
          "581:                              void *data, int *data_size,",
          "582:                              AVPacket *avpkt)",
          "584:   const uint8_t *buf = avpkt->data;",
          "585:   int buf_size = avpkt->size;",
          "586:   MpegEncContext *s=avctx->priv_data;",
          "587:   uint8_t        *current, *previous;",
          "588:   int             result, i, x, y, width, height;",
          "589:   AVFrame *pict = data;",
          "590:   svq1_pmv *pmv;",
          "593:   init_get_bits(&s->gb,buf,buf_size*8);",
          "596:   s->f_code = get_bits (&s->gb, 22);",
          "598:   if ((s->f_code & ~0x70) || !(s->f_code & 0x60))",
          "599:     return -1;",
          "602:   if (s->f_code != 0x20) {",
          "603:     uint32_t *src = (uint32_t *) (buf + 4);",
          "605:     for (i=0; i < 4; i++) {",
          "606:       src[i] = ((src[i] << 16) | (src[i] >> 16)) ^ src[7 - i];",
          "608:   }",
          "610:   result = svq1_decode_frame_header (&s->gb, s);",
          "612:   if (result != 0)",
          "613:   {",
          "614:     av_dlog(s->avctx, \"Error in svq1_decode_frame_header %i\\n\",result);",
          "615:     return result;",
          "616:   }",
          "617:   avcodec_set_dimensions(avctx, s->width, s->height);",
          "621:   if(s->pict_type==AV_PICTURE_TYPE_B && s->last_picture_ptr==NULL) return buf_size;",
          "623:   if(  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==AV_PICTURE_TYPE_B)",
          "624:      ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=AV_PICTURE_TYPE_I)",
          "625:      || avctx->skip_frame >= AVDISCARD_ALL)",
          "626:       return buf_size;",
          "628:   if(ff_MPV_frame_start(s, avctx) < 0)",
          "629:       return -1;",
          "631:   pmv = av_malloc((FFALIGN(s->width, 16)/8 + 3) * sizeof(*pmv));",
          "632:   if (!pmv)",
          "633:       return -1;",
          "636:   for (i=0; i < 3; i++) {",
          "637:     int linesize;",
          "638:     if (i == 0) {",
          "639:       width  = FFALIGN(s->width, 16);",
          "640:       height = FFALIGN(s->height, 16);",
          "641:       linesize= s->linesize;",
          "642:     } else {",
          "643:       if(s->flags&CODEC_FLAG_GRAY) break;",
          "644:       width  = FFALIGN(s->width/4, 16);",
          "645:       height = FFALIGN(s->height/4, 16);",
          "646:       linesize= s->uvlinesize;",
          "649:     current = s->current_picture.f.data[i];",
          "651:     if(s->pict_type==AV_PICTURE_TYPE_B){",
          "652:         previous = s->next_picture.f.data[i];",
          "653:     }else{",
          "654:         previous = s->last_picture.f.data[i];",
          "655:     }",
          "657:     if (s->pict_type == AV_PICTURE_TYPE_I) {",
          "659:       for (y=0; y < height; y+=16) {",
          "660:         for (x=0; x < width; x+=16) {",
          "661:           result = svq1_decode_block_intra (&s->gb, &current[x], linesize);",
          "662:           if (result != 0)",
          "663:           {",
          "664:             av_log(s->avctx, AV_LOG_INFO, \"Error in svq1_decode_block %i (keyframe)\\n\",result);",
          "665:             goto err;",
          "666:           }",
          "668:         current += 16*linesize;",
          "669:       }",
          "670:     } else {",
          "672:       memset (pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));",
          "674:       for (y=0; y < height; y+=16) {",
          "675:         for (x=0; x < width; x+=16) {",
          "676:           result = svq1_decode_delta_block (s, &s->gb, &current[x], previous,",
          "677:                                             linesize, pmv, x, y);",
          "678:           if (result != 0)",
          "679:           {",
          "680:             av_dlog(s->avctx, \"Error in svq1_decode_delta_block %i\\n\",result);",
          "681:             goto err;",
          "682:           }",
          "683:         }",
          "685:         pmv[0].x =",
          "686:         pmv[0].y = 0;",
          "688:         current += 16*linesize;",
          "689:       }",
          "691:   }",
          "696:   ff_MPV_frame_end(s);",
          "699:   result = buf_size;",
          "701:   av_free(pmv);",
          "702:   return result;",
          "",
          "[Added Lines]",
          "55:     int x;",
          "56:     int y;",
          "60:     0x00, 0xD5, 0x7F, 0xAA, 0xFE, 0x2B, 0x81, 0x54,",
          "61:     0x29, 0xFC, 0x56, 0x83, 0xD7, 0x02, 0xA8, 0x7D,",
          "62:     0x52, 0x87, 0x2D, 0xF8, 0xAC, 0x79, 0xD3, 0x06,",
          "63:     0x7B, 0xAE, 0x04, 0xD1, 0x85, 0x50, 0xFA, 0x2F,",
          "64:     0xA4, 0x71, 0xDB, 0x0E, 0x5A, 0x8F, 0x25, 0xF0,",
          "65:     0x8D, 0x58, 0xF2, 0x27, 0x73, 0xA6, 0x0C, 0xD9,",
          "66:     0xF6, 0x23, 0x89, 0x5C, 0x08, 0xDD, 0x77, 0xA2,",
          "67:     0xDF, 0x0A, 0xA0, 0x75, 0x21, 0xF4, 0x5E, 0x8B,",
          "68:     0x9D, 0x48, 0xE2, 0x37, 0x63, 0xB6, 0x1C, 0xC9,",
          "69:     0xB4, 0x61, 0xCB, 0x1E, 0x4A, 0x9F, 0x35, 0xE0,",
          "70:     0xCF, 0x1A, 0xB0, 0x65, 0x31, 0xE4, 0x4E, 0x9B,",
          "71:     0xE6, 0x33, 0x99, 0x4C, 0x18, 0xCD, 0x67, 0xB2,",
          "72:     0x39, 0xEC, 0x46, 0x93, 0xC7, 0x12, 0xB8, 0x6D,",
          "73:     0x10, 0xC5, 0x6F, 0xBA, 0xEE, 0x3B, 0x91, 0x44,",
          "74:     0x6B, 0xBE, 0x14, 0xC1, 0x95, 0x40, 0xEA, 0x3F,",
          "75:     0x42, 0x97, 0x3D, 0xE8, 0xBC, 0x69, 0xC3, 0x16,",
          "76:     0xEF, 0x3A, 0x90, 0x45, 0x11, 0xC4, 0x6E, 0xBB,",
          "77:     0xC6, 0x13, 0xB9, 0x6C, 0x38, 0xED, 0x47, 0x92,",
          "78:     0xBD, 0x68, 0xC2, 0x17, 0x43, 0x96, 0x3C, 0xE9,",
          "79:     0x94, 0x41, 0xEB, 0x3E, 0x6A, 0xBF, 0x15, 0xC0,",
          "80:     0x4B, 0x9E, 0x34, 0xE1, 0xB5, 0x60, 0xCA, 0x1F,",
          "81:     0x62, 0xB7, 0x1D, 0xC8, 0x9C, 0x49, 0xE3, 0x36,",
          "82:     0x19, 0xCC, 0x66, 0xB3, 0xE7, 0x32, 0x98, 0x4D,",
          "83:     0x30, 0xE5, 0x4F, 0x9A, 0xCE, 0x1B, 0xB1, 0x64,",
          "84:     0x72, 0xA7, 0x0D, 0xD8, 0x8C, 0x59, 0xF3, 0x26,",
          "85:     0x5B, 0x8E, 0x24, 0xF1, 0xA5, 0x70, 0xDA, 0x0F,",
          "86:     0x20, 0xF5, 0x5F, 0x8A, 0xDE, 0x0B, 0xA1, 0x74,",
          "87:     0x09, 0xDC, 0x76, 0xA3, 0xF7, 0x22, 0x88, 0x5D,",
          "88:     0xD6, 0x03, 0xA9, 0x7C, 0x28, 0xFD, 0x57, 0x82,",
          "89:     0xFF, 0x2A, 0x80, 0x55, 0x01, 0xD4, 0x7E, 0xAB,",
          "90:     0x84, 0x51, 0xFB, 0x2E, 0x7A, 0xAF, 0x05, 0xD0,",
          "91:     0xAD, 0x78, 0xD2, 0x07, 0x53, 0x86, 0x2C, 0xF9",
          "94: #define SVQ1_PROCESS_VECTOR()                                           \\",
          "95:     for (; level > 0; i++) {                                            \\",
          "97:         if (i == m) {                                                   \\",
          "98:             m = n;                                                      \\",
          "99:             if (--level == 0)                                           \\",
          "100:                 break;                                                  \\",
          "101:         }                                                               \\",
          "103:         if (get_bits1(bitbuf) == 0)                                     \\",
          "104:             break;                                                      \\",
          "106:         list[n++] = list[i];                                            \\",
          "107:         list[n++] = list[i] +                                           \\",
          "108:                     (((level & 1) ? pitch : 1) << ((level / 2) + 1));   \\",
          "111: #define SVQ1_ADD_CODEBOOK()                                             \\",
          "113:     for (j = 0; j < stages; j++) {                                      \\",
          "114:         n3  = codebook[entries[j]] ^ 0x80808080;                        \\",
          "115:         n1 += ((n3 & 0xFF00FF00) >> 8);                                 \\",
          "116:         n2 +=  (n3 & 0x00FF00FF);                                       \\",
          "117:     }                                                                   \\",
          "118:                                                                         \\",
          "120:     if (n1 & 0xFF00FF00) {                                              \\",
          "121:         n3  = (((n1 >> 15)  & 0x00010001) | 0x01000100) - 0x00010001;   \\",
          "122:         n1 += 0x7F007F00;                                               \\",
          "123:         n1 |= (((~n1 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;   \\",
          "124:         n1 &= (n3 & 0x00FF00FF);                                        \\",
          "125:     }                                                                   \\",
          "126:                                                                         \\",
          "127:     if (n2 & 0xFF00FF00) {                                              \\",
          "128:         n3  = (((n2 >> 15)  & 0x00010001) | 0x01000100) - 0x00010001;   \\",
          "129:         n2 += 0x7F007F00;                                               \\",
          "130:         n2 |= (((~n2 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;   \\",
          "131:         n2 &= (n3 & 0x00FF00FF);                                        \\",
          "134: #define SVQ1_DO_CODEBOOK_INTRA()                                        \\",
          "135:     for (y = 0; y < height; y++) {                                      \\",
          "136:         for (x = 0; x < (width / 4); x++, codebook++) {                 \\",
          "137:             n1 = n4;                                                    \\",
          "138:             n2 = n4;                                                    \\",
          "139:             SVQ1_ADD_CODEBOOK()                                         \\",
          "141:             dst[x] = (n1 << 8) | n2;                                    \\",
          "142:         }                                                               \\",
          "143:         dst += (pitch / 4);                                             \\",
          "146: #define SVQ1_DO_CODEBOOK_NONINTRA()                                     \\",
          "147:     for (y = 0; y < height; y++) {                                      \\",
          "148:         for (x = 0; x < (width / 4); x++, codebook++) {                 \\",
          "149:             n3 = dst[x];                                                \\",
          "151:             n1 = n4 + ((n3 & 0xFF00FF00) >> 8);                         \\",
          "152:             n2 = n4 +  (n3 & 0x00FF00FF);                               \\",
          "153:             SVQ1_ADD_CODEBOOK()                                         \\",
          "155:             dst[x] = (n1 << 8) | n2;                                    \\",
          "156:         }                                                               \\",
          "157:         dst += (pitch / 4);                                             \\",
          "158:     }",
          "160: #define SVQ1_CALC_CODEBOOK_ENTRIES(cbook)                               \\",
          "161:     codebook = (const uint32_t *)cbook[level];                          \\",
          "162:     if (stages > 0)                                                     \\",
          "163:         bit_cache = get_bits(bitbuf, 4 * stages);                       \\",
          "165:     for (j = 0; j < stages; j++) {                                      \\",
          "166:         entries[j] = (((bit_cache >> (4 * (stages - j - 1))) & 0xF) +   \\",
          "167:                       16 * j) << (level + 1);                           \\",
          "168:     }                                                                   \\",
          "169:     mean -= (stages * 128);                                             \\",
          "170:     n4    = ((mean + (mean >> 31)) << 16) | (mean & 0xFFFF);",
          "172: static int svq1_decode_block_intra(GetBitContext *bitbuf, uint8_t *pixels,",
          "173:                                    int pitch)",
          "174: {",
          "175:     uint32_t bit_cache;",
          "176:     uint8_t *list[63];",
          "177:     uint32_t *dst;",
          "178:     const uint32_t *codebook;",
          "179:     int entries[6];",
          "180:     int i, j, m, n;",
          "181:     int mean, stages;",
          "182:     unsigned x, y, width, height, level;",
          "183:     uint32_t n1, n2, n3, n4;",
          "186:     list[0] = pixels;",
          "189:     for (i = 0, m = 1, n = 1, level = 5; i < n; i++) {",
          "190:         SVQ1_PROCESS_VECTOR();",
          "193:         dst    = (uint32_t *)list[i];",
          "194:         width  = 1 << ((4 + level) / 2);",
          "195:         height = 1 << ((3 + level) / 2);",
          "198:         stages = get_vlc2(bitbuf, svq1_intra_multistage[level].table, 3, 3) - 1;",
          "200:         if (stages == -1) {",
          "201:             for (y = 0; y < height; y++)",
          "202:                 memset(&dst[y * (pitch / 4)], 0, width);",
          "204:         }",
          "206:         if ((stages > 0) && (level >= 4)) {",
          "207:             av_dlog(NULL,",
          "208:                     \"Error (svq1_decode_block_intra): invalid vector: stages=%i level=%i\\n\",",
          "209:                     stages, level);",
          "211:         }",
          "213:         mean = get_vlc2(bitbuf, svq1_intra_mean.table, 8, 3);",
          "215:         if (stages == 0) {",
          "216:             for (y = 0; y < height; y++)",
          "217:                 memset(&dst[y * (pitch / 4)], mean, width);",
          "218:         } else {",
          "219:             SVQ1_CALC_CODEBOOK_ENTRIES(ff_svq1_intra_codebooks);",
          "220:             SVQ1_DO_CODEBOOK_INTRA()",
          "221:         }",
          "224:     return 0;",
          "227: static int svq1_decode_block_non_intra(GetBitContext *bitbuf, uint8_t *pixels,",
          "228:                                        int pitch)",
          "229: {",
          "230:     uint32_t bit_cache;",
          "231:     uint8_t *list[63];",
          "232:     uint32_t *dst;",
          "233:     const uint32_t *codebook;",
          "234:     int entries[6];",
          "235:     int i, j, m, n;",
          "236:     int mean, stages;",
          "237:     int x, y, width, height, level;",
          "238:     uint32_t n1, n2, n3, n4;",
          "241:     list[0] = pixels;",
          "244:     for (i = 0, m = 1, n = 1, level = 5; i < n; i++) {",
          "245:         SVQ1_PROCESS_VECTOR();",
          "248:         dst    = (uint32_t *)list[i];",
          "249:         width  = 1 << ((4 + level) / 2);",
          "250:         height = 1 << ((3 + level) / 2);",
          "253:         stages = get_vlc2(bitbuf, svq1_inter_multistage[level].table, 3, 2) - 1;",
          "255:         if (stages == -1)",
          "258:         if ((stages > 0) && (level >= 4)) {",
          "259:             av_dlog(NULL,",
          "260:                     \"Error (svq1_decode_block_non_intra): invalid vector: stages=%i level=%i\\n\",",
          "261:                     stages, level);",
          "263:         }",
          "265:         mean = get_vlc2(bitbuf, svq1_inter_mean.table, 9, 3) - 256;",
          "267:         SVQ1_CALC_CODEBOOK_ENTRIES(ff_svq1_inter_codebooks);",
          "268:         SVQ1_DO_CODEBOOK_NONINTRA()",
          "269:     }",
          "270:     return 0;",
          "273: static int svq1_decode_motion_vector(GetBitContext *bitbuf, svq1_pmv *mv,",
          "274:                                      svq1_pmv **pmv)",
          "275: {",
          "276:     int diff;",
          "277:     int i;",
          "279:     for (i = 0; i < 2; i++) {",
          "281:         diff = get_vlc2(bitbuf, svq1_motion_component.table, 7, 2);",
          "282:         if (diff < 0)",
          "283:             return -1;",
          "284:         else if (diff) {",
          "285:             if (get_bits1(bitbuf))",
          "286:                 diff = -diff;",
          "287:         }",
          "290:         if (i == 1)",
          "291:             mv->y = sign_extend(diff + mid_pred(pmv[0]->y, pmv[1]->y, pmv[2]->y), 6);",
          "292:         else",
          "293:             mv->x = sign_extend(diff + mid_pred(pmv[0]->x, pmv[1]->x, pmv[2]->x), 6);",
          "296:     return 0;",
          "299: static void svq1_skip_block(uint8_t *current, uint8_t *previous,",
          "300:                             int pitch, int x, int y)",
          "301: {",
          "302:     uint8_t *src;",
          "303:     uint8_t *dst;",
          "304:     int i;",
          "306:     src = &previous[x + y * pitch];",
          "307:     dst = current;",
          "309:     for (i = 0; i < 16; i++) {",
          "310:         memcpy(dst, src, 16);",
          "311:         src += pitch;",
          "312:         dst += pitch;",
          "313:     }",
          "316: static int svq1_motion_inter_block(MpegEncContext *s, GetBitContext *bitbuf,",
          "317:                                    uint8_t *current, uint8_t *previous,",
          "318:                                    int pitch, svq1_pmv *motion, int x, int y)",
          "319: {",
          "320:     uint8_t *src;",
          "321:     uint8_t *dst;",
          "322:     svq1_pmv mv;",
          "323:     svq1_pmv *pmv[3];",
          "324:     int result;",
          "327:     pmv[0] = &motion[0];",
          "328:     if (y == 0) {",
          "329:         pmv[1] =",
          "330:         pmv[2] = pmv[0];",
          "331:     } else {",
          "332:         pmv[1] = &motion[(x / 8) + 2];",
          "333:         pmv[2] = &motion[(x / 8) + 4];",
          "334:     }",
          "336:     result = svq1_decode_motion_vector(bitbuf, &mv, pmv);",
          "338:     if (result != 0)",
          "339:         return result;",
          "341:     motion[0].x           =",
          "342:     motion[(x / 8) + 2].x =",
          "343:     motion[(x / 8) + 3].x = mv.x;",
          "344:     motion[0].y           =",
          "345:     motion[(x / 8) + 2].y =",
          "346:     motion[(x / 8) + 3].y = mv.y;",
          "348:     if (y + (mv.y >> 1) < 0)",
          "349:         mv.y = 0;",
          "350:     if (x + (mv.x >> 1) < 0)",
          "351:         mv.x = 0;",
          "353:     src = &previous[(x + (mv.x >> 1)) + (y + (mv.y >> 1)) * pitch];",
          "354:     dst = current;",
          "356:     s->dsp.put_pixels_tab[0][((mv.y & 1) << 1) | (mv.x & 1)](dst, src, pitch, 16);",
          "358:     return 0;",
          "361: static int svq1_motion_inter_4v_block(MpegEncContext *s, GetBitContext *bitbuf,",
          "362:                                       uint8_t *current, uint8_t *previous,",
          "363:                                       int pitch, svq1_pmv *motion, int x, int y)",
          "364: {",
          "365:     uint8_t *src;",
          "366:     uint8_t *dst;",
          "367:     svq1_pmv mv;",
          "368:     svq1_pmv *pmv[4];",
          "369:     int i, result;",
          "372:     pmv[0] = &motion[0];",
          "373:     if (y == 0) {",
          "374:         pmv[1] =",
          "375:         pmv[2] = pmv[0];",
          "376:     } else {",
          "377:         pmv[1] = &motion[(x / 8) + 2];",
          "378:         pmv[2] = &motion[(x / 8) + 4];",
          "379:     }",
          "381:     result = svq1_decode_motion_vector(bitbuf, &mv, pmv);",
          "383:     if (result != 0)",
          "384:         return result;",
          "387:     pmv[0] = &mv;",
          "388:     if (y == 0) {",
          "389:         pmv[1] =",
          "390:         pmv[2] = pmv[0];",
          "391:     } else {",
          "392:         pmv[1] = &motion[(x / 8) + 3];",
          "393:     }",
          "394:     result = svq1_decode_motion_vector(bitbuf, &motion[0], pmv);",
          "396:     if (result != 0)",
          "397:         return result;",
          "400:     pmv[1] = &motion[0];",
          "401:     pmv[2] = &motion[(x / 8) + 1];",
          "403:     result = svq1_decode_motion_vector(bitbuf, &motion[(x / 8) + 2], pmv);",
          "405:     if (result != 0)",
          "406:         return result;",
          "409:     pmv[2] = &motion[(x / 8) + 2];",
          "410:     pmv[3] = &motion[(x / 8) + 3];",
          "412:     result = svq1_decode_motion_vector(bitbuf, pmv[3], pmv);",
          "414:     if (result != 0)",
          "415:         return result;",
          "418:     for (i = 0; i < 4; i++) {",
          "419:         int mvx = pmv[i]->x + (i  & 1) * 16;",
          "420:         int mvy = pmv[i]->y + (i >> 1) * 16;",
          "423:         if (y + (mvy >> 1) < 0)",
          "424:             mvy = 0;",
          "425:         if (x + (mvx >> 1) < 0)",
          "426:             mvx = 0;",
          "428:         src = &previous[(x + (mvx >> 1)) + (y + (mvy >> 1)) * pitch];",
          "429:         dst = current;",
          "431:         s->dsp.put_pixels_tab[1][((mvy & 1) << 1) | (mvx & 1)](dst, src, pitch, 8);",
          "434:         if (i & 1)",
          "435:             current += 8 * (pitch - 1);",
          "436:         else",
          "437:             current += 8;",
          "440:     return 0;",
          "443: static int svq1_decode_delta_block(MpegEncContext *s, GetBitContext *bitbuf,",
          "444:                                    uint8_t *current, uint8_t *previous,",
          "445:                                    int pitch, svq1_pmv *motion, int x, int y)",
          "446: {",
          "447:     uint32_t block_type;",
          "448:     int result = 0;",
          "451:     block_type = get_vlc2(bitbuf, svq1_block_type.table, 2, 2);",
          "454:     if (block_type == SVQ1_BLOCK_SKIP || block_type == SVQ1_BLOCK_INTRA) {",
          "455:         motion[0].x           =",
          "456:         motion[0].y           =",
          "457:         motion[(x / 8) + 2].x =",
          "458:         motion[(x / 8) + 2].y =",
          "459:         motion[(x / 8) + 3].x =",
          "460:         motion[(x / 8) + 3].y = 0;",
          "461:     }",
          "463:     switch (block_type) {",
          "464:     case SVQ1_BLOCK_SKIP:",
          "465:         svq1_skip_block(current, previous, pitch, x, y);",
          "466:         break;",
          "468:     case SVQ1_BLOCK_INTER:",
          "469:         result = svq1_motion_inter_block(s, bitbuf, current, previous,",
          "470:                                          pitch, motion, x, y);",
          "472:         if (result != 0) {",
          "473:             av_dlog(s->avctx, \"Error in svq1_motion_inter_block %i\\n\", result);",
          "474:             break;",
          "475:         }",
          "476:         result = svq1_decode_block_non_intra(bitbuf, current, pitch);",
          "477:         break;",
          "479:     case SVQ1_BLOCK_INTER_4V:",
          "480:         result = svq1_motion_inter_4v_block(s, bitbuf, current, previous,",
          "481:                                             pitch, motion, x, y);",
          "483:         if (result != 0) {",
          "484:             av_dlog(s->avctx,",
          "485:                     \"Error in svq1_motion_inter_4v_block %i\\n\", result);",
          "486:             break;",
          "487:         }",
          "488:         result = svq1_decode_block_non_intra(bitbuf, current, pitch);",
          "489:         break;",
          "491:     case SVQ1_BLOCK_INTRA:",
          "492:         result = svq1_decode_block_intra(bitbuf, current, pitch);",
          "493:         break;",
          "496:     return result;",
          "499: static void svq1_parse_string(GetBitContext *bitbuf, uint8_t *out)",
          "500: {",
          "501:     uint8_t seed;",
          "502:     int i;",
          "504:     out[0] = get_bits(bitbuf, 8);",
          "505:     seed   = string_table[out[0]];",
          "507:     for (i = 1; i <= out[0]; i++) {",
          "508:         out[i] = get_bits(bitbuf, 8) ^ seed;",
          "509:         seed   = string_table[out[i] ^ seed];",
          "510:     }",
          "513: static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)",
          "514: {",
          "515:     int frame_size_code;",
          "520:     s->pict_type = get_bits(bitbuf, 2) + 1;",
          "521:     if (s->pict_type == 4)",
          "522:         return -1;",
          "524:     if (s->pict_type == AV_PICTURE_TYPE_I) {",
          "526:         if (s->f_code == 0x50 || s->f_code == 0x60) {",
          "527:             int csum = get_bits(bitbuf, 16);",
          "529:             csum = ff_svq1_packet_checksum(bitbuf->buffer,",
          "530:                                            bitbuf->size_in_bits >> 3,",
          "531:                                            csum);",
          "533:             av_dlog(s->avctx, \"%s checksum (%02x) for packet data\\n\",",
          "534:                     (csum == 0) ? \"correct\" : \"incorrect\", csum);",
          "535:         }",
          "537:         if ((s->f_code ^ 0x10) >= 0x50) {",
          "538:             uint8_t msg[256];",
          "540:             svq1_parse_string(bitbuf, msg);",
          "542:             av_log(s->avctx, AV_LOG_INFO,",
          "543:                    \"embedded message: \\\"%s\\\"\\n\", (char *)msg);",
          "544:         }",
          "546:         skip_bits(bitbuf, 2);",
          "547:         skip_bits(bitbuf, 2);",
          "548:         skip_bits1(bitbuf);",
          "551:         frame_size_code = get_bits(bitbuf, 3);",
          "553:         if (frame_size_code == 7) {",
          "555:             s->width  = get_bits(bitbuf, 12);",
          "556:             s->height = get_bits(bitbuf, 12);",
          "558:             if (!s->width || !s->height)",
          "559:                 return -1;",
          "560:         } else {",
          "562:             s->width  = ff_svq1_frame_size_table[frame_size_code].width;",
          "563:             s->height = ff_svq1_frame_size_table[frame_size_code].height;",
          "564:         }",
          "568:     if (get_bits1(bitbuf) == 1) {",
          "572:         if (get_bits(bitbuf, 2) != 0)",
          "573:             return -1;",
          "574:     }",
          "576:     if (get_bits1(bitbuf) == 1) {",
          "577:         skip_bits1(bitbuf);",
          "578:         skip_bits(bitbuf, 4);",
          "579:         skip_bits1(bitbuf);",
          "580:         skip_bits(bitbuf, 2);",
          "582:         while (get_bits1(bitbuf) == 1)",
          "583:             skip_bits(bitbuf, 8);",
          "586:     return 0;",
          "589: static int svq1_decode_frame(AVCodecContext *avctx, void *data,",
          "590:                              int *data_size, AVPacket *avpkt)",
          "592:     const uint8_t *buf = avpkt->data;",
          "593:     int buf_size       = avpkt->size;",
          "594:     MpegEncContext *s  = avctx->priv_data;",
          "595:     uint8_t *current, *previous;",
          "596:     int result, i, x, y, width, height;",
          "597:     AVFrame *pict = data;",
          "598:     svq1_pmv *pmv;",
          "601:     init_get_bits(&s->gb, buf, buf_size * 8);",
          "604:     s->f_code = get_bits(&s->gb, 22);",
          "606:     if ((s->f_code & ~0x70) || !(s->f_code & 0x60))",
          "607:         return -1;",
          "610:     if (s->f_code != 0x20) {",
          "611:         uint32_t *src = (uint32_t *)(buf + 4);",
          "613:         for (i = 0; i < 4; i++)",
          "614:             src[i] = ((src[i] << 16) | (src[i] >> 16)) ^ src[7 - i];",
          "617:     result = svq1_decode_frame_header(&s->gb, s);",
          "619:     if (result != 0) {",
          "620:         av_dlog(s->avctx, \"Error in svq1_decode_frame_header %i\\n\", result);",
          "621:         return result;",
          "623:     avcodec_set_dimensions(avctx, s->width, s->height);",
          "628:     if (s->pict_type == AV_PICTURE_TYPE_B && s->last_picture_ptr == NULL)",
          "629:         return buf_size;",
          "631:     if ((avctx->skip_frame >= AVDISCARD_NONREF &&",
          "632:          s->pict_type == AV_PICTURE_TYPE_B)    ||",
          "633:         (avctx->skip_frame >= AVDISCARD_NONKEY &&",
          "634:          s->pict_type != AV_PICTURE_TYPE_I)    ||",
          "635:         avctx->skip_frame >= AVDISCARD_ALL)",
          "636:         return buf_size;",
          "638:     if (ff_MPV_frame_start(s, avctx) < 0)",
          "639:         return -1;",
          "641:     pmv = av_malloc((FFALIGN(s->width, 16) / 8 + 3) * sizeof(*pmv));",
          "642:     if (!pmv)",
          "643:         return -1;",
          "646:     for (i = 0; i < 3; i++) {",
          "647:         int linesize;",
          "648:         if (i == 0) {",
          "649:             width    = FFALIGN(s->width,  16);",
          "650:             height   = FFALIGN(s->height, 16);",
          "651:             linesize = s->linesize;",
          "652:         } else {",
          "653:             if (s->flags & CODEC_FLAG_GRAY)",
          "654:                 break;",
          "655:             width    = FFALIGN(s->width  / 4, 16);",
          "656:             height   = FFALIGN(s->height / 4, 16);",
          "657:             linesize = s->uvlinesize;",
          "660:         current = s->current_picture.f.data[i];",
          "662:         if (s->pict_type == AV_PICTURE_TYPE_B)",
          "663:             previous = s->next_picture.f.data[i];",
          "664:         else",
          "665:             previous = s->last_picture.f.data[i];",
          "667:         if (s->pict_type == AV_PICTURE_TYPE_I) {",
          "669:             for (y = 0; y < height; y += 16) {",
          "670:                 for (x = 0; x < width; x += 16) {",
          "671:                     result = svq1_decode_block_intra(&s->gb, &current[x],",
          "672:                                                      linesize);",
          "673:                     if (result != 0) {",
          "674:                         av_log(s->avctx, AV_LOG_INFO,",
          "675:                                \"Error in svq1_decode_block %i (keyframe)\\n\",",
          "676:                                result);",
          "677:                         goto err;",
          "678:                     }",
          "679:                 }",
          "680:                 current += 16 * linesize;",
          "681:             }",
          "682:         } else {",
          "684:             memset(pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));",
          "686:             for (y = 0; y < height; y += 16) {",
          "687:                 for (x = 0; x < width; x += 16) {",
          "688:                     result = svq1_decode_delta_block(s, &s->gb, &current[x],",
          "689:                                                      previous, linesize,",
          "690:                                                      pmv, x, y);",
          "691:                     if (result != 0) {",
          "692:                         av_dlog(s->avctx,",
          "693:                                 \"Error in svq1_decode_delta_block %i\\n\",",
          "694:                                 result);",
          "695:                         goto err;",
          "696:                     }",
          "697:                 }",
          "699:                 pmv[0].x     =",
          "700:                     pmv[0].y = 0;",
          "702:                 current += 16 * linesize;",
          "703:             }",
          "704:         }",
          "709:     ff_MPV_frame_end(s);",
          "712:     result     = buf_size;",
          "715:     av_free(pmv);",
          "716:     return result;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "711:     ff_MPV_decode_defaults(s);",
          "722:     INIT_VLC_STATIC(&svq1_block_type, 2, 4,",
          "726:     INIT_VLC_STATIC(&svq1_motion_component, 7, 33,",
          "730:     for (i = 0; i < 6; i++) {",
          "732:         static VLC_TYPE table[168][2];",
          "734:         svq1_intra_multistage[i].table_allocated = sizes[0][i];",
          "736:         init_vlc(&svq1_intra_multistage[i], 3, 8,",
          "740:         svq1_inter_multistage[i].table_allocated = sizes[1][i];",
          "742:         init_vlc(&svq1_inter_multistage[i], 3, 8,",
          "745:     }",
          "747:     INIT_VLC_STATIC(&svq1_intra_mean, 8, 256,",
          "751:     INIT_VLC_STATIC(&svq1_inter_mean, 9, 512,",
          "755:     return 0;",
          "756: }",
          "",
          "[Removed Lines]",
          "713:     s->avctx = avctx;",
          "714:     s->width = (avctx->width+3)&~3;",
          "715:     s->height = (avctx->height+3)&~3;",
          "716:     s->codec_id= avctx->codec->id;",
          "717:     avctx->pix_fmt = AV_PIX_FMT_YUV410P;",
          "718:     avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames",
          "719:     s->flags= avctx->flags;",
          "720:     if (ff_MPV_common_init(s) < 0) return -1;",
          "723:         &ff_svq1_block_type_vlc[0][1], 2, 1,",
          "724:         &ff_svq1_block_type_vlc[0][0], 2, 1, 6);",
          "727:         &ff_mvtab[0][1], 2, 1,",
          "728:         &ff_mvtab[0][0], 2, 1, 176);",
          "731:         static const uint8_t sizes[2][6] = {{14, 10, 14, 18, 16, 18}, {10, 10, 14, 14, 14, 16}};",
          "733:         svq1_intra_multistage[i].table = &table[offset];",
          "735:         offset += sizes[0][i];",
          "737:             &ff_svq1_intra_multistage_vlc[i][0][1], 2, 1,",
          "738:             &ff_svq1_intra_multistage_vlc[i][0][0], 2, 1, INIT_VLC_USE_NEW_STATIC);",
          "739:         svq1_inter_multistage[i].table = &table[offset];",
          "741:         offset += sizes[1][i];",
          "743:             &ff_svq1_inter_multistage_vlc[i][0][1], 2, 1,",
          "744:             &ff_svq1_inter_multistage_vlc[i][0][0], 2, 1, INIT_VLC_USE_NEW_STATIC);",
          "748:         &ff_svq1_intra_mean_vlc[0][1], 4, 2,",
          "749:         &ff_svq1_intra_mean_vlc[0][0], 4, 2, 632);",
          "752:         &ff_svq1_inter_mean_vlc[0][1], 4, 2,",
          "753:         &ff_svq1_inter_mean_vlc[0][0], 4, 2, 1434);",
          "",
          "[Added Lines]",
          "727:     s->avctx            = avctx;",
          "728:     s->width            = (avctx->width  + 3) & ~3;",
          "729:     s->height           = (avctx->height + 3) & ~3;",
          "730:     s->codec_id         = avctx->codec->id;",
          "731:     avctx->pix_fmt      = AV_PIX_FMT_YUV410P;",
          "733:     avctx->has_b_frames = 1;",
          "734:     s->flags            = avctx->flags;",
          "735:     if (ff_MPV_common_init(s) < 0)",
          "736:         return -1;",
          "739:                     &ff_svq1_block_type_vlc[0][1], 2, 1,",
          "740:                     &ff_svq1_block_type_vlc[0][0], 2, 1, 6);",
          "743:                     &ff_mvtab[0][1], 2, 1,",
          "744:                     &ff_mvtab[0][0], 2, 1, 176);",
          "747:         static const uint8_t sizes[2][6] = { { 14, 10, 14, 18, 16, 18 },",
          "748:                                              { 10, 10, 14, 14, 14, 16 } };",
          "750:         svq1_intra_multistage[i].table           = &table[offset];",
          "752:         offset                                  += sizes[0][i];",
          "754:                  &ff_svq1_intra_multistage_vlc[i][0][1], 2, 1,",
          "755:                  &ff_svq1_intra_multistage_vlc[i][0][0], 2, 1,",
          "756:                  INIT_VLC_USE_NEW_STATIC);",
          "757:         svq1_inter_multistage[i].table           = &table[offset];",
          "759:         offset                                  += sizes[1][i];",
          "761:                  &ff_svq1_inter_multistage_vlc[i][0][1], 2, 1,",
          "762:                  &ff_svq1_inter_multistage_vlc[i][0][0], 2, 1,",
          "763:                  INIT_VLC_USE_NEW_STATIC);",
          "767:                     &ff_svq1_intra_mean_vlc[0][1], 4, 2,",
          "768:                     &ff_svq1_intra_mean_vlc[0][0], 4, 2, 632);",
          "771:                     &ff_svq1_inter_mean_vlc[0][1], 4, 2,",
          "772:                     &ff_svq1_inter_mean_vlc[0][0], 4, 2, 1434);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "774:     .decode         = svq1_decode_frame,",
          "775:     .capabilities   = CODEC_CAP_DR1,",
          "776:     .flush          = ff_mpeg_flush,",
          "778:     .long_name      = NULL_IF_CONFIG_SMALL(\"Sorenson Vector Quantizer 1 / Sorenson Video 1 / SVQ1\"),",
          "779: };",
          "",
          "[Removed Lines]",
          "777:     .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV410P, AV_PIX_FMT_NONE },",
          "",
          "[Added Lines]",
          "795:     .pix_fmts       = (const enum PixelFormat[]) { AV_PIX_FMT_YUV410P,",
          "796:                                                    AV_PIX_FMT_NONE },",
          "",
          "---------------"
        ],
        "libavcodec/svq1enc.c||libavcodec/svq1enc.c": [
          "File: libavcodec/svq1enc.c -> libavcodec/svq1enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"avcodec.h\"",
          "31: #include \"dsputil.h\"",
          "32: #include \"mpegvideo.h\"",
          "33: #include \"h263.h\"",
          "34: #include \"internal.h\"",
          "36: #include \"svq1.h\"",
          "37: #include \"svq1enc_cb.h\"",
          "39: #undef NDEBUG",
          "40: #include <assert.h>",
          "43: typedef struct SVQ1Context {",
          "45:     AVCodecContext *avctx;",
          "46:     DSPContext dsp;",
          "47:     AVFrame picture;",
          "",
          "[Removed Lines]",
          "44:     MpegEncContext m; // needed for motion estimation, should not be used for anything else, the idea is to make the motion estimation eventually independent of MpegEncContext, so this will be removed then (FIXME/XXX)",
          "",
          "[Added Lines]",
          "44:     MpegEncContext m;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:     PutBitContext pb;",
          "51:     GetBitContext gb;",
          "55:     int frame_width;",
          "56:     int frame_height;",
          "",
          "[Removed Lines]",
          "53:     PutBitContext reorder_pb[6]; //why ooh why this sick breadth first order, everything is slower and more complex",
          "",
          "[Added Lines]",
          "55:     PutBitContext reorder_pb[6];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:     put_bits(&s->pb, 2, frame_type - 1);",
          "89:     if (frame_type == AV_PICTURE_TYPE_I) {",
          "99:         put_bits(&s->pb, 3, i);",
          "105:         }",
          "106:     }",
          "",
          "[Removed Lines]",
          "98:         i= ff_match_2uint16(ff_svq1_frame_size_table, FF_ARRAY_ELEMS(ff_svq1_frame_size_table), s->frame_width, s->frame_height);",
          "101:         if (i == 7)",
          "102:         {",
          "103:                 put_bits(&s->pb, 12, s->frame_width);",
          "104:                 put_bits(&s->pb, 12, s->frame_height);",
          "",
          "[Added Lines]",
          "97:         i = ff_match_2uint16(ff_svq1_frame_size_table,",
          "98:                              FF_ARRAY_ELEMS(ff_svq1_frame_size_table),",
          "99:                              s->frame_width, s->frame_height);",
          "102:         if (i == 7) {",
          "103:             put_bits(&s->pb, 12, s->frame_width);",
          "104:             put_bits(&s->pb, 12, s->frame_height);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "109:     put_bits(&s->pb, 2, 0);",
          "110: }",
          "114: #define THRESHOLD_MULTIPLIER 0.6",
          "117:     int count, y, x, i, j, split, best_mean, best_score, best_count;",
          "118:     int best_vector[6];",
          "123:     int16_t block[7][256];",
          "124:     const int8_t *codebook_sum, *codebook;",
          "141:             }",
          "142:         }",
          "154:             }",
          "155:         }",
          "156:     }",
          "167:             const int8_t *vector;",
          "171:                 int sqr, diff, score;",
          "185:                 }",
          "186:             }",
          "187:             assert(best_vector_mean != -999);",
          "202:             }",
          "203:         }",
          "204:     }",
          "210:         PutBitContext backup[6];",
          "217:         score += lambda;",
          "226:         }",
          "227:     }",
          "228:     if (level > 0)",
          "229:         put_bits(&s->reorder_pb[level], 1, split);",
          "238:         put_bits(&s->reorder_pb[level],",
          "241:         put_bits(&s->reorder_pb[level], mean_vlc[best_mean][1],",
          "246:             put_bits(&s->reorder_pb[level], 4, best_vector[i]);",
          "247:         }",
          "254:     }",
          "256:     return best_score;",
          "257: }",
          "262: {",
          "263:     int x, y;",
          "264:     int i;",
          "265:     int block_width, block_height;",
          "266:     int level;",
          "267:     int threshold[6];",
          "272:     threshold[5] = QUALITY_THRESHOLD;",
          "273:     for (level = 4; level >= 0; level--)",
          "274:         threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;",
          "277:     block_height = (height + 15) / 16;",
          "287:         s->m.current_picture.f.linesize[0] = stride;",
          "309:         }",
          "317:         s->m.current_picture.f.mb_type = s->dummy;",
          "319:         s->m.current_picture.f.motion_val[0] = s->motion_val8[plane] + 2;",
          "322:         ff_init_me(&s->m);",
          "326:         for (y = 0; y < block_height; y++) {",
          "334:             }",
          "338:             for (x = 0; x < block_width; x++) {",
          "340:                 ff_init_block_index(&s->m);",
          "341:                 ff_update_block_index(&s->m);",
          "343:                 ff_estimate_p_frame_motion(&s->m, x, y);",
          "344:             }",
          "346:         }",
          "348:         ff_fix_long_p_mvs(&s->m);",
          "350:     }",
          "353:     for (y = 0; y < block_height; y++) {",
          "358:         }",
          "363:         for (x = 0; x < block_width; x++) {",
          "365:             int count[3][6];",
          "373:                 av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "374:                 return -1;",
          "375:             }",
          "378:             ff_init_block_index(&s->m);",
          "379:             ff_update_block_index(&s->m);",
          "387:                     put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);",
          "389:                 }",
          "393:                     flush_put_bits(&s->reorder_pb[i]);",
          "394:                 }",
          "402:                 int mx, my, pred_x, pred_y, dxy;",
          "403:                 int16_t *motion_ptr;",
          "410:                     put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);",
          "419:                     ff_h263_encode_motion(&s->m, mx - pred_x, 1);",
          "420:                     ff_h263_encode_motion(&s->m, my - pred_y, 1);",
          "436:                         s->dsp.put_pixels_tab[0][0](decoded, ref, stride, 16);",
          "440:                         put_bits(&s->pb, vlc[1], vlc[0]);",
          "441:                     }",
          "442:                 }",
          "447:                         flush_put_bits(&s->reorder_pb[i]);",
          "448:                     }",
          "454:                 }",
          "455:             }",
          "457:             s->rd_total += score[best];",
          "463:                 s->dsp.put_pixels_tab[0][0](decoded, temp, stride, 16);",
          "465:         }",
          "467:     }",
          "468:     return 0;",
          "469: }",
          "471: static av_cold int svq1_encode_init(AVCodecContext *avctx)",
          "472: {",
          "475:     ff_dsputil_init(&s->dsp, avctx);",
          "476:     avctx->coded_frame = &s->picture;",
          "479:     s->frame_height = avctx->height;",
          "482:     s->y_block_height = (s->frame_height + 15) / 16;",
          "485:     s->c_block_height = (s->frame_height / 4 + 15) / 16;",
          "489:     s->m.picture_structure = PICT_FRAME;",
          "498:     return 0;",
          "499: }",
          "",
          "[Removed Lines]",
          "113: #define QUALITY_THRESHOLD 100",
          "116: static int encode_block(SVQ1Context *s, uint8_t *src, uint8_t *ref, uint8_t *decoded, int stride, int level, int threshold, int lambda, int intra){",
          "119:     int block_sum[7]= {0, 0, 0, 0, 0, 0};",
          "120:     int w= 2<<((level+2)>>1);",
          "121:     int h= 2<<((level+1)>>1);",
          "122:     int size=w*h;",
          "125:     const uint16_t (*mean_vlc)[2];",
          "126:     const uint8_t (*multistage_vlc)[2];",
          "128:     best_score=0;",
          "130:     if(intra){",
          "131:         codebook_sum= svq1_intra_codebook_sum[level];",
          "132:         codebook= ff_svq1_intra_codebooks[level];",
          "133:         mean_vlc= ff_svq1_intra_mean_vlc;",
          "134:         multistage_vlc= ff_svq1_intra_multistage_vlc[level];",
          "135:         for(y=0; y<h; y++){",
          "136:             for(x=0; x<w; x++){",
          "137:                 int v= src[x + y*stride];",
          "138:                 block[0][x + w*y]= v;",
          "139:                 best_score += v*v;",
          "140:                 block_sum[0] += v;",
          "143:     }else{",
          "144:         codebook_sum= svq1_inter_codebook_sum[level];",
          "145:         codebook= ff_svq1_inter_codebooks[level];",
          "146:         mean_vlc= ff_svq1_inter_mean_vlc + 256;",
          "147:         multistage_vlc= ff_svq1_inter_multistage_vlc[level];",
          "148:         for(y=0; y<h; y++){",
          "149:             for(x=0; x<w; x++){",
          "150:                 int v= src[x + y*stride] - ref[x + y*stride];",
          "151:                 block[0][x + w*y]= v;",
          "152:                 best_score += v*v;",
          "153:                 block_sum[0] += v;",
          "158:     best_count=0;",
          "159:     best_score -= (int)(((unsigned)block_sum[0]*block_sum[0])>>(level+3));",
          "160:     best_mean= (block_sum[0] + (size>>1)) >> (level+3);",
          "162:     if(level<4){",
          "163:         for(count=1; count<7; count++){",
          "164:             int best_vector_score= INT_MAX;",
          "165:             int best_vector_sum=-999, best_vector_mean=-999;",
          "166:             const int stage= count-1;",
          "169:             for(i=0; i<16; i++){",
          "170:                 int sum= codebook_sum[stage*16 + i];",
          "173:                 vector = codebook + stage*size*16 + i*size;",
          "174:                 sqr = s->dsp.ssd_int8_vs_int16(vector, block[stage], size);",
          "175:                 diff= block_sum[stage] - sum;",
          "176:                 score= sqr - ((diff*(int64_t)diff)>>(level+3)); //FIXME 64bit slooow",
          "177:                 if(score < best_vector_score){",
          "178:                     int mean= (diff + (size>>1)) >> (level+3);",
          "179:                     assert(mean >-300 && mean<300);",
          "180:                     mean= av_clip(mean, intra?0:-256, 255);",
          "181:                     best_vector_score= score;",
          "182:                     best_vector[stage]= i;",
          "183:                     best_vector_sum= sum;",
          "184:                     best_vector_mean= mean;",
          "188:             vector= codebook + stage*size*16 + best_vector[stage]*size;",
          "189:             for(j=0; j<size; j++){",
          "190:                 block[stage+1][j] = block[stage][j] - vector[j];",
          "191:             }",
          "192:             block_sum[stage+1]= block_sum[stage] - best_vector_sum;",
          "193:             best_vector_score +=",
          "194:                 lambda*(+ 1 + 4*count",
          "195:                         + multistage_vlc[1+count][1]",
          "196:                         + mean_vlc[best_vector_mean][1]);",
          "198:             if(best_vector_score < best_score){",
          "199:                 best_score= best_vector_score;",
          "200:                 best_count= count;",
          "201:                 best_mean= best_vector_mean;",
          "206:     split=0;",
          "207:     if(best_score > threshold && level){",
          "208:         int score=0;",
          "209:         int offset= (level&1) ? stride*h/2 : w/2;",
          "212:         for(i=level-1; i>=0; i--){",
          "213:             backup[i]= s->reorder_pb[i];",
          "214:         }",
          "215:         score += encode_block(s, src         , ref         , decoded         , stride, level-1, threshold>>1, lambda, intra);",
          "216:         score += encode_block(s, src + offset, ref + offset, decoded + offset, stride, level-1, threshold>>1, lambda, intra);",
          "219:         if(score < best_score){",
          "220:             best_score= score;",
          "221:             split=1;",
          "222:         }else{",
          "223:             for(i=level-1; i>=0; i--){",
          "224:                 s->reorder_pb[i]= backup[i];",
          "225:             }",
          "231:     if(!split){",
          "232:         assert((best_mean >= 0 && best_mean<256) || !intra);",
          "233:         assert(best_mean >= -256 && best_mean<256);",
          "234:         assert(best_count >=0 && best_count<7);",
          "235:         assert(level<4 || best_count==0);",
          "239:             multistage_vlc[1 + best_count][1],",
          "240:             multistage_vlc[1 + best_count][0]);",
          "242:             mean_vlc[best_mean][0]);",
          "244:         for (i = 0; i < best_count; i++){",
          "245:             assert(best_vector[i]>=0 && best_vector[i]<16);",
          "249:         for(y=0; y<h; y++){",
          "250:             for(x=0; x<w; x++){",
          "251:                 decoded[x + y*stride]= src[x + y*stride] - block[best_count][x + w*y] + best_mean;",
          "252:             }",
          "253:         }",
          "260: static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *decoded_plane,",
          "261:     int width, int height, int src_stride, int stride)",
          "268:     uint8_t *src = s->scratchbuf + stride * 16;",
          "269:     const int lambda= (s->picture.quality*s->picture.quality) >> (2*FF_LAMBDA_SHIFT);",
          "276:     block_width = (width + 15) / 16;",
          "279:     if(s->picture.pict_type == AV_PICTURE_TYPE_P){",
          "280:         s->m.avctx= s->avctx;",
          "281:         s->m.current_picture_ptr= &s->m.current_picture;",
          "282:         s->m.last_picture_ptr   = &s->m.last_picture;",
          "283:         s->m.last_picture.f.data[0] = ref_plane;",
          "284:         s->m.linesize=",
          "285:         s->m.last_picture.f.linesize[0] =",
          "286:         s->m.new_picture.f.linesize[0] =",
          "288:         s->m.width= width;",
          "289:         s->m.height= height;",
          "290:         s->m.mb_width= block_width;",
          "291:         s->m.mb_height= block_height;",
          "292:         s->m.mb_stride= s->m.mb_width+1;",
          "293:         s->m.b8_stride= 2*s->m.mb_width+1;",
          "294:         s->m.f_code=1;",
          "295:         s->m.pict_type= s->picture.pict_type;",
          "296:         s->m.me_method= s->avctx->me_method;",
          "297:         s->m.me.scene_change_score=0;",
          "298:         s->m.flags= s->avctx->flags;",
          "302:         s->m.lambda= s->picture.quality;",
          "303:         s->m.qscale= (s->m.lambda*139 + FF_LAMBDA_SCALE*64) >> (FF_LAMBDA_SHIFT + 7);",
          "304:         s->m.lambda2= (s->m.lambda*s->m.lambda + FF_LAMBDA_SCALE/2) >> FF_LAMBDA_SHIFT;",
          "306:         if(!s->motion_val8[plane]){",
          "307:             s->motion_val8 [plane]= av_mallocz((s->m.b8_stride*block_height*2 + 2)*2*sizeof(int16_t));",
          "308:             s->motion_val16[plane]= av_mallocz((s->m.mb_stride*(block_height + 2) + 1)*2*sizeof(int16_t));",
          "311:         s->m.mb_type= s->mb_type;",
          "314:         s->m.current_picture.mb_mean=   (uint8_t *)s->dummy;",
          "315:         s->m.current_picture.mb_var=    (uint16_t*)s->dummy;",
          "316:         s->m.current_picture.mc_mb_var= (uint16_t*)s->dummy;",
          "320:         s->m.p_mv_table= s->motion_val16[plane] + s->m.mb_stride + 1;",
          "321:         s->m.dsp= s->dsp; //move",
          "324:         s->m.me.dia_size= s->avctx->dia_size;",
          "325:         s->m.first_slice_line=1;",
          "327:             s->m.new_picture.f.data[0] = src - y*16*stride; //ugly",
          "328:             s->m.mb_y= y;",
          "330:             for(i=0; i<16 && i + 16*y<height; i++){",
          "331:                 memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);",
          "332:                 for(x=width; x<16*block_width; x++)",
          "333:                     src[i*stride+x]= src[i*stride+x-1];",
          "335:             for(; i<16 && i + 16*y<16*block_height; i++)",
          "336:                 memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);",
          "339:                 s->m.mb_x= x;",
          "345:             s->m.first_slice_line=0;",
          "349:         ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code, CANDIDATE_MB_TYPE_INTER, 0);",
          "352:     s->m.first_slice_line=1;",
          "354:         for(i=0; i<16 && i + 16*y<height; i++){",
          "355:             memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);",
          "356:             for(x=width; x<16*block_width; x++)",
          "357:                 src[i*stride+x]= src[i*stride+x-1];",
          "359:         for(; i<16 && i + 16*y<16*block_height; i++)",
          "360:             memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);",
          "362:         s->m.mb_y= y;",
          "364:             uint8_t reorder_buffer[3][6][7*32];",
          "366:             int offset = y * 16 * stride + x * 16;",
          "367:             uint8_t *decoded= decoded_plane + offset;",
          "368:             uint8_t *ref= ref_plane + offset;",
          "369:             int score[4]={0,0,0,0}, best;",
          "370:             uint8_t *temp = s->scratchbuf;",
          "372:             if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < 3000){ //FIXME check size",
          "377:             s->m.mb_x= x;",
          "381:             if(s->picture.pict_type == AV_PICTURE_TYPE_I || (s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTRA)){",
          "382:                 for(i=0; i<6; i++){",
          "383:                     init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i], 7*32);",
          "384:                 }",
          "385:                 if(s->picture.pict_type == AV_PICTURE_TYPE_P){",
          "386:                     const uint8_t *vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];",
          "388:                     score[0]= vlc[1]*lambda;",
          "390:                 score[0]+= encode_block(s, src+16*x, NULL, temp, stride, 5, 64, lambda, 1);",
          "391:                 for(i=0; i<6; i++){",
          "392:                     count[0][i]= put_bits_count(&s->reorder_pb[i]);",
          "395:             }else",
          "396:                 score[0]= INT_MAX;",
          "398:             best=0;",
          "400:             if(s->picture.pict_type == AV_PICTURE_TYPE_P){",
          "401:                 const uint8_t *vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];",
          "405:                 motion_ptr= ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);",
          "406:                 if(s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTER){",
          "407:                     for(i=0; i<6; i++)",
          "408:                         init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i], 7*32);",
          "412:                     s->m.pb= s->reorder_pb[5];",
          "413:                     mx= motion_ptr[0];",
          "414:                     my= motion_ptr[1];",
          "415:                     assert(mx>=-32 && mx<=31);",
          "416:                     assert(my>=-32 && my<=31);",
          "417:                     assert(pred_x>=-32 && pred_x<=31);",
          "418:                     assert(pred_y>=-32 && pred_y<=31);",
          "421:                     s->reorder_pb[5]= s->m.pb;",
          "422:                     score[1] += lambda*put_bits_count(&s->reorder_pb[5]);",
          "424:                     dxy= (mx&1) + 2*(my&1);",
          "426:                     s->dsp.put_pixels_tab[0][dxy](temp+16, ref + (mx>>1) + stride*(my>>1), stride, 16);",
          "428:                     score[1]+= encode_block(s, src+16*x, temp+16, decoded, stride, 5, 64, lambda, 0);",
          "429:                     best= score[1] <= score[0];",
          "431:                     vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];",
          "432:                     score[2]= s->dsp.sse[0](NULL, src+16*x, ref, stride, 16);",
          "433:                     score[2]+= vlc[1]*lambda;",
          "434:                     if(score[2] < score[best] && mx==0 && my==0){",
          "435:                         best=2;",
          "437:                         for(i=0; i<6; i++){",
          "438:                             count[2][i]=0;",
          "439:                         }",
          "444:                 if(best==1){",
          "445:                     for(i=0; i<6; i++){",
          "446:                         count[1][i]= put_bits_count(&s->reorder_pb[i]);",
          "449:                 }else{",
          "450:                     motion_ptr[0                 ] = motion_ptr[1                 ]=",
          "451:                     motion_ptr[2                 ] = motion_ptr[3                 ]=",
          "452:                     motion_ptr[0+2*s->m.b8_stride] = motion_ptr[1+2*s->m.b8_stride]=",
          "453:                     motion_ptr[2+2*s->m.b8_stride] = motion_ptr[3+2*s->m.b8_stride]=0;",
          "459:             for(i=5; i>=0; i--){",
          "460:                 avpriv_copy_bits(&s->pb, reorder_buffer[best][i], count[best][i]);",
          "461:             }",
          "462:             if(best==0){",
          "464:             }",
          "466:         s->m.first_slice_line=0;",
          "473:     SVQ1Context * const s = avctx->priv_data;",
          "478:     s->frame_width = avctx->width;",
          "481:     s->y_block_width = (s->frame_width + 15) / 16;",
          "484:     s->c_block_width = (s->frame_width / 4 + 15) / 16;",
          "487:     s->avctx= avctx;",
          "488:     s->m.avctx= avctx;",
          "490:     s->m.me.temp      =",
          "491:     s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));",
          "492:     s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));",
          "493:     s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));",
          "494:     s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));",
          "495:     s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));",
          "496:     ff_h263_encode_init(&s->m); //mv_penalty",
          "",
          "[Added Lines]",
          "112: #define QUALITY_THRESHOLD    100",
          "115: static int encode_block(SVQ1Context *s, uint8_t *src, uint8_t *ref,",
          "116:                         uint8_t *decoded, int stride, int level,",
          "117:                         int threshold, int lambda, int intra)",
          "118: {",
          "121:     int block_sum[7] = { 0, 0, 0, 0, 0, 0 };",
          "122:     int w            = 2 << ((level + 2) >> 1);",
          "123:     int h            = 2 << ((level + 1) >> 1);",
          "124:     int size         = w * h;",
          "127:     const uint16_t(*mean_vlc)[2];",
          "128:     const uint8_t(*multistage_vlc)[2];",
          "130:     best_score = 0;",
          "132:     if (intra) {",
          "133:         codebook_sum   = svq1_intra_codebook_sum[level];",
          "134:         codebook       = ff_svq1_intra_codebooks[level];",
          "135:         mean_vlc       = ff_svq1_intra_mean_vlc;",
          "136:         multistage_vlc = ff_svq1_intra_multistage_vlc[level];",
          "137:         for (y = 0; y < h; y++) {",
          "138:             for (x = 0; x < w; x++) {",
          "139:                 int v = src[x + y * stride];",
          "140:                 block[0][x + w * y] = v;",
          "141:                 best_score         += v * v;",
          "142:                 block_sum[0]       += v;",
          "145:     } else {",
          "146:         codebook_sum   = svq1_inter_codebook_sum[level];",
          "147:         codebook       = ff_svq1_inter_codebooks[level];",
          "148:         mean_vlc       = ff_svq1_inter_mean_vlc + 256;",
          "149:         multistage_vlc = ff_svq1_inter_multistage_vlc[level];",
          "150:         for (y = 0; y < h; y++) {",
          "151:             for (x = 0; x < w; x++) {",
          "152:                 int v = src[x + y * stride] - ref[x + y * stride];",
          "153:                 block[0][x + w * y] = v;",
          "154:                 best_score         += v * v;",
          "155:                 block_sum[0]       += v;",
          "160:     best_count  = 0;",
          "161:     best_score -= (int)(((unsigned)block_sum[0] * block_sum[0]) >> (level + 3));",
          "162:     best_mean   = (block_sum[0] + (size >> 1)) >> (level + 3);",
          "164:     if (level < 4) {",
          "165:         for (count = 1; count < 7; count++) {",
          "166:             int best_vector_score = INT_MAX;",
          "167:             int best_vector_sum   = -999, best_vector_mean = -999;",
          "168:             const int stage       = count - 1;",
          "171:             for (i = 0; i < 16; i++) {",
          "172:                 int sum = codebook_sum[stage * 16 + i];",
          "175:                 vector = codebook + stage * size * 16 + i * size;",
          "176:                 sqr    = s->dsp.ssd_int8_vs_int16(vector, block[stage], size);",
          "177:                 diff   = block_sum[stage] - sum;",
          "178:                 score  = sqr - ((diff * (int64_t)diff) >> (level + 3)); // FIXME: 64bit slooow",
          "179:                 if (score < best_vector_score) {",
          "180:                     int mean = (diff + (size >> 1)) >> (level + 3);",
          "181:                     assert(mean > -300 && mean < 300);",
          "182:                     mean               = av_clip(mean, intra ? 0 : -256, 255);",
          "183:                     best_vector_score  = score;",
          "184:                     best_vector[stage] = i;",
          "185:                     best_vector_sum    = sum;",
          "186:                     best_vector_mean   = mean;",
          "190:             vector = codebook + stage * size * 16 + best_vector[stage] * size;",
          "191:             for (j = 0; j < size; j++)",
          "192:                 block[stage + 1][j] = block[stage][j] - vector[j];",
          "193:             block_sum[stage + 1] = block_sum[stage] - best_vector_sum;",
          "194:             best_vector_score   += lambda *",
          "195:                                    (+1 + 4 * count +",
          "196:                                     multistage_vlc[1 + count][1]",
          "197:                                     + mean_vlc[best_vector_mean][1]);",
          "199:             if (best_vector_score < best_score) {",
          "200:                 best_score = best_vector_score;",
          "201:                 best_count = count;",
          "202:                 best_mean  = best_vector_mean;",
          "207:     split = 0;",
          "208:     if (best_score > threshold && level) {",
          "209:         int score  = 0;",
          "210:         int offset = (level & 1) ? stride * h / 2 : w / 2;",
          "213:         for (i = level - 1; i >= 0; i--)",
          "214:             backup[i] = s->reorder_pb[i];",
          "215:         score += encode_block(s, src, ref, decoded, stride, level - 1,",
          "216:                               threshold >> 1, lambda, intra);",
          "217:         score += encode_block(s, src + offset, ref + offset, decoded + offset,",
          "218:                               stride, level - 1, threshold >> 1, lambda, intra);",
          "221:         if (score < best_score) {",
          "222:             best_score = score;",
          "223:             split      = 1;",
          "224:         } else {",
          "225:             for (i = level - 1; i >= 0; i--)",
          "226:                 s->reorder_pb[i] = backup[i];",
          "232:     if (!split) {",
          "233:         assert((best_mean >= 0 && best_mean < 256) || !intra);",
          "234:         assert(best_mean >= -256 && best_mean < 256);",
          "235:         assert(best_count >= 0 && best_count < 7);",
          "236:         assert(level < 4 || best_count == 0);",
          "240:                  multistage_vlc[1 + best_count][1],",
          "241:                  multistage_vlc[1 + best_count][0]);",
          "243:                  mean_vlc[best_mean][0]);",
          "245:         for (i = 0; i < best_count; i++) {",
          "246:             assert(best_vector[i] >= 0 && best_vector[i] < 16);",
          "250:         for (y = 0; y < h; y++)",
          "251:             for (x = 0; x < w; x++)",
          "252:                 decoded[x + y * stride] = src[x + y * stride] -",
          "253:                                           block[best_count][x + w * y] +",
          "254:                                           best_mean;",
          "260: static int svq1_encode_plane(SVQ1Context *s, int plane,",
          "261:                              unsigned char *src_plane,",
          "262:                              unsigned char *ref_plane,",
          "263:                              unsigned char *decoded_plane,",
          "264:                              int width, int height, int src_stride, int stride)",
          "271:     uint8_t *src     = s->scratchbuf + stride * 16;",
          "272:     const int lambda = (s->picture.quality * s->picture.quality) >>",
          "273:                        (2 * FF_LAMBDA_SHIFT);",
          "280:     block_width  = (width  + 15) / 16;",
          "283:     if (s->picture.pict_type == AV_PICTURE_TYPE_P) {",
          "284:         s->m.avctx                         = s->avctx;",
          "285:         s->m.current_picture_ptr           = &s->m.current_picture;",
          "286:         s->m.last_picture_ptr              = &s->m.last_picture;",
          "287:         s->m.last_picture.f.data[0]        = ref_plane;",
          "288:         s->m.linesize                      =",
          "289:         s->m.last_picture.f.linesize[0]    =",
          "290:         s->m.new_picture.f.linesize[0]     =",
          "292:         s->m.width                         = width;",
          "293:         s->m.height                        = height;",
          "294:         s->m.mb_width                      = block_width;",
          "295:         s->m.mb_height                     = block_height;",
          "296:         s->m.mb_stride                     = s->m.mb_width + 1;",
          "297:         s->m.b8_stride                     = 2 * s->m.mb_width + 1;",
          "298:         s->m.f_code                        = 1;",
          "299:         s->m.pict_type                     = s->picture.pict_type;",
          "300:         s->m.me_method                     = s->avctx->me_method;",
          "301:         s->m.me.scene_change_score         = 0;",
          "302:         s->m.flags                         = s->avctx->flags;",
          "305:         s->m.lambda                        = s->picture.quality;",
          "306:         s->m.qscale                        = (s->m.lambda * 139 +",
          "307:                                               FF_LAMBDA_SCALE * 64) >>",
          "308:                                              (FF_LAMBDA_SHIFT + 7);",
          "309:         s->m.lambda2                       = (s->m.lambda * s->m.lambda +",
          "310:                                               FF_LAMBDA_SCALE / 2) >>",
          "311:                                              FF_LAMBDA_SHIFT;",
          "313:         if (!s->motion_val8[plane]) {",
          "314:             s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *",
          "315:                                                  block_height * 2 + 2) *",
          "316:                                                 2 * sizeof(int16_t));",
          "317:             s->motion_val16[plane] = av_mallocz((s->m.mb_stride *",
          "318:                                                  (block_height + 2) + 1) *",
          "319:                                                 2 * sizeof(int16_t));",
          "322:         s->m.mb_type = s->mb_type;",
          "325:         s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;",
          "326:         s->m.current_picture.mb_var    = (uint16_t *)s->dummy;",
          "327:         s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;",
          "331:         s->m.p_mv_table                      = s->motion_val16[plane] +",
          "332:                                                s->m.mb_stride + 1;",
          "333:         s->m.dsp                             = s->dsp; // move",
          "336:         s->m.me.dia_size      = s->avctx->dia_size;",
          "337:         s->m.first_slice_line = 1;",
          "339:             s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly",
          "340:             s->m.mb_y                  = y;",
          "342:             for (i = 0; i < 16 && i + 16 * y < height; i++) {",
          "343:                 memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],",
          "344:                        width);",
          "345:                 for (x = width; x < 16 * block_width; x++)",
          "346:                     src[i * stride + x] = src[i * stride + x - 1];",
          "348:             for (; i < 16 && i + 16 * y < 16 * block_height; i++)",
          "349:                 memcpy(&src[i * stride], &src[(i - 1) * stride],",
          "350:                        16 * block_width);",
          "353:                 s->m.mb_x = x;",
          "359:             s->m.first_slice_line = 0;",
          "363:         ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,",
          "364:                         CANDIDATE_MB_TYPE_INTER, 0);",
          "367:     s->m.first_slice_line = 1;",
          "369:         for (i = 0; i < 16 && i + 16 * y < height; i++) {",
          "370:             memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],",
          "371:                    width);",
          "372:             for (x = width; x < 16 * block_width; x++)",
          "373:                 src[i * stride + x] = src[i * stride + x - 1];",
          "375:         for (; i < 16 && i + 16 * y < 16 * block_height; i++)",
          "376:             memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);",
          "378:         s->m.mb_y = y;",
          "380:             uint8_t reorder_buffer[3][6][7 * 32];",
          "382:             int offset       = y * 16 * stride + x * 16;",
          "383:             uint8_t *decoded = decoded_plane + offset;",
          "384:             uint8_t *ref     = ref_plane + offset;",
          "385:             int score[4]     = { 0, 0, 0, 0 }, best;",
          "386:             uint8_t *temp    = s->scratchbuf;",
          "388:             if (s->pb.buf_end - s->pb.buf -",
          "389:                 (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size",
          "394:             s->m.mb_x = x;",
          "398:             if (s->picture.pict_type == AV_PICTURE_TYPE_I ||",
          "399:                 (s->m.mb_type[x + y * s->m.mb_stride] &",
          "400:                  CANDIDATE_MB_TYPE_INTRA)) {",
          "401:                 for (i = 0; i < 6; i++)",
          "402:                     init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],",
          "403:                                   7 * 32);",
          "404:                 if (s->picture.pict_type == AV_PICTURE_TYPE_P) {",
          "405:                     const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];",
          "407:                     score[0] = vlc[1] * lambda;",
          "409:                 score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,",
          "410:                                          5, 64, lambda, 1);",
          "411:                 for (i = 0; i < 6; i++) {",
          "412:                     count[0][i] = put_bits_count(&s->reorder_pb[i]);",
          "415:             } else",
          "416:                 score[0] = INT_MAX;",
          "418:             best = 0;",
          "420:             if (s->picture.pict_type == AV_PICTURE_TYPE_P) {",
          "421:                 const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];",
          "425:                 motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);",
          "426:                 if (s->m.mb_type[x + y * s->m.mb_stride] &",
          "427:                     CANDIDATE_MB_TYPE_INTER) {",
          "428:                     for (i = 0; i < 6; i++)",
          "429:                         init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],",
          "430:                                       7 * 32);",
          "434:                     s->m.pb = s->reorder_pb[5];",
          "435:                     mx      = motion_ptr[0];",
          "436:                     my      = motion_ptr[1];",
          "437:                     assert(mx     >= -32 && mx     <= 31);",
          "438:                     assert(my     >= -32 && my     <= 31);",
          "439:                     assert(pred_x >= -32 && pred_x <= 31);",
          "440:                     assert(pred_y >= -32 && pred_y <= 31);",
          "443:                     s->reorder_pb[5] = s->m.pb;",
          "444:                     score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);",
          "446:                     dxy = (mx & 1) + 2 * (my & 1);",
          "448:                     s->dsp.put_pixels_tab[0][dxy](temp + 16,",
          "449:                                                   ref + (mx >> 1) +",
          "450:                                                   stride * (my >> 1),",
          "451:                                                   stride, 16);",
          "453:                     score[1] += encode_block(s, src + 16 * x, temp + 16,",
          "454:                                              decoded, stride, 5, 64, lambda, 0);",
          "455:                     best      = score[1] <= score[0];",
          "457:                     vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];",
          "458:                     score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,",
          "459:                                               stride, 16);",
          "460:                     score[2] += vlc[1] * lambda;",
          "461:                     if (score[2] < score[best] && mx == 0 && my == 0) {",
          "462:                         best = 2;",
          "464:                         for (i = 0; i < 6; i++)",
          "465:                             count[2][i] = 0;",
          "470:                 if (best == 1) {",
          "471:                     for (i = 0; i < 6; i++) {",
          "472:                         count[1][i] = put_bits_count(&s->reorder_pb[i]);",
          "475:                 } else {",
          "476:                     motion_ptr[0]                      =",
          "477:                     motion_ptr[1]                      =",
          "478:                     motion_ptr[2]                      =",
          "479:                     motion_ptr[3]                      =",
          "480:                     motion_ptr[0 + 2 * s->m.b8_stride] =",
          "481:                     motion_ptr[1 + 2 * s->m.b8_stride] =",
          "482:                     motion_ptr[2 + 2 * s->m.b8_stride] =",
          "483:                     motion_ptr[3 + 2 * s->m.b8_stride] = 0;",
          "489:             for (i = 5; i >= 0; i--)",
          "490:                 avpriv_copy_bits(&s->pb, reorder_buffer[best][i],",
          "491:                                  count[best][i]);",
          "492:             if (best == 0)",
          "495:         s->m.first_slice_line = 0;",
          "502:     SVQ1Context *const s = avctx->priv_data;",
          "507:     s->frame_width  = avctx->width;",
          "510:     s->y_block_width  = (s->frame_width  + 15) / 16;",
          "513:     s->c_block_width  = (s->frame_width  / 4 + 15) / 16;",
          "516:     s->avctx               = avctx;",
          "517:     s->m.avctx             = avctx;",
          "519:     s->m.me.temp           =",
          "520:     s->m.me.scratchpad     = av_mallocz((avctx->width + 64) *",
          "521:                                         2 * 16 * 2 * sizeof(uint8_t));",
          "522:     s->m.me.map            = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));",
          "523:     s->m.me.score_map      = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));",
          "524:     s->mb_type             = av_mallocz((s->y_block_width + 1) *",
          "525:                                         s->y_block_height * sizeof(int16_t));",
          "526:     s->dummy               = av_mallocz((s->y_block_width + 1) *",
          "527:                                         s->y_block_height * sizeof(int32_t));",
          "528:     ff_h263_encode_init(&s->m); // mv_penalty",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "501: static int svq1_encode_frame(AVCodecContext *avctx, AVPacket *pkt,",
          "502:                              const AVFrame *pict, int *got_packet)",
          "503: {",
          "506:     AVFrame temp;",
          "507:     int i, ret;",
          "509:     if (!pkt->data &&",
          "511:         av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");",
          "512:         return ret;",
          "513:     }",
          "516:         av_log(avctx, AV_LOG_ERROR, \"unsupported pixel format\\n\");",
          "517:         return -1;",
          "518:     }",
          "521:         avctx->get_buffer(avctx, &s->current_picture);",
          "522:         avctx->get_buffer(avctx, &s->last_picture);",
          "523:         s->scratchbuf = av_malloc(s->current_picture.linesize[0] * 16 * 2);",
          "524:     }",
          "530:     init_put_bits(&s->pb, pkt->data, pkt->size);",
          "534:     p->key_frame = p->pict_type == AV_PICTURE_TYPE_I;",
          "536:     svq1_write_header(s, p->pict_type);",
          "547:         put_bits(&s->pb, 1, 0);",
          "549:     flush_put_bits(&s->pb);",
          "",
          "[Removed Lines]",
          "504:     SVQ1Context * const s = avctx->priv_data;",
          "505:     AVFrame * const p = &s->picture;",
          "510:         (ret = av_new_packet(pkt, s->y_block_width*s->y_block_height*MAX_MB_BYTES*3 + FF_MIN_BUFFER_SIZE) < 0)) {",
          "515:     if(avctx->pix_fmt != AV_PIX_FMT_YUV410P){",
          "520:     if(!s->current_picture.data[0]){",
          "526:     temp= s->current_picture;",
          "527:     s->current_picture= s->last_picture;",
          "528:     s->last_picture= temp;",
          "533:     p->pict_type = avctx->gop_size && avctx->frame_number % avctx->gop_size ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I;",
          "537:     for(i=0; i<3; i++){",
          "538:         if(svq1_encode_plane(s, i,",
          "539:             s->picture.data[i], s->last_picture.data[i], s->current_picture.data[i],",
          "540:             s->frame_width / (i?4:1), s->frame_height / (i?4:1),",
          "541:             s->picture.linesize[i], s->current_picture.linesize[i]) < 0)",
          "542:                 return -1;",
          "543:     }",
          "546:     while(put_bits_count(&s->pb) & 31)",
          "",
          "[Added Lines]",
          "536:     SVQ1Context *const s = avctx->priv_data;",
          "537:     AVFrame *const p     = &s->picture;",
          "542:         (ret = av_new_packet(pkt, s->y_block_width * s->y_block_height *",
          "543:                              MAX_MB_BYTES * 3 + FF_MIN_BUFFER_SIZE) < 0)) {",
          "548:     if (avctx->pix_fmt != AV_PIX_FMT_YUV410P) {",
          "553:     if (!s->current_picture.data[0]) {",
          "559:     temp               = s->current_picture;",
          "560:     s->current_picture = s->last_picture;",
          "561:     s->last_picture    = temp;",
          "566:     p->pict_type = avctx->gop_size && avctx->frame_number % avctx->gop_size ?",
          "567:                    AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I;",
          "571:     for (i = 0; i < 3; i++)",
          "572:         if (svq1_encode_plane(s, i,",
          "573:                               s->picture.data[i],",
          "574:                               s->last_picture.data[i],",
          "575:                               s->current_picture.data[i],",
          "576:                               s->frame_width  / (i ? 4 : 1),",
          "577:                               s->frame_height / (i ? 4 : 1),",
          "578:                               s->picture.linesize[i],",
          "579:                               s->current_picture.linesize[i]) < 0)",
          "580:             return -1;",
          "583:     while (put_bits_count(&s->pb) & 31)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "559: static av_cold int svq1_encode_end(AVCodecContext *avctx)",
          "560: {",
          "562:     int i;",
          "566:     av_freep(&s->m.me.scratchpad);",
          "567:     av_freep(&s->m.me.map);",
          "",
          "[Removed Lines]",
          "561:     SVQ1Context * const s = avctx->priv_data;",
          "564:     av_log(avctx, AV_LOG_DEBUG, \"RD: %f\\n\", s->rd_total/(double)(avctx->width*avctx->height*avctx->frame_number));",
          "",
          "[Added Lines]",
          "598:     SVQ1Context *const s = avctx->priv_data;",
          "601:     av_log(avctx, AV_LOG_DEBUG, \"RD: %f\\n\",",
          "602:            s->rd_total / (double)(avctx->width * avctx->height *",
          "603:                                   avctx->frame_number));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "570:     av_freep(&s->dummy);",
          "571:     av_freep(&s->scratchbuf);",
          "574:         av_freep(&s->motion_val8[i]);",
          "575:         av_freep(&s->motion_val16[i]);",
          "576:     }",
          "",
          "[Removed Lines]",
          "573:     for(i=0; i<3; i++){",
          "",
          "[Added Lines]",
          "612:     for (i = 0; i < 3; i++) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "587:     .init           = svq1_encode_init,",
          "588:     .encode2        = svq1_encode_frame,",
          "589:     .close          = svq1_encode_end,",
          "591:     .long_name      = NULL_IF_CONFIG_SMALL(\"Sorenson Vector Quantizer 1 / Sorenson Video 1 / SVQ1\"),",
          "592: };",
          "",
          "[Removed Lines]",
          "590:     .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV410P, AV_PIX_FMT_NONE },",
          "",
          "[Added Lines]",
          "628:     .pix_fmts       = (const enum PixelFormat[]) { AV_PIX_FMT_YUV410P,",
          "629:                                                    AV_PIX_FMT_NONE },",
          "",
          "---------------"
        ],
        "libavcodec/svq1enc_cb.h||libavcodec/svq1enc_cb.h": [
          "File: libavcodec/svq1enc_cb.h -> libavcodec/svq1enc_cb.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include <stdint.h>",
          "32: static const int8_t svq1_inter_codebook_sum[4][16*6] = {",
          "62: };",
          "64: static const int8_t svq1_intra_codebook_sum[4][16*6] = {",
          "94: };",
          "",
          "[Removed Lines]",
          "33:  {",
          "34:  -1,  1, -2,  0,  1, -1, -1, -1, -2, -1,  1, -1, -1,  0, -1, -1,",
          "35:   0, -1, -1, -1, -1,  0, -1,  0,  0,  0, -3,  1, -1,  0,  1, -1,",
          "36:   1, -1,  2,  2,  1,  1,  2,  0,  0,  0, -1,  1,  1,  0,  0,  0,",
          "37:   1, -1,  0,  1, -1,  1,  1,  0,  1,  0, -1,  1,  1,  0,  0,  0,",
          "38:  -2,  0,  0, -2,  0,  0, -2,  0, -2, -1, -2, -1,  0,  0, -1,  0,",
          "39:   1,  0,  1, -1,  2,  2,  1,  2,  2,  1,  0,  1,  1,  0,  1,  1,",
          "40:  },{",
          "41:  -2,  1, -1, -1,  1,  0,  1, -1, -1, -1,  1, -1,  0, -1,  0, -1,",
          "42:   0,  0,  0, -2,  0,  1,  0, -1, -1,  0,  2, -3,  1, -2,  3, -1,",
          "43:   2,  0,  2,  1,  1, -1,  1,  1,  0,  0,  1,  1,  2, -2,  1,  0,",
          "44:  -2, -1,  2, -2, -2,  0, -3,  0, -1,  0, -1,  0, -1,  0, -2, -3,",
          "45:   1, -2, -2, -1,  1, -1, -1,  1, -1,  1,  1,  0, -2,  0,  1,  1,",
          "46:   1,  1,  2,  1,  0,  0, -1,  0,  0,  1,  0,  1, -1,  1,  0,  2,",
          "47:  },{",
          "48:   0,  0,  0, -3,  1,  1,  1, -3,  0, -1,  0, -3,  1, -3,  0, -2,",
          "49:   1,  2, -1, -3,  0, -3,  1, -1,  0, -1,  0,  0,  1,  2,  1,  1,",
          "50:  -1,  2, -3,  3,  1,  0, -5,  1,  0, -1, -3,  1,  0,  2,  0, -3,",
          "51:   4,  2,  0, -2,  1, -2,  3, -2,  1,  1,  0, -1,  2,  5,  3,  1,",
          "52:  -1,  0,  2, -3, -2,  0,  0, -2,  2, -3, -1, -1,  2,  1,  0, -2,",
          "53:   3, -1,  1, -1,  2,  4,  0,  1,  0,  1,  0, -1, -3, -2, -1,  0,",
          "54:  },{",
          "55:   0,  2, -1, -1,  2, -4, -2,  3,  0, -1, -5,  1,  0,  1,  0,  6,",
          "56:  -2,  2,  0,  1,  1, -1, -1, -2,  1, -2, -1,  0,  2, -2, -2, -1,",
          "57:  -4,  2, -1, -3, -1, -2,  2, -1,  2, -1,  2,  0,  3, -3, -3,  0,",
          "58:  -3,  0,  0, -2,  4, -4,  0, -1,  4,  0, -2, -2,  3, -2,  0,  4,",
          "59:   5,  0,  1,  0, -3,  3,  3,  2,  0,  0,  1,  2, -5, -2, -3,  0,",
          "60:  -3,  2, -2,  2, -2,  4,  7, -3,  4,  2,  3,  2, -1,  0, -3,  1,",
          "61:  }",
          "65:  {",
          "66:   0,  0,  0, -1, -1, -1, -1, -2,  0, -1, -1,  0, -1,  0,  1,  0,",
          "67:   1,  0, -1,  1,  0,  0, -1,  1, -1,  0,  0,  0, -1,  1,  0,  0,",
          "68:  -1,  0,  0,  1, -1,  1,  0, -1, -1,  0,  1,  1,  0,  0, -1,  1,",
          "69:   0,  1,  0,  0,  1, -1,  0,  0,  0, -1,  1,  0,  1,  0, -2,  1,",
          "70:   0, -1,  1,  0,  0,  0,  1,  0, -1,  0,  0,  0, -1,  0,  0,  0,",
          "71:   0,  1,  1,  0,  0, -1,  0,  1,  0,  0,  0,  0, -1,  1,  1, -1,",
          "72:  },{",
          "73:  -1, -2,  0, -1,  1,  0, -1,  0, -1, -4, -1, -2, -1, -2,  1, -2,",
          "74:   0,  0,  4, -2, -1,  1,  1,  0,  2,  1,  1,  0,  2,  0,  0,  0,",
          "75:   1,  1,  0, -1, -1, -1,  1,  0, -1, -3, -3,  1, -1,  1, -2, -1,",
          "76:   1, -1,  0,  1,  2,  1, -1, -1,  1,  1,  1,  2,  1,  0,  1, -2,",
          "77:  -2,  0, -1, -2, -2,  0, -1, -1, -1,  0,  1,  0, -1, -1,  0, -1,",
          "78:   0,  2,  1,  2,  2,  1, -1,  1,  0,  2,  0, -1,  1,  0,  0,  0,",
          "79:  },{",
          "80:  -2,  0, -1, -1,  1,  1, -2,  0, -2,  0,  1, -2, -2,  1, -1, -1,",
          "81:   3, -2,  0, -3, -4, -3,  2,  1,  0,  3, -2,  2,  3,  2,  2, -1,",
          "82:  -3,  1,  0,  1,  0,  0,  0,  1, -2,  1, -2, -2, -1, -2, -2,  2,",
          "83:   0, -4,  0,  2, -1,  0,  2,  2,  2,  1,  0, -1, -1,  1, -3,  2,",
          "84:   2,  1,  0,  3,  1, -1,  1,  3,  1,  0,  1,  1,  2, -1,  1, -1,",
          "85:  -2, -1,  0, -1,  1, -1,  1, -2, -2, -1, -1, -3,  1, -4, -3,  1,",
          "86:  },{",
          "87:  -2,  0, -2,  3, -1, -1,  0,  2,  2, -1, -3,  2,  1,  0, -2, -1,",
          "88:  -3, -2, -2,  1,  2, -3,  0,  1, -5, -2, -3,  0, -2, -1,  2,  0,",
          "89:  -1, -1,  0, -2,  1,  3, -7, -2, -2, -1,  2, -1,  0,  3,  1,  3,",
          "90:   1,  0,  0,  1,  2,  3,  1,  2,  0, -2, -2,  1,  1,  2,  2,  3,",
          "91:   4,  1, -1,  2, -2,  4,  0,  0,  0,  4,  2,  0, -2, -2,  2, -4,",
          "92:  -1,  5, -2, -2, -3,  2, -3, -1,  3, -3,  0,  4,  3,  0,  1, -2,",
          "93:  }",
          "",
          "[Added Lines]",
          "33:     { -1,  1, -2,  0,  1, -1, -1, -1, -2, -1,  1, -1, -1,  0, -1, -1,",
          "34:        0, -1, -1, -1, -1,  0, -1,  0,  0,  0, -3,  1, -1,  0,  1, -1,",
          "35:        1, -1,  2,  2,  1,  1,  2,  0,  0,  0, -1,  1,  1,  0,  0,  0,",
          "36:        1, -1,  0,  1, -1,  1,  1,  0,  1,  0, -1,  1,  1,  0,  0,  0,",
          "37:       -2,  0,  0, -2,  0,  0, -2,  0, -2, -1, -2, -1,  0,  0, -1,  0,",
          "38:        1,  0,  1, -1,  2,  2,  1,  2,  2,  1,  0,  1,  1,  0,  1,  1, },",
          "39:     { -2,  1, -1, -1,  1,  0,  1, -1, -1, -1,  1, -1,  0, -1,  0, -1,",
          "40:        0,  0,  0, -2,  0,  1,  0, -1, -1,  0,  2, -3,  1, -2,  3, -1,",
          "41:        2,  0,  2,  1,  1, -1,  1,  1,  0,  0,  1,  1,  2, -2,  1,  0,",
          "42:       -2, -1,  2, -2, -2,  0, -3,  0, -1,  0, -1,  0, -1,  0, -2, -3,",
          "43:        1, -2, -2, -1,  1, -1, -1,  1, -1,  1,  1,  0, -2,  0,  1,  1,",
          "44:        1,  1,  2,  1,  0,  0, -1,  0,  0,  1,  0,  1, -1,  1,  0,  2, },",
          "45:     {  0,  0,  0, -3,  1,  1,  1, -3,  0, -1,  0, -3,  1, -3,  0, -2,",
          "46:        1,  2, -1, -3,  0, -3,  1, -1,  0, -1,  0,  0,  1,  2,  1,  1,",
          "47:       -1,  2, -3,  3,  1,  0, -5,  1,  0, -1, -3,  1,  0,  2,  0, -3,",
          "48:        4,  2,  0, -2,  1, -2,  3, -2,  1,  1,  0, -1,  2,  5,  3,  1,",
          "49:       -1,  0,  2, -3, -2,  0,  0, -2,  2, -3, -1, -1,  2,  1,  0, -2,",
          "50:        3, -1,  1, -1,  2,  4,  0,  1,  0,  1,  0, -1, -3, -2, -1,  0, },",
          "51:     {  0,  2, -1, -1,  2, -4, -2,  3,  0, -1, -5,  1,  0,  1,  0,  6,",
          "52:       -2,  2,  0,  1,  1, -1, -1, -2,  1, -2, -1,  0,  2, -2, -2, -1,",
          "53:       -4,  2, -1, -3, -1, -2,  2, -1,  2, -1,  2,  0,  3, -3, -3,  0,",
          "54:       -3,  0,  0, -2,  4, -4,  0, -1,  4,  0, -2, -2,  3, -2,  0,  4,",
          "55:        5,  0,  1,  0, -3,  3,  3,  2,  0,  0,  1,  2, -5, -2, -3,  0,",
          "56:       -3,  2, -2,  2, -2,  4,  7, -3,  4,  2,  3,  2, -1,  0, -3,  1, }",
          "60:     {  0,  0,  0, -1, -1, -1, -1, -2,  0, -1, -1,  0, -1,  0,  1,  0,",
          "61:        1,  0, -1,  1,  0,  0, -1,  1, -1,  0,  0,  0, -1,  1,  0,  0,",
          "62:       -1,  0,  0,  1, -1,  1,  0, -1, -1,  0,  1,  1,  0,  0, -1,  1,",
          "63:        0,  1,  0,  0,  1, -1,  0,  0,  0, -1,  1,  0,  1,  0, -2,  1,",
          "64:        0, -1,  1,  0,  0,  0,  1,  0, -1,  0,  0,  0, -1,  0,  0,  0,",
          "65:        0,  1,  1,  0,  0, -1,  0,  1,  0,  0,  0,  0, -1,  1,  1, -1, },",
          "66:     { -1, -2,  0, -1,  1,  0, -1,  0, -1, -4, -1, -2, -1, -2,  1, -2,",
          "67:        0,  0,  4, -2, -1,  1,  1,  0,  2,  1,  1,  0,  2,  0,  0,  0,",
          "68:        1,  1,  0, -1, -1, -1,  1,  0, -1, -3, -3,  1, -1,  1, -2, -1,",
          "69:        1, -1,  0,  1,  2,  1, -1, -1,  1,  1,  1,  2,  1,  0,  1, -2,",
          "70:       -2,  0, -1, -2, -2,  0, -1, -1, -1,  0,  1,  0, -1, -1,  0, -1,",
          "71:        0,  2,  1,  2,  2,  1, -1,  1,  0,  2,  0, -1,  1,  0,  0,  0, },",
          "72:     { -2,  0, -1, -1,  1,  1, -2,  0, -2,  0,  1, -2, -2,  1, -1, -1,",
          "73:        3, -2,  0, -3, -4, -3,  2,  1,  0,  3, -2,  2,  3,  2,  2, -1,",
          "74:       -3,  1,  0,  1,  0,  0,  0,  1, -2,  1, -2, -2, -1, -2, -2,  2,",
          "75:        0, -4,  0,  2, -1,  0,  2,  2,  2,  1,  0, -1, -1,  1, -3,  2,",
          "76:        2,  1,  0,  3,  1, -1,  1,  3,  1,  0,  1,  1,  2, -1,  1, -1,",
          "77:       -2, -1,  0, -1,  1, -1,  1, -2, -2, -1, -1, -3,  1, -4, -3,  1, },",
          "78:     { -2,  0, -2,  3, -1, -1,  0,  2,  2, -1, -3,  2,  1,  0, -2, -1,",
          "79:       -3, -2, -2,  1,  2, -3,  0,  1, -5, -2, -3,  0, -2, -1,  2,  0,",
          "80:       -1, -1,  0, -2,  1,  3, -7, -2, -2, -1,  2, -1,  0,  3,  1,  3,",
          "81:        1,  0,  0,  1,  2,  3,  1,  2,  0, -2, -2,  1,  1,  2,  2,  3,",
          "82:        4,  1, -1,  2, -2,  4,  0,  0,  0,  4,  2,  0, -2, -2,  2, -4,",
          "83:       -1,  5, -2, -2, -3,  2, -3, -1,  3, -3,  0,  4,  3,  0,  1, -2, }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-2584",
  "cve_desc": "arch/x86/kvm/emulate.c in the Linux kernel through 4.9.3 allows local users to obtain sensitive information from kernel memory or cause a denial of service (use-after-free) via a crafted application that leverages instruction emulation for fxrstor, fxsave, sgdt, and sidt.",
  "repo": "torvalds/linux",
  "patch_hash": "129a72a0d3c8e139a04512325384fe5ac119e74d",
  "patch_info": {
    "commit_hash": "129a72a0d3c8e139a04512325384fe5ac119e74d",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/129a72a0d3c8e139a04512325384fe5ac119e74d",
    "files": [
      "arch/x86/kvm/emulate.c"
    ],
    "message": "KVM: x86: Introduce segmented_write_std\n\nIntroduces segemented_write_std.\n\nSwitches from emulated reads/writes to standard read/writes in fxsave,\nfxrstor, sgdt, and sidt.  This fixes CVE-2017-2584, a longstanding\nkernel memory leak.\n\nSince commit 283c95d0e389 (\"KVM: x86: emulate FXSAVE and FXRSTOR\",\n2016-11-09), which is luckily not yet in any final release, this would\nalso be an exploitable kernel memory *write*!\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nCc: stable@vger.kernel.org\nFixes: 96051572c819194c37a8367624b285be10297eca\nFixes: 283c95d0e3891b64087706b344a4b545d04a6e62\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Steve Rutherford <srutherford@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
      "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "818:  return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);",
      "819: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "821: static int segmented_write_std(struct x86_emulate_ctxt *ctxt,",
      "822:           struct segmented_address addr,",
      "823:           void *data,",
      "824:           unsigned int size)",
      "825: {",
      "826:  int rc;",
      "827:  ulong linear;",
      "829:  rc = linearize(ctxt, addr, size, true, &linear);",
      "830:  if (rc != X86EMUL_CONTINUE)",
      "831:   return rc;",
      "832:  return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);",
      "833: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3685:  }",
      "3687:  ctxt->dst.type = OP_NONE;",
      "3690: }",
      "3692: static int em_sgdt(struct x86_emulate_ctxt *ctxt)",
      "",
      "[Removed Lines]",
      "3688:  return segmented_write(ctxt, ctxt->dst.addr.mem,",
      "3689:           &desc_ptr, 2 + ctxt->op_bytes);",
      "",
      "[Added Lines]",
      "3702:  return segmented_write_std(ctxt, ctxt->dst.addr.mem,",
      "3703:        &desc_ptr, 2 + ctxt->op_bytes);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3932:  else",
      "3933:   size = offsetof(struct fxregs_state, xmm_space[0]);",
      "3936: }",
      "3938: static int fxrstor_fixup(struct x86_emulate_ctxt *ctxt,",
      "",
      "[Removed Lines]",
      "3935:  return segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);",
      "",
      "[Added Lines]",
      "3949:  return segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3974:  if (rc != X86EMUL_CONTINUE)",
      "3975:   return rc;",
      "3978:  if (rc != X86EMUL_CONTINUE)",
      "3979:   return rc;",
      "",
      "[Removed Lines]",
      "3977:  rc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);",
      "",
      "[Added Lines]",
      "3991:  rc = segmented_read_std(ctxt, ctxt->memop.addr.mem, &fx_state, 512);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9d643f63128bcec2b845fd0719a6b971b68c59cc",
      "candidate_info": {
        "commit_hash": "9d643f63128bcec2b845fd0719a6b971b68c59cc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9d643f63128bcec2b845fd0719a6b971b68c59cc",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: avoid large stack allocations in em_fxrstor\n\nem_fxstor previously called fxstor_fixup.  Both created instances of\nstruct fxregs_state on the stack, which triggered the warning:\n\narch/x86/kvm/emulate.c:4018:12: warning: stack frame size of 1080 bytes\nin function\n      'em_fxrstor' [-Wframe-larger-than=]\nstatic int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n           ^\nwith CONFIG_FRAME_WARN set to 1024.\n\nThis patch does the fixup in em_fxstor now, avoiding one additional\nstruct fxregs_state, and now fxstor_fixup can be removed as it has no\nother call sites.\n\nFurther, the calculation for offsets into xmm_space can be shared\nbetween em_fxstor and em_fxsave.\n\nSigned-off-by: Nick Desaulniers <nick.desaulniers@gmail.com>\n[Clean up calculation of offsets and fix it for 64-bit mode. - Paolo]\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3940:  return X86EMUL_CONTINUE;",
          "3941: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3947: static size_t __fxstate_size(int nregs)",
          "3948: {",
          "3949:  return offsetof(struct fxregs_state, xmm_space[0]) + nregs * 16;",
          "3950: }",
          "3952: static inline size_t fxstate_size(struct x86_emulate_ctxt *ctxt)",
          "3953: {",
          "3954:  bool cr4_osfxsr;",
          "3955:  if (ctxt->mode == X86EMUL_MODE_PROT64)",
          "3956:   return __fxstate_size(16);",
          "3958:  cr4_osfxsr = ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR;",
          "3959:  return __fxstate_size(cr4_osfxsr ? 8 : 0);",
          "3960: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3961: static int em_fxsave(struct x86_emulate_ctxt *ctxt)",
          "3962: {",
          "3963:  struct fxregs_state fx_state;",
          "3965:  int rc;",
          "3967:  rc = check_fxsr(ctxt);",
          "",
          "[Removed Lines]",
          "3964:  size_t size;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3977:  if (rc != X86EMUL_CONTINUE)",
          "3978:   return rc;",
          "4016: }",
          "4018: static int em_fxrstor(struct x86_emulate_ctxt *ctxt)",
          "4019: {",
          "4020:  struct fxregs_state fx_state;",
          "4021:  int rc;",
          "4023:  rc = check_fxsr(ctxt);",
          "4024:  if (rc != X86EMUL_CONTINUE)",
          "4025:   return rc;",
          "4039:  if (rc == X86EMUL_CONTINUE)",
          "4040:   rc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));",
          "4042:  ctxt->ops->put_fpu(ctxt);",
          "4044:  return rc;",
          "",
          "[Removed Lines]",
          "3980:  if (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)",
          "3981:   size = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);",
          "3982:  else",
          "3983:   size = offsetof(struct fxregs_state, xmm_space[0]);",
          "3985:  return segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);",
          "3986: }",
          "3988: static int fxrstor_fixup(struct x86_emulate_ctxt *ctxt,",
          "3989:   struct fxregs_state *new)",
          "3990: {",
          "3991:  int rc = X86EMUL_CONTINUE;",
          "3992:  struct fxregs_state old;",
          "3994:  rc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(old));",
          "3995:  if (rc != X86EMUL_CONTINUE)",
          "3996:   return rc;",
          "4003: #ifdef CONFIG_X86_64",
          "4005:  memcpy(&new->xmm_space[8 * 16/4], &old.xmm_space[8 * 16/4], 8 * 16);",
          "4006: #endif",
          "4012:  if (!(ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))",
          "4013:   memcpy(new->xmm_space, old.xmm_space, 8 * 16);",
          "4015:  return rc;",
          "4027:  rc = segmented_read_std(ctxt, ctxt->memop.addr.mem, &fx_state, 512);",
          "4028:  if (rc != X86EMUL_CONTINUE)",
          "4029:   return rc;",
          "4031:  if (fx_state.mxcsr >> 16)",
          "4032:   return emulate_gp(ctxt, 0);",
          "4034:  ctxt->ops->get_fpu(ctxt);",
          "4036:  if (ctxt->mode < X86EMUL_MODE_PROT64)",
          "4037:   rc = fxrstor_fixup(ctxt, &fx_state);",
          "",
          "[Added Lines]",
          "3998:  return segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state,",
          "3999:                      fxstate_size(ctxt));",
          "4006:  size_t size;",
          "4012:  ctxt->ops->get_fpu(ctxt);",
          "4014:  size = fxstate_size(ctxt);",
          "4015:  if (size < __fxstate_size(16)) {",
          "4016:   rc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));",
          "4017:   if (rc != X86EMUL_CONTINUE)",
          "4018:    goto out;",
          "4019:  }",
          "4021:  rc = segmented_read_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);",
          "4022:  if (rc != X86EMUL_CONTINUE)",
          "4023:   goto out;",
          "4025:  if (fx_state.mxcsr >> 16) {",
          "4026:   rc = emulate_gp(ctxt, 0);",
          "4027:   goto out;",
          "4028:  }",
          "4033: out:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "283c95d0e3891b64087706b344a4b545d04a6e62",
      "candidate_info": {
        "commit_hash": "283c95d0e3891b64087706b344a4b545d04a6e62",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/283c95d0e3891b64087706b344a4b545d04a6e62",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: emulate FXSAVE and FXRSTOR\n\nInternal errors were reported on 16 bit fxsave and fxrstor with ipxe.\nOld Intels don't have unrestricted_guest, so we have to emulate them.\n\nThe patch takes advantage of the hardware implementation.\n\nAMD and Intel differ in saving and restoring other fields in first 32\nbytes.  A test wrote 0xff to the fxsave area, 0 to upper bits of MCSXR\nin the fxsave area, executed fxrstor, rewrote the fxsave area to 0xee,\nand executed fxsave:\n\n  Intel (Nehalem):\n    7f 1f 7f 7f ff 00 ff 07 ff ff ff ff ff ff 00 00\n    ff ff ff ff ff ff 00 00 ff ff 00 00 ff ff 00 00\n  Intel (Haswell -- deprecated FPU CS and FPU DS):\n    7f 1f 7f 7f ff 00 ff 07 ff ff ff ff 00 00 00 00\n    ff ff ff ff 00 00 00 00 ff ff 00 00 ff ff 00 00\n  AMD (Opteron 2300-series):\n    7f 1f 7f 7f ff 00 ee ee ee ee ee ee ee ee ee ee\n    ee ee ee ee ee ee ee ee ff ff 00 00 ff ff 02 00\n\nfxsave/fxrstor will only be emulated on early Intels, so KVM can't do\nmuch to improve the situation.\n\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3883:  return X86EMUL_CONTINUE;",
          "3884: }",
          "3886: static bool valid_cr(int nr)",
          "3887: {",
          "3888:  switch (nr) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3886: static int check_fxsr(struct x86_emulate_ctxt *ctxt)",
          "3887: {",
          "3888:  u32 eax = 1, ebx, ecx = 0, edx;",
          "3890:  ctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx);",
          "3891:  if (!(edx & FFL(FXSR)))",
          "3892:   return emulate_ud(ctxt);",
          "3894:  if (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))",
          "3895:   return emulate_nm(ctxt);",
          "3901:  if (ctxt->mode >= X86EMUL_MODE_PROT64)",
          "3902:   return X86EMUL_UNHANDLEABLE;",
          "3904:  return X86EMUL_CONTINUE;",
          "3905: }",
          "3925: static int em_fxsave(struct x86_emulate_ctxt *ctxt)",
          "3926: {",
          "3927:  struct fxregs_state fx_state;",
          "3928:  size_t size;",
          "3929:  int rc;",
          "3931:  rc = check_fxsr(ctxt);",
          "3932:  if (rc != X86EMUL_CONTINUE)",
          "3933:   return rc;",
          "3935:  ctxt->ops->get_fpu(ctxt);",
          "3937:  rc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));",
          "3939:  ctxt->ops->put_fpu(ctxt);",
          "3941:  if (rc != X86EMUL_CONTINUE)",
          "3942:   return rc;",
          "3944:  if (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)",
          "3945:   size = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);",
          "3946:  else",
          "3947:   size = offsetof(struct fxregs_state, xmm_space[0]);",
          "3949:  return segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);",
          "3950: }",
          "3952: static int fxrstor_fixup(struct x86_emulate_ctxt *ctxt,",
          "3953:   struct fxregs_state *new)",
          "3954: {",
          "3955:  int rc = X86EMUL_CONTINUE;",
          "3956:  struct fxregs_state old;",
          "3958:  rc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(old));",
          "3959:  if (rc != X86EMUL_CONTINUE)",
          "3960:   return rc;",
          "3967: #ifdef CONFIG_X86_64",
          "3969:  memcpy(&new->xmm_space[8 * 16/4], &old.xmm_space[8 * 16/4], 8 * 16);",
          "3970: #endif",
          "3976:  if (!(ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))",
          "3977:   memcpy(new->xmm_space, old.xmm_space, 8 * 16);",
          "3979:  return rc;",
          "3980: }",
          "3982: static int em_fxrstor(struct x86_emulate_ctxt *ctxt)",
          "3983: {",
          "3984:  struct fxregs_state fx_state;",
          "3985:  int rc;",
          "3987:  rc = check_fxsr(ctxt);",
          "3988:  if (rc != X86EMUL_CONTINUE)",
          "3989:   return rc;",
          "3991:  rc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);",
          "3992:  if (rc != X86EMUL_CONTINUE)",
          "3993:   return rc;",
          "3995:  if (fx_state.mxcsr >> 16)",
          "3996:   return emulate_gp(ctxt, 0);",
          "3998:  ctxt->ops->get_fpu(ctxt);",
          "4000:  if (ctxt->mode < X86EMUL_MODE_PROT64)",
          "4001:   rc = fxrstor_fixup(ctxt, &fx_state);",
          "4003:  if (rc == X86EMUL_CONTINUE)",
          "4004:   rc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));",
          "4006:  ctxt->ops->put_fpu(ctxt);",
          "4008:  return rc;",
          "4009: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4235: };",
          "4237: static const struct group_dual group15 = { {",
          "4239: }, {",
          "4240:  N, N, N, N, N, N, N, N,",
          "4241: } };",
          "",
          "[Removed Lines]",
          "4238:  N, N, N, N, N, N, N, GP(0, &pfx_0f_ae_7),",
          "",
          "[Added Lines]",
          "4363:  I(ModRM | Aligned16, em_fxsave),",
          "4364:  I(ModRM | Aligned16, em_fxrstor),",
          "4365:  N, N, N, N, N, GP(0, &pfx_0f_ae_7),",
          "",
          "---------------"
        ]
      }
    }
  ]
}
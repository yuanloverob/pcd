{
  "cve_id": "CVE-2013-7020",
  "cve_desc": "The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not properly enforce certain bit-count and colorspace constraints, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f",
  "patch_info": {
    "commit_hash": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b05cd1ea7e45a836f7f6071a716c38bb30326e0f",
    "files": [
      "libavcodec/ffv1dec.c"
    ],
    "message": "ffv1dec: Check bits_per_raw_sample and colorspace for equality in ver 0/1 headers\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
      "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "580:     memset(state, 128, sizeof(state));",
      "582:     if (f->version < 2) {",
      "584:         unsigned v= get_symbol(c, state, 0);",
      "585:         if (v >= 2) {",
      "586:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
      "",
      "[Removed Lines]",
      "583:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;",
      "",
      "[Added Lines]",
      "583:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "593:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
      "594:         }",
      "601:         chroma_planes  = get_rac(c, state);",
      "602:         chroma_h_shift = get_symbol(c, state, 0);",
      "603:         chroma_v_shift = get_symbol(c, state, 0);",
      "604:         transparency   = get_rac(c, state);",
      "606:         if (f->plane_count) {",
      "608:                 || chroma_h_shift!= f->chroma_h_shift",
      "609:                 || chroma_v_shift!= f->chroma_v_shift",
      "610:                 || transparency  != f->transparency) {",
      "",
      "[Removed Lines]",
      "596:         f->colorspace = get_symbol(c, state, 0); //YUV cs type",
      "598:         if (f->version > 0)",
      "599:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
      "607:             if (   chroma_planes != f->chroma_planes",
      "",
      "[Added Lines]",
      "596:         colorspace     = get_symbol(c, state, 0); //YUV cs type",
      "597:         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;",
      "604:             if (   colorspace    != f->colorspace",
      "605:                 || bits_per_raw_sample != f->avctx->bits_per_raw_sample",
      "606:                 || chroma_planes != f->chroma_planes",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "613:             }",
      "614:         }",
      "616:         f->chroma_planes  = chroma_planes;",
      "617:         f->chroma_h_shift = chroma_h_shift;",
      "618:         f->chroma_v_shift = chroma_v_shift;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "615:         f->colorspace     = colorspace;",
      "616:         f->avctx->bits_per_raw_sample = bits_per_raw_sample;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0f13cd3187192ba0cc2b043430de6e279e7b97c3",
      "candidate_info": {
        "commit_hash": "0f13cd3187192ba0cc2b043430de6e279e7b97c3",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/0f13cd3187192ba0cc2b043430de6e279e7b97c3",
        "files": [
          "libavcodec/ffv1.c",
          "libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c"
        ],
        "message": "ffv1: update to ffv1 version 3\n\nBased on code from Carl Eugen Hoyos, Michael Niedermayer and Paul B Mahol.",
        "before_after_code_files": [
          "libavcodec/ffv1.c||libavcodec/ffv1.c",
          "libavcodec/ffv1.h||libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1.c||libavcodec/ffv1.c": [
          "File: libavcodec/ffv1.c -> libavcodec/ffv1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:     s->avctx = avctx;",
          "139:     s->flags = avctx->flags;",
          "141:     ff_dsputil_init(&s->dsp, avctx);",
          "143:     s->width  = avctx->width;",
          "144:     s->height = avctx->height;",
          "148:     s->num_h_slices = 1;",
          "149:     s->num_v_slices = 1;",
          "",
          "[Removed Lines]",
          "146:     assert(s->width && s->height);",
          "",
          "[Added Lines]",
          "141:     if (!avctx->width || !avctx->height)",
          "142:         return AVERROR_INVALIDDATA;",
          "144:     avcodec_get_frame_defaults(&s->picture);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:     return 0;",
          "152: }",
          "155: {",
          "175:         }",
          "183:         }",
          "184:     }",
          "",
          "[Removed Lines]",
          "154: int ffv1_init_slice_state(FFV1Context *f)",
          "156:     int i, j;",
          "158:     for (i = 0; i < f->slice_count; i++) {",
          "159:         FFV1Context *fs = f->slice_context[i];",
          "160:         for (j = 0; j < f->plane_count; j++) {",
          "161:             PlaneContext *const p = &fs->plane[j];",
          "163:             if (fs->ac) {",
          "164:                 if (!p->state)",
          "165:                     p->state = av_malloc(CONTEXT_SIZE * p->context_count *",
          "166:                                          sizeof(uint8_t));",
          "167:                 if (!p->state)",
          "168:                     return AVERROR(ENOMEM);",
          "169:             } else {",
          "170:                 if (!p->vlc_state)",
          "171:                     p->vlc_state = av_malloc(p->context_count * sizeof(VlcState));",
          "172:                 if (!p->vlc_state)",
          "173:                     return AVERROR(ENOMEM);",
          "174:             }",
          "177:         if (fs->ac > 1) {",
          "179:             for (j = 1; j < 256; j++) {",
          "180:                 fs->c.one_state[j]        = fs->state_transition[j];",
          "181:                 fs->c.zero_state[256 - j] = 256 - fs->c.one_state[j];",
          "182:             }",
          "",
          "[Added Lines]",
          "158: int ffv1_init_slice_state(FFV1Context *f, FFV1Context *fs)",
          "160:     int j;",
          "162:     fs->plane_count  = f->plane_count;",
          "163:     fs->transparency = f->transparency;",
          "164:     for (j = 0; j < f->plane_count; j++) {",
          "165:         PlaneContext *const p = &fs->plane[j];",
          "167:         if (fs->ac) {",
          "168:             if (!p->state)",
          "169:                 p->state = av_malloc(CONTEXT_SIZE * p->context_count *",
          "170:                                      sizeof(uint8_t));",
          "171:             if (!p->state)",
          "172:                 return AVERROR(ENOMEM);",
          "173:         } else {",
          "174:             if (!p->vlc_state)",
          "175:                 p->vlc_state = av_malloc(p->context_count * sizeof(VlcState));",
          "176:             if (!p->vlc_state)",
          "177:                 return AVERROR(ENOMEM);",
          "179:     }",
          "181:     if (fs->ac > 1) {",
          "183:         for (j = 1; j < 256; j++) {",
          "184:             fs->c.one_state[j]        = f->state_transition[j];",
          "185:             fs->c.zero_state[256 - j] = 256 - fs->c.one_state[j];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "209:         fs->slice_x      = sxs;",
          "210:         fs->slice_y      = sys;",
          "213:                                       sizeof(*fs->sample_buffer));",
          "214:         if (!fs->sample_buffer)",
          "215:             return AVERROR(ENOMEM);",
          "",
          "[Removed Lines]",
          "212:         fs->sample_buffer = av_malloc(9 * (fs->width + 6) *",
          "",
          "[Added Lines]",
          "215:         fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "232:     return 0;",
          "233: }",
          "236: {",
          "260:             }",
          "261:         }",
          "262:     }",
          "",
          "[Removed Lines]",
          "235: void ffv1_clear_state(FFV1Context *f)",
          "237:     int i, si, j;",
          "239:     for (si = 0; si < f->slice_count; si++) {",
          "240:         FFV1Context *fs = f->slice_context[si];",
          "241:         for (i = 0; i < f->plane_count; i++) {",
          "242:             PlaneContext *p = &fs->plane[i];",
          "244:             p->interlace_bit_state[0] = 128;",
          "245:             p->interlace_bit_state[1] = 128;",
          "247:             if (fs->ac) {",
          "248:                 if (f->initial_states[p->quant_table_index]) {",
          "249:                     memcpy(p->state, f->initial_states[p->quant_table_index],",
          "250:                            CONTEXT_SIZE * p->context_count);",
          "251:                 } else",
          "252:                     memset(p->state, 128, CONTEXT_SIZE * p->context_count);",
          "253:             } else {",
          "254:                 for (j = 0; j < p->context_count; j++) {",
          "255:                     p->vlc_state[j].drift     = 0;",
          "256:                     p->vlc_state[j].error_sum = 4; // FFMAX((RANGE + 32)/64, 2);",
          "257:                     p->vlc_state[j].bias      = 0;",
          "258:                     p->vlc_state[j].count     = 1;",
          "259:                 }",
          "",
          "[Added Lines]",
          "238: void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs)",
          "240:     int i, j;",
          "242:     for (i = 0; i < f->plane_count; i++) {",
          "243:         PlaneContext *p = &fs->plane[i];",
          "245:         p->interlace_bit_state[0] = 128;",
          "246:         p->interlace_bit_state[1] = 128;",
          "248:         if (fs->ac) {",
          "249:             if (f->initial_states[p->quant_table_index]) {",
          "250:                 memcpy(p->state, f->initial_states[p->quant_table_index],",
          "251:                        CONTEXT_SIZE * p->context_count);",
          "252:             } else",
          "253:                 memset(p->state, 128, CONTEXT_SIZE * p->context_count);",
          "254:         } else {",
          "255:             for (j = 0; j < p->context_count; j++) {",
          "256:                 p->vlc_state[j].drift     = 0;",
          "257:                 p->vlc_state[j].error_sum = 4;    //FFMAX((RANGE + 32)/64, 2);",
          "258:                 p->vlc_state[j].bias      = 0;",
          "259:                 p->vlc_state[j].count     = 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "270:     if (avctx->codec->decode && s->picture.data[0])",
          "271:         avctx->release_buffer(avctx, &s->picture);",
          "273:     for (j = 0; j < s->slice_count; j++) {",
          "274:         FFV1Context *fs = s->slice_context[j];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:     if (avctx->codec->decode && s->last_picture.data[0])",
          "273:         avctx->release_buffer(avctx, &s->last_picture);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1.h||libavcodec/ffv1.h": [
          "File: libavcodec/ffv1.h -> libavcodec/ffv1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #define MAX_SLICES 256",
          "59: typedef struct FFV1Context {",
          "60:     AVCodecContext *avctx;",
          "61:     RangeCoder c;",
          "62:     GetBitContext gb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60:     AVClass *class;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:     uint64_t rc_stat[256][2];",
          "65:     uint64_t (*rc_stat2[MAX_QUANT_TABLES])[32][2];",
          "66:     int version;",
          "67:     int width, height;",
          "68:     int chroma_h_shift, chroma_v_shift;",
          "69:     int flags;",
          "70:     int picture_number;",
          "72:     int plane_count;",
          "73:     int ac;     // 1 = range coder <-> 0 = golomb rice",
          "74:     PlaneContext plane[MAX_PLANES];",
          "75:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "76:     int16_t quant_tables[MAX_QUANT_TABLES][MAX_CONTEXT_INPUTS][256];",
          "",
          "[Removed Lines]",
          "71:     AVFrame picture;",
          "",
          "[Added Lines]",
          "68:     int minor_version;",
          "70:     int chroma_planes;",
          "72:     int transparency;",
          "75:     AVFrame picture, last_picture;",
          "78:     int ac_byte_count;      // number of bytes used for AC coding",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:     int run_index;",
          "81:     int colorspace;",
          "82:     int16_t *sample_buffer;",
          "85:     int quant_table_count;",
          "87:     DSPContext dsp;",
          "",
          "[Removed Lines]",
          "83:     int gob_count;",
          "",
          "[Added Lines]",
          "89:     int ec;",
          "90:     int slice_damaged;",
          "91:     int key_frame_ok;",
          "93:     int bits_per_raw_sample;",
          "94:     int packed_at_lsb;",
          "96:     int gob_count;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "175: }",
          "177: int ffv1_common_init(AVCodecContext *avctx);",
          "179: int ffv1_init_slice_contexts(FFV1Context *f);",
          "180: int ffv1_allocate_initial_states(FFV1Context *f);",
          "182: int ffv1_close(AVCodecContext *avctx);",
          "",
          "[Removed Lines]",
          "178: int ffv1_init_slice_state(FFV1Context *f);",
          "181: void ffv1_clear_state(FFV1Context *f);",
          "",
          "[Added Lines]",
          "190: int ffv1_init_slice_state(FFV1Context *f, FFV1Context *fs);",
          "193: void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"avcodec.h\"",
          "30: #include \"get_bits.h\"",
          "31: #include \"put_bits.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"libavutil/pixdesc.h\"",
          "30: #include \"libavutil/crc.h\"",
          "31: #include \"libavutil/opt.h\"",
          "32: #include \"libavutil/imgutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:         } else {",
          "193:             decode_line(s, w, sample, plane_index,",
          "194:                         s->avctx->bits_per_raw_sample);",
          "198:         }",
          "200:     }",
          "201: }",
          "205: {",
          "206:     int x, y, p;",
          "209:         sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;",
          "210:         sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;",
          "211:     }",
          "213:     s->run_index = 0;",
          "217:     for (y = 0; y < h; y++) {",
          "221:             sample[p][0] = sample[p][1];",
          "222:             sample[p][1] = temp;",
          "224:             sample[p][1][-1] = sample[p][0][0];",
          "225:             sample[p][0][w]  = sample[p][0][w - 1];",
          "227:         }",
          "228:         for (x = 0; x < w; x++) {",
          "229:             int g = sample[0][1][x];",
          "230:             int b = sample[1][1][x];",
          "231:             int r = sample[2][1][x];",
          "238:             g -= (b + r) >> 2;",
          "239:             b += g;",
          "240:             r += g;",
          "243:         }",
          "244:     }",
          "245: }",
          "247: static int decode_slice(AVCodecContext *c, void *arg)",
          "248: {",
          "255:     AVFrame *const p = &f->picture;",
          "257:     av_assert1(width && height);",
          "258:     if (f->colorspace == 0) {",
          "260:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "261:         const int cx            = x >> f->chroma_h_shift;",
          "262:         const int cy            = y >> f->chroma_v_shift;",
          "271:     } else {",
          "275:     }",
          "277:     emms_c();",
          "",
          "[Removed Lines]",
          "195:             for (x = 0; x < w; x++)",
          "196:                 ((uint16_t *)(src + stride * y))[x] =",
          "197:                     sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "203: static void decode_rgb_frame(FFV1Context *s, uint32_t *src,",
          "204:                              int w, int h, int stride)",
          "207:     int16_t *sample[3][2];",
          "208:     for (x = 0; x < 3; x++) {",
          "215:     memset(s->sample_buffer, 0, 6 * (w + 6) * sizeof(*s->sample_buffer));",
          "218:         for (p = 0; p < 3; p++) {",
          "219:             int16_t *temp = sample[p][0]; // FIXME: try a normal buffer",
          "226:             decode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "236:             b -= 0x100;",
          "237:             r -= 0x100;",
          "242:             src[x + stride * y] = b + (g << 8) + (r << 16) + (0xFF << 24);",
          "249:     FFV1Context *fs  = *(void **)arg;",
          "250:     FFV1Context *f   = fs->avctx->priv_data;",
          "251:     int width        = fs->slice_width;",
          "252:     int height       = fs->slice_height;",
          "253:     int x            = fs->slice_x;",
          "254:     int y            = fs->slice_y;",
          "259:         const int chroma_width  = -((-width)  >> f->chroma_h_shift);",
          "264:         decode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "265:                      width, height, p->linesize[0], 0);",
          "267:         decode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "268:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "269:         decode_plane(fs, p->data[2] + cx + cy * p->linesize[1],",
          "270:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "272:         decode_rgb_frame(fs,",
          "273:                          (uint32_t *)p->data[0] + x + y * (p->linesize[0] / 4),",
          "274:                          width, height, p->linesize[0] / 4);",
          "",
          "[Added Lines]",
          "199:             if (s->packed_at_lsb) {",
          "200:                 for (x = 0; x < w; x++)",
          "201:                     ((uint16_t *)(src + stride * y))[x] = sample[1][x];",
          "202:             } else {",
          "203:                 for (x = 0; x < w; x++)",
          "204:                     ((uint16_t *)(src + stride * y))[x] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "205:             }",
          "211: static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h,",
          "212:                              int stride[3])",
          "215:     int16_t *sample[4][2];",
          "216:     int lbd  = s->avctx->bits_per_raw_sample <= 8;",
          "217:     int bits = s->avctx->bits_per_raw_sample > 0",
          "218:                ? s->avctx->bits_per_raw_sample",
          "219:                : 8;",
          "220:     int offset = 1 << bits;",
          "222:     for (x = 0; x < 4; x++) {",
          "229:     memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));",
          "232:         for (p = 0; p < 3 + s->transparency; p++) {",
          "233:             int16_t *temp = sample[p][0]; //FIXME try a normal buffer",
          "240:             if (lbd)",
          "241:                 decode_line(s, w, sample[p], (p + 1) / 2, 9);",
          "242:             else",
          "243:                 decode_line(s, w, sample[p], (p + 1) / 2, bits + 1);",
          "249:             int a = sample[3][1][x];",
          "251:             b -= offset;",
          "252:             r -= offset;",
          "257:             if (lbd)",
          "259:                     (g << 8) + (r << 16) + (a << 24);",
          "260:             else {",
          "264:             }",
          "269: static int decode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "270: {",
          "271:     RangeCoder *c = &fs->c;",
          "272:     uint8_t state[CONTEXT_SIZE];",
          "273:     unsigned ps, i, context_count;",
          "274:     memset(state, 128, sizeof(state));",
          "276:     av_assert0(f->version > 2);",
          "278:     fs->slice_x      = get_symbol(c, state, 0) * f->width;",
          "279:     fs->slice_y      = get_symbol(c, state, 0) * f->height;",
          "280:     fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;",
          "281:     fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "283:     fs->slice_x     /= f->num_h_slices;",
          "284:     fs->slice_y     /= f->num_v_slices;",
          "285:     fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;",
          "286:     fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "287:     if ((unsigned)fs->slice_width  > f->width ||",
          "288:         (unsigned)fs->slice_height > f->height)",
          "289:         return AVERROR_INVALIDDATA;",
          "290:     if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "291:         (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "292:         return AVERROR_INVALIDDATA;",
          "294:     for (i = 0; i < f->plane_count; i++) {",
          "295:         PlaneContext *const p = &fs->plane[i];",
          "296:         int idx               = get_symbol(c, state, 0);",
          "297:         if (idx > (unsigned)f->quant_table_count) {",
          "298:             av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");",
          "299:             return AVERROR_INVALIDDATA;",
          "300:         }",
          "301:         p->quant_table_index = idx;",
          "302:         memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));",
          "303:         context_count = f->context_count[idx];",
          "305:         if (p->context_count < context_count) {",
          "306:             av_freep(&p->state);",
          "307:             av_freep(&p->vlc_state);",
          "308:         }",
          "309:         p->context_count = context_count;",
          "310:     }",
          "312:     ps = get_symbol(c, state, 0);",
          "313:     if (ps == 1) {",
          "314:         f->picture.interlaced_frame = 1;",
          "315:         f->picture.top_field_first  = 1;",
          "316:     } else if (ps == 2) {",
          "317:         f->picture.interlaced_frame = 1;",
          "318:         f->picture.top_field_first  = 0;",
          "319:     } else if (ps == 3) {",
          "320:         f->picture.interlaced_frame = 0;",
          "321:     }",
          "322:     f->picture.sample_aspect_ratio.num = get_symbol(c, state, 0);",
          "323:     f->picture.sample_aspect_ratio.den = get_symbol(c, state, 0);",
          "325:     return 0;",
          "326: }",
          "330:     FFV1Context *fs = *(void **)arg;",
          "331:     FFV1Context *f  = fs->avctx->priv_data;",
          "332:     int width, height, x, y, ret;",
          "333:     const int ps = (av_pix_fmt_desc_get(c->pix_fmt)->flags & PIX_FMT_PLANAR)",
          "334:                    ? (c->bits_per_raw_sample > 8) + 1",
          "335:                    : 4;",
          "338:     if (f->version > 2) {",
          "339:         if (decode_slice_header(f, fs) < 0) {",
          "340:             fs->slice_damaged = 1;",
          "341:             return AVERROR_INVALIDDATA;",
          "342:         }",
          "343:     }",
          "344:     if ((ret = ffv1_init_slice_state(f, fs)) < 0)",
          "345:         return ret;",
          "346:     if (f->picture.key_frame)",
          "347:         ffv1_clear_slice_state(f, fs);",
          "348:     width  = fs->slice_width;",
          "349:     height = fs->slice_height;",
          "350:     x      = fs->slice_x;",
          "351:     y      = fs->slice_y;",
          "353:     if (!fs->ac) {",
          "354:         if (f->version == 3 && f->minor_version > 1 || f->version > 3)",
          "355:             get_rac(&fs->c, (uint8_t[]) { 129 });",
          "356:         fs->ac_byte_count = f->version > 2 || (!x && !y) ? fs->c.bytestream - fs->c.bytestream_start - 1 : 0;",
          "357:         init_get_bits(&fs->gb, fs->c.bytestream_start + fs->ac_byte_count,",
          "358:                       (fs->c.bytestream_end - fs->c.bytestream_start -",
          "359:                        fs->ac_byte_count) * 8);",
          "360:     }",
          "364:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "368:         decode_plane(fs, p->data[0] + ps * x + y * p->linesize[0], width,",
          "369:                      height, p->linesize[0],",
          "370:                      0);",
          "372:         if (f->chroma_planes) {",
          "373:             decode_plane(fs, p->data[1] + ps * cx + cy * p->linesize[1],",
          "374:                          chroma_width, chroma_height, p->linesize[1],",
          "375:                          1);",
          "376:             decode_plane(fs, p->data[2] + ps * cx + cy * p->linesize[2],",
          "377:                          chroma_width, chroma_height, p->linesize[2],",
          "378:                          1);",
          "379:         }",
          "380:         if (fs->transparency)",
          "381:             decode_plane(fs, p->data[3] + ps * x + y * p->linesize[3], width,",
          "382:                          height, p->linesize[3],",
          "383:                          2);",
          "385:         uint8_t *planes[3] = { p->data[0] + ps * x + y * p->linesize[0],",
          "386:                                p->data[1] + ps * x + y * p->linesize[1],",
          "387:                                p->data[2] + ps * x + y * p->linesize[2] };",
          "388:         decode_rgb_frame(fs, planes, width, height, p->linesize);",
          "389:     }",
          "390:     if (fs->ac && f->version > 2) {",
          "391:         int v;",
          "392:         get_rac(&fs->c, (uint8_t[]) { 129 });",
          "393:         v = fs->c.bytestream_end - fs->c.bytestream - 2 - 5 * f->ec;",
          "394:         if (v) {",
          "395:             av_log(f->avctx, AV_LOG_ERROR, \"bytestream end mismatching by %d\\n\",",
          "396:                    v);",
          "397:             fs->slice_damaged = 1;",
          "398:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:     memset(state, 128, sizeof(state));",
          "290:     for (v = 0; i < 128; v++) {",
          "296:         while (len--) {",
          "297:             quant_table[i] = scale * v;",
          "",
          "[Removed Lines]",
          "291:         int len = get_symbol(c, state, 0) + 1;",
          "293:         if (len + i > 128)",
          "294:             return AVERROR_INVALIDDATA;",
          "",
          "[Added Lines]",
          "415:         unsigned len = get_symbol(c, state, 0) + 1;",
          "417:         if (len > 128 - i)",
          "418:             return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "315:     for (i = 0; i < 5; i++) {",
          "316:         context_count *= read_quant_table(c, quant_table[i], context_count);",
          "317:         if (context_count > 32768U) {",
          "319:         }",
          "320:     }",
          "321:     return (context_count + 1) / 2;",
          "",
          "[Removed Lines]",
          "318:             return AVERROR_INVALIDDATA;",
          "",
          "[Added Lines]",
          "442:             return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "325: {",
          "326:     RangeCoder *const c = &f->c;",
          "327:     uint8_t state[CONTEXT_SIZE];",
          "329:     uint8_t state2[32][CONTEXT_SIZE];",
          "331:     memset(state2, 128, sizeof(state2));",
          "",
          "[Removed Lines]",
          "328:     int i, j, k;",
          "",
          "[Added Lines]",
          "452:     int i, j, k, ret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "335:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "337:     f->version = get_symbol(c, state, 0);",
          "340:         for (i = 1; i < 256; i++)",
          "341:             f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "343:     f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "352:     if (f->num_h_slices > (unsigned)f->width ||",
          "353:         f->num_v_slices > (unsigned)f->height) {",
          "",
          "[Removed Lines]",
          "338:     f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "339:     if (f->ac > 1)",
          "342:     f->colorspace                 = get_symbol(c, state, 0); // YUV cs type",
          "344:     get_rac(c, state); // no chroma = false",
          "345:     f->chroma_h_shift = get_symbol(c, state, 0);",
          "346:     f->chroma_v_shift = get_symbol(c, state, 0);",
          "347:     get_rac(c, state); // transparency plane",
          "348:     f->plane_count  = 2;",
          "349:     f->num_h_slices = 1 + get_symbol(c, state, 0);",
          "350:     f->num_v_slices = 1 + get_symbol(c, state, 0);",
          "",
          "[Added Lines]",
          "462:     if (f->version > 2) {",
          "463:         c->bytestream_end -= 4;",
          "464:         f->minor_version   = get_symbol(c, state, 0);",
          "465:     }",
          "466:     f->ac = f->avctx->coder_type = get_symbol(c, state, 0);",
          "468:     if (f->ac > 1) {",
          "471:     }",
          "473:     f->colorspace                 = get_symbol(c, state, 0); //YUV cs type",
          "475:     f->chroma_planes              = get_rac(c, state);",
          "476:     f->chroma_h_shift             = get_symbol(c, state, 0);",
          "477:     f->chroma_v_shift             = get_symbol(c, state, 0);",
          "478:     f->transparency               = get_rac(c, state);",
          "479:     f->plane_count                = 2 + f->transparency;",
          "480:     f->num_h_slices               = 1 + get_symbol(c, state, 0);",
          "481:     f->num_v_slices               = 1 + get_symbol(c, state, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "356:     }",
          "358:     f->quant_table_count = get_symbol(c, state, 0);",
          "360:     if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)",
          "361:         return AVERROR_INVALIDDATA;",
          "363:     for (i = 0; i < f->quant_table_count; i++) {",
          "364:         f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);",
          "365:         if (f->context_count[i] < 0) {",
          "366:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "368:         }",
          "369:     }",
          "374:     for (i = 0; i < f->quant_table_count; i++)",
          "376:             for (j = 0; j < f->context_count[i]; j++)",
          "377:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "378:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "379:                     f->initial_states[i][j][k] =",
          "380:                         (pred + get_symbol(c, state2[k], 1)) & 0xFF;",
          "381:                 }",
          "382:     return 0;",
          "383: }",
          "385: static int read_header(FFV1Context *f)",
          "386: {",
          "387:     uint8_t state[CONTEXT_SIZE];",
          "389:     RangeCoder *const c = &f->slice_context[0]->c;",
          "391:     memset(state, 128, sizeof(state));",
          "393:     if (f->version < 2) {",
          "397:             for (i = 1; i < 256; i++)",
          "400:         if (f->version > 0)",
          "401:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "403:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "404:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "407:     }",
          "409:     if (f->colorspace == 0) {",
          "411:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "412:             case 0x00:",
          "413:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "414:                 break;",
          "415:             case 0x10:",
          "416:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "417:                 break;",
          "",
          "[Removed Lines]",
          "367:             return f->context_count[i];",
          "371:     if (ffv1_allocate_initial_states(f) < 0)",
          "372:         return AVERROR(ENOMEM);",
          "375:         if (get_rac(c, state))",
          "388:     int i, j, context_count;",
          "394:         f->version = get_symbol(c, state, 0);",
          "395:         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "396:         if (f->ac > 1)",
          "398:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "399:         f->colorspace = get_symbol(c, state, 0); // YUV cs type",
          "402:         get_rac(c, state); // no chroma = false",
          "405:         get_rac(c, state); // transparency plane",
          "406:         f->plane_count = 2;",
          "410:         if (f->avctx->bits_per_raw_sample <= 8) {",
          "",
          "[Added Lines]",
          "496:             return AVERROR_INVALIDDATA;",
          "499:     if ((ret = ffv1_allocate_initial_states(f)) < 0)",
          "500:         return ret;",
          "503:         if (get_rac(c, state)) {",
          "510:         }",
          "512:     if (f->version > 2) {",
          "513:         f->ec = get_symbol(c, state, 0);",
          "514:     }",
          "516:     if (f->version > 2) {",
          "517:         unsigned v;",
          "518:         v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0,",
          "519:                    f->avctx->extradata, f->avctx->extradata_size);",
          "520:         if (v) {",
          "521:             av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", v);",
          "522:             return AVERROR_INVALIDDATA;",
          "523:         }",
          "524:     }",
          "533:     int i, j, context_count = -1;",
          "539:         unsigned v = get_symbol(c, state, 0);",
          "540:         if (v > 1) {",
          "541:             av_log(f->avctx, AV_LOG_ERROR,",
          "542:                    \"invalid version %d in version 1 header\\n\", v);",
          "543:             return AVERROR_INVALIDDATA;",
          "544:         }",
          "545:         f->version = v;",
          "547:         f->ac = f->avctx->coder_type = get_symbol(c, state, 0);",
          "549:         if (f->ac > 1) {",
          "551:                 f->state_transition[i] =",
          "552:                     get_symbol(c, state, 1) + c->one_state[i];",
          "553:         }",
          "555:         f->colorspace = get_symbol(c, state, 0); //YUV cs type",
          "560:         f->chroma_planes  = get_rac(c, state);",
          "563:         f->transparency   = get_rac(c, state);",
          "564:         f->plane_count    = 2 + f->transparency;",
          "568:         if (!f->transparency && !f->chroma_planes) {",
          "569:             if (f->avctx->bits_per_raw_sample <= 8)",
          "570:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;",
          "571:             else",
          "572:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;",
          "573:         } else if (f->avctx->bits_per_raw_sample <= 8 && !f->transparency) {",
          "578:             case 0x01:",
          "579:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV440P;",
          "580:                 break;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "428:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "429:                 return AVERROR(ENOSYS);",
          "430:             }",
          "431:         } else {",
          "432:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "433:             case 0x00:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {",
          "598:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "599:             case 0x00:",
          "600:                 f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P;",
          "601:                 break;",
          "602:             case 0x10:",
          "603:                 f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P;",
          "604:                 break;",
          "605:             case 0x11:",
          "606:                 f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;",
          "607:                 break;",
          "608:             default:",
          "609:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "610:                 return AVERROR(ENOSYS);",
          "611:             }",
          "612:         } else if (f->avctx->bits_per_raw_sample == 9) {",
          "613:             f->packed_at_lsb = 1;",
          "614:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "615:             case 0x00:",
          "616:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9;",
          "617:                 break;",
          "618:             case 0x10:",
          "619:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9;",
          "620:                 break;",
          "621:             case 0x11:",
          "622:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9;",
          "623:                 break;",
          "624:             default:",
          "625:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "626:                 return AVERROR(ENOSYS);",
          "627:             }",
          "628:         } else if (f->avctx->bits_per_raw_sample == 10) {",
          "629:             f->packed_at_lsb = 1;",
          "630:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "631:             case 0x00:",
          "632:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10;",
          "633:                 break;",
          "634:             case 0x10:",
          "635:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;",
          "636:                 break;",
          "637:             case 0x11:",
          "638:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10;",
          "639:                 break;",
          "640:             default:",
          "641:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "642:                 return AVERROR(ENOSYS);",
          "643:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "450:                    \"chroma subsampling not supported in this colorspace\\n\");",
          "451:             return AVERROR(ENOSYS);",
          "452:         }",
          "454:     } else {",
          "455:         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");",
          "456:         return AVERROR(ENOSYS);",
          "",
          "[Removed Lines]",
          "453:         f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "",
          "[Added Lines]",
          "666:         switch (f->avctx->bits_per_raw_sample) {",
          "667:         case 8:",
          "668:             f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "669:             break;",
          "670:         case 9:",
          "671:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;",
          "672:             break;",
          "673:         case 10:",
          "674:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
          "675:             break;",
          "676:         default:",
          "677:             av_log(f->avctx, AV_LOG_ERROR,",
          "678:                    \"bit depth %d not supported\\n\",",
          "679:                    f->avctx->bits_per_raw_sample);",
          "680:             return AVERROR(ENOSYS);",
          "681:         }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "459:     av_dlog(f->avctx, \"%d %d %d\\n\",",
          "460:             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);",
          "462:     if (f->version < 2) {",
          "463:         context_count = read_quant_tables(c, f->quant_table);",
          "464:         if (context_count < 0) {",
          "465:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "467:         }",
          "469:         f->slice_count = get_symbol(c, state, 0);",
          "472:     }",
          "474:     for (j = 0; j < f->slice_count; j++) {",
          "475:         FFV1Context *fs = f->slice_context[j];",
          "489:                 (unsigned)fs->slice_height > f->height)",
          "490:                 return AVERROR_INVALIDDATA;",
          "493:                 return AVERROR_INVALIDDATA;",
          "494:         }",
          "496:         for (i = 0; i < f->plane_count; i++) {",
          "497:             PlaneContext *const p = &fs->plane[i];",
          "500:                 int idx = get_symbol(c, state, 0);",
          "501:                 if (idx > (unsigned)f->quant_table_count) {",
          "502:                     av_log(f->avctx, AV_LOG_ERROR,",
          "",
          "[Removed Lines]",
          "466:             return context_count;",
          "468:     } else {",
          "470:         if (f->slice_count > (unsigned)MAX_SLICES)",
          "471:             return AVERROR_INVALIDDATA;",
          "476:         fs->ac = f->ac;",
          "478:         if (f->version >= 2) {",
          "479:             fs->slice_x      = get_symbol(c, state, 0) * f->width;",
          "480:             fs->slice_y      = get_symbol(c, state, 0) * f->height;",
          "481:             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "482:             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "484:             fs->slice_x     /= f->num_h_slices;",
          "485:             fs->slice_y     /= f->num_v_slices;",
          "486:             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;",
          "487:             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "488:             if ((unsigned)fs->slice_width  > f->width ||",
          "491:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "492:                 (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "499:             if (f->version >= 2) {",
          "",
          "[Added Lines]",
          "693:             return AVERROR_INVALIDDATA;",
          "695:     } else if (f->version < 3) {",
          "697:     } else {",
          "698:         const uint8_t *p = c->bytestream_end;",
          "699:         for (f->slice_count = 0;",
          "700:              f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;",
          "701:              f->slice_count++) {",
          "702:             int trailer = 3 + 5 * !!f->ec;",
          "703:             int size    = AV_RB24(p - trailer);",
          "704:             if (size + trailer > p - c->bytestream_start)",
          "705:                 break;",
          "706:             p -= size + trailer;",
          "707:         }",
          "708:     }",
          "709:     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {",
          "710:         av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\",",
          "711:                f->slice_count);",
          "712:         return AVERROR_INVALIDDATA;",
          "717:         fs->ac            = f->ac;",
          "718:         fs->packed_at_lsb = f->packed_at_lsb;",
          "720:         fs->slice_damaged = 0;",
          "722:         if (f->version == 2) {",
          "723:             fs->slice_x     = get_symbol(c, state, 0) * f->width;",
          "724:             fs->slice_y     = get_symbol(c, state, 0) * f->height;",
          "725:             fs->slice_width =",
          "726:                 (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;",
          "727:             fs->slice_height =",
          "728:                 (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "730:             fs->slice_x      /= f->num_h_slices;",
          "731:             fs->slice_y      /= f->num_v_slices;",
          "732:             fs->slice_width  /= f->num_h_slices - fs->slice_x;",
          "733:             fs->slice_height /= f->num_v_slices - fs->slice_y;",
          "734:             if ((unsigned)fs->slice_width > f->width ||",
          "737:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width > f->width",
          "738:                 || (unsigned)fs->slice_y + (uint64_t)fs->slice_height >",
          "739:                 f->height)",
          "746:             if (f->version == 2) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "511:                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));",
          "512:             }",
          "517:             }",
          "519:         }",
          "520:     }",
          "522:     return 0;",
          "523: }",
          "",
          "[Removed Lines]",
          "514:             if (p->context_count < context_count) {",
          "515:                 av_freep(&p->state);",
          "516:                 av_freep(&p->vlc_state);",
          "518:             p->context_count = context_count;",
          "",
          "[Added Lines]",
          "761:             if (f->version <= 2) {",
          "762:                 av_assert0(context_count >= 0);",
          "763:                 if (p->context_count < context_count) {",
          "764:                     av_freep(&p->state);",
          "765:                     av_freep(&p->vlc_state);",
          "766:                 }",
          "767:                 p->context_count = context_count;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "546:     FFV1Context *f      = avctx->priv_data;",
          "547:     RangeCoder *const c = &f->slice_context[0]->c;",
          "548:     AVFrame *const p    = &f->picture;",
          "550:     uint8_t keystate = 128;",
          "551:     const uint8_t *buf_p;",
          "",
          "[Removed Lines]",
          "549:     int bytes_read, i, ret;",
          "",
          "[Added Lines]",
          "798:     int i, ret;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "559:     ff_init_range_decoder(c, buf, buf_size);",
          "560:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "563:     if (get_rac(c, &keystate)) {",
          "565:         if ((ret = read_header(f)) < 0)",
          "566:             return ret;",
          "571:     } else {",
          "579:         }",
          "580:     }",
          "583:     if ((ret = avctx->get_buffer(avctx, p)) < 0) {",
          "584:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "585:         return ret;",
          "586:     }",
          "588:     if (avctx->debug & FF_DEBUG_PICT_INFO)",
          "601:     buf_p = buf + buf_size;",
          "603:         FFV1Context *fs = f->slice_context[i];",
          "606:             av_log(avctx, AV_LOG_ERROR, \"Slice pointer chain broken\\n\");",
          "607:             return AVERROR_INVALIDDATA;",
          "608:         }",
          "609:         buf_p -= v;",
          "611:             ff_init_range_decoder(&fs->c, buf_p, v);",
          "614:     }",
          "618:     f->picture_number++;",
          "623:     return buf_size;",
          "624: }",
          "",
          "[Removed Lines]",
          "562:     p->pict_type = AV_PICTURE_TYPE_I; // FIXME: I vs. P",
          "564:         p->key_frame = 1;",
          "567:         if ((ret = ffv1_init_slice_state(f)) < 0)",
          "568:             return ret;",
          "570:         ffv1_clear_state(f);",
          "572:         p->key_frame = 0;",
          "573:     }",
          "574:     if (f->ac > 1) {",
          "575:         int i;",
          "576:         for (i = 1; i < 256; i++) {",
          "577:             c->one_state[i]        = f->state_transition[i];",
          "578:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "582:     p->reference = 0;",
          "589:         av_log(avctx, AV_LOG_ERROR, \"keyframe:%d coder:%d\\n\", p->key_frame, f->ac);",
          "591:     if (!f->ac) {",
          "592:         bytes_read = c->bytestream - c->bytestream_start - 1;",
          "593:         if (bytes_read == 0)",
          "594:             av_log(avctx, AV_LOG_ERROR, \"error at end of AC stream\\n\"); // FIXME",
          "595:         init_get_bits(&f->slice_context[0]->gb, buf + bytes_read,",
          "596:                       (buf_size - bytes_read) * 8);",
          "597:     } else {",
          "599:     }",
          "602:     for (i = f->slice_count - 1; i > 0; i--) {",
          "604:         int v           = AV_RB24(buf_p - 3) + 3;",
          "605:         if (buf_p - buf <= v) {",
          "610:         if (fs->ac)",
          "612:         else",
          "613:             init_get_bits(&fs->gb, buf_p, v * 8);",
          "616:     avctx->execute(avctx, decode_slice, &f->slice_context[0],",
          "617:                    NULL, f->slice_count, sizeof(void *));",
          "",
          "[Added Lines]",
          "811:     p->pict_type = AV_PICTURE_TYPE_I; //FIXME I vs. P",
          "813:         p->key_frame    = 1;",
          "814:         f->key_frame_ok = 0;",
          "817:         f->key_frame_ok = 1;",
          "819:         if (!f->key_frame_ok) {",
          "820:             av_log(avctx, AV_LOG_ERROR,",
          "821:                    \"Cant decode non keyframe without valid keyframe\\n\");",
          "822:             return AVERROR_INVALIDDATA;",
          "824:         p->key_frame = 0;",
          "827:     p->reference = 3; //for error concealment",
          "834:         av_log(avctx, AV_LOG_DEBUG,",
          "835:                \"ver:%d keyframe:%d coder:%d ec:%d slices:%d bps:%d\\n\",",
          "836:                f->version, p->key_frame, f->ac, f->ec, f->slice_count,",
          "837:                f->avctx->bits_per_raw_sample);",
          "840:     for (i = f->slice_count - 1; i >= 0; i--) {",
          "842:         int trailer     = 3 + 5 * !!f->ec;",
          "843:         int v;",
          "845:         if (i || f->version > 2)",
          "846:             v = AV_RB24(buf_p - trailer) + trailer;",
          "847:         else",
          "848:             v = buf_p - c->bytestream_start;",
          "849:         if (buf_p - c->bytestream_start < v) {",
          "855:         if (f->ec) {",
          "856:             unsigned crc = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, v);",
          "857:             if (crc) {",
          "858:                 av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", crc);",
          "859:                 fs->slice_damaged = 1;",
          "860:             }",
          "861:         }",
          "863:         if (i) {",
          "865:         } else",
          "866:             fs->c.bytestream_end = (uint8_t *)(buf_p + v);",
          "867:     }",
          "869:     avctx->execute(avctx, decode_slice, &f->slice_context[0], NULL,",
          "870:                    f->slice_count,",
          "871:                    sizeof(void *));",
          "873:     for (i = f->slice_count - 1; i >= 0; i--) {",
          "874:         FFV1Context *fs = f->slice_context[i];",
          "875:         int j;",
          "876:         if (fs->slice_damaged && f->last_picture.data[0]) {",
          "877:             const uint8_t *src[4];",
          "878:             uint8_t *dst[4];",
          "879:             for (j = 0; j < 4; j++) {",
          "880:                 int sh = (j == 1 || j == 2) ? f->chroma_h_shift : 0;",
          "881:                 int sv = (j == 1 || j == 2) ? f->chroma_v_shift : 0;",
          "882:                 dst[j] = f->picture.data[j] + f->picture.linesize[j] *",
          "883:                          (fs->slice_y >> sv) + (fs->slice_x >> sh);",
          "884:                 src[j] = f->last_picture.data[j] +",
          "885:                          f->last_picture.linesize[j] *",
          "886:                          (fs->slice_y >> sv) + (fs->slice_x >> sh);",
          "887:             }",
          "888:             av_image_copy(dst, f->picture.linesize, (const uint8_t **)src,",
          "889:                           f->last_picture.linesize,",
          "890:                           avctx->pix_fmt, fs->slice_width,",
          "891:                           fs->slice_height);",
          "892:         }",
          "900:     FFSWAP(AVFrame, f->picture, f->last_picture);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c": [
          "File: libavcodec/ffv1enc.c -> libavcodec/ffv1enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"avcodec.h\"",
          "30: #include \"get_bits.h\"",
          "31: #include \"put_bits.h\"",
          "32: #include \"dsputil.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"libavutil/pixdesc.h\"",
          "30: #include \"libavutil/crc.h\"",
          "31: #include \"libavutil/opt.h\"",
          "32: #include \"libavutil/imgutils.h\"",
          "34: #include \"internal.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:             occ[j] = 1.0;",
          "58:             for (k = 0; k < 256; k++) {",
          "59:                 double newocc[256] = { 0 };",
          "61:                     if (occ[m]) {",
          "62:                         len -= occ[m] *     (p  * l2tab[m] +",
          "63:                                         (1 - p) * l2tab[256 - m]);",
          "",
          "[Removed Lines]",
          "60:                 for (m = 0; m < 256; m++)",
          "",
          "[Added Lines]",
          "65:                 for (m = 1; m < 256; m++)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:         i += i;",
          "145:     }",
          "149: #if 0 // JPEG LS",
          "150:     if (k == 0 && 2 * state->drift <= -state->count)",
          "",
          "[Removed Lines]",
          "147:     assert(k <= 8);",
          "",
          "[Added Lines]",
          "152:     assert(k <= 13);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "269:         sample[0][-1] = sample[1][0];",
          "270:         sample[1][w]  = sample[1][w - 1];",
          "273:             for (x = 0; x < w; x++)",
          "274:                 sample[0][x] = src[x + stride * y];",
          "275:             encode_line(s, w, sample, plane_index, 8);",
          "276:         } else {",
          "281:         }",
          "283:     }",
          "284: }",
          "288: {",
          "289:     int x, y, p, i;",
          "290:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "292:     s->run_index = 0;",
          "296:     for (y = 0; y < h; y++) {",
          "297:         for (i = 0; i < ring_size; i++)",
          "300:                                ((h + i - y) % ring_size) * (w + 6) + 3;",
          "302:         for (x = 0; x < w; x++) {",
          "308:             b -= g;",
          "309:             r -= g;",
          "310:             g += (b + r) >> 2;",
          "314:             sample[0][0][x] = g;",
          "315:             sample[1][0][x] = b;",
          "316:             sample[2][0][x] = r;",
          "317:         }",
          "319:             sample[p][0][-1] = sample[p][1][0];",
          "320:             sample[p][1][w]  = sample[p][1][w - 1];",
          "322:         }",
          "323:     }",
          "324: }",
          "326: static void write_quant_table(RangeCoder *c, int16_t *quant_table)",
          "327: {",
          "328:     int last = 0;",
          "",
          "[Removed Lines]",
          "272:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "277:             for (x = 0; x < w; x++)",
          "278:                 sample[0][x] = ((uint16_t *)(src + stride * y))[x] >>",
          "279:                                (16 - s->avctx->bits_per_raw_sample);",
          "280:             encode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);",
          "286: static void encode_rgb_frame(FFV1Context *s, uint32_t *src, int w, int h,",
          "287:                              int stride)",
          "291:     int16_t *sample[3][3];",
          "294:     memset(s->sample_buffer, 0, ring_size * 3 * (w + 6) * sizeof(*s->sample_buffer));",
          "298:             for (p = 0; p < 3; p++)",
          "299:                 sample[p][i] = s->sample_buffer + p * ring_size * (w + 6) +",
          "303:             int v = src[x + stride * y];",
          "304:             int b =  v        & 0xFF;",
          "305:             int g = (v >>  8) & 0xFF;",
          "306:             int r = (v >> 16) & 0xFF;",
          "311:             b += 0x100;",
          "312:             r += 0x100;",
          "318:         for (p = 0; p < 3; p++) {",
          "321:             encode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "",
          "[Added Lines]",
          "277:         if (s->bits_per_raw_sample <= 8) {",
          "282:             if (s->packed_at_lsb) {",
          "283:                 for (x = 0; x < w; x++)",
          "284:                     sample[0][x] = ((uint16_t *)(src + stride * y))[x];",
          "285:             } else {",
          "286:                 for (x = 0; x < w; x++)",
          "287:                     sample[0][x] =",
          "288:                         ((uint16_t *)(src + stride * y))[x] >> (16 - s->bits_per_raw_sample);",
          "289:             }",
          "290:             encode_line(s, w, sample, plane_index, s->bits_per_raw_sample);",
          "296: static void encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h,",
          "297:                              int stride[3])",
          "301:     int16_t *sample[MAX_PLANES][3];",
          "302:     int lbd  = s->avctx->bits_per_raw_sample <= 8;",
          "303:     int bits = s->avctx->bits_per_raw_sample > 0",
          "304:                ? s->avctx->bits_per_raw_sample",
          "305:                : 8;",
          "306:     int offset = 1 << bits;",
          "310:     memset(s->sample_buffer, 0, ring_size * MAX_PLANES *",
          "311:                                 (w + 6) * sizeof(*s->sample_buffer));",
          "315:             for (p = 0; p < MAX_PLANES; p++)",
          "316:                 sample[p][i] = s->sample_buffer + p * ring_size *",
          "317:                                (w + 6) +",
          "321:             int b, g, r, av_uninit(a);",
          "322:             if (lbd) {",
          "323:                 unsigned v = *((uint32_t *)(src[0] + x * 4 + stride[0] * y));",
          "324:                 b = v & 0xFF;",
          "325:                 g = (v >> 8) & 0xFF;",
          "326:                 r = (v >> 16) & 0xFF;",
          "327:                 a = v >> 24;",
          "328:             } else {",
          "329:                 b = *((uint16_t *)(src[0] + x * 2 + stride[0] * y));",
          "330:                 g = *((uint16_t *)(src[1] + x * 2 + stride[1] * y));",
          "331:                 r = *((uint16_t *)(src[2] + x * 2 + stride[2] * y));",
          "332:             }",
          "337:             b += offset;",
          "338:             r += offset;",
          "343:             sample[3][0][x] = a;",
          "345:         for (p = 0; p < 3 + s->transparency; p++) {",
          "348:             if (lbd)",
          "349:                 encode_line(s, w, sample[p], (p + 1) / 2, 9);",
          "350:             else",
          "351:                 encode_line(s, w, sample[p], (p + 1) / 2, bits + 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "364:         }",
          "365:         put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "366:         if (f->version > 0)",
          "369:         put_symbol(c, state, f->chroma_h_shift, 0);",
          "370:         put_symbol(c, state, f->chroma_v_shift, 0);",
          "373:         write_quant_tables(c, f->quant_table);",
          "375:         put_symbol(c, state, f->slice_count, 0);",
          "376:         for (i = 0; i < f->slice_count; i++) {",
          "377:             FFV1Context *fs = f->slice_context[i];",
          "",
          "[Removed Lines]",
          "367:             put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "368:         put_rac(c, state, 1); // chroma planes",
          "371:         put_rac(c, state, 0); // no transparency plane",
          "374:     } else {",
          "",
          "[Added Lines]",
          "398:             put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "399:         put_rac(c, state, f->chroma_planes);",
          "402:         put_rac(c, state, f->transparency);",
          "405:     } else if (f->version < 3) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "393:     }",
          "394: }",
          "397: {",
          "398:     RangeCoder *const c = &f->c;",
          "399:     uint8_t state[CONTEXT_SIZE];",
          "400:     int i, j, k;",
          "401:     uint8_t state2[32][CONTEXT_SIZE];",
          "403:     memset(state2, 128, sizeof(state2));",
          "404:     memset(state, 128, sizeof(state));",
          "408:     ff_init_range_encoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "409:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "411:     put_symbol(c, state, f->version, 0);",
          "412:     put_symbol(c, state, f->ac, 0);",
          "413:     if (f->ac > 1)",
          "414:         for (i = 1; i < 256; i++)",
          "415:             put_symbol(c, state, f->state_transition[i] - c->one_state[i], 1);",
          "416:     put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "419:     put_symbol(c, state, f->chroma_h_shift, 0);",
          "420:     put_symbol(c, state, f->chroma_v_shift, 0);",
          "422:     put_symbol(c, state, f->num_h_slices - 1, 0);",
          "423:     put_symbol(c, state, f->num_v_slices - 1, 0);",
          "",
          "[Removed Lines]",
          "396: static int write_extra_header(FFV1Context *f)",
          "406:     f->avctx->extradata = av_malloc(f->avctx->extradata_size = 10000 +",
          "407:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32);",
          "417:     put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "418:     put_rac(c, state, 1); // chroma planes",
          "421:     put_rac(c, state, 0); // no transparency plane",
          "",
          "[Added Lines]",
          "427: static int write_extradata(FFV1Context *f)",
          "433:     unsigned v;",
          "438:     f->avctx->extradata_size = 10000 + 4 +",
          "439:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32;",
          "440:     f->avctx->extradata = av_malloc(f->avctx->extradata_size);",
          "445:     if (f->version > 2) {",
          "446:         if (f->version == 3)",
          "447:             f->minor_version = 2;",
          "448:         put_symbol(c, state, f->minor_version, 0);",
          "449:     }",
          "457:     put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "458:     put_rac(c, state, f->chroma_planes);",
          "461:     put_rac(c, state, f->transparency);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "443:         }",
          "444:     }",
          "446:     f->avctx->extradata_size = ff_rac_terminate(c);",
          "448:     return 0;",
          "449: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "486:     if (f->version > 2) {",
          "487:         put_symbol(c, state, f->ec, 0);",
          "488:     }",
          "492:     v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0,",
          "493:                f->avctx->extradata, f->avctx->extradata_size);",
          "494:     AV_WL32(f->avctx->extradata + f->avctx->extradata_size, v);",
          "495:     f->avctx->extradata_size += 4;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "496:     return print;",
          "497: }",
          "499: static av_cold int ffv1_encode_init(AVCodecContext *avctx)",
          "500: {",
          "501:     FFV1Context *s = avctx->priv_data;",
          "502:     int i, j, k, m, ret;",
          "504:     ffv1_common_init(avctx);",
          "506:     s->version = 0;",
          "509:     if (s->ac > 1)",
          "510:         for (i = 1; i < 256; i++)",
          "511:             s->state_transition[i] = ffv1_ver2_state[i];",
          "514:     for (i = 0; i < 256; i++) {",
          "515:         s->quant_table_count = 2;",
          "517:             s->quant_tables[0][0][i] = ffv1_quant11[i];",
          "518:             s->quant_tables[0][1][i] = ffv1_quant11[i] * 11;",
          "519:             s->quant_tables[0][2][i] = ffv1_quant11[i] * 11 * 11;",
          "",
          "[Removed Lines]",
          "507:     s->ac      = avctx->coder_type ? 2 : 0;",
          "513:     s->plane_count = 2;",
          "516:         if (avctx->bits_per_raw_sample <= 8) {",
          "",
          "[Added Lines]",
          "548: static int init_slices_state(FFV1Context *f)",
          "549: {",
          "550:     int i, ret;",
          "551:     for (i = 0; i < f->slice_count; i++) {",
          "552:         FFV1Context *fs = f->slice_context[i];",
          "553:         if ((ret = ffv1_init_slice_state(f, fs)) < 0)",
          "554:             return AVERROR(ENOMEM);",
          "555:     }",
          "556:     return 0;",
          "557: }",
          "562:     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "569:     if ((avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) ||",
          "570:         avctx->slices > 1)",
          "571:         s->version = FFMAX(s->version, 2);",
          "573:     if (avctx->level == 3) {",
          "574:         s->version = 3;",
          "575:     }",
          "577:     if (s->ec < 0) {",
          "578:         s->ec = (s->version >= 3);",
          "579:     }",
          "581:     if (s->version >= 2 &&",
          "582:         avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {",
          "583:         av_log(avctx, AV_LOG_ERROR,",
          "584:                \"Version %d requested, please set -strict experimental in \"",
          "585:                \"order to enable it\\n\",",
          "586:                s->version);",
          "587:         return AVERROR(ENOSYS);",
          "588:     }",
          "590:     s->ac = avctx->coder_type > 0 ? 2 : 0;",
          "592:     s->plane_count = 3;",
          "593:     switch (avctx->pix_fmt) {",
          "594:     case AV_PIX_FMT_YUV444P9:",
          "595:     case AV_PIX_FMT_YUV422P9:",
          "596:     case AV_PIX_FMT_YUV420P9:",
          "597:         if (!avctx->bits_per_raw_sample)",
          "598:             s->bits_per_raw_sample = 9;",
          "599:     case AV_PIX_FMT_YUV444P10:",
          "600:     case AV_PIX_FMT_YUV420P10:",
          "601:     case AV_PIX_FMT_YUV422P10:",
          "602:         s->packed_at_lsb = 1;",
          "603:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "604:             s->bits_per_raw_sample = 10;",
          "605:     case AV_PIX_FMT_GRAY16:",
          "606:     case AV_PIX_FMT_YUV444P16:",
          "607:     case AV_PIX_FMT_YUV422P16:",
          "608:     case AV_PIX_FMT_YUV420P16:",
          "609:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {",
          "610:             s->bits_per_raw_sample = 16;",
          "611:         } else if (!s->bits_per_raw_sample) {",
          "612:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "613:         }",
          "614:         if (s->bits_per_raw_sample <= 8) {",
          "615:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "616:             return AVERROR_INVALIDDATA;",
          "617:         }",
          "618:         if (!s->ac && avctx->coder_type == -1) {",
          "619:             av_log(avctx, AV_LOG_INFO,",
          "620:                    \"bits_per_raw_sample > 8, forcing coder 1\\n\");",
          "621:             s->ac = 2;",
          "622:         }",
          "623:         if (!s->ac) {",
          "624:             av_log(",
          "625:                 avctx, AV_LOG_ERROR,",
          "626:                 \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "627:             return AVERROR_INVALIDDATA;",
          "628:         }",
          "629:         s->version = FFMAX(s->version, 1);",
          "630:     case AV_PIX_FMT_GRAY8:",
          "631:     case AV_PIX_FMT_YUV444P:",
          "632:     case AV_PIX_FMT_YUV440P:",
          "633:     case AV_PIX_FMT_YUV422P:",
          "634:     case AV_PIX_FMT_YUV420P:",
          "635:     case AV_PIX_FMT_YUV411P:",
          "636:     case AV_PIX_FMT_YUV410P:",
          "637:         s->chroma_planes = desc->nb_components < 3 ? 0 : 1;",
          "638:         s->colorspace    = 0;",
          "639:         break;",
          "640:     case AV_PIX_FMT_YUVA444P:",
          "641:     case AV_PIX_FMT_YUVA422P:",
          "642:     case AV_PIX_FMT_YUVA420P:",
          "643:         s->chroma_planes = 1;",
          "644:         s->colorspace    = 0;",
          "645:         s->transparency  = 1;",
          "646:         break;",
          "647:     case AV_PIX_FMT_RGB32:",
          "648:         s->colorspace   = 1;",
          "649:         s->transparency = 1;",
          "650:         break;",
          "651:     case AV_PIX_FMT_GBRP9:",
          "652:         if (!avctx->bits_per_raw_sample)",
          "653:             s->bits_per_raw_sample = 9;",
          "654:     case AV_PIX_FMT_GBRP10:",
          "655:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "656:             s->bits_per_raw_sample = 10;",
          "657:     case AV_PIX_FMT_GBRP16:",
          "658:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "659:             s->bits_per_raw_sample = 16;",
          "660:         else if (!s->bits_per_raw_sample)",
          "661:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "662:         s->colorspace    = 1;",
          "663:         s->chroma_planes = 1;",
          "664:         s->version       = FFMAX(s->version, 1);",
          "665:         break;",
          "666:     default:",
          "667:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "668:         return AVERROR_INVALIDDATA;",
          "669:     }",
          "670:     if (s->transparency) {",
          "671:         av_log(",
          "672:             avctx, AV_LOG_WARNING,",
          "673:             \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");",
          "674:     }",
          "675:     if (avctx->context_model > 1U) {",
          "676:         av_log(avctx, AV_LOG_ERROR,",
          "677:                \"Invalid context model %d, valid values are 0 and 1\\n\",",
          "678:                avctx->context_model);",
          "679:         return AVERROR(EINVAL);",
          "680:     }",
          "688:         if (s->bits_per_raw_sample <= 8) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "546:         p->context_count     = s->context_count[p->quant_table_index];",
          "547:     }",
          "552:     avctx->coded_frame = &s->picture;",
          "581:     avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift,",
          "582:                                   &s->chroma_v_shift);",
          "",
          "[Removed Lines]",
          "549:     if (ffv1_allocate_initial_states(s) < 0)",
          "550:         return AVERROR(ENOMEM);",
          "553:     switch (avctx->pix_fmt) {",
          "554:     case AV_PIX_FMT_YUV444P16:",
          "555:     case AV_PIX_FMT_YUV422P16:",
          "556:     case AV_PIX_FMT_YUV420P16:",
          "557:         if (avctx->bits_per_raw_sample <= 8) {",
          "558:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "559:             return AVERROR_INVALIDDATA;",
          "560:         }",
          "561:         if (!s->ac) {",
          "562:             av_log(avctx, AV_LOG_ERROR,",
          "563:                    \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "564:             return AVERROR(ENOSYS);",
          "565:         }",
          "566:         s->version = FFMAX(s->version, 1);",
          "567:     case AV_PIX_FMT_YUV444P:",
          "568:     case AV_PIX_FMT_YUV422P:",
          "569:     case AV_PIX_FMT_YUV420P:",
          "570:     case AV_PIX_FMT_YUV411P:",
          "571:     case AV_PIX_FMT_YUV410P:",
          "572:         s->colorspace = 0;",
          "573:         break;",
          "574:     case AV_PIX_FMT_RGB32:",
          "575:         s->colorspace = 1;",
          "576:         break;",
          "577:     default:",
          "578:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "579:         return AVERROR(ENOSYS);",
          "580:     }",
          "",
          "[Added Lines]",
          "721:     if ((ret = ffv1_allocate_initial_states(s)) < 0)",
          "722:         return ret;",
          "725:     if (!s->transparency)",
          "726:         s->plane_count = 2;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "625:                         }",
          "626:                 }",
          "627:             gob_count = strtol(p, &next, 0);",
          "629:                 av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");",
          "630:                 return AVERROR_INVALIDDATA;",
          "631:             }",
          "",
          "[Removed Lines]",
          "628:             if (next == p || gob_count < 0) {",
          "",
          "[Added Lines]",
          "775:             if (next == p || gob_count <= 0) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "656:     }",
          "658:     if (s->version > 1) {",
          "662:     }",
          "664:     if ((ret = ffv1_init_slice_contexts(s)) < 0)",
          "665:         return ret;",
          "667:         return ret;",
          "669: #define STATS_OUT_SIZE 1024 * 1024 * 6",
          "",
          "[Removed Lines]",
          "659:         s->num_h_slices = 2;",
          "660:         s->num_v_slices = 2;",
          "661:         write_extra_header(s);",
          "666:     if ((ret = ffv1_init_slice_state(s)) < 0)",
          "",
          "[Added Lines]",
          "806:         for (s->num_v_slices = 2; s->num_v_slices < 9; s->num_v_slices++)",
          "807:             for (s->num_h_slices = s->num_v_slices;",
          "808:                  s->num_h_slices < 2 * s->num_v_slices; s->num_h_slices++)",
          "809:                 if (avctx->slices == s->num_h_slices * s->num_v_slices &&",
          "810:                     avctx->slices <= 64 || !avctx->slices)",
          "811:                     goto slices_ok;",
          "812:         av_log(avctx, AV_LOG_ERROR,",
          "813:                \"Unsupported number %d of slices requested, please specify a \"",
          "814:                \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",",
          "815:                avctx->slices);",
          "816:         return AVERROR(ENOSYS);",
          "817: slices_ok:",
          "818:         write_extradata(s);",
          "823:     if ((ret = init_slices_state(s)) < 0)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "683:     return 0;",
          "684: }",
          "686: static int encode_slice(AVCodecContext *c, void *arg)",
          "687: {",
          "688:     FFV1Context *fs  = *(void **)arg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "843: static void encode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "844: {",
          "845:     RangeCoder *c = &fs->c;",
          "846:     uint8_t state[CONTEXT_SIZE];",
          "847:     int j;",
          "848:     memset(state, 128, sizeof(state));",
          "850:     put_symbol(c, state, (fs->slice_x + 1) * f->num_h_slices / f->width, 0);",
          "851:     put_symbol(c, state, (fs->slice_y + 1) * f->num_v_slices / f->height, 0);",
          "852:     put_symbol(c, state, (fs->slice_width + 1) * f->num_h_slices / f->width - 1,",
          "853:                0);",
          "854:     put_symbol(c, state,",
          "855:                (fs->slice_height + 1) * f->num_v_slices / f->height - 1,",
          "856:                0);",
          "857:     for (j = 0; j < f->plane_count; j++) {",
          "858:         put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "859:         av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "860:     }",
          "861:     if (!f->picture.interlaced_frame)",
          "862:         put_symbol(c, state, 3, 0);",
          "863:     else",
          "864:         put_symbol(c, state, 1 + !f->picture.top_field_first, 0);",
          "865:     put_symbol(c, state, f->picture.sample_aspect_ratio.num, 0);",
          "866:     put_symbol(c, state, f->picture.sample_aspect_ratio.den, 0);",
          "867: }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "692:     int x            = fs->slice_x;",
          "693:     int y            = fs->slice_y;",
          "694:     AVFrame *const p = &f->picture;",
          "696:     if (f->colorspace == 0) {",
          "697:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878:     const int ps     = (av_pix_fmt_desc_get(c->pix_fmt)->flags & PIX_FMT_PLANAR)",
          "879:                        ? (f->bits_per_raw_sample > 8) + 1",
          "880:                        : 4;",
          "882:     if (p->key_frame)",
          "883:         ffv1_clear_slice_state(f, fs);",
          "884:     if (f->version > 2) {",
          "885:         encode_slice_header(f, fs);",
          "886:     }",
          "887:     if (!fs->ac) {",
          "888:         if (f->version > 2)",
          "889:             put_rac(&fs->c, (uint8_t[]) { 129 }, 0);",
          "890:         fs->ac_byte_count = f->version > 2 || (!x && !y) ? ff_rac_terminate( &fs->c) : 0;",
          "891:         init_put_bits(&fs->pb, fs->c.bytestream_start + fs->ac_byte_count,",
          "892:                       fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count);",
          "893:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "699:         const int cx            = x >> f->chroma_h_shift;",
          "700:         const int cy            = y >> f->chroma_v_shift;",
          "703:                      width, height, p->linesize[0], 0);",
          "709:     } else {",
          "713:     }",
          "714:     emms_c();",
          "",
          "[Removed Lines]",
          "702:         encode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "705:         encode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "706:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "707:         encode_plane(fs, p->data[2] + cx + cy * p->linesize[2],",
          "708:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "710:         encode_rgb_frame(fs, (uint32_t *)(p->data[0]) +",
          "711:                          x + y * (p->linesize[0] / 4),",
          "712:                          width, height, p->linesize[0] / 4);",
          "",
          "[Added Lines]",
          "901:         encode_plane(fs, p->data[0] + ps * x + y * p->linesize[0],",
          "904:         if (f->chroma_planes) {",
          "905:             encode_plane(fs, p->data[1] + ps * cx + cy * p->linesize[1],",
          "906:                          chroma_width, chroma_height, p->linesize[1], 1);",
          "907:             encode_plane(fs, p->data[2] + ps * cx + cy * p->linesize[2],",
          "908:                          chroma_width, chroma_height, p->linesize[2], 1);",
          "909:         }",
          "910:         if (fs->transparency)",
          "911:             encode_plane(fs, p->data[3] + ps * x + y * p->linesize[3], width,",
          "912:                          height, p->linesize[3], 2);",
          "914:         uint8_t *planes[3] = { p->data[0] + ps * x + y * p->linesize[0],",
          "915:                                p->data[1] + ps * x + y * p->linesize[1],",
          "916:                                p->data[2] + ps * x + y * p->linesize[2] };",
          "917:         encode_rgb_frame(fs, planes, width, height, p->linesize);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "717: }",
          "719: static int ffv1_encode_frame(AVCodecContext *avctx, AVPacket *pkt,",
          "721: {",
          "722:     FFV1Context *f      = avctx->priv_data;",
          "723:     RangeCoder *const c = &f->slice_context[0]->c;",
          "",
          "[Removed Lines]",
          "720:                              const AVFrame *pict, int *got_packet)",
          "",
          "[Added Lines]",
          "925:                         const AVFrame *pict, int *got_packet)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "727:     uint8_t *buf_p;",
          "728:     int i, ret;",
          "733:         av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");",
          "734:         return ret;",
          "735:     }",
          "",
          "[Removed Lines]",
          "730:     if (!pkt->data &&",
          "731:         (ret = av_new_packet(pkt, avctx->width * avctx->height *",
          "732:                              ((8 * 2 + 1 + 1) * 4) / 8 + FF_MIN_BUFFER_SIZE)) < 0) {",
          "",
          "[Added Lines]",
          "935:     if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height *",
          "936:                              ((8 * 2 + 1 + 1) * 4) / 8 +",
          "937:                              FF_MIN_BUFFER_SIZE)) < 0) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "745:         p->key_frame = 1;",
          "746:         f->gob_count++;",
          "747:         write_header(f);",
          "749:     } else {",
          "750:         put_rac(c, &keystate, 0);",
          "751:         p->key_frame = 0;",
          "752:     }",
          "759:         int i;",
          "760:         for (i = 1; i < 256; i++) {",
          "761:             c->one_state[i]        = f->state_transition[i];",
          "",
          "[Removed Lines]",
          "748:         ffv1_clear_state(f);",
          "754:     if (!f->ac) {",
          "755:         used_count += ff_rac_terminate(c);",
          "756:         init_put_bits(&f->slice_context[0]->pb, pkt->data + used_count,",
          "757:                       pkt->size - used_count);",
          "758:     } else if (f->ac > 1) {",
          "",
          "[Added Lines]",
          "958:     if (f->ac > 1) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "766:     for (i = 1; i < f->slice_count; i++) {",
          "767:         FFV1Context *fs = f->slice_context[i];",
          "775:     }",
          "776:     avctx->execute(avctx, encode_slice, &f->slice_context[0], NULL,",
          "777:                    f->slice_count, sizeof(void *));",
          "",
          "[Removed Lines]",
          "768:         uint8_t *start  = pkt->data + (pkt->size - used_count) * i / f->slice_count;",
          "769:         int len         = pkt->size / f->slice_count;",
          "771:         if (fs->ac)",
          "772:             ff_init_range_encoder(&fs->c, start, len);",
          "773:         else",
          "774:             init_put_bits(&fs->pb, start, len);",
          "",
          "[Added Lines]",
          "968:         uint8_t *start  = pkt->data +",
          "969:                           (pkt->size - used_count) * (int64_t)i / f->slice_count;",
          "970:         int len = pkt->size / f->slice_count;",
          "971:         ff_init_range_encoder(&fs->c, start, len);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "782:         int bytes;",
          "784:         if (fs->ac) {",
          "786:             put_rac(&fs->c, &state, 0);",
          "787:             bytes = ff_rac_terminate(&fs->c);",
          "788:         } else {",
          "789:             flush_put_bits(&fs->pb); // FIXME: nicer padding",
          "792:         }",
          "794:             av_assert0(bytes < pkt->size / f->slice_count);",
          "796:             av_assert0(bytes < (1 << 24));",
          "797:             AV_WB24(buf_p + bytes, bytes);",
          "798:             bytes += 3;",
          "799:         }",
          "800:         buf_p += bytes;",
          "801:     }",
          "",
          "[Removed Lines]",
          "785:             uint8_t state = 128;",
          "790:             bytes      = used_count + (put_bits_count(&fs->pb) + 7) / 8;",
          "791:             used_count = 0;",
          "793:         if (i > 0) {",
          "795:             memmove(buf_p, fs->ac ? fs->c.bytestream_start : fs->pb.buf, bytes);",
          "",
          "[Added Lines]",
          "982:             uint8_t state = 129;",
          "987:             bytes = fs->ac_byte_count + (put_bits_count(&fs->pb) + 7) / 8;",
          "989:         if (i > 0 || f->version > 2) {",
          "991:             memmove(buf_p, fs->c.bytestream_start, bytes);",
          "996:         if (f->ec) {",
          "997:             unsigned v;",
          "998:             buf_p[bytes++] = 0;",
          "999:             v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, bytes);",
          "1000:             AV_WL32(buf_p + bytes, v);",
          "1001:             bytes += 4;",
          "1002:         }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "851:     return 0;",
          "852: }",
          "854: AVCodec ff_ffv1_encoder = {",
          "855:     .name           = \"ffv1\",",
          "856:     .type           = AVMEDIA_TYPE_VIDEO,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1057: #define OFFSET(x) offsetof(FFV1Context, x)",
          "1058: #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM",
          "1059: static const AVOption options[] = {",
          "1060:     { \"slicecrc\", \"Protect slices with CRCs\", OFFSET(ec), AV_OPT_TYPE_INT,",
          "1061:              { .i64 = -1 }, -1, 1, VE },",
          "1062:     { NULL }",
          "1063: };",
          "1065: static const AVClass class = {",
          "1066:     .class_name = \"ffv1 encoder\",",
          "1067:     .item_name  = av_default_item_name,",
          "1068:     .option     = options,",
          "1069:     .version    = LIBAVUTIL_VERSION_INT,",
          "1070: };",
          "1072: static const AVCodecDefault ffv1_defaults[] = {",
          "1073:     { \"coder\", \"-1\" },",
          "1074:     { NULL },",
          "1075: };",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "863:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "864:         AV_PIX_FMT_YUV420P,   AV_PIX_FMT_YUV422P,   AV_PIX_FMT_YUV444P,",
          "865:         AV_PIX_FMT_YUV411P,   AV_PIX_FMT_YUV410P,",
          "866:         AV_PIX_FMT_YUV420P16, AV_PIX_FMT_YUV422P16, AV_PIX_FMT_YUV444P16,",
          "867:         AV_PIX_FMT_RGB32,",
          "868:         AV_PIX_FMT_NONE",
          "869:     },",
          "870:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "871: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1089:         AV_PIX_FMT_YUV444P9,  AV_PIX_FMT_YUV422P9,  AV_PIX_FMT_YUV420P9,",
          "1090:         AV_PIX_FMT_YUV420P10, AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV444P10,",
          "1093:         AV_PIX_FMT_GBRP9,     AV_PIX_FMT_GBRP10,",
          "1094:         AV_PIX_FMT_YUVA420P,  AV_PIX_FMT_YUVA422P,  AV_PIX_FMT_YUVA444P,",
          "1095:         AV_PIX_FMT_GRAY16,    AV_PIX_FMT_GRAY8,",
          "1100:     .defaults       = ffv1_defaults,",
          "1101:     .priv_class     = &class,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e4255eaf47373c0c1691cbcbc0816253e938b662",
      "candidate_info": {
        "commit_hash": "e4255eaf47373c0c1691cbcbc0816253e938b662",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e4255eaf47373c0c1691cbcbc0816253e938b662",
        "files": [
          "libavcodec/Makefile",
          "libavcodec/ffv1.c",
          "libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c"
        ],
        "message": "ffv1: split decoder and encoder\n\nThis is not based on lucas work due to code divergence (its less work this way\nthan trying to merge from a split based on 2 years outdated code)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/ffv1.c||libavcodec/ffv1.c",
          "libavcodec/ffv1.h||libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1.c||libavcodec/ffv1.c": [
          "File: libavcodec/ffv1.c -> libavcodec/ffv1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include \"libavutil/timer.h\"",
          "34: #include \"avcodec.h\"",
          "35: #include \"internal.h\"",
          "38: #include \"dsputil.h\"",
          "39: #include \"rangecoder.h\"",
          "40: #include \"golomb.h\"",
          "41: #include \"mathops.h\"",
          "736: {",
          "737:     FFV1Context *s = avctx->priv_data;",
          "",
          "[Removed Lines]",
          "36: #include \"get_bits.h\"",
          "37: #include \"put_bits.h\"",
          "43: #ifdef __INTEL_COMPILER",
          "44: #undef av_flatten",
          "45: #define av_flatten",
          "46: #endif",
          "48: #define MAX_PLANES 4",
          "49: #define CONTEXT_SIZE 32",
          "51: #define MAX_QUANT_TABLES 8",
          "52: #define MAX_CONTEXT_INPUTS 5",
          "54: extern const uint8_t ff_log2_run[41];",
          "56: static const int8_t quant5_10bit[256] = {",
          "57:      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,",
          "58:      1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,",
          "59:      1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,",
          "60:      1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "61:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "62:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "63:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "64:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "65:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "66:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "67:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "68:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "69:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1,",
          "70:     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "71:     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "72:     -1, -1, -1, -1, -1, -1, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0,",
          "73: };",
          "75: static const int8_t quant5[256] = {",
          "76:      0,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "77:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "78:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "79:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "80:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "81:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "82:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "83:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "84:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "85:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "86:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "87:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "88:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "89:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "90:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "91:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -1,",
          "92: };",
          "94: static const int8_t quant9_10bit[256] = {",
          "95:      0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,",
          "96:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,",
          "97:      3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,",
          "98:      3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,",
          "99:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "100:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "101:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "102:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "103:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "104:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "105:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "106:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "107:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3,",
          "108:     -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,",
          "109:     -3, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "110:     -2, -2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -0, -0, -0, -0,",
          "111: };",
          "113: static const int8_t quant11[256] = {",
          "114:      0,  1,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,",
          "115:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "116:      4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "117:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "118:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "119:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "120:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "121:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "122:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "123:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "124:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "125:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "126:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "127:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -4, -4,",
          "128:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "129:     -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2, -2, -2, -1,",
          "130: };",
          "132: static const uint8_t ver2_state[256] = {",
          "133:       0,  10,  10,  10,  10,  16,  16,  16, 28,   16,  16,  29,  42,  49,  20,  49,",
          "134:      59,  25,  26,  26,  27,  31,  33,  33, 33,   34,  34,  37,  67,  38,  39,  39,",
          "135:      40,  40,  41,  79,  43,  44,  45,  45, 48,   48,  64,  50,  51,  52,  88,  52,",
          "136:      53,  74,  55,  57,  58,  58,  74,  60, 101,  61,  62,  84,  66,  66,  68,  69,",
          "137:      87,  82,  71,  97,  73,  73,  82,  75, 111,  77,  94,  78,  87,  81,  83,  97,",
          "138:      85,  83,  94,  86,  99,  89,  90,  99, 111,  92,  93,  134, 95,  98,  105, 98,",
          "139:     105, 110, 102, 108, 102, 118, 103, 106, 106, 113, 109, 112, 114, 112, 116, 125,",
          "140:     115, 116, 117, 117, 126, 119, 125, 121, 121, 123, 145, 124, 126, 131, 127, 129,",
          "141:     165, 130, 132, 138, 133, 135, 145, 136, 137, 139, 146, 141, 143, 142, 144, 148,",
          "142:     147, 155, 151, 149, 151, 150, 152, 157, 153, 154, 156, 168, 158, 162, 161, 160,",
          "143:     172, 163, 169, 164, 166, 184, 167, 170, 177, 174, 171, 173, 182, 176, 180, 178,",
          "144:     175, 189, 179, 181, 186, 183, 192, 185, 200, 187, 191, 188, 190, 197, 193, 196,",
          "145:     197, 194, 195, 196, 198, 202, 199, 201, 210, 203, 207, 204, 205, 206, 208, 214,",
          "146:     209, 211, 221, 212, 213, 215, 224, 216, 217, 218, 219, 220, 222, 228, 223, 225,",
          "147:     226, 224, 227, 229, 240, 230, 231, 232, 233, 234, 235, 236, 238, 239, 237, 242,",
          "148:     241, 243, 242, 244, 245, 246, 247, 248, 249, 250, 251, 252, 252, 253, 254, 255,",
          "149: };",
          "151: typedef struct VlcState {",
          "152:     int16_t drift;",
          "153:     uint16_t error_sum;",
          "154:     int8_t bias;",
          "155:     uint8_t count;",
          "156: } VlcState;",
          "158: typedef struct PlaneContext {",
          "159:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "160:     int quant_table_index;",
          "161:     int context_count;",
          "162:     uint8_t (*state)[CONTEXT_SIZE];",
          "163:     VlcState *vlc_state;",
          "164:     uint8_t interlace_bit_state[2];",
          "165: } PlaneContext;",
          "167: #define MAX_SLICES 256",
          "169: typedef struct FFV1Context {",
          "170:     AVClass *class;",
          "171:     AVCodecContext *avctx;",
          "172:     RangeCoder c;",
          "173:     GetBitContext gb;",
          "174:     PutBitContext pb;",
          "175:     uint64_t rc_stat[256][2];",
          "176:     uint64_t (*rc_stat2[MAX_QUANT_TABLES])[32][2];",
          "177:     int version;",
          "178:     int minor_version;",
          "179:     int width, height;",
          "180:     int chroma_h_shift, chroma_v_shift;",
          "181:     int chroma_planes;",
          "182:     int transparency;",
          "183:     int flags;",
          "184:     int picture_number;",
          "185:     AVFrame picture;",
          "186:     AVFrame last_picture;",
          "187:     int plane_count;",
          "188:     int ac;                              ///< 1=range coder <-> 0=golomb rice",
          "189:     int ac_byte_count;                   ///< number of bytes used for AC coding",
          "190:     PlaneContext plane[MAX_PLANES];",
          "191:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "192:     int16_t quant_tables[MAX_QUANT_TABLES][MAX_CONTEXT_INPUTS][256];",
          "193:     int context_count[MAX_QUANT_TABLES];",
          "194:     uint8_t state_transition[256];",
          "195:     uint8_t (*initial_states[MAX_QUANT_TABLES])[32];",
          "196:     int run_index;",
          "197:     int colorspace;",
          "198:     int16_t *sample_buffer;",
          "199:     int gob_count;",
          "200:     int packed_at_lsb;",
          "201:     int ec;",
          "202:     int slice_damaged;",
          "203:     int key_frame_ok;",
          "205:     int quant_table_count;",
          "207:     DSPContext dsp;",
          "209:     struct FFV1Context *slice_context[MAX_SLICES];",
          "210:     int slice_count;",
          "211:     int num_v_slices;",
          "212:     int num_h_slices;",
          "213:     int slice_width;",
          "214:     int slice_height;",
          "215:     int slice_x;",
          "216:     int slice_y;",
          "217:     int bits_per_raw_sample;",
          "218: } FFV1Context;",
          "220: static av_always_inline int fold(int diff, int bits)",
          "221: {",
          "222:     if (bits == 8)",
          "223:         diff = (int8_t)diff;",
          "224:     else {",
          "225:         diff +=  1 << (bits  - 1);",
          "226:         diff &= (1 <<  bits) - 1;",
          "227:         diff -=  1 << (bits  - 1);",
          "228:     }",
          "230:     return diff;",
          "231: }",
          "233: static inline int predict(int16_t *src, int16_t *last)",
          "234: {",
          "235:     const int LT = last[-1];",
          "236:     const int T  = last[0];",
          "237:     const int L  = src[-1];",
          "239:     return mid_pred(L, L + T - LT, T);",
          "240: }",
          "242: static inline int get_context(PlaneContext *p, int16_t *src,",
          "243:                               int16_t *last, int16_t *last2)",
          "244: {",
          "245:     const int LT = last[-1];",
          "246:     const int T  = last[0];",
          "247:     const int RT = last[1];",
          "248:     const int L  = src[-1];",
          "250:     if (p->quant_table[3][127]) {",
          "251:         const int TT = last2[0];",
          "252:         const int LL = src[-2];",
          "253:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "254:                p->quant_table[1][(LT - T) & 0xFF] +",
          "255:                p->quant_table[2][(T - RT) & 0xFF] +",
          "256:                p->quant_table[3][(LL - L) & 0xFF] +",
          "257:                p->quant_table[4][(TT - T) & 0xFF];",
          "258:     } else",
          "259:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "260:                p->quant_table[1][(LT - T) & 0xFF] +",
          "261:                p->quant_table[2][(T - RT) & 0xFF];",
          "262: }",
          "264: static void find_best_state(uint8_t best_state[256][256],",
          "265:                             const uint8_t one_state[256])",
          "266: {",
          "267:     int i, j, k, m;",
          "268:     double l2tab[256];",
          "270:     for (i = 1; i < 256; i++)",
          "271:         l2tab[i] = log2(i / 256.0);",
          "273:     for (i = 0; i < 256; i++) {",
          "274:         double best_len[256];",
          "275:         double p = i / 256.0;",
          "277:         for (j = 0; j < 256; j++)",
          "278:             best_len[j] = 1 << 30;",
          "280:         for (j = FFMAX(i - 10, 1); j < FFMIN(i + 11, 256); j++) {",
          "281:             double occ[256] = { 0 };",
          "282:             double len      = 0;",
          "283:             occ[j] = 1.0;",
          "284:             for (k = 0; k < 256; k++) {",
          "285:                 double newocc[256] = { 0 };",
          "286:                 for (m = 1; m < 256; m++)",
          "287:                     if (occ[m]) {",
          "288:                         len -=occ[m]*(     p *l2tab[    m]",
          "289:                                       + (1-p)*l2tab[256-m]);",
          "290:                     }",
          "291:                 if (len < best_len[k]) {",
          "292:                     best_len[k]      = len;",
          "293:                     best_state[i][k] = j;",
          "294:                 }",
          "295:                 for (m = 0; m < 256; m++)",
          "296:                     if (occ[m]) {",
          "297:                         newocc[      one_state[      m]] += occ[m] * p;",
          "298:                         newocc[256 - one_state[256 - m]] += occ[m] * (1 - p);",
          "299:                     }",
          "300:                 memcpy(occ, newocc, sizeof(occ));",
          "301:             }",
          "302:         }",
          "303:     }",
          "304: }",
          "306: static av_always_inline av_flatten void put_symbol_inline(RangeCoder *c,",
          "307:                                                           uint8_t *state, int v,",
          "308:                                                           int is_signed,",
          "309:                                                           uint64_t rc_stat[256][2],",
          "310:                                                           uint64_t rc_stat2[32][2])",
          "311: {",
          "312:     int i;",
          "314: #define put_rac(C, S, B)                        \\",
          "315:     do {                                        \\",
          "316:         if (rc_stat) {                          \\",
          "317:             rc_stat[*(S)][B]++;                 \\",
          "318:             rc_stat2[(S) - state][B]++;         \\",
          "319:         }                                       \\",
          "320:         put_rac(C, S, B);                       \\",
          "321:     } while (0)",
          "323:     if (v) {",
          "324:         const int a = FFABS(v);",
          "325:         const int e = av_log2(a);",
          "326:         put_rac(c, state + 0, 0);",
          "327:         if (e <= 9) {",
          "328:             for (i = 0; i < e; i++)",
          "329:                 put_rac(c, state + 1 + i, 1);  // 1..10",
          "330:             put_rac(c, state + 1 + i, 0);",
          "332:             for (i = e - 1; i >= 0; i--)",
          "333:                 put_rac(c, state + 22 + i, (a >> i) & 1);  // 22..31",
          "335:             if (is_signed)",
          "336:                 put_rac(c, state + 11 + e, v < 0);  // 11..21",
          "337:         } else {",
          "338:             for (i = 0; i < e; i++)",
          "339:                 put_rac(c, state + 1 + FFMIN(i, 9), 1);  // 1..10",
          "340:             put_rac(c, state + 1 + 9, 0);",
          "342:             for (i = e - 1; i >= 0; i--)",
          "343:                 put_rac(c, state + 22 + FFMIN(i, 9), (a >> i) & 1);  // 22..31",
          "345:             if (is_signed)",
          "346:                 put_rac(c, state + 11 + 10, v < 0);  // 11..21",
          "347:         }",
          "348:     } else {",
          "349:         put_rac(c, state + 0, 1);",
          "350:     }",
          "351: #undef put_rac",
          "352: }",
          "354: static av_noinline void put_symbol(RangeCoder *c, uint8_t *state,",
          "355:                                    int v, int is_signed)",
          "356: {",
          "357:     put_symbol_inline(c, state, v, is_signed, NULL, NULL);",
          "358: }",
          "360: static inline av_flatten int get_symbol_inline(RangeCoder *c, uint8_t *state,",
          "361:                                                int is_signed)",
          "362: {",
          "363:     if (get_rac(c, state + 0))",
          "364:         return 0;",
          "365:     else {",
          "366:         int i, e, a;",
          "367:         e = 0;",
          "368:         while (get_rac(c, state + 1 + FFMIN(e, 9))) // 1..10",
          "369:             e++;",
          "371:         a = 1;",
          "372:         for (i = e - 1; i >= 0; i--)",
          "373:             a += a + get_rac(c, state + 22 + FFMIN(i, 9));  // 22..31",
          "375:         e = -(is_signed && get_rac(c, state + 11 + FFMIN(e, 10))); // 11..21",
          "376:         return (a ^ e) - e;",
          "377:     }",
          "378: }",
          "380: static av_noinline int get_symbol(RangeCoder *c, uint8_t *state, int is_signed)",
          "381: {",
          "382:     return get_symbol_inline(c, state, is_signed);",
          "383: }",
          "385: static inline void update_vlc_state(VlcState *const state, const int v)",
          "386: {",
          "387:     int drift = state->drift;",
          "388:     int count = state->count;",
          "389:     state->error_sum += FFABS(v);",
          "390:     drift            += v;",
          "392:     if (count == 128) { // FIXME: variable",
          "393:         count            >>= 1;",
          "394:         drift            >>= 1;",
          "395:         state->error_sum >>= 1;",
          "396:     }",
          "397:     count++;",
          "399:     if (drift <= -count) {",
          "400:         if (state->bias > -128)",
          "401:             state->bias--;",
          "403:         drift += count;",
          "404:         if (drift <= -count)",
          "405:             drift = -count + 1;",
          "406:     } else if (drift > 0) {",
          "407:         if (state->bias < 127)",
          "408:             state->bias++;",
          "410:         drift -= count;",
          "411:         if (drift > 0)",
          "412:             drift = 0;",
          "413:     }",
          "415:     state->drift = drift;",
          "416:     state->count = count;",
          "417: }",
          "419: static inline void put_vlc_symbol(PutBitContext *pb, VlcState *const state,",
          "420:                                   int v, int bits)",
          "421: {",
          "422:     int i, k, code;",
          "423:     v = fold(v - state->bias, bits);",
          "425:     i = state->count;",
          "426:     k = 0;",
          "427:     while (i < state->error_sum) { // FIXME: optimize",
          "428:         k++;",
          "429:         i += i;",
          "430:     }",
          "432:     av_assert2(k<=13);",
          "434: #if 0 // JPEG LS",
          "435:     if (k == 0 && 2 * state->drift <= -state->count)",
          "436:         code = v ^ (-1);",
          "437:     else",
          "438:         code = v;",
          "439: #else",
          "440:     code = v ^ ((2 * state->drift + state->count) >> 31);",
          "441: #endif",
          "443:     av_dlog(NULL, \"v:%d/%d bias:%d error:%d drift:%d count:%d k:%d\\n\", v, code,",
          "444:             state->bias, state->error_sum, state->drift, state->count, k);",
          "445:     set_sr_golomb(pb, code, k, 12, bits);",
          "447:     update_vlc_state(state, v);",
          "448: }",
          "450: static inline int get_vlc_symbol(GetBitContext *gb, VlcState *const state,",
          "451:                                  int bits)",
          "452: {",
          "453:     int k, i, v, ret;",
          "455:     i = state->count;",
          "456:     k = 0;",
          "457:     while (i < state->error_sum) { // FIXME: optimize",
          "458:         k++;",
          "459:         i += i;",
          "460:     }",
          "462:     assert(k <= 8);",
          "464:     v = get_sr_golomb(gb, k, 12, bits);",
          "465:     av_dlog(NULL, \"v:%d bias:%d error:%d drift:%d count:%d k:%d\",",
          "466:             v, state->bias, state->error_sum, state->drift, state->count, k);",
          "468: #if 0 // JPEG LS",
          "469:     if (k == 0 && 2 * state->drift <= -state->count)",
          "470:         v ^= (-1);",
          "471: #else",
          "472:     v ^= ((2 * state->drift + state->count) >> 31);",
          "473: #endif",
          "475:     ret = fold(v + state->bias, bits);",
          "477:     update_vlc_state(state, v);",
          "479:     return ret;",
          "480: }",
          "482: #if CONFIG_FFV1_ENCODER",
          "483: static av_always_inline int encode_line(FFV1Context *s, int w,",
          "484:                                         int16_t *sample[3],",
          "485:                                         int plane_index, int bits)",
          "486: {",
          "487:     PlaneContext *const p = &s->plane[plane_index];",
          "488:     RangeCoder *const c   = &s->c;",
          "489:     int x;",
          "490:     int run_index = s->run_index;",
          "491:     int run_count = 0;",
          "492:     int run_mode  = 0;",
          "494:     if (s->ac) {",
          "495:         if (c->bytestream_end - c->bytestream < w * 20) {",
          "496:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "497:             return -1;",
          "498:         }",
          "499:     } else {",
          "500:         if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < w * 4) {",
          "501:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "502:             return -1;",
          "503:         }",
          "504:     }",
          "506:     for (x = 0; x < w; x++) {",
          "507:         int diff, context;",
          "509:         context = get_context(p, sample[0] + x, sample[1] + x, sample[2] + x);",
          "510:         diff    = sample[0][x] - predict(sample[0] + x, sample[1] + x);",
          "512:         if (context < 0) {",
          "513:             context = -context;",
          "514:             diff    = -diff;",
          "515:         }",
          "517:         diff = fold(diff, bits);",
          "519:         if (s->ac) {",
          "520:             if (s->flags & CODEC_FLAG_PASS1) {",
          "521:                 put_symbol_inline(c, p->state[context], diff, 1, s->rc_stat,",
          "522:                                   s->rc_stat2[p->quant_table_index][context]);",
          "523:             } else {",
          "524:                 put_symbol_inline(c, p->state[context], diff, 1, NULL, NULL);",
          "525:             }",
          "526:         } else {",
          "527:             if (context == 0)",
          "528:                 run_mode = 1;",
          "530:             if (run_mode) {",
          "531:                 if (diff) {",
          "532:                     while (run_count >= 1 << ff_log2_run[run_index]) {",
          "533:                         run_count -= 1 << ff_log2_run[run_index];",
          "534:                         run_index++;",
          "535:                         put_bits(&s->pb, 1, 1);",
          "536:                     }",
          "538:                     put_bits(&s->pb, 1 + ff_log2_run[run_index], run_count);",
          "539:                     if (run_index)",
          "540:                         run_index--;",
          "541:                     run_count = 0;",
          "542:                     run_mode  = 0;",
          "543:                     if (diff > 0)",
          "544:                         diff--;",
          "545:                 } else {",
          "546:                     run_count++;",
          "547:                 }",
          "548:             }",
          "550:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "551:                     run_count, run_index, run_mode, x,",
          "552:                     (int)put_bits_count(&s->pb));",
          "554:             if (run_mode == 0)",
          "555:                 put_vlc_symbol(&s->pb, &p->vlc_state[context], diff, bits);",
          "556:         }",
          "557:     }",
          "558:     if (run_mode) {",
          "559:         while (run_count >= 1 << ff_log2_run[run_index]) {",
          "560:             run_count -= 1 << ff_log2_run[run_index];",
          "561:             run_index++;",
          "562:             put_bits(&s->pb, 1, 1);",
          "563:         }",
          "565:         if (run_count)",
          "566:             put_bits(&s->pb, 1, 1);",
          "567:     }",
          "568:     s->run_index = run_index;",
          "570:     return 0;",
          "571: }",
          "573: static void encode_plane(FFV1Context *s, uint8_t *src, int w, int h,",
          "574:                          int stride, int plane_index)",
          "575: {",
          "576:     int x, y, i;",
          "577:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "578:     int16_t *sample[3];",
          "579:     s->run_index = 0;",
          "581:     memset(s->sample_buffer, 0, ring_size * (w + 6) * sizeof(*s->sample_buffer));",
          "583:     for (y = 0; y < h; y++) {",
          "584:         for (i = 0; i < ring_size; i++)",
          "585:             sample[i] = s->sample_buffer + (w + 6) * ((h + i - y) % ring_size) + 3;",
          "587:         sample[0][-1]= sample[1][0  ];",
          "588:         sample[1][ w]= sample[1][w-1];",
          "590:         if (s->bits_per_raw_sample <= 8) {",
          "591:             for (x = 0; x < w; x++)",
          "592:                 sample[0][x] = src[x + stride * y];",
          "593:             encode_line(s, w, sample, plane_index, 8);",
          "594:         } else {",
          "595:             if (s->packed_at_lsb) {",
          "596:                 for (x = 0; x < w; x++) {",
          "597:                     sample[0][x] = ((uint16_t*)(src + stride*y))[x];",
          "598:                 }",
          "599:             } else {",
          "600:                 for (x = 0; x < w; x++) {",
          "601:                     sample[0][x] = ((uint16_t*)(src + stride*y))[x] >> (16 - s->bits_per_raw_sample);",
          "602:                 }",
          "603:             }",
          "604:             encode_line(s, w, sample, plane_index, s->bits_per_raw_sample);",
          "605:         }",
          "607:     }",
          "608: }",
          "610: static void encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])",
          "611: {",
          "612:     int x, y, p, i;",
          "613:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "614:     int16_t *sample[4][3];",
          "615:     int lbd    = s->avctx->bits_per_raw_sample <= 8;",
          "616:     int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;",
          "617:     int offset = 1 << bits;",
          "618:     s->run_index = 0;",
          "620:     memset(s->sample_buffer, 0, ring_size * 4 * (w + 6) * sizeof(*s->sample_buffer));",
          "622:     for (y = 0; y < h; y++) {",
          "623:         for (i = 0; i < ring_size; i++)",
          "624:             for (p = 0; p < 4; p++)",
          "625:                 sample[p][i]= s->sample_buffer + p*ring_size*(w+6) + ((h+i-y)%ring_size)*(w+6) + 3;",
          "627:         for (x = 0; x < w; x++) {",
          "628:             int b, g, r, av_uninit(a);",
          "629:             if (lbd) {",
          "630:                 unsigned v = *((uint32_t*)(src[0] + x*4 + stride[0]*y));",
          "631:                 b =  v        & 0xFF;",
          "632:                 g = (v >>  8) & 0xFF;",
          "633:                 r = (v >> 16) & 0xFF;",
          "634:                 a =  v >> 24;",
          "635:             } else {",
          "636:                 b = *((uint16_t*)(src[0] + x*2 + stride[0]*y));",
          "637:                 g = *((uint16_t*)(src[1] + x*2 + stride[1]*y));",
          "638:                 r = *((uint16_t*)(src[2] + x*2 + stride[2]*y));",
          "639:             }",
          "641:             b -= g;",
          "642:             r -= g;",
          "643:             g += (b + r) >> 2;",
          "644:             b += offset;",
          "645:             r += offset;",
          "647:             sample[0][0][x] = g;",
          "648:             sample[1][0][x] = b;",
          "649:             sample[2][0][x] = r;",
          "650:             sample[3][0][x] = a;",
          "651:         }",
          "652:         for (p = 0; p < 3 + s->transparency; p++) {",
          "653:             sample[p][0][-1] = sample[p][1][0  ];",
          "654:             sample[p][1][ w] = sample[p][1][w-1];",
          "655:             if (lbd)",
          "656:                 encode_line(s, w, sample[p], (p+1)/2, 9);",
          "657:             else",
          "658:                 encode_line(s, w, sample[p], (p+1)/2, bits+1);",
          "659:         }",
          "660:     }",
          "661: }",
          "663: static void write_quant_table(RangeCoder *c, int16_t *quant_table)",
          "664: {",
          "665:     int last = 0;",
          "666:     int i;",
          "667:     uint8_t state[CONTEXT_SIZE];",
          "668:     memset(state, 128, sizeof(state));",
          "670:     for (i = 1; i < 128; i++)",
          "671:         if (quant_table[i] != quant_table[i - 1]) {",
          "672:             put_symbol(c, state, i - last - 1, 0);",
          "673:             last = i;",
          "674:         }",
          "675:     put_symbol(c, state, i - last - 1, 0);",
          "676: }",
          "678: static void write_quant_tables(RangeCoder *c,",
          "679:                                int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "680: {",
          "681:     int i;",
          "682:     for (i = 0; i < 5; i++)",
          "683:         write_quant_table(c, quant_table[i]);",
          "684: }",
          "686: static void write_header(FFV1Context *f)",
          "687: {",
          "688:     uint8_t state[CONTEXT_SIZE];",
          "689:     int i, j;",
          "690:     RangeCoder *const c = &f->slice_context[0]->c;",
          "692:     memset(state, 128, sizeof(state));",
          "694:     if (f->version < 2) {",
          "695:         put_symbol(c, state, f->version, 0);",
          "696:         put_symbol(c, state, f->ac, 0);",
          "697:         if (f->ac > 1) {",
          "698:             for (i = 1; i < 256; i++)",
          "699:                 put_symbol(c, state,",
          "700:                            f->state_transition[i] - c->one_state[i], 1);",
          "701:         }",
          "702:         put_symbol(c, state, f->colorspace, 0); //YUV cs type",
          "703:         if (f->version > 0)",
          "704:             put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "705:         put_rac(c, state, f->chroma_planes);",
          "706:         put_symbol(c, state, f->chroma_h_shift, 0);",
          "707:         put_symbol(c, state, f->chroma_v_shift, 0);",
          "708:         put_rac(c, state, f->transparency);",
          "710:         write_quant_tables(c, f->quant_table);",
          "711:     } else if (f->version < 3) {",
          "712:         put_symbol(c, state, f->slice_count, 0);",
          "713:         for (i = 0; i < f->slice_count; i++) {",
          "714:             FFV1Context *fs = f->slice_context[i];",
          "715:             put_symbol(c, state,",
          "716:                        (fs->slice_x      + 1) * f->num_h_slices / f->width, 0);",
          "717:             put_symbol(c, state,",
          "718:                        (fs->slice_y      + 1) * f->num_v_slices / f->height, 0);",
          "719:             put_symbol(c, state,",
          "720:                        (fs->slice_width  + 1) * f->num_h_slices / f->width - 1,",
          "721:                        0);",
          "722:             put_symbol(c, state,",
          "723:                        (fs->slice_height + 1) * f->num_v_slices / f->height - 1,",
          "724:                        0);",
          "725:             for (j = 0; j < f->plane_count; j++) {",
          "726:                 put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "727:                 av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "728:             }",
          "729:         }",
          "730:     }",
          "731: }",
          "735: static av_cold int common_init(AVCodecContext *avctx)",
          "",
          "[Added Lines]",
          "40: #include \"ffv1.h\"",
          "42: av_cold int ffv1_common_init(AVCodecContext *avctx)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "756:     return 0;",
          "757: }",
          "760: {",
          "761:     int j;",
          "",
          "[Removed Lines]",
          "759: static int init_slice_state(FFV1Context *f, FFV1Context *fs)",
          "",
          "[Added Lines]",
          "66: int ffv1_init_slice_state(FFV1Context *f, FFV1Context *fs)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "790:     return 0;",
          "791: }",
          "794:     int i;",
          "795:     for (i = 0; i < f->slice_count; i++) {",
          "796:         FFV1Context *fs = f->slice_context[i];",
          "798:             return -1;",
          "799:     }",
          "800:     return 0;",
          "801: }",
          "804: {",
          "805:     int i;",
          "",
          "[Removed Lines]",
          "793: static int init_slices_state(FFV1Context *f) {",
          "797:         if (init_slice_state(f, fs) < 0)",
          "803: static av_cold int init_slice_contexts(FFV1Context *f)",
          "",
          "[Added Lines]",
          "100: int ffv1_init_slices_state(FFV1Context *f) {",
          "104:         if (ffv1_init_slice_state(f, fs) < 0)",
          "110: av_cold int ffv1_init_slice_contexts(FFV1Context *f)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "830:     return 0;",
          "831: }",
          "834: {",
          "835:     int i;",
          "",
          "[Removed Lines]",
          "833: static int allocate_initial_states(FFV1Context *f)",
          "",
          "[Added Lines]",
          "140: int ffv1_allocate_initial_states(FFV1Context *f)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "845:     return 0;",
          "846: }",
          "918: {",
          "958:                 }",
          "959:             }",
          "960:         }",
          "963: }",
          "966: {",
          "968:     FFV1Context *s = avctx->priv_data;",
          "1106:         }",
          "1107:     }",
          "1136:         }",
          "1137:     }",
          "1726:     return 0;",
          "1727: }",
          "",
          "[Removed Lines]",
          "848: #if CONFIG_FFV1_ENCODER",
          "849: static int write_extra_header(FFV1Context *f)",
          "850: {",
          "851:     RangeCoder *const c = &f->c;",
          "852:     uint8_t state[CONTEXT_SIZE];",
          "853:     int i, j, k;",
          "854:     uint8_t state2[32][CONTEXT_SIZE];",
          "855:     unsigned v;",
          "857:     memset(state2, 128, sizeof(state2));",
          "858:     memset(state, 128, sizeof(state));",
          "860:     f->avctx->extradata = av_malloc(f->avctx->extradata_size = 10000 +",
          "861:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32);",
          "862:     ff_init_range_encoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "863:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "865:     put_symbol(c, state, f->version, 0);",
          "866:     if (f->version > 2) {",
          "867:         if (f->version == 3)",
          "868:             f->minor_version = 2;",
          "869:         put_symbol(c, state, f->minor_version, 0);",
          "870:     }",
          "871:     put_symbol(c, state, f->ac, 0);",
          "872:     if (f->ac > 1)",
          "873:         for (i = 1; i < 256; i++)",
          "874:             put_symbol(c, state, f->state_transition[i] - c->one_state[i], 1);",
          "875:     put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "876:     put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "877:     put_rac(c, state, f->chroma_planes);",
          "878:     put_symbol(c, state, f->chroma_h_shift, 0);",
          "879:     put_symbol(c, state, f->chroma_v_shift, 0);",
          "880:     put_rac(c, state, f->transparency);",
          "881:     put_symbol(c, state, f->num_h_slices - 1, 0);",
          "882:     put_symbol(c, state, f->num_v_slices - 1, 0);",
          "884:     put_symbol(c, state, f->quant_table_count, 0);",
          "885:     for (i = 0; i < f->quant_table_count; i++)",
          "886:         write_quant_tables(c, f->quant_tables[i]);",
          "888:     for (i = 0; i < f->quant_table_count; i++) {",
          "889:         for (j = 0; j < f->context_count[i] * CONTEXT_SIZE; j++)",
          "890:             if (f->initial_states[i] && f->initial_states[i][0][j] != 128)",
          "891:                 break;",
          "892:         if (j < f->context_count[i] * CONTEXT_SIZE) {",
          "893:             put_rac(c, state, 1);",
          "894:             for (j = 0; j < f->context_count[i]; j++)",
          "895:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "896:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "897:                     put_symbol(c, state2[k],",
          "898:                                (int8_t)(f->initial_states[i][j][k] - pred), 1);",
          "899:                 }",
          "900:         } else {",
          "901:             put_rac(c, state, 0);",
          "902:         }",
          "903:     }",
          "905:     if (f->version > 2) {",
          "906:         put_symbol(c, state, f->ec, 0);",
          "907:     }",
          "909:     f->avctx->extradata_size = ff_rac_terminate(c);",
          "910:     v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, f->avctx->extradata, f->avctx->extradata_size);",
          "911:     AV_WL32(f->avctx->extradata + f->avctx->extradata_size, v);",
          "912:     f->avctx->extradata_size += 4;",
          "914:     return 0;",
          "915: }",
          "917: static int sort_stt(FFV1Context *s, uint8_t stt[256])",
          "919:     int i, i2, changed, print = 0;",
          "921:     do {",
          "922:         changed = 0;",
          "923:         for (i = 12; i < 244; i++) {",
          "924:             for (i2 = i + 1; i2 < 245 && i2 < i + 4; i2++) {",
          "926: #define COST(old, new)                                      \\",
          "927:     s->rc_stat[old][0] * -log2((256 - (new)) / 256.0) +     \\",
          "928:     s->rc_stat[old][1] * -log2((new)         / 256.0)",
          "930: #define COST2(old, new)                         \\",
          "931:     COST(old, new) + COST(256 - (old), 256 - (new))",
          "933:                 double size0 = COST2(i,  i) + COST2(i2, i2);",
          "934:                 double sizeX = COST2(i, i2) + COST2(i2, i);",
          "935:                 if (sizeX < size0 && i != 128 && i2 != 128) {",
          "936:                     int j;",
          "937:                     FFSWAP(int, stt[i], stt[i2]);",
          "938:                     FFSWAP(int, s->rc_stat[i][0], s->rc_stat[i2][0]);",
          "939:                     FFSWAP(int, s->rc_stat[i][1], s->rc_stat[i2][1]);",
          "940:                     if (i != 256 - i2) {",
          "941:                         FFSWAP(int, stt[256 - i], stt[256 - i2]);",
          "942:                         FFSWAP(int, s->rc_stat[256 - i][0], s->rc_stat[256 - i2][0]);",
          "943:                         FFSWAP(int, s->rc_stat[256 - i][1], s->rc_stat[256 - i2][1]);",
          "944:                     }",
          "945:                     for (j = 1; j < 256; j++) {",
          "946:                         if (stt[j] == i)",
          "947:                             stt[j] = i2;",
          "948:                         else if (stt[j] == i2)",
          "949:                             stt[j] = i;",
          "950:                         if (i != 256 - i2) {",
          "951:                             if (stt[256 - j] == 256 - i)",
          "952:                                 stt[256 - j] = 256 - i2;",
          "953:                             else if (stt[256 - j] == 256 - i2)",
          "954:                                 stt[256 - j] = 256 - i;",
          "955:                         }",
          "956:                     }",
          "957:                     print = changed = 1;",
          "961:     } while (changed);",
          "962:     return print;",
          "965: static av_cold int encode_init(AVCodecContext *avctx)",
          "967:     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "969:     int i, j, k, m;",
          "971:     common_init(avctx);",
          "973:     s->version = 0;",
          "975:     if ((avctx->flags & (CODEC_FLAG_PASS1|CODEC_FLAG_PASS2)) || avctx->slices>1)",
          "976:         s->version = FFMAX(s->version, 2);",
          "978:     if (avctx->level == 3) {",
          "979:         s->version = 3;",
          "980:     }",
          "982:     if (s->ec < 0) {",
          "983:         s->ec = (s->version >= 3);",
          "984:     }",
          "986:     if (s->version >= 2 && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {",
          "987:         av_log(avctx, AV_LOG_ERROR, \"Version 2 needed for requested features but version 2 is experimental and not enabled\\n\");",
          "988:         return AVERROR_INVALIDDATA;",
          "989:     }",
          "991:     s->ac = avctx->coder_type > 0 ? 2 : 0;",
          "993:     s->plane_count = 3;",
          "994:     switch(avctx->pix_fmt) {",
          "995:     case AV_PIX_FMT_YUV444P9:",
          "996:     case AV_PIX_FMT_YUV422P9:",
          "997:     case AV_PIX_FMT_YUV420P9:",
          "998:         if (!avctx->bits_per_raw_sample)",
          "999:             s->bits_per_raw_sample = 9;",
          "1000:     case AV_PIX_FMT_YUV444P10:",
          "1001:     case AV_PIX_FMT_YUV420P10:",
          "1002:     case AV_PIX_FMT_YUV422P10:",
          "1003:         s->packed_at_lsb = 1;",
          "1004:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "1005:             s->bits_per_raw_sample = 10;",
          "1006:     case AV_PIX_FMT_GRAY16:",
          "1007:     case AV_PIX_FMT_YUV444P16:",
          "1008:     case AV_PIX_FMT_YUV422P16:",
          "1009:     case AV_PIX_FMT_YUV420P16:",
          "1010:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {",
          "1011:             s->bits_per_raw_sample = 16;",
          "1012:         } else if (!s->bits_per_raw_sample) {",
          "1013:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "1014:         }",
          "1015:         if (s->bits_per_raw_sample <= 8) {",
          "1016:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "1017:             return AVERROR_INVALIDDATA;",
          "1018:         }",
          "1019:         if (!s->ac && avctx->coder_type == -1) {",
          "1020:             av_log(avctx, AV_LOG_INFO, \"bits_per_raw_sample > 8, forcing coder 1\\n\");",
          "1021:             s->ac = 2;",
          "1022:         }",
          "1023:         if (!s->ac) {",
          "1024:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "1025:             return AVERROR_INVALIDDATA;",
          "1026:         }",
          "1027:         s->version = FFMAX(s->version, 1);",
          "1028:     case AV_PIX_FMT_GRAY8:",
          "1029:     case AV_PIX_FMT_YUV444P:",
          "1030:     case AV_PIX_FMT_YUV440P:",
          "1031:     case AV_PIX_FMT_YUV422P:",
          "1032:     case AV_PIX_FMT_YUV420P:",
          "1033:     case AV_PIX_FMT_YUV411P:",
          "1034:     case AV_PIX_FMT_YUV410P:",
          "1035:         s->chroma_planes = desc->nb_components < 3 ? 0 : 1;",
          "1036:         s->colorspace = 0;",
          "1037:         break;",
          "1038:     case AV_PIX_FMT_YUVA444P:",
          "1039:     case AV_PIX_FMT_YUVA422P:",
          "1040:     case AV_PIX_FMT_YUVA420P:",
          "1041:         s->chroma_planes = 1;",
          "1042:         s->colorspace = 0;",
          "1043:         s->transparency = 1;",
          "1044:         break;",
          "1045:     case AV_PIX_FMT_RGB32:",
          "1046:         s->colorspace = 1;",
          "1047:         s->transparency = 1;",
          "1048:         break;",
          "1049:     case AV_PIX_FMT_0RGB32:",
          "1050:         s->colorspace = 1;",
          "1051:         break;",
          "1052:     case AV_PIX_FMT_GBRP9:",
          "1053:         if (!avctx->bits_per_raw_sample)",
          "1054:             s->bits_per_raw_sample = 9;",
          "1055:     case AV_PIX_FMT_GBRP10:",
          "1056:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "1057:             s->bits_per_raw_sample = 10;",
          "1058:     case AV_PIX_FMT_GBRP12:",
          "1059:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "1060:             s->bits_per_raw_sample = 12;",
          "1061:     case AV_PIX_FMT_GBRP14:",
          "1062:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "1063:             s->bits_per_raw_sample = 14;",
          "1064:         else if (!s->bits_per_raw_sample)",
          "1065:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "1066:         s->colorspace = 1;",
          "1067:         s->chroma_planes = 1;",
          "1068:         s->version = FFMAX(s->version, 1);",
          "1069:         break;",
          "1070:     default:",
          "1071:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "1072:         return AVERROR_INVALIDDATA;",
          "1073:     }",
          "1074:     if (s->transparency) {",
          "1075:         av_log(avctx, AV_LOG_WARNING, \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");",
          "1076:     }",
          "1077:     if (avctx->context_model > 1U) {",
          "1078:         av_log(avctx, AV_LOG_ERROR, \"Invalid context model %d, valid values are 0 and 1\\n\", avctx->context_model);",
          "1079:         return AVERROR(EINVAL);",
          "1080:     }",
          "1082:     if (s->ac > 1)",
          "1083:         for (i = 1; i < 256; i++)",
          "1084:             s->state_transition[i] = ver2_state[i];",
          "1086:     for (i = 0; i < 256; i++) {",
          "1087:         s->quant_table_count = 2;",
          "1088:         if (s->bits_per_raw_sample <= 8) {",
          "1089:             s->quant_tables[0][0][i]=           quant11[i];",
          "1090:             s->quant_tables[0][1][i]=        11*quant11[i];",
          "1091:             s->quant_tables[0][2][i]=     11*11*quant11[i];",
          "1092:             s->quant_tables[1][0][i]=           quant11[i];",
          "1093:             s->quant_tables[1][1][i]=        11*quant11[i];",
          "1094:             s->quant_tables[1][2][i]=     11*11*quant5 [i];",
          "1095:             s->quant_tables[1][3][i]=   5*11*11*quant5 [i];",
          "1096:             s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i];",
          "1097:         } else {",
          "1098:             s->quant_tables[0][0][i]=           quant9_10bit[i];",
          "1099:             s->quant_tables[0][1][i]=        11*quant9_10bit[i];",
          "1100:             s->quant_tables[0][2][i]=     11*11*quant9_10bit[i];",
          "1101:             s->quant_tables[1][0][i]=           quant9_10bit[i];",
          "1102:             s->quant_tables[1][1][i]=        11*quant9_10bit[i];",
          "1103:             s->quant_tables[1][2][i]=     11*11*quant5_10bit[i];",
          "1104:             s->quant_tables[1][3][i]=   5*11*11*quant5_10bit[i];",
          "1105:             s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i];",
          "1108:     s->context_count[0] = (11 * 11 * 11        + 1) / 2;",
          "1109:     s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;",
          "1110:     memcpy(s->quant_table, s->quant_tables[avctx->context_model],",
          "1111:            sizeof(s->quant_table));",
          "1113:     for (i = 0; i < s->plane_count; i++) {",
          "1114:         PlaneContext *const p = &s->plane[i];",
          "1116:         memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));",
          "1117:         p->quant_table_index = avctx->context_model;",
          "1118:         p->context_count     = s->context_count[p->quant_table_index];",
          "1119:     }",
          "1121:     if (allocate_initial_states(s) < 0)",
          "1122:         return AVERROR(ENOMEM);",
          "1124:     avctx->coded_frame = &s->picture;",
          "1125:     if (!s->transparency)",
          "1126:         s->plane_count = 2;",
          "1127:     avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);",
          "1128:     s->picture_number = 0;",
          "1130:     if (avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) {",
          "1131:         for (i = 0; i < s->quant_table_count; i++) {",
          "1132:             s->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "1133:                                         sizeof(*s->rc_stat2[i]));",
          "1134:             if (!s->rc_stat2[i])",
          "1135:                 return AVERROR(ENOMEM);",
          "1138:     if (avctx->stats_in) {",
          "1139:         char *p = avctx->stats_in;",
          "1140:         uint8_t best_state[256][256];",
          "1141:         int gob_count = 0;",
          "1142:         char *next;",
          "1144:         av_assert0(s->version >= 2);",
          "1146:         for (;;) {",
          "1147:             for (j = 0; j < 256; j++)",
          "1148:                 for (i = 0; i < 2; i++) {",
          "1149:                     s->rc_stat[j][i] = strtol(p, &next, 0);",
          "1150:                     if (next == p) {",
          "1151:                         av_log(avctx, AV_LOG_ERROR,",
          "1152:                                \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);",
          "1153:                         return -1;",
          "1154:                     }",
          "1155:                     p = next;",
          "1156:                 }",
          "1157:             for (i = 0; i < s->quant_table_count; i++)",
          "1158:                 for (j = 0; j < s->context_count[i]; j++) {",
          "1159:                     for (k = 0; k < 32; k++)",
          "1160:                         for (m = 0; m < 2; m++) {",
          "1161:                             s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);",
          "1162:                             if (next == p) {",
          "1163:                                 av_log(avctx, AV_LOG_ERROR,",
          "1164:                                        \"2Pass file invalid at %d %d %d %d [%s]\\n\",",
          "1165:                                        i, j, k, m, p);",
          "1166:                                 return AVERROR_INVALIDDATA;",
          "1167:                             }",
          "1168:                             p = next;",
          "1169:                         }",
          "1170:                 }",
          "1171:             gob_count = strtol(p, &next, 0);",
          "1172:             if (next == p || gob_count <= 0) {",
          "1173:                 av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");",
          "1174:                 return AVERROR_INVALIDDATA;",
          "1175:             }",
          "1176:             p = next;",
          "1177:             while (*p == '\\n' || *p == ' ')",
          "1178:                 p++;",
          "1179:             if (p[0] == 0)",
          "1180:                 break;",
          "1181:         }",
          "1182:         sort_stt(s, s->state_transition);",
          "1184:         find_best_state(best_state, s->state_transition);",
          "1186:         for (i = 0; i < s->quant_table_count; i++) {",
          "1187:             for (j = 0; j < s->context_count[i]; j++)",
          "1188:                 for (k = 0; k < 32; k++) {",
          "1189:                     double p = 128;",
          "1190:                     if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) {",
          "1191:                         p = 256.0 * s->rc_stat2[i][j][k][1] /",
          "1192:                             (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]);",
          "1193:                     }",
          "1194:                     s->initial_states[i][j][k] =",
          "1195:                         best_state[av_clip(round(p), 1, 255)][av_clip((s->rc_stat2[i][j][k][0] +",
          "1196:                                                                        s->rc_stat2[i][j][k][1]) /",
          "1197:                                                                       gob_count, 0, 255)];",
          "1198:                 }",
          "1199:         }",
          "1200:     }",
          "1202:     if (s->version > 1) {",
          "1203:         for (s->num_v_slices = 2; s->num_v_slices < 9; s->num_v_slices++) {",
          "1204:             for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) {",
          "1205:                 if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= 64 || !avctx->slices)",
          "1206:                     goto slices_ok;",
          "1207:             }",
          "1208:         }",
          "1209:         av_log(avctx, AV_LOG_ERROR, \"Unsupported number %d of slices requested, please specify a supported number with -slices (ex:4,6,9,12,16, ...)\\n\", avctx->slices);",
          "1210:         return -1;",
          "1211:         slices_ok:",
          "1212:         write_extra_header(s);",
          "1213:     }",
          "1215:     if (init_slice_contexts(s) < 0)",
          "1216:         return -1;",
          "1217:     if (init_slices_state(s) < 0)",
          "1218:         return -1;",
          "1220: #define STATS_OUT_SIZE 1024 * 1024 * 6",
          "1221:     if (avctx->flags & CODEC_FLAG_PASS1) {",
          "1222:         avctx->stats_out = av_mallocz(STATS_OUT_SIZE);",
          "1223:         for (i = 0; i < s->quant_table_count; i++)",
          "1224:             for (j = 0; j < s->slice_count; j++) {",
          "1225:                 FFV1Context *sf = s->slice_context[j];",
          "1226:                 av_assert0(!sf->rc_stat2[i]);",
          "1227:                 sf->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "1228:                                              sizeof(*sf->rc_stat2[i]));",
          "1229:                 if (!sf->rc_stat2[i])",
          "1230:                     return AVERROR(ENOMEM);",
          "1231:             }",
          "1232:     }",
          "1234:     return 0;",
          "1235: }",
          "1240: static void clear_slice_state(FFV1Context *f, FFV1Context *fs)",
          "1241: {",
          "1242:     int i, j;",
          "1244:         for (i = 0; i < f->plane_count; i++) {",
          "1245:             PlaneContext *p = &fs->plane[i];",
          "1247:             p->interlace_bit_state[0] = 128;",
          "1248:             p->interlace_bit_state[1] = 128;",
          "1250:             if (fs->ac) {",
          "1251:                 if (f->initial_states[p->quant_table_index]) {",
          "1252:                     memcpy(p->state, f->initial_states[p->quant_table_index],",
          "1253:                            CONTEXT_SIZE * p->context_count);",
          "1254:                 } else",
          "1255:                     memset(p->state, 128, CONTEXT_SIZE * p->context_count);",
          "1256:             } else {",
          "1257:                 for (j = 0; j < p->context_count; j++) {",
          "1258:                     p->vlc_state[j].drift     = 0;",
          "1259:                     p->vlc_state[j].error_sum = 4; // FFMAX((RANGE + 32)/64, 2);",
          "1260:                     p->vlc_state[j].bias      = 0;",
          "1261:                     p->vlc_state[j].count     = 1;",
          "1262:                 }",
          "1263:             }",
          "1264:         }",
          "1265: }",
          "1267: #if CONFIG_FFV1_ENCODER",
          "1269: static void encode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "1270: {",
          "1271:     RangeCoder *c = &fs->c;",
          "1272:     uint8_t state[CONTEXT_SIZE];",
          "1273:     int j;",
          "1274:     memset(state, 128, sizeof(state));",
          "1276:     put_symbol(c, state, (fs->slice_x     +1)*f->num_h_slices / f->width   , 0);",
          "1277:     put_symbol(c, state, (fs->slice_y     +1)*f->num_v_slices / f->height  , 0);",
          "1278:     put_symbol(c, state, (fs->slice_width +1)*f->num_h_slices / f->width -1, 0);",
          "1279:     put_symbol(c, state, (fs->slice_height+1)*f->num_v_slices / f->height-1, 0);",
          "1280:     for (j=0; j<f->plane_count; j++) {",
          "1281:         put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "1282:         av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "1283:     }",
          "1284:     if (!f->picture.interlaced_frame) put_symbol(c, state, 3, 0);",
          "1285:     else                             put_symbol(c, state, 1 + !f->picture.top_field_first, 0);",
          "1286:     put_symbol(c, state, f->picture.sample_aspect_ratio.num, 0);",
          "1287:     put_symbol(c, state, f->picture.sample_aspect_ratio.den, 0);",
          "1288: }",
          "1290: static int encode_slice(AVCodecContext *c, void *arg)",
          "1291: {",
          "1292:     FFV1Context *fs  = *(void **)arg;",
          "1293:     FFV1Context *f   = fs->avctx->priv_data;",
          "1294:     int width        = fs->slice_width;",
          "1295:     int height       = fs->slice_height;",
          "1296:     int x            = fs->slice_x;",
          "1297:     int y            = fs->slice_y;",
          "1298:     AVFrame *const p = &f->picture;",
          "1299:     const int ps     = av_pix_fmt_desc_get(c->pix_fmt)->comp[0].step_minus1 + 1;",
          "1301:     if (p->key_frame)",
          "1302:         clear_slice_state(f, fs);",
          "1303:     if (f->version > 2) {",
          "1304:         encode_slice_header(f, fs);",
          "1305:     }",
          "1306:     if (!fs->ac) {",
          "1307:         if (f->version > 2)",
          "1308:             put_rac(&fs->c, (uint8_t[]) {129}, 0);",
          "1309:         fs->ac_byte_count = f->version > 2 || (!x&&!y) ? ff_rac_terminate(&fs->c) : 0;",
          "1310:         init_put_bits(&fs->pb, fs->c.bytestream_start + fs->ac_byte_count, fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count);",
          "1311:     }",
          "1313:     if (f->colorspace == 0) {",
          "1314:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "1315:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "1316:         const int cx            = x >> f->chroma_h_shift;",
          "1317:         const int cy            = y >> f->chroma_v_shift;",
          "1319:         encode_plane(fs, p->data[0] + ps*x + y*p->linesize[0], width, height, p->linesize[0], 0);",
          "1321:         if (f->chroma_planes) {",
          "1322:             encode_plane(fs, p->data[1] + ps*cx+cy*p->linesize[1], chroma_width, chroma_height, p->linesize[1], 1);",
          "1323:             encode_plane(fs, p->data[2] + ps*cx+cy*p->linesize[2], chroma_width, chroma_height, p->linesize[2], 1);",
          "1324:         }",
          "1325:         if (fs->transparency)",
          "1326:             encode_plane(fs, p->data[3] + ps*x + y*p->linesize[3], width, height, p->linesize[3], 2);",
          "1327:     } else {",
          "1328:         uint8_t *planes[3] = {p->data[0] + ps*x + y*p->linesize[0],",
          "1329:                               p->data[1] + ps*x + y*p->linesize[1],",
          "1330:                               p->data[2] + ps*x + y*p->linesize[2]};",
          "1331:         encode_rgb_frame(fs, planes, width, height, p->linesize);",
          "1332:     }",
          "1333:     emms_c();",
          "1335:     return 0;",
          "1336: }",
          "1338: static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,",
          "1339:                         const AVFrame *pict, int *got_packet)",
          "1340: {",
          "1341:     FFV1Context *f      = avctx->priv_data;",
          "1342:     RangeCoder *const c = &f->slice_context[0]->c;",
          "1343:     AVFrame *const p    = &f->picture;",
          "1344:     int used_count      = 0;",
          "1345:     uint8_t keystate    = 128;",
          "1346:     uint8_t *buf_p;",
          "1347:     int i, ret;",
          "1349:     if ((ret = ff_alloc_packet2(avctx, pkt, avctx->width*avctx->height*((8*2+1+1)*4)/8",
          "1350:                                             + FF_MIN_BUFFER_SIZE)) < 0)",
          "1351:         return ret;",
          "1353:     ff_init_range_encoder(c, pkt->data, pkt->size);",
          "1354:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "1357:     p->pict_type = AV_PICTURE_TYPE_I;",
          "1359:     if (avctx->gop_size == 0 || f->picture_number % avctx->gop_size == 0) {",
          "1360:         put_rac(c, &keystate, 1);",
          "1361:         p->key_frame = 1;",
          "1362:         f->gob_count++;",
          "1363:         write_header(f);",
          "1364:     } else {",
          "1365:         put_rac(c, &keystate, 0);",
          "1366:         p->key_frame = 0;",
          "1367:     }",
          "1369:     if (f->ac > 1) {",
          "1370:         int i;",
          "1371:         for (i = 1; i < 256; i++) {",
          "1372:             c->one_state[i]        = f->state_transition[i];",
          "1373:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "1374:         }",
          "1375:     }",
          "1377:     for (i = 1; i < f->slice_count; i++) {",
          "1378:         FFV1Context *fs = f->slice_context[i];",
          "1379:         uint8_t *start  = pkt->data + (pkt->size - used_count) * (int64_t)i / f->slice_count;",
          "1380:         int len         = pkt->size / f->slice_count;",
          "1381:         ff_init_range_encoder(&fs->c, start, len);",
          "1382:     }",
          "1383:     avctx->execute(avctx, encode_slice, &f->slice_context[0], NULL,",
          "1384:                    f->slice_count, sizeof(void *));",
          "1386:     buf_p = pkt->data;",
          "1387:     for (i = 0; i < f->slice_count; i++) {",
          "1388:         FFV1Context *fs = f->slice_context[i];",
          "1389:         int bytes;",
          "1391:         if (fs->ac) {",
          "1392:             uint8_t state=129;",
          "1393:             put_rac(&fs->c, &state, 0);",
          "1394:             bytes = ff_rac_terminate(&fs->c);",
          "1395:         } else {",
          "1396:             flush_put_bits(&fs->pb); // FIXME: nicer padding",
          "1397:             bytes = fs->ac_byte_count + (put_bits_count(&fs->pb) + 7)/8;",
          "1398:         }",
          "1399:         if (i > 0 || f->version > 2) {",
          "1400:             av_assert0(bytes < pkt->size / f->slice_count);",
          "1401:             memmove(buf_p, fs->c.bytestream_start, bytes);",
          "1402:             av_assert0(bytes < (1 << 24));",
          "1403:             AV_WB24(buf_p + bytes, bytes);",
          "1404:             bytes += 3;",
          "1405:         }",
          "1406:         if (f->ec) {",
          "1407:             unsigned v;",
          "1408:             buf_p[bytes++] = 0;",
          "1409:             v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, bytes);",
          "1410:             AV_WL32(buf_p + bytes, v); bytes += 4;",
          "1411:         }",
          "1412:         buf_p += bytes;",
          "1413:     }",
          "1415:     if ((avctx->flags & CODEC_FLAG_PASS1) && (f->picture_number & 31) == 0) {",
          "1416:         int j, k, m;",
          "1417:         char *p   = avctx->stats_out;",
          "1418:         char *end = p + STATS_OUT_SIZE;",
          "1420:         memset(f->rc_stat, 0, sizeof(f->rc_stat));",
          "1421:         for (i = 0; i < f->quant_table_count; i++)",
          "1422:             memset(f->rc_stat2[i], 0, f->context_count[i] * sizeof(*f->rc_stat2[i]));",
          "1424:         for (j = 0; j < f->slice_count; j++) {",
          "1425:             FFV1Context *fs = f->slice_context[j];",
          "1426:             for (i = 0; i < 256; i++) {",
          "1427:                 f->rc_stat[i][0] += fs->rc_stat[i][0];",
          "1428:                 f->rc_stat[i][1] += fs->rc_stat[i][1];",
          "1429:             }",
          "1430:             for (i = 0; i < f->quant_table_count; i++) {",
          "1431:                 for (k = 0; k < f->context_count[i]; k++)",
          "1432:                     for (m = 0; m < 32; m++) {",
          "1433:                         f->rc_stat2[i][k][m][0] += fs->rc_stat2[i][k][m][0];",
          "1434:                         f->rc_stat2[i][k][m][1] += fs->rc_stat2[i][k][m][1];",
          "1435:                     }",
          "1436:             }",
          "1437:         }",
          "1439:         for (j = 0; j < 256; j++) {",
          "1440:             snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "1441:                      f->rc_stat[j][0], f->rc_stat[j][1]);",
          "1442:             p += strlen(p);",
          "1443:         }",
          "1444:         snprintf(p, end - p, \"\\n\");",
          "1446:         for (i = 0; i < f->quant_table_count; i++) {",
          "1447:             for (j = 0; j < f->context_count[i]; j++)",
          "1448:                 for (m = 0; m < 32; m++) {",
          "1449:                     snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "1450:                              f->rc_stat2[i][j][m][0], f->rc_stat2[i][j][m][1]);",
          "1451:                     p += strlen(p);",
          "1452:                 }",
          "1453:         }",
          "1454:         snprintf(p, end - p, \"%d\\n\", f->gob_count);",
          "1455:     } else if (avctx->flags & CODEC_FLAG_PASS1)",
          "1456:         avctx->stats_out[0] = '\\0';",
          "1458:     f->picture_number++;",
          "1459:     pkt->size   = buf_p - pkt->data;",
          "1460:     pkt->flags |= AV_PKT_FLAG_KEY * p->key_frame;",
          "1463:     return 0;",
          "1464: }",
          "1468: static av_cold int common_end(AVCodecContext *avctx)",
          "1469: {",
          "1470:     FFV1Context *s = avctx->priv_data;",
          "1471:     int i, j;",
          "1473:     if (avctx->codec->decode && s->picture.data[0])",
          "1474:         avctx->release_buffer(avctx, &s->picture);",
          "1475:     if (avctx->codec->decode && s->last_picture.data[0])",
          "1476:         avctx->release_buffer(avctx, &s->last_picture);",
          "1478:     for (j = 0; j < s->slice_count; j++) {",
          "1479:         FFV1Context *fs = s->slice_context[j];",
          "1480:         for (i = 0; i < s->plane_count; i++) {",
          "1481:             PlaneContext *p = &fs->plane[i];",
          "1483:             av_freep(&p->state);",
          "1484:             av_freep(&p->vlc_state);",
          "1485:         }",
          "1486:         av_freep(&fs->sample_buffer);",
          "1487:     }",
          "1489:     av_freep(&avctx->stats_out);",
          "1490:     for (j = 0; j < s->quant_table_count; j++) {",
          "1491:         av_freep(&s->initial_states[j]);",
          "1492:         for (i = 0; i < s->slice_count; i++) {",
          "1493:             FFV1Context *sf = s->slice_context[i];",
          "1494:             av_freep(&sf->rc_stat2[j]);",
          "1495:         }",
          "1496:         av_freep(&s->rc_stat2[j]);",
          "1497:     }",
          "1499:     for (i = 0; i < s->slice_count; i++)",
          "1500:         av_freep(&s->slice_context[i]);",
          "1502:     return 0;",
          "1503: }",
          "1505: static av_always_inline void decode_line(FFV1Context *s, int w,",
          "1506:                                          int16_t *sample[2],",
          "1507:                                          int plane_index, int bits)",
          "1508: {",
          "1509:     PlaneContext *const p = &s->plane[plane_index];",
          "1510:     RangeCoder *const c   = &s->c;",
          "1511:     int x;",
          "1512:     int run_count = 0;",
          "1513:     int run_mode  = 0;",
          "1514:     int run_index = s->run_index;",
          "1516:     for (x = 0; x < w; x++) {",
          "1517:         int diff, context, sign;",
          "1519:         context = get_context(p, sample[1] + x, sample[0] + x, sample[1] + x);",
          "1520:         if (context < 0) {",
          "1521:             context = -context;",
          "1522:             sign    = 1;",
          "1523:         } else",
          "1524:             sign = 0;",
          "1526:         av_assert2(context < p->context_count);",
          "1528:         if (s->ac) {",
          "1529:             diff = get_symbol_inline(c, p->state[context], 1);",
          "1530:         } else {",
          "1531:             if (context == 0 && run_mode == 0)",
          "1532:                 run_mode = 1;",
          "1534:             if (run_mode) {",
          "1535:                 if (run_count == 0 && run_mode == 1) {",
          "1536:                     if (get_bits1(&s->gb)) {",
          "1537:                         run_count = 1 << ff_log2_run[run_index];",
          "1538:                         if (x + run_count <= w)",
          "1539:                             run_index++;",
          "1540:                     } else {",
          "1541:                         if (ff_log2_run[run_index])",
          "1542:                             run_count = get_bits(&s->gb, ff_log2_run[run_index]);",
          "1543:                         else",
          "1544:                             run_count = 0;",
          "1545:                         if (run_index)",
          "1546:                             run_index--;",
          "1547:                         run_mode = 2;",
          "1548:                     }",
          "1549:                 }",
          "1550:                 run_count--;",
          "1551:                 if (run_count < 0) {",
          "1552:                     run_mode  = 0;",
          "1553:                     run_count = 0;",
          "1554:                     diff      = get_vlc_symbol(&s->gb, &p->vlc_state[context],",
          "1555:                                                bits);",
          "1556:                     if (diff >= 0)",
          "1557:                         diff++;",
          "1558:                 } else",
          "1559:                     diff = 0;",
          "1560:             } else",
          "1561:                 diff = get_vlc_symbol(&s->gb, &p->vlc_state[context], bits);",
          "1563:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "1564:                     run_count, run_index, run_mode, x, get_bits_count(&s->gb));",
          "1565:         }",
          "1567:         if (sign)",
          "1568:             diff = -diff;",
          "1570:         sample[1][x] = (predict(sample[1] + x, sample[0] + x) + diff) &",
          "1571:                        ((1 << bits) - 1);",
          "1572:     }",
          "1573:     s->run_index = run_index;",
          "1574: }",
          "1576: static void decode_plane(FFV1Context *s, uint8_t *src,",
          "1577:                          int w, int h, int stride, int plane_index)",
          "1578: {",
          "1579:     int x, y;",
          "1580:     int16_t *sample[2];",
          "1581:     sample[0] = s->sample_buffer + 3;",
          "1582:     sample[1] = s->sample_buffer + w + 6 + 3;",
          "1584:     s->run_index = 0;",
          "1586:     memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));",
          "1588:     for (y = 0; y < h; y++) {",
          "1589:         int16_t *temp = sample[0]; // FIXME: try a normal buffer",
          "1591:         sample[0] = sample[1];",
          "1592:         sample[1] = temp;",
          "1594:         sample[1][-1] = sample[0][0];",
          "1595:         sample[0][w]  = sample[0][w - 1];",
          "1598:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "1599:             decode_line(s, w, sample, plane_index, 8);",
          "1600:             for (x = 0; x < w; x++)",
          "1601:                 src[x + stride * y] = sample[1][x];",
          "1602:         } else {",
          "1603:             decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);",
          "1604:             if (s->packed_at_lsb) {",
          "1605:                 for (x = 0; x < w; x++) {",
          "1606:                     ((uint16_t*)(src + stride*y))[x] = sample[1][x];",
          "1607:                 }",
          "1608:             } else {",
          "1609:                 for (x = 0; x < w; x++) {",
          "1610:                     ((uint16_t*)(src + stride*y))[x] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "1611:                 }",
          "1612:             }",
          "1613:         }",
          "1615:     }",
          "1616: }",
          "1618: static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])",
          "1619: {",
          "1620:     int x, y, p;",
          "1621:     int16_t *sample[4][2];",
          "1622:     int lbd  = s->avctx->bits_per_raw_sample <= 8;",
          "1623:     int bits = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;",
          "1624:     int offset = 1 << bits;",
          "1625:     for (x = 0; x < 4; x++) {",
          "1626:         sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;",
          "1627:         sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;",
          "1628:     }",
          "1630:     s->run_index = 0;",
          "1632:     memset(s->sample_buffer, 0, 8*(w+6)*sizeof(*s->sample_buffer));",
          "1634:     for (y = 0; y < h; y++) {",
          "1635:         for (p = 0; p < 3 + s->transparency; p++) {",
          "1636:             int16_t *temp = sample[p][0]; // FIXME: try a normal buffer",
          "1638:             sample[p][0] = sample[p][1];",
          "1639:             sample[p][1] = temp;",
          "1641:             sample[p][1][-1]= sample[p][0][0  ];",
          "1642:             sample[p][0][ w]= sample[p][0][w-1];",
          "1643:             if (lbd)",
          "1644:                 decode_line(s, w, sample[p], (p+1)/2, 9);",
          "1645:             else",
          "1646:                 decode_line(s, w, sample[p], (p+1)/2, bits+1);",
          "1647:         }",
          "1648:         for (x = 0; x < w; x++) {",
          "1649:             int g = sample[0][1][x];",
          "1650:             int b = sample[1][1][x];",
          "1651:             int r = sample[2][1][x];",
          "1652:             int a = sample[3][1][x];",
          "1654:             b -= offset;",
          "1655:             r -= offset;",
          "1656:             g -= (b + r) >> 2;",
          "1657:             b += g;",
          "1658:             r += g;",
          "1660:             if (lbd)",
          "1662:             else {",
          "1666:             }",
          "1667:         }",
          "1668:     }",
          "1669: }",
          "1671: static int decode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "1672: {",
          "1673:     RangeCoder *c = &fs->c;",
          "1674:     uint8_t state[CONTEXT_SIZE];",
          "1675:     unsigned ps, i, context_count;",
          "1676:     memset(state, 128, sizeof(state));",
          "1678:     av_assert0(f->version > 2);",
          "1680:     fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;",
          "1681:     fs->slice_y      =  get_symbol(c, state, 0)      * f->height;",
          "1682:     fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "1683:     fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "1685:     fs->slice_x /= f->num_h_slices;",
          "1686:     fs->slice_y /= f->num_v_slices;",
          "1687:     fs->slice_width  = fs->slice_width /f->num_h_slices - fs->slice_x;",
          "1688:     fs->slice_height = fs->slice_height/f->num_v_slices - fs->slice_y;",
          "1689:     if ((unsigned)fs->slice_width > f->width || (unsigned)fs->slice_height > f->height)",
          "1690:         return -1;",
          "1691:     if (    (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width",
          "1692:          || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "1693:         return -1;",
          "1695:     for (i = 0; i < f->plane_count; i++) {",
          "1696:         PlaneContext * const p = &fs->plane[i];",
          "1697:         int idx = get_symbol(c, state, 0);",
          "1698:         if (idx > (unsigned)f->quant_table_count) {",
          "1699:             av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");",
          "1700:             return -1;",
          "1701:         }",
          "1702:         p->quant_table_index = idx;",
          "1703:         memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));",
          "1704:         context_count = f->context_count[idx];",
          "1706:         if (p->context_count < context_count) {",
          "1707:             av_freep(&p->state);",
          "1708:             av_freep(&p->vlc_state);",
          "1709:         }",
          "1710:         p->context_count = context_count;",
          "1711:     }",
          "1713:     ps = get_symbol(c, state, 0);",
          "1714:     if (ps == 1) {",
          "1715:         f->picture.interlaced_frame = 1;",
          "1716:         f->picture.top_field_first  = 1;",
          "1717:     } else if (ps == 2) {",
          "1718:         f->picture.interlaced_frame = 1;",
          "1719:         f->picture.top_field_first  = 0;",
          "1720:     } else if (ps == 3) {",
          "1721:         f->picture.interlaced_frame = 0;",
          "1722:     }",
          "1723:     f->picture.sample_aspect_ratio.num = get_symbol(c, state, 0);",
          "1724:     f->picture.sample_aspect_ratio.den = get_symbol(c, state, 0);",
          "1729: static int decode_slice(AVCodecContext *c, void *arg)",
          "1730: {",
          "1731:     FFV1Context *fs  = *(void **)arg;",
          "1732:     FFV1Context *f   = fs->avctx->priv_data;",
          "1733:     int width, height, x, y;",
          "1734:     const int ps      = av_pix_fmt_desc_get(c->pix_fmt)->comp[0].step_minus1 + 1;",
          "1735:     AVFrame * const p = &f->picture;",
          "1737:     if (f->version > 2) {",
          "1738:         if (init_slice_state(f, fs) < 0)",
          "1739:             return AVERROR(ENOMEM);",
          "1740:         if (decode_slice_header(f, fs) < 0) {",
          "1741:             fs->slice_damaged = 1;",
          "1742:             return AVERROR_INVALIDDATA;",
          "1743:         }",
          "1744:     }",
          "1745:     if (init_slice_state(f, fs) < 0)",
          "1746:         return AVERROR(ENOMEM);",
          "1747:     if (f->picture.key_frame)",
          "1748:         clear_slice_state(f, fs);",
          "1749:     width = fs->slice_width;",
          "1750:     height= fs->slice_height;",
          "1751:     x= fs->slice_x;",
          "1752:     y= fs->slice_y;",
          "1754:     if (!fs->ac) {",
          "1755:         if (f->version == 3 && f->minor_version > 1 || f->version > 3)",
          "1756:             get_rac(&fs->c, (uint8_t[]) {129});",
          "1757:         fs->ac_byte_count = f->version > 2 || (!x&&!y) ? fs->c.bytestream - fs->c.bytestream_start - 1 : 0;",
          "1758:         init_get_bits(&fs->gb,",
          "1759:                       fs->c.bytestream_start + fs->ac_byte_count,",
          "1760:                       (fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count) * 8);",
          "1761:     }",
          "1763:     av_assert1(width && height);",
          "1764:     if (f->colorspace == 0) {",
          "1765:         const int chroma_width  = -((-width)  >> f->chroma_h_shift);",
          "1766:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "1767:         const int cx            = x >> f->chroma_h_shift;",
          "1768:         const int cy            = y >> f->chroma_v_shift;",
          "1769:         decode_plane(fs, p->data[0] + ps*x + y*p->linesize[0], width, height, p->linesize[0], 0);",
          "1771:         if (f->chroma_planes) {",
          "1772:             decode_plane(fs, p->data[1] + ps*cx+cy*p->linesize[1], chroma_width, chroma_height, p->linesize[1], 1);",
          "1773:             decode_plane(fs, p->data[2] + ps*cx+cy*p->linesize[2], chroma_width, chroma_height, p->linesize[2], 1);",
          "1774:         }",
          "1775:         if (fs->transparency)",
          "1776:             decode_plane(fs, p->data[3] + ps*x + y*p->linesize[3], width, height, p->linesize[3], 2);",
          "1777:     } else {",
          "1778:         uint8_t *planes[3] = {p->data[0] + ps*x + y*p->linesize[0],",
          "1779:                               p->data[1] + ps*x + y*p->linesize[1],",
          "1780:                               p->data[2] + ps*x + y*p->linesize[2]};",
          "1781:         decode_rgb_frame(fs, planes, width, height, p->linesize);",
          "1782:     }",
          "1783:     if (fs->ac && f->version > 2) {",
          "1784:         int v;",
          "1785:         get_rac(&fs->c, (uint8_t[]) {129});",
          "1786:         v = fs->c.bytestream_end - fs->c.bytestream - 2 - 5*f->ec;",
          "1787:         if (v) {",
          "1788:             av_log(f->avctx, AV_LOG_ERROR, \"bytestream end mismatching by %d\\n\", v);",
          "1789:             fs->slice_damaged = 1;",
          "1790:         }",
          "1791:     }",
          "1793:     emms_c();",
          "1795:     return 0;",
          "1796: }",
          "1798: static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)",
          "1799: {",
          "1800:     int v;",
          "1801:     int i = 0;",
          "1802:     uint8_t state[CONTEXT_SIZE];",
          "1804:     memset(state, 128, sizeof(state));",
          "1806:     for (v = 0; i < 128; v++) {",
          "1807:         unsigned len = get_symbol(c, state, 0) + 1;",
          "1809:         if (len > 128 - i)",
          "1810:             return -1;",
          "1812:         while (len--) {",
          "1813:             quant_table[i] = scale * v;",
          "1814:             i++;",
          "1815:         }",
          "1816:     }",
          "1818:     for (i = 1; i < 128; i++)",
          "1819:         quant_table[256 - i] = -quant_table[i];",
          "1820:     quant_table[128] = -quant_table[127];",
          "1822:     return 2 * v - 1;",
          "1823: }",
          "1825: static int read_quant_tables(RangeCoder *c,",
          "1826:                              int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "1827: {",
          "1828:     int i;",
          "1829:     int context_count = 1;",
          "1831:     for (i = 0; i < 5; i++) {",
          "1832:         context_count *= read_quant_table(c, quant_table[i], context_count);",
          "1833:         if (context_count > 32768U) {",
          "1834:             return -1;",
          "1835:         }",
          "1836:     }",
          "1837:     return (context_count + 1) / 2;",
          "1838: }",
          "1840: static int read_extra_header(FFV1Context *f)",
          "1841: {",
          "1842:     RangeCoder *const c = &f->c;",
          "1843:     uint8_t state[CONTEXT_SIZE];",
          "1844:     int i, j, k;",
          "1845:     uint8_t state2[32][CONTEXT_SIZE];",
          "1847:     memset(state2, 128, sizeof(state2));",
          "1848:     memset(state, 128, sizeof(state));",
          "1850:     ff_init_range_decoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "1851:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "1853:     f->version = get_symbol(c, state, 0);",
          "1854:     if (f->version > 2) {",
          "1855:         c->bytestream_end -= 4;",
          "1856:         f->minor_version = get_symbol(c, state, 0);",
          "1857:     }",
          "1858:     f->ac = f->avctx->coder_type = get_symbol(c, state, 0);",
          "1859:     if (f->ac > 1)",
          "1860:         for (i = 1; i < 256; i++)",
          "1861:             f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "1863:     f->colorspace                 = get_symbol(c, state, 0); // YUV cs type",
          "1864:     f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "1865:     f->chroma_planes  = get_rac(c, state);",
          "1866:     f->chroma_h_shift = get_symbol(c, state, 0);",
          "1867:     f->chroma_v_shift = get_symbol(c, state, 0);",
          "1868:     f->transparency = get_rac(c, state);",
          "1869:     f->plane_count  = 2 + f->transparency;",
          "1870:     f->num_h_slices = 1 + get_symbol(c, state, 0);",
          "1871:     f->num_v_slices = 1 + get_symbol(c, state, 0);",
          "1873:     if (f->num_h_slices > (unsigned)f->width ||",
          "1874:         f->num_v_slices > (unsigned)f->height) {",
          "1875:         av_log(f->avctx, AV_LOG_ERROR, \"too many slices\\n\");",
          "1876:         return -1;",
          "1877:     }",
          "1879:     f->quant_table_count = get_symbol(c, state, 0);",
          "1881:     if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)",
          "1882:         return -1;",
          "1884:     for (i = 0; i < f->quant_table_count; i++) {",
          "1885:         f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);",
          "1886:         if (f->context_count[i] < 0) {",
          "1887:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "1888:             return -1;",
          "1889:         }",
          "1890:     }",
          "1892:     if (allocate_initial_states(f) < 0)",
          "1893:         return AVERROR(ENOMEM);",
          "1895:     for (i = 0; i < f->quant_table_count; i++)",
          "1896:         if (get_rac(c, state))",
          "1897:             for (j = 0; j < f->context_count[i]; j++)",
          "1898:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "1899:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "1900:                     f->initial_states[i][j][k] =",
          "1901:                         (pred + get_symbol(c, state2[k], 1)) & 0xFF;",
          "1902:                 }",
          "1904:     if (f->version > 2) {",
          "1905:         f->ec = get_symbol(c, state, 0);",
          "1906:     }",
          "1908:     if (f->version > 2) {",
          "1909:         unsigned v;",
          "1910:         v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, f->avctx->extradata, f->avctx->extradata_size);",
          "1911:         if (v) {",
          "1912:             av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", v);",
          "1913:             return AVERROR_INVALIDDATA;",
          "1914:         }",
          "1915:     }",
          "1917:     return 0;",
          "1918: }",
          "1920: static int read_header(FFV1Context *f)",
          "1921: {",
          "1922:     uint8_t state[CONTEXT_SIZE];",
          "1923:     int i, j, context_count = -1; //-1 to avoid warning",
          "1924:     RangeCoder *const c = &f->slice_context[0]->c;",
          "1926:     memset(state, 128, sizeof(state));",
          "1928:     if (f->version < 2) {",
          "1929:         unsigned v= get_symbol(c, state, 0);",
          "1930:         if (v >= 2) {",
          "1931:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
          "1932:             return AVERROR_INVALIDDATA;",
          "1933:         }",
          "1934:         f->version = v;",
          "1935:         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "1936:         if (f->ac > 1)",
          "1937:             for (i = 1; i < 256; i++)",
          "1938:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "1939:         f->colorspace = get_symbol(c, state, 0); // YUV cs type",
          "1940:         if (f->version > 0)",
          "1941:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "1942:         f->chroma_planes  = get_rac(c, state);",
          "1943:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "1944:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "1945:         f->transparency   = get_rac(c, state);",
          "1946:         f->plane_count    = 2 + f->transparency;",
          "1947:     }",
          "1949:     if (f->colorspace == 0) {",
          "1950:         if (!f->transparency && !f->chroma_planes) {",
          "1951:             if (f->avctx->bits_per_raw_sample <= 8)",
          "1952:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;",
          "1953:             else",
          "1954:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;",
          "1955:         } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {",
          "1956:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "1957:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;",
          "1958:             case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;",
          "1959:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;",
          "1960:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;",
          "1961:             case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;",
          "1962:             case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;",
          "1963:             default:",
          "1964:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "1965:                 return -1;",
          "1966:             }",
          "1967:         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {",
          "1968:             switch(16*f->chroma_h_shift + f->chroma_v_shift) {",
          "1969:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;",
          "1970:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;",
          "1971:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;",
          "1972:             default:",
          "1973:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "1974:                 return -1;",
          "1975:             }",
          "1976:         } else if (f->avctx->bits_per_raw_sample == 9) {",
          "1977:             f->packed_at_lsb = 1;",
          "1978:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "1979:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;",
          "1980:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;",
          "1981:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;",
          "1982:             default:",
          "1983:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "1984:                 return -1;",
          "1985:             }",
          "1986:         } else if (f->avctx->bits_per_raw_sample == 10) {",
          "1987:             f->packed_at_lsb = 1;",
          "1988:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "1989:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;",
          "1990:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;",
          "1991:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;",
          "1992:             default:",
          "1993:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "1994:                 return -1;",
          "1995:             }",
          "1996:         } else {",
          "1997:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "1998:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;",
          "1999:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;",
          "2000:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;",
          "2001:             default:",
          "2002:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "2003:                 return -1;",
          "2004:             }",
          "2005:         }",
          "2006:     } else if (f->colorspace == 1) {",
          "2007:         if (f->chroma_h_shift || f->chroma_v_shift) {",
          "2008:             av_log(f->avctx, AV_LOG_ERROR,",
          "2009:                    \"chroma subsampling not supported in this colorspace\\n\");",
          "2010:             return -1;",
          "2011:         }",
          "2012:         if (     f->avctx->bits_per_raw_sample ==  9)",
          "2013:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;",
          "2014:         else if (f->avctx->bits_per_raw_sample == 10)",
          "2015:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
          "2016:         else if (f->avctx->bits_per_raw_sample == 12)",
          "2017:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;",
          "2018:         else if (f->avctx->bits_per_raw_sample == 14)",
          "2019:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;",
          "2020:         else",
          "2021:         if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "2022:         else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;",
          "2023:     } else {",
          "2024:         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");",
          "2025:         return -1;",
          "2026:     }",
          "2028:     av_dlog(f->avctx, \"%d %d %d\\n\",",
          "2029:             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);",
          "2031:     if (f->version < 2) {",
          "2032:         context_count = read_quant_tables(c, f->quant_table);",
          "2033:         if (context_count < 0) {",
          "2034:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "2035:             return -1;",
          "2036:         }",
          "2037:     } else if (f->version < 3) {",
          "2038:         f->slice_count = get_symbol(c, state, 0);",
          "2039:     } else {",
          "2040:         const uint8_t *p = c->bytestream_end;",
          "2041:         for (f->slice_count = 0; f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start; f->slice_count++) {",
          "2042:             int trailer = 3 + 5*!!f->ec;",
          "2043:             int size = AV_RB24(p-trailer);",
          "2044:             if (size + trailer > p - c->bytestream_start)",
          "2045:                 break;",
          "2046:             p -= size + trailer;",
          "2047:         }",
          "2048:     }",
          "2049:     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {",
          "2050:         av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);",
          "2051:         return -1;",
          "2052:     }",
          "2054:     for (j = 0; j < f->slice_count; j++) {",
          "2055:         FFV1Context *fs = f->slice_context[j];",
          "2056:         fs->ac = f->ac;",
          "2057:         fs->packed_at_lsb = f->packed_at_lsb;",
          "2059:         fs->slice_damaged = 0;",
          "2061:         if (f->version == 2) {",
          "2062:             fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;",
          "2063:             fs->slice_y      =  get_symbol(c, state, 0)      * f->height;",
          "2064:             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "2065:             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "2067:             fs->slice_x     /= f->num_h_slices;",
          "2068:             fs->slice_y     /= f->num_v_slices;",
          "2069:             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;",
          "2070:             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "2071:             if ((unsigned)fs->slice_width  > f->width ||",
          "2072:                 (unsigned)fs->slice_height > f->height)",
          "2073:                 return -1;",
          "2074:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "2075:                 (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "2076:                 return -1;",
          "2077:         }",
          "2079:         for (i = 0; i < f->plane_count; i++) {",
          "2080:             PlaneContext *const p = &fs->plane[i];",
          "2082:             if (f->version == 2) {",
          "2083:                 int idx = get_symbol(c, state, 0);",
          "2084:                 if (idx > (unsigned)f->quant_table_count) {",
          "2085:                     av_log(f->avctx, AV_LOG_ERROR,",
          "2086:                            \"quant_table_index out of range\\n\");",
          "2087:                     return -1;",
          "2088:                 }",
          "2089:                 p->quant_table_index = idx;",
          "2090:                 memcpy(p->quant_table, f->quant_tables[idx],",
          "2091:                        sizeof(p->quant_table));",
          "2092:                 context_count = f->context_count[idx];",
          "2093:             } else {",
          "2094:                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));",
          "2095:             }",
          "2097:             if (f->version <= 2) {",
          "2098:                 av_assert0(context_count >= 0);",
          "2099:                 if (p->context_count < context_count) {",
          "2100:                     av_freep(&p->state);",
          "2101:                     av_freep(&p->vlc_state);",
          "2102:                 }",
          "2103:                 p->context_count = context_count;",
          "2104:             }",
          "2105:         }",
          "2106:     }",
          "2107:     return 0;",
          "2108: }",
          "2110: static av_cold int decode_init(AVCodecContext *avctx)",
          "2111: {",
          "2112:     FFV1Context *f = avctx->priv_data;",
          "2114:     common_init(avctx);",
          "2116:     if (avctx->extradata && read_extra_header(f) < 0)",
          "2117:         return -1;",
          "2119:     if (init_slice_contexts(f) < 0)",
          "2120:         return -1;",
          "2122:     return 0;",
          "2123: }",
          "2125: static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)",
          "2126: {",
          "2127:     const uint8_t *buf  = avpkt->data;",
          "2128:     int buf_size        = avpkt->size;",
          "2129:     FFV1Context *f      = avctx->priv_data;",
          "2130:     RangeCoder *const c = &f->slice_context[0]->c;",
          "2131:     AVFrame *const p    = &f->picture;",
          "2132:     int i;",
          "2133:     uint8_t keystate = 128;",
          "2134:     const uint8_t *buf_p;",
          "2136:     AVFrame *picture = data;",
          "2139:     if (p->data[0])",
          "2140:         avctx->release_buffer(avctx, p);",
          "2142:     ff_init_range_decoder(c, buf, buf_size);",
          "2143:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "2145:     p->pict_type = AV_PICTURE_TYPE_I; // FIXME: I vs. P",
          "2146:     if (get_rac(c, &keystate)) {",
          "2147:         p->key_frame = 1;",
          "2148:         f->key_frame_ok = 0;",
          "2149:         if (read_header(f) < 0)",
          "2150:             return -1;",
          "2151:         f->key_frame_ok = 1;",
          "2152:     } else {",
          "2153:         if (!f->key_frame_ok) {",
          "2154:             av_log(avctx, AV_LOG_ERROR, \"Cant decode non keyframe without valid keyframe\\n\");",
          "2155:             return AVERROR_INVALIDDATA;",
          "2156:         }",
          "2157:         p->key_frame= 0;",
          "2158:     }",
          "2160:     p->reference = 3; //for error concealment",
          "2161:     if (avctx->get_buffer(avctx, p) < 0) {",
          "2162:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "2163:         return -1;",
          "2164:     }",
          "2166:     if (avctx->debug&FF_DEBUG_PICT_INFO)",
          "2167:         av_log(avctx, AV_LOG_DEBUG, \"ver:%d keyframe:%d coder:%d ec:%d slices:%d bps:%d\\n\",",
          "2168:                f->version, p->key_frame, f->ac, f->ec, f->slice_count, f->avctx->bits_per_raw_sample);",
          "2170:     buf_p = buf + buf_size;",
          "2171:     for (i = f->slice_count - 1; i >= 0; i--) {",
          "2172:         FFV1Context *fs = f->slice_context[i];",
          "2173:         int trailer = 3 + 5*!!f->ec;",
          "2174:         int v;",
          "2176:         if (i || f->version>2) v = AV_RB24(buf_p-trailer)+trailer;",
          "2177:         else                   v = buf_p - c->bytestream_start;",
          "2178:         if (buf_p - c->bytestream_start < v) {",
          "2179:             av_log(avctx, AV_LOG_ERROR, \"Slice pointer chain broken\\n\");",
          "2180:             return -1;",
          "2181:         }",
          "2182:         buf_p -= v;",
          "2184:         if (f->ec) {",
          "2185:             unsigned crc = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, v);",
          "2186:             if (crc) {",
          "2187:                 int64_t ts = avpkt->pts != AV_NOPTS_VALUE ? avpkt->pts : avpkt->dts;",
          "2188:                 av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\", crc);",
          "2189:                 if (ts != AV_NOPTS_VALUE && avctx->pkt_timebase.num) {",
          "2190:                     av_log(f->avctx, AV_LOG_ERROR, \"at %f seconds\\n\", ts*av_q2d(avctx->pkt_timebase));",
          "2191:                 } else if (ts != AV_NOPTS_VALUE) {",
          "2192:                     av_log(f->avctx, AV_LOG_ERROR, \"at %\"PRId64\"\\n\", ts);",
          "2193:                 } else {",
          "2194:                     av_log(f->avctx, AV_LOG_ERROR, \"\\n\");",
          "2195:                 }",
          "2196:                 fs->slice_damaged = 1;",
          "2197:             }",
          "2198:         }",
          "2200:         if (i) {",
          "2201:             ff_init_range_decoder(&fs->c, buf_p, v);",
          "2202:         } else",
          "2203:             fs->c.bytestream_end = (uint8_t *)(buf_p + v);",
          "2204:     }",
          "2206:     avctx->execute(avctx, decode_slice, &f->slice_context[0], NULL, f->slice_count, sizeof(void*));",
          "2208:     for (i=f->slice_count-1; i>=0; i--) {",
          "2209:         FFV1Context *fs= f->slice_context[i];",
          "2210:         int j;",
          "2211:         if (fs->slice_damaged && f->last_picture.data[0]) {",
          "2212:             uint8_t *dst[4], *src[4];",
          "2213:             for (j=0; j<4; j++) {",
          "2214:                 int sh = (j==1 || j==2) ? f->chroma_h_shift : 0;",
          "2215:                 int sv = (j==1 || j==2) ? f->chroma_v_shift : 0;",
          "2216:                 dst[j] = f->picture     .data[j] + f->picture     .linesize[j]*",
          "2217:                          (fs->slice_y>>sv) + (fs->slice_x>>sh);",
          "2218:                 src[j] = f->last_picture.data[j] + f->last_picture.linesize[j]*",
          "2219:                          (fs->slice_y>>sv) + (fs->slice_x>>sh);",
          "2220:             }",
          "2221:             av_image_copy(dst, f->picture.linesize, (const uint8_t **)src, f->last_picture.linesize,",
          "2222:                           avctx->pix_fmt, fs->slice_width, fs->slice_height);",
          "2223:         }",
          "2224:     }",
          "2226:     f->picture_number++;",
          "2231:     FFSWAP(AVFrame, f->picture, f->last_picture);",
          "2233:     return buf_size;",
          "2234: }",
          "2236: AVCodec ff_ffv1_decoder = {",
          "2237:     .name           = \"ffv1\",",
          "2238:     .type           = AVMEDIA_TYPE_VIDEO,",
          "2239:     .id             = AV_CODEC_ID_FFV1,",
          "2240:     .priv_data_size = sizeof(FFV1Context),",
          "2241:     .init           = decode_init,",
          "2242:     .close          = common_end,",
          "2243:     .decode         = decode_frame,",
          "2244:     .capabilities   = CODEC_CAP_DR1 /*| CODEC_CAP_DRAW_HORIZ_BAND*/ |",
          "2245:                       CODEC_CAP_SLICE_THREADS,",
          "2246:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "2247: };",
          "2249: #if CONFIG_FFV1_ENCODER",
          "2251: #define OFFSET(x) offsetof(FFV1Context, x)",
          "2252: #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM",
          "2253: static const AVOption options[] = {",
          "2254:     { \"slicecrc\",        \"Protect slices with CRCs\",               OFFSET(ec),              AV_OPT_TYPE_INT, {.i64 = -1}, -1, 1, VE},",
          "2255: {NULL}",
          "2256: };",
          "2258: static const AVClass class = {",
          "2259:     .class_name = \"ffv1 encoder\",",
          "2260:     .item_name  = av_default_item_name,",
          "2261:     .option     = options,",
          "2262:     .version    = LIBAVUTIL_VERSION_INT,",
          "2263: };",
          "2265: static const AVCodecDefault ffv1_defaults[] = {",
          "2266:     { \"coder\",                \"-1\" },",
          "2267:     { NULL },",
          "2268: };",
          "2270: AVCodec ff_ffv1_encoder = {",
          "2271:     .name           = \"ffv1\",",
          "2272:     .type           = AVMEDIA_TYPE_VIDEO,",
          "2273:     .id             = AV_CODEC_ID_FFV1,",
          "2274:     .priv_data_size = sizeof(FFV1Context),",
          "2275:     .init           = encode_init,",
          "2276:     .encode2        = encode_frame,",
          "2277:     .close          = common_end,",
          "2278:     .capabilities   = CODEC_CAP_SLICE_THREADS,",
          "2279:     .defaults       = ffv1_defaults,",
          "2280:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "2281:         AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUV444P,",
          "2282:         AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV411P,",
          "2283:         AV_PIX_FMT_YUV410P, AV_PIX_FMT_0RGB32, AV_PIX_FMT_RGB32, AV_PIX_FMT_YUV420P16,",
          "2284:         AV_PIX_FMT_YUV422P16, AV_PIX_FMT_YUV444P16, AV_PIX_FMT_YUV444P9, AV_PIX_FMT_YUV422P9,",
          "2285:         AV_PIX_FMT_YUV420P9, AV_PIX_FMT_YUV420P10, AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV444P10,",
          "2286:         AV_PIX_FMT_GRAY16, AV_PIX_FMT_GRAY8, AV_PIX_FMT_GBRP9, AV_PIX_FMT_GBRP10,",
          "2287:         AV_PIX_FMT_GBRP12, AV_PIX_FMT_GBRP14,",
          "2288:         AV_PIX_FMT_NONE",
          "2289:     },",
          "2290:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "2291:     .priv_class     = &class,",
          "2292: };",
          "2293: #endif",
          "",
          "[Added Lines]",
          "155: void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs)",
          "157:     int i, j;",
          "159:         for (i = 0; i < f->plane_count; i++) {",
          "160:             PlaneContext *p = &fs->plane[i];",
          "162:             p->interlace_bit_state[0] = 128;",
          "163:             p->interlace_bit_state[1] = 128;",
          "165:             if (fs->ac) {",
          "166:                 if (f->initial_states[p->quant_table_index]) {",
          "167:                     memcpy(p->state, f->initial_states[p->quant_table_index],",
          "168:                            CONTEXT_SIZE * p->context_count);",
          "169:                 } else",
          "170:                     memset(p->state, 128, CONTEXT_SIZE * p->context_count);",
          "171:             } else {",
          "172:                 for (j = 0; j < p->context_count; j++) {",
          "173:                     p->vlc_state[j].drift     = 0;",
          "174:                     p->vlc_state[j].error_sum = 4; // FFMAX((RANGE + 32)/64, 2);",
          "175:                     p->vlc_state[j].bias      = 0;",
          "176:                     p->vlc_state[j].count     = 1;",
          "183: av_cold int ffv1_common_end(AVCodecContext *avctx)",
          "186:     int i, j;",
          "188:     if (avctx->codec->decode && s->picture.data[0])",
          "189:         avctx->release_buffer(avctx, &s->picture);",
          "190:     if (avctx->codec->decode && s->last_picture.data[0])",
          "191:         avctx->release_buffer(avctx, &s->last_picture);",
          "193:     for (j = 0; j < s->slice_count; j++) {",
          "194:         FFV1Context *fs = s->slice_context[j];",
          "195:         for (i = 0; i < s->plane_count; i++) {",
          "196:             PlaneContext *p = &fs->plane[i];",
          "198:             av_freep(&p->state);",
          "199:             av_freep(&p->vlc_state);",
          "201:         av_freep(&fs->sample_buffer);",
          "204:     av_freep(&avctx->stats_out);",
          "205:     for (j = 0; j < s->quant_table_count; j++) {",
          "206:         av_freep(&s->initial_states[j]);",
          "207:         for (i = 0; i < s->slice_count; i++) {",
          "208:             FFV1Context *sf = s->slice_context[i];",
          "209:             av_freep(&sf->rc_stat2[j]);",
          "211:         av_freep(&s->rc_stat2[j]);",
          "214:     for (i = 0; i < s->slice_count; i++)",
          "215:         av_freep(&s->slice_context[i]);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1.h||libavcodec/ffv1.h": [
          "File: libavcodec/ffv1.h -> libavcodec/ffv1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #ifndef AVCODEC_FFV1_H",
          "24: #define AVCODEC_FFV1_H",
          "31: #include \"libavutil/avassert.h\"",
          "32: #include \"libavutil/crc.h\"",
          "33: #include \"libavutil/opt.h\"",
          "34: #include \"libavutil/imgutils.h\"",
          "35: #include \"libavutil/pixdesc.h\"",
          "36: #include \"libavutil/timer.h\"",
          "37: #include \"avcodec.h\"",
          "38: #include \"internal.h\"",
          "39: #include \"dsputil.h\"",
          "40: #include \"rangecoder.h\"",
          "41: #include \"golomb.h\"",
          "42: #include \"mathops.h\"",
          "44: #ifdef __INTEL_COMPILER",
          "45: #undef av_flatten",
          "46: #define av_flatten",
          "47: #endif",
          "49: #define MAX_PLANES 4",
          "50: #define CONTEXT_SIZE 32",
          "52: #define MAX_QUANT_TABLES 8",
          "53: #define MAX_CONTEXT_INPUTS 5",
          "55: extern const uint8_t ff_log2_run[41];",
          "57: typedef struct VlcState {",
          "58:     int16_t drift;",
          "59:     uint16_t error_sum;",
          "60:     int8_t bias;",
          "61:     uint8_t count;",
          "62: } VlcState;",
          "64: typedef struct PlaneContext {",
          "65:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "66:     int quant_table_index;",
          "67:     int context_count;",
          "68:     uint8_t (*state)[CONTEXT_SIZE];",
          "69:     VlcState *vlc_state;",
          "70:     uint8_t interlace_bit_state[2];",
          "71: } PlaneContext;",
          "73: #define MAX_SLICES 256",
          "75: typedef struct FFV1Context {",
          "76:     AVClass *class;",
          "77:     AVCodecContext *avctx;",
          "78:     RangeCoder c;",
          "79:     GetBitContext gb;",
          "80:     PutBitContext pb;",
          "81:     uint64_t rc_stat[256][2];",
          "82:     uint64_t (*rc_stat2[MAX_QUANT_TABLES])[32][2];",
          "83:     int version;",
          "84:     int minor_version;",
          "85:     int width, height;",
          "86:     int chroma_h_shift, chroma_v_shift;",
          "87:     int chroma_planes;",
          "88:     int transparency;",
          "89:     int flags;",
          "90:     int picture_number;",
          "91:     AVFrame picture;",
          "92:     AVFrame last_picture;",
          "93:     int plane_count;",
          "94:     int ac;                              ///< 1=range coder <-> 0=golomb rice",
          "95:     int ac_byte_count;                   ///< number of bytes used for AC coding",
          "96:     PlaneContext plane[MAX_PLANES];",
          "97:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "98:     int16_t quant_tables[MAX_QUANT_TABLES][MAX_CONTEXT_INPUTS][256];",
          "99:     int context_count[MAX_QUANT_TABLES];",
          "100:     uint8_t state_transition[256];",
          "101:     uint8_t (*initial_states[MAX_QUANT_TABLES])[32];",
          "102:     int run_index;",
          "103:     int colorspace;",
          "104:     int16_t *sample_buffer;",
          "105:     int gob_count;",
          "106:     int packed_at_lsb;",
          "107:     int ec;",
          "108:     int slice_damaged;",
          "109:     int key_frame_ok;",
          "111:     int quant_table_count;",
          "113:     DSPContext dsp;",
          "115:     struct FFV1Context *slice_context[MAX_SLICES];",
          "116:     int slice_count;",
          "117:     int num_v_slices;",
          "118:     int num_h_slices;",
          "119:     int slice_width;",
          "120:     int slice_height;",
          "121:     int slice_x;",
          "122:     int slice_y;",
          "123:     int bits_per_raw_sample;",
          "124: } FFV1Context;",
          "126: int ffv1_common_init(AVCodecContext *avctx);",
          "127: int ffv1_init_slice_state(FFV1Context *f, FFV1Context *fs);",
          "128: int ffv1_init_slices_state(FFV1Context *f);",
          "129: int ffv1_init_slice_contexts(FFV1Context *f);",
          "130: int ffv1_allocate_initial_states(FFV1Context *f);",
          "131: void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs);",
          "132: int ffv1_common_end(AVCodecContext *avctx);",
          "134: static av_always_inline int fold(int diff, int bits)",
          "135: {",
          "136:     if (bits == 8)",
          "137:         diff = (int8_t)diff;",
          "138:     else {",
          "139:         diff +=  1 << (bits  - 1);",
          "140:         diff &= (1 <<  bits) - 1;",
          "141:         diff -=  1 << (bits  - 1);",
          "142:     }",
          "144:     return diff;",
          "145: }",
          "147: static inline int predict(int16_t *src, int16_t *last)",
          "148: {",
          "149:     const int LT = last[-1];",
          "150:     const int T  = last[0];",
          "151:     const int L  = src[-1];",
          "153:     return mid_pred(L, L + T - LT, T);",
          "154: }",
          "156: static inline int get_context(PlaneContext *p, int16_t *src,",
          "157:                               int16_t *last, int16_t *last2)",
          "158: {",
          "159:     const int LT = last[-1];",
          "160:     const int T  = last[0];",
          "161:     const int RT = last[1];",
          "162:     const int L  = src[-1];",
          "164:     if (p->quant_table[3][127]) {",
          "165:         const int TT = last2[0];",
          "166:         const int LL = src[-2];",
          "167:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "168:                p->quant_table[1][(LT - T) & 0xFF] +",
          "169:                p->quant_table[2][(T - RT) & 0xFF] +",
          "170:                p->quant_table[3][(LL - L) & 0xFF] +",
          "171:                p->quant_table[4][(TT - T) & 0xFF];",
          "172:     } else",
          "173:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "174:                p->quant_table[1][(LT - T) & 0xFF] +",
          "175:                p->quant_table[2][(T - RT) & 0xFF];",
          "176: }",
          "178: static inline void update_vlc_state(VlcState *const state, const int v)",
          "179: {",
          "180:     int drift = state->drift;",
          "181:     int count = state->count;",
          "182:     state->error_sum += FFABS(v);",
          "183:     drift            += v;",
          "185:     if (count == 128) { // FIXME: variable",
          "186:         count            >>= 1;",
          "187:         drift            >>= 1;",
          "188:         state->error_sum >>= 1;",
          "189:     }",
          "190:     count++;",
          "192:     if (drift <= -count) {",
          "193:         if (state->bias > -128)",
          "194:             state->bias--;",
          "196:         drift += count;",
          "197:         if (drift <= -count)",
          "198:             drift = -count + 1;",
          "199:     } else if (drift > 0) {",
          "200:         if (state->bias < 127)",
          "201:             state->bias++;",
          "203:         drift -= count;",
          "204:         if (drift > 0)",
          "205:             drift = 0;",
          "206:     }",
          "208:     state->drift = drift;",
          "209:     state->count = count;",
          "210: }",
          "",
          "---------------"
        ],
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"libavutil/crc.h\"",
          "30: #include \"libavutil/opt.h\"",
          "31: #include \"libavutil/imgutils.h\"",
          "32: #include \"libavutil/pixdesc.h\"",
          "33: #include \"libavutil/timer.h\"",
          "34: #include \"avcodec.h\"",
          "35: #include \"internal.h\"",
          "36: #include \"get_bits.h\"",
          "37: #include \"put_bits.h\"",
          "38: #include \"dsputil.h\"",
          "39: #include \"rangecoder.h\"",
          "40: #include \"golomb.h\"",
          "41: #include \"mathops.h\"",
          "42: #include \"ffv1.h\"",
          "44: static inline av_flatten int get_symbol_inline(RangeCoder *c, uint8_t *state,",
          "45:                                                int is_signed)",
          "46: {",
          "47:     if (get_rac(c, state + 0))",
          "48:         return 0;",
          "49:     else {",
          "50:         int i, e, a;",
          "51:         e = 0;",
          "52:         while (get_rac(c, state + 1 + FFMIN(e, 9))) // 1..10",
          "53:             e++;",
          "55:         a = 1;",
          "56:         for (i = e - 1; i >= 0; i--)",
          "57:             a += a + get_rac(c, state + 22 + FFMIN(i, 9));  // 22..31",
          "59:         e = -(is_signed && get_rac(c, state + 11 + FFMIN(e, 10))); // 11..21",
          "60:         return (a ^ e) - e;",
          "61:     }",
          "62: }",
          "64: static av_noinline int get_symbol(RangeCoder *c, uint8_t *state, int is_signed)",
          "65: {",
          "66:     return get_symbol_inline(c, state, is_signed);",
          "67: }",
          "69: static inline int get_vlc_symbol(GetBitContext *gb, VlcState *const state,",
          "70:                                  int bits)",
          "71: {",
          "72:     int k, i, v, ret;",
          "74:     i = state->count;",
          "75:     k = 0;",
          "76:     while (i < state->error_sum) { // FIXME: optimize",
          "77:         k++;",
          "78:         i += i;",
          "79:     }",
          "81:     assert(k <= 8);",
          "83:     v = get_sr_golomb(gb, k, 12, bits);",
          "84:     av_dlog(NULL, \"v:%d bias:%d error:%d drift:%d count:%d k:%d\",",
          "85:             v, state->bias, state->error_sum, state->drift, state->count, k);",
          "87: #if 0 // JPEG LS",
          "88:     if (k == 0 && 2 * state->drift <= -state->count)",
          "89:         v ^= (-1);",
          "90: #else",
          "91:     v ^= ((2 * state->drift + state->count) >> 31);",
          "92: #endif",
          "94:     ret = fold(v + state->bias, bits);",
          "96:     update_vlc_state(state, v);",
          "98:     return ret;",
          "99: }",
          "101: static av_always_inline void decode_line(FFV1Context *s, int w,",
          "102:                                          int16_t *sample[2],",
          "103:                                          int plane_index, int bits)",
          "104: {",
          "105:     PlaneContext *const p = &s->plane[plane_index];",
          "106:     RangeCoder *const c   = &s->c;",
          "107:     int x;",
          "108:     int run_count = 0;",
          "109:     int run_mode  = 0;",
          "110:     int run_index = s->run_index;",
          "112:     for (x = 0; x < w; x++) {",
          "113:         int diff, context, sign;",
          "115:         context = get_context(p, sample[1] + x, sample[0] + x, sample[1] + x);",
          "116:         if (context < 0) {",
          "117:             context = -context;",
          "118:             sign    = 1;",
          "119:         } else",
          "120:             sign = 0;",
          "122:         av_assert2(context < p->context_count);",
          "124:         if (s->ac) {",
          "125:             diff = get_symbol_inline(c, p->state[context], 1);",
          "126:         } else {",
          "127:             if (context == 0 && run_mode == 0)",
          "128:                 run_mode = 1;",
          "130:             if (run_mode) {",
          "131:                 if (run_count == 0 && run_mode == 1) {",
          "132:                     if (get_bits1(&s->gb)) {",
          "133:                         run_count = 1 << ff_log2_run[run_index];",
          "134:                         if (x + run_count <= w)",
          "135:                             run_index++;",
          "136:                     } else {",
          "137:                         if (ff_log2_run[run_index])",
          "138:                             run_count = get_bits(&s->gb, ff_log2_run[run_index]);",
          "139:                         else",
          "140:                             run_count = 0;",
          "141:                         if (run_index)",
          "142:                             run_index--;",
          "143:                         run_mode = 2;",
          "144:                     }",
          "145:                 }",
          "146:                 run_count--;",
          "147:                 if (run_count < 0) {",
          "148:                     run_mode  = 0;",
          "149:                     run_count = 0;",
          "150:                     diff      = get_vlc_symbol(&s->gb, &p->vlc_state[context],",
          "151:                                                bits);",
          "152:                     if (diff >= 0)",
          "153:                         diff++;",
          "154:                 } else",
          "155:                     diff = 0;",
          "156:             } else",
          "157:                 diff = get_vlc_symbol(&s->gb, &p->vlc_state[context], bits);",
          "159:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "160:                     run_count, run_index, run_mode, x, get_bits_count(&s->gb));",
          "161:         }",
          "163:         if (sign)",
          "164:             diff = -diff;",
          "166:         sample[1][x] = (predict(sample[1] + x, sample[0] + x) + diff) &",
          "167:                        ((1 << bits) - 1);",
          "168:     }",
          "169:     s->run_index = run_index;",
          "170: }",
          "172: static void decode_plane(FFV1Context *s, uint8_t *src,",
          "173:                          int w, int h, int stride, int plane_index)",
          "174: {",
          "175:     int x, y;",
          "176:     int16_t *sample[2];",
          "177:     sample[0] = s->sample_buffer + 3;",
          "178:     sample[1] = s->sample_buffer + w + 6 + 3;",
          "180:     s->run_index = 0;",
          "182:     memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));",
          "184:     for (y = 0; y < h; y++) {",
          "185:         int16_t *temp = sample[0]; // FIXME: try a normal buffer",
          "187:         sample[0] = sample[1];",
          "188:         sample[1] = temp;",
          "190:         sample[1][-1] = sample[0][0];",
          "191:         sample[0][w]  = sample[0][w - 1];",
          "194:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "195:             decode_line(s, w, sample, plane_index, 8);",
          "196:             for (x = 0; x < w; x++)",
          "197:                 src[x + stride * y] = sample[1][x];",
          "198:         } else {",
          "199:             decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);",
          "200:             if (s->packed_at_lsb) {",
          "201:                 for (x = 0; x < w; x++) {",
          "202:                     ((uint16_t*)(src + stride*y))[x] = sample[1][x];",
          "203:                 }",
          "204:             } else {",
          "205:                 for (x = 0; x < w; x++) {",
          "206:                     ((uint16_t*)(src + stride*y))[x] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "207:                 }",
          "208:             }",
          "209:         }",
          "211:     }",
          "212: }",
          "214: static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])",
          "215: {",
          "216:     int x, y, p;",
          "217:     int16_t *sample[4][2];",
          "218:     int lbd  = s->avctx->bits_per_raw_sample <= 8;",
          "219:     int bits = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;",
          "220:     int offset = 1 << bits;",
          "221:     for (x = 0; x < 4; x++) {",
          "222:         sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;",
          "223:         sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;",
          "224:     }",
          "226:     s->run_index = 0;",
          "228:     memset(s->sample_buffer, 0, 8*(w+6)*sizeof(*s->sample_buffer));",
          "230:     for (y = 0; y < h; y++) {",
          "231:         for (p = 0; p < 3 + s->transparency; p++) {",
          "232:             int16_t *temp = sample[p][0]; // FIXME: try a normal buffer",
          "234:             sample[p][0] = sample[p][1];",
          "235:             sample[p][1] = temp;",
          "237:             sample[p][1][-1]= sample[p][0][0  ];",
          "238:             sample[p][0][ w]= sample[p][0][w-1];",
          "239:             if (lbd)",
          "240:                 decode_line(s, w, sample[p], (p+1)/2, 9);",
          "241:             else",
          "242:                 decode_line(s, w, sample[p], (p+1)/2, bits+1);",
          "243:         }",
          "244:         for (x = 0; x < w; x++) {",
          "245:             int g = sample[0][1][x];",
          "246:             int b = sample[1][1][x];",
          "247:             int r = sample[2][1][x];",
          "248:             int a = sample[3][1][x];",
          "250:             b -= offset;",
          "251:             r -= offset;",
          "252:             g -= (b + r) >> 2;",
          "253:             b += g;",
          "254:             r += g;",
          "256:             if (lbd)",
          "258:             else {",
          "262:             }",
          "263:         }",
          "264:     }",
          "265: }",
          "267: static int decode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "268: {",
          "269:     RangeCoder *c = &fs->c;",
          "270:     uint8_t state[CONTEXT_SIZE];",
          "271:     unsigned ps, i, context_count;",
          "272:     memset(state, 128, sizeof(state));",
          "274:     av_assert0(f->version > 2);",
          "276:     fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;",
          "277:     fs->slice_y      =  get_symbol(c, state, 0)      * f->height;",
          "278:     fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "279:     fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "281:     fs->slice_x /= f->num_h_slices;",
          "282:     fs->slice_y /= f->num_v_slices;",
          "283:     fs->slice_width  = fs->slice_width /f->num_h_slices - fs->slice_x;",
          "284:     fs->slice_height = fs->slice_height/f->num_v_slices - fs->slice_y;",
          "285:     if ((unsigned)fs->slice_width > f->width || (unsigned)fs->slice_height > f->height)",
          "286:         return -1;",
          "287:     if (    (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width",
          "288:          || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "289:         return -1;",
          "291:     for (i = 0; i < f->plane_count; i++) {",
          "292:         PlaneContext * const p = &fs->plane[i];",
          "293:         int idx = get_symbol(c, state, 0);",
          "294:         if (idx > (unsigned)f->quant_table_count) {",
          "295:             av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");",
          "296:             return -1;",
          "297:         }",
          "298:         p->quant_table_index = idx;",
          "299:         memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));",
          "300:         context_count = f->context_count[idx];",
          "302:         if (p->context_count < context_count) {",
          "303:             av_freep(&p->state);",
          "304:             av_freep(&p->vlc_state);",
          "305:         }",
          "306:         p->context_count = context_count;",
          "307:     }",
          "309:     ps = get_symbol(c, state, 0);",
          "310:     if (ps == 1) {",
          "311:         f->picture.interlaced_frame = 1;",
          "312:         f->picture.top_field_first  = 1;",
          "313:     } else if (ps == 2) {",
          "314:         f->picture.interlaced_frame = 1;",
          "315:         f->picture.top_field_first  = 0;",
          "316:     } else if (ps == 3) {",
          "317:         f->picture.interlaced_frame = 0;",
          "318:     }",
          "319:     f->picture.sample_aspect_ratio.num = get_symbol(c, state, 0);",
          "320:     f->picture.sample_aspect_ratio.den = get_symbol(c, state, 0);",
          "322:     return 0;",
          "323: }",
          "325: static int decode_slice(AVCodecContext *c, void *arg)",
          "326: {",
          "327:     FFV1Context *fs  = *(void **)arg;",
          "328:     FFV1Context *f   = fs->avctx->priv_data;",
          "329:     int width, height, x, y;",
          "330:     const int ps      = av_pix_fmt_desc_get(c->pix_fmt)->comp[0].step_minus1 + 1;",
          "331:     AVFrame * const p = &f->picture;",
          "333:     if (f->version > 2) {",
          "334:         if (ffv1_init_slice_state(f, fs) < 0)",
          "335:             return AVERROR(ENOMEM);",
          "336:         if (decode_slice_header(f, fs) < 0) {",
          "337:             fs->slice_damaged = 1;",
          "338:             return AVERROR_INVALIDDATA;",
          "339:         }",
          "340:     }",
          "341:     if (ffv1_init_slice_state(f, fs) < 0)",
          "342:         return AVERROR(ENOMEM);",
          "343:     if (f->picture.key_frame)",
          "344:         ffv1_clear_slice_state(f, fs);",
          "345:     width = fs->slice_width;",
          "346:     height= fs->slice_height;",
          "347:     x= fs->slice_x;",
          "348:     y= fs->slice_y;",
          "350:     if (!fs->ac) {",
          "351:         if (f->version == 3 && f->minor_version > 1 || f->version > 3)",
          "352:             get_rac(&fs->c, (uint8_t[]) {129});",
          "353:         fs->ac_byte_count = f->version > 2 || (!x&&!y) ? fs->c.bytestream - fs->c.bytestream_start - 1 : 0;",
          "354:         init_get_bits(&fs->gb,",
          "355:                       fs->c.bytestream_start + fs->ac_byte_count,",
          "356:                       (fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count) * 8);",
          "357:     }",
          "359:     av_assert1(width && height);",
          "360:     if (f->colorspace == 0) {",
          "361:         const int chroma_width  = -((-width)  >> f->chroma_h_shift);",
          "362:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "363:         const int cx            = x >> f->chroma_h_shift;",
          "364:         const int cy            = y >> f->chroma_v_shift;",
          "365:         decode_plane(fs, p->data[0] + ps*x + y*p->linesize[0], width, height, p->linesize[0], 0);",
          "367:         if (f->chroma_planes) {",
          "368:             decode_plane(fs, p->data[1] + ps*cx+cy*p->linesize[1], chroma_width, chroma_height, p->linesize[1], 1);",
          "369:             decode_plane(fs, p->data[2] + ps*cx+cy*p->linesize[2], chroma_width, chroma_height, p->linesize[2], 1);",
          "370:         }",
          "371:         if (fs->transparency)",
          "372:             decode_plane(fs, p->data[3] + ps*x + y*p->linesize[3], width, height, p->linesize[3], 2);",
          "373:     } else {",
          "374:         uint8_t *planes[3] = {p->data[0] + ps*x + y*p->linesize[0],",
          "375:                               p->data[1] + ps*x + y*p->linesize[1],",
          "376:                               p->data[2] + ps*x + y*p->linesize[2]};",
          "377:         decode_rgb_frame(fs, planes, width, height, p->linesize);",
          "378:     }",
          "379:     if (fs->ac && f->version > 2) {",
          "380:         int v;",
          "381:         get_rac(&fs->c, (uint8_t[]) {129});",
          "382:         v = fs->c.bytestream_end - fs->c.bytestream - 2 - 5*f->ec;",
          "383:         if (v) {",
          "384:             av_log(f->avctx, AV_LOG_ERROR, \"bytestream end mismatching by %d\\n\", v);",
          "385:             fs->slice_damaged = 1;",
          "386:         }",
          "387:     }",
          "389:     emms_c();",
          "391:     return 0;",
          "392: }",
          "394: static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)",
          "395: {",
          "396:     int v;",
          "397:     int i = 0;",
          "398:     uint8_t state[CONTEXT_SIZE];",
          "400:     memset(state, 128, sizeof(state));",
          "402:     for (v = 0; i < 128; v++) {",
          "403:         unsigned len = get_symbol(c, state, 0) + 1;",
          "405:         if (len > 128 - i)",
          "406:             return -1;",
          "408:         while (len--) {",
          "409:             quant_table[i] = scale * v;",
          "410:             i++;",
          "411:         }",
          "412:     }",
          "414:     for (i = 1; i < 128; i++)",
          "415:         quant_table[256 - i] = -quant_table[i];",
          "416:     quant_table[128] = -quant_table[127];",
          "418:     return 2 * v - 1;",
          "419: }",
          "421: static int read_quant_tables(RangeCoder *c,",
          "422:                              int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "423: {",
          "424:     int i;",
          "425:     int context_count = 1;",
          "427:     for (i = 0; i < 5; i++) {",
          "428:         context_count *= read_quant_table(c, quant_table[i], context_count);",
          "429:         if (context_count > 32768U) {",
          "430:             return -1;",
          "431:         }",
          "432:     }",
          "433:     return (context_count + 1) / 2;",
          "434: }",
          "436: static int read_extra_header(FFV1Context *f)",
          "437: {",
          "438:     RangeCoder *const c = &f->c;",
          "439:     uint8_t state[CONTEXT_SIZE];",
          "440:     int i, j, k;",
          "441:     uint8_t state2[32][CONTEXT_SIZE];",
          "443:     memset(state2, 128, sizeof(state2));",
          "444:     memset(state, 128, sizeof(state));",
          "446:     ff_init_range_decoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "447:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "449:     f->version = get_symbol(c, state, 0);",
          "450:     if (f->version > 2) {",
          "451:         c->bytestream_end -= 4;",
          "452:         f->minor_version = get_symbol(c, state, 0);",
          "453:     }",
          "454:     f->ac = f->avctx->coder_type = get_symbol(c, state, 0);",
          "455:     if (f->ac > 1)",
          "456:         for (i = 1; i < 256; i++)",
          "457:             f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "459:     f->colorspace                 = get_symbol(c, state, 0); // YUV cs type",
          "460:     f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "461:     f->chroma_planes  = get_rac(c, state);",
          "462:     f->chroma_h_shift = get_symbol(c, state, 0);",
          "463:     f->chroma_v_shift = get_symbol(c, state, 0);",
          "464:     f->transparency = get_rac(c, state);",
          "465:     f->plane_count  = 2 + f->transparency;",
          "466:     f->num_h_slices = 1 + get_symbol(c, state, 0);",
          "467:     f->num_v_slices = 1 + get_symbol(c, state, 0);",
          "469:     if (f->num_h_slices > (unsigned)f->width ||",
          "470:         f->num_v_slices > (unsigned)f->height) {",
          "471:         av_log(f->avctx, AV_LOG_ERROR, \"too many slices\\n\");",
          "472:         return -1;",
          "473:     }",
          "475:     f->quant_table_count = get_symbol(c, state, 0);",
          "477:     if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)",
          "478:         return -1;",
          "480:     for (i = 0; i < f->quant_table_count; i++) {",
          "481:         f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);",
          "482:         if (f->context_count[i] < 0) {",
          "483:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "484:             return -1;",
          "485:         }",
          "486:     }",
          "488:     if (ffv1_allocate_initial_states(f) < 0)",
          "489:         return AVERROR(ENOMEM);",
          "491:     for (i = 0; i < f->quant_table_count; i++)",
          "492:         if (get_rac(c, state))",
          "493:             for (j = 0; j < f->context_count[i]; j++)",
          "494:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "495:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "496:                     f->initial_states[i][j][k] =",
          "497:                         (pred + get_symbol(c, state2[k], 1)) & 0xFF;",
          "498:                 }",
          "500:     if (f->version > 2) {",
          "501:         f->ec = get_symbol(c, state, 0);",
          "502:     }",
          "504:     if (f->version > 2) {",
          "505:         unsigned v;",
          "506:         v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, f->avctx->extradata, f->avctx->extradata_size);",
          "507:         if (v) {",
          "508:             av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", v);",
          "509:             return AVERROR_INVALIDDATA;",
          "510:         }",
          "511:     }",
          "513:     return 0;",
          "514: }",
          "516: static int read_header(FFV1Context *f)",
          "517: {",
          "518:     uint8_t state[CONTEXT_SIZE];",
          "519:     int i, j, context_count = -1; //-1 to avoid warning",
          "520:     RangeCoder *const c = &f->slice_context[0]->c;",
          "522:     memset(state, 128, sizeof(state));",
          "524:     if (f->version < 2) {",
          "525:         unsigned v= get_symbol(c, state, 0);",
          "526:         if (v >= 2) {",
          "527:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
          "528:             return AVERROR_INVALIDDATA;",
          "529:         }",
          "530:         f->version = v;",
          "531:         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "532:         if (f->ac > 1)",
          "533:             for (i = 1; i < 256; i++)",
          "534:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "535:         f->colorspace = get_symbol(c, state, 0); // YUV cs type",
          "536:         if (f->version > 0)",
          "537:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "538:         f->chroma_planes  = get_rac(c, state);",
          "539:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "540:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "541:         f->transparency   = get_rac(c, state);",
          "542:         f->plane_count    = 2 + f->transparency;",
          "543:     }",
          "545:     if (f->colorspace == 0) {",
          "546:         if (!f->transparency && !f->chroma_planes) {",
          "547:             if (f->avctx->bits_per_raw_sample <= 8)",
          "548:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;",
          "549:             else",
          "550:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;",
          "551:         } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {",
          "552:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "553:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;",
          "554:             case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;",
          "555:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;",
          "556:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;",
          "557:             case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;",
          "558:             case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;",
          "559:             default:",
          "560:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "561:                 return -1;",
          "562:             }",
          "563:         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {",
          "564:             switch(16*f->chroma_h_shift + f->chroma_v_shift) {",
          "565:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;",
          "566:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;",
          "567:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;",
          "568:             default:",
          "569:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "570:                 return -1;",
          "571:             }",
          "572:         } else if (f->avctx->bits_per_raw_sample == 9) {",
          "573:             f->packed_at_lsb = 1;",
          "574:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "575:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;",
          "576:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;",
          "577:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;",
          "578:             default:",
          "579:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "580:                 return -1;",
          "581:             }",
          "582:         } else if (f->avctx->bits_per_raw_sample == 10) {",
          "583:             f->packed_at_lsb = 1;",
          "584:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "585:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;",
          "586:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;",
          "587:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;",
          "588:             default:",
          "589:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "590:                 return -1;",
          "591:             }",
          "592:         } else {",
          "593:             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "594:             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;",
          "595:             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;",
          "596:             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;",
          "597:             default:",
          "598:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "599:                 return -1;",
          "600:             }",
          "601:         }",
          "602:     } else if (f->colorspace == 1) {",
          "603:         if (f->chroma_h_shift || f->chroma_v_shift) {",
          "604:             av_log(f->avctx, AV_LOG_ERROR,",
          "605:                    \"chroma subsampling not supported in this colorspace\\n\");",
          "606:             return -1;",
          "607:         }",
          "608:         if (     f->avctx->bits_per_raw_sample ==  9)",
          "609:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;",
          "610:         else if (f->avctx->bits_per_raw_sample == 10)",
          "611:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
          "612:         else if (f->avctx->bits_per_raw_sample == 12)",
          "613:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;",
          "614:         else if (f->avctx->bits_per_raw_sample == 14)",
          "615:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;",
          "616:         else",
          "617:         if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "618:         else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;",
          "619:     } else {",
          "620:         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");",
          "621:         return -1;",
          "622:     }",
          "624:     av_dlog(f->avctx, \"%d %d %d\\n\",",
          "625:             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);",
          "627:     if (f->version < 2) {",
          "628:         context_count = read_quant_tables(c, f->quant_table);",
          "629:         if (context_count < 0) {",
          "630:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "631:             return -1;",
          "632:         }",
          "633:     } else if (f->version < 3) {",
          "634:         f->slice_count = get_symbol(c, state, 0);",
          "635:     } else {",
          "636:         const uint8_t *p = c->bytestream_end;",
          "637:         for (f->slice_count = 0; f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start; f->slice_count++) {",
          "638:             int trailer = 3 + 5*!!f->ec;",
          "639:             int size = AV_RB24(p-trailer);",
          "640:             if (size + trailer > p - c->bytestream_start)",
          "641:                 break;",
          "642:             p -= size + trailer;",
          "643:         }",
          "644:     }",
          "645:     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {",
          "646:         av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);",
          "647:         return -1;",
          "648:     }",
          "650:     for (j = 0; j < f->slice_count; j++) {",
          "651:         FFV1Context *fs = f->slice_context[j];",
          "652:         fs->ac = f->ac;",
          "653:         fs->packed_at_lsb = f->packed_at_lsb;",
          "655:         fs->slice_damaged = 0;",
          "657:         if (f->version == 2) {",
          "658:             fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;",
          "659:             fs->slice_y      =  get_symbol(c, state, 0)      * f->height;",
          "660:             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "661:             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "663:             fs->slice_x     /= f->num_h_slices;",
          "664:             fs->slice_y     /= f->num_v_slices;",
          "665:             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;",
          "666:             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "667:             if ((unsigned)fs->slice_width  > f->width ||",
          "668:                 (unsigned)fs->slice_height > f->height)",
          "669:                 return -1;",
          "670:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "671:                 (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "672:                 return -1;",
          "673:         }",
          "675:         for (i = 0; i < f->plane_count; i++) {",
          "676:             PlaneContext *const p = &fs->plane[i];",
          "678:             if (f->version == 2) {",
          "679:                 int idx = get_symbol(c, state, 0);",
          "680:                 if (idx > (unsigned)f->quant_table_count) {",
          "681:                     av_log(f->avctx, AV_LOG_ERROR,",
          "682:                            \"quant_table_index out of range\\n\");",
          "683:                     return -1;",
          "684:                 }",
          "685:                 p->quant_table_index = idx;",
          "686:                 memcpy(p->quant_table, f->quant_tables[idx],",
          "687:                        sizeof(p->quant_table));",
          "688:                 context_count = f->context_count[idx];",
          "689:             } else {",
          "690:                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));",
          "691:             }",
          "693:             if (f->version <= 2) {",
          "694:                 av_assert0(context_count >= 0);",
          "695:                 if (p->context_count < context_count) {",
          "696:                     av_freep(&p->state);",
          "697:                     av_freep(&p->vlc_state);",
          "698:                 }",
          "699:                 p->context_count = context_count;",
          "700:             }",
          "701:         }",
          "702:     }",
          "703:     return 0;",
          "704: }",
          "706: static av_cold int decode_init(AVCodecContext *avctx)",
          "707: {",
          "708:     FFV1Context *f = avctx->priv_data;",
          "710:     ffv1_common_init(avctx);",
          "712:     if (avctx->extradata && read_extra_header(f) < 0)",
          "713:         return -1;",
          "715:     if (ffv1_init_slice_contexts(f) < 0)",
          "716:         return -1;",
          "718:     return 0;",
          "719: }",
          "721: static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)",
          "722: {",
          "723:     const uint8_t *buf  = avpkt->data;",
          "724:     int buf_size        = avpkt->size;",
          "725:     FFV1Context *f      = avctx->priv_data;",
          "726:     RangeCoder *const c = &f->slice_context[0]->c;",
          "727:     AVFrame *const p    = &f->picture;",
          "728:     int i;",
          "729:     uint8_t keystate = 128;",
          "730:     const uint8_t *buf_p;",
          "732:     AVFrame *picture = data;",
          "735:     if (p->data[0])",
          "736:         avctx->release_buffer(avctx, p);",
          "738:     ff_init_range_decoder(c, buf, buf_size);",
          "739:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "741:     p->pict_type = AV_PICTURE_TYPE_I; // FIXME: I vs. P",
          "742:     if (get_rac(c, &keystate)) {",
          "743:         p->key_frame = 1;",
          "744:         f->key_frame_ok = 0;",
          "745:         if (read_header(f) < 0)",
          "746:             return -1;",
          "747:         f->key_frame_ok = 1;",
          "748:     } else {",
          "749:         if (!f->key_frame_ok) {",
          "750:             av_log(avctx, AV_LOG_ERROR, \"Cant decode non keyframe without valid keyframe\\n\");",
          "751:             return AVERROR_INVALIDDATA;",
          "752:         }",
          "753:         p->key_frame= 0;",
          "754:     }",
          "756:     p->reference = 3; //for error concealment",
          "757:     if (avctx->get_buffer(avctx, p) < 0) {",
          "758:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "759:         return -1;",
          "760:     }",
          "762:     if (avctx->debug&FF_DEBUG_PICT_INFO)",
          "763:         av_log(avctx, AV_LOG_DEBUG, \"ver:%d keyframe:%d coder:%d ec:%d slices:%d bps:%d\\n\",",
          "764:                f->version, p->key_frame, f->ac, f->ec, f->slice_count, f->avctx->bits_per_raw_sample);",
          "766:     buf_p = buf + buf_size;",
          "767:     for (i = f->slice_count - 1; i >= 0; i--) {",
          "768:         FFV1Context *fs = f->slice_context[i];",
          "769:         int trailer = 3 + 5*!!f->ec;",
          "770:         int v;",
          "772:         if (i || f->version>2) v = AV_RB24(buf_p-trailer)+trailer;",
          "773:         else                   v = buf_p - c->bytestream_start;",
          "774:         if (buf_p - c->bytestream_start < v) {",
          "775:             av_log(avctx, AV_LOG_ERROR, \"Slice pointer chain broken\\n\");",
          "776:             return -1;",
          "777:         }",
          "778:         buf_p -= v;",
          "780:         if (f->ec) {",
          "781:             unsigned crc = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, v);",
          "782:             if (crc) {",
          "783:                 int64_t ts = avpkt->pts != AV_NOPTS_VALUE ? avpkt->pts : avpkt->dts;",
          "784:                 av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\", crc);",
          "785:                 if (ts != AV_NOPTS_VALUE && avctx->pkt_timebase.num) {",
          "786:                     av_log(f->avctx, AV_LOG_ERROR, \"at %f seconds\\n\", ts*av_q2d(avctx->pkt_timebase));",
          "787:                 } else if (ts != AV_NOPTS_VALUE) {",
          "788:                     av_log(f->avctx, AV_LOG_ERROR, \"at %\"PRId64\"\\n\", ts);",
          "789:                 } else {",
          "790:                     av_log(f->avctx, AV_LOG_ERROR, \"\\n\");",
          "791:                 }",
          "792:                 fs->slice_damaged = 1;",
          "793:             }",
          "794:         }",
          "796:         if (i) {",
          "797:             ff_init_range_decoder(&fs->c, buf_p, v);",
          "798:         } else",
          "799:             fs->c.bytestream_end = (uint8_t *)(buf_p + v);",
          "800:     }",
          "802:     avctx->execute(avctx, decode_slice, &f->slice_context[0], NULL, f->slice_count, sizeof(void*));",
          "804:     for (i=f->slice_count-1; i>=0; i--) {",
          "805:         FFV1Context *fs= f->slice_context[i];",
          "806:         int j;",
          "807:         if (fs->slice_damaged && f->last_picture.data[0]) {",
          "808:             uint8_t *dst[4], *src[4];",
          "809:             for (j=0; j<4; j++) {",
          "810:                 int sh = (j==1 || j==2) ? f->chroma_h_shift : 0;",
          "811:                 int sv = (j==1 || j==2) ? f->chroma_v_shift : 0;",
          "812:                 dst[j] = f->picture     .data[j] + f->picture     .linesize[j]*",
          "813:                          (fs->slice_y>>sv) + (fs->slice_x>>sh);",
          "814:                 src[j] = f->last_picture.data[j] + f->last_picture.linesize[j]*",
          "815:                          (fs->slice_y>>sv) + (fs->slice_x>>sh);",
          "816:             }",
          "817:             av_image_copy(dst, f->picture.linesize, (const uint8_t **)src, f->last_picture.linesize,",
          "818:                           avctx->pix_fmt, fs->slice_width, fs->slice_height);",
          "819:         }",
          "820:     }",
          "822:     f->picture_number++;",
          "827:     FFSWAP(AVFrame, f->picture, f->last_picture);",
          "829:     return buf_size;",
          "830: }",
          "832: AVCodec ff_ffv1_decoder = {",
          "833:     .name           = \"ffv1\",",
          "834:     .type           = AVMEDIA_TYPE_VIDEO,",
          "835:     .id             = AV_CODEC_ID_FFV1,",
          "836:     .priv_data_size = sizeof(FFV1Context),",
          "837:     .init           = decode_init,",
          "838:     .close          = ffv1_common_end,",
          "839:     .decode         = decode_frame,",
          "840:     .capabilities   = CODEC_CAP_DR1 /*| CODEC_CAP_DRAW_HORIZ_BAND*/ |",
          "841:                       CODEC_CAP_SLICE_THREADS,",
          "842:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "843: };",
          "",
          "---------------"
        ],
        "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c": [
          "File: libavcodec/ffv1enc.c -> libavcodec/ffv1enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"libavutil/crc.h\"",
          "30: #include \"libavutil/opt.h\"",
          "31: #include \"libavutil/imgutils.h\"",
          "32: #include \"libavutil/pixdesc.h\"",
          "33: #include \"libavutil/timer.h\"",
          "34: #include \"avcodec.h\"",
          "35: #include \"internal.h\"",
          "36: #include \"get_bits.h\"",
          "37: #include \"dsputil.h\"",
          "38: #include \"rangecoder.h\"",
          "39: #include \"golomb.h\"",
          "40: #include \"mathops.h\"",
          "41: #include \"ffv1.h\"",
          "43: static const int8_t quant5_10bit[256] = {",
          "44:      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,",
          "45:      1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,",
          "46:      1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,",
          "47:      1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "48:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "49:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "50:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "51:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "52:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "53:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "54:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "55:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "56:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1,",
          "57:     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "58:     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "59:     -1, -1, -1, -1, -1, -1, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0,",
          "60: };",
          "62: static const int8_t quant5[256] = {",
          "63:      0,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "64:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "65:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "66:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "67:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "68:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "69:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "70:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "71:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "72:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "73:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "74:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "75:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "76:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "77:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "78:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -1,",
          "79: };",
          "81: static const int8_t quant9_10bit[256] = {",
          "82:      0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,",
          "83:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,",
          "84:      3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,",
          "85:      3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,",
          "86:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "87:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "88:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "89:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "90:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "91:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "92:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "93:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "94:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3,",
          "95:     -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,",
          "96:     -3, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,",
          "97:     -2, -2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -0, -0, -0, -0,",
          "98: };",
          "100: static const int8_t quant11[256] = {",
          "101:      0,  1,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,",
          "102:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "103:      4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "104:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "105:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "106:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "107:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "108:      5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "109:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "110:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "111:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "112:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "113:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5,",
          "114:     -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -4, -4,",
          "115:     -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,",
          "116:     -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2, -2, -2, -1,",
          "117: };",
          "119: static const uint8_t ver2_state[256] = {",
          "120:       0,  10,  10,  10,  10,  16,  16,  16, 28,   16,  16,  29,  42,  49,  20,  49,",
          "121:      59,  25,  26,  26,  27,  31,  33,  33, 33,   34,  34,  37,  67,  38,  39,  39,",
          "122:      40,  40,  41,  79,  43,  44,  45,  45, 48,   48,  64,  50,  51,  52,  88,  52,",
          "123:      53,  74,  55,  57,  58,  58,  74,  60, 101,  61,  62,  84,  66,  66,  68,  69,",
          "124:      87,  82,  71,  97,  73,  73,  82,  75, 111,  77,  94,  78,  87,  81,  83,  97,",
          "125:      85,  83,  94,  86,  99,  89,  90,  99, 111,  92,  93,  134, 95,  98,  105, 98,",
          "126:     105, 110, 102, 108, 102, 118, 103, 106, 106, 113, 109, 112, 114, 112, 116, 125,",
          "127:     115, 116, 117, 117, 126, 119, 125, 121, 121, 123, 145, 124, 126, 131, 127, 129,",
          "128:     165, 130, 132, 138, 133, 135, 145, 136, 137, 139, 146, 141, 143, 142, 144, 148,",
          "129:     147, 155, 151, 149, 151, 150, 152, 157, 153, 154, 156, 168, 158, 162, 161, 160,",
          "130:     172, 163, 169, 164, 166, 184, 167, 170, 177, 174, 171, 173, 182, 176, 180, 178,",
          "131:     175, 189, 179, 181, 186, 183, 192, 185, 200, 187, 191, 188, 190, 197, 193, 196,",
          "132:     197, 194, 195, 196, 198, 202, 199, 201, 210, 203, 207, 204, 205, 206, 208, 214,",
          "133:     209, 211, 221, 212, 213, 215, 224, 216, 217, 218, 219, 220, 222, 228, 223, 225,",
          "134:     226, 224, 227, 229, 240, 230, 231, 232, 233, 234, 235, 236, 238, 239, 237, 242,",
          "135:     241, 243, 242, 244, 245, 246, 247, 248, 249, 250, 251, 252, 252, 253, 254, 255,",
          "136: };",
          "138: static void find_best_state(uint8_t best_state[256][256],",
          "139:                             const uint8_t one_state[256])",
          "140: {",
          "141:     int i, j, k, m;",
          "142:     double l2tab[256];",
          "144:     for (i = 1; i < 256; i++)",
          "145:         l2tab[i] = log2(i / 256.0);",
          "147:     for (i = 0; i < 256; i++) {",
          "148:         double best_len[256];",
          "149:         double p = i / 256.0;",
          "151:         for (j = 0; j < 256; j++)",
          "152:             best_len[j] = 1 << 30;",
          "154:         for (j = FFMAX(i - 10, 1); j < FFMIN(i + 11, 256); j++) {",
          "155:             double occ[256] = { 0 };",
          "156:             double len      = 0;",
          "157:             occ[j] = 1.0;",
          "158:             for (k = 0; k < 256; k++) {",
          "159:                 double newocc[256] = { 0 };",
          "160:                 for (m = 1; m < 256; m++)",
          "161:                     if (occ[m]) {",
          "162:                         len -=occ[m]*(     p *l2tab[    m]",
          "163:                                       + (1-p)*l2tab[256-m]);",
          "164:                     }",
          "165:                 if (len < best_len[k]) {",
          "166:                     best_len[k]      = len;",
          "167:                     best_state[i][k] = j;",
          "168:                 }",
          "169:                 for (m = 0; m < 256; m++)",
          "170:                     if (occ[m]) {",
          "171:                         newocc[      one_state[      m]] += occ[m] * p;",
          "172:                         newocc[256 - one_state[256 - m]] += occ[m] * (1 - p);",
          "173:                     }",
          "174:                 memcpy(occ, newocc, sizeof(occ));",
          "175:             }",
          "176:         }",
          "177:     }",
          "178: }",
          "180: static av_always_inline av_flatten void put_symbol_inline(RangeCoder *c,",
          "181:                                                           uint8_t *state, int v,",
          "182:                                                           int is_signed,",
          "183:                                                           uint64_t rc_stat[256][2],",
          "184:                                                           uint64_t rc_stat2[32][2])",
          "185: {",
          "186:     int i;",
          "188: #define put_rac(C, S, B)                        \\",
          "189:     do {                                        \\",
          "190:         if (rc_stat) {                          \\",
          "191:             rc_stat[*(S)][B]++;                 \\",
          "192:             rc_stat2[(S) - state][B]++;         \\",
          "193:         }                                       \\",
          "194:         put_rac(C, S, B);                       \\",
          "195:     } while (0)",
          "197:     if (v) {",
          "198:         const int a = FFABS(v);",
          "199:         const int e = av_log2(a);",
          "200:         put_rac(c, state + 0, 0);",
          "201:         if (e <= 9) {",
          "202:             for (i = 0; i < e; i++)",
          "203:                 put_rac(c, state + 1 + i, 1);  // 1..10",
          "204:             put_rac(c, state + 1 + i, 0);",
          "206:             for (i = e - 1; i >= 0; i--)",
          "207:                 put_rac(c, state + 22 + i, (a >> i) & 1);  // 22..31",
          "209:             if (is_signed)",
          "210:                 put_rac(c, state + 11 + e, v < 0);  // 11..21",
          "211:         } else {",
          "212:             for (i = 0; i < e; i++)",
          "213:                 put_rac(c, state + 1 + FFMIN(i, 9), 1);  // 1..10",
          "214:             put_rac(c, state + 1 + 9, 0);",
          "216:             for (i = e - 1; i >= 0; i--)",
          "217:                 put_rac(c, state + 22 + FFMIN(i, 9), (a >> i) & 1);  // 22..31",
          "219:             if (is_signed)",
          "220:                 put_rac(c, state + 11 + 10, v < 0);  // 11..21",
          "221:         }",
          "222:     } else {",
          "223:         put_rac(c, state + 0, 1);",
          "224:     }",
          "225: #undef put_rac",
          "226: }",
          "228: static av_noinline void put_symbol(RangeCoder *c, uint8_t *state,",
          "229:                                    int v, int is_signed)",
          "230: {",
          "231:     put_symbol_inline(c, state, v, is_signed, NULL, NULL);",
          "232: }",
          "235: static inline void put_vlc_symbol(PutBitContext *pb, VlcState *const state,",
          "236:                                   int v, int bits)",
          "237: {",
          "238:     int i, k, code;",
          "239:     v = fold(v - state->bias, bits);",
          "241:     i = state->count;",
          "242:     k = 0;",
          "243:     while (i < state->error_sum) { // FIXME: optimize",
          "244:         k++;",
          "245:         i += i;",
          "246:     }",
          "248:     av_assert2(k<=13);",
          "250: #if 0 // JPEG LS",
          "251:     if (k == 0 && 2 * state->drift <= -state->count)",
          "252:         code = v ^ (-1);",
          "253:     else",
          "254:         code = v;",
          "255: #else",
          "256:     code = v ^ ((2 * state->drift + state->count) >> 31);",
          "257: #endif",
          "259:     av_dlog(NULL, \"v:%d/%d bias:%d error:%d drift:%d count:%d k:%d\\n\", v, code,",
          "260:             state->bias, state->error_sum, state->drift, state->count, k);",
          "261:     set_sr_golomb(pb, code, k, 12, bits);",
          "263:     update_vlc_state(state, v);",
          "264: }",
          "266: static av_always_inline int encode_line(FFV1Context *s, int w,",
          "267:                                         int16_t *sample[3],",
          "268:                                         int plane_index, int bits)",
          "269: {",
          "270:     PlaneContext *const p = &s->plane[plane_index];",
          "271:     RangeCoder *const c   = &s->c;",
          "272:     int x;",
          "273:     int run_index = s->run_index;",
          "274:     int run_count = 0;",
          "275:     int run_mode  = 0;",
          "277:     if (s->ac) {",
          "278:         if (c->bytestream_end - c->bytestream < w * 20) {",
          "279:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "280:             return -1;",
          "281:         }",
          "282:     } else {",
          "283:         if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < w * 4) {",
          "284:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "285:             return -1;",
          "286:         }",
          "287:     }",
          "289:     for (x = 0; x < w; x++) {",
          "290:         int diff, context;",
          "292:         context = get_context(p, sample[0] + x, sample[1] + x, sample[2] + x);",
          "293:         diff    = sample[0][x] - predict(sample[0] + x, sample[1] + x);",
          "295:         if (context < 0) {",
          "296:             context = -context;",
          "297:             diff    = -diff;",
          "298:         }",
          "300:         diff = fold(diff, bits);",
          "302:         if (s->ac) {",
          "303:             if (s->flags & CODEC_FLAG_PASS1) {",
          "304:                 put_symbol_inline(c, p->state[context], diff, 1, s->rc_stat,",
          "305:                                   s->rc_stat2[p->quant_table_index][context]);",
          "306:             } else {",
          "307:                 put_symbol_inline(c, p->state[context], diff, 1, NULL, NULL);",
          "308:             }",
          "309:         } else {",
          "310:             if (context == 0)",
          "311:                 run_mode = 1;",
          "313:             if (run_mode) {",
          "314:                 if (diff) {",
          "315:                     while (run_count >= 1 << ff_log2_run[run_index]) {",
          "316:                         run_count -= 1 << ff_log2_run[run_index];",
          "317:                         run_index++;",
          "318:                         put_bits(&s->pb, 1, 1);",
          "319:                     }",
          "321:                     put_bits(&s->pb, 1 + ff_log2_run[run_index], run_count);",
          "322:                     if (run_index)",
          "323:                         run_index--;",
          "324:                     run_count = 0;",
          "325:                     run_mode  = 0;",
          "326:                     if (diff > 0)",
          "327:                         diff--;",
          "328:                 } else {",
          "329:                     run_count++;",
          "330:                 }",
          "331:             }",
          "333:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "334:                     run_count, run_index, run_mode, x,",
          "335:                     (int)put_bits_count(&s->pb));",
          "337:             if (run_mode == 0)",
          "338:                 put_vlc_symbol(&s->pb, &p->vlc_state[context], diff, bits);",
          "339:         }",
          "340:     }",
          "341:     if (run_mode) {",
          "342:         while (run_count >= 1 << ff_log2_run[run_index]) {",
          "343:             run_count -= 1 << ff_log2_run[run_index];",
          "344:             run_index++;",
          "345:             put_bits(&s->pb, 1, 1);",
          "346:         }",
          "348:         if (run_count)",
          "349:             put_bits(&s->pb, 1, 1);",
          "350:     }",
          "351:     s->run_index = run_index;",
          "353:     return 0;",
          "354: }",
          "356: static void encode_plane(FFV1Context *s, uint8_t *src, int w, int h,",
          "357:                          int stride, int plane_index)",
          "358: {",
          "359:     int x, y, i;",
          "360:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "361:     int16_t *sample[3];",
          "362:     s->run_index = 0;",
          "364:     memset(s->sample_buffer, 0, ring_size * (w + 6) * sizeof(*s->sample_buffer));",
          "366:     for (y = 0; y < h; y++) {",
          "367:         for (i = 0; i < ring_size; i++)",
          "368:             sample[i] = s->sample_buffer + (w + 6) * ((h + i - y) % ring_size) + 3;",
          "370:         sample[0][-1]= sample[1][0  ];",
          "371:         sample[1][ w]= sample[1][w-1];",
          "373:         if (s->bits_per_raw_sample <= 8) {",
          "374:             for (x = 0; x < w; x++)",
          "375:                 sample[0][x] = src[x + stride * y];",
          "376:             encode_line(s, w, sample, plane_index, 8);",
          "377:         } else {",
          "378:             if (s->packed_at_lsb) {",
          "379:                 for (x = 0; x < w; x++) {",
          "380:                     sample[0][x] = ((uint16_t*)(src + stride*y))[x];",
          "381:                 }",
          "382:             } else {",
          "383:                 for (x = 0; x < w; x++) {",
          "384:                     sample[0][x] = ((uint16_t*)(src + stride*y))[x] >> (16 - s->bits_per_raw_sample);",
          "385:                 }",
          "386:             }",
          "387:             encode_line(s, w, sample, plane_index, s->bits_per_raw_sample);",
          "388:         }",
          "390:     }",
          "391: }",
          "393: static void encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])",
          "394: {",
          "395:     int x, y, p, i;",
          "396:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "397:     int16_t *sample[4][3];",
          "398:     int lbd    = s->avctx->bits_per_raw_sample <= 8;",
          "399:     int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;",
          "400:     int offset = 1 << bits;",
          "401:     s->run_index = 0;",
          "403:     memset(s->sample_buffer, 0, ring_size * 4 * (w + 6) * sizeof(*s->sample_buffer));",
          "405:     for (y = 0; y < h; y++) {",
          "406:         for (i = 0; i < ring_size; i++)",
          "407:             for (p = 0; p < 4; p++)",
          "408:                 sample[p][i]= s->sample_buffer + p*ring_size*(w+6) + ((h+i-y)%ring_size)*(w+6) + 3;",
          "410:         for (x = 0; x < w; x++) {",
          "411:             int b, g, r, av_uninit(a);",
          "412:             if (lbd) {",
          "413:                 unsigned v = *((uint32_t*)(src[0] + x*4 + stride[0]*y));",
          "414:                 b =  v        & 0xFF;",
          "415:                 g = (v >>  8) & 0xFF;",
          "416:                 r = (v >> 16) & 0xFF;",
          "417:                 a =  v >> 24;",
          "418:             } else {",
          "419:                 b = *((uint16_t*)(src[0] + x*2 + stride[0]*y));",
          "420:                 g = *((uint16_t*)(src[1] + x*2 + stride[1]*y));",
          "421:                 r = *((uint16_t*)(src[2] + x*2 + stride[2]*y));",
          "422:             }",
          "424:             b -= g;",
          "425:             r -= g;",
          "426:             g += (b + r) >> 2;",
          "427:             b += offset;",
          "428:             r += offset;",
          "430:             sample[0][0][x] = g;",
          "431:             sample[1][0][x] = b;",
          "432:             sample[2][0][x] = r;",
          "433:             sample[3][0][x] = a;",
          "434:         }",
          "435:         for (p = 0; p < 3 + s->transparency; p++) {",
          "436:             sample[p][0][-1] = sample[p][1][0  ];",
          "437:             sample[p][1][ w] = sample[p][1][w-1];",
          "438:             if (lbd)",
          "439:                 encode_line(s, w, sample[p], (p+1)/2, 9);",
          "440:             else",
          "441:                 encode_line(s, w, sample[p], (p+1)/2, bits+1);",
          "442:         }",
          "443:     }",
          "444: }",
          "446: static void write_quant_table(RangeCoder *c, int16_t *quant_table)",
          "447: {",
          "448:     int last = 0;",
          "449:     int i;",
          "450:     uint8_t state[CONTEXT_SIZE];",
          "451:     memset(state, 128, sizeof(state));",
          "453:     for (i = 1; i < 128; i++)",
          "454:         if (quant_table[i] != quant_table[i - 1]) {",
          "455:             put_symbol(c, state, i - last - 1, 0);",
          "456:             last = i;",
          "457:         }",
          "458:     put_symbol(c, state, i - last - 1, 0);",
          "459: }",
          "461: static void write_quant_tables(RangeCoder *c,",
          "462:                                int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "463: {",
          "464:     int i;",
          "465:     for (i = 0; i < 5; i++)",
          "466:         write_quant_table(c, quant_table[i]);",
          "467: }",
          "469: static void write_header(FFV1Context *f)",
          "470: {",
          "471:     uint8_t state[CONTEXT_SIZE];",
          "472:     int i, j;",
          "473:     RangeCoder *const c = &f->slice_context[0]->c;",
          "475:     memset(state, 128, sizeof(state));",
          "477:     if (f->version < 2) {",
          "478:         put_symbol(c, state, f->version, 0);",
          "479:         put_symbol(c, state, f->ac, 0);",
          "480:         if (f->ac > 1) {",
          "481:             for (i = 1; i < 256; i++)",
          "482:                 put_symbol(c, state,",
          "483:                            f->state_transition[i] - c->one_state[i], 1);",
          "484:         }",
          "485:         put_symbol(c, state, f->colorspace, 0); //YUV cs type",
          "486:         if (f->version > 0)",
          "487:             put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "488:         put_rac(c, state, f->chroma_planes);",
          "489:         put_symbol(c, state, f->chroma_h_shift, 0);",
          "490:         put_symbol(c, state, f->chroma_v_shift, 0);",
          "491:         put_rac(c, state, f->transparency);",
          "493:         write_quant_tables(c, f->quant_table);",
          "494:     } else if (f->version < 3) {",
          "495:         put_symbol(c, state, f->slice_count, 0);",
          "496:         for (i = 0; i < f->slice_count; i++) {",
          "497:             FFV1Context *fs = f->slice_context[i];",
          "498:             put_symbol(c, state,",
          "499:                        (fs->slice_x      + 1) * f->num_h_slices / f->width, 0);",
          "500:             put_symbol(c, state,",
          "501:                        (fs->slice_y      + 1) * f->num_v_slices / f->height, 0);",
          "502:             put_symbol(c, state,",
          "503:                        (fs->slice_width  + 1) * f->num_h_slices / f->width - 1,",
          "504:                        0);",
          "505:             put_symbol(c, state,",
          "506:                        (fs->slice_height + 1) * f->num_v_slices / f->height - 1,",
          "507:                        0);",
          "508:             for (j = 0; j < f->plane_count; j++) {",
          "509:                 put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "510:                 av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "511:             }",
          "512:         }",
          "513:     }",
          "514: }",
          "516: static int write_extra_header(FFV1Context *f)",
          "517: {",
          "518:     RangeCoder *const c = &f->c;",
          "519:     uint8_t state[CONTEXT_SIZE];",
          "520:     int i, j, k;",
          "521:     uint8_t state2[32][CONTEXT_SIZE];",
          "522:     unsigned v;",
          "524:     memset(state2, 128, sizeof(state2));",
          "525:     memset(state, 128, sizeof(state));",
          "527:     f->avctx->extradata = av_malloc(f->avctx->extradata_size = 10000 +",
          "528:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32);",
          "529:     ff_init_range_encoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "530:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "532:     put_symbol(c, state, f->version, 0);",
          "533:     if (f->version > 2) {",
          "534:         if (f->version == 3)",
          "535:             f->minor_version = 2;",
          "536:         put_symbol(c, state, f->minor_version, 0);",
          "537:     }",
          "538:     put_symbol(c, state, f->ac, 0);",
          "539:     if (f->ac > 1)",
          "540:         for (i = 1; i < 256; i++)",
          "541:             put_symbol(c, state, f->state_transition[i] - c->one_state[i], 1);",
          "542:     put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "543:     put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "544:     put_rac(c, state, f->chroma_planes);",
          "545:     put_symbol(c, state, f->chroma_h_shift, 0);",
          "546:     put_symbol(c, state, f->chroma_v_shift, 0);",
          "547:     put_rac(c, state, f->transparency);",
          "548:     put_symbol(c, state, f->num_h_slices - 1, 0);",
          "549:     put_symbol(c, state, f->num_v_slices - 1, 0);",
          "551:     put_symbol(c, state, f->quant_table_count, 0);",
          "552:     for (i = 0; i < f->quant_table_count; i++)",
          "553:         write_quant_tables(c, f->quant_tables[i]);",
          "555:     for (i = 0; i < f->quant_table_count; i++) {",
          "556:         for (j = 0; j < f->context_count[i] * CONTEXT_SIZE; j++)",
          "557:             if (f->initial_states[i] && f->initial_states[i][0][j] != 128)",
          "558:                 break;",
          "559:         if (j < f->context_count[i] * CONTEXT_SIZE) {",
          "560:             put_rac(c, state, 1);",
          "561:             for (j = 0; j < f->context_count[i]; j++)",
          "562:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "563:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "564:                     put_symbol(c, state2[k],",
          "565:                                (int8_t)(f->initial_states[i][j][k] - pred), 1);",
          "566:                 }",
          "567:         } else {",
          "568:             put_rac(c, state, 0);",
          "569:         }",
          "570:     }",
          "572:     if (f->version > 2) {",
          "573:         put_symbol(c, state, f->ec, 0);",
          "574:     }",
          "576:     f->avctx->extradata_size = ff_rac_terminate(c);",
          "577:     v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, f->avctx->extradata, f->avctx->extradata_size);",
          "578:     AV_WL32(f->avctx->extradata + f->avctx->extradata_size, v);",
          "579:     f->avctx->extradata_size += 4;",
          "581:     return 0;",
          "582: }",
          "584: static int sort_stt(FFV1Context *s, uint8_t stt[256])",
          "585: {",
          "586:     int i, i2, changed, print = 0;",
          "588:     do {",
          "589:         changed = 0;",
          "590:         for (i = 12; i < 244; i++) {",
          "591:             for (i2 = i + 1; i2 < 245 && i2 < i + 4; i2++) {",
          "593: #define COST(old, new)                                      \\",
          "594:     s->rc_stat[old][0] * -log2((256 - (new)) / 256.0) +     \\",
          "595:     s->rc_stat[old][1] * -log2((new)         / 256.0)",
          "597: #define COST2(old, new)                         \\",
          "598:     COST(old, new) + COST(256 - (old), 256 - (new))",
          "600:                 double size0 = COST2(i,  i) + COST2(i2, i2);",
          "601:                 double sizeX = COST2(i, i2) + COST2(i2, i);",
          "602:                 if (sizeX < size0 && i != 128 && i2 != 128) {",
          "603:                     int j;",
          "604:                     FFSWAP(int, stt[i], stt[i2]);",
          "605:                     FFSWAP(int, s->rc_stat[i][0], s->rc_stat[i2][0]);",
          "606:                     FFSWAP(int, s->rc_stat[i][1], s->rc_stat[i2][1]);",
          "607:                     if (i != 256 - i2) {",
          "608:                         FFSWAP(int, stt[256 - i], stt[256 - i2]);",
          "609:                         FFSWAP(int, s->rc_stat[256 - i][0], s->rc_stat[256 - i2][0]);",
          "610:                         FFSWAP(int, s->rc_stat[256 - i][1], s->rc_stat[256 - i2][1]);",
          "611:                     }",
          "612:                     for (j = 1; j < 256; j++) {",
          "613:                         if (stt[j] == i)",
          "614:                             stt[j] = i2;",
          "615:                         else if (stt[j] == i2)",
          "616:                             stt[j] = i;",
          "617:                         if (i != 256 - i2) {",
          "618:                             if (stt[256 - j] == 256 - i)",
          "619:                                 stt[256 - j] = 256 - i2;",
          "620:                             else if (stt[256 - j] == 256 - i2)",
          "621:                                 stt[256 - j] = 256 - i;",
          "622:                         }",
          "623:                     }",
          "624:                     print = changed = 1;",
          "625:                 }",
          "626:             }",
          "627:         }",
          "628:     } while (changed);",
          "629:     return print;",
          "630: }",
          "632: static av_cold int encode_init(AVCodecContext *avctx)",
          "633: {",
          "634:     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "635:     FFV1Context *s = avctx->priv_data;",
          "636:     int i, j, k, m;",
          "638:     ffv1_common_init(avctx);",
          "640:     s->version = 0;",
          "642:     if ((avctx->flags & (CODEC_FLAG_PASS1|CODEC_FLAG_PASS2)) || avctx->slices>1)",
          "643:         s->version = FFMAX(s->version, 2);",
          "645:     if (avctx->level == 3) {",
          "646:         s->version = 3;",
          "647:     }",
          "649:     if (s->ec < 0) {",
          "650:         s->ec = (s->version >= 3);",
          "651:     }",
          "653:     if (s->version >= 2 && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {",
          "654:         av_log(avctx, AV_LOG_ERROR, \"Version 2 needed for requested features but version 2 is experimental and not enabled\\n\");",
          "655:         return AVERROR_INVALIDDATA;",
          "656:     }",
          "658:     s->ac = avctx->coder_type > 0 ? 2 : 0;",
          "660:     s->plane_count = 3;",
          "661:     switch(avctx->pix_fmt) {",
          "662:     case AV_PIX_FMT_YUV444P9:",
          "663:     case AV_PIX_FMT_YUV422P9:",
          "664:     case AV_PIX_FMT_YUV420P9:",
          "665:         if (!avctx->bits_per_raw_sample)",
          "666:             s->bits_per_raw_sample = 9;",
          "667:     case AV_PIX_FMT_YUV444P10:",
          "668:     case AV_PIX_FMT_YUV420P10:",
          "669:     case AV_PIX_FMT_YUV422P10:",
          "670:         s->packed_at_lsb = 1;",
          "671:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "672:             s->bits_per_raw_sample = 10;",
          "673:     case AV_PIX_FMT_GRAY16:",
          "674:     case AV_PIX_FMT_YUV444P16:",
          "675:     case AV_PIX_FMT_YUV422P16:",
          "676:     case AV_PIX_FMT_YUV420P16:",
          "677:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {",
          "678:             s->bits_per_raw_sample = 16;",
          "679:         } else if (!s->bits_per_raw_sample) {",
          "680:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "681:         }",
          "682:         if (s->bits_per_raw_sample <= 8) {",
          "683:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "684:             return AVERROR_INVALIDDATA;",
          "685:         }",
          "686:         if (!s->ac && avctx->coder_type == -1) {",
          "687:             av_log(avctx, AV_LOG_INFO, \"bits_per_raw_sample > 8, forcing coder 1\\n\");",
          "688:             s->ac = 2;",
          "689:         }",
          "690:         if (!s->ac) {",
          "691:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "692:             return AVERROR_INVALIDDATA;",
          "693:         }",
          "694:         s->version = FFMAX(s->version, 1);",
          "695:     case AV_PIX_FMT_GRAY8:",
          "696:     case AV_PIX_FMT_YUV444P:",
          "697:     case AV_PIX_FMT_YUV440P:",
          "698:     case AV_PIX_FMT_YUV422P:",
          "699:     case AV_PIX_FMT_YUV420P:",
          "700:     case AV_PIX_FMT_YUV411P:",
          "701:     case AV_PIX_FMT_YUV410P:",
          "702:         s->chroma_planes = desc->nb_components < 3 ? 0 : 1;",
          "703:         s->colorspace = 0;",
          "704:         break;",
          "705:     case AV_PIX_FMT_YUVA444P:",
          "706:     case AV_PIX_FMT_YUVA422P:",
          "707:     case AV_PIX_FMT_YUVA420P:",
          "708:         s->chroma_planes = 1;",
          "709:         s->colorspace = 0;",
          "710:         s->transparency = 1;",
          "711:         break;",
          "712:     case AV_PIX_FMT_RGB32:",
          "713:         s->colorspace = 1;",
          "714:         s->transparency = 1;",
          "715:         break;",
          "716:     case AV_PIX_FMT_0RGB32:",
          "717:         s->colorspace = 1;",
          "718:         break;",
          "719:     case AV_PIX_FMT_GBRP9:",
          "720:         if (!avctx->bits_per_raw_sample)",
          "721:             s->bits_per_raw_sample = 9;",
          "722:     case AV_PIX_FMT_GBRP10:",
          "723:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "724:             s->bits_per_raw_sample = 10;",
          "725:     case AV_PIX_FMT_GBRP12:",
          "726:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "727:             s->bits_per_raw_sample = 12;",
          "728:     case AV_PIX_FMT_GBRP14:",
          "729:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "730:             s->bits_per_raw_sample = 14;",
          "731:         else if (!s->bits_per_raw_sample)",
          "732:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "733:         s->colorspace = 1;",
          "734:         s->chroma_planes = 1;",
          "735:         s->version = FFMAX(s->version, 1);",
          "736:         break;",
          "737:     default:",
          "738:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "739:         return AVERROR_INVALIDDATA;",
          "740:     }",
          "741:     if (s->transparency) {",
          "742:         av_log(avctx, AV_LOG_WARNING, \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");",
          "743:     }",
          "744:     if (avctx->context_model > 1U) {",
          "745:         av_log(avctx, AV_LOG_ERROR, \"Invalid context model %d, valid values are 0 and 1\\n\", avctx->context_model);",
          "746:         return AVERROR(EINVAL);",
          "747:     }",
          "749:     if (s->ac > 1)",
          "750:         for (i = 1; i < 256; i++)",
          "751:             s->state_transition[i] = ver2_state[i];",
          "753:     for (i = 0; i < 256; i++) {",
          "754:         s->quant_table_count = 2;",
          "755:         if (s->bits_per_raw_sample <= 8) {",
          "756:             s->quant_tables[0][0][i]=           quant11[i];",
          "757:             s->quant_tables[0][1][i]=        11*quant11[i];",
          "758:             s->quant_tables[0][2][i]=     11*11*quant11[i];",
          "759:             s->quant_tables[1][0][i]=           quant11[i];",
          "760:             s->quant_tables[1][1][i]=        11*quant11[i];",
          "761:             s->quant_tables[1][2][i]=     11*11*quant5 [i];",
          "762:             s->quant_tables[1][3][i]=   5*11*11*quant5 [i];",
          "763:             s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i];",
          "764:         } else {",
          "765:             s->quant_tables[0][0][i]=           quant9_10bit[i];",
          "766:             s->quant_tables[0][1][i]=        11*quant9_10bit[i];",
          "767:             s->quant_tables[0][2][i]=     11*11*quant9_10bit[i];",
          "768:             s->quant_tables[1][0][i]=           quant9_10bit[i];",
          "769:             s->quant_tables[1][1][i]=        11*quant9_10bit[i];",
          "770:             s->quant_tables[1][2][i]=     11*11*quant5_10bit[i];",
          "771:             s->quant_tables[1][3][i]=   5*11*11*quant5_10bit[i];",
          "772:             s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i];",
          "773:         }",
          "774:     }",
          "775:     s->context_count[0] = (11 * 11 * 11        + 1) / 2;",
          "776:     s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;",
          "777:     memcpy(s->quant_table, s->quant_tables[avctx->context_model],",
          "778:            sizeof(s->quant_table));",
          "780:     for (i = 0; i < s->plane_count; i++) {",
          "781:         PlaneContext *const p = &s->plane[i];",
          "783:         memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));",
          "784:         p->quant_table_index = avctx->context_model;",
          "785:         p->context_count     = s->context_count[p->quant_table_index];",
          "786:     }",
          "788:     if (ffv1_allocate_initial_states(s) < 0)",
          "789:         return AVERROR(ENOMEM);",
          "791:     avctx->coded_frame = &s->picture;",
          "792:     if (!s->transparency)",
          "793:         s->plane_count = 2;",
          "794:     avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);",
          "795:     s->picture_number = 0;",
          "797:     if (avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) {",
          "798:         for (i = 0; i < s->quant_table_count; i++) {",
          "799:             s->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "800:                                         sizeof(*s->rc_stat2[i]));",
          "801:             if (!s->rc_stat2[i])",
          "802:                 return AVERROR(ENOMEM);",
          "803:         }",
          "804:     }",
          "805:     if (avctx->stats_in) {",
          "806:         char *p = avctx->stats_in;",
          "807:         uint8_t best_state[256][256];",
          "808:         int gob_count = 0;",
          "809:         char *next;",
          "811:         av_assert0(s->version >= 2);",
          "813:         for (;;) {",
          "814:             for (j = 0; j < 256; j++)",
          "815:                 for (i = 0; i < 2; i++) {",
          "816:                     s->rc_stat[j][i] = strtol(p, &next, 0);",
          "817:                     if (next == p) {",
          "818:                         av_log(avctx, AV_LOG_ERROR,",
          "819:                                \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);",
          "820:                         return -1;",
          "821:                     }",
          "822:                     p = next;",
          "823:                 }",
          "824:             for (i = 0; i < s->quant_table_count; i++)",
          "825:                 for (j = 0; j < s->context_count[i]; j++) {",
          "826:                     for (k = 0; k < 32; k++)",
          "827:                         for (m = 0; m < 2; m++) {",
          "828:                             s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);",
          "829:                             if (next == p) {",
          "830:                                 av_log(avctx, AV_LOG_ERROR,",
          "831:                                        \"2Pass file invalid at %d %d %d %d [%s]\\n\",",
          "832:                                        i, j, k, m, p);",
          "833:                                 return AVERROR_INVALIDDATA;",
          "834:                             }",
          "835:                             p = next;",
          "836:                         }",
          "837:                 }",
          "838:             gob_count = strtol(p, &next, 0);",
          "839:             if (next == p || gob_count <= 0) {",
          "840:                 av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");",
          "841:                 return AVERROR_INVALIDDATA;",
          "842:             }",
          "843:             p = next;",
          "844:             while (*p == '\\n' || *p == ' ')",
          "845:                 p++;",
          "846:             if (p[0] == 0)",
          "847:                 break;",
          "848:         }",
          "849:         sort_stt(s, s->state_transition);",
          "851:         find_best_state(best_state, s->state_transition);",
          "853:         for (i = 0; i < s->quant_table_count; i++) {",
          "854:             for (j = 0; j < s->context_count[i]; j++)",
          "855:                 for (k = 0; k < 32; k++) {",
          "856:                     double p = 128;",
          "857:                     if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) {",
          "858:                         p = 256.0 * s->rc_stat2[i][j][k][1] /",
          "859:                             (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]);",
          "860:                     }",
          "861:                     s->initial_states[i][j][k] =",
          "862:                         best_state[av_clip(round(p), 1, 255)][av_clip((s->rc_stat2[i][j][k][0] +",
          "863:                                                                        s->rc_stat2[i][j][k][1]) /",
          "864:                                                                       gob_count, 0, 255)];",
          "865:                 }",
          "866:         }",
          "867:     }",
          "869:     if (s->version > 1) {",
          "870:         for (s->num_v_slices = 2; s->num_v_slices < 9; s->num_v_slices++) {",
          "871:             for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) {",
          "872:                 if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= 64 || !avctx->slices)",
          "873:                     goto slices_ok;",
          "874:             }",
          "875:         }",
          "876:         av_log(avctx, AV_LOG_ERROR, \"Unsupported number %d of slices requested, please specify a supported number with -slices (ex:4,6,9,12,16, ...)\\n\", avctx->slices);",
          "877:         return -1;",
          "878:         slices_ok:",
          "879:         write_extra_header(s);",
          "880:     }",
          "882:     if (ffv1_init_slice_contexts(s) < 0)",
          "883:         return -1;",
          "884:     if (ffv1_init_slices_state(s) < 0)",
          "885:         return -1;",
          "887: #define STATS_OUT_SIZE 1024 * 1024 * 6",
          "888:     if (avctx->flags & CODEC_FLAG_PASS1) {",
          "889:         avctx->stats_out = av_mallocz(STATS_OUT_SIZE);",
          "890:         for (i = 0; i < s->quant_table_count; i++)",
          "891:             for (j = 0; j < s->slice_count; j++) {",
          "892:                 FFV1Context *sf = s->slice_context[j];",
          "893:                 av_assert0(!sf->rc_stat2[i]);",
          "894:                 sf->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "895:                                              sizeof(*sf->rc_stat2[i]));",
          "896:                 if (!sf->rc_stat2[i])",
          "897:                     return AVERROR(ENOMEM);",
          "898:             }",
          "899:     }",
          "901:     return 0;",
          "902: }",
          "904: static void encode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "905: {",
          "906:     RangeCoder *c = &fs->c;",
          "907:     uint8_t state[CONTEXT_SIZE];",
          "908:     int j;",
          "909:     memset(state, 128, sizeof(state));",
          "911:     put_symbol(c, state, (fs->slice_x     +1)*f->num_h_slices / f->width   , 0);",
          "912:     put_symbol(c, state, (fs->slice_y     +1)*f->num_v_slices / f->height  , 0);",
          "913:     put_symbol(c, state, (fs->slice_width +1)*f->num_h_slices / f->width -1, 0);",
          "914:     put_symbol(c, state, (fs->slice_height+1)*f->num_v_slices / f->height-1, 0);",
          "915:     for (j=0; j<f->plane_count; j++) {",
          "916:         put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "917:         av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "918:     }",
          "919:     if (!f->picture.interlaced_frame) put_symbol(c, state, 3, 0);",
          "920:     else                             put_symbol(c, state, 1 + !f->picture.top_field_first, 0);",
          "921:     put_symbol(c, state, f->picture.sample_aspect_ratio.num, 0);",
          "922:     put_symbol(c, state, f->picture.sample_aspect_ratio.den, 0);",
          "923: }",
          "925: static int encode_slice(AVCodecContext *c, void *arg)",
          "926: {",
          "927:     FFV1Context *fs  = *(void **)arg;",
          "928:     FFV1Context *f   = fs->avctx->priv_data;",
          "929:     int width        = fs->slice_width;",
          "930:     int height       = fs->slice_height;",
          "931:     int x            = fs->slice_x;",
          "932:     int y            = fs->slice_y;",
          "933:     AVFrame *const p = &f->picture;",
          "934:     const int ps     = av_pix_fmt_desc_get(c->pix_fmt)->comp[0].step_minus1 + 1;",
          "936:     if (p->key_frame)",
          "937:         ffv1_clear_slice_state(f, fs);",
          "938:     if (f->version > 2) {",
          "939:         encode_slice_header(f, fs);",
          "940:     }",
          "941:     if (!fs->ac) {",
          "942:         if (f->version > 2)",
          "943:             put_rac(&fs->c, (uint8_t[]) {129}, 0);",
          "944:         fs->ac_byte_count = f->version > 2 || (!x&&!y) ? ff_rac_terminate(&fs->c) : 0;",
          "945:         init_put_bits(&fs->pb, fs->c.bytestream_start + fs->ac_byte_count, fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count);",
          "946:     }",
          "948:     if (f->colorspace == 0) {",
          "949:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "950:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "951:         const int cx            = x >> f->chroma_h_shift;",
          "952:         const int cy            = y >> f->chroma_v_shift;",
          "954:         encode_plane(fs, p->data[0] + ps*x + y*p->linesize[0], width, height, p->linesize[0], 0);",
          "956:         if (f->chroma_planes) {",
          "957:             encode_plane(fs, p->data[1] + ps*cx+cy*p->linesize[1], chroma_width, chroma_height, p->linesize[1], 1);",
          "958:             encode_plane(fs, p->data[2] + ps*cx+cy*p->linesize[2], chroma_width, chroma_height, p->linesize[2], 1);",
          "959:         }",
          "960:         if (fs->transparency)",
          "961:             encode_plane(fs, p->data[3] + ps*x + y*p->linesize[3], width, height, p->linesize[3], 2);",
          "962:     } else {",
          "963:         uint8_t *planes[3] = {p->data[0] + ps*x + y*p->linesize[0],",
          "964:                               p->data[1] + ps*x + y*p->linesize[1],",
          "965:                               p->data[2] + ps*x + y*p->linesize[2]};",
          "966:         encode_rgb_frame(fs, planes, width, height, p->linesize);",
          "967:     }",
          "968:     emms_c();",
          "970:     return 0;",
          "971: }",
          "973: static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,",
          "974:                         const AVFrame *pict, int *got_packet)",
          "975: {",
          "976:     FFV1Context *f      = avctx->priv_data;",
          "977:     RangeCoder *const c = &f->slice_context[0]->c;",
          "978:     AVFrame *const p    = &f->picture;",
          "979:     int used_count      = 0;",
          "980:     uint8_t keystate    = 128;",
          "981:     uint8_t *buf_p;",
          "982:     int i, ret;",
          "984:     if ((ret = ff_alloc_packet2(avctx, pkt, avctx->width*avctx->height*((8*2+1+1)*4)/8",
          "985:                                             + FF_MIN_BUFFER_SIZE)) < 0)",
          "986:         return ret;",
          "988:     ff_init_range_encoder(c, pkt->data, pkt->size);",
          "989:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "992:     p->pict_type = AV_PICTURE_TYPE_I;",
          "994:     if (avctx->gop_size == 0 || f->picture_number % avctx->gop_size == 0) {",
          "995:         put_rac(c, &keystate, 1);",
          "996:         p->key_frame = 1;",
          "997:         f->gob_count++;",
          "998:         write_header(f);",
          "999:     } else {",
          "1000:         put_rac(c, &keystate, 0);",
          "1001:         p->key_frame = 0;",
          "1002:     }",
          "1004:     if (f->ac > 1) {",
          "1005:         int i;",
          "1006:         for (i = 1; i < 256; i++) {",
          "1007:             c->one_state[i]        = f->state_transition[i];",
          "1008:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "1009:         }",
          "1010:     }",
          "1012:     for (i = 1; i < f->slice_count; i++) {",
          "1013:         FFV1Context *fs = f->slice_context[i];",
          "1014:         uint8_t *start  = pkt->data + (pkt->size - used_count) * (int64_t)i / f->slice_count;",
          "1015:         int len         = pkt->size / f->slice_count;",
          "1016:         ff_init_range_encoder(&fs->c, start, len);",
          "1017:     }",
          "1018:     avctx->execute(avctx, encode_slice, &f->slice_context[0], NULL,",
          "1019:                    f->slice_count, sizeof(void *));",
          "1021:     buf_p = pkt->data;",
          "1022:     for (i = 0; i < f->slice_count; i++) {",
          "1023:         FFV1Context *fs = f->slice_context[i];",
          "1024:         int bytes;",
          "1026:         if (fs->ac) {",
          "1027:             uint8_t state=129;",
          "1028:             put_rac(&fs->c, &state, 0);",
          "1029:             bytes = ff_rac_terminate(&fs->c);",
          "1030:         } else {",
          "1031:             flush_put_bits(&fs->pb); // FIXME: nicer padding",
          "1032:             bytes = fs->ac_byte_count + (put_bits_count(&fs->pb) + 7)/8;",
          "1033:         }",
          "1034:         if (i > 0 || f->version > 2) {",
          "1035:             av_assert0(bytes < pkt->size / f->slice_count);",
          "1036:             memmove(buf_p, fs->c.bytestream_start, bytes);",
          "1037:             av_assert0(bytes < (1 << 24));",
          "1038:             AV_WB24(buf_p + bytes, bytes);",
          "1039:             bytes += 3;",
          "1040:         }",
          "1041:         if (f->ec) {",
          "1042:             unsigned v;",
          "1043:             buf_p[bytes++] = 0;",
          "1044:             v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, bytes);",
          "1045:             AV_WL32(buf_p + bytes, v); bytes += 4;",
          "1046:         }",
          "1047:         buf_p += bytes;",
          "1048:     }",
          "1050:     if ((avctx->flags & CODEC_FLAG_PASS1) && (f->picture_number & 31) == 0) {",
          "1051:         int j, k, m;",
          "1052:         char *p   = avctx->stats_out;",
          "1053:         char *end = p + STATS_OUT_SIZE;",
          "1055:         memset(f->rc_stat, 0, sizeof(f->rc_stat));",
          "1056:         for (i = 0; i < f->quant_table_count; i++)",
          "1057:             memset(f->rc_stat2[i], 0, f->context_count[i] * sizeof(*f->rc_stat2[i]));",
          "1059:         for (j = 0; j < f->slice_count; j++) {",
          "1060:             FFV1Context *fs = f->slice_context[j];",
          "1061:             for (i = 0; i < 256; i++) {",
          "1062:                 f->rc_stat[i][0] += fs->rc_stat[i][0];",
          "1063:                 f->rc_stat[i][1] += fs->rc_stat[i][1];",
          "1064:             }",
          "1065:             for (i = 0; i < f->quant_table_count; i++) {",
          "1066:                 for (k = 0; k < f->context_count[i]; k++)",
          "1067:                     for (m = 0; m < 32; m++) {",
          "1068:                         f->rc_stat2[i][k][m][0] += fs->rc_stat2[i][k][m][0];",
          "1069:                         f->rc_stat2[i][k][m][1] += fs->rc_stat2[i][k][m][1];",
          "1070:                     }",
          "1071:             }",
          "1072:         }",
          "1074:         for (j = 0; j < 256; j++) {",
          "1075:             snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "1076:                      f->rc_stat[j][0], f->rc_stat[j][1]);",
          "1077:             p += strlen(p);",
          "1078:         }",
          "1079:         snprintf(p, end - p, \"\\n\");",
          "1081:         for (i = 0; i < f->quant_table_count; i++) {",
          "1082:             for (j = 0; j < f->context_count[i]; j++)",
          "1083:                 for (m = 0; m < 32; m++) {",
          "1084:                     snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "1085:                              f->rc_stat2[i][j][m][0], f->rc_stat2[i][j][m][1]);",
          "1086:                     p += strlen(p);",
          "1087:                 }",
          "1088:         }",
          "1089:         snprintf(p, end - p, \"%d\\n\", f->gob_count);",
          "1090:     } else if (avctx->flags & CODEC_FLAG_PASS1)",
          "1091:         avctx->stats_out[0] = '\\0';",
          "1093:     f->picture_number++;",
          "1094:     pkt->size   = buf_p - pkt->data;",
          "1095:     pkt->flags |= AV_PKT_FLAG_KEY * p->key_frame;",
          "1098:     return 0;",
          "1099: }",
          "1101: #define OFFSET(x) offsetof(FFV1Context, x)",
          "1102: #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM",
          "1103: static const AVOption options[] = {",
          "1104:     { \"slicecrc\",        \"Protect slices with CRCs\",               OFFSET(ec),              AV_OPT_TYPE_INT, {.i64 = -1}, -1, 1, VE},",
          "1105: {NULL}",
          "1106: };",
          "1108: static const AVClass class = {",
          "1109:     .class_name = \"ffv1 encoder\",",
          "1110:     .item_name  = av_default_item_name,",
          "1111:     .option     = options,",
          "1112:     .version    = LIBAVUTIL_VERSION_INT,",
          "1113: };",
          "1115: static const AVCodecDefault ffv1_defaults[] = {",
          "1116:     { \"coder\",                \"-1\" },",
          "1117:     { NULL },",
          "1118: };",
          "1120: AVCodec ff_ffv1_encoder = {",
          "1121:     .name           = \"ffv1\",",
          "1122:     .type           = AVMEDIA_TYPE_VIDEO,",
          "1123:     .id             = AV_CODEC_ID_FFV1,",
          "1124:     .priv_data_size = sizeof(FFV1Context),",
          "1125:     .init           = encode_init,",
          "1126:     .encode2        = encode_frame,",
          "1127:     .close          = ffv1_common_end,",
          "1128:     .capabilities   = CODEC_CAP_SLICE_THREADS,",
          "1129:     .defaults       = ffv1_defaults,",
          "1130:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "1131:         AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUV444P,",
          "1132:         AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV411P,",
          "1133:         AV_PIX_FMT_YUV410P, AV_PIX_FMT_0RGB32, AV_PIX_FMT_RGB32, AV_PIX_FMT_YUV420P16,",
          "1134:         AV_PIX_FMT_YUV422P16, AV_PIX_FMT_YUV444P16, AV_PIX_FMT_YUV444P9, AV_PIX_FMT_YUV422P9,",
          "1135:         AV_PIX_FMT_YUV420P9, AV_PIX_FMT_YUV420P10, AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV444P10,",
          "1136:         AV_PIX_FMT_GRAY16, AV_PIX_FMT_GRAY8, AV_PIX_FMT_GBRP9, AV_PIX_FMT_GBRP10,",
          "1137:         AV_PIX_FMT_GBRP12, AV_PIX_FMT_GBRP14,",
          "1138:         AV_PIX_FMT_NONE",
          "1139:     },",
          "1140:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "1141:     .priv_class     = &class,",
          "1142: };",
          "",
          "---------------"
        ]
      }
    }
  ]
}
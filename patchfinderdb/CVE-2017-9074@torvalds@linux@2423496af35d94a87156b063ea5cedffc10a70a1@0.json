{
  "cve_id": "CVE-2017-9074",
  "cve_desc": "The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls.",
  "repo": "torvalds/linux",
  "patch_hash": "2423496af35d94a87156b063ea5cedffc10a70a1",
  "patch_info": {
    "commit_hash": "2423496af35d94a87156b063ea5cedffc10a70a1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1",
    "files": [
      "net/ipv6/ip6_offload.c",
      "net/ipv6/ip6_output.c",
      "net/ipv6/output_core.c",
      "net/ipv6/udp_offload.c"
    ],
    "message": "ipv6: Prevent overrun when parsing v6 header options\n\nThe KASAN warning repoted below was discovered with a syzkaller\nprogram.  The reproducer is basically:\n  int s = socket(AF_INET6, SOCK_RAW, NEXTHDR_HOP);\n  send(s, &one_byte_of_data, 1, MSG_MORE);\n  send(s, &more_than_mtu_bytes_data, 2000, 0);\n\nThe socket() call sets the nexthdr field of the v6 header to\nNEXTHDR_HOP, the first send call primes the payload with a non zero\nbyte of data, and the second send call triggers the fragmentation path.\n\nThe fragmentation code tries to parse the header options in order\nto figure out where to insert the fragment option.  Since nexthdr points\nto an invalid option, the calculation of the size of the network header\ncan made to be much larger than the linear section of the skb and data\nis read outside of it.\n\nThis fix makes ip6_find_1stfrag return an error if it detects\nrunning out-of-bounds.\n\n[   42.361487] ==================================================================\n[   42.364412] BUG: KASAN: slab-out-of-bounds in ip6_fragment+0x11c8/0x3730\n[   42.365471] Read of size 840 at addr ffff88000969e798 by task ip6_fragment-oo/3789\n[   42.366469]\n[   42.366696] CPU: 1 PID: 3789 Comm: ip6_fragment-oo Not tainted 4.11.0+ #41\n[   42.367628] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04/01/2014\n[   42.368824] Call Trace:\n[   42.369183]  dump_stack+0xb3/0x10b\n[   42.369664]  print_address_description+0x73/0x290\n[   42.370325]  kasan_report+0x252/0x370\n[   42.370839]  ? ip6_fragment+0x11c8/0x3730\n[   42.371396]  check_memory_region+0x13c/0x1a0\n[   42.371978]  memcpy+0x23/0x50\n[   42.372395]  ip6_fragment+0x11c8/0x3730\n[   42.372920]  ? nf_ct_expect_unregister_notifier+0x110/0x110\n[   42.373681]  ? ip6_copy_metadata+0x7f0/0x7f0\n[   42.374263]  ? ip6_forward+0x2e30/0x2e30\n[   42.374803]  ip6_finish_output+0x584/0x990\n[   42.375350]  ip6_output+0x1b7/0x690\n[   42.375836]  ? ip6_finish_output+0x990/0x990\n[   42.376411]  ? ip6_fragment+0x3730/0x3730\n[   42.376968]  ip6_local_out+0x95/0x160\n[   42.377471]  ip6_send_skb+0xa1/0x330\n[   42.377969]  ip6_push_pending_frames+0xb3/0xe0\n[   42.378589]  rawv6_sendmsg+0x2051/0x2db0\n[   42.379129]  ? rawv6_bind+0x8b0/0x8b0\n[   42.379633]  ? _copy_from_user+0x84/0xe0\n[   42.380193]  ? debug_check_no_locks_freed+0x290/0x290\n[   42.380878]  ? ___sys_sendmsg+0x162/0x930\n[   42.381427]  ? rcu_read_lock_sched_held+0xa3/0x120\n[   42.382074]  ? sock_has_perm+0x1f6/0x290\n[   42.382614]  ? ___sys_sendmsg+0x167/0x930\n[   42.383173]  ? lock_downgrade+0x660/0x660\n[   42.383727]  inet_sendmsg+0x123/0x500\n[   42.384226]  ? inet_sendmsg+0x123/0x500\n[   42.384748]  ? inet_recvmsg+0x540/0x540\n[   42.385263]  sock_sendmsg+0xca/0x110\n[   42.385758]  SYSC_sendto+0x217/0x380\n[   42.386249]  ? SYSC_connect+0x310/0x310\n[   42.386783]  ? __might_fault+0x110/0x1d0\n[   42.387324]  ? lock_downgrade+0x660/0x660\n[   42.387880]  ? __fget_light+0xa1/0x1f0\n[   42.388403]  ? __fdget+0x18/0x20\n[   42.388851]  ? sock_common_setsockopt+0x95/0xd0\n[   42.389472]  ? SyS_setsockopt+0x17f/0x260\n[   42.390021]  ? entry_SYSCALL_64_fastpath+0x5/0xbe\n[   42.390650]  SyS_sendto+0x40/0x50\n[   42.391103]  entry_SYSCALL_64_fastpath+0x1f/0xbe\n[   42.391731] RIP: 0033:0x7fbbb711e383\n[   42.392217] RSP: 002b:00007ffff4d34f28 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\n[   42.393235] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fbbb711e383\n[   42.394195] RDX: 0000000000001000 RSI: 00007ffff4d34f60 RDI: 0000000000000003\n[   42.395145] RBP: 0000000000000046 R08: 00007ffff4d34f40 R09: 0000000000000018\n[   42.396056] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400aad\n[   42.396598] R13: 0000000000000066 R14: 00007ffff4d34ee0 R15: 00007fbbb717af00\n[   42.397257]\n[   42.397411] Allocated by task 3789:\n[   42.397702]  save_stack_trace+0x16/0x20\n[   42.398005]  save_stack+0x46/0xd0\n[   42.398267]  kasan_kmalloc+0xad/0xe0\n[   42.398548]  kasan_slab_alloc+0x12/0x20\n[   42.398848]  __kmalloc_node_track_caller+0xcb/0x380\n[   42.399224]  __kmalloc_reserve.isra.32+0x41/0xe0\n[   42.399654]  __alloc_skb+0xf8/0x580\n[   42.400003]  sock_wmalloc+0xab/0xf0\n[   42.400346]  __ip6_append_data.isra.41+0x2472/0x33d0\n[   42.400813]  ip6_append_data+0x1a8/0x2f0\n[   42.401122]  rawv6_sendmsg+0x11ee/0x2db0\n[   42.401505]  inet_sendmsg+0x123/0x500\n[   42.401860]  sock_sendmsg+0xca/0x110\n[   42.402209]  ___sys_sendmsg+0x7cb/0x930\n[   42.402582]  __sys_sendmsg+0xd9/0x190\n[   42.402941]  SyS_sendmsg+0x2d/0x50\n[   42.403273]  entry_SYSCALL_64_fastpath+0x1f/0xbe\n[   42.403718]\n[   42.403871] Freed by task 1794:\n[   42.404146]  save_stack_trace+0x16/0x20\n[   42.404515]  save_stack+0x46/0xd0\n[   42.404827]  kasan_slab_free+0x72/0xc0\n[   42.405167]  kfree+0xe8/0x2b0\n[   42.405462]  skb_free_head+0x74/0xb0\n[   42.405806]  skb_release_data+0x30e/0x3a0\n[   42.406198]  skb_release_all+0x4a/0x60\n[   42.406563]  consume_skb+0x113/0x2e0\n[   42.406910]  skb_free_datagram+0x1a/0xe0\n[   42.407288]  netlink_recvmsg+0x60d/0xe40\n[   42.407667]  sock_recvmsg+0xd7/0x110\n[   42.408022]  ___sys_recvmsg+0x25c/0x580\n[   42.408395]  __sys_recvmsg+0xd6/0x190\n[   42.408753]  SyS_recvmsg+0x2d/0x50\n[   42.409086]  entry_SYSCALL_64_fastpath+0x1f/0xbe\n[   42.409513]\n[   42.409665] The buggy address belongs to the object at ffff88000969e780\n[   42.409665]  which belongs to the cache kmalloc-512 of size 512\n[   42.410846] The buggy address is located 24 bytes inside of\n[   42.410846]  512-byte region [ffff88000969e780, ffff88000969e980)\n[   42.411941] The buggy address belongs to the page:\n[   42.412405] page:ffffea000025a780 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0\n[   42.413298] flags: 0x100000000008100(slab|head)\n[   42.413729] raw: 0100000000008100 0000000000000000 0000000000000000 00000001800c000c\n[   42.414387] raw: ffffea00002a9500 0000000900000007 ffff88000c401280 0000000000000000\n[   42.415074] page dumped because: kasan: bad access detected\n[   42.415604]\n[   42.415757] Memory state around the buggy address:\n[   42.416222]  ffff88000969e880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   42.416904]  ffff88000969e900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   42.417591] >ffff88000969e980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   42.418273]                    ^\n[   42.418588]  ffff88000969ea00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   42.419273]  ffff88000969ea80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   42.419882] ==================================================================\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Craig Gallek <kraig@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c",
      "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
      "net/ipv6/output_core.c||net/ipv6/output_core.c",
      "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
      "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "118:   if (udpfrag) {",
      "119:    unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
      "120:    fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);",
      "121:    fptr->frag_off = htons(offset);",
      "122:    if (skb->next)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "120:    if (unfrag_ip6hlen < 0)",
      "121:     return ERR_PTR(unfrag_ip6hlen);",
      "",
      "---------------"
    ],
    "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
      "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "598:  u8 *prevhdr, nexthdr = 0;",
      "600:  hlen = ip6_find_1stfragopt(skb, &prevhdr);",
      "601:  nexthdr = *prevhdr;",
      "603:  mtu = ip6_skb_dst_mtu(skb);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "601:  if (hlen < 0) {",
      "602:   err = hlen;",
      "603:   goto fail;",
      "604:  }",
      "",
      "---------------"
    ],
    "net/ipv6/output_core.c||net/ipv6/output_core.c": [
      "File: net/ipv6/output_core.c -> net/ipv6/output_core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "79: int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)",
      "80: {",
      "81:  u16 offset = sizeof(struct ipv6hdr);",
      "84:  unsigned int packet_len = skb_tail_pointer(skb) -",
      "85:   skb_network_header(skb);",
      "86:  int found_rhdr = 0;",
      "91:   switch (**nexthdr) {",
      "",
      "[Removed Lines]",
      "82:  struct ipv6_opt_hdr *exthdr =",
      "83:     (struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);",
      "89:  while (offset + 1 <= packet_len) {",
      "",
      "[Added Lines]",
      "87:  while (offset <= packet_len) {",
      "88:   struct ipv6_opt_hdr *exthdr;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "107:    return offset;",
      "108:   }",
      "112:   exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +",
      "113:        offset);",
      "114:  }",
      "117: }",
      "118: EXPORT_SYMBOL(ip6_find_1stfragopt);",
      "",
      "[Removed Lines]",
      "110:   offset += ipv6_optlen(exthdr);",
      "116:  return offset;",
      "",
      "[Added Lines]",
      "109:   if (offset + sizeof(struct ipv6_opt_hdr) > packet_len)",
      "110:    return -EINVAL;",
      "114:   offset += ipv6_optlen(exthdr);",
      "118:  return -EINVAL;",
      "",
      "---------------"
    ],
    "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c": [
      "File: net/ipv6/udp_offload.c -> net/ipv6/udp_offload.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "93:   unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
      "94:   nexthdr = *prevhdr;",
      "96:   unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "94:   if (unfrag_ip6hlen < 0)",
      "95:    return ERR_PTR(unfrag_ip6hlen);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e3e86b5119f81e5e2499bea7ea1ebe8ac6aab789",
      "candidate_info": {
        "commit_hash": "e3e86b5119f81e5e2499bea7ea1ebe8ac6aab789",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e3e86b5119f81e5e2499bea7ea1ebe8ac6aab789",
        "files": [
          "net/ipv6/ip6_offload.c"
        ],
        "message": "ipv6: Fix leak in ipv6_gso_segment().\n\nIf ip6_find_1stfragopt() fails and we return an error we have to free\nup 'segs' because nobody else is going to.\n\nFixes: 2423496af35d (\"ipv6: Prevent overrun when parsing v6 header options\")\nReported-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
          ],
          "candidate": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
          "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "117:   if (udpfrag) {",
          "118:    int err = ip6_find_1stfragopt(skb, &prevhdr);",
          "120:     return ERR_PTR(err);",
          "121:    fptr = (struct frag_hdr *)((u8 *)ipv6h + err);",
          "122:    fptr->frag_off = htons(offset);",
          "123:    if (skb->next)",
          "",
          "[Removed Lines]",
          "119:    if (err < 0)",
          "",
          "[Added Lines]",
          "119:    if (err < 0) {",
          "120:     kfree_skb_list(segs);",
          "122:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7dd7eb9513bd02184d45f000ab69d78cb1fa1531",
      "candidate_info": {
        "commit_hash": "7dd7eb9513bd02184d45f000ab69d78cb1fa1531",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7dd7eb9513bd02184d45f000ab69d78cb1fa1531",
        "files": [
          "net/ipv6/ip6_offload.c",
          "net/ipv6/ip6_output.c",
          "net/ipv6/udp_offload.c"
        ],
        "message": "ipv6: Check ip6_find_1stfragopt() return value properly.\n\nDo not use unsigned variables to see if it returns a negative\nerror or not.\n\nFixes: 2423496af35d (\"ipv6: Prevent overrun when parsing v6 header options\")\nReported-by: Julia Lawall <julia.lawall@lip6.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c",
          "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
          "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c",
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ],
          "candidate": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c",
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
          "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:  const struct net_offload *ops;",
          "64:  int proto;",
          "65:  struct frag_hdr *fptr;",
          "67:  unsigned int payload_len;",
          "68:  u8 *prevhdr;",
          "69:  int offset = 0;",
          "",
          "[Removed Lines]",
          "66:  unsigned int unfrag_ip6hlen;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116:   skb->network_header = (u8 *)ipv6h - skb->head;",
          "118:   if (udpfrag) {",
          "123:    fptr->frag_off = htons(offset);",
          "124:    if (skb->next)",
          "125:     fptr->frag_off |= htons(IP6_MF);",
          "",
          "[Removed Lines]",
          "119:    unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "120:    if (unfrag_ip6hlen < 0)",
          "121:     return ERR_PTR(unfrag_ip6hlen);",
          "122:    fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);",
          "",
          "[Added Lines]",
          "118:    int err = ip6_find_1stfragopt(skb, &prevhdr);",
          "119:    if (err < 0)",
          "120:     return ERR_PTR(err);",
          "121:    fptr = (struct frag_hdr *)((u8 *)ipv6h + err);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
          "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "597:  int ptr, offset = 0, err = 0;",
          "598:  u8 *prevhdr, nexthdr = 0;",
          "603:   goto fail;",
          "605:  nexthdr = *prevhdr;",
          "607:  mtu = ip6_skb_dst_mtu(skb);",
          "",
          "[Removed Lines]",
          "600:  hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "601:  if (hlen < 0) {",
          "602:   err = hlen;",
          "604:  }",
          "",
          "[Added Lines]",
          "600:  err = ip6_find_1stfragopt(skb, &prevhdr);",
          "601:  if (err < 0)",
          "603:  hlen = err;",
          "",
          "---------------"
        ],
        "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c": [
          "File: net/ipv6/udp_offload.c -> net/ipv6/udp_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:  u8 frag_hdr_sz = sizeof(struct frag_hdr);",
          "30:  __wsum csum;",
          "31:  int tnl_hlen;",
          "33:  mss = skb_shinfo(skb)->gso_size;",
          "34:  if (unlikely(skb->len <= mss))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32:  int err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96:   nexthdr = *prevhdr;",
          "98:   unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +",
          "",
          "[Removed Lines]",
          "93:   unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "94:   if (unfrag_ip6hlen < 0)",
          "95:    return ERR_PTR(unfrag_ip6hlen);",
          "",
          "[Added Lines]",
          "94:   err = ip6_find_1stfragopt(skb, &prevhdr);",
          "95:   if (err < 0)",
          "96:    return ERR_PTR(err);",
          "97:   unfrag_ip6hlen = err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6399f1fae4ec29fab5ec76070435555e256ca3a6",
      "candidate_info": {
        "commit_hash": "6399f1fae4ec29fab5ec76070435555e256ca3a6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6399f1fae4ec29fab5ec76070435555e256ca3a6",
        "files": [
          "net/ipv6/output_core.c"
        ],
        "message": "ipv6: avoid overflow of offset in ip6_find_1stfragopt\n\nIn some cases, offset can overflow and can cause an infinite loop in\nip6_find_1stfragopt(). Make it unsigned int to prevent the overflow, and\ncap it at IPV6_MAXPLEN, since packets larger than that should be invalid.\n\nThis problem has been here since before the beginning of git history.\n\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/output_core.c||net/ipv6/output_core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/output_core.c||net/ipv6/output_core.c"
          ],
          "candidate": [
            "net/ipv6/output_core.c||net/ipv6/output_core.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/output_core.c||net/ipv6/output_core.c": [
          "File: net/ipv6/output_core.c -> net/ipv6/output_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79: int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)",
          "80: {",
          "82:  unsigned int packet_len = skb_tail_pointer(skb) -",
          "83:   skb_network_header(skb);",
          "84:  int found_rhdr = 0;",
          "",
          "[Removed Lines]",
          "81:  u16 offset = sizeof(struct ipv6hdr);",
          "",
          "[Added Lines]",
          "81:  unsigned int offset = sizeof(struct ipv6hdr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:  while (offset <= packet_len) {",
          "88:   struct ipv6_opt_hdr *exthdr;",
          "90:   switch (**nexthdr) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89:   unsigned int len;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "112:   exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +",
          "113:        offset);",
          "116:  }",
          "",
          "[Removed Lines]",
          "114:   offset += ipv6_optlen(exthdr);",
          "",
          "[Added Lines]",
          "115:   len = ipv6_optlen(exthdr);",
          "116:   if (len + offset >= IPV6_MAXPLEN)",
          "117:    return -EINVAL;",
          "118:   offset += len;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3de33e1ba0506723ab25734e098cf280ecc34756",
      "candidate_info": {
        "commit_hash": "3de33e1ba0506723ab25734e098cf280ecc34756",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3de33e1ba0506723ab25734e098cf280ecc34756",
        "files": [
          "net/ipv6/output_core.c"
        ],
        "message": "ipv6: accept 64k - 1 packet length in ip6_find_1stfragopt()\n\nA packet length of exactly IPV6_MAXPLEN is allowed, we should\nrefuse parsing options only if the size is 64KiB or more.\n\nWhile at it, remove one extra variable and one assignment which\nwere also introduced by the commit that introduced the size\ncheck. Checking the sum 'offset + len' and only later adding\n'len' to 'offset' doesn't provide any advantage over directly\nsumming to 'offset' and checking it.\n\nFixes: 6399f1fae4ec (\"ipv6: avoid overflow of offset in ip6_find_1stfragopt\")\nSigned-off-by: Stefano Brivio <sbrivio@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/output_core.c||net/ipv6/output_core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/output_core.c||net/ipv6/output_core.c"
          ],
          "candidate": [
            "net/ipv6/output_core.c||net/ipv6/output_core.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/output_core.c||net/ipv6/output_core.c": [
          "File: net/ipv6/output_core.c -> net/ipv6/output_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:  while (offset <= packet_len) {",
          "88:   struct ipv6_opt_hdr *exthdr;",
          "91:   switch (**nexthdr) {",
          "",
          "[Removed Lines]",
          "89:   unsigned int len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:   exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +",
          "114:        offset);",
          "117:    return -EINVAL;",
          "120:  }",
          "",
          "[Removed Lines]",
          "115:   len = ipv6_optlen(exthdr);",
          "116:   if (len + offset >= IPV6_MAXPLEN)",
          "118:   offset += len;",
          "",
          "[Added Lines]",
          "114:   offset += ipv6_optlen(exthdr);",
          "115:   if (offset > IPV6_MAXPLEN)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
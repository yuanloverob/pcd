{
  "cve_id": "CVE-2015-8963",
  "cve_desc": "Race condition in kernel/events/core.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect handling of an swevent data structure during a CPU unplug operation.",
  "repo": "torvalds/linux",
  "patch_hash": "12ca6ad2e3a896256f086497a7c7406a547ee373",
  "patch_info": {
    "commit_hash": "12ca6ad2e3a896256f086497a7c7406a547ee373",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
    "files": [
      "kernel/events/core.c"
    ],
    "message": "perf: Fix race in swevent hash\n\nThere's a race on CPU unplug where we free the swevent hash array\nwhile it can still have events on. This will result in a\nuse-after-free which is BAD.\n\nSimply do not free the hash array on unplug. This leaves the thing\naround and no use-after-free takes place.\n\nWhen the last swevent dies, we do a for_each_possible_cpu() iteration\nanyway to clean these up, at which time we'll free it, so no leakage\nwill occur.\n\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nTested-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "before_after_code_files": [
      "kernel/events/core.c||kernel/events/core.c"
    ]
  },
  "patch_diff": {
    "kernel/events/core.c||kernel/events/core.c": [
      "File: kernel/events/core.c -> kernel/events/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6490:  int    recursion[PERF_NR_CONTEXTS];",
      "6494: };",
      "6496: static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);",
      "",
      "[Removed Lines]",
      "6493:  bool    online;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "6748:  hwc->state = !(flags & PERF_EF_START);",
      "6750:  head = find_swevent_head(swhash, event);",
      "6757:   return -EINVAL;",
      "6760:  hlist_add_head_rcu(&event->hlist_entry, head);",
      "6761:  perf_event_update_userpage(event);",
      "",
      "[Removed Lines]",
      "6751:  if (!head) {",
      "6756:   WARN_ON_ONCE(swhash->online);",
      "6758:  }",
      "",
      "[Added Lines]",
      "6748:  if (WARN_ON_ONCE(!head))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "9286:  struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);",
      "9288:  mutex_lock(&swhash->hlist_mutex);",
      "9290:  if (swhash->hlist_refcount > 0) {",
      "9291:   struct swevent_hlist *hlist;",
      "",
      "[Removed Lines]",
      "9289:  swhash->online = true;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "9329: static void perf_event_exit_cpu(int cpu)",
      "9330: {",
      "9333:  perf_event_exit_cpu_context(cpu);",
      "9339: }",
      "9340: #else",
      "9341: static inline void perf_event_exit_cpu(int cpu) { }",
      "",
      "[Removed Lines]",
      "9331:  struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);",
      "9335:  mutex_lock(&swhash->hlist_mutex);",
      "9336:  swhash->online = false;",
      "9337:  swevent_hlist_release(swhash);",
      "9338:  mutex_unlock(&swhash->hlist_mutex);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2965faa5e03d1e71e9ff9aa143fff39e0a77543a",
      "candidate_info": {
        "commit_hash": "2965faa5e03d1e71e9ff9aa143fff39e0a77543a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2965faa5e03d1e71e9ff9aa143fff39e0a77543a",
        "files": [
          "arch/Kconfig",
          "arch/arm/Kconfig",
          "arch/ia64/Kconfig",
          "arch/m68k/Kconfig",
          "arch/mips/Kconfig",
          "arch/powerpc/Kconfig",
          "arch/s390/Kconfig",
          "arch/sh/Kconfig",
          "arch/tile/Kconfig",
          "arch/x86/Kconfig",
          "arch/x86/boot/header.S",
          "arch/x86/include/asm/kdebug.h",
          "arch/x86/kernel/Makefile",
          "arch/x86/kernel/kvmclock.c",
          "arch/x86/kernel/reboot.c",
          "arch/x86/kernel/setup.c",
          "arch/x86/kernel/vmlinux.lds.S",
          "arch/x86/kvm/vmx.c",
          "arch/x86/platform/efi/efi.c",
          "arch/x86/platform/uv/uv_nmi.c",
          "drivers/firmware/efi/Kconfig",
          "drivers/pci/pci-driver.c",
          "include/linux/kexec.h",
          "init/initramfs.c",
          "kernel/Makefile",
          "kernel/events/core.c",
          "kernel/kexec.c",
          "kernel/kexec_core.c",
          "kernel/ksysfs.c",
          "kernel/printk/printk.c",
          "kernel/reboot.c",
          "kernel/sysctl.c"
        ],
        "message": "kexec: split kexec_load syscall from kexec core code\n\nThere are two kexec load syscalls, kexec_load another and kexec_file_load.\n kexec_file_load has been splited as kernel/kexec_file.c.  In this patch I\nsplit kexec_load syscall code to kernel/kexec.c.\n\nAnd add a new kconfig option KEXEC_CORE, so we can disable kexec_load and\nuse kexec_file_load only, or vice verse.\n\nThe original requirement is from Ted Ts'o, he want kexec kernel signature\nbeing checked with CONFIG_KEXEC_VERIFY_SIG enabled.  But kexec-tools use\nkexec_load syscall can bypass the checking.\n\nVivek Goyal proposed to create a common kconfig option so user can compile\nin only one syscall for loading kexec kernel.  KEXEC/KEXEC_FILE selects\nKEXEC_CORE so that old config files still work.\n\nBecause there's general code need CONFIG_KEXEC_CORE, so I updated all the\narchitecture Kconfig with a new option KEXEC_CORE, and let KEXEC selects\nKEXEC_CORE in arch Kconfig.  Also updated general kernel code with to\nkexec_load syscall.\n\n[akpm@linux-foundation.org: coding-style fixes]\nSigned-off-by: Dave Young <dyoung@redhat.com>\nCc: Eric W. Biederman <ebiederm@xmission.com>\nCc: Vivek Goyal <vgoyal@redhat.com>\nCc: Petr Tesarik <ptesarik@suse.cz>\nCc: Theodore Ts'o <tytso@mit.edu>\nCc: Josh Boyer <jwboyer@fedoraproject.org>\nCc: David Howells <dhowells@redhat.com>\nCc: Geert Uytterhoeven <geert@linux-m68k.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "arch/x86/boot/header.S||arch/x86/boot/header.S",
          "arch/x86/include/asm/kdebug.h||arch/x86/include/asm/kdebug.h",
          "arch/x86/kernel/kvmclock.c||arch/x86/kernel/kvmclock.c",
          "arch/x86/kernel/reboot.c||arch/x86/kernel/reboot.c",
          "arch/x86/kernel/setup.c||arch/x86/kernel/setup.c",
          "arch/x86/kernel/vmlinux.lds.S||arch/x86/kernel/vmlinux.lds.S",
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c",
          "arch/x86/platform/efi/efi.c||arch/x86/platform/efi/efi.c",
          "arch/x86/platform/uv/uv_nmi.c||arch/x86/platform/uv/uv_nmi.c",
          "drivers/pci/pci-driver.c||drivers/pci/pci-driver.c",
          "include/linux/kexec.h||include/linux/kexec.h",
          "init/initramfs.c||init/initramfs.c",
          "kernel/events/core.c||kernel/events/core.c",
          "kernel/kexec.c||kernel/kexec.c",
          "kernel/kexec_core.c||kernel/kexec_core.c",
          "kernel/ksysfs.c||kernel/ksysfs.c",
          "kernel/printk/printk.c||kernel/printk/printk.c",
          "kernel/reboot.c||kernel/reboot.c",
          "kernel/sysctl.c||kernel/sysctl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/boot/header.S||arch/x86/boot/header.S": [
          "File: arch/x86/boot/header.S -> arch/x86/boot/header.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "414: # define XLF23 0",
          "415: #endif",
          "418: # define XLF4 XLF_EFI_KEXEC",
          "419: #else",
          "420: # define XLF4 0",
          "",
          "[Removed Lines]",
          "417: #if defined(CONFIG_X86_64) && defined(CONFIG_EFI) && defined(CONFIG_KEXEC)",
          "",
          "[Added Lines]",
          "417: #if defined(CONFIG_X86_64) && defined(CONFIG_EFI) && defined(CONFIG_KEXEC_CORE)",
          "",
          "---------------"
        ],
        "arch/x86/include/asm/kdebug.h||arch/x86/include/asm/kdebug.h": [
          "File: arch/x86/include/asm/kdebug.h -> arch/x86/include/asm/kdebug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: extern void __show_regs(struct pt_regs *regs, int all);",
          "30: extern unsigned long oops_begin(void);",
          "31: extern void oops_end(unsigned long, struct pt_regs *, int signr);",
          "33: extern int in_crash_kexec;",
          "34: #else",
          "",
          "[Removed Lines]",
          "32: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "32: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "arch/x86/kernel/kvmclock.c||arch/x86/kernel/kvmclock.c": [
          "File: arch/x86/kernel/kvmclock.c -> arch/x86/kernel/kvmclock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "204: static void kvm_crash_shutdown(struct pt_regs *regs)",
          "205: {",
          "206:  native_write_msr(msr_kvm_system_time, 0, 0);",
          "",
          "[Removed Lines]",
          "203: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "203: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "259:  x86_platform.save_sched_clock_state = kvm_save_sched_clock_state;",
          "260:  x86_platform.restore_sched_clock_state = kvm_restore_sched_clock_state;",
          "261:  machine_ops.shutdown  = kvm_shutdown;",
          "263:  machine_ops.crash_shutdown  = kvm_crash_shutdown;",
          "264: #endif",
          "265:  kvm_get_preset_lpj();",
          "",
          "[Removed Lines]",
          "262: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "262: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "arch/x86/kernel/reboot.c||arch/x86/kernel/reboot.c": [
          "File: arch/x86/kernel/reboot.c -> arch/x86/kernel/reboot.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "673:  .emergency_restart = native_machine_emergency_restart,",
          "674:  .restart = native_machine_restart,",
          "675:  .halt = native_machine_halt,",
          "677:  .crash_shutdown = native_machine_crash_shutdown,",
          "678: #endif",
          "679: };",
          "",
          "[Removed Lines]",
          "676: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "676: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "703:  machine_ops.halt();",
          "704: }",
          "707: void machine_crash_shutdown(struct pt_regs *regs)",
          "708: {",
          "709:  machine_ops.crash_shutdown(regs);",
          "",
          "[Removed Lines]",
          "706: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "706: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "arch/x86/kernel/setup.c||arch/x86/kernel/setup.c": [
          "File: arch/x86/kernel/setup.c -> arch/x86/kernel/setup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "481: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "481: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "arch/x86/kernel/vmlinux.lds.S||arch/x86/kernel/vmlinux.lds.S": [
          "File: arch/x86/kernel/vmlinux.lds.S -> arch/x86/kernel/vmlinux.lds.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "368: #include <asm/kexec.h>",
          "370: . = ASSERT(kexec_control_code_size <= KEXEC_CONTROL_CODE_MAX_SIZE,",
          "",
          "[Removed Lines]",
          "367: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "367: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1264:          vmcs, phys_addr);",
          "1265: }",
          "",
          "[Removed Lines]",
          "1267: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "1267: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10411:  if (r)",
          "10412:   return r;",
          "10415:  rcu_assign_pointer(crash_vmclear_loaded_vmcss,",
          "10416:       crash_vmclear_local_loaded_vmcss);",
          "10417: #endif",
          "",
          "[Removed Lines]",
          "10414: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "10414: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "10422: static void __exit vmx_exit(void)",
          "10423: {",
          "10425:  RCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);",
          "10426:  synchronize_rcu();",
          "10427: #endif",
          "",
          "[Removed Lines]",
          "10424: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "10424: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "arch/x86/platform/efi/efi.c||arch/x86/platform/efi/efi.c": [
          "File: arch/x86/platform/efi/efi.c -> arch/x86/platform/efi/efi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "651: static void __init save_runtime_map(void)",
          "652: {",
          "654:  efi_memory_desc_t *md;",
          "655:  void *tmp, *p, *q = NULL;",
          "656:  int count = 0;",
          "",
          "[Removed Lines]",
          "653: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "653: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "749: static void __init kexec_enter_virtual_mode(void)",
          "750: {",
          "752:  efi_memory_desc_t *md;",
          "753:  void *p;",
          "",
          "[Removed Lines]",
          "751: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "751: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "arch/x86/platform/uv/uv_nmi.c||arch/x86/platform/uv/uv_nmi.c": [
          "File: arch/x86/platform/uv/uv_nmi.c -> arch/x86/platform/uv/uv_nmi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "492:  touch_nmi_watchdog();",
          "493: }",
          "496: static atomic_t uv_nmi_kexec_failed;",
          "497: static void uv_nmi_kdump(int cpu, int master, struct pt_regs *regs)",
          "498: {",
          "",
          "[Removed Lines]",
          "495: #if defined(CONFIG_KEXEC)",
          "",
          "[Added Lines]",
          "495: #if defined(CONFIG_KEXEC_CORE)",
          "",
          "---------------"
        ],
        "drivers/pci/pci-driver.c||drivers/pci/pci-driver.c": [
          "File: drivers/pci/pci-driver.c -> drivers/pci/pci-driver.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "467:  pci_msi_shutdown(pci_dev);",
          "468:  pci_msix_shutdown(pci_dev);",
          "",
          "[Removed Lines]",
          "470: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "470: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "include/linux/kexec.h||include/linux/kexec.h": [
          "File: include/linux/kexec.h -> include/linux/kexec.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <uapi/linux/kexec.h>",
          "20: #include <linux/list.h>",
          "21: #include <linux/linkage.h>",
          "22: #include <linux/compat.h>",
          "",
          "[Removed Lines]",
          "19: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "19: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "init/initramfs.c||init/initramfs.c": [
          "File: init/initramfs.c -> init/initramfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "527: static void __init free_initrd(void)",
          "528: {",
          "530:  unsigned long crashk_start = (unsigned long)__va(crashk_res.start);",
          "531:  unsigned long crashk_end   = (unsigned long)__va(crashk_res.end);",
          "532: #endif",
          "533:  if (do_retain_initrd)",
          "534:   goto skip;",
          "",
          "[Removed Lines]",
          "529: #ifdef CONFIG_KEXEC",
          "536: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "529: #ifdef CONFIG_KEXEC_CORE",
          "536: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9094:  mutex_unlock(&swhash->hlist_mutex);",
          "9095: }",
          "9098: static void __perf_event_exit_context(void *__info)",
          "9099: {",
          "9100:  struct remove_event re = { .detach_group = true };",
          "",
          "[Removed Lines]",
          "9097: #if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "9097: #if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "kernel/kexec.c||kernel/kexec.c": [
          "File: kernel/kexec.c -> kernel/kexec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include <linux/capability.h>",
          "12: #include <linux/mm.h>",
          "13: #include <linux/file.h>",
          "16: #include <linux/kexec.h>",
          "17: #include <linux/mutex.h>",
          "18: #include <linux/list.h>",
          "20: #include <linux/syscalls.h>",
          "31: #include <linux/vmalloc.h>",
          "47: #include \"kexec_internal.h\"",
          "146: static int copy_user_segment_list(struct kimage *image,",
          "147:       unsigned long nr_segments,",
          "148:       struct kexec_segment __user *segments)",
          "",
          "[Removed Lines]",
          "9: #define pr_fmt(fmt) \"kexec: \" fmt",
          "14: #include <linux/slab.h>",
          "15: #include <linux/fs.h>",
          "19: #include <linux/highmem.h>",
          "21: #include <linux/reboot.h>",
          "22: #include <linux/ioport.h>",
          "23: #include <linux/hardirq.h>",
          "24: #include <linux/elf.h>",
          "25: #include <linux/elfcore.h>",
          "26: #include <linux/utsname.h>",
          "27: #include <linux/numa.h>",
          "28: #include <linux/suspend.h>",
          "29: #include <linux/device.h>",
          "30: #include <linux/freezer.h>",
          "32: #include <linux/pm.h>",
          "33: #include <linux/cpu.h>",
          "34: #include <linux/console.h>",
          "35: #include <linux/swap.h>",
          "36: #include <linux/syscore_ops.h>",
          "37: #include <linux/compiler.h>",
          "38: #include <linux/hugetlb.h>",
          "40: #include <asm/page.h>",
          "41: #include <asm/uaccess.h>",
          "42: #include <asm/io.h>",
          "43: #include <asm/sections.h>",
          "45: #include <crypto/hash.h>",
          "46: #include <crypto/sha.h>",
          "49: DEFINE_MUTEX(kexec_mutex);",
          "52: note_buf_t __percpu *crash_notes;",
          "55: static unsigned char vmcoreinfo_data[VMCOREINFO_BYTES];",
          "56: u32 vmcoreinfo_note[VMCOREINFO_NOTE_SIZE/4];",
          "57: size_t vmcoreinfo_size;",
          "58: size_t vmcoreinfo_max_size = sizeof(vmcoreinfo_data);",
          "61: bool kexec_in_progress = false;",
          "65: struct resource crashk_res = {",
          "66:  .name  = \"Crash kernel\",",
          "67:  .start = 0,",
          "68:  .end   = 0,",
          "69:  .flags = IORESOURCE_BUSY | IORESOURCE_MEM",
          "70: };",
          "71: struct resource crashk_low_res = {",
          "72:  .name  = \"Crash kernel\",",
          "73:  .start = 0,",
          "74:  .end   = 0,",
          "75:  .flags = IORESOURCE_BUSY | IORESOURCE_MEM",
          "76: };",
          "78: int kexec_should_crash(struct task_struct *p)",
          "79: {",
          "85:  if (crash_kexec_post_notifiers)",
          "86:   return 0;",
          "91:  if (in_interrupt() || !p->pid || is_global_init(p) || panic_on_oops)",
          "92:   return 1;",
          "93:  return 0;",
          "94: }",
          "140: #define KIMAGE_NO_DEST (-1UL)",
          "142: static struct page *kimage_alloc_page(struct kimage *image,",
          "143:            gfp_t gfp_mask,",
          "144:            unsigned long dest);",
          "",
          "[Added Lines]",
          "17: #include <linux/slab.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:  return ret;",
          "161: }",
          "280: static int kimage_alloc_init(struct kimage **rimage, unsigned long entry,",
          "281:         unsigned long nr_segments,",
          "282:         struct kexec_segment __user *segments,",
          "",
          "[Removed Lines]",
          "163: int sanity_check_segment_list(struct kimage *image)",
          "164: {",
          "165:  int result, i;",
          "166:  unsigned long nr_segments = image->nr_segments;",
          "181:  result = -EADDRNOTAVAIL;",
          "182:  for (i = 0; i < nr_segments; i++) {",
          "183:   unsigned long mstart, mend;",
          "185:   mstart = image->segment[i].mem;",
          "186:   mend   = mstart + image->segment[i].memsz;",
          "187:   if ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))",
          "188:    return result;",
          "189:   if (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)",
          "190:    return result;",
          "191:  }",
          "198:  result = -EINVAL;",
          "199:  for (i = 0; i < nr_segments; i++) {",
          "200:   unsigned long mstart, mend;",
          "201:   unsigned long j;",
          "203:   mstart = image->segment[i].mem;",
          "204:   mend   = mstart + image->segment[i].memsz;",
          "205:   for (j = 0; j < i; j++) {",
          "206:    unsigned long pstart, pend;",
          "207:    pstart = image->segment[j].mem;",
          "208:    pend   = pstart + image->segment[j].memsz;",
          "210:    if ((mend > pstart) && (mstart < pend))",
          "211:     return result;",
          "212:   }",
          "213:  }",
          "220:  result = -EINVAL;",
          "221:  for (i = 0; i < nr_segments; i++) {",
          "222:   if (image->segment[i].bufsz > image->segment[i].memsz)",
          "223:    return result;",
          "224:  }",
          "236:  if (image->type == KEXEC_TYPE_CRASH) {",
          "237:   result = -EADDRNOTAVAIL;",
          "238:   for (i = 0; i < nr_segments; i++) {",
          "239:    unsigned long mstart, mend;",
          "241:    mstart = image->segment[i].mem;",
          "242:    mend = mstart + image->segment[i].memsz - 1;",
          "244:    if ((mstart < crashk_res.start) ||",
          "245:        (mend > crashk_res.end))",
          "246:     return result;",
          "247:   }",
          "248:  }",
          "250:  return 0;",
          "251: }",
          "253: struct kimage *do_kimage_alloc_init(void)",
          "254: {",
          "255:  struct kimage *image;",
          "258:  image = kzalloc(sizeof(*image), GFP_KERNEL);",
          "259:  if (!image)",
          "260:   return NULL;",
          "262:  image->head = 0;",
          "263:  image->entry = &image->head;",
          "264:  image->last_entry = &image->head;",
          "266:  image->type = KEXEC_TYPE_DEFAULT;",
          "269:  INIT_LIST_HEAD(&image->control_pages);",
          "272:  INIT_LIST_HEAD(&image->dest_pages);",
          "275:  INIT_LIST_HEAD(&image->unusable_pages);",
          "277:  return image;",
          "278: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "343:  return ret;",
          "344: }",
          "",
          "[Removed Lines]",
          "346: int kimage_is_destination_range(struct kimage *image,",
          "347:      unsigned long start,",
          "348:      unsigned long end)",
          "349: {",
          "350:  unsigned long i;",
          "352:  for (i = 0; i < image->nr_segments; i++) {",
          "353:   unsigned long mstart, mend;",
          "355:   mstart = image->segment[i].mem;",
          "356:   mend = mstart + image->segment[i].memsz;",
          "357:   if ((end > mstart) && (start < mend))",
          "358:    return 1;",
          "359:  }",
          "361:  return 0;",
          "362: }",
          "364: static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)",
          "365: {",
          "366:  struct page *pages;",
          "368:  pages = alloc_pages(gfp_mask, order);",
          "369:  if (pages) {",
          "370:   unsigned int count, i;",
          "371:   pages->mapping = NULL;",
          "372:   set_page_private(pages, order);",
          "373:   count = 1 << order;",
          "374:   for (i = 0; i < count; i++)",
          "375:    SetPageReserved(pages + i);",
          "376:  }",
          "378:  return pages;",
          "379: }",
          "381: static void kimage_free_pages(struct page *page)",
          "382: {",
          "383:  unsigned int order, count, i;",
          "385:  order = page_private(page);",
          "386:  count = 1 << order;",
          "387:  for (i = 0; i < count; i++)",
          "388:   ClearPageReserved(page + i);",
          "389:  __free_pages(page, order);",
          "390: }",
          "392: void kimage_free_page_list(struct list_head *list)",
          "393: {",
          "394:  struct list_head *pos, *next;",
          "396:  list_for_each_safe(pos, next, list) {",
          "397:   struct page *page;",
          "399:   page = list_entry(pos, struct page, lru);",
          "400:   list_del(&page->lru);",
          "401:   kimage_free_pages(page);",
          "402:  }",
          "403: }",
          "405: static struct page *kimage_alloc_normal_control_pages(struct kimage *image,",
          "406:        unsigned int order)",
          "407: {",
          "421:  struct list_head extra_pages;",
          "422:  struct page *pages;",
          "423:  unsigned int count;",
          "425:  count = 1 << order;",
          "426:  INIT_LIST_HEAD(&extra_pages);",
          "431:  do {",
          "432:   unsigned long pfn, epfn, addr, eaddr;",
          "434:   pages = kimage_alloc_pages(KEXEC_CONTROL_MEMORY_GFP, order);",
          "435:   if (!pages)",
          "436:    break;",
          "437:   pfn   = page_to_pfn(pages);",
          "438:   epfn  = pfn + count;",
          "439:   addr  = pfn << PAGE_SHIFT;",
          "440:   eaddr = epfn << PAGE_SHIFT;",
          "441:   if ((epfn >= (KEXEC_CONTROL_MEMORY_LIMIT >> PAGE_SHIFT)) ||",
          "442:          kimage_is_destination_range(image, addr, eaddr)) {",
          "443:    list_add(&pages->lru, &extra_pages);",
          "444:    pages = NULL;",
          "445:   }",
          "446:  } while (!pages);",
          "448:  if (pages) {",
          "450:   list_add(&pages->lru, &image->control_pages);",
          "458:  }",
          "466:  kimage_free_page_list(&extra_pages);",
          "468:  return pages;",
          "469: }",
          "471: static struct page *kimage_alloc_crash_control_pages(struct kimage *image,",
          "472:             unsigned int order)",
          "473: {",
          "495:  unsigned long hole_start, hole_end, size;",
          "496:  struct page *pages;",
          "498:  pages = NULL;",
          "499:  size = (1 << order) << PAGE_SHIFT;",
          "500:  hole_start = (image->control_page + (size - 1)) & ~(size - 1);",
          "501:  hole_end   = hole_start + size - 1;",
          "502:  while (hole_end <= crashk_res.end) {",
          "503:   unsigned long i;",
          "505:   if (hole_end > KEXEC_CRASH_CONTROL_MEMORY_LIMIT)",
          "506:    break;",
          "508:   for (i = 0; i < image->nr_segments; i++) {",
          "509:    unsigned long mstart, mend;",
          "511:    mstart = image->segment[i].mem;",
          "512:    mend   = mstart + image->segment[i].memsz - 1;",
          "513:    if ((hole_end >= mstart) && (hole_start <= mend)) {",
          "515:     hole_start = (mend + (size - 1)) & ~(size - 1);",
          "516:     hole_end   = hole_start + size - 1;",
          "517:     break;",
          "518:    }",
          "519:   }",
          "521:   if (i == image->nr_segments) {",
          "522:    pages = pfn_to_page(hole_start >> PAGE_SHIFT);",
          "523:    break;",
          "524:   }",
          "525:  }",
          "526:  if (pages)",
          "527:   image->control_page = hole_end;",
          "529:  return pages;",
          "530: }",
          "533: struct page *kimage_alloc_control_pages(struct kimage *image,",
          "534:       unsigned int order)",
          "535: {",
          "536:  struct page *pages = NULL;",
          "538:  switch (image->type) {",
          "539:  case KEXEC_TYPE_DEFAULT:",
          "540:   pages = kimage_alloc_normal_control_pages(image, order);",
          "541:   break;",
          "542:  case KEXEC_TYPE_CRASH:",
          "543:   pages = kimage_alloc_crash_control_pages(image, order);",
          "544:   break;",
          "545:  }",
          "547:  return pages;",
          "548: }",
          "550: static int kimage_add_entry(struct kimage *image, kimage_entry_t entry)",
          "551: {",
          "552:  if (*image->entry != 0)",
          "553:   image->entry++;",
          "555:  if (image->entry == image->last_entry) {",
          "556:   kimage_entry_t *ind_page;",
          "557:   struct page *page;",
          "559:   page = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);",
          "560:   if (!page)",
          "561:    return -ENOMEM;",
          "563:   ind_page = page_address(page);",
          "565:   image->entry = ind_page;",
          "566:   image->last_entry = ind_page +",
          "567:           ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);",
          "568:  }",
          "570:  image->entry++;",
          "573:  return 0;",
          "574: }",
          "576: static int kimage_set_destination(struct kimage *image,",
          "577:        unsigned long destination)",
          "578: {",
          "579:  int result;",
          "581:  destination &= PAGE_MASK;",
          "582:  result = kimage_add_entry(image, destination | IND_DESTINATION);",
          "584:  return result;",
          "585: }",
          "588: static int kimage_add_page(struct kimage *image, unsigned long page)",
          "589: {",
          "590:  int result;",
          "592:  page &= PAGE_MASK;",
          "593:  result = kimage_add_entry(image, page | IND_SOURCE);",
          "595:  return result;",
          "596: }",
          "599: static void kimage_free_extra_pages(struct kimage *image)",
          "600: {",
          "602:  kimage_free_page_list(&image->dest_pages);",
          "605:  kimage_free_page_list(&image->unusable_pages);",
          "607: }",
          "608: void kimage_terminate(struct kimage *image)",
          "609: {",
          "610:  if (*image->entry != 0)",
          "611:   image->entry++;",
          "614: }",
          "616: #define for_each_kimage_entry(image, ptr, entry) \\",
          "617:  for (ptr = &image->head; (entry = *ptr) && !(entry & IND_DONE); \\",
          "618:   ptr = (entry & IND_INDIRECTION) ? \\",
          "619:    phys_to_virt((entry & PAGE_MASK)) : ptr + 1)",
          "621: static void kimage_free_entry(kimage_entry_t entry)",
          "622: {",
          "623:  struct page *page;",
          "625:  page = pfn_to_page(entry >> PAGE_SHIFT);",
          "626:  kimage_free_pages(page);",
          "627: }",
          "629: void kimage_free(struct kimage *image)",
          "630: {",
          "631:  kimage_entry_t *ptr, entry;",
          "632:  kimage_entry_t ind = 0;",
          "634:  if (!image)",
          "635:   return;",
          "637:  kimage_free_extra_pages(image);",
          "638:  for_each_kimage_entry(image, ptr, entry) {",
          "639:   if (entry & IND_INDIRECTION) {",
          "641:    if (ind & IND_INDIRECTION)",
          "642:     kimage_free_entry(ind);",
          "646:    ind = entry;",
          "647:   } else if (entry & IND_SOURCE)",
          "648:    kimage_free_entry(entry);",
          "649:  }",
          "651:  if (ind & IND_INDIRECTION)",
          "652:   kimage_free_entry(ind);",
          "655:  machine_kexec_cleanup(image);",
          "658:  kimage_free_page_list(&image->control_pages);",
          "664:  if (image->file_mode)",
          "665:   kimage_file_post_load_cleanup(image);",
          "667:  kfree(image);",
          "668: }",
          "670: static kimage_entry_t *kimage_dst_used(struct kimage *image,",
          "671:      unsigned long page)",
          "672: {",
          "673:  kimage_entry_t *ptr, entry;",
          "674:  unsigned long destination = 0;",
          "676:  for_each_kimage_entry(image, ptr, entry) {",
          "677:   if (entry & IND_DESTINATION)",
          "678:    destination = entry & PAGE_MASK;",
          "679:   else if (entry & IND_SOURCE) {",
          "680:    if (page == destination)",
          "681:     return ptr;",
          "682:    destination += PAGE_SIZE;",
          "683:   }",
          "684:  }",
          "686:  return NULL;",
          "687: }",
          "689: static struct page *kimage_alloc_page(struct kimage *image,",
          "690:      gfp_t gfp_mask,",
          "691:      unsigned long destination)",
          "692: {",
          "711:  struct page *page;",
          "712:  unsigned long addr;",
          "718:  list_for_each_entry(page, &image->dest_pages, lru) {",
          "719:   addr = page_to_pfn(page) << PAGE_SHIFT;",
          "720:   if (addr == destination) {",
          "721:    list_del(&page->lru);",
          "722:    return page;",
          "723:   }",
          "724:  }",
          "725:  page = NULL;",
          "726:  while (1) {",
          "727:   kimage_entry_t *old;",
          "730:   page = kimage_alloc_pages(gfp_mask, 0);",
          "731:   if (!page)",
          "732:    return NULL;",
          "734:   if (page_to_pfn(page) >",
          "735:     (KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {",
          "736:    list_add(&page->lru, &image->unusable_pages);",
          "737:    continue;",
          "738:   }",
          "739:   addr = page_to_pfn(page) << PAGE_SHIFT;",
          "742:   if (addr == destination)",
          "743:    break;",
          "746:   if (!kimage_is_destination_range(image, addr,",
          "747:         addr + PAGE_SIZE))",
          "748:    break;",
          "755:   old = kimage_dst_used(image, addr);",
          "756:   if (old) {",
          "758:    unsigned long old_addr;",
          "759:    struct page *old_page;",
          "761:    old_addr = *old & PAGE_MASK;",
          "762:    old_page = pfn_to_page(old_addr >> PAGE_SHIFT);",
          "763:    copy_highpage(page, old_page);",
          "770:    if (!(gfp_mask & __GFP_HIGHMEM) &&",
          "771:        PageHighMem(old_page)) {",
          "772:     kimage_free_pages(old_page);",
          "773:     continue;",
          "774:    }",
          "775:    addr = old_addr;",
          "776:    page = old_page;",
          "777:    break;",
          "778:   } else {",
          "782:    list_add(&page->lru, &image->dest_pages);",
          "783:   }",
          "784:  }",
          "786:  return page;",
          "787: }",
          "789: static int kimage_load_normal_segment(struct kimage *image,",
          "790:       struct kexec_segment *segment)",
          "791: {",
          "792:  unsigned long maddr;",
          "793:  size_t ubytes, mbytes;",
          "794:  int result;",
          "795:  unsigned char __user *buf = NULL;",
          "796:  unsigned char *kbuf = NULL;",
          "798:  result = 0;",
          "799:  if (image->file_mode)",
          "800:   kbuf = segment->kbuf;",
          "801:  else",
          "802:   buf = segment->buf;",
          "803:  ubytes = segment->bufsz;",
          "804:  mbytes = segment->memsz;",
          "805:  maddr = segment->mem;",
          "807:  result = kimage_set_destination(image, maddr);",
          "808:  if (result < 0)",
          "809:   goto out;",
          "811:  while (mbytes) {",
          "812:   struct page *page;",
          "813:   char *ptr;",
          "814:   size_t uchunk, mchunk;",
          "816:   page = kimage_alloc_page(image, GFP_HIGHUSER, maddr);",
          "817:   if (!page) {",
          "818:    result  = -ENOMEM;",
          "819:    goto out;",
          "820:   }",
          "821:   result = kimage_add_page(image, page_to_pfn(page)",
          "822:         << PAGE_SHIFT);",
          "823:   if (result < 0)",
          "824:    goto out;",
          "826:   ptr = kmap(page);",
          "828:   clear_page(ptr);",
          "829:   ptr += maddr & ~PAGE_MASK;",
          "830:   mchunk = min_t(size_t, mbytes,",
          "831:     PAGE_SIZE - (maddr & ~PAGE_MASK));",
          "832:   uchunk = min(ubytes, mchunk);",
          "835:   if (image->file_mode)",
          "836:    memcpy(ptr, kbuf, uchunk);",
          "837:   else",
          "838:    result = copy_from_user(ptr, buf, uchunk);",
          "839:   kunmap(page);",
          "840:   if (result) {",
          "841:    result = -EFAULT;",
          "842:    goto out;",
          "843:   }",
          "844:   ubytes -= uchunk;",
          "845:   maddr  += mchunk;",
          "846:   if (image->file_mode)",
          "847:    kbuf += mchunk;",
          "848:   else",
          "849:    buf += mchunk;",
          "850:   mbytes -= mchunk;",
          "851:  }",
          "852: out:",
          "853:  return result;",
          "854: }",
          "856: static int kimage_load_crash_segment(struct kimage *image,",
          "857:      struct kexec_segment *segment)",
          "858: {",
          "863:  unsigned long maddr;",
          "864:  size_t ubytes, mbytes;",
          "865:  int result;",
          "866:  unsigned char __user *buf = NULL;",
          "867:  unsigned char *kbuf = NULL;",
          "869:  result = 0;",
          "870:  if (image->file_mode)",
          "871:   kbuf = segment->kbuf;",
          "872:  else",
          "873:   buf = segment->buf;",
          "874:  ubytes = segment->bufsz;",
          "875:  mbytes = segment->memsz;",
          "876:  maddr = segment->mem;",
          "877:  while (mbytes) {",
          "878:   struct page *page;",
          "879:   char *ptr;",
          "880:   size_t uchunk, mchunk;",
          "882:   page = pfn_to_page(maddr >> PAGE_SHIFT);",
          "883:   if (!page) {",
          "884:    result  = -ENOMEM;",
          "885:    goto out;",
          "886:   }",
          "887:   ptr = kmap(page);",
          "888:   ptr += maddr & ~PAGE_MASK;",
          "889:   mchunk = min_t(size_t, mbytes,",
          "890:     PAGE_SIZE - (maddr & ~PAGE_MASK));",
          "891:   uchunk = min(ubytes, mchunk);",
          "892:   if (mchunk > uchunk) {",
          "894:    memset(ptr + uchunk, 0, mchunk - uchunk);",
          "895:   }",
          "898:   if (image->file_mode)",
          "899:    memcpy(ptr, kbuf, uchunk);",
          "900:   else",
          "901:    result = copy_from_user(ptr, buf, uchunk);",
          "902:   kexec_flush_icache_page(page);",
          "903:   kunmap(page);",
          "904:   if (result) {",
          "905:    result = -EFAULT;",
          "906:    goto out;",
          "907:   }",
          "908:   ubytes -= uchunk;",
          "909:   maddr  += mchunk;",
          "910:   if (image->file_mode)",
          "911:    kbuf += mchunk;",
          "912:   else",
          "913:    buf += mchunk;",
          "914:   mbytes -= mchunk;",
          "915:  }",
          "916: out:",
          "917:  return result;",
          "918: }",
          "920: int kimage_load_segment(struct kimage *image,",
          "921:     struct kexec_segment *segment)",
          "922: {",
          "923:  int result = -ENOMEM;",
          "925:  switch (image->type) {",
          "926:  case KEXEC_TYPE_DEFAULT:",
          "927:   result = kimage_load_normal_segment(image, segment);",
          "928:   break;",
          "929:  case KEXEC_TYPE_CRASH:",
          "930:   result = kimage_load_crash_segment(image, segment);",
          "931:   break;",
          "932:  }",
          "934:  return result;",
          "935: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "961: SYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,",
          "962:   struct kexec_segment __user *, segments, unsigned long, flags)",
          "",
          "[Removed Lines]",
          "957: struct kimage *kexec_image;",
          "958: struct kimage *kexec_crash_image;",
          "959: int kexec_load_disabled;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1051:  return result;",
          "1052: }",
          "1066: #ifdef CONFIG_COMPAT",
          "1067: COMPAT_SYSCALL_DEFINE4(kexec_load, compat_ulong_t, entry,",
          "1068:          compat_ulong_t, nr_segments,",
          "",
          "[Removed Lines]",
          "1060: void __weak crash_map_reserved_pages(void)",
          "1061: {}",
          "1063: void __weak crash_unmap_reserved_pages(void)",
          "1064: {}",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1101:  return sys_kexec_load(entry, nr_segments, ksegments, flags);",
          "1102: }",
          "1103: #endif",
          "",
          "[Removed Lines]",
          "1105: void crash_kexec(struct pt_regs *regs)",
          "1106: {",
          "1115:  if (mutex_trylock(&kexec_mutex)) {",
          "1116:   if (kexec_crash_image) {",
          "1117:    struct pt_regs fixed_regs;",
          "1119:    crash_setup_regs(&fixed_regs, regs);",
          "1120:    crash_save_vmcoreinfo();",
          "1121:    machine_crash_shutdown(&fixed_regs);",
          "1122:    machine_kexec(kexec_crash_image);",
          "1123:   }",
          "1124:   mutex_unlock(&kexec_mutex);",
          "1125:  }",
          "1126: }",
          "1128: size_t crash_get_memory_size(void)",
          "1129: {",
          "1130:  size_t size = 0;",
          "1131:  mutex_lock(&kexec_mutex);",
          "1132:  if (crashk_res.end != crashk_res.start)",
          "1133:   size = resource_size(&crashk_res);",
          "1134:  mutex_unlock(&kexec_mutex);",
          "1135:  return size;",
          "1136: }",
          "1138: void __weak crash_free_reserved_phys_range(unsigned long begin,",
          "1139:         unsigned long end)",
          "1140: {",
          "1141:  unsigned long addr;",
          "1143:  for (addr = begin; addr < end; addr += PAGE_SIZE)",
          "1144:   free_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));",
          "1145: }",
          "1147: int crash_shrink_memory(unsigned long new_size)",
          "1148: {",
          "1149:  int ret = 0;",
          "1150:  unsigned long start, end;",
          "1151:  unsigned long old_size;",
          "1152:  struct resource *ram_res;",
          "1154:  mutex_lock(&kexec_mutex);",
          "1156:  if (kexec_crash_image) {",
          "1157:   ret = -ENOENT;",
          "1158:   goto unlock;",
          "1159:  }",
          "1160:  start = crashk_res.start;",
          "1161:  end = crashk_res.end;",
          "1162:  old_size = (end == 0) ? 0 : end - start + 1;",
          "1163:  if (new_size >= old_size) {",
          "1164:   ret = (new_size == old_size) ? 0 : -EINVAL;",
          "1165:   goto unlock;",
          "1166:  }",
          "1168:  ram_res = kzalloc(sizeof(*ram_res), GFP_KERNEL);",
          "1169:  if (!ram_res) {",
          "1170:   ret = -ENOMEM;",
          "1171:   goto unlock;",
          "1172:  }",
          "1174:  start = roundup(start, KEXEC_CRASH_MEM_ALIGN);",
          "1175:  end = roundup(start + new_size, KEXEC_CRASH_MEM_ALIGN);",
          "1177:  crash_map_reserved_pages();",
          "1178:  crash_free_reserved_phys_range(end, crashk_res.end);",
          "1180:  if ((start == end) && (crashk_res.parent != NULL))",
          "1181:   release_resource(&crashk_res);",
          "1183:  ram_res->start = end;",
          "1184:  ram_res->end = crashk_res.end;",
          "1185:  ram_res->flags = IORESOURCE_BUSY | IORESOURCE_MEM;",
          "1186:  ram_res->name = \"System RAM\";",
          "1188:  crashk_res.end = end - 1;",
          "1190:  insert_resource(&iomem_resource, ram_res);",
          "1191:  crash_unmap_reserved_pages();",
          "1193: unlock:",
          "1194:  mutex_unlock(&kexec_mutex);",
          "1195:  return ret;",
          "1196: }",
          "1198: static u32 *append_elf_note(u32 *buf, char *name, unsigned type, void *data,",
          "1199:        size_t data_len)",
          "1200: {",
          "1201:  struct elf_note note;",
          "1203:  note.n_namesz = strlen(name) + 1;",
          "1204:  note.n_descsz = data_len;",
          "1205:  note.n_type   = type;",
          "1206:  memcpy(buf, &note, sizeof(note));",
          "1207:  buf += (sizeof(note) + 3)/4;",
          "1208:  memcpy(buf, name, note.n_namesz);",
          "1209:  buf += (note.n_namesz + 3)/4;",
          "1210:  memcpy(buf, data, note.n_descsz);",
          "1211:  buf += (note.n_descsz + 3)/4;",
          "1213:  return buf;",
          "1214: }",
          "1216: static void final_note(u32 *buf)",
          "1217: {",
          "1218:  struct elf_note note;",
          "1220:  note.n_namesz = 0;",
          "1221:  note.n_descsz = 0;",
          "1222:  note.n_type   = 0;",
          "1223:  memcpy(buf, &note, sizeof(note));",
          "1224: }",
          "1226: void crash_save_cpu(struct pt_regs *regs, int cpu)",
          "1227: {",
          "1228:  struct elf_prstatus prstatus;",
          "1229:  u32 *buf;",
          "1231:  if ((cpu < 0) || (cpu >= nr_cpu_ids))",
          "1232:   return;",
          "1241:  buf = (u32 *)per_cpu_ptr(crash_notes, cpu);",
          "1242:  if (!buf)",
          "1243:   return;",
          "1244:  memset(&prstatus, 0, sizeof(prstatus));",
          "1245:  prstatus.pr_pid = current->pid;",
          "1246:  elf_core_copy_kernel_regs(&prstatus.pr_reg, regs);",
          "1247:  buf = append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,",
          "1248:          &prstatus, sizeof(prstatus));",
          "1249:  final_note(buf);",
          "1250: }",
          "1252: static int __init crash_notes_memory_init(void)",
          "1253: {",
          "1255:  crash_notes = alloc_percpu(note_buf_t);",
          "1256:  if (!crash_notes) {",
          "1257:   pr_warn(\"Kexec: Memory allocation for saving cpu register states failed\\n\");",
          "1258:   return -ENOMEM;",
          "1259:  }",
          "1260:  return 0;",
          "1261: }",
          "1262: subsys_initcall(crash_notes_memory_init);",
          "1279: static int __init parse_crashkernel_mem(char *cmdline,",
          "1280:      unsigned long long system_ram,",
          "1281:      unsigned long long *crash_size,",
          "1282:      unsigned long long *crash_base)",
          "1283: {",
          "1284:  char *cur = cmdline, *tmp;",
          "1287:  do {",
          "1288:   unsigned long long start, end = ULLONG_MAX, size;",
          "1291:   start = memparse(cur, &tmp);",
          "1292:   if (cur == tmp) {",
          "1293:    pr_warn(\"crashkernel: Memory value expected\\n\");",
          "1294:    return -EINVAL;",
          "1295:   }",
          "1296:   cur = tmp;",
          "1297:   if (*cur != '-') {",
          "1298:    pr_warn(\"crashkernel: '-' expected\\n\");",
          "1299:    return -EINVAL;",
          "1300:   }",
          "1301:   cur++;",
          "1304:   if (*cur != ':') {",
          "1305:    end = memparse(cur, &tmp);",
          "1306:    if (cur == tmp) {",
          "1307:     pr_warn(\"crashkernel: Memory value expected\\n\");",
          "1308:     return -EINVAL;",
          "1309:    }",
          "1310:    cur = tmp;",
          "1311:    if (end <= start) {",
          "1312:     pr_warn(\"crashkernel: end <= start\\n\");",
          "1313:     return -EINVAL;",
          "1314:    }",
          "1315:   }",
          "1317:   if (*cur != ':') {",
          "1318:    pr_warn(\"crashkernel: ':' expected\\n\");",
          "1319:    return -EINVAL;",
          "1320:   }",
          "1321:   cur++;",
          "1323:   size = memparse(cur, &tmp);",
          "1324:   if (cur == tmp) {",
          "1325:    pr_warn(\"Memory value expected\\n\");",
          "1326:    return -EINVAL;",
          "1327:   }",
          "1328:   cur = tmp;",
          "1329:   if (size >= system_ram) {",
          "1330:    pr_warn(\"crashkernel: invalid size\\n\");",
          "1331:    return -EINVAL;",
          "1332:   }",
          "1335:   if (system_ram >= start && system_ram < end) {",
          "1337:    break;",
          "1338:   }",
          "1339:  } while (*cur++ == ',');",
          "1341:  if (*crash_size > 0) {",
          "1342:   while (*cur && *cur != ' ' && *cur != '@')",
          "1343:    cur++;",
          "1344:   if (*cur == '@') {",
          "1345:    cur++;",
          "1347:    if (cur == tmp) {",
          "1348:     pr_warn(\"Memory value expected after '@'\\n\");",
          "1349:     return -EINVAL;",
          "1350:    }",
          "1351:   }",
          "1352:  }",
          "1354:  return 0;",
          "1355: }",
          "1364: static int __init parse_crashkernel_simple(char *cmdline,",
          "1365:         unsigned long long *crash_size,",
          "1366:         unsigned long long *crash_base)",
          "1367: {",
          "1368:  char *cur = cmdline;",
          "1371:  if (cmdline == cur) {",
          "1372:   pr_warn(\"crashkernel: memory value expected\\n\");",
          "1373:   return -EINVAL;",
          "1374:  }",
          "1376:  if (*cur == '@')",
          "1378:  else if (*cur != ' ' && *cur != '\\0') {",
          "1379:   pr_warn(\"crashkernel: unrecognized char\\n\");",
          "1380:   return -EINVAL;",
          "1381:  }",
          "1383:  return 0;",
          "1384: }",
          "1386: #define SUFFIX_HIGH 0",
          "1387: #define SUFFIX_LOW  1",
          "1388: #define SUFFIX_NULL 2",
          "1389: static __initdata char *suffix_tbl[] = {",
          "1390:  [SUFFIX_HIGH] = \",high\",",
          "1391:  [SUFFIX_LOW]  = \",low\",",
          "1392:  [SUFFIX_NULL] = NULL,",
          "1393: };",
          "1402: static int __init parse_crashkernel_suffix(char *cmdline,",
          "1403:         unsigned long long *crash_size,",
          "1404:         const char *suffix)",
          "1405: {",
          "1406:  char *cur = cmdline;",
          "1409:  if (cmdline == cur) {",
          "1410:   pr_warn(\"crashkernel: memory value expected\\n\");",
          "1411:   return -EINVAL;",
          "1412:  }",
          "1415:  if (strncmp(cur, suffix, strlen(suffix))) {",
          "1416:   pr_warn(\"crashkernel: unrecognized char\\n\");",
          "1417:   return -EINVAL;",
          "1418:  }",
          "1419:  cur += strlen(suffix);",
          "1420:  if (*cur != ' ' && *cur != '\\0') {",
          "1421:   pr_warn(\"crashkernel: unrecognized char\\n\");",
          "1422:   return -EINVAL;",
          "1423:  }",
          "1425:  return 0;",
          "1426: }",
          "1428: static __init char *get_last_crashkernel(char *cmdline,",
          "1429:         const char *name,",
          "1430:         const char *suffix)",
          "1431: {",
          "1432:  char *p = cmdline, *ck_cmdline = NULL;",
          "1435:  p = strstr(p, name);",
          "1436:  while (p) {",
          "1437:   char *end_p = strchr(p, ' ');",
          "1438:   char *q;",
          "1440:   if (!end_p)",
          "1441:    end_p = p + strlen(p);",
          "1443:   if (!suffix) {",
          "1444:    int i;",
          "1447:    for (i = 0; suffix_tbl[i]; i++) {",
          "1448:     q = end_p - strlen(suffix_tbl[i]);",
          "1449:     if (!strncmp(q, suffix_tbl[i],",
          "1450:           strlen(suffix_tbl[i])))",
          "1451:      goto next;",
          "1452:    }",
          "1453:    ck_cmdline = p;",
          "1454:   } else {",
          "1455:    q = end_p - strlen(suffix);",
          "1456:    if (!strncmp(q, suffix, strlen(suffix)))",
          "1457:     ck_cmdline = p;",
          "1458:   }",
          "1459: next:",
          "1460:   p = strstr(p+1, name);",
          "1461:  }",
          "1463:  if (!ck_cmdline)",
          "1464:   return NULL;",
          "1466:  return ck_cmdline;",
          "1467: }",
          "1469: static int __init __parse_crashkernel(char *cmdline,",
          "1470:         unsigned long long system_ram,",
          "1471:         unsigned long long *crash_size,",
          "1472:         unsigned long long *crash_base,",
          "1473:         const char *name,",
          "1474:         const char *suffix)",
          "1475: {",
          "1476:  char *first_colon, *first_space;",
          "1477:  char *ck_cmdline;",
          "1479:  BUG_ON(!crash_size || !crash_base);",
          "1483:  ck_cmdline = get_last_crashkernel(cmdline, name, suffix);",
          "1485:  if (!ck_cmdline)",
          "1486:   return -EINVAL;",
          "1488:  ck_cmdline += strlen(name);",
          "1490:  if (suffix)",
          "1491:   return parse_crashkernel_suffix(ck_cmdline, crash_size,",
          "1492:     suffix);",
          "1497:  first_colon = strchr(ck_cmdline, ':');",
          "1498:  first_space = strchr(ck_cmdline, ' ');",
          "1499:  if (first_colon && (!first_space || first_colon < first_space))",
          "1500:   return parse_crashkernel_mem(ck_cmdline, system_ram,",
          "1501:     crash_size, crash_base);",
          "1503:  return parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);",
          "1504: }",
          "1510: int __init parse_crashkernel(char *cmdline,",
          "1511:         unsigned long long system_ram,",
          "1512:         unsigned long long *crash_size,",
          "1513:         unsigned long long *crash_base)",
          "1514: {",
          "1515:  return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,",
          "1516:      \"crashkernel=\", NULL);",
          "1517: }",
          "1519: int __init parse_crashkernel_high(char *cmdline,",
          "1520:         unsigned long long system_ram,",
          "1521:         unsigned long long *crash_size,",
          "1522:         unsigned long long *crash_base)",
          "1523: {",
          "1524:  return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,",
          "1525:     \"crashkernel=\", suffix_tbl[SUFFIX_HIGH]);",
          "1526: }",
          "1528: int __init parse_crashkernel_low(char *cmdline,",
          "1529:         unsigned long long system_ram,",
          "1530:         unsigned long long *crash_size,",
          "1531:         unsigned long long *crash_base)",
          "1532: {",
          "1533:  return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,",
          "1534:     \"crashkernel=\", suffix_tbl[SUFFIX_LOW]);",
          "1535: }",
          "1537: static void update_vmcoreinfo_note(void)",
          "1538: {",
          "1539:  u32 *buf = vmcoreinfo_note;",
          "1541:  if (!vmcoreinfo_size)",
          "1542:   return;",
          "1543:  buf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,",
          "1544:          vmcoreinfo_size);",
          "1545:  final_note(buf);",
          "1546: }",
          "1548: void crash_save_vmcoreinfo(void)",
          "1549: {",
          "1550:  vmcoreinfo_append_str(\"CRASHTIME=%ld\\n\", get_seconds());",
          "1551:  update_vmcoreinfo_note();",
          "1552: }",
          "1554: void vmcoreinfo_append_str(const char *fmt, ...)",
          "1555: {",
          "1556:  va_list args;",
          "1557:  char buf[0x50];",
          "1558:  size_t r;",
          "1560:  va_start(args, fmt);",
          "1561:  r = vscnprintf(buf, sizeof(buf), fmt, args);",
          "1562:  va_end(args);",
          "1564:  r = min(r, vmcoreinfo_max_size - vmcoreinfo_size);",
          "1566:  memcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);",
          "1568:  vmcoreinfo_size += r;",
          "1569: }",
          "1575: void __weak arch_crash_save_vmcoreinfo(void)",
          "1576: {}",
          "1578: unsigned long __weak paddr_vmcoreinfo_note(void)",
          "1579: {",
          "1580:  return __pa((unsigned long)(char *)&vmcoreinfo_note);",
          "1581: }",
          "1583: static int __init crash_save_vmcoreinfo_init(void)",
          "1584: {",
          "1585:  VMCOREINFO_OSRELEASE(init_uts_ns.name.release);",
          "1586:  VMCOREINFO_PAGESIZE(PAGE_SIZE);",
          "1588:  VMCOREINFO_SYMBOL(init_uts_ns);",
          "1589:  VMCOREINFO_SYMBOL(node_online_map);",
          "1590: #ifdef CONFIG_MMU",
          "1591:  VMCOREINFO_SYMBOL(swapper_pg_dir);",
          "1592: #endif",
          "1593:  VMCOREINFO_SYMBOL(_stext);",
          "1594:  VMCOREINFO_SYMBOL(vmap_area_list);",
          "1596: #ifndef CONFIG_NEED_MULTIPLE_NODES",
          "1597:  VMCOREINFO_SYMBOL(mem_map);",
          "1598:  VMCOREINFO_SYMBOL(contig_page_data);",
          "1599: #endif",
          "1600: #ifdef CONFIG_SPARSEMEM",
          "1601:  VMCOREINFO_SYMBOL(mem_section);",
          "1602:  VMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);",
          "1603:  VMCOREINFO_STRUCT_SIZE(mem_section);",
          "1604:  VMCOREINFO_OFFSET(mem_section, section_mem_map);",
          "1605: #endif",
          "1606:  VMCOREINFO_STRUCT_SIZE(page);",
          "1607:  VMCOREINFO_STRUCT_SIZE(pglist_data);",
          "1608:  VMCOREINFO_STRUCT_SIZE(zone);",
          "1609:  VMCOREINFO_STRUCT_SIZE(free_area);",
          "1610:  VMCOREINFO_STRUCT_SIZE(list_head);",
          "1611:  VMCOREINFO_SIZE(nodemask_t);",
          "1612:  VMCOREINFO_OFFSET(page, flags);",
          "1613:  VMCOREINFO_OFFSET(page, _count);",
          "1614:  VMCOREINFO_OFFSET(page, mapping);",
          "1615:  VMCOREINFO_OFFSET(page, lru);",
          "1616:  VMCOREINFO_OFFSET(page, _mapcount);",
          "1617:  VMCOREINFO_OFFSET(page, private);",
          "1618:  VMCOREINFO_OFFSET(pglist_data, node_zones);",
          "1619:  VMCOREINFO_OFFSET(pglist_data, nr_zones);",
          "1620: #ifdef CONFIG_FLAT_NODE_MEM_MAP",
          "1621:  VMCOREINFO_OFFSET(pglist_data, node_mem_map);",
          "1622: #endif",
          "1623:  VMCOREINFO_OFFSET(pglist_data, node_start_pfn);",
          "1624:  VMCOREINFO_OFFSET(pglist_data, node_spanned_pages);",
          "1625:  VMCOREINFO_OFFSET(pglist_data, node_id);",
          "1626:  VMCOREINFO_OFFSET(zone, free_area);",
          "1627:  VMCOREINFO_OFFSET(zone, vm_stat);",
          "1628:  VMCOREINFO_OFFSET(zone, spanned_pages);",
          "1629:  VMCOREINFO_OFFSET(free_area, free_list);",
          "1630:  VMCOREINFO_OFFSET(list_head, next);",
          "1631:  VMCOREINFO_OFFSET(list_head, prev);",
          "1632:  VMCOREINFO_OFFSET(vmap_area, va_start);",
          "1633:  VMCOREINFO_OFFSET(vmap_area, list);",
          "1634:  VMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);",
          "1635:  log_buf_kexec_setup();",
          "1636:  VMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);",
          "1637:  VMCOREINFO_NUMBER(NR_FREE_PAGES);",
          "1638:  VMCOREINFO_NUMBER(PG_lru);",
          "1639:  VMCOREINFO_NUMBER(PG_private);",
          "1640:  VMCOREINFO_NUMBER(PG_swapcache);",
          "1641:  VMCOREINFO_NUMBER(PG_slab);",
          "1642: #ifdef CONFIG_MEMORY_FAILURE",
          "1643:  VMCOREINFO_NUMBER(PG_hwpoison);",
          "1644: #endif",
          "1645:  VMCOREINFO_NUMBER(PG_head_mask);",
          "1646:  VMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);",
          "1647: #ifdef CONFIG_HUGETLBFS",
          "1648:  VMCOREINFO_SYMBOL(free_huge_page);",
          "1649: #endif",
          "1651:  arch_crash_save_vmcoreinfo();",
          "1652:  update_vmcoreinfo_note();",
          "1654:  return 0;",
          "1655: }",
          "1657: subsys_initcall(crash_save_vmcoreinfo_init);",
          "1663: int kernel_kexec(void)",
          "1664: {",
          "1665:  int error = 0;",
          "1667:  if (!mutex_trylock(&kexec_mutex))",
          "1668:   return -EBUSY;",
          "1669:  if (!kexec_image) {",
          "1670:   error = -EINVAL;",
          "1671:   goto Unlock;",
          "1672:  }",
          "1674: #ifdef CONFIG_KEXEC_JUMP",
          "1675:  if (kexec_image->preserve_context) {",
          "1676:   lock_system_sleep();",
          "1677:   pm_prepare_console();",
          "1678:   error = freeze_processes();",
          "1679:   if (error) {",
          "1680:    error = -EBUSY;",
          "1681:    goto Restore_console;",
          "1682:   }",
          "1683:   suspend_console();",
          "1684:   error = dpm_suspend_start(PMSG_FREEZE);",
          "1685:   if (error)",
          "1686:    goto Resume_console;",
          "1694:   error = dpm_suspend_end(PMSG_FREEZE);",
          "1695:   if (error)",
          "1696:    goto Resume_devices;",
          "1697:   error = disable_nonboot_cpus();",
          "1698:   if (error)",
          "1699:    goto Enable_cpus;",
          "1700:   local_irq_disable();",
          "1701:   error = syscore_suspend();",
          "1702:   if (error)",
          "1703:    goto Enable_irqs;",
          "1704:  } else",
          "1705: #endif",
          "1706:  {",
          "1707:   kexec_in_progress = true;",
          "1708:   kernel_restart_prepare(NULL);",
          "1709:   migrate_to_reboot_cpu();",
          "1717:   cpu_hotplug_enable();",
          "1718:   pr_emerg(\"Starting new kernel\\n\");",
          "1719:   machine_shutdown();",
          "1720:  }",
          "1722:  machine_kexec(kexec_image);",
          "1724: #ifdef CONFIG_KEXEC_JUMP",
          "1725:  if (kexec_image->preserve_context) {",
          "1726:   syscore_resume();",
          "1727:  Enable_irqs:",
          "1728:   local_irq_enable();",
          "1729:  Enable_cpus:",
          "1730:   enable_nonboot_cpus();",
          "1731:   dpm_resume_start(PMSG_RESTORE);",
          "1732:  Resume_devices:",
          "1733:   dpm_resume_end(PMSG_RESTORE);",
          "1734:  Resume_console:",
          "1735:   resume_console();",
          "1736:   thaw_processes();",
          "1737:  Restore_console:",
          "1738:   pm_restore_console();",
          "1739:   unlock_system_sleep();",
          "1740:  }",
          "1741: #endif",
          "1743:  Unlock:",
          "1744:  mutex_unlock(&kexec_mutex);",
          "1745:  return error;",
          "1746: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/kexec_core.c||kernel/kexec_core.c": [
          "File: kernel/kexec_core.c -> kernel/kexec_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #define pr_fmt(fmt) \"kexec: \" fmt",
          "11: #include <linux/capability.h>",
          "12: #include <linux/mm.h>",
          "13: #include <linux/file.h>",
          "14: #include <linux/slab.h>",
          "15: #include <linux/fs.h>",
          "16: #include <linux/kexec.h>",
          "17: #include <linux/mutex.h>",
          "18: #include <linux/list.h>",
          "19: #include <linux/highmem.h>",
          "20: #include <linux/syscalls.h>",
          "21: #include <linux/reboot.h>",
          "22: #include <linux/ioport.h>",
          "23: #include <linux/hardirq.h>",
          "24: #include <linux/elf.h>",
          "25: #include <linux/elfcore.h>",
          "26: #include <linux/utsname.h>",
          "27: #include <linux/numa.h>",
          "28: #include <linux/suspend.h>",
          "29: #include <linux/device.h>",
          "30: #include <linux/freezer.h>",
          "31: #include <linux/pm.h>",
          "32: #include <linux/cpu.h>",
          "33: #include <linux/uaccess.h>",
          "34: #include <linux/io.h>",
          "35: #include <linux/console.h>",
          "36: #include <linux/vmalloc.h>",
          "37: #include <linux/swap.h>",
          "38: #include <linux/syscore_ops.h>",
          "39: #include <linux/compiler.h>",
          "40: #include <linux/hugetlb.h>",
          "42: #include <asm/page.h>",
          "43: #include <asm/sections.h>",
          "45: #include <crypto/hash.h>",
          "46: #include <crypto/sha.h>",
          "47: #include \"kexec_internal.h\"",
          "49: DEFINE_MUTEX(kexec_mutex);",
          "52: note_buf_t __percpu *crash_notes;",
          "55: static unsigned char vmcoreinfo_data[VMCOREINFO_BYTES];",
          "56: u32 vmcoreinfo_note[VMCOREINFO_NOTE_SIZE/4];",
          "57: size_t vmcoreinfo_size;",
          "58: size_t vmcoreinfo_max_size = sizeof(vmcoreinfo_data);",
          "61: bool kexec_in_progress = false;",
          "65: struct resource crashk_res = {",
          "66:  .name  = \"Crash kernel\",",
          "67:  .start = 0,",
          "68:  .end   = 0,",
          "69:  .flags = IORESOURCE_BUSY | IORESOURCE_MEM",
          "70: };",
          "71: struct resource crashk_low_res = {",
          "72:  .name  = \"Crash kernel\",",
          "73:  .start = 0,",
          "74:  .end   = 0,",
          "75:  .flags = IORESOURCE_BUSY | IORESOURCE_MEM",
          "76: };",
          "78: int kexec_should_crash(struct task_struct *p)",
          "79: {",
          "85:  if (crash_kexec_post_notifiers)",
          "86:   return 0;",
          "91:  if (in_interrupt() || !p->pid || is_global_init(p) || panic_on_oops)",
          "92:   return 1;",
          "93:  return 0;",
          "94: }",
          "140: #define KIMAGE_NO_DEST (-1UL)",
          "142: static struct page *kimage_alloc_page(struct kimage *image,",
          "143:            gfp_t gfp_mask,",
          "144:            unsigned long dest);",
          "146: int sanity_check_segment_list(struct kimage *image)",
          "147: {",
          "148:  int result, i;",
          "149:  unsigned long nr_segments = image->nr_segments;",
          "164:  result = -EADDRNOTAVAIL;",
          "165:  for (i = 0; i < nr_segments; i++) {",
          "166:   unsigned long mstart, mend;",
          "168:   mstart = image->segment[i].mem;",
          "169:   mend   = mstart + image->segment[i].memsz;",
          "170:   if ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))",
          "171:    return result;",
          "172:   if (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)",
          "173:    return result;",
          "174:  }",
          "181:  result = -EINVAL;",
          "182:  for (i = 0; i < nr_segments; i++) {",
          "183:   unsigned long mstart, mend;",
          "184:   unsigned long j;",
          "186:   mstart = image->segment[i].mem;",
          "187:   mend   = mstart + image->segment[i].memsz;",
          "188:   for (j = 0; j < i; j++) {",
          "189:    unsigned long pstart, pend;",
          "191:    pstart = image->segment[j].mem;",
          "192:    pend   = pstart + image->segment[j].memsz;",
          "194:    if ((mend > pstart) && (mstart < pend))",
          "195:     return result;",
          "196:   }",
          "197:  }",
          "204:  result = -EINVAL;",
          "205:  for (i = 0; i < nr_segments; i++) {",
          "206:   if (image->segment[i].bufsz > image->segment[i].memsz)",
          "207:    return result;",
          "208:  }",
          "220:  if (image->type == KEXEC_TYPE_CRASH) {",
          "221:   result = -EADDRNOTAVAIL;",
          "222:   for (i = 0; i < nr_segments; i++) {",
          "223:    unsigned long mstart, mend;",
          "225:    mstart = image->segment[i].mem;",
          "226:    mend = mstart + image->segment[i].memsz - 1;",
          "228:    if ((mstart < crashk_res.start) ||",
          "229:        (mend > crashk_res.end))",
          "230:     return result;",
          "231:   }",
          "232:  }",
          "234:  return 0;",
          "235: }",
          "237: struct kimage *do_kimage_alloc_init(void)",
          "238: {",
          "239:  struct kimage *image;",
          "242:  image = kzalloc(sizeof(*image), GFP_KERNEL);",
          "243:  if (!image)",
          "244:   return NULL;",
          "246:  image->head = 0;",
          "247:  image->entry = &image->head;",
          "248:  image->last_entry = &image->head;",
          "250:  image->type = KEXEC_TYPE_DEFAULT;",
          "253:  INIT_LIST_HEAD(&image->control_pages);",
          "256:  INIT_LIST_HEAD(&image->dest_pages);",
          "259:  INIT_LIST_HEAD(&image->unusable_pages);",
          "261:  return image;",
          "262: }",
          "264: int kimage_is_destination_range(struct kimage *image,",
          "265:      unsigned long start,",
          "266:      unsigned long end)",
          "267: {",
          "268:  unsigned long i;",
          "270:  for (i = 0; i < image->nr_segments; i++) {",
          "271:   unsigned long mstart, mend;",
          "273:   mstart = image->segment[i].mem;",
          "274:   mend = mstart + image->segment[i].memsz;",
          "275:   if ((end > mstart) && (start < mend))",
          "276:    return 1;",
          "277:  }",
          "279:  return 0;",
          "280: }",
          "282: static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)",
          "283: {",
          "284:  struct page *pages;",
          "286:  pages = alloc_pages(gfp_mask, order);",
          "287:  if (pages) {",
          "288:   unsigned int count, i;",
          "290:   pages->mapping = NULL;",
          "291:   set_page_private(pages, order);",
          "292:   count = 1 << order;",
          "293:   for (i = 0; i < count; i++)",
          "294:    SetPageReserved(pages + i);",
          "295:  }",
          "297:  return pages;",
          "298: }",
          "300: static void kimage_free_pages(struct page *page)",
          "301: {",
          "302:  unsigned int order, count, i;",
          "304:  order = page_private(page);",
          "305:  count = 1 << order;",
          "306:  for (i = 0; i < count; i++)",
          "307:   ClearPageReserved(page + i);",
          "308:  __free_pages(page, order);",
          "309: }",
          "311: void kimage_free_page_list(struct list_head *list)",
          "312: {",
          "313:  struct list_head *pos, *next;",
          "315:  list_for_each_safe(pos, next, list) {",
          "316:   struct page *page;",
          "318:   page = list_entry(pos, struct page, lru);",
          "319:   list_del(&page->lru);",
          "320:   kimage_free_pages(page);",
          "321:  }",
          "322: }",
          "324: static struct page *kimage_alloc_normal_control_pages(struct kimage *image,",
          "325:        unsigned int order)",
          "326: {",
          "340:  struct list_head extra_pages;",
          "341:  struct page *pages;",
          "342:  unsigned int count;",
          "344:  count = 1 << order;",
          "345:  INIT_LIST_HEAD(&extra_pages);",
          "350:  do {",
          "351:   unsigned long pfn, epfn, addr, eaddr;",
          "353:   pages = kimage_alloc_pages(KEXEC_CONTROL_MEMORY_GFP, order);",
          "354:   if (!pages)",
          "355:    break;",
          "356:   pfn   = page_to_pfn(pages);",
          "357:   epfn  = pfn + count;",
          "358:   addr  = pfn << PAGE_SHIFT;",
          "359:   eaddr = epfn << PAGE_SHIFT;",
          "360:   if ((epfn >= (KEXEC_CONTROL_MEMORY_LIMIT >> PAGE_SHIFT)) ||",
          "361:          kimage_is_destination_range(image, addr, eaddr)) {",
          "362:    list_add(&pages->lru, &extra_pages);",
          "363:    pages = NULL;",
          "364:   }",
          "365:  } while (!pages);",
          "367:  if (pages) {",
          "369:   list_add(&pages->lru, &image->control_pages);",
          "377:  }",
          "385:  kimage_free_page_list(&extra_pages);",
          "387:  return pages;",
          "388: }",
          "390: static struct page *kimage_alloc_crash_control_pages(struct kimage *image,",
          "391:             unsigned int order)",
          "392: {",
          "414:  unsigned long hole_start, hole_end, size;",
          "415:  struct page *pages;",
          "417:  pages = NULL;",
          "418:  size = (1 << order) << PAGE_SHIFT;",
          "419:  hole_start = (image->control_page + (size - 1)) & ~(size - 1);",
          "420:  hole_end   = hole_start + size - 1;",
          "421:  while (hole_end <= crashk_res.end) {",
          "422:   unsigned long i;",
          "424:   if (hole_end > KEXEC_CRASH_CONTROL_MEMORY_LIMIT)",
          "425:    break;",
          "427:   for (i = 0; i < image->nr_segments; i++) {",
          "428:    unsigned long mstart, mend;",
          "430:    mstart = image->segment[i].mem;",
          "431:    mend   = mstart + image->segment[i].memsz - 1;",
          "432:    if ((hole_end >= mstart) && (hole_start <= mend)) {",
          "434:     hole_start = (mend + (size - 1)) & ~(size - 1);",
          "435:     hole_end   = hole_start + size - 1;",
          "436:     break;",
          "437:    }",
          "438:   }",
          "440:   if (i == image->nr_segments) {",
          "441:    pages = pfn_to_page(hole_start >> PAGE_SHIFT);",
          "442:    break;",
          "443:   }",
          "444:  }",
          "445:  if (pages)",
          "446:   image->control_page = hole_end;",
          "448:  return pages;",
          "449: }",
          "452: struct page *kimage_alloc_control_pages(struct kimage *image,",
          "453:       unsigned int order)",
          "454: {",
          "455:  struct page *pages = NULL;",
          "457:  switch (image->type) {",
          "458:  case KEXEC_TYPE_DEFAULT:",
          "459:   pages = kimage_alloc_normal_control_pages(image, order);",
          "460:   break;",
          "461:  case KEXEC_TYPE_CRASH:",
          "462:   pages = kimage_alloc_crash_control_pages(image, order);",
          "463:   break;",
          "464:  }",
          "466:  return pages;",
          "467: }",
          "469: static int kimage_add_entry(struct kimage *image, kimage_entry_t entry)",
          "470: {",
          "471:  if (*image->entry != 0)",
          "472:   image->entry++;",
          "474:  if (image->entry == image->last_entry) {",
          "475:   kimage_entry_t *ind_page;",
          "476:   struct page *page;",
          "478:   page = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);",
          "479:   if (!page)",
          "480:    return -ENOMEM;",
          "482:   ind_page = page_address(page);",
          "484:   image->entry = ind_page;",
          "485:   image->last_entry = ind_page +",
          "486:           ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);",
          "487:  }",
          "489:  image->entry++;",
          "492:  return 0;",
          "493: }",
          "495: static int kimage_set_destination(struct kimage *image,",
          "496:        unsigned long destination)",
          "497: {",
          "498:  int result;",
          "500:  destination &= PAGE_MASK;",
          "501:  result = kimage_add_entry(image, destination | IND_DESTINATION);",
          "503:  return result;",
          "504: }",
          "507: static int kimage_add_page(struct kimage *image, unsigned long page)",
          "508: {",
          "509:  int result;",
          "511:  page &= PAGE_MASK;",
          "512:  result = kimage_add_entry(image, page | IND_SOURCE);",
          "514:  return result;",
          "515: }",
          "518: static void kimage_free_extra_pages(struct kimage *image)",
          "519: {",
          "521:  kimage_free_page_list(&image->dest_pages);",
          "524:  kimage_free_page_list(&image->unusable_pages);",
          "526: }",
          "527: void kimage_terminate(struct kimage *image)",
          "528: {",
          "529:  if (*image->entry != 0)",
          "530:   image->entry++;",
          "533: }",
          "535: #define for_each_kimage_entry(image, ptr, entry) \\",
          "536:  for (ptr = &image->head; (entry = *ptr) && !(entry & IND_DONE); \\",
          "537:   ptr = (entry & IND_INDIRECTION) ? \\",
          "538:    phys_to_virt((entry & PAGE_MASK)) : ptr + 1)",
          "540: static void kimage_free_entry(kimage_entry_t entry)",
          "541: {",
          "542:  struct page *page;",
          "544:  page = pfn_to_page(entry >> PAGE_SHIFT);",
          "545:  kimage_free_pages(page);",
          "546: }",
          "548: void kimage_free(struct kimage *image)",
          "549: {",
          "550:  kimage_entry_t *ptr, entry;",
          "551:  kimage_entry_t ind = 0;",
          "553:  if (!image)",
          "554:   return;",
          "556:  kimage_free_extra_pages(image);",
          "557:  for_each_kimage_entry(image, ptr, entry) {",
          "558:   if (entry & IND_INDIRECTION) {",
          "560:    if (ind & IND_INDIRECTION)",
          "561:     kimage_free_entry(ind);",
          "565:    ind = entry;",
          "566:   } else if (entry & IND_SOURCE)",
          "567:    kimage_free_entry(entry);",
          "568:  }",
          "570:  if (ind & IND_INDIRECTION)",
          "571:   kimage_free_entry(ind);",
          "574:  machine_kexec_cleanup(image);",
          "577:  kimage_free_page_list(&image->control_pages);",
          "583:  if (image->file_mode)",
          "584:   kimage_file_post_load_cleanup(image);",
          "586:  kfree(image);",
          "587: }",
          "589: static kimage_entry_t *kimage_dst_used(struct kimage *image,",
          "590:      unsigned long page)",
          "591: {",
          "592:  kimage_entry_t *ptr, entry;",
          "593:  unsigned long destination = 0;",
          "595:  for_each_kimage_entry(image, ptr, entry) {",
          "596:   if (entry & IND_DESTINATION)",
          "597:    destination = entry & PAGE_MASK;",
          "598:   else if (entry & IND_SOURCE) {",
          "599:    if (page == destination)",
          "600:     return ptr;",
          "601:    destination += PAGE_SIZE;",
          "602:   }",
          "603:  }",
          "605:  return NULL;",
          "606: }",
          "608: static struct page *kimage_alloc_page(struct kimage *image,",
          "609:      gfp_t gfp_mask,",
          "610:      unsigned long destination)",
          "611: {",
          "630:  struct page *page;",
          "631:  unsigned long addr;",
          "637:  list_for_each_entry(page, &image->dest_pages, lru) {",
          "638:   addr = page_to_pfn(page) << PAGE_SHIFT;",
          "639:   if (addr == destination) {",
          "640:    list_del(&page->lru);",
          "641:    return page;",
          "642:   }",
          "643:  }",
          "644:  page = NULL;",
          "645:  while (1) {",
          "646:   kimage_entry_t *old;",
          "649:   page = kimage_alloc_pages(gfp_mask, 0);",
          "650:   if (!page)",
          "651:    return NULL;",
          "653:   if (page_to_pfn(page) >",
          "654:     (KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {",
          "655:    list_add(&page->lru, &image->unusable_pages);",
          "656:    continue;",
          "657:   }",
          "658:   addr = page_to_pfn(page) << PAGE_SHIFT;",
          "661:   if (addr == destination)",
          "662:    break;",
          "665:   if (!kimage_is_destination_range(image, addr,",
          "666:         addr + PAGE_SIZE))",
          "667:    break;",
          "674:   old = kimage_dst_used(image, addr);",
          "675:   if (old) {",
          "677:    unsigned long old_addr;",
          "678:    struct page *old_page;",
          "680:    old_addr = *old & PAGE_MASK;",
          "681:    old_page = pfn_to_page(old_addr >> PAGE_SHIFT);",
          "682:    copy_highpage(page, old_page);",
          "689:    if (!(gfp_mask & __GFP_HIGHMEM) &&",
          "690:        PageHighMem(old_page)) {",
          "691:     kimage_free_pages(old_page);",
          "692:     continue;",
          "693:    }",
          "694:    addr = old_addr;",
          "695:    page = old_page;",
          "696:    break;",
          "697:   }",
          "699:   list_add(&page->lru, &image->dest_pages);",
          "700:  }",
          "702:  return page;",
          "703: }",
          "705: static int kimage_load_normal_segment(struct kimage *image,",
          "706:       struct kexec_segment *segment)",
          "707: {",
          "708:  unsigned long maddr;",
          "709:  size_t ubytes, mbytes;",
          "710:  int result;",
          "711:  unsigned char __user *buf = NULL;",
          "712:  unsigned char *kbuf = NULL;",
          "714:  result = 0;",
          "715:  if (image->file_mode)",
          "716:   kbuf = segment->kbuf;",
          "717:  else",
          "718:   buf = segment->buf;",
          "719:  ubytes = segment->bufsz;",
          "720:  mbytes = segment->memsz;",
          "721:  maddr = segment->mem;",
          "723:  result = kimage_set_destination(image, maddr);",
          "724:  if (result < 0)",
          "725:   goto out;",
          "727:  while (mbytes) {",
          "728:   struct page *page;",
          "729:   char *ptr;",
          "730:   size_t uchunk, mchunk;",
          "732:   page = kimage_alloc_page(image, GFP_HIGHUSER, maddr);",
          "733:   if (!page) {",
          "734:    result  = -ENOMEM;",
          "735:    goto out;",
          "736:   }",
          "737:   result = kimage_add_page(image, page_to_pfn(page)",
          "738:         << PAGE_SHIFT);",
          "739:   if (result < 0)",
          "740:    goto out;",
          "742:   ptr = kmap(page);",
          "744:   clear_page(ptr);",
          "745:   ptr += maddr & ~PAGE_MASK;",
          "746:   mchunk = min_t(size_t, mbytes,",
          "747:     PAGE_SIZE - (maddr & ~PAGE_MASK));",
          "748:   uchunk = min(ubytes, mchunk);",
          "751:   if (image->file_mode)",
          "752:    memcpy(ptr, kbuf, uchunk);",
          "753:   else",
          "754:    result = copy_from_user(ptr, buf, uchunk);",
          "755:   kunmap(page);",
          "756:   if (result) {",
          "757:    result = -EFAULT;",
          "758:    goto out;",
          "759:   }",
          "760:   ubytes -= uchunk;",
          "761:   maddr  += mchunk;",
          "762:   if (image->file_mode)",
          "763:    kbuf += mchunk;",
          "764:   else",
          "765:    buf += mchunk;",
          "766:   mbytes -= mchunk;",
          "767:  }",
          "768: out:",
          "769:  return result;",
          "770: }",
          "772: static int kimage_load_crash_segment(struct kimage *image,",
          "773:      struct kexec_segment *segment)",
          "774: {",
          "779:  unsigned long maddr;",
          "780:  size_t ubytes, mbytes;",
          "781:  int result;",
          "782:  unsigned char __user *buf = NULL;",
          "783:  unsigned char *kbuf = NULL;",
          "785:  result = 0;",
          "786:  if (image->file_mode)",
          "787:   kbuf = segment->kbuf;",
          "788:  else",
          "789:   buf = segment->buf;",
          "790:  ubytes = segment->bufsz;",
          "791:  mbytes = segment->memsz;",
          "792:  maddr = segment->mem;",
          "793:  while (mbytes) {",
          "794:   struct page *page;",
          "795:   char *ptr;",
          "796:   size_t uchunk, mchunk;",
          "798:   page = pfn_to_page(maddr >> PAGE_SHIFT);",
          "799:   if (!page) {",
          "800:    result  = -ENOMEM;",
          "801:    goto out;",
          "802:   }",
          "803:   ptr = kmap(page);",
          "804:   ptr += maddr & ~PAGE_MASK;",
          "805:   mchunk = min_t(size_t, mbytes,",
          "806:     PAGE_SIZE - (maddr & ~PAGE_MASK));",
          "807:   uchunk = min(ubytes, mchunk);",
          "808:   if (mchunk > uchunk) {",
          "810:    memset(ptr + uchunk, 0, mchunk - uchunk);",
          "811:   }",
          "814:   if (image->file_mode)",
          "815:    memcpy(ptr, kbuf, uchunk);",
          "816:   else",
          "817:    result = copy_from_user(ptr, buf, uchunk);",
          "818:   kexec_flush_icache_page(page);",
          "819:   kunmap(page);",
          "820:   if (result) {",
          "821:    result = -EFAULT;",
          "822:    goto out;",
          "823:   }",
          "824:   ubytes -= uchunk;",
          "825:   maddr  += mchunk;",
          "826:   if (image->file_mode)",
          "827:    kbuf += mchunk;",
          "828:   else",
          "829:    buf += mchunk;",
          "830:   mbytes -= mchunk;",
          "831:  }",
          "832: out:",
          "833:  return result;",
          "834: }",
          "836: int kimage_load_segment(struct kimage *image,",
          "837:     struct kexec_segment *segment)",
          "838: {",
          "839:  int result = -ENOMEM;",
          "841:  switch (image->type) {",
          "842:  case KEXEC_TYPE_DEFAULT:",
          "843:   result = kimage_load_normal_segment(image, segment);",
          "844:   break;",
          "845:  case KEXEC_TYPE_CRASH:",
          "846:   result = kimage_load_crash_segment(image, segment);",
          "847:   break;",
          "848:  }",
          "850:  return result;",
          "851: }",
          "853: struct kimage *kexec_image;",
          "854: struct kimage *kexec_crash_image;",
          "855: int kexec_load_disabled;",
          "857: void crash_kexec(struct pt_regs *regs)",
          "858: {",
          "867:  if (mutex_trylock(&kexec_mutex)) {",
          "868:   if (kexec_crash_image) {",
          "869:    struct pt_regs fixed_regs;",
          "871:    crash_setup_regs(&fixed_regs, regs);",
          "872:    crash_save_vmcoreinfo();",
          "873:    machine_crash_shutdown(&fixed_regs);",
          "874:    machine_kexec(kexec_crash_image);",
          "875:   }",
          "876:   mutex_unlock(&kexec_mutex);",
          "877:  }",
          "878: }",
          "880: size_t crash_get_memory_size(void)",
          "881: {",
          "882:  size_t size = 0;",
          "884:  mutex_lock(&kexec_mutex);",
          "885:  if (crashk_res.end != crashk_res.start)",
          "886:   size = resource_size(&crashk_res);",
          "887:  mutex_unlock(&kexec_mutex);",
          "888:  return size;",
          "889: }",
          "891: void __weak crash_free_reserved_phys_range(unsigned long begin,",
          "892:         unsigned long end)",
          "893: {",
          "894:  unsigned long addr;",
          "896:  for (addr = begin; addr < end; addr += PAGE_SIZE)",
          "897:   free_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));",
          "898: }",
          "900: int crash_shrink_memory(unsigned long new_size)",
          "901: {",
          "902:  int ret = 0;",
          "903:  unsigned long start, end;",
          "904:  unsigned long old_size;",
          "905:  struct resource *ram_res;",
          "907:  mutex_lock(&kexec_mutex);",
          "909:  if (kexec_crash_image) {",
          "910:   ret = -ENOENT;",
          "911:   goto unlock;",
          "912:  }",
          "913:  start = crashk_res.start;",
          "914:  end = crashk_res.end;",
          "915:  old_size = (end == 0) ? 0 : end - start + 1;",
          "916:  if (new_size >= old_size) {",
          "917:   ret = (new_size == old_size) ? 0 : -EINVAL;",
          "918:   goto unlock;",
          "919:  }",
          "921:  ram_res = kzalloc(sizeof(*ram_res), GFP_KERNEL);",
          "922:  if (!ram_res) {",
          "923:   ret = -ENOMEM;",
          "924:   goto unlock;",
          "925:  }",
          "927:  start = roundup(start, KEXEC_CRASH_MEM_ALIGN);",
          "928:  end = roundup(start + new_size, KEXEC_CRASH_MEM_ALIGN);",
          "930:  crash_map_reserved_pages();",
          "931:  crash_free_reserved_phys_range(end, crashk_res.end);",
          "933:  if ((start == end) && (crashk_res.parent != NULL))",
          "934:   release_resource(&crashk_res);",
          "936:  ram_res->start = end;",
          "937:  ram_res->end = crashk_res.end;",
          "938:  ram_res->flags = IORESOURCE_BUSY | IORESOURCE_MEM;",
          "939:  ram_res->name = \"System RAM\";",
          "941:  crashk_res.end = end - 1;",
          "943:  insert_resource(&iomem_resource, ram_res);",
          "944:  crash_unmap_reserved_pages();",
          "946: unlock:",
          "947:  mutex_unlock(&kexec_mutex);",
          "948:  return ret;",
          "949: }",
          "951: static u32 *append_elf_note(u32 *buf, char *name, unsigned type, void *data,",
          "952:        size_t data_len)",
          "953: {",
          "954:  struct elf_note note;",
          "956:  note.n_namesz = strlen(name) + 1;",
          "957:  note.n_descsz = data_len;",
          "958:  note.n_type   = type;",
          "959:  memcpy(buf, &note, sizeof(note));",
          "960:  buf += (sizeof(note) + 3)/4;",
          "961:  memcpy(buf, name, note.n_namesz);",
          "962:  buf += (note.n_namesz + 3)/4;",
          "963:  memcpy(buf, data, note.n_descsz);",
          "964:  buf += (note.n_descsz + 3)/4;",
          "966:  return buf;",
          "967: }",
          "969: static void final_note(u32 *buf)",
          "970: {",
          "971:  struct elf_note note;",
          "973:  note.n_namesz = 0;",
          "974:  note.n_descsz = 0;",
          "975:  note.n_type   = 0;",
          "976:  memcpy(buf, &note, sizeof(note));",
          "977: }",
          "979: void crash_save_cpu(struct pt_regs *regs, int cpu)",
          "980: {",
          "981:  struct elf_prstatus prstatus;",
          "982:  u32 *buf;",
          "984:  if ((cpu < 0) || (cpu >= nr_cpu_ids))",
          "985:   return;",
          "994:  buf = (u32 *)per_cpu_ptr(crash_notes, cpu);",
          "995:  if (!buf)",
          "996:   return;",
          "997:  memset(&prstatus, 0, sizeof(prstatus));",
          "998:  prstatus.pr_pid = current->pid;",
          "999:  elf_core_copy_kernel_regs(&prstatus.pr_reg, regs);",
          "1000:  buf = append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,",
          "1001:          &prstatus, sizeof(prstatus));",
          "1002:  final_note(buf);",
          "1003: }",
          "1005: static int __init crash_notes_memory_init(void)",
          "1006: {",
          "1008:  crash_notes = alloc_percpu(note_buf_t);",
          "1009:  if (!crash_notes) {",
          "1010:   pr_warn(\"Kexec: Memory allocation for saving cpu register states failed\\n\");",
          "1011:   return -ENOMEM;",
          "1012:  }",
          "1013:  return 0;",
          "1014: }",
          "1015: subsys_initcall(crash_notes_memory_init);",
          "1032: static int __init parse_crashkernel_mem(char *cmdline,",
          "1033:      unsigned long long system_ram,",
          "1034:      unsigned long long *crash_size,",
          "1035:      unsigned long long *crash_base)",
          "1036: {",
          "1037:  char *cur = cmdline, *tmp;",
          "1040:  do {",
          "1041:   unsigned long long start, end = ULLONG_MAX, size;",
          "1044:   start = memparse(cur, &tmp);",
          "1045:   if (cur == tmp) {",
          "1046:    pr_warn(\"crashkernel: Memory value expected\\n\");",
          "1047:    return -EINVAL;",
          "1048:   }",
          "1049:   cur = tmp;",
          "1050:   if (*cur != '-') {",
          "1051:    pr_warn(\"crashkernel: '-' expected\\n\");",
          "1052:    return -EINVAL;",
          "1053:   }",
          "1054:   cur++;",
          "1057:   if (*cur != ':') {",
          "1058:    end = memparse(cur, &tmp);",
          "1059:    if (cur == tmp) {",
          "1060:     pr_warn(\"crashkernel: Memory value expected\\n\");",
          "1061:     return -EINVAL;",
          "1062:    }",
          "1063:    cur = tmp;",
          "1064:    if (end <= start) {",
          "1065:     pr_warn(\"crashkernel: end <= start\\n\");",
          "1066:     return -EINVAL;",
          "1067:    }",
          "1068:   }",
          "1070:   if (*cur != ':') {",
          "1071:    pr_warn(\"crashkernel: ':' expected\\n\");",
          "1072:    return -EINVAL;",
          "1073:   }",
          "1074:   cur++;",
          "1076:   size = memparse(cur, &tmp);",
          "1077:   if (cur == tmp) {",
          "1078:    pr_warn(\"Memory value expected\\n\");",
          "1079:    return -EINVAL;",
          "1080:   }",
          "1081:   cur = tmp;",
          "1082:   if (size >= system_ram) {",
          "1083:    pr_warn(\"crashkernel: invalid size\\n\");",
          "1084:    return -EINVAL;",
          "1085:   }",
          "1088:   if (system_ram >= start && system_ram < end) {",
          "1090:    break;",
          "1091:   }",
          "1092:  } while (*cur++ == ',');",
          "1094:  if (*crash_size > 0) {",
          "1095:   while (*cur && *cur != ' ' && *cur != '@')",
          "1096:    cur++;",
          "1097:   if (*cur == '@') {",
          "1098:    cur++;",
          "1100:    if (cur == tmp) {",
          "1101:     pr_warn(\"Memory value expected after '@'\\n\");",
          "1102:     return -EINVAL;",
          "1103:    }",
          "1104:   }",
          "1105:  }",
          "1107:  return 0;",
          "1108: }",
          "1117: static int __init parse_crashkernel_simple(char *cmdline,",
          "1118:         unsigned long long *crash_size,",
          "1119:         unsigned long long *crash_base)",
          "1120: {",
          "1121:  char *cur = cmdline;",
          "1124:  if (cmdline == cur) {",
          "1125:   pr_warn(\"crashkernel: memory value expected\\n\");",
          "1126:   return -EINVAL;",
          "1127:  }",
          "1129:  if (*cur == '@')",
          "1131:  else if (*cur != ' ' && *cur != '\\0') {",
          "1132:   pr_warn(\"crashkernel: unrecognized char\\n\");",
          "1133:   return -EINVAL;",
          "1134:  }",
          "1136:  return 0;",
          "1137: }",
          "1139: #define SUFFIX_HIGH 0",
          "1140: #define SUFFIX_LOW  1",
          "1141: #define SUFFIX_NULL 2",
          "1142: static __initdata char *suffix_tbl[] = {",
          "1143:  [SUFFIX_HIGH] = \",high\",",
          "1144:  [SUFFIX_LOW]  = \",low\",",
          "1145:  [SUFFIX_NULL] = NULL,",
          "1146: };",
          "1155: static int __init parse_crashkernel_suffix(char *cmdline,",
          "1156:         unsigned long long *crash_size,",
          "1157:         const char *suffix)",
          "1158: {",
          "1159:  char *cur = cmdline;",
          "1162:  if (cmdline == cur) {",
          "1163:   pr_warn(\"crashkernel: memory value expected\\n\");",
          "1164:   return -EINVAL;",
          "1165:  }",
          "1168:  if (strncmp(cur, suffix, strlen(suffix))) {",
          "1169:   pr_warn(\"crashkernel: unrecognized char\\n\");",
          "1170:   return -EINVAL;",
          "1171:  }",
          "1172:  cur += strlen(suffix);",
          "1173:  if (*cur != ' ' && *cur != '\\0') {",
          "1174:   pr_warn(\"crashkernel: unrecognized char\\n\");",
          "1175:   return -EINVAL;",
          "1176:  }",
          "1178:  return 0;",
          "1179: }",
          "1181: static __init char *get_last_crashkernel(char *cmdline,",
          "1182:         const char *name,",
          "1183:         const char *suffix)",
          "1184: {",
          "1185:  char *p = cmdline, *ck_cmdline = NULL;",
          "1188:  p = strstr(p, name);",
          "1189:  while (p) {",
          "1190:   char *end_p = strchr(p, ' ');",
          "1191:   char *q;",
          "1193:   if (!end_p)",
          "1194:    end_p = p + strlen(p);",
          "1196:   if (!suffix) {",
          "1197:    int i;",
          "1200:    for (i = 0; suffix_tbl[i]; i++) {",
          "1201:     q = end_p - strlen(suffix_tbl[i]);",
          "1202:     if (!strncmp(q, suffix_tbl[i],",
          "1203:           strlen(suffix_tbl[i])))",
          "1204:      goto next;",
          "1205:    }",
          "1206:    ck_cmdline = p;",
          "1207:   } else {",
          "1208:    q = end_p - strlen(suffix);",
          "1209:    if (!strncmp(q, suffix, strlen(suffix)))",
          "1210:     ck_cmdline = p;",
          "1211:   }",
          "1212: next:",
          "1213:   p = strstr(p+1, name);",
          "1214:  }",
          "1216:  if (!ck_cmdline)",
          "1217:   return NULL;",
          "1219:  return ck_cmdline;",
          "1220: }",
          "1222: static int __init __parse_crashkernel(char *cmdline,",
          "1223:         unsigned long long system_ram,",
          "1224:         unsigned long long *crash_size,",
          "1225:         unsigned long long *crash_base,",
          "1226:         const char *name,",
          "1227:         const char *suffix)",
          "1228: {",
          "1229:  char *first_colon, *first_space;",
          "1230:  char *ck_cmdline;",
          "1232:  BUG_ON(!crash_size || !crash_base);",
          "1236:  ck_cmdline = get_last_crashkernel(cmdline, name, suffix);",
          "1238:  if (!ck_cmdline)",
          "1239:   return -EINVAL;",
          "1241:  ck_cmdline += strlen(name);",
          "1243:  if (suffix)",
          "1244:   return parse_crashkernel_suffix(ck_cmdline, crash_size,",
          "1245:     suffix);",
          "1250:  first_colon = strchr(ck_cmdline, ':');",
          "1251:  first_space = strchr(ck_cmdline, ' ');",
          "1252:  if (first_colon && (!first_space || first_colon < first_space))",
          "1253:   return parse_crashkernel_mem(ck_cmdline, system_ram,",
          "1254:     crash_size, crash_base);",
          "1256:  return parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);",
          "1257: }",
          "1263: int __init parse_crashkernel(char *cmdline,",
          "1264:         unsigned long long system_ram,",
          "1265:         unsigned long long *crash_size,",
          "1266:         unsigned long long *crash_base)",
          "1267: {",
          "1268:  return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,",
          "1269:      \"crashkernel=\", NULL);",
          "1270: }",
          "1272: int __init parse_crashkernel_high(char *cmdline,",
          "1273:         unsigned long long system_ram,",
          "1274:         unsigned long long *crash_size,",
          "1275:         unsigned long long *crash_base)",
          "1276: {",
          "1277:  return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,",
          "1278:     \"crashkernel=\", suffix_tbl[SUFFIX_HIGH]);",
          "1279: }",
          "1281: int __init parse_crashkernel_low(char *cmdline,",
          "1282:         unsigned long long system_ram,",
          "1283:         unsigned long long *crash_size,",
          "1284:         unsigned long long *crash_base)",
          "1285: {",
          "1286:  return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,",
          "1287:     \"crashkernel=\", suffix_tbl[SUFFIX_LOW]);",
          "1288: }",
          "1290: static void update_vmcoreinfo_note(void)",
          "1291: {",
          "1292:  u32 *buf = vmcoreinfo_note;",
          "1294:  if (!vmcoreinfo_size)",
          "1295:   return;",
          "1296:  buf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,",
          "1297:          vmcoreinfo_size);",
          "1298:  final_note(buf);",
          "1299: }",
          "1301: void crash_save_vmcoreinfo(void)",
          "1302: {",
          "1303:  vmcoreinfo_append_str(\"CRASHTIME=%ld\\n\", get_seconds());",
          "1304:  update_vmcoreinfo_note();",
          "1305: }",
          "1307: void vmcoreinfo_append_str(const char *fmt, ...)",
          "1308: {",
          "1309:  va_list args;",
          "1310:  char buf[0x50];",
          "1311:  size_t r;",
          "1313:  va_start(args, fmt);",
          "1314:  r = vscnprintf(buf, sizeof(buf), fmt, args);",
          "1315:  va_end(args);",
          "1317:  r = min(r, vmcoreinfo_max_size - vmcoreinfo_size);",
          "1319:  memcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);",
          "1321:  vmcoreinfo_size += r;",
          "1322: }",
          "1328: void __weak arch_crash_save_vmcoreinfo(void)",
          "1329: {}",
          "1331: unsigned long __weak paddr_vmcoreinfo_note(void)",
          "1332: {",
          "1333:  return __pa((unsigned long)(char *)&vmcoreinfo_note);",
          "1334: }",
          "1336: static int __init crash_save_vmcoreinfo_init(void)",
          "1337: {",
          "1338:  VMCOREINFO_OSRELEASE(init_uts_ns.name.release);",
          "1339:  VMCOREINFO_PAGESIZE(PAGE_SIZE);",
          "1341:  VMCOREINFO_SYMBOL(init_uts_ns);",
          "1342:  VMCOREINFO_SYMBOL(node_online_map);",
          "1343: #ifdef CONFIG_MMU",
          "1344:  VMCOREINFO_SYMBOL(swapper_pg_dir);",
          "1345: #endif",
          "1346:  VMCOREINFO_SYMBOL(_stext);",
          "1347:  VMCOREINFO_SYMBOL(vmap_area_list);",
          "1349: #ifndef CONFIG_NEED_MULTIPLE_NODES",
          "1350:  VMCOREINFO_SYMBOL(mem_map);",
          "1351:  VMCOREINFO_SYMBOL(contig_page_data);",
          "1352: #endif",
          "1353: #ifdef CONFIG_SPARSEMEM",
          "1354:  VMCOREINFO_SYMBOL(mem_section);",
          "1355:  VMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);",
          "1356:  VMCOREINFO_STRUCT_SIZE(mem_section);",
          "1357:  VMCOREINFO_OFFSET(mem_section, section_mem_map);",
          "1358: #endif",
          "1359:  VMCOREINFO_STRUCT_SIZE(page);",
          "1360:  VMCOREINFO_STRUCT_SIZE(pglist_data);",
          "1361:  VMCOREINFO_STRUCT_SIZE(zone);",
          "1362:  VMCOREINFO_STRUCT_SIZE(free_area);",
          "1363:  VMCOREINFO_STRUCT_SIZE(list_head);",
          "1364:  VMCOREINFO_SIZE(nodemask_t);",
          "1365:  VMCOREINFO_OFFSET(page, flags);",
          "1366:  VMCOREINFO_OFFSET(page, _count);",
          "1367:  VMCOREINFO_OFFSET(page, mapping);",
          "1368:  VMCOREINFO_OFFSET(page, lru);",
          "1369:  VMCOREINFO_OFFSET(page, _mapcount);",
          "1370:  VMCOREINFO_OFFSET(page, private);",
          "1371:  VMCOREINFO_OFFSET(pglist_data, node_zones);",
          "1372:  VMCOREINFO_OFFSET(pglist_data, nr_zones);",
          "1373: #ifdef CONFIG_FLAT_NODE_MEM_MAP",
          "1374:  VMCOREINFO_OFFSET(pglist_data, node_mem_map);",
          "1375: #endif",
          "1376:  VMCOREINFO_OFFSET(pglist_data, node_start_pfn);",
          "1377:  VMCOREINFO_OFFSET(pglist_data, node_spanned_pages);",
          "1378:  VMCOREINFO_OFFSET(pglist_data, node_id);",
          "1379:  VMCOREINFO_OFFSET(zone, free_area);",
          "1380:  VMCOREINFO_OFFSET(zone, vm_stat);",
          "1381:  VMCOREINFO_OFFSET(zone, spanned_pages);",
          "1382:  VMCOREINFO_OFFSET(free_area, free_list);",
          "1383:  VMCOREINFO_OFFSET(list_head, next);",
          "1384:  VMCOREINFO_OFFSET(list_head, prev);",
          "1385:  VMCOREINFO_OFFSET(vmap_area, va_start);",
          "1386:  VMCOREINFO_OFFSET(vmap_area, list);",
          "1387:  VMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);",
          "1388:  log_buf_kexec_setup();",
          "1389:  VMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);",
          "1390:  VMCOREINFO_NUMBER(NR_FREE_PAGES);",
          "1391:  VMCOREINFO_NUMBER(PG_lru);",
          "1392:  VMCOREINFO_NUMBER(PG_private);",
          "1393:  VMCOREINFO_NUMBER(PG_swapcache);",
          "1394:  VMCOREINFO_NUMBER(PG_slab);",
          "1395: #ifdef CONFIG_MEMORY_FAILURE",
          "1396:  VMCOREINFO_NUMBER(PG_hwpoison);",
          "1397: #endif",
          "1398:  VMCOREINFO_NUMBER(PG_head_mask);",
          "1399:  VMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);",
          "1400: #ifdef CONFIG_HUGETLBFS",
          "1401:  VMCOREINFO_SYMBOL(free_huge_page);",
          "1402: #endif",
          "1404:  arch_crash_save_vmcoreinfo();",
          "1405:  update_vmcoreinfo_note();",
          "1407:  return 0;",
          "1408: }",
          "1410: subsys_initcall(crash_save_vmcoreinfo_init);",
          "1416: int kernel_kexec(void)",
          "1417: {",
          "1418:  int error = 0;",
          "1420:  if (!mutex_trylock(&kexec_mutex))",
          "1421:   return -EBUSY;",
          "1422:  if (!kexec_image) {",
          "1423:   error = -EINVAL;",
          "1424:   goto Unlock;",
          "1425:  }",
          "1427: #ifdef CONFIG_KEXEC_JUMP",
          "1428:  if (kexec_image->preserve_context) {",
          "1429:   lock_system_sleep();",
          "1430:   pm_prepare_console();",
          "1431:   error = freeze_processes();",
          "1432:   if (error) {",
          "1433:    error = -EBUSY;",
          "1434:    goto Restore_console;",
          "1435:   }",
          "1436:   suspend_console();",
          "1437:   error = dpm_suspend_start(PMSG_FREEZE);",
          "1438:   if (error)",
          "1439:    goto Resume_console;",
          "1447:   error = dpm_suspend_end(PMSG_FREEZE);",
          "1448:   if (error)",
          "1449:    goto Resume_devices;",
          "1450:   error = disable_nonboot_cpus();",
          "1451:   if (error)",
          "1452:    goto Enable_cpus;",
          "1453:   local_irq_disable();",
          "1454:   error = syscore_suspend();",
          "1455:   if (error)",
          "1456:    goto Enable_irqs;",
          "1457:  } else",
          "1458: #endif",
          "1459:  {",
          "1460:   kexec_in_progress = true;",
          "1461:   kernel_restart_prepare(NULL);",
          "1462:   migrate_to_reboot_cpu();",
          "1470:   cpu_hotplug_enable();",
          "1471:   pr_emerg(\"Starting new kernel\\n\");",
          "1472:   machine_shutdown();",
          "1473:  }",
          "1475:  machine_kexec(kexec_image);",
          "1477: #ifdef CONFIG_KEXEC_JUMP",
          "1478:  if (kexec_image->preserve_context) {",
          "1479:   syscore_resume();",
          "1480:  Enable_irqs:",
          "1481:   local_irq_enable();",
          "1482:  Enable_cpus:",
          "1483:   enable_nonboot_cpus();",
          "1484:   dpm_resume_start(PMSG_RESTORE);",
          "1485:  Resume_devices:",
          "1486:   dpm_resume_end(PMSG_RESTORE);",
          "1487:  Resume_console:",
          "1488:   resume_console();",
          "1489:   thaw_processes();",
          "1490:  Restore_console:",
          "1491:   pm_restore_console();",
          "1492:   unlock_system_sleep();",
          "1493:  }",
          "1494: #endif",
          "1496:  Unlock:",
          "1497:  mutex_unlock(&kexec_mutex);",
          "1498:  return error;",
          "1499: }",
          "1507: void __weak crash_map_reserved_pages(void)",
          "1508: {}",
          "1510: void __weak crash_unmap_reserved_pages(void)",
          "1511: {}",
          "",
          "---------------"
        ],
        "kernel/ksysfs.c||kernel/ksysfs.c": [
          "File: kernel/ksysfs.c -> kernel/ksysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: KERNEL_ATTR_RW(profiling);",
          "91: #endif",
          "94: static ssize_t kexec_loaded_show(struct kobject *kobj,",
          "95:      struct kobj_attribute *attr, char *buf)",
          "96: {",
          "",
          "[Removed Lines]",
          "93: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "93: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "196: #ifdef CONFIG_PROFILING",
          "197:  &profiling_attr.attr,",
          "198: #endif",
          "200:  &kexec_loaded_attr.attr,",
          "201:  &kexec_crash_loaded_attr.attr,",
          "202:  &kexec_crash_size_attr.attr,",
          "",
          "[Removed Lines]",
          "199: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "199: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "kernel/printk/printk.c||kernel/printk/printk.c": [
          "File: kernel/printk/printk.c -> kernel/printk/printk.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "835:  .release = devkmsg_release,",
          "836: };",
          "",
          "[Removed Lines]",
          "838: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "838: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "kernel/reboot.c||kernel/reboot.c": [
          "File: kernel/reboot.c -> kernel/reboot.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "346:   kernel_restart(buffer);",
          "347:   break;",
          "350:  case LINUX_REBOOT_CMD_KEXEC:",
          "351:   ret = kernel_kexec();",
          "352:   break;",
          "",
          "[Removed Lines]",
          "349: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "349: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ],
        "kernel/sysctl.c||kernel/sysctl.c": [
          "File: kernel/sysctl.c -> kernel/sysctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "621:   .proc_handler = proc_dointvec,",
          "622:  },",
          "623: #endif",
          "625:  {",
          "626:   .procname = \"kexec_load_disabled\",",
          "627:   .data  = &kexec_load_disabled,",
          "",
          "[Removed Lines]",
          "624: #ifdef CONFIG_KEXEC",
          "",
          "[Added Lines]",
          "624: #ifdef CONFIG_KEXEC_CORE",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6a694a607a97d58c042fb7fbd60ef1caea26950c",
      "candidate_info": {
        "commit_hash": "6a694a607a97d58c042fb7fbd60ef1caea26950c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6a694a607a97d58c042fb7fbd60ef1caea26950c",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf: Update userspace page info for software event\n\nFor hardware events, the userspace page of the event gets updated in\ncontext switches, so if we read the timestamp in the page, we get\nfresh info.\n\nFor software events, this is missing currently. This patch makes the\nbehavior consistent.\n\nWith this patch, we can implement clock_gettime(THREAD_CPUTIME) with\nPERF_COUNT_SW_DUMMY in userspace as suggested by Andy and Peter. Code\nlike this:\n\n  if (pc->cap_user_time) {\n\tdo {\n\t\tseq = pc->lock;\n\t\tbarrier();\n\n\t\trunning = pc->time_running;\n\t\tcyc = rdtsc();\n\t\ttime_mult = pc->time_mult;\n\t\ttime_shift = pc->time_shift;\n\t\ttime_offset = pc->time_offset;\n\n\t\tbarrier();\n\t} while (pc->lock != seq);\n\n\tquot = (cyc >> time_shift);\n\trem = cyc & ((1 << time_shift) - 1);\n\tdelta = time_offset + quot * time_mult +\n\t\t((rem * time_mult) >> time_shift);\n\n\trunning += delta;\n\treturn running;\n  }\n\nI tried it on a busy system, the userspace page updating doesn't\nhave noticeable overhead.\n\nSigned-off-by: Shaohua Li <shli@fb.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http://lkml.kernel.org/r/aa2dd2e4f1e9f2225758be5ba00f14d6909a8ce1.1423180257.git.shli@fb.com\n[ Improved the changelog. ]\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6123:  }",
          "6125:  hlist_add_head_rcu(&event->hlist_entry, head);",
          "6127:  return 0;",
          "6128: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6126:  perf_event_update_userpage(event);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6592: {",
          "6593:  if (flags & PERF_EF_START)",
          "6594:   cpu_clock_event_start(event, flags);",
          "6596:  return 0;",
          "6597: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6596:  perf_event_update_userpage(event);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6666: {",
          "6667:  if (flags & PERF_EF_START)",
          "6668:   task_clock_event_start(event, flags);",
          "6670:  return 0;",
          "6671: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6671:  perf_event_update_userpage(event);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
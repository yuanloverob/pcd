{
  "cve_id": "CVE-2016-2327",
  "cve_desc": "libavcodec/pngenc.c in FFmpeg before 2.8.5 uses incorrect line sizes in certain row calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .avi file, related to the apng_encode_frame and encode_apng functions.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "7ec9c5ce8a753175244da971fed9f1e25aef7971",
  "patch_info": {
    "commit_hash": "7ec9c5ce8a753175244da971fed9f1e25aef7971",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7ec9c5ce8a753175244da971fed9f1e25aef7971",
    "files": [
      "libavcodec/pngenc.c"
    ],
    "message": "avcodec/pngenc: Replace memcpy by av_image_copy()\n\nFixes out of array access\nFixes: 0cf176e6d3ab9fe924f39738e513f547/asan_generic_4a54aa_3431_aaa28be1cb32e307a9890cad06f84fba.avi\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/pngenc.c||libavcodec/pngenc.c"
    ]
  },
  "patch_diff": {
    "libavcodec/pngenc.c||libavcodec/pngenc.c": [
      "File: libavcodec/pngenc.c -> libavcodec/pngenc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "768:             if (last_fctl_chunk.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {",
      "772:                 if (last_fctl_chunk.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {",
      "773:                     for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) {",
      "",
      "[Removed Lines]",
      "769:                 memcpy(diffFrame->data[0], s->last_frame->data[0],",
      "770:                        s->last_frame->linesize[0] * s->last_frame->height);",
      "",
      "[Added Lines]",
      "769:                 av_frame_copy(diffFrame, s->last_frame);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "779:                 if (!s->prev_frame)",
      "780:                     continue;",
      "784:             }",
      "",
      "[Removed Lines]",
      "782:                 memcpy(diffFrame->data[0], s->prev_frame->data[0],",
      "783:                        s->prev_frame->linesize[0] * s->prev_frame->height);",
      "",
      "[Added Lines]",
      "781:                 av_frame_copy(diffFrame, s->prev_frame);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "945:             }",
      "950:             if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {",
      "951:                 uint32_t y;",
      "952:                 uint8_t bpp = (s->bits_per_pixel + 7) >> 3;",
      "",
      "[Removed Lines]",
      "948:             memcpy(s->prev_frame->data[0], s->last_frame->data[0],",
      "949:                    s->last_frame->linesize[0] * s->last_frame->height);",
      "",
      "[Added Lines]",
      "946:             av_frame_copy(s->prev_frame, s->last_frame);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0c5a71fececbfd98e4cf3d3ae4a64660eba8c2b9",
      "candidate_info": {
        "commit_hash": "0c5a71fececbfd98e4cf3d3ae4a64660eba8c2b9",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/0c5a71fececbfd98e4cf3d3ae4a64660eba8c2b9",
        "files": [
          "libavcodec/pngenc.c"
        ],
        "message": "avcodec/pngenc: Replace memcpy by av_image_copy()\n\nFixes out of array access\nFixes: 0cf176e6d3ab9fe924f39738e513f547/asan_generic_4a54aa_3431_aaa28be1cb32e307a9890cad06f84fba.avi\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 7ec9c5ce8a753175244da971fed9f1e25aef7971)\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/pngenc.c||libavcodec/pngenc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ],
          "candidate": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/pngenc.c||libavcodec/pngenc.c": [
          "File: libavcodec/pngenc.c -> libavcodec/pngenc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "749:             if (last_fctl_chunk.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {",
          "753:                 if (last_fctl_chunk.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {",
          "754:                     for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) {",
          "",
          "[Removed Lines]",
          "750:                 memcpy(diffFrame->data[0], s->last_frame->data[0],",
          "751:                        s->last_frame->linesize[0] * s->last_frame->height);",
          "",
          "[Added Lines]",
          "750:                 av_frame_copy(diffFrame, s->last_frame);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "760:                 if (!s->prev_frame)",
          "761:                     continue;",
          "765:             }",
          "",
          "[Removed Lines]",
          "763:                 memcpy(diffFrame->data[0], s->prev_frame->data[0],",
          "764:                        s->prev_frame->linesize[0] * s->prev_frame->height);",
          "",
          "[Added Lines]",
          "762:                 av_frame_copy(diffFrame, s->prev_frame);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "923:             }",
          "928:             if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {",
          "929:                 uint32_t y;",
          "930:                 uint8_t bpp = (s->bits_per_pixel + 7) >> 3;",
          "",
          "[Removed Lines]",
          "926:             memcpy(s->prev_frame->data[0], s->last_frame->data[0],",
          "927:                    s->last_frame->linesize[0] * s->last_frame->height);",
          "",
          "[Added Lines]",
          "924:             av_frame_copy(s->prev_frame, s->last_frame);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d75984486399e655cbcba098e986ced4e1187efa",
      "candidate_info": {
        "commit_hash": "d75984486399e655cbcba098e986ced4e1187efa",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/d75984486399e655cbcba098e986ced4e1187efa",
        "files": [
          "configure",
          "libavcodec/Makefile",
          "libavcodec/allcodecs.c",
          "libavcodec/pngenc.c"
        ],
        "message": "apng: Add a basic APNG encoder\n\nSigned-off-by: Donny Yang <work@kota.moe>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/allcodecs.c||libavcodec/allcodecs.c",
          "libavcodec/pngenc.c||libavcodec/pngenc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ],
          "candidate": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/allcodecs.c||libavcodec/allcodecs.c": [
          "File: libavcodec/allcodecs.c -> libavcodec/allcodecs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:     REGISTER_ENCDEC (AMV,               amv);",
          "109:     REGISTER_DECODER(ANM,               anm);",
          "110:     REGISTER_DECODER(ANSI,              ansi);",
          "112:     REGISTER_ENCDEC (ASV1,              asv1);",
          "113:     REGISTER_ENCDEC (ASV2,              asv2);",
          "114:     REGISTER_DECODER(AURA,              aura);",
          "",
          "[Removed Lines]",
          "111:     REGISTER_DECODER(APNG,              apng);",
          "",
          "[Added Lines]",
          "111:     REGISTER_ENCDEC (APNG,              apng);",
          "",
          "---------------"
        ],
        "libavcodec/pngenc.c||libavcodec/pngenc.c": [
          "File: libavcodec/pngenc.c -> libavcodec/pngenc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"bytestream.h\"",
          "25: #include \"huffyuvencdsp.h\"",
          "26: #include \"png.h\"",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"libavutil/libm.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"apng.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:     int bit_depth;",
          "54:     int color_type;",
          "55:     int bits_per_pixel;",
          "56: } PNGEncContext;",
          "58: static void png_get_interlaced_row(uint8_t *dst, int row_size,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:     uint32_t palette_checksum;   // Used to ensure a single unique palette",
          "60:     uint32_t sequence_number;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:     bytestream_put_be32(f, crc);",
          "217: }",
          "221: {",
          "222:     int ret;",
          "224:     s->zstream.avail_in = size;",
          "",
          "[Removed Lines]",
          "220: static int png_write_row(PNGEncContext *s, const uint8_t *data, int size)",
          "",
          "[Added Lines]",
          "224: static void png_write_image_data(AVCodecContext *avctx,",
          "225:                                  const uint8_t *buf, int length)",
          "226: {",
          "227:     PNGEncContext *s = avctx->priv_data;",
          "228:     uint32_t crc = crc32(0, Z_NULL, 0);",
          "230:     if (avctx->codec_id == AV_CODEC_ID_PNG || avctx->frame_number == 0)",
          "231:         return png_write_chunk(&s->bytestream, MKTAG('I', 'D', 'A', 'T'), buf, length);",
          "233:     bytestream_put_be32(&s->bytestream, length + 4);",
          "235:     bytestream_put_be32(&s->bytestream, MKBETAG('f', 'd', 'A', 'T'));",
          "236:     bytestream_put_be32(&s->bytestream, s->sequence_number);",
          "237:     crc = crc32(crc, s->bytestream - 8, 8);",
          "239:     crc = crc32(crc, buf, length);",
          "240:     memcpy(s->bytestream, buf, length);",
          "241:     s->bytestream += length;",
          "243:     bytestream_put_be32(&s->bytestream, crc);",
          "245:     ++s->sequence_number;",
          "246: }",
          "249: static int png_write_row(AVCodecContext *avctx, const uint8_t *data, int size)",
          "251:     PNGEncContext *s = avctx->priv_data;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "229:             return -1;",
          "230:         if (s->zstream.avail_out == 0) {",
          "231:             if (s->bytestream_end - s->bytestream > IOBUF_SIZE + 100)",
          "234:             s->zstream.avail_out = IOBUF_SIZE;",
          "235:             s->zstream.next_out  = s->buf;",
          "236:         }",
          "",
          "[Removed Lines]",
          "232:                 png_write_chunk(&s->bytestream,",
          "233:                                 MKTAG('I', 'D', 'A', 'T'), s->buf, IOBUF_SIZE);",
          "",
          "[Added Lines]",
          "262:                 png_write_image_data(avctx, s->buf, IOBUF_SIZE);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "409:                                                ptr, avctx->width);",
          "410:                         crow = png_choose_filter(s, crow_buf, progressive_buf,",
          "411:                                                  top, pass_row_size, s->bits_per_pixel >> 3);",
          "413:                         top = progressive_buf;",
          "414:                     }",
          "415:             }",
          "",
          "[Removed Lines]",
          "412:                         png_write_row(s, crow, pass_row_size + 1);",
          "",
          "[Added Lines]",
          "441:                         png_write_row(avctx, crow, pass_row_size + 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "420:             ptr = p->data[0] + y * p->linesize[0];",
          "421:             crow = png_choose_filter(s, crow_buf, ptr, top,",
          "422:                                      row_size, s->bits_per_pixel >> 3);",
          "424:             top = ptr;",
          "425:         }",
          "426:     }",
          "",
          "[Removed Lines]",
          "423:             png_write_row(s, crow, row_size + 1);",
          "",
          "[Added Lines]",
          "452:             png_write_row(avctx, crow, row_size + 1);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "430:         if (ret == Z_OK || ret == Z_STREAM_END) {",
          "431:             len = IOBUF_SIZE - s->zstream.avail_out;",
          "432:             if (len > 0 && s->bytestream_end - s->bytestream > len + 100) {",
          "434:             }",
          "435:             s->zstream.avail_out = IOBUF_SIZE;",
          "436:             s->zstream.next_out  = s->buf;",
          "",
          "[Removed Lines]",
          "433:                 png_write_chunk(&s->bytestream, MKTAG('I', 'D', 'A', 'T'), s->buf, len);",
          "",
          "[Added Lines]",
          "462:                 png_write_image_data(avctx, s->buf, len);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "452:     return ret;",
          "453: }",
          "457: {",
          "458:     PNGEncContext *s = avctx->priv_data;",
          "459:     int ret;",
          "",
          "[Removed Lines]",
          "455: static int encode(AVCodecContext *avctx, AVPacket *pkt,",
          "456:                   const AVFrame *pict, int *got_packet)",
          "",
          "[Added Lines]",
          "484: static int encode_png(AVCodecContext *avctx, AVPacket *pkt,",
          "485:                       const AVFrame *pict, int *got_packet)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "497:     return 0;",
          "498: }",
          "500: static av_cold int png_enc_init(AVCodecContext *avctx)",
          "501: {",
          "502:     PNGEncContext *s = avctx->priv_data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "529: static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,",
          "530:                        const AVFrame *pict, int *got_packet)",
          "531: {",
          "532:     PNGEncContext *s = avctx->priv_data;",
          "533:     int ret;",
          "534:     int enc_row_size;",
          "535:     size_t max_packet_size;",
          "536:     uint8_t buf[26];",
          "538:     if (avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {",
          "539:         uint32_t checksum = crc32(crc32(0, Z_NULL, 0), pict->data[1], 256 * sizeof(uint32_t));",
          "541:         if (avctx->frame_number == 0) {",
          "542:             s->palette_checksum = checksum;",
          "543:         } else if (checksum != s->palette_checksum) {",
          "544:             av_log(avctx, AV_LOG_ERROR,",
          "545:                    \"Input contains more than one unique palette. APNG does not support multiple palettes.\\n\");",
          "546:             return -1;",
          "547:         }",
          "548:     }",
          "550:     enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3);",
          "551:     max_packet_size =",
          "552:         FF_MIN_BUFFER_SIZE + // headers",
          "553:         avctx->height * (",
          "554:             enc_row_size +",
          "555:             (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) // fdAT * ceil(enc_row_size / IOBUF_SIZE)",
          "556:         );",
          "557:     if (max_packet_size > INT_MAX)",
          "558:         return AVERROR(ENOMEM);",
          "559:     ret = ff_alloc_packet2(avctx, pkt, max_packet_size);",
          "560:     if (ret < 0)",
          "561:         return ret;",
          "563:     s->bytestream_start =",
          "564:     s->bytestream       = pkt->data;",
          "565:     s->bytestream_end   = pkt->data + pkt->size;",
          "567:     if (avctx->frame_number == 0) {",
          "568:         ret = encode_headers(avctx, pict);",
          "569:         if (ret < 0)",
          "570:             return ret;",
          "572:         avctx->extradata = av_malloc(s->bytestream - s->bytestream_start);",
          "573:         if (!avctx->extradata)",
          "574:             return AVERROR(ENOMEM);",
          "575:         avctx->extradata_size = s->bytestream - s->bytestream_start;",
          "576:         memcpy(avctx->extradata, s->bytestream_start, s->bytestream - s->bytestream_start);",
          "578:         s->bytestream = s->bytestream_start;",
          "579:     }",
          "581:     AV_WB32(buf, s->sequence_number);",
          "582:     AV_WB32(buf + 4, avctx->width);",
          "583:     AV_WB32(buf + 8, avctx->height);",
          "584:     AV_WB32(buf + 12, 0); // x offset",
          "585:     AV_WB32(buf + 16, 0); // y offset",
          "586:     AV_WB16(buf + 20, 0); // delay numerator (filled in during muxing)",
          "587:     AV_WB16(buf + 22, 0); // delay denominator",
          "588:     buf[24] = APNG_DISPOSE_OP_BACKGROUND;",
          "589:     buf[25] = APNG_BLEND_OP_SOURCE;",
          "590:     png_write_chunk(&s->bytestream, MKTAG('f', 'c', 'T', 'L'), buf, 26);",
          "591:     ++s->sequence_number;",
          "593:     ret = encode_frame(avctx, pict);",
          "594:     if (ret < 0)",
          "595:         return ret;",
          "597:     pkt->size = s->bytestream - s->bytestream_start;",
          "598:     pkt->flags |= AV_PKT_FLAG_KEY;",
          "601:     return 0;",
          "602: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "624:     .version    = LIBAVUTIL_VERSION_INT,",
          "625: };",
          "627: AVCodec ff_png_encoder = {",
          "628:     .name           = \"png\",",
          "629:     .long_name      = NULL_IF_CONFIG_SMALL(\"PNG (Portable Network Graphics) image\"),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "731: static const AVClass apngenc_class = {",
          "732:     .class_name = \"APNG encoder\",",
          "733:     .item_name  = av_default_item_name,",
          "734:     .option     = options,",
          "735:     .version    = LIBAVUTIL_VERSION_INT,",
          "736: };",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "632:     .priv_data_size = sizeof(PNGEncContext),",
          "633:     .init           = png_enc_init,",
          "634:     .close          = png_enc_close,",
          "636:     .capabilities   = CODEC_CAP_FRAME_THREADS | CODEC_CAP_INTRA_ONLY,",
          "637:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "638:         AV_PIX_FMT_RGB24, AV_PIX_FMT_RGBA,",
          "",
          "[Removed Lines]",
          "635:     .encode2        = encode,",
          "",
          "[Added Lines]",
          "746:     .encode2        = encode_png,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "644:     },",
          "645:     .priv_class     = &pngenc_class,",
          "646: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "759: AVCodec ff_apng_encoder = {",
          "760:     .name           = \"apng\",",
          "761:     .long_name      = NULL_IF_CONFIG_SMALL(\"APNG (Animated Portable Network Graphics) image\"),",
          "762:     .type           = AVMEDIA_TYPE_VIDEO,",
          "763:     .id             = AV_CODEC_ID_APNG,",
          "764:     .priv_data_size = sizeof(PNGEncContext),",
          "765:     .init           = png_enc_init,",
          "766:     .close          = png_enc_close,",
          "767:     .encode2        = encode_apng,",
          "768:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "769:         AV_PIX_FMT_RGB24, AV_PIX_FMT_RGBA,",
          "770:         AV_PIX_FMT_RGB48BE, AV_PIX_FMT_RGBA64BE,",
          "771:         AV_PIX_FMT_PAL8,",
          "772:         AV_PIX_FMT_GRAY8, AV_PIX_FMT_GRAY8A,",
          "773:         AV_PIX_FMT_GRAY16BE, AV_PIX_FMT_YA16BE,",
          "774:         AV_PIX_FMT_MONOBLACK, AV_PIX_FMT_NONE",
          "775:     },",
          "776:     .priv_class     = &apngenc_class,",
          "777: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "51ca70322296f59666dda6c59bfa35ff9bf17dd5",
      "candidate_info": {
        "commit_hash": "51ca70322296f59666dda6c59bfa35ff9bf17dd5",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/51ca70322296f59666dda6c59bfa35ff9bf17dd5",
        "files": [
          "libavcodec/pngenc.c"
        ],
        "message": "apng: Support inter-frame compression\n\nThe current algorithm is just \"try all the combinations, and pick the best\".\nIt's not very fast either, probably due to a lot of copying, but will do for\nan initial implementation.\n\nSigned-off-by: Donny Yang <work@kota.moe>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/pngenc.c||libavcodec/pngenc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ],
          "candidate": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/pngenc.c||libavcodec/pngenc.c": [
          "File: libavcodec/pngenc.c -> libavcodec/pngenc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define IOBUF_SIZE 4096",
          "39: typedef struct PNGEncContext {",
          "40:     AVClass *class;",
          "41:     HuffYUVEncDSPContext hdsp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: typedef struct APNGFctlChunk {",
          "40:     uint32_t sequence_number;",
          "41:     uint32_t width, height;",
          "42:     uint32_t x_offset, y_offset;",
          "43:     uint16_t delay_num, delay_den;",
          "44:     uint8_t dispose_op, blend_op;",
          "45: } APNGFctlChunk;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:     uint32_t palette_checksum;   // Used to ensure a single unique palette",
          "61:     uint32_t sequence_number;",
          "62: } PNGEncContext;",
          "64: static void png_get_interlaced_row(uint8_t *dst, int row_size,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71:     AVFrame *prev_frame;",
          "72:     AVFrame *last_frame;",
          "73:     APNGFctlChunk last_frame_fctl;",
          "74:     uint8_t *last_frame_packet;",
          "75:     size_t last_frame_packet_size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "403:     uint8_t *progressive_buf = NULL;",
          "404:     uint8_t *top_buf         = NULL;",
          "408:     crow_base = av_malloc((row_size + 32) << (s->filter_type == PNG_FILTER_VALUE_MIXED));",
          "409:     if (!crow_base) {",
          "",
          "[Removed Lines]",
          "406:     row_size = (avctx->width * s->bits_per_pixel + 7) >> 3;",
          "",
          "[Added Lines]",
          "420:     row_size = (pict->width * s->bits_per_pixel + 7) >> 3;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "430:         for (pass = 0; pass < NB_PASSES; pass++) {",
          "434:             if (pass_row_size > 0) {",
          "435:                 top = NULL;",
          "437:                     if ((ff_png_pass_ymask[pass] << (y & 7)) & 0x80) {",
          "438:                         ptr = p->data[0] + y * p->linesize[0];",
          "439:                         FFSWAP(uint8_t *, progressive_buf, top_buf);",
          "440:                         png_get_interlaced_row(progressive_buf, pass_row_size,",
          "441:                                                s->bits_per_pixel, pass,",
          "443:                         crow = png_choose_filter(s, crow_buf, progressive_buf,",
          "444:                                                  top, pass_row_size, s->bits_per_pixel >> 3);",
          "445:                         png_write_row(avctx, crow, pass_row_size + 1);",
          "",
          "[Removed Lines]",
          "433:             pass_row_size = ff_png_pass_row_size(pass, s->bits_per_pixel, avctx->width);",
          "436:                 for (y = 0; y < avctx->height; y++)",
          "442:                                                ptr, avctx->width);",
          "",
          "[Added Lines]",
          "447:             pass_row_size = ff_png_pass_row_size(pass, s->bits_per_pixel, pict->width);",
          "450:                 for (y = 0; y < pict->height; y++)",
          "456:                                                ptr, pict->width);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "449:         }",
          "450:     } else {",
          "451:         top = NULL;",
          "453:             ptr = p->data[0] + y * p->linesize[0];",
          "454:             crow = png_choose_filter(s, crow_buf, ptr, top,",
          "455:                                      row_size, s->bits_per_pixel >> 3);",
          "",
          "[Removed Lines]",
          "452:         for (y = 0; y < avctx->height; y++) {",
          "",
          "[Added Lines]",
          "466:         for (y = 0; y < pict->height; y++) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "530:     return 0;",
          "531: }",
          "533: static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,",
          "534:                        const AVFrame *pict, int *got_packet)",
          "535: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "547: static int apng_do_inverse_blend(AVFrame *output, const AVFrame *input,",
          "548:                                   APNGFctlChunk *fctl_chunk, uint8_t bpp)",
          "549: {",
          "553:     unsigned int x, y;",
          "554:     unsigned int leftmost_x = input->width;",
          "555:     unsigned int rightmost_x = 0;",
          "556:     unsigned int topmost_y = input->height;",
          "557:     unsigned int bottommost_y = 0;",
          "558:     const uint8_t *input_data = input->data[0];",
          "559:     uint8_t *output_data = output->data[0];",
          "560:     ptrdiff_t input_linesize = input->linesize[0];",
          "561:     ptrdiff_t output_linesize = output->linesize[0];",
          "564:     for (y = 0; y < input->height; ++y) {",
          "565:         for (x = 0; x < input->width; ++x) {",
          "566:             if (!memcmp(input_data + bpp * x, output_data + bpp * x, bpp))",
          "567:                 continue;",
          "569:             if (x < leftmost_x)",
          "570:                 leftmost_x = x;",
          "571:             if (x >= rightmost_x)",
          "572:                 rightmost_x = x + 1;",
          "573:             if (y < topmost_y)",
          "574:                 topmost_y = y;",
          "575:             if (y >= bottommost_y)",
          "576:                 bottommost_y = y + 1;",
          "577:         }",
          "579:         input_data += input_linesize;",
          "580:         output_data += output_linesize;",
          "581:     }",
          "583:     if (leftmost_x == input->width && rightmost_x == 0) {",
          "586:         leftmost_x = topmost_y = 0;",
          "587:         rightmost_x = bottommost_y = 1;",
          "588:     }",
          "591:     if (fctl_chunk->blend_op == APNG_BLEND_OP_SOURCE) {",
          "592:         output_data = output->data[0];",
          "593:         for (y = topmost_y; y < bottommost_y; ++y) {",
          "594:             memcpy(output_data,",
          "595:                    input->data[0] + input_linesize * y + bpp * leftmost_x,",
          "596:                    bpp * (rightmost_x - leftmost_x));",
          "597:             output_data += output_linesize;",
          "598:         }",
          "599:     } else { // APNG_BLEND_OP_OVER",
          "600:         size_t transparent_palette_index;",
          "601:         uint32_t *palette;",
          "603:         switch (input->format) {",
          "604:         case AV_PIX_FMT_RGBA64BE:",
          "605:         case AV_PIX_FMT_YA16BE:",
          "606:         case AV_PIX_FMT_RGBA:",
          "607:         case AV_PIX_FMT_GRAY8A:",
          "608:             break;",
          "610:         case AV_PIX_FMT_PAL8:",
          "611:             palette = (uint32_t*)input->data[1];",
          "612:             for (transparent_palette_index = 0; transparent_palette_index < 256; ++transparent_palette_index)",
          "613:                 if (palette[transparent_palette_index] >> 24 == 0)",
          "614:                     break;",
          "615:             break;",
          "617:         default:",
          "619:             return -1;",
          "620:         }",
          "622:         for (y = topmost_y; y < bottommost_y; ++y) {",
          "623:             uint8_t *foreground = input->data[0] + input_linesize * y + bpp * leftmost_x;",
          "624:             uint8_t *background = output->data[0] + output_linesize * y + bpp * leftmost_x;",
          "625:             output_data = output->data[0] + output_linesize * (y - topmost_y);",
          "626:             for (x = leftmost_x; x < rightmost_x; ++x, foreground += bpp, background += bpp, output_data += bpp) {",
          "627:                 if (!memcmp(foreground, background, bpp)) {",
          "628:                     if (input->format == AV_PIX_FMT_PAL8) {",
          "629:                         if (transparent_palette_index == 256) {",
          "631:                             return -1;",
          "632:                         }",
          "635:                     } else {",
          "636:                         memset(output_data, 0, bpp);",
          "637:                     }",
          "638:                     continue;",
          "639:                 }",
          "645:                 switch (input->format) {",
          "646:                 case AV_PIX_FMT_RGBA64BE:",
          "647:                     if (((uint16_t*)foreground)[3] == 0xffff ||",
          "648:                         ((uint16_t*)background)[3] == 0)",
          "649:                         break;",
          "650:                     return -1;",
          "652:                 case AV_PIX_FMT_YA16BE:",
          "653:                     if (((uint16_t*)foreground)[1] == 0xffff ||",
          "654:                         ((uint16_t*)background)[1] == 0)",
          "655:                         break;",
          "656:                     return -1;",
          "658:                 case AV_PIX_FMT_RGBA:",
          "659:                     if (foreground[3] == 0xff || background[3] == 0)",
          "660:                         break;",
          "661:                     return -1;",
          "663:                 case AV_PIX_FMT_GRAY8A:",
          "664:                     if (foreground[1] == 0xff || background[1] == 0)",
          "665:                         break;",
          "666:                     return -1;",
          "668:                 case AV_PIX_FMT_PAL8:",
          "669:                     if (palette[*foreground] >> 24 == 0xff ||",
          "670:                         palette[*background] >> 24 == 0)",
          "671:                         break;",
          "672:                     return -1;",
          "673:                 }",
          "675:                 memmove(output_data, foreground, bpp);",
          "676:             }",
          "677:         }",
          "678:     }",
          "680:     output->width = rightmost_x - leftmost_x;",
          "681:     output->height = bottommost_y - topmost_y;",
          "682:     fctl_chunk->width = output->width;",
          "683:     fctl_chunk->height = output->height;",
          "684:     fctl_chunk->x_offset = leftmost_x;",
          "685:     fctl_chunk->y_offset = topmost_y;",
          "687:     return 0;",
          "688: }",
          "690: static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,",
          "691:                              APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk)",
          "692: {",
          "693:     PNGEncContext *s = avctx->priv_data;",
          "694:     int ret;",
          "695:     unsigned int y;",
          "696:     AVFrame* diffFrame;",
          "697:     uint8_t bpp = (s->bits_per_pixel + 7) >> 3;",
          "698:     uint8_t *original_bytestream, *original_bytestream_end;",
          "699:     uint8_t *temp_bytestream = 0, *temp_bytestream_end;",
          "700:     uint32_t best_sequence_number;",
          "701:     uint8_t *best_bytestream;",
          "702:     size_t best_bytestream_size = SIZE_MAX;",
          "703:     APNGFctlChunk last_fctl_chunk = *best_last_fctl_chunk;",
          "704:     APNGFctlChunk fctl_chunk = *best_fctl_chunk;",
          "706:     if (avctx->frame_number == 0) {",
          "707:         best_fctl_chunk->width = pict->width;",
          "708:         best_fctl_chunk->height = pict->height;",
          "709:         best_fctl_chunk->x_offset = 0;",
          "710:         best_fctl_chunk->y_offset = 0;",
          "711:         best_fctl_chunk->blend_op = APNG_BLEND_OP_SOURCE;",
          "712:         return encode_frame(avctx, pict);",
          "713:     }",
          "715:     diffFrame = av_frame_alloc();",
          "716:     if (!diffFrame)",
          "717:         return AVERROR(ENOMEM);",
          "719:     diffFrame->format = pict->format;",
          "720:     diffFrame->width = pict->width;",
          "721:     diffFrame->height = pict->height;",
          "722:     if ((ret = av_frame_get_buffer(diffFrame, 32)) < 0)",
          "723:         goto fail;",
          "725:     original_bytestream = s->bytestream;",
          "726:     original_bytestream_end = s->bytestream_end;",
          "728:     temp_bytestream = av_malloc(original_bytestream_end - original_bytestream);",
          "729:     temp_bytestream_end = temp_bytestream + (original_bytestream_end - original_bytestream);",
          "730:     if (!temp_bytestream) {",
          "731:         ret = AVERROR(ENOMEM);",
          "732:         goto fail;",
          "733:     }",
          "735:     for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) {",
          "740:         for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) {",
          "744:             uint32_t original_sequence_number = s->sequence_number, sequence_number;",
          "745:             uint8_t *bytestream_start = s->bytestream;",
          "746:             size_t bytestream_size;",
          "749:             if (last_fctl_chunk.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {",
          "750:                 memcpy(diffFrame->data[0], s->last_frame->data[0],",
          "751:                        s->last_frame->linesize[0] * s->last_frame->height);",
          "753:                 if (last_fctl_chunk.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {",
          "754:                     for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) {",
          "755:                         size_t row_start = s->last_frame->linesize[0] * y + bpp * last_fctl_chunk.x_offset;",
          "756:                         memset(diffFrame->data[0] + row_start, 0, bpp * last_fctl_chunk.width);",
          "757:                     }",
          "758:                 }",
          "759:             } else {",
          "760:                 if (!s->prev_frame)",
          "761:                     continue;",
          "763:                 memcpy(diffFrame->data[0], s->prev_frame->data[0],",
          "764:                        s->prev_frame->linesize[0] * s->prev_frame->height);",
          "765:             }",
          "768:             if (apng_do_inverse_blend(diffFrame, pict, &fctl_chunk, bpp) < 0)",
          "769:                 continue;",
          "772:             ret = encode_frame(avctx, diffFrame);",
          "773:             sequence_number = s->sequence_number;",
          "774:             s->sequence_number = original_sequence_number;",
          "775:             bytestream_size = s->bytestream - bytestream_start;",
          "776:             s->bytestream = bytestream_start;",
          "777:             if (ret < 0)",
          "778:                 goto fail;",
          "780:             if (bytestream_size < best_bytestream_size) {",
          "784:                 best_sequence_number = sequence_number;",
          "785:                 best_bytestream = s->bytestream;",
          "786:                 best_bytestream_size = bytestream_size;",
          "788:                 if (best_bytestream == original_bytestream) {",
          "789:                     s->bytestream = temp_bytestream;",
          "790:                     s->bytestream_end = temp_bytestream_end;",
          "791:                 } else {",
          "792:                     s->bytestream = original_bytestream;",
          "793:                     s->bytestream_end = original_bytestream_end;",
          "794:                 }",
          "795:             }",
          "796:         }",
          "797:     }",
          "799:     s->sequence_number = best_sequence_number;",
          "800:     s->bytestream = original_bytestream + best_bytestream_size;",
          "801:     s->bytestream_end = original_bytestream_end;",
          "802:     if (best_bytestream != original_bytestream)",
          "803:         memcpy(original_bytestream, best_bytestream, best_bytestream_size);",
          "805:     ret = 0;",
          "807: fail:",
          "808:     av_freep(&temp_bytestream);",
          "809:     av_frame_free(&diffFrame);",
          "810:     return ret;",
          "811: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "537:     int ret;",
          "538:     int enc_row_size;",
          "539:     size_t max_packet_size;",
          "543:         uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t));",
          "545:         if (avctx->frame_number == 0) {",
          "",
          "[Removed Lines]",
          "540:     uint8_t buf[26];",
          "542:     if (avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {",
          "",
          "[Added Lines]",
          "820:     APNGFctlChunk fctl_chunk;",
          "822:     if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "560:         );",
          "561:     if (max_packet_size > INT_MAX)",
          "562:         return AVERROR(ENOMEM);",
          "571:     if (avctx->frame_number == 0) {",
          "572:         ret = encode_headers(avctx, pict);",
          "573:         if (ret < 0)",
          "574:             return ret;",
          "578:             return AVERROR(ENOMEM);",
          "583:     }",
          "605:     return 0;",
          "606: }",
          "",
          "[Removed Lines]",
          "563:     ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);",
          "564:     if (ret < 0)",
          "565:         return ret;",
          "567:     s->bytestream_start =",
          "568:     s->bytestream       = pkt->data;",
          "569:     s->bytestream_end   = pkt->data + pkt->size;",
          "576:         avctx->extradata = av_malloc(s->bytestream - s->bytestream_start);",
          "577:         if (!avctx->extradata)",
          "579:         avctx->extradata_size = s->bytestream - s->bytestream_start;",
          "580:         memcpy(avctx->extradata, s->bytestream_start, s->bytestream - s->bytestream_start);",
          "582:         s->bytestream = s->bytestream_start;",
          "585:     AV_WB32(buf, s->sequence_number);",
          "586:     AV_WB32(buf + 4, avctx->width);",
          "587:     AV_WB32(buf + 8, avctx->height);",
          "588:     AV_WB32(buf + 12, 0); // x offset",
          "589:     AV_WB32(buf + 16, 0); // y offset",
          "590:     AV_WB16(buf + 20, 0); // delay numerator (filled in during muxing)",
          "591:     AV_WB16(buf + 22, 0); // delay denominator",
          "592:     buf[24] = APNG_DISPOSE_OP_BACKGROUND;",
          "593:     buf[25] = APNG_BLEND_OP_SOURCE;",
          "594:     png_write_chunk(&s->bytestream, MKTAG('f', 'c', 'T', 'L'), buf, 26);",
          "595:     ++s->sequence_number;",
          "597:     ret = encode_frame(avctx, pict);",
          "598:     if (ret < 0)",
          "599:         return ret;",
          "601:     pkt->size = s->bytestream - s->bytestream_start;",
          "602:     pkt->flags |= AV_PKT_FLAG_KEY;",
          "",
          "[Added Lines]",
          "845:         s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE);",
          "846:         if (!avctx->extradata)",
          "847:             return AVERROR(ENOMEM);",
          "853:         avctx->extradata_size = s->bytestream - avctx->extradata;",
          "855:         s->last_frame_packet = av_malloc(max_packet_size);",
          "856:         if (!s->last_frame_packet)",
          "858:     } else if (s->last_frame) {",
          "859:         ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);",
          "860:         if (ret < 0)",
          "861:             return ret;",
          "863:         memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);",
          "864:         pkt->size = s->last_frame_packet_size;",
          "865:         pkt->pts = pkt->dts = s->last_frame->pts;",
          "868:     if (pict) {",
          "869:         s->bytestream_start =",
          "870:         s->bytestream       = s->last_frame_packet;",
          "871:         s->bytestream_end   = s->bytestream + max_packet_size;",
          "875:         fctl_chunk.sequence_number = s->sequence_number;",
          "876:         ++s->sequence_number;",
          "877:         s->bytestream += 26 + 12;",
          "879:         ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl);",
          "880:         if (ret < 0)",
          "881:             return ret;",
          "883:         fctl_chunk.delay_num = 0; // delay filled in during muxing",
          "884:         fctl_chunk.delay_den = 0;",
          "885:     } else {",
          "886:         s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE;",
          "887:     }",
          "889:     if (s->last_frame) {",
          "890:         uint8_t* last_fctl_chunk_start = pkt->data;",
          "891:         uint8_t buf[26];",
          "893:         AV_WB32(buf + 0, s->last_frame_fctl.sequence_number);",
          "894:         AV_WB32(buf + 4, s->last_frame_fctl.width);",
          "895:         AV_WB32(buf + 8, s->last_frame_fctl.height);",
          "896:         AV_WB32(buf + 12, s->last_frame_fctl.x_offset);",
          "897:         AV_WB32(buf + 16, s->last_frame_fctl.y_offset);",
          "898:         AV_WB16(buf + 20, s->last_frame_fctl.delay_num);",
          "899:         AV_WB16(buf + 22, s->last_frame_fctl.delay_den);",
          "900:         buf[24] = s->last_frame_fctl.dispose_op;",
          "901:         buf[25] = s->last_frame_fctl.blend_op;",
          "902:         png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26);",
          "905:     }",
          "907:     if (pict) {",
          "908:         if (!s->last_frame) {",
          "909:             s->last_frame = av_frame_alloc();",
          "910:             if (!s->last_frame)",
          "911:                 return AVERROR(ENOMEM);",
          "912:         } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {",
          "913:             if (!s->prev_frame) {",
          "914:                 s->prev_frame = av_frame_alloc();",
          "915:                 if (!s->prev_frame)",
          "916:                     return AVERROR(ENOMEM);",
          "918:                 s->prev_frame->format = pict->format;",
          "919:                 s->prev_frame->width = pict->width;",
          "920:                 s->prev_frame->height = pict->height;",
          "921:                 if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)",
          "922:                     return ret;",
          "923:             }",
          "926:             memcpy(s->prev_frame->data[0], s->last_frame->data[0],",
          "927:                    s->last_frame->linesize[0] * s->last_frame->height);",
          "928:             if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {",
          "929:                 uint32_t y;",
          "930:                 uint8_t bpp = (s->bits_per_pixel + 7) >> 3;",
          "931:                 for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {",
          "932:                     size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;",
          "933:                     memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);",
          "934:                 }",
          "935:             }",
          "936:         }",
          "938:         av_frame_unref(s->last_frame);",
          "939:         ret = av_frame_ref(s->last_frame, (AVFrame*)pict);",
          "940:         if (ret < 0)",
          "941:             return ret;",
          "943:         s->last_frame_fctl = fctl_chunk;",
          "944:         s->last_frame_packet_size = s->bytestream - s->bytestream_start;",
          "945:     } else {",
          "946:         av_frame_free(&s->last_frame);",
          "947:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "713:     PNGEncContext *s = avctx->priv_data;",
          "715:     deflateEnd(&s->zstream);",
          "716:     return 0;",
          "717: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1060:     av_frame_free(&s->last_frame);",
          "1061:     av_frame_free(&s->prev_frame);",
          "1062:     av_freep(&s->last_frame_packet);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "768:     .init           = png_enc_init,",
          "769:     .close          = png_enc_close,",
          "770:     .encode2        = encode_apng,",
          "771:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "772:         AV_PIX_FMT_RGB24, AV_PIX_FMT_RGBA,",
          "773:         AV_PIX_FMT_RGB48BE, AV_PIX_FMT_RGBA64BE,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1118:     .capabilities   = CODEC_CAP_DELAY,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1490682bcb0fe359e05b85bb7198bb87be686054",
      "candidate_info": {
        "commit_hash": "1490682bcb0fe359e05b85bb7198bb87be686054",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/1490682bcb0fe359e05b85bb7198bb87be686054",
        "files": [
          "libavcodec/pngenc.c"
        ],
        "message": "avcodec/pngenc: check return value of av_frame_copy()\n\nSigned-off-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavcodec/pngenc.c||libavcodec/pngenc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ],
          "candidate": [
            "libavcodec/pngenc.c||libavcodec/pngenc.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/pngenc.c||libavcodec/pngenc.c": [
          "File: libavcodec/pngenc.c -> libavcodec/pngenc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "768:             if (last_fctl_chunk.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {",
          "769:                 diffFrame->width = pict->width;",
          "770:                 diffFrame->height = pict->height;",
          "773:                 if (last_fctl_chunk.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {",
          "774:                     for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) {",
          "",
          "[Removed Lines]",
          "771:                 av_frame_copy(diffFrame, s->last_frame);",
          "",
          "[Added Lines]",
          "771:                 ret = av_frame_copy(diffFrame, s->last_frame);",
          "772:                 if (ret < 0)",
          "773:                     goto fail;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "783:                 diffFrame->width = pict->width;",
          "784:                 diffFrame->height = pict->height;",
          "786:             }",
          "",
          "[Removed Lines]",
          "785:                 av_frame_copy(diffFrame, s->prev_frame);",
          "",
          "[Added Lines]",
          "787:                 ret = av_frame_copy(diffFrame, s->prev_frame);",
          "788:                 if (ret < 0)",
          "789:                     goto fail;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "49b0572302bd0117210dff47021077b72e8829a9",
      "candidate_info": {
        "commit_hash": "49b0572302bd0117210dff47021077b72e8829a9",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/49b0572302bd0117210dff47021077b72e8829a9",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/msvc.h"
        ],
        "message": "Fix for 8-byte alignment asserts that can trigger in some circumstances with 32-bit MSVC.\n\nFossilOrigin-Name: 4c02832e0c4351ced9d2391f09ee071c65a74b85a0509bf58f045afeb166f48c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/msvc.h||src/msvc.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 930842470da27d72650033ef2c1df413e70f7c40eb46f91027b35f5ee156af38",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/msvc.h||src/msvc.h": [
          "File: src/msvc.h -> src/msvc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #pragma warning(disable : 4706)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: #if !defined(_WIN64)",
          "37: #undef SQLITE_4_BYTE_ALIGNED_MALLOC",
          "38: #define SQLITE_4_BYTE_ALIGNED_MALLOC",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "06baba54b4d097113e8a425010d31f044df57f4b",
      "candidate_info": {
        "commit_hash": "06baba54b4d097113e8a425010d31f044df57f4b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/06baba54b4d097113e8a425010d31f044df57f4b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c",
          "src/vdbe.h",
          "src/vdbeaux.c",
          "test/trigger1.test"
        ],
        "message": "Correction to check-in [bec5b6d4d083556d] so that it detects *all* triggers that might perturb the insertion cursor. Ticket [50c09fc2cf0d91ce].\n\nFossilOrigin-Name: 521f1d36282549488a47a434484a24924ee970d29f05a8ae499b7d536bcd692b",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c",
          "src/vdbe.h||src/vdbe.h",
          "src/vdbeaux.c||src/vdbeaux.c",
          "test/trigger1.test||test/trigger1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1a6e009372cf9571e540812c8607e95a86740112a1091f03e3f632339eccb629",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1064:       sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur,",
          "1065:           regIns, aRegIdx, 0, appendFlag, bUseSeek",
          "1066:       );",
          "",
          "[Removed Lines]",
          "1061:       bUseSeek = (isReplace==0 || (pTrigger==0 &&",
          "1062:           ((db->flags & SQLITE_ForeignKeys)==0 || sqlite3FkReferences(pTab)==0)",
          "1063:       ));",
          "",
          "[Added Lines]",
          "1061:       bUseSeek = (isReplace==0 || !sqlite3VdbeHasSubProgram(v));",
          "",
          "---------------"
        ],
        "src/vdbe.h||src/vdbe.h": [
          "File: src/vdbe.h -> src/vdbe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "278: typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);",
          "279: RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);",
          "282: void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);",
          "285: int sqlite3NotPureFunc(sqlite3_context*);",
          "",
          "[Removed Lines]",
          "281: #ifndef SQLITE_OMIT_TRIGGER",
          "283: #endif",
          "",
          "[Added Lines]",
          "282: int sqlite3VdbeHasSubProgram(Vdbe*);",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1098:   pVdbe->pProgram = p;",
          "1099: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1104: int sqlite3VdbeHasSubProgram(Vdbe *pVdbe){",
          "1105:   return pVdbe->pProgram!=0;",
          "1106: }",
          "",
          "---------------"
        ],
        "test/trigger1.test||test/trigger1.test": [
          "File: test/trigger1.test -> test/trigger1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "782:   DROP TRIGGER r20_3;",
          "783: } {}",
          "785: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "785: # 2019-10-24 ticket 50c09fc2cf0d91ce",
          "786: #",
          "787: db close",
          "788: sqlite3 db :memory:",
          "789: do_execsql_test trigger1-21.1 {",
          "790:   PRAGMA recursive_triggers = true;",
          "791:   CREATE TABLE t0(a, b, c UNIQUE);",
          "792:   CREATE UNIQUE INDEX i0 ON t0(b) WHERE a;",
          "793:   CREATE TRIGGER tr0 AFTER DELETE ON t0 BEGIN",
          "794:     DELETE FROM t0;",
          "795:   END;",
          "796:   INSERT INTO t0(a,b,c) VALUES(0,0,9),(1,1,1);",
          "797:   REPLACE INTO t0(a,b,c) VALUES(2,0,9);",
          "798:   SELECT * FROM t0;",
          "799: } {2 0 9}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8117f113bc0468d4c955ffa3f04cea26a39a3bd3",
      "candidate_info": {
        "commit_hash": "8117f113bc0468d4c955ffa3f04cea26a39a3bd3",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/8117f113bc0468d4c955ffa3f04cea26a39a3bd3",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/resolve.c",
          "src/walker.c"
        ],
        "message": "Minor performance improvement in sqlite3ExprDeleteNN().\n\nFossilOrigin-Name: bcc8b38ac75b731a4cd2873ab83f423be036467a511b617c779869de9bbb5383",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/resolve.c||src/resolve.c",
          "src/walker.c||src/walker.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7a1e30a17f57ca006dd84b6f97b0c7811bf4c6da4b02903452ffc4bc363cab9b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1040:     assert( p->x.pList==0 || p->pRight==0 );",
          "1041:     if( p->pLeft && p->op!=TK_SELECT_COLUMN ) sqlite3ExprDeleteNN(db, p->pLeft);",
          "1042:     if( p->pRight ){",
          "1043:       sqlite3ExprDeleteNN(db, p->pRight);",
          "1044:     }else if( ExprHasProperty(p, EP_xIsSelect) ){",
          "1045:       sqlite3SelectDelete(db, p->x.pSelect);",
          "1046:     }else{",
          "1047:       sqlite3ExprListDelete(db, p->x.pList);",
          "1049: #ifndef SQLITE_OMIT_WINDOWFUNC",
          "1057: #endif",
          "1058:   }",
          "1059:   if( ExprHasProperty(p, EP_MemToken) ) sqlite3DbFree(db, p->u.zToken);",
          "1060:   if( !ExprHasProperty(p, EP_Static) ){",
          "",
          "[Removed Lines]",
          "1048:     }",
          "1050:     if( ExprHasProperty(p, EP_WinFunc) ){",
          "1051:       assert( p->op==TK_FUNCTION && !ExprHasProperty(p, EP_Filter) );",
          "1052:       sqlite3WindowDelete(db, p->y.pWin);",
          "1053:     }else if( ExprHasProperty(p, EP_Filter) ){",
          "1054:       assert( p->op==TK_FUNCTION || p->op==TK_AGG_FUNCTION );",
          "1055:       sqlite3ExprDelete(db, p->y.pFilter);",
          "1056:     }",
          "",
          "[Added Lines]",
          "1043:       assert( !ExprHasProperty(p, (EP_WinFunc|EP_Filter)) );",
          "1046:       assert( !ExprHasProperty(p, (EP_WinFunc|EP_Filter)) );",
          "1051:       if( ExprHasProperty(p, (EP_WinFunc|EP_Filter)) ){",
          "1052:         if( ExprHasProperty(p, EP_WinFunc) ){",
          "1053:           assert( p->op==TK_FUNCTION && !ExprHasProperty(p, EP_Filter) );",
          "1054:           sqlite3WindowDelete(db, p->y.pWin);",
          "1055:         }else{",
          "1056:           assert( p->op==TK_FUNCTION || p->op==TK_AGG_FUNCTION );",
          "1057:           sqlite3ExprDeleteNN(db, p->y.pFilter);",
          "1058:         }",
          "1059:       }",
          "1061:     }",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "827:       if( 0==IN_RENAME_OBJECT ){",
          "828: #ifndef SQLITE_OMIT_WINDOWFUNC",
          "830:         assert( is_agg==0 || (pDef->funcFlags & SQLITE_FUNC_MINMAX)",
          "831:           || (pDef->xValue==0 && pDef->xInverse==0)",
          "832:           || (pDef->xValue && pDef->xInverse && pDef->xSFunc && pDef->xFinalize)",
          "833:         );",
          "835:           sqlite3ErrorMsg(pParse,",
          "836:               \"%.*s() may not be used as a window function\", nId, zId",
          "837:           );",
          "838:           pNC->nErr++;",
          "839:         }else if(",
          "840:               (is_agg && (pNC->ncFlags & NC_AllowAgg)==0)",
          "843:         ){",
          "844:           const char *zType;",
          "846:             zType = \"window\";",
          "847:           }else{",
          "848:             zType = \"aggregate\";",
          "",
          "[Removed Lines]",
          "829:         int is_win = ExprHasProperty(pExpr, EP_WinFunc);",
          "834:         if( pDef && pDef->xValue==0 && is_win ){",
          "841:            || (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !is_win)",
          "842:            || (is_agg && is_win && (pNC->ncFlags & NC_AllowWin)==0)",
          "845:           if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || is_win ){",
          "",
          "[Added Lines]",
          "829:         Window *pWin = (ExprHasProperty(pExpr, EP_WinFunc) ? pExpr->y.pWin : 0);",
          "834:         if( pDef && pDef->xValue==0 && pWin ){",
          "841:            || (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !pWin)",
          "842:            || (is_agg && pWin && (pNC->ncFlags & NC_AllowWin)==0)",
          "845:           if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || pWin ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "883: #ifndef SQLITE_OMIT_WINDOWFUNC",
          "885: #else",
          "886:           pNC->ncFlags &= ~NC_AllowAgg;",
          "887: #endif",
          "",
          "[Removed Lines]",
          "884:           pNC->ncFlags &= ~(NC_AllowWin | (!is_win ? NC_AllowAgg : 0));",
          "",
          "[Added Lines]",
          "884:           pNC->ncFlags &= ~(NC_AllowWin | (!pWin ? NC_AllowAgg : 0));",
          "",
          "---------------"
        ],
        "src/walker.c||src/walker.c": [
          "File: src/walker.c -> src/walker.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:       if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;",
          "64:        assert( pExpr->x.pList==0 || pExpr->pRight==0 );",
          "65:       if( pExpr->pRight ){",
          "66:         pExpr = pExpr->pRight;",
          "67:         continue;",
          "68:       }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "69:         if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return WRC_Abort;",
          "73: #ifndef SQLITE_OMIT_WINDOWFUNC",
          "80: #endif",
          "81:     }",
          "82:     break;",
          "83:   }",
          "",
          "[Removed Lines]",
          "70:       }else if( pExpr->x.pList ){",
          "71:         if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;",
          "72:       }",
          "74:       if( ExprHasProperty(pExpr, EP_WinFunc) ){",
          "75:         if( walkWindowList(pWalker, pExpr->y.pWin) ) return WRC_Abort;",
          "76:       }",
          "77:       if( ExprHasProperty(pExpr, EP_Filter) ){",
          "78:         if( walkExpr(pWalker, pExpr->y.pFilter) ) return WRC_Abort;",
          "79:       }",
          "",
          "[Added Lines]",
          "66:         assert( !ExprHasProperty(pExpr, EP_WinFunc|EP_Filter) );",
          "70:         assert( !ExprHasProperty(pExpr, EP_WinFunc|EP_Filter) );",
          "72:       }else{",
          "73:         if( pExpr->x.pList ){",
          "74:           if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;",
          "75:         }",
          "77:         if( ExprHasProperty(pExpr, EP_WinFunc|EP_Filter) ){",
          "78:           if( ExprHasProperty(pExpr, EP_WinFunc) ){",
          "79:             if( walkWindowList(pWalker, pExpr->y.pWin) ) return WRC_Abort;",
          "80:           }else if( ExprHasProperty(pExpr, EP_Filter) ){",
          "81:             if( walkExpr(pWalker, pExpr->y.pFilter) ) return WRC_Abort;",
          "82:           }",
          "83:         }",
          "85:       }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "73c0d272a9bdb8e43394d62d14f0c7c8843fadfa",
      "candidate_info": {
        "commit_hash": "73c0d272a9bdb8e43394d62d14f0c7c8843fadfa",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/73c0d272a9bdb8e43394d62d14f0c7c8843fadfa",
        "files": [
          "ext/misc/dbdata.c",
          "main.mk",
          "manifest",
          "manifest.uuid",
          "src/shell.c.in",
          "test/dbdata.test",
          "test/recover.test",
          "tool/mkshellc.tcl"
        ],
        "message": "Add the \".recover\" command to the shell tool. For recovering as much data as possible from corrupt databases.\n\nFossilOrigin-Name: 50fe48458942fa7a6bcc76316c6321f95b23dc34f2f8e0a483826483b2fb16f6",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "main.mk||main.mk",
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in",
          "test/dbdata.test||test/dbdata.test",
          "test/recover.test||test/recover.test",
          "tool/mkshellc.tcl||tool/mkshellc.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: #if !defined(SQLITEINT_H)",
          "75: #include \"sqlite3ext.h\"",
          "77: typedef unsigned char u8;",
          "79: #endif",
          "80: SQLITE_EXTENSION_INIT1",
          "81: #include <string.h>",
          "82: #include <assert.h>",
          "84: typedef struct DbdataTable DbdataTable;",
          "85: typedef struct DbdataCursor DbdataCursor;",
          "88: struct DbdataCursor {",
          "98:   int szDb;",
          "99:   sqlite3_int64 iRowid;",
          "106:   u8 *pHdrPtr;",
          "107:   u8 *pPtr;",
          "110: };",
          "113: struct DbdataTable {",
          "118: };",
          "121: #define DBDATA_COLUMN_PGNO        0",
          "122: #define DBDATA_COLUMN_CELL        1",
          "123: #define DBDATA_COLUMN_FIELD       2",
          "124: #define DBDATA_COLUMN_VALUE       3",
          "125: #define DBDATA_COLUMN_SCHEMA      4",
          "126: #define DBDATA_SCHEMA             \\",
          "127:       \"CREATE TABLE x(\"           \\",
          "128:       \"  pgno INTEGER,\"           \\",
          "129:       \"  cell INTEGER,\"           \\",
          "130:       \"  field INTEGER,\"          \\",
          "131:       \"  value ANY,\"              \\",
          "132:       \"  schema TEXT HIDDEN\"      \\",
          "133:       \")\"",
          "136: #define DBPTR_COLUMN_PGNO         0",
          "137: #define DBPTR_COLUMN_CHILD        1",
          "138: #define DBPTR_COLUMN_SCHEMA       2",
          "139: #define DBPTR_SCHEMA              \\",
          "140:       \"CREATE TABLE x(\"           \\",
          "141:       \"  pgno INTEGER,\"           \\",
          "142:       \"  child INTEGER,\"          \\",
          "143:       \"  schema TEXT HIDDEN\"      \\",
          "144:       \")\"",
          "150: static int dbdataConnect(",
          "151:   sqlite3 *db,",
          "152:   void *pAux,",
          "153:   int argc, const char *const*argv,",
          "154:   sqlite3_vtab **ppVtab,",
          "155:   char **pzErr",
          "156: ){",
          "157:   DbdataTable *pTab = 0;",
          "158:   int rc = sqlite3_declare_vtab(db, pAux ? DBPTR_SCHEMA : DBDATA_SCHEMA);",
          "160:   if( rc==SQLITE_OK ){",
          "161:     pTab = (DbdataTable*)sqlite3_malloc64(sizeof(DbdataTable));",
          "162:     if( pTab==0 ){",
          "163:       rc = SQLITE_NOMEM;",
          "164:     }else{",
          "165:       memset(pTab, 0, sizeof(DbdataTable));",
          "166:       pTab->db = db;",
          "167:       pTab->bPtr = (pAux!=0);",
          "168:     }",
          "169:   }",
          "172:   return rc;",
          "173: }",
          "178: static int dbdataDisconnect(sqlite3_vtab *pVtab){",
          "179:   DbdataTable *pTab = (DbdataTable*)pVtab;",
          "180:   if( pTab ){",
          "181:     sqlite3_finalize(pTab->pStmt);",
          "182:     sqlite3_free(pVtab);",
          "183:   }",
          "184:   return SQLITE_OK;",
          "185: }",
          "200: static int dbdataBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdx){",
          "201:   DbdataTable *pTab = (DbdataTable*)tab;",
          "202:   int i;",
          "203:   int iSchema = -1;",
          "204:   int iPgno = -1;",
          "205:   int colSchema = (pTab->bPtr ? DBPTR_COLUMN_SCHEMA : DBDATA_COLUMN_SCHEMA);",
          "207:   for(i=0; i<pIdx->nConstraint; i++){",
          "208:     struct sqlite3_index_constraint *p = &pIdx->aConstraint[i];",
          "209:     if( p->op==SQLITE_INDEX_CONSTRAINT_EQ ){",
          "210:       if( p->iColumn==colSchema ){",
          "211:         if( p->usable==0 ) return SQLITE_CONSTRAINT;",
          "212:         iSchema = i;",
          "213:       }",
          "214:       if( p->iColumn==DBDATA_COLUMN_PGNO && p->usable ){",
          "215:         iPgno = i;",
          "216:       }",
          "217:     }",
          "218:   }",
          "220:   if( iSchema>=0 ){",
          "221:     pIdx->aConstraintUsage[iSchema].argvIndex = 1;",
          "222:     pIdx->aConstraintUsage[iSchema].omit = 1;",
          "223:   }",
          "224:   if( iPgno>=0 ){",
          "225:     pIdx->aConstraintUsage[iPgno].argvIndex = 1 + (iSchema>=0);",
          "226:     pIdx->aConstraintUsage[iPgno].omit = 1;",
          "227:     pIdx->estimatedCost = 100;",
          "228:     pIdx->estimatedRows =  50;",
          "230:     if( pTab->bPtr==0 && pIdx->nOrderBy && pIdx->aOrderBy[0].desc==0 ){",
          "231:       int iCol = pIdx->aOrderBy[0].iColumn;",
          "232:       if( pIdx->nOrderBy==1 ){",
          "233:         pIdx->orderByConsumed = (iCol==0 || iCol==1);",
          "234:       }else if( pIdx->nOrderBy==2 && pIdx->aOrderBy[1].desc==0 && iCol==0 ){",
          "235:         pIdx->orderByConsumed = (pIdx->aOrderBy[1].iColumn==1);",
          "236:       }",
          "237:     }",
          "239:   }else{",
          "240:     pIdx->estimatedCost = 100000000;",
          "241:     pIdx->estimatedRows = 1000000000;",
          "242:   }",
          "243:   pIdx->idxNum = (iSchema>=0 ? 0x01 : 0x00) | (iPgno>=0 ? 0x02 : 0x00);",
          "244:   return SQLITE_OK;",
          "245: }",
          "250: static int dbdataOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){",
          "251:   DbdataCursor *pCsr;",
          "253:   pCsr = (DbdataCursor*)sqlite3_malloc64(sizeof(DbdataCursor));",
          "254:   if( pCsr==0 ){",
          "255:     return SQLITE_NOMEM;",
          "256:   }else{",
          "257:     memset(pCsr, 0, sizeof(DbdataCursor));",
          "258:     pCsr->base.pVtab = pVTab;",
          "259:   }",
          "262:   return SQLITE_OK;",
          "263: }",
          "269: static void dbdataResetCursor(DbdataCursor *pCsr){",
          "270:   DbdataTable *pTab = (DbdataTable*)(pCsr->base.pVtab);",
          "271:   if( pTab->pStmt==0 ){",
          "272:     pTab->pStmt = pCsr->pStmt;",
          "273:   }else{",
          "274:     sqlite3_finalize(pCsr->pStmt);",
          "275:   }",
          "276:   pCsr->pStmt = 0;",
          "277:   pCsr->iPgno = 1;",
          "278:   pCsr->iCell = 0;",
          "279:   pCsr->iField = 0;",
          "280:   pCsr->bOnePage = 0;",
          "281: }",
          "286: static int dbdataClose(sqlite3_vtab_cursor *pCursor){",
          "287:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "288:   dbdataResetCursor(pCsr);",
          "289:   sqlite3_free(pCsr);",
          "290:   return SQLITE_OK;",
          "291: }",
          "296: static unsigned int get_uint16(unsigned char *a){",
          "297:   return (a[0]<<8)|a[1];",
          "298: }",
          "299: static unsigned int get_uint32(unsigned char *a){",
          "300:   return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|a[3];",
          "301: }",
          "313: static int dbdataLoadPage(",
          "318: ){",
          "319:   int rc2;",
          "320:   int rc = SQLITE_OK;",
          "321:   sqlite3_stmt *pStmt = pCsr->pStmt;",
          "325:   sqlite3_bind_int64(pStmt, 2, pgno);",
          "326:   if( SQLITE_ROW==sqlite3_step(pStmt) ){",
          "327:     int nCopy = sqlite3_column_bytes(pStmt, 0);",
          "328:     if( nCopy>0 ){",
          "329:       u8 *pPage;",
          "330:       pPage = (u8*)sqlite3_malloc64(nCopy);",
          "331:       if( pPage==0 ){",
          "332:         rc = SQLITE_NOMEM;",
          "333:       }else{",
          "334:         const u8 *pCopy = sqlite3_column_blob(pStmt, 0);",
          "335:         memcpy(pPage, pCopy, nCopy);",
          "336:       }",
          "339:     }",
          "340:   }",
          "341:   rc2 = sqlite3_reset(pStmt);",
          "342:   if( rc==SQLITE_OK ) rc = rc2;",
          "344:   return rc;",
          "345: }",
          "350: static int dbdataGetVarint(const u8 *z, sqlite3_int64 *pVal){",
          "351:   sqlite3_int64 v = 0;",
          "352:   int i;",
          "353:   for(i=0; i<8; i++){",
          "354:     v = (v<<7) + (z[i]&0x7f);",
          "355:     if( (z[i]&0x80)==0 ){ *pVal = v; return i+1; }",
          "356:   }",
          "357:   v = (v<<8) + (z[i]&0xff);",
          "359:   return 9;",
          "360: }",
          "366: static int dbdataValueBytes(int eType){",
          "367:   switch( eType ){",
          "368:     case 0: case 8: case 9:",
          "369:     case 10: case 11:",
          "370:       return 0;",
          "371:     case 1:",
          "372:       return 1;",
          "373:     case 2:",
          "374:       return 2;",
          "375:     case 3:",
          "376:       return 3;",
          "377:     case 4:",
          "378:       return 4;",
          "379:     case 5:",
          "380:       return 6;",
          "381:     case 6:",
          "382:     case 7:",
          "383:       return 8;",
          "384:     default:",
          "385:       return ((eType-12) / 2);",
          "386:   }",
          "387: }",
          "393: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "394:   switch( eType ){",
          "395:     case 0:",
          "396:     case 10:",
          "397:     case 11:",
          "398:       sqlite3_result_null(pCtx);",
          "399:       break;",
          "401:     case 8:",
          "402:       sqlite3_result_int(pCtx, 0);",
          "403:       break;",
          "404:     case 9:",
          "405:       sqlite3_result_int(pCtx, 1);",
          "406:       break;",
          "408:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "409:       sqlite3_uint64 v = (signed char)pData[0];",
          "410:       pData++;",
          "411:       switch( eType ){",
          "412:         case 7:",
          "413:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "414:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "415:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "416:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "417:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "418:       }",
          "420:       if( eType==7 ){",
          "421:         double r;",
          "422:         memcpy(&r, &v, sizeof(r));",
          "423:         sqlite3_result_double(pCtx, r);",
          "424:       }else{",
          "425:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "426:       }",
          "427:       break;",
          "428:     }",
          "430:     default: {",
          "431:       int n = ((eType-12) / 2);",
          "432:       if( eType % 2 ){",
          "433:         sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "434:       }else{",
          "435:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "436:       }",
          "437:     }",
          "438:   }",
          "439: }",
          "445: static int dbdataNext(sqlite3_vtab_cursor *pCursor){",
          "446:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "447:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "449:   pCsr->iRowid++;",
          "450:   while( 1 ){",
          "451:     int rc;",
          "452:     int iOff = (pCsr->iPgno==1 ? 100 : 0);",
          "454:     if( pCsr->aPage==0 ){",
          "455:       while( 1 ){",
          "456:         if( pCsr->bOnePage==0 && pCsr->iPgno>pCsr->szDb ) return SQLITE_OK;",
          "457:         rc = dbdataLoadPage(pCsr, pCsr->iPgno, &pCsr->aPage, &pCsr->nPage);",
          "458:         if( rc!=SQLITE_OK ) return rc;",
          "459:         if( pCsr->aPage ) break;",
          "460:         pCsr->iPgno++;",
          "461:       }",
          "462:       pCsr->iCell = pTab->bPtr ? -2 : 0;",
          "463:       pCsr->nCell = get_uint16(&pCsr->aPage[iOff+3]);",
          "464:     }",
          "466:     if( pTab->bPtr ){",
          "467:       if( pCsr->aPage[iOff]!=0x02 && pCsr->aPage[iOff]!=0x05 ){",
          "468:         pCsr->iCell = pCsr->nCell;",
          "469:       }",
          "470:       pCsr->iCell++;",
          "471:       if( pCsr->iCell>=pCsr->nCell ){",
          "472:         sqlite3_free(pCsr->aPage);",
          "473:         pCsr->aPage = 0;",
          "474:         if( pCsr->bOnePage ) return SQLITE_OK;",
          "475:         pCsr->iPgno++;",
          "476:       }else{",
          "477:         return SQLITE_OK;",
          "478:       }",
          "479:     }else{",
          "481:       if( pCsr->pRec==0 ){",
          "482:         int bHasRowid = 0;",
          "483:         int nPointer = 0;",
          "484:         sqlite3_int64 nPayload = 0;",
          "485:         sqlite3_int64 nHdr = 0;",
          "486:         int iHdr;",
          "487:         int U, X;",
          "488:         int nLocal;",
          "490:         switch( pCsr->aPage[iOff] ){",
          "491:           case 0x02:",
          "492:             nPointer = 4;",
          "493:             break;",
          "494:           case 0x0a:",
          "495:             break;",
          "496:           case 0x0d:",
          "497:             bHasRowid = 1;",
          "498:             break;",
          "499:           default:",
          "501:             pCsr->iCell = pCsr->nCell;",
          "502:             break;",
          "503:         }",
          "505:         if( pCsr->iCell>=pCsr->nCell ){",
          "506:           sqlite3_free(pCsr->aPage);",
          "507:           pCsr->aPage = 0;",
          "508:           if( pCsr->bOnePage ) return SQLITE_OK;",
          "509:           pCsr->iPgno++;",
          "510:           continue;",
          "511:         }",
          "513:         iOff += 8 + nPointer + pCsr->iCell*2;",
          "514:         iOff = get_uint16(&pCsr->aPage[iOff]);",
          "517:         iOff += nPointer;",
          "520:         iOff += dbdataGetVarint(&pCsr->aPage[iOff], &nPayload);",
          "523:         if( bHasRowid ){",
          "524:           iOff += dbdataGetVarint(&pCsr->aPage[iOff], &pCsr->iIntkey);",
          "525:         }",
          "528:         pCsr->pRec = (u8*)sqlite3_malloc64(nPayload);",
          "529:         if( pCsr->pRec==0 ) return SQLITE_NOMEM;",
          "530:         pCsr->nRec = nPayload;",
          "532:         U = pCsr->nPage;",
          "533:         if( bHasRowid ){",
          "534:           X = U-35;",
          "535:         }else{",
          "536:           X = ((U-12)*64/255)-23;",
          "537:         }",
          "538:         if( nPayload<=X ){",
          "539:           nLocal = nPayload;",
          "540:         }else{",
          "541:           int M, K;",
          "542:           M = ((U-12)*32/255)-23;",
          "543:           K = M+((nPayload-M)%(U-4));",
          "544:           if( K<=X ){",
          "545:             nLocal = K;",
          "546:           }else{",
          "547:             nLocal = M;",
          "548:           }",
          "549:         }",
          "552:         memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);",
          "553:         iOff += nLocal;",
          "556:         if( nPayload>nLocal ){",
          "557:           sqlite3_int64 nRem = nPayload - nLocal;",
          "558:           unsigned int pgnoOvfl = get_uint32(&pCsr->aPage[iOff]);",
          "559:           while( nRem>0 ){",
          "560:             u8 *aOvfl = 0;",
          "561:             int nOvfl = 0;",
          "562:             int nCopy;",
          "563:             rc = dbdataLoadPage(pCsr, pgnoOvfl, &aOvfl, &nOvfl);",
          "564:             assert( rc!=SQLITE_OK || nOvfl==pCsr->nPage );",
          "565:             if( rc!=SQLITE_OK ) return rc;",
          "567:             nCopy = U-4;",
          "568:             if( nCopy>nRem ) nCopy = nRem;",
          "569:             memcpy(&pCsr->pRec[nPayload-nRem], &aOvfl[4], nCopy);",
          "570:             nRem -= nCopy;",
          "572:             pgnoOvfl = get_uint32(aOvfl);",
          "573:             sqlite3_free(aOvfl);",
          "574:           }",
          "575:         }",
          "577:         iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);",
          "578:         pCsr->nHdr = nHdr;",
          "579:         pCsr->pHdrPtr = &pCsr->pRec[iHdr];",
          "580:         pCsr->pPtr = &pCsr->pRec[pCsr->nHdr];",
          "581:         pCsr->iField = (bHasRowid ? -1 : 0);",
          "582:       }else{",
          "583:         pCsr->iField++;",
          "584:         if( pCsr->iField>0 ){",
          "585:           sqlite3_int64 iType;",
          "586:           pCsr->pHdrPtr += dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "587:           pCsr->pPtr += dbdataValueBytes(iType);",
          "588:         }",
          "589:       }",
          "591:       if( pCsr->iField<0 || pCsr->pHdrPtr<&pCsr->pRec[pCsr->nHdr] ){",
          "592:         return SQLITE_OK;",
          "593:       }",
          "597:       sqlite3_free(pCsr->pRec);",
          "598:       pCsr->pRec = 0;",
          "599:       pCsr->iCell++;",
          "600:     }",
          "601:   }",
          "603:   assert( !\"can't get here\" );",
          "604:   return SQLITE_OK;",
          "605: }",
          "610: static int dbdataEof(sqlite3_vtab_cursor *pCursor){",
          "611:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "612:   return pCsr->aPage==0;",
          "613: }",
          "621: static int dbdataDbsize(DbdataCursor *pCsr, const char *zSchema){",
          "622:   DbdataTable *pTab = (DbdataTable*)pCsr->base.pVtab;",
          "623:   char *zSql = 0;",
          "624:   int rc, rc2;",
          "625:   sqlite3_stmt *pStmt = 0;",
          "627:   zSql = sqlite3_mprintf(\"PRAGMA %Q.page_count\", zSchema);",
          "628:   if( zSql==0 ) return SQLITE_NOMEM;",
          "629:   rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pStmt, 0);",
          "630:   sqlite3_free(zSql);",
          "631:   if( rc==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){",
          "632:     pCsr->szDb = sqlite3_column_int(pStmt, 0);",
          "633:   }",
          "634:   rc2 = sqlite3_finalize(pStmt);",
          "635:   if( rc==SQLITE_OK ) rc = rc2;",
          "636:   return rc;",
          "637: }",
          "642: static int dbdataFilter(",
          "643:   sqlite3_vtab_cursor *pCursor,",
          "644:   int idxNum, const char *idxStr,",
          "645:   int argc, sqlite3_value **argv",
          "646: ){",
          "647:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "648:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "649:   int rc = SQLITE_OK;",
          "650:   const char *zSchema = \"main\";",
          "652:   dbdataResetCursor(pCsr);",
          "653:   assert( pCsr->iPgno==1 );",
          "654:   if( idxNum & 0x01 ){",
          "655:     zSchema = (const char*)sqlite3_value_text(argv[0]);",
          "656:   }",
          "657:   if( idxNum & 0x02 ){",
          "658:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);",
          "659:     pCsr->bOnePage = 1;",
          "660:   }else{",
          "661:     pCsr->nPage = dbdataDbsize(pCsr, zSchema);",
          "662:     rc = dbdataDbsize(pCsr, zSchema);",
          "663:   }",
          "665:   if( rc==SQLITE_OK ){",
          "666:     if( pTab->pStmt ){",
          "667:       pCsr->pStmt = pTab->pStmt;",
          "668:       pTab->pStmt = 0;",
          "669:     }else{",
          "670:       rc = sqlite3_prepare_v2(pTab->db,",
          "671:           \"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\", -1,",
          "672:           &pCsr->pStmt, 0",
          "673:       );",
          "674:     }",
          "675:   }",
          "676:   if( rc==SQLITE_OK ){",
          "677:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);",
          "678:   }else{",
          "679:     pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(pTab->db));",
          "680:   }",
          "681:   if( rc==SQLITE_OK ){",
          "682:     rc = dbdataNext(pCursor);",
          "683:   }",
          "684:   return rc;",
          "685: }",
          "690: static int dbdataColumn(",
          "691:   sqlite3_vtab_cursor *pCursor,",
          "692:   sqlite3_context *ctx,",
          "693:   int i",
          "694: ){",
          "695:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "696:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "697:   if( pTab->bPtr ){",
          "698:     switch( i ){",
          "699:       case DBPTR_COLUMN_PGNO:",
          "700:         sqlite3_result_int64(ctx, pCsr->iPgno);",
          "701:         break;",
          "702:       case DBPTR_COLUMN_CHILD: {",
          "703:         int iOff = pCsr->iPgno==1 ? 100 : 0;",
          "704:         if( pCsr->iCell<0 ){",
          "705:           iOff += 8;",
          "706:         }else{",
          "707:           iOff += 12 + pCsr->iCell*2;",
          "708:           iOff = get_uint16(&pCsr->aPage[iOff]);",
          "709:         }",
          "710:         sqlite3_result_int64(ctx, get_uint32(&pCsr->aPage[iOff]));",
          "711:         break;",
          "712:       }",
          "713:     }",
          "714:   }else{",
          "715:     switch( i ){",
          "716:       case DBDATA_COLUMN_PGNO:",
          "717:         sqlite3_result_int64(ctx, pCsr->iPgno);",
          "718:         break;",
          "719:       case DBDATA_COLUMN_CELL:",
          "720:         sqlite3_result_int(ctx, pCsr->iCell);",
          "721:         break;",
          "722:       case DBDATA_COLUMN_FIELD:",
          "723:         sqlite3_result_int(ctx, pCsr->iField);",
          "724:         break;",
          "725:       case DBDATA_COLUMN_VALUE: {",
          "726:         if( pCsr->iField<0 ){",
          "727:           sqlite3_result_int64(ctx, pCsr->iIntkey);",
          "728:         }else{",
          "729:           sqlite3_int64 iType;",
          "730:           dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "731:           dbdataValue(ctx, iType, pCsr->pPtr);",
          "732:         }",
          "733:         break;",
          "734:       }",
          "735:     }",
          "736:   }",
          "737:   return SQLITE_OK;",
          "738: }",
          "743: static int dbdataRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){",
          "744:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "746:   return SQLITE_OK;",
          "747: }",
          "753: static int sqlite3DbdataRegister(sqlite3 *db){",
          "754:   static sqlite3_module dbdata_module = {",
          "779:   };",
          "781:   int rc = sqlite3_create_module(db, \"sqlite_dbdata\", &dbdata_module, 0);",
          "782:   if( rc==SQLITE_OK ){",
          "783:     rc = sqlite3_create_module(db, \"sqlite_dbptr\", &dbdata_module, (void*)1);",
          "784:   }",
          "785:   return rc;",
          "786: }",
          "788: #ifdef _WIN32",
          "789: __declspec(dllexport)",
          "790: #endif",
          "791: int sqlite3_dbdata_init(",
          "792:   sqlite3 *db,",
          "793:   char **pzErrMsg,",
          "794:   const sqlite3_api_routines *pApi",
          "795: ){",
          "796:   SQLITE_EXTENSION_INIT2(pApi);",
          "797:   return sqlite3DbdataRegister(db);",
          "798: }",
          "",
          "---------------"
        ],
        "main.mk||main.mk": [
          "File: main.mk -> main.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:  $(TOP)/ext/expert/sqlite3expert.h \\",
          "739:  $(TOP)/ext/misc/zipfile.c \\",
          "740:  $(TOP)/ext/misc/memtrace.c \\",
          "741:         $(TOP)/src/test_windirent.c",
          "743: shell.c: $(SHELL_SRC) $(TOP)/tool/mkshellc.tcl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741:  $(TOP)/ext/misc/dbdata.c \\",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 95209072176ff21a91e96d5bd014b35ef100da2b0b93958baf6df4294a8daa85",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "948: INCLUDE ../ext/expert/sqlite3expert.h",
          "949: INCLUDE ../ext/expert/sqlite3expert.c",
          "951: #if defined(SQLITE_ENABLE_SESSION)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "952: INCLUDE ../ext/misc/dbdata.c",
          "953: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3574:   \".prompt MAIN CONTINUE    Replace the standard prompts\",",
          "3575:   \".quit                    Exit this program\",",
          "3576:   \".read FILE               Read input from FILE\",",
          "3577:   \".restore ?DB? FILE       Restore content of DB (default \\\"main\\\") from FILE\",",
          "3578:   \".save FILE               Write in-memory database into FILE\",",
          "3579:   \".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3581: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "3582:   \".recover                 Recover as much data as possible from corrupt db.\",",
          "3583: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3931: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3947: static void shellInt32(",
          "3948:   sqlite3_context *context,",
          "3949:   int argc,",
          "3950:   sqlite3_value **argv",
          "3951: ){",
          "3952:   const unsigned char *pBlob;",
          "3953:   int nBlob;",
          "3954:   int iInt;",
          "3956:   nBlob = sqlite3_value_bytes(argv[0]);",
          "3957:   pBlob = (const unsigned char*)sqlite3_value_blob(argv[0]);",
          "3958:   iInt = sqlite3_value_int(argv[1]);",
          "3960:   if( iInt>=0 && (iInt+1)*4<=nBlob ){",
          "3961:     const unsigned char *a = &pBlob[iInt*4];",
          "3962:     sqlite3_int64 iVal = ((sqlite3_int64)a[0]<<24)",
          "3963:                        + ((sqlite3_int64)a[1]<<16)",
          "3964:                        + ((sqlite3_int64)a[2]<< 8)",
          "3965:                        + ((sqlite3_int64)a[3]<< 0);",
          "3966:     sqlite3_result_int64(context, iVal);",
          "3967:   }",
          "3968: }",
          "3983: static void shellEscapeCrnl(",
          "3984:   sqlite3_context *context,",
          "3985:   int argc,",
          "3986:   sqlite3_value **argv",
          "3987: ){",
          "3988:   const char *zText = (const char*)sqlite3_value_text(argv[0]);",
          "3989:   if( zText[0]=='\\'' ){",
          "3990:     int nText = sqlite3_value_bytes(argv[0]);",
          "3991:     int i;",
          "3992:     char zBuf1[20];",
          "3993:     char zBuf2[20];",
          "3994:     const char *zNL = 0;",
          "3995:     const char *zCR = 0;",
          "3996:     int nCR = 0;",
          "3997:     int nNL = 0;",
          "3999:     for(i=0; zText[i]; i++){",
          "4000:       if( zNL==0 && zText[i]=='\\n' ){",
          "4001:         zNL = unused_string(zText, \"\\\\n\", \"\\\\012\", zBuf1);",
          "4002:         nNL = (int)strlen(zNL);",
          "4003:       }",
          "4004:       if( zCR==0 && zText[i]=='\\r' ){",
          "4005:         zCR = unused_string(zText, \"\\\\r\", \"\\\\015\", zBuf2);",
          "4006:         nCR = (int)strlen(zCR);",
          "4007:       }",
          "4008:     }",
          "4010:     if( zNL || zCR ){",
          "4011:       int iOut = 0;",
          "4012:       i64 nMax = (nNL > nCR) ? nNL : nCR;",
          "4013:       i64 nAlloc = nMax * nText + (nMax+12)*2;",
          "4014:       char *zOut = (char*)sqlite3_malloc64(nAlloc);",
          "4015:       if( zOut==0 ){",
          "4016:         sqlite3_result_error_nomem(context);",
          "4017:         return;",
          "4018:       }",
          "4020:       if( zNL && zCR ){",
          "4021:         memcpy(&zOut[iOut], \"replace(replace(\", 16);",
          "4022:         iOut += 16;",
          "4023:       }else{",
          "4024:         memcpy(&zOut[iOut], \"replace(\", 8);",
          "4025:         iOut += 8;",
          "4026:       }",
          "4027:       for(i=0; zText[i]; i++){",
          "4028:         if( zText[i]=='\\n' ){",
          "4029:           memcpy(&zOut[iOut], zNL, nNL);",
          "4030:           iOut += nNL;",
          "4031:         }else if( zText[i]=='\\r' ){",
          "4032:           memcpy(&zOut[iOut], zCR, nCR);",
          "4033:           iOut += nCR;",
          "4034:         }else{",
          "4035:           zOut[iOut] = zText[i];",
          "4036:           iOut++;",
          "4037:         }",
          "4038:       }",
          "4040:       if( zNL ){",
          "4041:         memcpy(&zOut[iOut], \",'\", 2); iOut += 2;",
          "4042:         memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;",
          "4043:         memcpy(&zOut[iOut], \"', char(10))\", 12); iOut += 12;",
          "4044:       }",
          "4045:       if( zCR ){",
          "4046:         memcpy(&zOut[iOut], \",'\", 2); iOut += 2;",
          "4047:         memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;",
          "4048:         memcpy(&zOut[iOut], \"', char(13))\", 12); iOut += 12;",
          "4049:       }",
          "4051:       sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);",
          "4052:       sqlite3_free(zOut);",
          "4053:       return;",
          "4054:     }",
          "4055:   }",
          "4057:   sqlite3_result_value(context, argv[0]);",
          "4058: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3999:     sqlite3_fileio_init(p->db, 0, 0);",
          "4000:     sqlite3_shathree_init(p->db, 0, 0);",
          "4001:     sqlite3_completion_init(p->db, 0, 0);",
          "4002: #ifdef SQLITE_HAVE_ZLIB",
          "4003:     sqlite3_zipfile_init(p->db, 0, 0);",
          "4004:     sqlite3_sqlar_init(p->db, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4128: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "4129:     sqlite3_dbdata_init(p->db, 0, 0);",
          "4130: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4009:                             shellModuleSchema, 0, 0);",
          "4010:     sqlite3_create_function(p->db, \"shell_putsnl\", 1, SQLITE_UTF8, p,",
          "4011:                             shellPutsFunc, 0, 0);",
          "4012: #ifndef SQLITE_NOHAVE_SYSTEM",
          "4013:     sqlite3_create_function(p->db, \"edit\", 1, SQLITE_UTF8, 0,",
          "4014:                             editFunc, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4141:     sqlite3_create_function(p->db, \"shell_escape_crnl\", 1, SQLITE_UTF8, 0,",
          "4142:                             shellEscapeCrnl, 0, 0);",
          "4143:     sqlite3_create_function(p->db, \"shell_int32\", 2, SQLITE_UTF8, 0,",
          "4144:                             shellInt32, 0, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5263:   return SQLITE_ERROR;",
          "5264: }",
          "5270: static void shellPrepare(",
          "5271:   sqlite3 *db,",
          "5272:   int *pRc,",
          "",
          "[Removed Lines]",
          "5266: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)",
          "",
          "[Added Lines]",
          "5399: #if !defined SQLITE_OMIT_VIRTUALTABLE",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5338:   }",
          "5339: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5472: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6165: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "6172: static void shellExec(sqlite3 *db, int *pRc, const char *zSql){",
          "6173:   int rc = *pRc;",
          "6174:   if( rc==SQLITE_OK ){",
          "6175:     char *zErr = 0;",
          "6176:     rc = sqlite3_exec(db, zSql, 0, 0, &zErr);",
          "6177:     if( rc!=SQLITE_OK ){",
          "6178:       raw_printf(stderr, \"SQL error: %s\\n\", zErr);",
          "6179:     }",
          "6181:   }",
          "6182: }",
          "6187: static void shellExecPrintf(sqlite3 *db, int *pRc, const char *zFmt, ...){",
          "6188:   char *z = 0;",
          "6189:   if( *pRc==SQLITE_OK ){",
          "6190:     va_list ap;",
          "6191:     va_start(ap, zFmt);",
          "6192:     z = sqlite3_vmprintf(zFmt, ap);",
          "6193:     va_end(ap);",
          "6194:     if( z==0 ){",
          "6196:     }else{",
          "6197:       shellExec(db, pRc, z);",
          "6198:     }",
          "6199:     sqlite3_free(z);",
          "6200:   }",
          "6201: }",
          "6209: static void *shellMalloc(int *pRc, sqlite3_int64 nByte){",
          "6210:   void *pRet = 0;",
          "6211:   if( *pRc==SQLITE_OK ){",
          "6212:     pRet = sqlite3_malloc64(nByte);",
          "6213:     if( pRet==0 ){",
          "6215:     }else{",
          "6216:       memset(pRet, 0, nByte);",
          "6217:     }",
          "6218:   }",
          "6219:   return pRet;",
          "6220: }",
          "6233: static char *shellMPrintf(int *pRc, const char *zFmt, ...){",
          "6234:   char *z = 0;",
          "6235:   if( *pRc==SQLITE_OK ){",
          "6236:     va_list ap;",
          "6237:     va_start(ap, zFmt);",
          "6238:     z = sqlite3_vmprintf(zFmt, ap);",
          "6239:     va_end(ap);",
          "6240:     if( z==0 ){",
          "6242:     }",
          "6243:   }",
          "6244:   return z;",
          "6245: }",
          "6252: typedef struct RecoverTable RecoverTable;",
          "6253: struct RecoverTable {",
          "6258: };",
          "6264: static void recoverFreeTable(RecoverTable *pTab){",
          "6265:   if( pTab ){",
          "6266:     sqlite3_free(pTab->zQuoted);",
          "6267:     if( pTab->azlCol ){",
          "6268:       int i;",
          "6269:       for(i=0; i<=pTab->nCol; i++){",
          "6270:         sqlite3_free(pTab->azlCol[i]);",
          "6271:       }",
          "6272:       sqlite3_free(pTab->azlCol);",
          "6273:     }",
          "6274:     sqlite3_free(pTab);",
          "6275:   }",
          "6276: }",
          "6285: static RecoverTable *recoverNewTable(",
          "6289:   int bIntkey,",
          "6290:   int nCol",
          "6291: ){",
          "6293:   int rc = *pRc;",
          "6294:   RecoverTable *pTab = 0;",
          "6296:   pTab = (RecoverTable*)shellMalloc(&rc, sizeof(RecoverTable));",
          "6297:   if( rc==SQLITE_OK ){",
          "6298:     int nSqlCol = 0;",
          "6299:     int bSqlIntkey = 0;",
          "6300:     sqlite3_stmt *pStmt = 0;",
          "6302:     rc = sqlite3_open(\"\", &dbtmp);",
          "6303:     if( rc==SQLITE_OK ){",
          "6304:       rc = sqlite3_exec(dbtmp, \"PRAGMA writable_schema = on\", 0, 0, 0);",
          "6305:     }",
          "6306:     if( rc==SQLITE_OK ){",
          "6307:       rc = sqlite3_exec(dbtmp, zSql, 0, 0, 0);",
          "6308:       if( rc==SQLITE_ERROR ){",
          "6309:         rc = SQLITE_OK;",
          "6310:         goto finished;",
          "6311:       }",
          "6312:     }",
          "6313:     shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6314:         \"SELECT count(*) FROM pragma_table_info(%Q)\", zName",
          "6315:     );",
          "6316:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6317:       nSqlCol = sqlite3_column_int(pStmt, 0);",
          "6318:     }",
          "6319:     shellFinalize(&rc, pStmt);",
          "6321:     if( rc!=SQLITE_OK || nSqlCol<nCol ){",
          "6322:       goto finished;",
          "6323:     }",
          "6325:     shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6326:       \"SELECT (\"",
          "6327:       \"  SELECT substr(data,1,1)==X'0D' FROM sqlite_dbpage WHERE pgno=rootpage\"",
          "6328:       \") FROM sqlite_master WHERE name = %Q\", zName",
          "6329:     );",
          "6330:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6331:       bSqlIntkey = sqlite3_column_int(pStmt, 0);",
          "6332:     }",
          "6333:     shellFinalize(&rc, pStmt);",
          "6335:     if( bIntkey==bSqlIntkey ){",
          "6336:       int i;",
          "6337:       const char *zPk = \"_rowid_\";",
          "6338:       sqlite3_stmt *pPkFinder = 0;",
          "6345:       pTab->iPk = -2;",
          "6346:       if( bIntkey ){",
          "6347:         shellPreparePrintf(dbtmp, &rc, &pPkFinder,",
          "6348:           \"SELECT cid, name FROM pragma_table_info(%Q) \"",
          "6349:           \"  WHERE pk=1 AND type='integer' COLLATE nocase\"",
          "6350:           \"  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\"",
          "6351:           , zName, zName",
          "6352:         );",
          "6353:         if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){",
          "6354:           pTab->iPk = sqlite3_column_int(pPkFinder, 0);",
          "6355:           zPk = (const char*)sqlite3_column_text(pPkFinder, 1);",
          "6356:         }",
          "6357:       }",
          "6359:       pTab->zQuoted = shellMPrintf(&rc, \"%Q\", zName);",
          "6360:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * (nSqlCol+1));",
          "6361:       pTab->nCol = nSqlCol;",
          "6363:       if( bIntkey ){",
          "6364:         pTab->azlCol[0] = shellMPrintf(&rc, \"%Q\", zPk);",
          "6365:       }else{",
          "6366:         pTab->azlCol[0] = shellMPrintf(&rc, \"\");",
          "6367:       }",
          "6368:       i = 1;",
          "6369:       shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6370:           \"SELECT %Q || group_concat(name, ', ') \"",
          "6371:           \"  FILTER (WHERE cid!=%d) OVER (ORDER BY %s cid) \"",
          "6372:           \"FROM pragma_table_info(%Q)\",",
          "6373:           bIntkey ? \", \" : \"\", pTab->iPk,",
          "6374:           bIntkey ? \"\" : \"(CASE WHEN pk=0 THEN 1000000 ELSE pk END), \",",
          "6375:           zName",
          "6376:       );",
          "6377:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6378:         const char *zText = (const char*)sqlite3_column_text(pStmt, 0);",
          "6379:         pTab->azlCol[i] = shellMPrintf(&rc, \"%s%s\", pTab->azlCol[0], zText);",
          "6380:         i++;",
          "6381:       }",
          "6382:       shellFinalize(&rc, pStmt);",
          "6384:       shellFinalize(&rc, pPkFinder);",
          "6385:     }",
          "6386:   }",
          "6388:  finished:",
          "6389:   sqlite3_close(dbtmp);",
          "6391:   if( rc!=SQLITE_OK ){",
          "6392:     recoverFreeTable(pTab);",
          "6393:     pTab = 0;",
          "6394:   }",
          "6395:   return pTab;",
          "6396: }",
          "6413: static RecoverTable *recoverFindTable(",
          "6420: ){",
          "6421:   sqlite3_stmt *pStmt = 0;",
          "6422:   RecoverTable *pRet = 0;",
          "6423:   int bNoop = 0;",
          "6424:   const char *zSql = 0;",
          "6425:   const char *zName = 0;",
          "6428:   shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6429:       \"SELECT type, name, sql FROM recovery.schema WHERE rootpage=%d\", iRoot",
          "6430:   );",
          "6431:   while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6432:     const char *zType = (const char*)sqlite3_column_text(pStmt, 0);",
          "6433:     if( bIntkey==0 && sqlite3_stricmp(zType, \"index\")==0 ){",
          "6434:       bNoop = 1;",
          "6435:       break;",
          "6436:     }",
          "6437:     if( sqlite3_stricmp(zType, \"table\")==0 ){",
          "6438:       zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6439:       zSql = (const char*)sqlite3_column_text(pStmt, 2);",
          "6440:       pRet = recoverNewTable(pRc, zName, zSql, bIntkey, nCol);",
          "6441:       break;",
          "6442:     }",
          "6443:   }",
          "6445:   shellFinalize(pRc, pStmt);",
          "6447:   return pRet;",
          "6448: }",
          "6453: static RecoverTable *recoverOrphanTable(",
          "6458: ){",
          "6459:   RecoverTable *pTab = 0;",
          "6460:   if( nCol>=0 && *pRc==SQLITE_OK ){",
          "6461:     int i;",
          "6467:     int iTab = 0;",
          "6468:     char *zTab = shellMPrintf(pRc, \"%s\", zLostAndFound);",
          "6469:     sqlite3_stmt *pTest = 0;",
          "6470:     shellPrepare(pState->db, pRc,",
          "6471:         \"SELECT 1 FROM recovery.schema WHERE name=?\", &pTest",
          "6472:     );",
          "6473:     if( pTest ) sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6474:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pTest) ){",
          "6475:       shellReset(pRc, pTest);",
          "6476:       sqlite3_free(zTab);",
          "6477:       zTab = shellMPrintf(pRc, \"%s_%d\", zLostAndFound, iTab++);",
          "6478:       sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6479:     }",
          "6480:     shellFinalize(pRc, pTest);",
          "6482:     pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6483:     if( pTab ){",
          "6484:       pTab->zQuoted = shellMPrintf(pRc, \"%Q\", zTab);",
          "6485:       pTab->nCol = nCol;",
          "6486:       pTab->iPk = -2;",
          "6487:       if( nCol>0 ){",
          "6488:         pTab->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * (nCol+1));",
          "6489:         if( pTab->azlCol ){",
          "6490:           pTab->azlCol[nCol] = shellMPrintf(pRc, \"\");",
          "6491:           for(i=nCol-1; i>=0; i--){",
          "6492:             pTab->azlCol[i] = shellMPrintf(pRc, \"%s, NULL\", pTab->azlCol[i+1]);",
          "6493:           }",
          "6494:         }",
          "6495:       }",
          "6497:       if( *pRc!=SQLITE_OK ){",
          "6498:         recoverFreeTable(pTab);",
          "6499:         pTab = 0;",
          "6500:       }else{",
          "6501:         raw_printf(pState->out,",
          "6502:             \"CREATE TABLE %s(rootpgno INTEGER, \"",
          "6503:             \"pgno INTEGER, nfield INTEGER, id INTEGER\", pTab->zQuoted",
          "6504:         );",
          "6505:         for(i=0; i<nCol; i++){",
          "6506:           raw_printf(pState->out, \", c%d\", i);",
          "6507:         }",
          "6508:         raw_printf(pState->out, \");\\n\");",
          "6509:       }",
          "6510:     }",
          "6511:     sqlite3_free(zTab);",
          "6512:   }",
          "6513:   return pTab;",
          "6514: }",
          "6521: static int recoverDatabaseCmd(ShellState *pState, int nArg, char **azArg){",
          "6522:   int rc = SQLITE_OK;",
          "6527:   const char *zLostAndFound = \"lost_and_found\";",
          "6528:   int i;",
          "6529:   int nOrphan = -1;",
          "6530:   RecoverTable *pOrphan = 0;",
          "6533:   for(i=1; i<nArg; i++){",
          "6534:     char *z = azArg[i];",
          "6535:     int n;",
          "6536:     if( z[0]=='-' && z[1]=='-' ) z++;",
          "6537:     n = strlen(z);",
          "6538:     if( n<=17 && memcmp(\"-freelist-corrupt\", z, n)==0 ){",
          "6539:       bFreelist = 0;",
          "6540:     }else",
          "6541:     if( n<=12 && memcmp(\"-recovery-db\", z, n)==0 && i<(nArg-1) ){",
          "6542:       i++;",
          "6543:       zRecoveryDb = azArg[i];",
          "6544:     }else",
          "6545:     if( n<=15 && memcmp(\"-lost-and-found\", z, n)==0 && i<(nArg-1) ){",
          "6546:       i++;",
          "6547:       zLostAndFound = azArg[i];",
          "6548:     }",
          "6549:     else{",
          "6550:       raw_printf(stderr, \"unexpected option: %s\\n\", azArg[i]);",
          "6551:       raw_printf(stderr, \"options are:\\n\");",
          "6552:       raw_printf(stderr, \"    --freelist-corrupt\\n\");",
          "6553:       raw_printf(stderr, \"    --recovery-db DATABASE\\n\");",
          "6554:       raw_printf(stderr, \"    --lost-and-found TABLE-NAME\\n\");",
          "6555:       return 1;",
          "6556:     }",
          "6557:   }",
          "6559:   shellExecPrintf(pState->db, &rc,",
          "6562:     \"ATTACH %Q AS recovery;\"",
          "6563:     \"DROP TABLE IF EXISTS recovery.dbptr;\"",
          "6564:     \"DROP TABLE IF EXISTS recovery.freelist;\"",
          "6565:     \"DROP TABLE IF EXISTS recovery.map;\"",
          "6566:     \"DROP TABLE IF EXISTS recovery.schema;\"",
          "6567:     \"CREATE TABLE recovery.freelist(pgno INTEGER PRIMARY KEY);\", zRecoveryDb",
          "6568:   );",
          "6570:   if( bFreelist ){",
          "6571:     shellExec(pState->db, &rc,",
          "6572:       \"WITH trunk(pgno) AS (\"",
          "6573:       \"  SELECT shell_int32(\"",
          "6574:       \"      (SELECT data FROM sqlite_dbpage WHERE pgno=1), 8) AS x \"",
          "6575:       \"      WHERE x>0\"",
          "6576:       \"    UNION\"",
          "6577:       \"  SELECT shell_int32(\"",
          "6578:       \"      (SELECT data FROM sqlite_dbpage WHERE pgno=trunk.pgno), 0) AS x \"",
          "6579:       \"      FROM trunk WHERE x>0\"",
          "6580:       \"),\"",
          "6581:       \"freelist(data, n, freepgno) AS (\"",
          "6582:       \"  SELECT data, shell_int32(data, 1)-1, t.pgno \"",
          "6583:       \"      FROM trunk t, sqlite_dbpage s WHERE s.pgno=t.pgno\"",
          "6584:       \"    UNION ALL\"",
          "6585:       \"  SELECT data, n-1, shell_int32(data, 2+n) \"",
          "6586:       \"      FROM freelist WHERE n>=0\"",
          "6587:       \")\"",
          "6588:       \"REPLACE INTO recovery.freelist SELECT freepgno FROM freelist;\"",
          "6589:     );",
          "6590:   }",
          "6592:   shellExec(pState->db, &rc,",
          "6593:     \"CREATE TABLE recovery.dbptr(\"",
          "6594:     \"      pgno, child, PRIMARY KEY(child, pgno)\"",
          "6595:     \") WITHOUT ROWID;\"",
          "6596:     \"INSERT OR IGNORE INTO recovery.dbptr(pgno, child) \"",
          "6597:     \"    SELECT * FROM sqlite_dbptr\"",
          "6598:     \"      WHERE pgno NOT IN freelist AND child NOT IN freelist;\"",
          "6602:     \"DELETE FROM recovery.dbptr WHERE child = 1;\"",
          "6607:     \"DELETE FROM recovery.dbptr WHERE child IN (\"",
          "6608:     \"  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1\"",
          "6609:     \");\"",
          "6614:     \"CREATE TABLE recovery.map(\"",
          "6615:       \"pgno INTEGER PRIMARY KEY, maxlen INT, intkey, root INT\"",
          "6616:     \");\"",
          "6621:     \"WITH pages(i, maxlen) AS (\"",
          "6622:     \"  SELECT page_count, (\"",
          "6623:     \"    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=page_count\"",
          "6624:     \"  ) FROM pragma_page_count\"",
          "6625:     \"    UNION ALL\"",
          "6626:     \"  SELECT i-1, (\"",
          "6627:     \"    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=i-1\"",
          "6628:     \"  ) FROM pages WHERE i>=2\"",
          "6629:     \")\"",
          "6630:     \"INSERT INTO recovery.map(pgno, maxlen, intkey, root) \"",
          "6631:     \"  SELECT i, maxlen, NULL, (\"",
          "6632:     \"    WITH p(orig, pgno, parent) AS (\"",
          "6633:     \"      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)\"",
          "6634:     \"        UNION ALL\"",
          "6635:     \"      SELECT i, p.parent, \"",
          "6636:     \"        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p\"",
          "6637:     \"    )\"",
          "6638:     \"    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)\"",
          "6639:     \") \"",
          "6640:     \"FROM pages WHERE maxlen > 0 AND i NOT IN freelist;\"",
          "6641:     \"UPDATE recovery.map AS o SET intkey = (\"",
          "6642:     \"  SELECT substr(data, 1, 1)==X'0D' FROM sqlite_dbpage WHERE pgno=o.pgno\"",
          "6643:     \");\"",
          "6647:     \"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\"",
          "6648:     \"INSERT INTO recovery.schema SELECT \"",
          "6649:     \"  max(CASE WHEN field=0 THEN value ELSE NULL END),\"",
          "6650:     \"  max(CASE WHEN field=1 THEN value ELSE NULL END),\"",
          "6651:     \"  max(CASE WHEN field=2 THEN value ELSE NULL END),\"",
          "6652:     \"  max(CASE WHEN field=3 THEN value ELSE NULL END),\"",
          "6653:     \"  max(CASE WHEN field=4 THEN value ELSE NULL END)\"",
          "6654:     \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6655:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6656:     \")\"",
          "6657:     \"GROUP BY pgno, cell;\"",
          "6658:     \"CREATE INDEX recovery.schema_rootpage ON schema(rootpage);\"",
          "6659:   );",
          "6663:   if( rc==SQLITE_OK ){",
          "6664:     sqlite3_stmt *pStmt = 0;",
          "6665:     raw_printf(pState->out, \"BEGIN;\\n\");",
          "6666:     raw_printf(pState->out, \"PRAGMA writable_schema = on;\\n\");",
          "6667:     shellPrepare(pState->db, &rc,",
          "6668:         \"SELECT sql FROM recovery.schema \"",
          "6669:         \"WHERE type='table' AND sql LIKE 'create table%'\", &pStmt",
          "6670:     );",
          "6671:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6672:       const char *zCreateTable = (const char*)sqlite3_column_text(pStmt, 0);",
          "6673:       raw_printf(pState->out, \"CREATE TABLE IF NOT EXISTS %s;\\n\",",
          "6674:           &zCreateTable[12]",
          "6675:       );",
          "6676:     }",
          "6677:     shellFinalize(&rc, pStmt);",
          "6678:   }",
          "6682:   shellPrepare(pState->db, &rc,",
          "6683:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map\"",
          "6684:       \"  WHERE root>1 AND root NOT IN (SELECT rootpage FROM recovery.schema)\"",
          "6685:       , &pLoop",
          "6686:   );",
          "6687:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6688:     nOrphan = sqlite3_column_int(pLoop, 0);",
          "6689:   }",
          "6690:   shellFinalize(&rc, pLoop);",
          "6691:   pLoop = 0;",
          "6692:   pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "6694:   shellPrepare(pState->db, &rc,",
          "6695:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "6696:   );",
          "6697:   shellPrepare(pState->db, &rc,",
          "6698:       \"SELECT max(field), group_concat(shell_escape_crnl(quote(value)), ', ')\"",
          "6699:       \"FROM sqlite_dbdata WHERE pgno = ? AND field != ?\"",
          "6700:       \"GROUP BY cell\", &pCells",
          "6701:   );",
          "6704:   shellPrepare(pState->db, &rc,",
          "6705:       \"SELECT root, intkey, max(maxlen) FROM recovery.map\"",
          "6706:       \" WHERE root>1 GROUP BY root, intkey ORDER BY root=(\"",
          "6707:       \"  SELECT rootpage FROM recovery.schema WHERE name='sqlite_sequence'\"",
          "6708:       \")\", &pLoop",
          "6709:   );",
          "6710:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6711:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6712:     int bIntkey = sqlite3_column_int(pLoop, 1);",
          "6713:     int nCol = sqlite3_column_int(pLoop, 2);",
          "6714:     int bNoop = 0;",
          "6715:     RecoverTable *pTab;",
          "6717:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6718:     if( bNoop || rc ) continue;",
          "6719:     if( pTab==0 ) pTab = pOrphan;",
          "6721:     if( 0==sqlite3_stricmp(pTab->zQuoted, \"'sqlite_sequence'\") ){",
          "6722:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6723:     }",
          "6724:     sqlite3_bind_int(pPages, 1, iRoot);",
          "6725:     sqlite3_bind_int(pCells, 2, pTab->iPk);",
          "6727:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){",
          "6728:       int iPgno = sqlite3_column_int(pPages, 0);",
          "6729:       sqlite3_bind_int(pCells, 1, iPgno);",
          "6730:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6731:         int nField = sqlite3_column_int(pCells, 0);",
          "6732:         const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6734:         nField = nField+1;",
          "6735:         if( pTab==pOrphan ){",
          "6736:           raw_printf(pState->out,",
          "6737:               \"INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\\n\",",
          "6738:               pTab->zQuoted, iRoot, iPgno, nField,",
          "6739:               bIntkey ? \"\" : \"NULL, \", zVal, pTab->azlCol[nField]",
          "6740:           );",
          "6741:         }else{",
          "6742:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6743:               pTab->zQuoted, pTab->azlCol[nField], zVal",
          "6744:           );",
          "6745:         }",
          "6746:       }",
          "6747:       shellReset(&rc, pCells);",
          "6748:     }",
          "6749:     shellReset(&rc, pPages);",
          "6750:     if( pTab!=pOrphan ) recoverFreeTable(pTab);",
          "6751:   }",
          "6752:   shellFinalize(&rc, pLoop);",
          "6753:   shellFinalize(&rc, pPages);",
          "6754:   shellFinalize(&rc, pCells);",
          "6755:   recoverFreeTable(pOrphan);",
          "6758:   if( rc==SQLITE_OK ){",
          "6759:     sqlite3_stmt *pStmt = 0;",
          "6760:     shellPrepare(pState->db, &rc,",
          "6761:         \"SELECT sql, name FROM recovery.schema \"",
          "6762:         \"WHERE sql NOT LIKE 'create table%'\", &pStmt",
          "6763:     );",
          "6764:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6765:       const char *zSql = (const char*)sqlite3_column_text(pStmt, 0);",
          "6766:       if( sqlite3_strnicmp(zSql, \"create virt\", 11)==0 ){",
          "6767:         const char *zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6768:         char *zPrint = shellMPrintf(&rc,",
          "6769:           \"INSERT INTO sqlite_master VALUES('table', %Q, %Q, 0, %Q)\",",
          "6770:           zName, zName, zSql",
          "6771:         );",
          "6772:         raw_printf(pState->out, \"%s;\\n\", zPrint);",
          "6773:         sqlite3_free(zPrint);",
          "6774:       }else{",
          "6775:         raw_printf(pState->out, \"%s;\\n\", zSql);",
          "6776:       }",
          "6777:     }",
          "6778:     shellFinalize(&rc, pStmt);",
          "6779:   }",
          "6781:   if( rc==SQLITE_OK ){",
          "6782:     raw_printf(pState->out, \"PRAGMA writable_schema = off;\\n\");",
          "6783:     raw_printf(pState->out, \"COMMIT;\\n\");",
          "6784:   }",
          "6785:   sqlite3_exec(pState->db, \"DETACH recovery\", 0, 0, 0);",
          "6786:   return rc;",
          "6787: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6313:     rc = shell_dbinfo_command(p, nArg, azArg);",
          "6314:   }else",
          "6316:   if( c=='d' && strncmp(azArg[0], \"dump\", n)==0 ){",
          "6317:     const char *zLike = 0;",
          "6318:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7077: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "7078:   if( c=='r' && strncmp(azArg[0], \"recover\", n)==0 ){",
          "7079:     open_db(p, 0);",
          "7080:     rc = recoverDatabaseCmd(p, nArg, azArg);",
          "7081:   }else",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6398:     }",
          "6399:     sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);",
          "6400:     sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);",
          "6402:     p->showHeader = savedShowHeader;",
          "6403:     p->shellFlgs = savedShellFlags;",
          "6404:   }else",
          "",
          "[Removed Lines]",
          "6401:     raw_printf(p->out, p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");",
          "",
          "[Added Lines]",
          "7171:     raw_printf(p->out, p->nErr?\"ROLLBACK; -- due to errors\\n\":\"COMMIT;\\n\");",
          "",
          "---------------"
        ],
        "test/dbdata.test||test/dbdata.test": [
          "File: test/dbdata.test -> test/dbdata.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019-04-11",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this file is testing the sqlite_dbpage virtual table.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix dbdata",
          "19: ifcapable !vtab||!compound {",
          "20:   finish_test",
          "21:   return",
          "22: }",
          "23: db enable_load_extension 1",
          "24: if { [catch { db eval { SELECT load_extension('../dbdata') } }] } {",
          "25:   finish_test",
          "26:   return",
          "27: }",
          "29: do_execsql_test 1.0 {",
          "30:   CREATE TABLE T1(a, b);",
          "31:   INSERT INTO t1(rowid, a ,b) VALUES(5, 'v', 'five');",
          "32:   INSERT INTO t1(rowid, a, b) VALUES(10, 'x', 'ten');",
          "33: }",
          "35: do_execsql_test 1.1 {",
          "36:   SELECT pgno, cell, field, quote(value) FROM sqlite_dbdata WHERE pgno=2;",
          "37: } {",
          "38:   2 0 -1 5",
          "39:   2 0  0 'v'",
          "40:   2 0  1 'five'",
          "41:   2 1 -1 10",
          "42:   2 1  0 'x'",
          "43:   2 1  1 'ten'",
          "44: }",
          "46: breakpoint",
          "47: do_execsql_test 1.2 {",
          "48:   SELECT pgno, cell, field, quote(value) FROM sqlite_dbdata;",
          "49: } {",
          "50:   1 0 -1 1",
          "51:   1 0 0 'table'",
          "52:   1 0 1 'T1'",
          "53:   1 0 2 'T1'",
          "54:   1 0 3 2",
          "55:   1 0 4 {'CREATE TABLE T1(a, b)'}",
          "56:   2 0 -1 5",
          "57:   2 0  0 'v'",
          "58:   2 0  1 'five'",
          "59:   2 1 -1 10",
          "60:   2 1  0 'x'",
          "61:   2 1  1 'ten'",
          "62: }",
          "64: set big [string repeat big 2000]",
          "65: do_execsql_test 1.3 {",
          "66:   INSERT INTO t1 VALUES(NULL, $big);",
          "67:   SELECT value FROM sqlite_dbdata WHERE pgno=2 AND cell=2 AND field=1;",
          "68: } $big",
          "70: do_execsql_test 1.4 {",
          "71:   DELETE FROM t1;",
          "72:   INSERT INTO t1 VALUES(NULL, randomblob(5050));",
          "73: }",
          "74: do_test 1.5 {",
          "75:   execsql {",
          "76:     SELECT quote(value) FROM sqlite_dbdata WHERE pgno=2 AND cell=0 AND field=1;",
          "77:   }",
          "78: } [db one {SELECT quote(b) FROM t1}]",
          "80: #-------------------------------------------------------------------------",
          "81: reset_db",
          "82: db enable_load_extension 1",
          "83: db eval { SELECT load_extension('../dbdata') }",
          "85: do_execsql_test 2.0 {",
          "86:   CREATE TABLE t1(a);",
          "87:   CREATE INDEX i1 ON t1(a);",
          "88:   WITH s(i) AS (",
          "89:     SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<10",
          "90:   )",
          "91:   INSERT INTO t1 SELECT randomblob(900) FROM s;",
          "92: }",
          "94: do_execsql_test 2.1 {",
          "95:   SELECT * FROM sqlite_dbptr WHERE pgno=2;",
          "96: } {",
          "97:   2 25   2 6   2 7   2 9   2 11   2 13   2 15   2 17   2 19   2 21",
          "98: }",
          "100: do_execsql_test 2.2 {",
          "101:   SELECT * FROM sqlite_dbptr WHERE pgno=3;",
          "102: } {",
          "103:   3 24   3 23",
          "104: }",
          "106: do_execsql_test 2.3 {",
          "107:   SELECT * FROM sqlite_dbptr",
          "108: } {",
          "109:   2 25   2 6   2 7   2 9   2 11   2 13   2 15   2 17   2 19   2 21",
          "110:   3 24   3 23",
          "111: }",
          "114: finish_test",
          "",
          "---------------"
        ],
        "test/recover.test||test/recover.test": [
          "File: test/recover.test -> test/recover.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 April 23",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # Test the shell tool \".ar\" command.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix recover",
          "19: ifcapable !vtab {",
          "20:   finish_test; return",
          "21: }",
          "22: set CLI [test_find_cli]",
          "24: proc compare_result {db1 db2 sql} {",
          "25:   set r1 [$db1 eval $sql]",
          "26:   set r2 [$db2 eval $sql]",
          "27:   if {$r1 != $r2} {",
          "28:   puts \"r1: $r1\"",
          "29:   puts \"r2: $r2\"",
          "30:     error \"mismatch for $sql\"",
          "31:   }",
          "32:   return \"\"",
          "33: }",
          "35: proc compare_dbs {db1 db2} {",
          "36:   compare_result $db1 $db2 \"SELECT sql FROM sqlite_master ORDER BY 1\"",
          "37:   foreach tbl [$db1 eval {SELECT name FROM sqlite_master WHERE type='table'}] {",
          "38:     compare_result $db1 $db2 \"SELECT * FROM $tbl\"",
          "39:   }",
          "40: }",
          "42: proc do_recover_test {tn {tsql {}} {res {}}} {",
          "43:   set fd [open \"|$::CLI test.db .recover\"]",
          "44:   fconfigure $fd -encoding binary",
          "45:   fconfigure $fd -translation binary",
          "46:   set sql [read $fd]",
          "47:   close $fd",
          "49:   forcedelete test.db2",
          "50:   sqlite3 db2 test.db2",
          "51:   execsql $sql db2",
          "52:   if {$tsql==\"\"} {",
          "53:     uplevel [list do_test $tn [list compare_dbs db db2] {}]",
          "54:   } else {",
          "55:     uplevel [list do_execsql_test -db db2 $tn $tsql $res]",
          "56:   }",
          "57:   db2 close",
          "58: }",
          "60: set doc {",
          "61:   hello",
          "62:   world",
          "63: }",
          "64: do_execsql_test 1.1.1 {",
          "65:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "66:   INSERT INTO t1 VALUES(1, 4, X'1234567800');",
          "67:   INSERT INTO t1 VALUES(2, 'test', 8.1);",
          "68:   INSERT INTO t1 VALUES(3, $doc, 8.4);",
          "69: }",
          "70: do_recover_test 1.1.2",
          "72: do_execsql_test 1.2.1 \"",
          "73:   DELETE FROM t1;",
          "74:   INSERT INTO t1 VALUES(13, 'hello\\r\\nworld', 13);",
          "75: \"",
          "76: do_recover_test 1.2.2",
          "78: do_execsql_test 1.3.1 \"",
          "79:   CREATE TABLE t2(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "80:   INSERT INTO t2 VALUES(NULL, 1, 2);",
          "81:   INSERT INTO t2 VALUES(NULL, 3, 4);",
          "82:   INSERT INTO t2 VALUES(NULL, 5, 6);",
          "83:   CREATE TABLE t3(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "84:   INSERT INTO t3 VALUES(NULL, 1, 2);",
          "85:   INSERT INTO t3 VALUES(NULL, 3, 4);",
          "86:   INSERT INTO t3 VALUES(NULL, 5, 6);",
          "87:   DELETE FROM t2;",
          "88: \"",
          "89: do_recover_test 1.3.2",
          "91: #-------------------------------------------------------------------------",
          "92: reset_db",
          "93: do_execsql_test 2.1.0 {",
          "94:   CREATE TABLE t1(a, b, c, PRIMARY KEY(b, c)) WITHOUT ROWID;",
          "95:   INSERT INTO t1 VALUES(1, 2, 3);",
          "96:   INSERT INTO t1 VALUES(4, 5, 6);",
          "97:   INSERT INTO t1 VALUES(7, 8, 9);",
          "98: }",
          "100: do_recover_test 2.1.1",
          "102: do_execsql_test 2.2.0 {",
          "103:   PRAGMA writable_schema = 1;",
          "104:   DELETE FROM sqlite_master WHERE name='t1';",
          "105: }",
          "106: do_recover_test 2.2.1 {",
          "107:   SELECT name FROM sqlite_master",
          "108: } {lost_and_found}",
          "110: do_execsql_test 2.3.0 {",
          "111:   CREATE TABLE lost_and_found(a, b, c);",
          "112: }",
          "113: do_recover_test 2.3.1 {",
          "114:   SELECT name FROM sqlite_master",
          "115: } {lost_and_found lost_and_found_0}",
          "117: do_execsql_test 2.4.0 {",
          "118:   CREATE TABLE lost_and_found_0(a, b, c);",
          "119: }",
          "120: do_recover_test 2.4.1 {",
          "121:   SELECT name FROM sqlite_master;",
          "122:   SELECT * FROM lost_and_found_1;",
          "123: } {lost_and_found lost_and_found_0 lost_and_found_1",
          "124:   2 2 3 {} 2 3 1",
          "125:   2 2 3 {} 5 6 4",
          "126:   2 2 3 {} 8 9 7",
          "127: }",
          "129: finish_test",
          "",
          "---------------"
        ],
        "tool/mkshellc.tcl||tool/mkshellc.tcl": [
          "File: tool/mkshellc.tcl -> tool/mkshellc.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   }",
          "41:   return $line",
          "42: }",
          "43: while {1} {",
          "44:   set lx [omit_redundant_typedefs [gets $in]]",
          "45:   if {[eof $in]} break;",
          "46:   if {[regexp {^INCLUDE } $lx]} {",
          "47:     set cfile [lindex $lx 1]",
          "48:     puts $out \"/************************* Begin $cfile ******************/\"",
          "49:     set in2 [open $topdir/src/$cfile rb]",
          "50:     while {![eof $in2]} {",
          "51:       set lx [omit_redundant_typedefs [gets $in2]]",
          "53:       if {[regexp {^# *include \"test_windirent.h\"} $lx]} {",
          "54:         set lx \"/* $lx */\"",
          "55:       }",
          "",
          "[Removed Lines]",
          "52:       if {[regexp {^#include \"sqlite} $lx]} continue",
          "",
          "[Added Lines]",
          "43: set iLine 0",
          "47:   incr iLine",
          "51: #   puts $out \"#line 1 \\\"$cfile\\\"\"",
          "55:       if {[regexp {^#include \"sqlite} $lx]} {",
          "56:         set lx \"/* $lx */\"",
          "57:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     }",
          "59:     close $in2",
          "60:     puts $out \"/************************* End $cfile ********************/\"",
          "61:     continue",
          "62:   }",
          "63:   puts $out $lx",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: #   puts $out \"#line [expr $iLine+1] \\\"shell.c.in\\\"\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "97c8cb3ed8adb0867db29dbc24b2df9d35fb1d88",
      "candidate_info": {
        "commit_hash": "97c8cb3ed8adb0867db29dbc24b2df9d35fb1d88",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/97c8cb3ed8adb0867db29dbc24b2df9d35fb1d88",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/vdbe.c",
          "test/window1.test"
        ],
        "message": "Ensure that when a new cursor is opened by OP_OpenDup, any existing cursor with the same id opened by a previous OP_OpenDup is closed first.\n\nFossilOrigin-Name: 5c188361a91407805c0feb4bf6d3214522ce3e55013efcf63a4613ecd416bcbc",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/vdbe.c||src/vdbe.c",
          "test/window1.test||test/window1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: f7e6cdc5625664f449d0edbe39af2d45910c4137bfd856ae1f770dd826c138ff",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4416:     sqlite3_free(pCur->aOverflow);",
          "4417:     sqlite3_free(pCur->pKey);",
          "4418:     sqlite3BtreeLeave(pBtree);",
          "4419:   }",
          "4420:   return SQLITE_OK;",
          "4421: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4419:     pCur->pBtree = 0;",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:   assert( iCur>=0 && iCur<p->nCursor );",
          "243:     sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);",
          "244:     p->apCsr[iCur] = 0;",
          "245:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "247:     p->apCsr[iCur]->isEphemeral = 0;",
          "",
          "---------------"
        ],
        "test/window1.test||test/window1.test": [
          "File: test/window1.test -> test/window1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "665:   ) FROM t1;",
          "666: } {a 3 b 3 c 3}",
          "668: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "668: do_execsql_test 15.2 {",
          "669:   SELECT(",
          "670:     WITH c AS(",
          "671:       VALUES(1)",
          "672:     ) SELECT '' FROM c,c",
          "673:   ) x WHERE x+x;",
          "674: } {}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
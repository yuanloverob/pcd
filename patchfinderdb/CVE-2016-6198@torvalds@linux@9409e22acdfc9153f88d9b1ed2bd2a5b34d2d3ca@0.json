{
  "cve_id": "CVE-2016-6198",
  "cve_desc": "The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.",
  "repo": "torvalds/linux",
  "patch_hash": "9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca",
  "patch_info": {
    "commit_hash": "9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca",
    "files": [
      "fs/namei.c"
    ],
    "message": "vfs: rename: check backing inode being equal\n\nIf a file is renamed to a hardlink of itself POSIX specifies that rename(2)\nshould do nothing and return success.\n\nThis condition is checked in vfs_rename().  However it won't detect hard\nlinks on overlayfs where these are given separate inodes on the overlayfs\nlayer.\n\nOverlayfs itself detects this condition and returns success without doing\nanything, but then vfs_rename() will proceed as if this was a successful\nrename (detach_mounts(), d_move()).\n\nThe correct thing to do is to detect this condition before even calling\ninto overlayfs.  This patch does this by calling vfs_select_inode() to get\nthe underlying inodes.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\nCc: <stable@vger.kernel.org> # v4.2+",
    "before_after_code_files": [
      "fs/namei.c||fs/namei.c"
    ]
  },
  "patch_diff": {
    "fs/namei.c||fs/namei.c": [
      "File: fs/namei.c -> fs/namei.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4213:  bool new_is_dir = false;",
      "4214:  unsigned max_links = new_dir->i_sb->s_max_links;",
      "4217:   return 0;",
      "4219:  error = may_delete(old_dir, old_dentry, is_dir);",
      "",
      "[Removed Lines]",
      "4216:  if (source == target)",
      "",
      "[Added Lines]",
      "4220:  if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2d902671ce1cd98cdc88d78c481889a1b2996101",
      "candidate_info": {
        "commit_hash": "2d902671ce1cd98cdc88d78c481889a1b2996101",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2d902671ce1cd98cdc88d78c481889a1b2996101",
        "files": [
          "fs/dcache.c",
          "fs/namei.c",
          "fs/open.c",
          "fs/overlayfs/inode.c",
          "fs/overlayfs/overlayfs.h",
          "fs/overlayfs/super.c",
          "include/linux/dcache.h",
          "include/linux/fs.h"
        ],
        "message": "vfs: merge .d_select_inode() into .d_real()\n\nThe two methods essentially do the same: find the real dentry/inode\nbelonging to an overlay dentry.  The difference is in the usage:\n\nvfs_open() uses ->d_select_inode() and expects the function to perform\ncopy-up if necessary based on the open flags argument.\n\nfile_dentry() uses ->d_real() passing in the overlay dentry as well as the\nunderlying inode.\n\nvfs_rename() uses ->d_select_inode() but passes zero flags.  ->d_real()\nwith a zero inode would have worked just as well here.\n\nThis patch merges the functionality of ->d_select_inode() into ->d_real()\nby adding an 'open_flags' argument to the latter.\n\n[Al Viro] Make the signature of d_real() match that of ->d_real() again.\nAnd constify the inode argument, while we are at it.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>",
        "before_after_code_files": [
          "fs/dcache.c||fs/dcache.c",
          "fs/namei.c||fs/namei.c",
          "fs/open.c||fs/open.c",
          "fs/overlayfs/inode.c||fs/overlayfs/inode.c",
          "fs/overlayfs/overlayfs.h||fs/overlayfs/overlayfs.h",
          "fs/overlayfs/super.c||fs/overlayfs/super.c",
          "include/linux/dcache.h||include/linux/dcache.h",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namei.c||fs/namei.c"
          ],
          "candidate": [
            "fs/namei.c||fs/namei.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/dcache.c||fs/dcache.c": [
          "File: fs/dcache.c -> fs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1729:     DCACHE_OP_REVALIDATE |",
          "1730:     DCACHE_OP_WEAK_REVALIDATE |",
          "1731:     DCACHE_OP_DELETE |",
          "1733:     DCACHE_OP_REAL));",
          "1734:  dentry->d_op = op;",
          "1735:  if (!op)",
          "",
          "[Removed Lines]",
          "1732:     DCACHE_OP_SELECT_INODE |",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1746:   dentry->d_flags |= DCACHE_OP_DELETE;",
          "1747:  if (op->d_prune)",
          "1748:   dentry->d_flags |= DCACHE_OP_PRUNE;",
          "1751:  if (op->d_real)",
          "1752:   dentry->d_flags |= DCACHE_OP_REAL;",
          "",
          "[Removed Lines]",
          "1749:  if (op->d_select_inode)",
          "1750:   dentry->d_flags |= DCACHE_OP_SELECT_INODE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/namei.c||fs/namei.c": [
          "File: fs/namei.c -> fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4332:   return 0;",
          "4334:  error = may_delete(old_dir, old_dentry, is_dir);",
          "",
          "[Removed Lines]",
          "4331:  if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))",
          "",
          "[Added Lines]",
          "4331:  if (d_real_inode(old_dentry) == d_real_inode(new_dentry))",
          "",
          "---------------"
        ],
        "fs/open.c||fs/open.c": [
          "File: fs/open.c -> fs/open.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "840: int vfs_open(const struct path *path, struct file *file,",
          "841:       const struct cred *cred)",
          "842: {",
          "848:  file->f_path = *path;",
          "850: }",
          "852: struct file *dentry_open(const struct path *path, int flags,",
          "",
          "[Removed Lines]",
          "843:  struct inode *inode = vfs_select_inode(path->dentry, file->f_flags);",
          "845:  if (IS_ERR(inode))",
          "846:   return PTR_ERR(inode);",
          "849:  return do_dentry_open(file, inode, NULL, cred);",
          "",
          "[Added Lines]",
          "843:  struct dentry *dentry = d_real(path->dentry, NULL, file->f_flags);",
          "845:  if (IS_ERR(dentry))",
          "846:   return PTR_ERR(dentry);",
          "849:  return do_dentry_open(file, d_backing_inode(dentry), NULL, cred);",
          "",
          "---------------"
        ],
        "fs/overlayfs/inode.c||fs/overlayfs/inode.c": [
          "File: fs/overlayfs/inode.c -> fs/overlayfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "325:  return true;",
          "326: }",
          "329: {",
          "331:  struct path realpath;",
          "332:  enum ovl_path_type type;",
          "337:  type = ovl_path_real(dentry, &realpath);",
          "338:  if (ovl_open_need_copy_up(file_flags, type, realpath.dentry)) {",
          "339:   err = ovl_want_write(dentry);",
          "352:  }",
          "358: }",
          "360: static const struct inode_operations ovl_file_inode_operations = {",
          "",
          "[Removed Lines]",
          "328: struct inode *ovl_d_select_inode(struct dentry *dentry, unsigned file_flags)",
          "330:  int err;",
          "334:  if (d_is_dir(dentry))",
          "335:   return d_backing_inode(dentry);",
          "340:   if (err)",
          "341:    return ERR_PTR(err);",
          "343:   if (file_flags & O_TRUNC)",
          "344:    err = ovl_copy_up_truncate(dentry);",
          "345:   else",
          "346:    err = ovl_copy_up(dentry);",
          "347:   ovl_drop_write(dentry);",
          "348:   if (err)",
          "349:    return ERR_PTR(err);",
          "351:   ovl_path_upper(dentry, &realpath);",
          "354:  if (realpath.dentry->d_flags & DCACHE_OP_SELECT_INODE)",
          "355:   return realpath.dentry->d_op->d_select_inode(realpath.dentry, file_flags);",
          "357:  return d_backing_inode(realpath.dentry);",
          "",
          "[Added Lines]",
          "328: int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags)",
          "330:  int err = 0;",
          "337:   if (!err) {",
          "338:    if (file_flags & O_TRUNC)",
          "339:     err = ovl_copy_up_truncate(dentry);",
          "340:    else",
          "341:     err = ovl_copy_up(dentry);",
          "342:    ovl_drop_write(dentry);",
          "343:   }",
          "346:  return err;",
          "",
          "---------------"
        ],
        "fs/overlayfs/overlayfs.h||fs/overlayfs/overlayfs.h": [
          "File: fs/overlayfs/overlayfs.h -> fs/overlayfs/overlayfs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "179:        const char *name, void *value, size_t size);",
          "180: ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);",
          "181: int ovl_removexattr(struct dentry *dentry, const char *name);",
          "184: struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,",
          "185:        struct ovl_entry *oe);",
          "",
          "[Removed Lines]",
          "182: struct inode *ovl_d_select_inode(struct dentry *dentry, unsigned file_flags);",
          "",
          "[Added Lines]",
          "182: int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);",
          "",
          "---------------"
        ],
        "fs/overlayfs/super.c||fs/overlayfs/super.c": [
          "File: fs/overlayfs/super.c -> fs/overlayfs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:  }",
          "305: }",
          "308: {",
          "309:  struct dentry *real;",
          "",
          "[Removed Lines]",
          "307: static struct dentry *ovl_d_real(struct dentry *dentry, struct inode *inode)",
          "",
          "[Added Lines]",
          "307: static struct dentry *ovl_d_real(struct dentry *dentry,",
          "308:      const struct inode *inode,",
          "309:      unsigned int open_flags)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "314:   goto bug;",
          "315:  }",
          "317:  real = ovl_dentry_upper(dentry);",
          "318:  if (real && (!inode || inode == d_inode(real)))",
          "319:   return real;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "319:  if (d_is_negative(dentry))",
          "320:   return dentry;",
          "322:  if (open_flags) {",
          "323:   int err = ovl_open_maybe_copy_up(dentry, open_flags);",
          "325:   if (err)",
          "326:    return ERR_PTR(err);",
          "327:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "326:   return real;",
          "332: bug:",
          "333:  WARN(1, \"ovl_d_real(%pd4, %s:%lu\\n): real dentry not found\\n\", dentry,",
          "334:       inode ? inode->i_sb->s_id : \"NULL\", inode ? inode->i_ino : 0);",
          "",
          "[Removed Lines]",
          "329:  if (real->d_flags & DCACHE_OP_REAL)",
          "330:   return real->d_op->d_real(real, inode);",
          "",
          "[Added Lines]",
          "341:  return d_real(real, inode, open_flags);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "379: static const struct dentry_operations ovl_dentry_operations = {",
          "380:  .d_release = ovl_dentry_release,",
          "382:  .d_real = ovl_d_real,",
          "383: };",
          "385: static const struct dentry_operations ovl_reval_dentry_operations = {",
          "386:  .d_release = ovl_dentry_release,",
          "388:  .d_real = ovl_d_real,",
          "389:  .d_revalidate = ovl_dentry_revalidate,",
          "390:  .d_weak_revalidate = ovl_dentry_weak_revalidate,",
          "",
          "[Removed Lines]",
          "381:  .d_select_inode = ovl_d_select_inode,",
          "387:  .d_select_inode = ovl_d_select_inode,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/dcache.h||include/linux/dcache.h": [
          "File: include/linux/dcache.h -> include/linux/dcache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:  char *(*d_dname)(struct dentry *, char *, int);",
          "140:  struct vfsmount *(*d_automount)(struct path *);",
          "141:  int (*d_manage)(struct dentry *, bool);",
          "144: } ____cacheline_aligned;",
          "",
          "[Removed Lines]",
          "142:  struct inode *(*d_select_inode)(struct dentry *, unsigned);",
          "143:  struct dentry *(*d_real)(struct dentry *, struct inode *);",
          "",
          "[Added Lines]",
          "142:  struct dentry *(*d_real)(struct dentry *, const struct inode *, unsigned int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207: #define DCACHE_MAY_FREE   0x00800000",
          "215: #define DCACHE_DENTRY_CURSOR  0x20000000",
          "",
          "[Removed Lines]",
          "212: #define DCACHE_OP_REAL   0x08000000",
          "",
          "[Added Lines]",
          "209: #define DCACHE_OP_REAL   0x04000000",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "557:  return upper;",
          "558: }",
          "561: {",
          "562:  if (unlikely(dentry->d_flags & DCACHE_OP_REAL))",
          "564:  else",
          "565:   return dentry;",
          "566: }",
          "",
          "[Removed Lines]",
          "560: static inline struct dentry *d_real(struct dentry *dentry)",
          "563:   return dentry->d_op->d_real(dentry, NULL);",
          "568: static inline struct inode *vfs_select_inode(struct dentry *dentry,",
          "569:           unsigned open_flags)",
          "570: {",
          "571:  struct inode *inode = d_inode(dentry);",
          "573:  if (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))",
          "574:   inode = dentry->d_op->d_select_inode(dentry, open_flags);",
          "576:  return inode;",
          "577: }",
          "",
          "[Added Lines]",
          "557: static inline struct dentry *d_real(struct dentry *dentry,",
          "558:         const struct inode *inode,",
          "559:         unsigned int flags)",
          "562:   return dentry->d_op->d_real(dentry, inode, flags);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "586: static inline struct inode *d_real_inode(struct dentry *dentry)",
          "587: {",
          "589: }",
          "",
          "[Removed Lines]",
          "588:  return d_backing_inode(d_real(dentry));",
          "",
          "[Added Lines]",
          "576:  return d_backing_inode(d_real(dentry, NULL, 0));",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1273: static inline struct dentry *file_dentry(const struct file *file)",
          "1274: {",
          "1281: }",
          "1283: static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)",
          "",
          "[Removed Lines]",
          "1275:  struct dentry *dentry = file->f_path.dentry;",
          "1277:  if (unlikely(dentry->d_flags & DCACHE_OP_REAL))",
          "1278:   return dentry->d_op->d_real(dentry, file_inode(file));",
          "1279:  else",
          "1280:   return dentry;",
          "",
          "[Added Lines]",
          "1275:  return d_real(file->f_path.dentry, file_inode(file), 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8d3e2936375bacce6abacbce3917d667e4133409",
      "candidate_info": {
        "commit_hash": "8d3e2936375bacce6abacbce3917d667e4133409",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8d3e2936375bacce6abacbce3917d667e4133409",
        "files": [
          "fs/namei.c"
        ],
        "message": "Revert \"vfs: rename: check backing inode being equal\"\n\nThis reverts commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca.\n\nSince commit 51f7e52dc943 (\"ovl: share inode for hard link\") there's no\nneed to call d_real_inode() to check two overlay inodes for equality.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>",
        "before_after_code_files": [
          "fs/namei.c||fs/namei.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namei.c||fs/namei.c"
          ],
          "candidate": [
            "fs/namei.c||fs/namei.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namei.c||fs/namei.c": [
          "File: fs/namei.c -> fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4345:  bool new_is_dir = false;",
          "4346:  unsigned max_links = new_dir->i_sb->s_max_links;",
          "4353:   return 0;",
          "4355:  error = may_delete(old_dir, old_dentry, is_dir);",
          "",
          "[Removed Lines]",
          "4352:  if (d_real_inode(old_dentry) == d_real_inode(new_dentry))",
          "",
          "[Added Lines]",
          "4348:  if (source == target)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
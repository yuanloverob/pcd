{
  "cve_id": "CVE-2020-36280",
  "cve_desc": "Leptonica before 1.80.0 allows a heap-based buffer over-read in pixReadFromTiffStream, related to tiffio.c.",
  "repo": "DanBloomberg/leptonica",
  "patch_hash": "5ba34b1fe741d69d43a6c8cf767756997eadd87c",
  "patch_info": {
    "commit_hash": "5ba34b1fe741d69d43a6c8cf767756997eadd87c",
    "repo": "DanBloomberg/leptonica",
    "commit_url": "https://github.com/DanBloomberg/leptonica/commit/5ba34b1fe741d69d43a6c8cf767756997eadd87c",
    "files": [
      "prog/dewarptest1.c",
      "src/tiffio.c"
    ],
    "message": "Issue 23654 in oss-fuzz: Heap-buffer-overflow in pixReadFromTiffStream   * Increase scanline buffer for reading gray+alpha and converting to RGBA",
    "before_after_code_files": [
      "prog/dewarptest1.c||prog/dewarptest1.c",
      "src/tiffio.c||src/tiffio.c"
    ]
  },
  "patch_diff": {
    "prog/dewarptest1.c||prog/dewarptest1.c": [
      "File: prog/dewarptest1.c -> prog/dewarptest1.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "53:     setLeptDebugOK(1);",
      "54:     lept_mkdir(\"lept/model\");",
      "57:     pixs = pixRead(\"cat.035.jpg\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "55:     lept_rmdir(\"lept/dewmod\");",
      "56:     lept_mkdir(\"lept/dewmod\");",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "160:                       \"/tmp/lept/dewarptest1.pdf\");",
      "161:     lept_stderr(\"pdf file made: /tmp/lept/model/dewarptest1.pdf\\n\");",
      "165:     pixDestroy(&pixs);",
      "166:     pixDestroy(&pixn);",
      "167:     pixDestroy(&pixg);",
      "",
      "[Removed Lines]",
      "163:     lept_rmdir(\"lept/dewmod\");",
      "164:     lept_rmdir(\"lept/dewtest\");",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/tiffio.c||src/tiffio.c": [
      "File: src/tiffio.c -> src/tiffio.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "603:         L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);",
      "604:         pixSetSpp(pix, 4);",
      "606:         pixdata = pixGetData(pix);",
      "607:         for (i = 0; i < h; i++) {",
      "608:             if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {",
      "",
      "[Removed Lines]",
      "605:         linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));",
      "",
      "[Added Lines]",
      "605:         linebuf = (l_uint8 *)LEPT_CALLOC(2 * tiffbpl + 1, sizeof(l_uint8));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d8b93eb0d1f04bb3a461d5354109a3746fa24783",
      "candidate_info": {
        "commit_hash": "d8b93eb0d1f04bb3a461d5354109a3746fa24783",
        "repo": "DanBloomberg/leptonica",
        "commit_url": "https://github.com/DanBloomberg/leptonica/commit/d8b93eb0d1f04bb3a461d5354109a3746fa24783",
        "files": [
          "prog/adaptmap_reg.c",
          "prog/hash_reg.c",
          "prog/pixa2_reg.c",
          "prog/tiffpdftest.c",
          "src/Makefile.am",
          "src/allheaders.h",
          "src/alltypes.h",
          "src/array.h",
          "src/dnabasic.c",
          "src/dnafunc1.c",
          "src/dnahash.c",
          "src/fhmtauto.c",
          "src/flipdetect.c",
          "src/graphics.c",
          "src/hashmap.c",
          "src/hashmap.h",
          "src/makefile.static",
          "src/pix4.c",
          "src/pixalloc.c",
          "src/ptabasic.c",
          "src/ptafunc1.c",
          "src/ptafunc2.c",
          "src/sarray1.c",
          "src/sarray2.c",
          "src/sel1.c",
          "src/tiffio.c",
          "src/utils1.c",
          "version-notes.html"
        ],
        "message": "Implemented a more general hashmap utility. * Use dnahash only for simple jbig2 classifer application. * Replaced all other uses of dnahash by the new hashmap, with new files:     hashmap.c, hashmap.h. * Implemented the set/intersection/union hashing ops for pta, sarray and dna. * Added a fast string hash that works well. * Removed the float64 to uint64 hash; slow and unnecessary. * More thorough testing in hash_reg.c. * Read and write to memory serialization for dna and dnaa. * Simplify the line buffer allocation for decoding tiff files",
        "before_after_code_files": [
          "prog/adaptmap_reg.c||prog/adaptmap_reg.c",
          "prog/hash_reg.c||prog/hash_reg.c",
          "prog/pixa2_reg.c||prog/pixa2_reg.c",
          "prog/tiffpdftest.c||prog/tiffpdftest.c",
          "src/Makefile.am||src/Makefile.am",
          "src/allheaders.h||src/allheaders.h",
          "src/alltypes.h||src/alltypes.h",
          "src/array.h||src/array.h",
          "src/dnabasic.c||src/dnabasic.c",
          "src/dnafunc1.c||src/dnafunc1.c",
          "src/dnahash.c||src/dnahash.c",
          "src/fhmtauto.c||src/fhmtauto.c",
          "src/flipdetect.c||src/flipdetect.c",
          "src/graphics.c||src/graphics.c",
          "src/hashmap.c||src/hashmap.c",
          "src/hashmap.h||src/hashmap.h",
          "src/makefile.static||src/makefile.static",
          "src/pix4.c||src/pix4.c",
          "src/pixalloc.c||src/pixalloc.c",
          "src/ptabasic.c||src/ptabasic.c",
          "src/ptafunc1.c||src/ptafunc1.c",
          "src/ptafunc2.c||src/ptafunc2.c",
          "src/sarray1.c||src/sarray1.c",
          "src/sarray2.c||src/sarray2.c",
          "src/sel1.c||src/sel1.c",
          "src/tiffio.c||src/tiffio.c",
          "src/utils1.c||src/utils1.c",
          "version-notes.html||version-notes.html"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/tiffio.c||src/tiffio.c"
          ],
          "candidate": [
            "src/tiffio.c||src/tiffio.c"
          ]
        }
      },
      "candidate_diff": {
        "prog/adaptmap_reg.c||prog/adaptmap_reg.c": [
          "File: prog/adaptmap_reg.c -> prog/adaptmap_reg.c"
        ],
        "prog/hash_reg.c||prog/hash_reg.c": [
          "File: prog/hash_reg.c -> prog/hash_reg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: #include \"allheaders.h\"",
          "68: l_int32 main(int    argc,",
          "69:              char **argv)",
          "70: {",
          "72: L_ASET       *set;",
          "79: PIX          *pix1;",
          "80: L_REGPARAMS  *rp;",
          "",
          "[Removed Lines]",
          "64: static SARRAY *BuildShortStrings(l_int32 nchars, l_int32 add_dups);",
          "65: static PTA *BuildPointSet(l_int32 w, l_int32 h, l_int32 add_dups);",
          "71: l_int32       ncolors, c1, c2, c3, s1;",
          "73: L_DNA        *da1, *da2, *da3, *da4, *da5, *da6, *da7, *da8, *dav, *dac;",
          "74: L_DNAHASH    *dahash;",
          "75: GPLOT        *gplot;",
          "76: NUMA         *nav, *nac;",
          "77: PTA          *pta1, *pta2, *pta3;",
          "78: SARRAY       *sa1, *sa2, *sa3, *sa4;",
          "",
          "[Added Lines]",
          "46: static SARRAY *BuildShortStrings(l_int32 nchars);",
          "47: static PTA *BuildPointSet(l_int32 w, l_int32 h);",
          "49: const l_int32  string_set = 10967;",
          "50: const l_int32  string_union = 18278;",
          "51: const l_int32  string_intersection = 3656;",
          "52: const l_int32  pta_set = 150000;",
          "53: const l_int32  pta_union = 250000;",
          "54: const l_int32  pta_intersection = 50001;",
          "55: const l_int32  da_set = 48000;",
          "56: const l_int32  da_union = 80000;",
          "57: const l_int32  da_intersection = 16001;",
          "62: l_uint8      *data1, *data2;",
          "63: l_int32       i, n, c1, c2, s1;",
          "64: size_t        size1, size2;",
          "66: L_DNA        *da0, *da1, *da2, *da3;",
          "67: L_HASHMAP    *hmap;",
          "68: PTA          *pta0, *pta1, *pta2, *pta3;",
          "69: SARRAY       *sa0, *sa1, *sa2, *sa3;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:     lept_mkdir(\"lept/hash\");",
          "90:     c1 = sarrayGetCount(sa1);",
          "91:     c2 = sarrayGetCount(sa2);",
          "100:     set = l_asetCreateFromSarray(sa2);",
          "101:     s1 = l_asetSize(set);",
          "103:     if (rp->display) {",
          "106:     }",
          "107:     l_asetDestroy(&set);",
          "110:     c1 = sarrayGetCount(sa3);",
          "124:     sarrayDestroy(&sa3);",
          "145:     c1 = sarrayGetCount(sa3);",
          "159:     sarrayDestroy(&sa3);",
          "161:     sarrayDestroy(&sa1);",
          "162:     sarrayDestroy(&sa2);",
          "171:     c1 = ptaGetCount(pta1);",
          "172:     c2 = ptaGetCount(pta2);",
          "175:     if (rp->display) {",
          "179:     }",
          "182:     c1 = ptaGetCount(pta3);",
          "188:     ptaDestroy(&pta3);",
          "192:     c1 = ptaGetCount(pta3);",
          "200:     ptaDestroy(&pta3);",
          "218:     c1 = ptaGetCount(pta3);",
          "224:     ptaDestroy(&pta3);",
          "228:     c1 = ptaGetCount(pta3);",
          "234:     ptaDestroy(&pta1);",
          "235:     ptaDestroy(&pta2);",
          "250:     c1 = l_dnaGetCount(da1);",
          "254:     if (rp->display) {",
          "258:     }",
          "264:     if (rp->display)",
          "290:     l_dnaDestroy(&da1);",
          "291:     l_dnaDestroy(&da2);",
          "292:     l_dnaDestroy(&da3);",
          "304:     pix1 = pixRead(\"wet-day.jpg\");",
          "305:     pixCountRGBColorsByHash(pix1, &c1);",
          "306:     pixCountRGBColors(pix1, 1, &c2);",
          "309:     if (rp->display) {",
          "312:     }",
          "313:     pixDestroy(&pix1);",
          "396:     return regTestCleanup(rp);",
          "397: }",
          "401: static SARRAY *",
          "404: {",
          "405: char      buf[64];",
          "406: l_int32   i, j, k, l, m;",
          "",
          "[Removed Lines]",
          "88:     sa1 = BuildShortStrings(3, 0);",
          "89:     sa2 = BuildShortStrings(3, 1);",
          "94:     if (rp->display) {",
          "95:         lept_stderr(\"Set results with string hashing:\\n\");",
          "96:         lept_stderr(\"  size with unique strings: %d\\n\", c1);",
          "97:         lept_stderr(\"  size with dups: %d\\n\", c2);",
          "98:     }",
          "99:     startTimer();",
          "104:         lept_stderr(\"  time to make set: %5.3f sec\\n\", stopTimer());",
          "105:         lept_stderr(\"  size of set without dups: %d\\n\", s1);",
          "108:     startTimer();",
          "109:     sa3 = sarrayRemoveDupsByAset(sa2);",
          "112:     if (rp->display) {",
          "113:         lept_stderr(\"  time to remove dups: %5.3f sec\\n\", stopTimer());",
          "114:         lept_stderr(\"  size without dups = %d\\n\", c1);",
          "115:     }",
          "116:     startTimer();",
          "117:     sa4 = sarrayIntersectionByAset(sa1, sa2);",
          "118:     c1 = sarrayGetCount(sa4);",
          "120:     if (rp->display) {",
          "121:         lept_stderr(\"  time to intersect: %5.3f sec\\n\", stopTimer());",
          "122:         lept_stderr(\"  intersection size = %d\\n\", c1);",
          "123:     }",
          "125:     sarrayDestroy(&sa4);",
          "129:     if (rp->display) {",
          "130:         lept_stderr(\"\\nDna hash results for sarray:\\n\");",
          "131:         lept_stderr(\"  size with unique strings: %d\\n\", sarrayGetCount(sa1));",
          "132:         lept_stderr(\"  size with dups: %d\\n\", sarrayGetCount(sa2));",
          "133:     }",
          "134:     startTimer();",
          "135:     dahash = l_dnaHashCreateFromSarray(sa2);",
          "136:     s1 = l_dnaHashGetTotalCount(dahash);",
          "138:     if (rp->display) {",
          "139:         lept_stderr(\"  time to make hashmap: %5.3f sec\\n\", stopTimer());",
          "140:         lept_stderr(\"  entries in hashmap with dups: %d\\n\", s1);",
          "141:     }",
          "142:     l_dnaHashDestroy(&dahash);",
          "143:     startTimer();",
          "144:     sarrayRemoveDupsByHash(sa2, &sa3, NULL);",
          "147:     if (rp->display) {",
          "148:         lept_stderr(\"  time to remove dups: %5.3f sec\\n\", stopTimer());",
          "149:         lept_stderr(\"  size without dups = %d\\n\", c1);",
          "150:     }",
          "151:     startTimer();",
          "152:     sa4 = sarrayIntersectionByHash(sa1, sa2);",
          "153:     c1 = sarrayGetCount(sa4);",
          "155:     if (rp->display) {",
          "156:         lept_stderr(\"  time to intersect: %5.3f sec\\n\", stopTimer());",
          "157:         lept_stderr(\"  intersection size = %d\\n\", c1);",
          "158:     }",
          "160:     sarrayDestroy(&sa4);",
          "169:     pta1 = BuildPointSet(300, 300, 0);",
          "170:     pta2 = BuildPointSet(300, 300, 1);",
          "176:         lept_stderr(\"\\nSet results for pta:\\n\");",
          "177:         lept_stderr(\"  pta1 size with unique points: %d\\n\", c1);",
          "178:         lept_stderr(\"  pta2 size with dups: %d\\n\", c2);",
          "180:     startTimer();",
          "181:     pta3 = ptaRemoveDupsByAset(pta2);",
          "184:     if (rp->display) {",
          "185:         lept_stderr(\"  Time to remove dups: %5.3f sec\\n\", stopTimer());",
          "186:         lept_stderr(\"  size without dups = %d\\n\", ptaGetCount(pta3));",
          "187:     }",
          "190:     startTimer();",
          "191:     pta3 = ptaIntersectionByAset(pta1, pta2);",
          "194:     if (rp->display) {",
          "195:         lept_stderr(\"  Time to intersect: %5.3f sec\\n\", stopTimer());",
          "196:         lept_stderr(\"  intersection size = %d\\n\", c1);",
          "197:     }",
          "198:     ptaDestroy(&pta1);",
          "199:     ptaDestroy(&pta2);",
          "205:     pta1 = BuildPointSet(400, 400, 0);",
          "206:     pta2 = BuildPointSet(400, 400, 1);",
          "207:     c1 = ptaGetCount(pta1);",
          "208:     c2 = ptaGetCount(pta2);",
          "211:     if (rp->display) {",
          "212:         lept_stderr(\"\\nDna hash results for pta:\\n\");",
          "213:         lept_stderr(\"  pta1 size with unique points: %d\\n\", c1);",
          "214:         lept_stderr(\"  pta2 size with dups: %d\\n\", c2);",
          "215:     }",
          "216:     startTimer();",
          "217:     ptaRemoveDupsByHash(pta2, &pta3, NULL);",
          "220:     if (rp->display) {",
          "221:         lept_stderr(\"  Time to remove dups: %5.3f sec\\n\", stopTimer());",
          "222:         lept_stderr(\"  size without dups = %d\\n\", c1);",
          "223:     }",
          "226:     startTimer();",
          "227:     pta3 = ptaIntersectionByHash(pta1, pta2);",
          "230:     if (rp->display) {",
          "231:         lept_stderr(\"  Time to intersect: %5.3f sec\\n\", stopTimer());",
          "232:         lept_stderr(\"  intersection size = %d\\n\", c1);",
          "233:     }",
          "236:     ptaDestroy(&pta3);",
          "239:     da1 = l_dnaMakeSequence(0.0, 0.125, 8000);",
          "240:     da2 = l_dnaMakeSequence(300.0, 0.125, 8000);",
          "241:     da3 = l_dnaMakeSequence(600.0, 0.125, 8000);",
          "242:     da4 = l_dnaMakeSequence(900.0, 0.125, 8000);",
          "243:     da5 = l_dnaMakeSequence(1200.0, 0.125, 8000);",
          "244:     l_dnaJoin(da1, da2, 0, -1);",
          "245:     l_dnaJoin(da1, da3, 0, -1);",
          "246:     l_dnaJoin(da1, da4, 0, -1);",
          "247:     l_dnaJoin(da1, da5, 0, -1);",
          "248:     l_dnaRemoveDupsByHash(da1, &da6, &dahash);",
          "249:     l_dnaHashDestroy(&dahash);",
          "251:     c2 = l_dnaGetCount(da6);",
          "255:         lept_stderr(\"\\nDna hash results for dna:\\n\");",
          "256:         lept_stderr(\"  dna size with dups = %d\\n\", c1);",
          "257:         lept_stderr(\"  dna size of unique numbers = %d\\n\", c2);",
          "259:     l_dnaMakeHistoByHash(da1, &dahash, &dav, &dac);",
          "260:     nav = l_dnaConvertToNuma(dav);",
          "261:     nac = l_dnaConvertToNuma(dac);",
          "262:     c1 = l_dnaGetCount(dac);",
          "265:         lept_stderr(\"  dna number of histo points = %d\\n\", c1);",
          "268:     pix1 = gplotGeneralPix2(nav, nac, GPLOT_IMPULSES, \"/tmp/lept/hash/histo\",",
          "269:                             \"Histo\", NULL, NULL);",
          "270:     gplot = gplotSimpleXY1(nav, nac, GPLOT_IMPULSES, GPLOT_PNG,",
          "271:                            \"/tmp/lept/hash/histo\", \"Histo\");",
          "272:     if (rp->display) {",
          "273:         pixDisplay(pix1, 700, 100);",
          "274:         l_fileDisplay(\"/tmp/lept/hash/histo.png\", 700, 600, 1.0);",
          "275:     }",
          "276:     pixDestroy(&pix1);",
          "277:     gplotDestroy(&gplot);",
          "279:     da7 = l_dnaIntersectionByHash(da2, da3);",
          "280:     c1 = l_dnaGetCount(da2);",
          "281:     c2 = l_dnaGetCount(da3);",
          "282:     c3 = l_dnaGetCount(da7);",
          "286:     if (rp->display) {",
          "287:         lept_stderr(\"  dna num points: da2 = %d, da3 = %d\\n\", c1, c2);",
          "288:         lept_stderr(\"  dna num da2/da3 intersection points = %d\\n\", c3);",
          "289:     }",
          "293:     l_dnaDestroy(&da4);",
          "294:     l_dnaDestroy(&da5);",
          "295:     l_dnaDestroy(&da6);",
          "296:     l_dnaDestroy(&da7);",
          "297:     l_dnaDestroy(&dac);",
          "298:     l_dnaDestroy(&dav);",
          "299:     l_dnaHashDestroy(&dahash);",
          "300:     numaDestroy(&nav);",
          "301:     numaDestroy(&nac);",
          "310:         lept_stderr(\"\\nColor count using dna hash: %d\\n\", c1);",
          "311:         lept_stderr(\"Color count using amap: %d\\n\", c2);",
          "316:     da1 = l_dnaMakeSequence(0, 3, 10000);",
          "317:     da2 = l_dnaMakeSequence(0, 5, 10000);",
          "318:     da3 = l_dnaMakeSequence(0, 7, 10000);",
          "319:     l_dnaJoin(da1, da2, 0, -1);",
          "320:     l_dnaJoin(da1, da3, 0, -1);",
          "321:     set = l_asetCreateFromDna(da1);",
          "322:     c1 = l_dnaGetCount(da1);",
          "323:     c2 = l_asetSize(set);",
          "326:     if (rp->display) {",
          "327:         lept_stderr(\"\\nDna results using set:\\n\");",
          "328:         lept_stderr(\"  da1 count: %d\\n\", c1);",
          "329:         lept_stderr(\"  da1 set size: %d\\n\\n\", c2);",
          "330:     }",
          "331:     l_asetDestroy(&set);",
          "333:     da4 = l_dnaUnionByAset(da2, da3);",
          "334:     set = l_asetCreateFromDna(da4);",
          "335:     c1 = l_dnaGetCount(da4);",
          "336:     c2 = l_asetSize(set);",
          "339:     if (rp->display) {",
          "340:         lept_stderr(\"  da4 count: %d\\n\", c1);",
          "341:         lept_stderr(\"  da4 set size: %d\\n\\n\", c2);",
          "342:     }",
          "343:     l_asetDestroy(&set);",
          "345:     da5 = l_dnaIntersectionByAset(da1, da2);",
          "346:     set = l_asetCreateFromDna(da5);",
          "347:     c1 = l_dnaGetCount(da5);",
          "348:     c2 = l_asetSize(set);",
          "351:     if (rp->display) {",
          "352:         lept_stderr(\"  da5 count: %d\\n\", c1);",
          "353:         lept_stderr(\"  da5 set size: %d\\n\\n\", c2);",
          "354:     }",
          "355:     l_asetDestroy(&set);",
          "357:     da6 = l_dnaMakeSequence(100000, 11, 5000);",
          "358:     l_dnaJoin(da6, da1, 0, -1);",
          "359:     set = l_asetCreateFromDna(da6);",
          "360:     c1 = l_dnaGetCount(da6);",
          "361:     c2 = l_asetSize(set);",
          "364:     if (rp->display) {",
          "365:         lept_stderr(\"  da6 count: %d\\n\", c1);",
          "366:         lept_stderr(\"  da6 set size: %d\\n\\n\", c2);",
          "367:     }",
          "368:     l_asetDestroy(&set);",
          "370:     da7 = l_dnaIntersectionByAset(da6, da3);",
          "371:     set = l_asetCreateFromDna(da7);",
          "372:     c1 = l_dnaGetCount(da7);",
          "373:     c2 = l_asetSize(set);",
          "376:     if (rp->display) {",
          "377:         lept_stderr(\"  da7 count: %d\\n\", c1);",
          "378:         lept_stderr(\"  da7 set size: %d\\n\\n\", c2);",
          "379:     }",
          "380:     l_asetDestroy(&set);",
          "382:     da8 = l_dnaRemoveDupsByAset(da1);",
          "383:     c1 = l_dnaGetCount(da8);",
          "385:     if (rp->display)",
          "386:         lept_stderr(\"  da8 count: %d\\n\\n\", c1);",
          "387:     l_dnaDestroy(&da1);",
          "388:     l_dnaDestroy(&da2);",
          "389:     l_dnaDestroy(&da3);",
          "390:     l_dnaDestroy(&da4);",
          "391:     l_dnaDestroy(&da5);",
          "392:     l_dnaDestroy(&da6);",
          "393:     l_dnaDestroy(&da7);",
          "394:     l_dnaDestroy(&da8);",
          "403:                   l_int32  add_dups)",
          "",
          "[Added Lines]",
          "79:     sa0 = BuildShortStrings(3);",
          "80:     n = sarrayGetCount(sa0);",
          "81:     sa1 = sarraySelectRange(sa0, 0, 0.6 * n);",
          "91:         lept_stderr(\"String operations\\n  c1 = %d, c2 = %d\\n\", c1, c2);",
          "92:         lept_stderr(\"  aset: size of set without dups: %d\\n\", s1);",
          "95:     sarrayRemoveDupsByAset(sa2, &sa3);",
          "99:     if (rp->display)",
          "100:         lept_stderr(\"  aset: size without dups = %d\\n\", c1);",
          "101:     sarrayIntersectionByAset(sa1, sa2, &sa3);",
          "102:     c1 = sarrayGetCount(sa3);",
          "103:     sarrayDestroy(&sa3);",
          "105:     if (rp->display)",
          "106:         lept_stderr(\"  aset: intersection size = %d\\n\", c1);",
          "107:     sarrayUnionByAset(sa1, sa2, &sa3);",
          "108:     c1 = sarrayGetCount(sa3);",
          "109:     sarrayDestroy(&sa3);",
          "111:     if (rp->display)",
          "112:         lept_stderr(\"  aset: union size = %d\\n\", c1);",
          "115:     hmap = l_hmapCreateFromSarray(sa1);",
          "116:     c1 = hmap->nitems;",
          "118:     if (rp->display) lept_stderr(\"  hmap: set size without dups: %d\\n\", c1);",
          "119:     l_hmapDestroy(&hmap);",
          "121:     sarrayRemoveDupsByHmap(sa2, &sa3, NULL);",
          "125:     if (rp->display)",
          "126:         lept_stderr(\"  hmap: size without dups = %d\\n\", c1);",
          "127:     sarrayIntersectionByHmap(sa1, sa2, &sa3);",
          "128:     c1 = sarrayGetCount(sa3);",
          "129:     sarrayDestroy(&sa3);",
          "131:     if (rp->display)",
          "132:         lept_stderr(\"  hmap: intersection size = %d\\n\", c1);",
          "133:     sarrayUnionByHmap(sa1, sa2, &sa3);",
          "134:     c1 = sarrayGetCount(sa3);",
          "135:     sarrayDestroy(&sa3);",
          "137:     if (rp->display)",
          "138:         lept_stderr(\"  hmap: union size = %d\\n\", c1);",
          "139:     sarrayDestroy(&sa3);",
          "140:     sarrayDestroy(&sa0);",
          "145:     pta0 = BuildPointSet(500, 500);",
          "146:     n = ptaGetCount(pta0);",
          "147:     pta1 = ptaSelectRange(pta0, 0, 0.6 * n);",
          "153:     set = l_asetCreateFromPta(pta2);",
          "154:     s1 = l_asetSize(set);",
          "155:     l_asetDestroy(&set);",
          "158:         lept_stderr(\"Pt array operations\\n  c1 = %d, c2 = %d\\n\", c1, c2);",
          "159:         lept_stderr(\"  aset: size of set without dups: %d\\n\", s1);",
          "161:     ptaRemoveDupsByAset(pta2, &pta3);",
          "165:     if (rp->display)",
          "166:         lept_stderr(\"  aset: size without dups = %d\\n\", c1);",
          "167:     ptaIntersectionByAset(pta1, pta2, &pta3);",
          "171:     if (rp->display)",
          "172:         lept_stderr(\"  aset: intersection size = %d\\n\", c1);",
          "173:     ptaUnionByAset(pta1, pta2, &pta3);",
          "177:     if (rp->display)",
          "178:         lept_stderr(\"  aset: union size = %d\\n\", c1);",
          "181:     hmap = l_hmapCreateFromPta(pta2);",
          "182:     c1 = hmap->nitems;",
          "184:     if (rp->display) lept_stderr(\"  hmap: set size without dups: %d\\n\", c1);",
          "185:     l_hmapDestroy(&hmap);",
          "186:     ptaRemoveDupsByHmap(pta2, &pta3, NULL);",
          "188:     ptaDestroy(&pta3);",
          "190:     if (rp->display)",
          "191:         lept_stderr(\"  hmap: size without dups = %d\\n\", c1);",
          "192:     ptaIntersectionByHmap(pta1, pta2, &pta3);",
          "193:     c1 = ptaGetCount(pta3);",
          "194:     ptaDestroy(&pta3);",
          "196:     if (rp->display)",
          "197:         lept_stderr(\"  hmap: intersection size = %d\\n\", c1);",
          "198:     ptaUnionByHmap(pta1, pta2, &pta3);",
          "199:     c1 = ptaGetCount(pta3);",
          "200:     ptaDestroy(&pta3);",
          "202:     if (rp->display)",
          "203:         lept_stderr(\"  hmap: union size = %d\\n\", c1);",
          "204:     ptaDestroy(&pta0);",
          "209:     da0 = l_dnaMakeSequence(0, 1, 80000);",
          "210:     n = l_dnaGetCount(da0);",
          "211:     for (i = 0; i < n; i++)",
          "212:         da0->array[i] = -7.4 * da0->array[i];",
          "213:     da1 = l_dnaSelectRange(da0, 0, 0.6 * n);",
          "218:     c2 = l_dnaGetCount(da2);",
          "219:     set = l_asetCreateFromDna(da2);",
          "220:     s1 = l_asetSize(set);",
          "221:     l_asetDestroy(&set);",
          "224:         lept_stderr(\"Double array operations\\n  c1 = %d, c2 = %d\\n\", c1, c2);",
          "225:         lept_stderr(\"  aset: size of set without dups: %d\\n\", s1);",
          "227:     l_dnaRemoveDupsByAset(da2, &da3);",
          "228:     c1 = l_dnaGetCount(da3);",
          "229:     l_dnaDestroy(&da3);",
          "232:         lept_stderr(\"  aset: size without dups = %d\\n\", c1);",
          "233:     l_dnaIntersectionByAset(da1, da2, &da3);",
          "234:     c1 = l_dnaGetCount(da3);",
          "235:     l_dnaDestroy(&da3);",
          "237:     if (rp->display)",
          "238:         lept_stderr(\"  aset: intersection size = %d\\n\", c1);",
          "239:     l_dnaUnionByAset(da1, da2, &da3);",
          "240:     c1 = l_dnaGetCount(da3);",
          "241:     l_dnaDestroy(&da3);",
          "243:     if (rp->display)",
          "244:         lept_stderr(\"  aset: union size = %d\\n\", c1);",
          "247:     hmap = l_hmapCreateFromDna(da2);",
          "248:     c1 = hmap->nitems;",
          "250:     if (rp->display) lept_stderr(\"  hmap: set size without dups: %d\\n\", c1);",
          "251:     l_hmapDestroy(&hmap);",
          "252:     l_dnaRemoveDupsByHmap(da2, &da3, NULL);",
          "253:     c1 = l_dnaGetCount(da3);",
          "254:     l_dnaDestroy(&da3);",
          "256:     if (rp->display)",
          "257:         lept_stderr(\"  hmap: size without dups = %d\\n\", c1);",
          "258:     l_dnaIntersectionByHmap(da1, da2, &da3);",
          "259:     c1 = l_dnaGetCount(da3);",
          "260:     l_dnaDestroy(&da3);",
          "262:     if (rp->display)",
          "263:         lept_stderr(\"  hmap: intersection size = %d\\n\", c1);",
          "264:     l_dnaUnionByHmap(da1, da2, &da3);",
          "265:     c1 = l_dnaGetCount(da3);",
          "266:     l_dnaDestroy(&da3);",
          "268:     if (rp->display)",
          "269:         lept_stderr(\"  hmap: union size = %d\\n\", c1);",
          "270:     l_dnaDestroy(&da0);",
          "271:     l_dnaDestroy(&da1);",
          "272:     l_dnaDestroy(&da2);",
          "276:     da0 = l_dnaMakeSequence(0, 1, 20);",
          "277:     n = l_dnaGetCount(da0);",
          "278:     for (i = 0; i < n; i++)",
          "279:         da0->array[i] = 3.4 * da0->array[i];",
          "280:     da1 = l_dnaSelectRange(da0, 0, 0.6 * n);",
          "284:     c1 = l_dnaGetCount(da1);",
          "285:     c2 = l_dnaGetCount(da2);",
          "286:     l_dnaRemoveDupsByAset(da2, &da3);",
          "287:     l_dnaWriteMem(&data1, &size1, da3);",
          "288:     l_dnaDestroy(&da3);",
          "289:     l_dnaRemoveDupsByHmap(da2, &da3, NULL);",
          "290:     l_dnaWriteMem(&data2, &size2, da3);",
          "292:     if (rp->display) lept_stderr(\"%s\", data1);",
          "293:     lept_free(data1);",
          "294:     lept_free(data2);",
          "295:     l_dnaDestroy(&da0);",
          "307:         lept_stderr(\"Color count using hashmap: %d\\n\", c1);",
          "308:         lept_stderr(\"Color count using aset: %d\\n\", c2);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "418:                 snprintf(buf, sizeof(buf), \"%c%c%c\", i + 0x61, j + 0x61,",
          "419:                          k + 0x61);",
          "420:                 sarrayAddString(sa, buf, L_COPY);",
          "423:                 if (nchars > 3) {",
          "424:                     for (l = 0; l < 26; l++) {",
          "425:                         snprintf(buf, sizeof(buf), \"%c%c%c%c\", i + 0x61,",
          "426:                                  j + 0x61, k + 0x61, l + 0x61);",
          "427:                         sarrayAddString(sa, buf, L_COPY);",
          "430:                         if (nchars > 4) {",
          "431:                             for (m = 0; m < 26; m++) {",
          "432:                                 snprintf(buf, sizeof(buf), \"%c%c%c%c%c\",",
          "433:                                          i + 0x61, j + 0x61, k + 0x61,",
          "434:                                          l + 0x61, m + 0x61);",
          "435:                                 sarrayAddString(sa, buf, L_COPY);",
          "438:                                     l_hashStringToUint64(buf, &hash);",
          "439:                                     lept_stderr(\"  %llx\\n\", hash);",
          "440:                                 }",
          "443:                             }",
          "444:                         }",
          "445:                     }",
          "",
          "[Removed Lines]",
          "422:                     sarrayAddString(sa, buf, L_COPY);",
          "429:                             sarrayAddString(sa, buf, L_COPY);",
          "436:                                 if (!add_dups && i == 17 && j == 12 &&",
          "437:                                     k == 4 && l == 21) {",
          "442:                                     sarrayAddString(sa, buf, L_COPY);",
          "",
          "[Added Lines]",
          "346:                                 if (i == 17 && j == 12 && k == 4 && l == 21) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "451:     return sa;",
          "452: }",
          "454: static PTA *",
          "456: {",
          "457: l_int32  i, j;",
          "458: PTA     *pta;",
          "",
          "[Removed Lines]",
          "455: BuildPointSet(l_int32  w, l_int32 h, l_int32 add_dups)",
          "",
          "[Added Lines]",
          "363: BuildPointSet(l_int32  w, l_int32 h)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "460:     pta = ptaCreate(w * h);",
          "461:     for (i = 0; i < h; i++) {",
          "462:         for (j = 0; j < w; j++)",
          "468:     }",
          "470:     return pta;",
          "471: }",
          "",
          "[Removed Lines]",
          "463:             ptaAddPt(pta, j, i);",
          "465:             for (j = 0.4 * w; j < 0.6 * w; j++)",
          "466:                 ptaAddPt(pta, j, i);",
          "467:         }",
          "",
          "[Added Lines]",
          "371:             ptaAddPt(pta, 316.27 * j, 243.59 * i);",
          "",
          "---------------"
        ],
        "prog/pixa2_reg.c||prog/pixa2_reg.c": [
          "File: prog/pixa2_reg.c -> prog/pixa2_reg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:     sa1 = getSortedPathnamesInDirectory(\".\", \".jpg\", 0, 0);",
          "55:     sa2 = getSortedPathnamesInDirectory(\".\", \".tif\", 0, 0);",
          "58:     sarrayJoin(sa3, sa4);",
          "59:     n =sarrayGetCount(sa3);",
          "60:     sarrayDestroy(&sa1);",
          "",
          "[Removed Lines]",
          "56:     sa3 = sarraySelectByRange(sa1, 10, 19);",
          "57:     sa4 = sarraySelectByRange(sa2, 10, 19);",
          "",
          "[Added Lines]",
          "56:     sa3 = sarraySelectRange(sa1, 10, 19);",
          "57:     sa4 = sarraySelectRange(sa2, 10, 19);",
          "",
          "---------------"
        ],
        "prog/tiffpdftest.c||prog/tiffpdftest.c": [
          "File: prog/tiffpdftest.c -> prog/tiffpdftest.c"
        ],
        "src/Makefile.am||src/Makefile.am": [
          "File: src/Makefile.am -> src/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:  fmorphauto.c fmorphgen.1.c fmorphgenlow.1.c                    \\",
          "32:  fpix1.c fpix2.c gifio.c gifiostub.c                            \\",
          "33:  gplot.c graphics.c graymorph.c                                 \\",
          "35:  jp2kheader.c jp2kheaderstub.c                                  \\",
          "36:  jp2kio.c jp2kiostub.c jpegio.c jpegiostub.c                    \\",
          "37:  kernel.c leptwin.c libversions.c list.c map.c maze.c           \\",
          "",
          "[Removed Lines]",
          "34:  grayquant.c heap.c jbclass.c                                   \\",
          "",
          "[Added Lines]",
          "34:  grayquant.c hashmap.c heap.c jbclass.c                         \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:  array.h arrayaccess.h bbuffer.h bilateral.h                    \\",
          "69:  bmf.h bmfdata.h bmp.h ccbord.h colorfill.h                     \\",
          "70:  dewarp.h endianness.h environ.h                                \\",
          "72:  leptwin.h list.h                                               \\",
          "73:  morph.h pix.h ptra.h queue.h rbtree.h                          \\",
          "74:  readbarcode.h recog.h regutils.h stack.h                       \\",
          "",
          "[Removed Lines]",
          "71:  gplot.h heap.h imageio.h jbclass.h                             \\",
          "",
          "[Added Lines]",
          "71:  gplot.h hashmap.h heap.h imageio.h jbclass.h                   \\",
          "",
          "---------------"
        ],
        "src/allheaders.h||src/allheaders.h": [
          "File: src/allheaders.h -> src/allheaders.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "734: LEPT_DLL extern l_ok l_dnaCopyParameters ( L_DNA *dad, L_DNA *das );",
          "735: LEPT_DLL extern L_DNA * l_dnaRead ( const char *filename );",
          "736: LEPT_DLL extern L_DNA * l_dnaReadStream ( FILE *fp );",
          "737: LEPT_DLL extern l_ok l_dnaWrite ( const char *filename, L_DNA *da );",
          "738: LEPT_DLL extern l_ok l_dnaWriteStream ( FILE *fp, L_DNA *da );",
          "739: LEPT_DLL extern l_ok l_dnaWriteStderr ( L_DNA *da );",
          "740: LEPT_DLL extern L_DNAA * l_dnaaCreate ( l_int32 n );",
          "741: LEPT_DLL extern L_DNAA * l_dnaaCreateFull ( l_int32 nptr, l_int32 n );",
          "742: LEPT_DLL extern l_ok l_dnaaTruncate ( L_DNAA *daa );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "737: LEPT_DLL extern L_DNA * l_dnaReadMem ( const l_uint8 *data, size_t size );",
          "741: LEPT_DLL extern l_ok l_dnaWriteMem ( l_uint8 **pdata, size_t *psize, L_DNA *da );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "751: LEPT_DLL extern l_ok l_dnaaAddNumber ( L_DNAA *daa, l_int32 index, l_float64 val );",
          "752: LEPT_DLL extern L_DNAA * l_dnaaRead ( const char *filename );",
          "753: LEPT_DLL extern L_DNAA * l_dnaaReadStream ( FILE *fp );",
          "754: LEPT_DLL extern l_ok l_dnaaWrite ( const char *filename, L_DNAA *daa );",
          "755: LEPT_DLL extern l_ok l_dnaaWriteStream ( FILE *fp, L_DNAA *daa );",
          "756: LEPT_DLL extern l_ok l_dnaJoin ( L_DNA *dad, L_DNA *das, l_int32 istart, l_int32 iend );",
          "757: LEPT_DLL extern L_DNA * l_dnaaFlattenToDna ( L_DNAA *daa );",
          "758: LEPT_DLL extern NUMA * l_dnaConvertToNuma ( L_DNA *da );",
          "759: LEPT_DLL extern L_DNA * numaConvertToDna ( NUMA *na );",
          "760: LEPT_DLL extern L_DNA * pixConvertDataToDna ( PIX *pix );",
          "764: LEPT_DLL extern L_ASET * l_asetCreateFromDna ( L_DNA *da );",
          "765: LEPT_DLL extern L_DNA * l_dnaDiffAdjValues ( L_DNA *das );",
          "766: LEPT_DLL extern L_DNAHASH * l_dnaHashCreate ( l_int32 nbuckets, l_int32 initsize );",
          "767: LEPT_DLL extern void l_dnaHashDestroy ( L_DNAHASH **pdahash );",
          "770: LEPT_DLL extern L_DNA * l_dnaHashGetDna ( L_DNAHASH *dahash, l_uint64 key, l_int32 copyflag );",
          "771: LEPT_DLL extern l_ok l_dnaHashAdd ( L_DNAHASH *dahash, l_uint64 key, l_float64 value );",
          "777: LEPT_DLL extern PIX * pixMorphDwa_2 ( PIX *pixd, PIX *pixs, l_int32 operation, char *selname );",
          "778: LEPT_DLL extern PIX * pixFMorphopGen_2 ( PIX *pixd, PIX *pixs, l_int32 operation, char *selname );",
          "779: LEPT_DLL extern l_int32 fmorphopgen_low_2 ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 index );",
          "",
          "[Removed Lines]",
          "761: LEPT_DLL extern L_DNA * l_dnaUnionByAset ( L_DNA *da1, L_DNA *da2 );",
          "762: LEPT_DLL extern L_DNA * l_dnaRemoveDupsByAset ( L_DNA *das );",
          "763: LEPT_DLL extern L_DNA * l_dnaIntersectionByAset ( L_DNA *da1, L_DNA *da2 );",
          "768: LEPT_DLL extern l_int32 l_dnaHashGetCount ( L_DNAHASH *dahash );",
          "769: LEPT_DLL extern l_int32 l_dnaHashGetTotalCount ( L_DNAHASH *dahash );",
          "772: LEPT_DLL extern L_DNAHASH * l_dnaHashCreateFromDna ( L_DNA *da );",
          "773: LEPT_DLL extern l_ok l_dnaRemoveDupsByHash ( L_DNA *das, L_DNA **pdad, L_DNAHASH **pdahash );",
          "774: LEPT_DLL extern l_ok l_dnaMakeHistoByHash ( L_DNA *das, L_DNAHASH **pdahash, L_DNA **pdav, L_DNA **pdac );",
          "775: LEPT_DLL extern L_DNA * l_dnaIntersectionByHash ( L_DNA *da1, L_DNA *da2 );",
          "776: LEPT_DLL extern l_ok l_dnaFindValByHash ( L_DNA *da, L_DNAHASH *dahash, l_float64 val, l_int32 *pindex );",
          "",
          "[Added Lines]",
          "756: LEPT_DLL extern L_DNAA * l_dnaaReadMem ( const l_uint8 *data, size_t size );",
          "759: LEPT_DLL extern l_ok l_dnaaWriteMem ( l_uint8 **pdata, size_t *psize, L_DNAA *daa );",
          "762: LEPT_DLL extern L_DNA * l_dnaSelectRange ( L_DNA *das, l_int32 first, l_int32 last );",
          "767: LEPT_DLL extern l_ok l_dnaRemoveDupsByAset ( L_DNA *das, L_DNA **pdad );",
          "768: LEPT_DLL extern l_ok l_dnaUnionByAset ( L_DNA *da1, L_DNA *da2, L_DNA **pdad );",
          "769: LEPT_DLL extern l_ok l_dnaIntersectionByAset ( L_DNA *da1, L_DNA *da2, L_DNA **pdad );",
          "770: LEPT_DLL extern L_HASHMAP * l_hmapCreateFromDna ( L_DNA *da );",
          "771: LEPT_DLL extern l_ok l_dnaRemoveDupsByHmap ( L_DNA *das, L_DNA **pdad, L_HASHMAP **phmap );",
          "772: LEPT_DLL extern l_ok l_dnaUnionByHmap ( L_DNA *da1, L_DNA *da2, L_DNA **pdad );",
          "773: LEPT_DLL extern l_ok l_dnaIntersectionByHmap ( L_DNA *da1, L_DNA *da2, L_DNA **pdad );",
          "774: LEPT_DLL extern l_ok l_dnaMakeHistoByHmap ( L_DNA *das, L_DNA **pdav, L_DNA **pdac );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1039: LEPT_DLL extern PIX * pixGenerateMaskByDiscr32 ( PIX *pixs, l_uint32 refval1, l_uint32 refval2, l_int32 distflag );",
          "1040: LEPT_DLL extern PIX * pixGrayQuantFromHisto ( PIX *pixd, PIX *pixs, PIX *pixm, l_float32 minfract, l_int32 maxsize );",
          "1041: LEPT_DLL extern PIX * pixGrayQuantFromCmap ( PIX *pixs, PIXCMAP *cmap, l_int32 mindepth );",
          "1042: LEPT_DLL extern L_HEAP * lheapCreate ( l_int32 n, l_int32 direction );",
          "1043: LEPT_DLL extern void lheapDestroy ( L_HEAP **plh, l_int32 freeflag );",
          "1044: LEPT_DLL extern l_ok lheapAdd ( L_HEAP *lh, void *item );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1045: LEPT_DLL extern L_HASHMAP * l_hmapCreate ( l_int32 ninit, l_int32 maxocc );",
          "1046: LEPT_DLL extern void l_hmapDestroy ( L_HASHMAP **phmap );",
          "1047: LEPT_DLL extern L_HASHITEM * l_hmapLookup ( L_HASHMAP *hmap, l_uint64 key, l_uint64 val, l_int32 op );",
          "1048: LEPT_DLL extern l_ok l_hmapRehash ( L_HASHMAP *hmap );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2158: LEPT_DLL extern l_ok ptaGetRankValue ( PTA *pta, l_float32 fract, PTA *ptasort, l_int32 sorttype, l_float32 *pval );",
          "2159: LEPT_DLL extern PTA * ptaSort2d ( PTA *pta );",
          "2160: LEPT_DLL extern l_ok ptaEqual ( PTA *pta1, PTA *pta2, l_int32 *psame );",
          "2164: LEPT_DLL extern L_ASET * l_asetCreateFromPta ( PTA *pta );",
          "2170: LEPT_DLL extern L_PTRA * ptraCreate ( l_int32 n );",
          "2171: LEPT_DLL extern void ptraDestroy ( L_PTRA **ppa, l_int32 freeflag, l_int32 warnflag );",
          "2172: LEPT_DLL extern l_ok ptraAdd ( L_PTRA *pa, void *item );",
          "",
          "[Removed Lines]",
          "2161: LEPT_DLL extern PTA * ptaUnionByAset ( PTA *pta1, PTA *pta2 );",
          "2162: LEPT_DLL extern PTA * ptaRemoveDupsByAset ( PTA *ptas );",
          "2163: LEPT_DLL extern PTA * ptaIntersectionByAset ( PTA *pta1, PTA *pta2 );",
          "2165: LEPT_DLL extern PTA * ptaUnionByHash ( PTA *pta1, PTA *pta2 );",
          "2166: LEPT_DLL extern l_ok ptaRemoveDupsByHash ( PTA *ptas, PTA **pptad, L_DNAHASH **pdahash );",
          "2167: LEPT_DLL extern PTA * ptaIntersectionByHash ( PTA *pta1, PTA *pta2 );",
          "2168: LEPT_DLL extern l_ok ptaFindPtByHash ( PTA *pta, L_DNAHASH *dahash, l_int32 x, l_int32 y, l_int32 *pindex );",
          "2169: LEPT_DLL extern L_DNAHASH * l_dnaHashCreateFromPta ( PTA *pta );",
          "",
          "[Added Lines]",
          "2169: LEPT_DLL extern l_ok ptaRemoveDupsByAset ( PTA *ptas, PTA **pptad );",
          "2170: LEPT_DLL extern l_ok ptaUnionByAset ( PTA *pta1, PTA *pta2, PTA **pptad );",
          "2171: LEPT_DLL extern l_ok ptaIntersectionByAset ( PTA *pta1, PTA *pta2, PTA **pptad );",
          "2172: LEPT_DLL extern L_HASHMAP * l_hmapCreateFromPta ( PTA *pta );",
          "2173: LEPT_DLL extern l_ok ptaRemoveDupsByHmap ( PTA *ptas, PTA **pptad, L_HASHMAP **phmap );",
          "2174: LEPT_DLL extern l_ok ptaUnionByHmap ( PTA *pta1, PTA *pta2, PTA **pptad );",
          "2175: LEPT_DLL extern l_ok ptaIntersectionByHmap ( PTA *pta1, PTA *pta2, PTA **pptad );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2384: LEPT_DLL extern SARRAY * sarrayConvertWordsToLines ( SARRAY *sa, l_int32 linesize );",
          "2385: LEPT_DLL extern l_int32 sarraySplitString ( SARRAY *sa, const char *str, const char *separators );",
          "2386: LEPT_DLL extern SARRAY * sarraySelectBySubstring ( SARRAY *sain, const char *substr );",
          "2388: LEPT_DLL extern l_int32 sarrayParseRange ( SARRAY *sa, l_int32 start, l_int32 *pactualstart, l_int32 *pend, l_int32 *pnewstart, const char *substr, l_int32 loc );",
          "2389: LEPT_DLL extern SARRAY * sarrayRead ( const char *filename );",
          "2390: LEPT_DLL extern SARRAY * sarrayReadStream ( FILE *fp );",
          "",
          "[Removed Lines]",
          "2387: LEPT_DLL extern SARRAY * sarraySelectByRange ( SARRAY *sain, l_int32 first, l_int32 last );",
          "",
          "[Added Lines]",
          "2393: LEPT_DLL extern SARRAY * sarraySelectRange ( SARRAY *sain, l_int32 first, l_int32 last );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2401: LEPT_DLL extern SARRAY * sarraySort ( SARRAY *saout, SARRAY *sain, l_int32 sortorder );",
          "2402: LEPT_DLL extern SARRAY * sarraySortByIndex ( SARRAY *sain, NUMA *naindex );",
          "2403: LEPT_DLL extern l_int32 stringCompareLexical ( const char *str1, const char *str2 );",
          "2407: LEPT_DLL extern L_ASET * l_asetCreateFromSarray ( SARRAY *sa );",
          "2412: LEPT_DLL extern SARRAY * sarrayGenerateIntegers ( l_int32 n );",
          "2413: LEPT_DLL extern l_ok sarrayLookupCSKV ( SARRAY *sa, const char *keystring, char **pvalstring );",
          "2414: LEPT_DLL extern PIX * pixScale ( PIX *pixs, l_float32 scalex, l_float32 scaley );",
          "",
          "[Removed Lines]",
          "2404: LEPT_DLL extern SARRAY * sarrayUnionByAset ( SARRAY *sa1, SARRAY *sa2 );",
          "2405: LEPT_DLL extern SARRAY * sarrayRemoveDupsByAset ( SARRAY *sas );",
          "2406: LEPT_DLL extern SARRAY * sarrayIntersectionByAset ( SARRAY *sa1, SARRAY *sa2 );",
          "2408: LEPT_DLL extern l_ok sarrayRemoveDupsByHash ( SARRAY *sas, SARRAY **psad, L_DNAHASH **pdahash );",
          "2409: LEPT_DLL extern SARRAY * sarrayIntersectionByHash ( SARRAY *sa1, SARRAY *sa2 );",
          "2410: LEPT_DLL extern l_ok sarrayFindStringByHash ( SARRAY *sa, L_DNAHASH *dahash, const char *str, l_int32 *pindex );",
          "2411: LEPT_DLL extern L_DNAHASH * l_dnaHashCreateFromSarray ( SARRAY *sa );",
          "",
          "[Added Lines]",
          "2411: LEPT_DLL extern l_ok sarrayRemoveDupsByAset ( SARRAY *sas, SARRAY **psad );",
          "2412: LEPT_DLL extern l_ok sarrayUnionByAset ( SARRAY *sa1, SARRAY *sa2, SARRAY **psad );",
          "2413: LEPT_DLL extern l_ok sarrayIntersectionByAset ( SARRAY *sa1, SARRAY *sa2, SARRAY **psad );",
          "2414: LEPT_DLL extern L_HASHMAP * l_hmapCreateFromSarray ( SARRAY *sa );",
          "2415: LEPT_DLL extern l_ok sarrayRemoveDupsByHmap ( SARRAY *sas, SARRAY **psad, L_HASHMAP **phmap );",
          "2416: LEPT_DLL extern l_ok sarrayUnionByHmap ( SARRAY *sa1, SARRAY *sa2, SARRAY **psad );",
          "2417: LEPT_DLL extern l_ok sarrayIntersectionByHmap ( SARRAY *sa1, SARRAY *sa2, SARRAY **psad );",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2648: LEPT_DLL extern l_ok genRandomIntOnInterval ( l_int32 start, l_int32 end, l_int32 seed, l_int32 *pval );",
          "2649: LEPT_DLL extern l_int32 lept_roundftoi ( l_float32 fval );",
          "2650: LEPT_DLL extern l_ok l_hashStringToUint64 ( const char *str, l_uint64 *phash );",
          "2651: LEPT_DLL extern l_ok l_hashPtToUint64 ( l_int32 x, l_int32 y, l_uint64 *phash );",
          "2653: LEPT_DLL extern l_ok findNextLargerPrime ( l_int32 start, l_uint32 *pprime );",
          "2654: LEPT_DLL extern l_ok lept_isPrime ( l_uint64 n, l_int32 *pis_prime, l_uint32 *pfactor );",
          "2655: LEPT_DLL extern l_uint32 convertIntToGrayCode ( l_uint32 val );",
          "",
          "[Removed Lines]",
          "2652: LEPT_DLL extern l_ok l_hashFloat64ToUint64 ( l_int32 nbuckets, l_float64 val, l_uint64 *phash );",
          "",
          "[Added Lines]",
          "2657: LEPT_DLL extern l_ok l_hashStringToUint64Fast ( const char *str, l_uint64 *phash );",
          "",
          "---------------"
        ],
        "src/alltypes.h||src/alltypes.h": [
          "File: src/alltypes.h -> src/alltypes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #include \"array.h\"",
          "41: #include \"bbuffer.h\"",
          "42: #include \"heap.h\"",
          "43: #include \"list.h\"",
          "44: #include \"ptra.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: #include \"hashmap.h\"",
          "",
          "---------------"
        ],
        "src/array.h||src/array.h": [
          "File: src/array.h -> src/array.h"
        ],
        "src/dnabasic.c||src/dnabasic.c": [
          "File: src/dnabasic.c -> src/dnabasic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "483:     if (!da)",
          "484:         return ERROR_INT(\"da not defined\", procName, 1);",
          "487:     oldsize = da->nalloc * sizeof(l_float64);",
          "492:     if ((da->array = (l_float64 *)reallocNew((void **)&da->array,",
          "493:                                              oldsize, newsize)) == NULL)",
          "494:         return ERROR_INT(\"new ptr array not returned\", procName, 1);",
          "497:     return 0;",
          "498: }",
          "",
          "[Removed Lines]",
          "486:         return ERROR_INT(\"da has too many ptrs\", procName, 1);",
          "488:     newsize = 2 * oldsize;",
          "489:     if (newsize > 8 * MaxDoubleArraySize)",
          "490:         return ERROR_INT(\"newsize > 800 MB; too large\", procName, 1);",
          "496:     da->nalloc *= 2;",
          "",
          "[Added Lines]",
          "490:     if (da->nalloc > MaxDoubleArraySize)",
          "491:         return ERROR_INT(\"da at maximum size; can't extend\", procName, 1);",
          "493:     if (da->nalloc > MaxDoubleArraySize / 2) {",
          "494:         newsize = MaxDoubleArraySize * sizeof(l_float64);",
          "495:         da->nalloc = MaxDoubleArraySize;",
          "496:     } else {",
          "497:         newsize = 2 * oldsize;",
          "498:         da->nalloc *= 2;",
          "499:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1078: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1095: L_DNA *",
          "1096: l_dnaReadMem(const l_uint8  *data,",
          "1097:              size_t          size)",
          "1098: {",
          "1099: FILE   *fp;",
          "1100: L_DNA  *da;",
          "1102:     PROCNAME(\"l_dnaReadMem\");",
          "1104:     if (!data)",
          "1105:         return (L_DNA *)ERROR_PTR(\"data not defined\", procName, NULL);",
          "1106:     if ((fp = fopenReadFromMemory(data, size)) == NULL)",
          "1107:         return (L_DNA *)ERROR_PTR(\"stream not opened\", procName, NULL);",
          "1109:     da = l_dnaReadStream(fp);",
          "1110:     fclose(fp);",
          "1111:     if (!da) L_ERROR(\"dna not read\\n\", procName);",
          "1112:     return da;",
          "1113: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1179: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1230: l_ok",
          "1231: l_dnaWriteMem(l_uint8  **pdata,",
          "1232:               size_t    *psize,",
          "1233:               L_DNA     *da)",
          "1234: {",
          "1235: l_int32  ret;",
          "1236: FILE    *fp;",
          "1238:     PROCNAME(\"l_dnaWriteMem\");",
          "1240:     if (pdata) *pdata = NULL;",
          "1241:     if (psize) *psize = 0;",
          "1242:     if (!pdata)",
          "1243:         return ERROR_INT(\"&data not defined\", procName, 1);",
          "1244:     if (!psize)",
          "1245:         return ERROR_INT(\"&size not defined\", procName, 1);",
          "1246:     if (!da)",
          "1247:         return ERROR_INT(\"da not defined\", procName, 1);",
          "1249: #if HAVE_FMEMOPEN",
          "1250:     if ((fp = open_memstream((char **)pdata, psize)) == NULL)",
          "1251:         return ERROR_INT(\"stream not opened\", procName, 1);",
          "1252:     ret = l_dnaWriteStream(fp, da);",
          "1253: #else",
          "1254:     L_INFO(\"work-around: writing to a temp file\\n\", procName);",
          "1255:   #ifdef _WIN32",
          "1256:     if ((fp = fopenWriteWinTempfile()) == NULL)",
          "1257:         return ERROR_INT(\"tmpfile stream not opened\", procName, 1);",
          "1258:   #else",
          "1259:     if ((fp = tmpfile()) == NULL)",
          "1260:         return ERROR_INT(\"tmpfile stream not opened\", procName, 1);",
          "1262:     ret = l_dnaWriteStream(fp, da);",
          "1263:     rewind(fp);",
          "1266:     fclose(fp);",
          "1267:     return ret;",
          "1268: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1695: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1794: L_DNAA *",
          "1795: l_dnaaReadMem(const l_uint8  *data,",
          "1796:               size_t          size)",
          "1797: {",
          "1798: FILE    *fp;",
          "1799: L_DNAA  *daa;",
          "1801:     PROCNAME(\"l_dnaaReadMem\");",
          "1803:     if (!data)",
          "1804:         return (L_DNAA *)ERROR_PTR(\"data not defined\", procName, NULL);",
          "1805:     if ((fp = fopenReadFromMemory(data, size)) == NULL)",
          "1806:         return (L_DNAA *)ERROR_PTR(\"stream not opened\", procName, NULL);",
          "1808:     daa = l_dnaaReadStream(fp);",
          "1809:     fclose(fp);",
          "1810:     if (!daa) L_ERROR(\"daa not read\\n\", procName);",
          "1811:     return daa;",
          "1812: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1761:     return 0;",
          "1762: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1895: l_ok",
          "1896: l_dnaaWriteMem(l_uint8  **pdata,",
          "1897:                size_t    *psize,",
          "1898:                L_DNAA    *daa)",
          "1899: {",
          "1900: l_int32  ret;",
          "1901: FILE    *fp;",
          "1903:     PROCNAME(\"l_dnaaWriteMem\");",
          "1905:     if (pdata) *pdata = NULL;",
          "1906:     if (psize) *psize = 0;",
          "1907:     if (!pdata)",
          "1908:         return ERROR_INT(\"&data not defined\", procName, 1);",
          "1909:     if (!psize)",
          "1910:         return ERROR_INT(\"&size not defined\", procName, 1);",
          "1911:     if (!daa)",
          "1912:         return ERROR_INT(\"daa not defined\", procName, 1);",
          "1914: #if HAVE_FMEMOPEN",
          "1915:     if ((fp = open_memstream((char **)pdata, psize)) == NULL)",
          "1916:         return ERROR_INT(\"stream not opened\", procName, 1);",
          "1917:     ret = l_dnaaWriteStream(fp, daa);",
          "1918: #else",
          "1919:     L_INFO(\"work-around: writing to a temp file\\n\", procName);",
          "1920:   #ifdef _WIN32",
          "1921:     if ((fp = fopenWriteWinTempfile()) == NULL)",
          "1922:         return ERROR_INT(\"tmpfile stream not opened\", procName, 1);",
          "1923:   #else",
          "1924:     if ((fp = tmpfile()) == NULL)",
          "1925:         return ERROR_INT(\"tmpfile stream not opened\", procName, 1);",
          "1927:     ret = l_dnaaWriteStream(fp, daa);",
          "1928:     rewind(fp);",
          "1931:     fclose(fp);",
          "1932:     return ret;",
          "1933: }",
          "",
          "---------------"
        ],
        "src/dnafunc1.c||src/dnafunc1.c": [
          "File: src/dnafunc1.c -> src/dnafunc1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "109:     for (i = istart; i <= iend; i++) {",
          "110:         l_dnaGetDValue(das, i, &val);",
          "114:     return 0;",
          "115: }",
          "",
          "[Removed Lines]",
          "111:         l_dnaAddNumber(dad, val);",
          "112:     }",
          "",
          "[Added Lines]",
          "128:         if (l_dnaAddNumber(dad, val) == 1) {",
          "129:             L_ERROR(\"failed to add double at i = %d\\n\", procName, i);",
          "130:             return 1;",
          "131:         }",
          "133:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184: L_DNA *",
          "185: l_dnaSelectRange(L_DNA   *das,",
          "186:                  l_int32  first,",
          "187:                  l_int32  last)",
          "188: {",
          "189: l_int32    n, i;",
          "190: l_float64  dval;",
          "191: L_DNA     *dad;",
          "193:     PROCNAME(\"l_dnaSelectRange\");",
          "195:     if (!das)",
          "196:         return (L_DNA *)ERROR_PTR(\"das not defined\", procName, NULL);",
          "197:     if ((n = l_dnaGetCount(das)) == 0) {",
          "198:         L_WARNING(\"das is empty\\n\", procName);",
          "199:         return l_dnaCopy(das);",
          "200:     }",
          "201:     first = L_MAX(0, first);",
          "202:     if (last < 0) last = n - 1;",
          "203:     if (first >= n)",
          "204:         return (L_DNA *)ERROR_PTR(\"invalid first\", procName, NULL);",
          "205:     if (last >= n) {",
          "206:         L_WARNING(\"last = %d is beyond max index = %d; adjusting\\n\",",
          "207:                   procName, last, n - 1);",
          "208:         last = n - 1;",
          "209:     }",
          "210:     if (first > last)",
          "211:         return (L_DNA *)ERROR_PTR(\"first > last\", procName, NULL);",
          "213:     dad = l_dnaCreate(last - first + 1);",
          "214:     for (i = first; i <= last; i++) {",
          "215:         l_dnaGetDValue(das, i, &dval);",
          "216:         l_dnaAddNumber(dad, dval);",
          "217:     }",
          "218:     return dad;",
          "219: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "276: {",
          "294: }",
          "",
          "[Removed Lines]",
          "273: L_DNA *",
          "274: l_dnaUnionByAset(L_DNA  *da1,",
          "275:                  L_DNA  *da2)",
          "277: L_DNA  *da3, *dad;",
          "279:     PROCNAME(\"l_dnaUnionByAset\");",
          "281:     if (!da1)",
          "282:         return (L_DNA *)ERROR_PTR(\"da1 not defined\", procName, NULL);",
          "283:     if (!da2)",
          "284:         return (L_DNA *)ERROR_PTR(\"da2 not defined\", procName, NULL);",
          "287:     da3 = l_dnaCopy(da1);",
          "288:     l_dnaJoin(da3, da2, 0, -1);",
          "291:     dad = l_dnaRemoveDupsByAset(da3);",
          "292:     l_dnaDestroy(&da3);",
          "293:     return dad;",
          "",
          "[Added Lines]",
          "331: L_ASET *",
          "332: l_asetCreateFromDna(L_DNA  *da)",
          "334: l_int32    i, n;",
          "335: l_float64  val;",
          "336: L_ASET    *set;",
          "337: RB_TYPE    key;",
          "339:     PROCNAME(\"l_asetCreateFromDna\");",
          "341:     if (!da)",
          "342:         return (L_ASET *)ERROR_PTR(\"da not defined\", procName, NULL);",
          "344:     set = l_asetCreate(L_FLOAT_TYPE);",
          "345:     n = l_dnaGetCount(da);",
          "346:     for (i = 0; i < n; i++) {",
          "347:         l_dnaGetDValue(da, i, &val);",
          "348:         key.ftype = val;",
          "349:         l_asetInsert(set, key);",
          "350:     }",
          "352:     return set;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "305: {",
          "306: l_int32    i, n;",
          "307: l_float64  val;",
          "",
          "[Removed Lines]",
          "303: L_DNA *",
          "304: l_dnaRemoveDupsByAset(L_DNA  *das)",
          "",
          "[Added Lines]",
          "363: l_ok",
          "364: l_dnaRemoveDupsByAset(L_DNA   *das,",
          "365:                       L_DNA  **pdad)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "312:     PROCNAME(\"l_dnaRemoveDupsByAset\");",
          "314:     if (!das)",
          "317:     set = l_asetCreate(L_FLOAT_TYPE);",
          "318:     dad = l_dnaCreate(0);",
          "319:     n = l_dnaGetCount(das);",
          "320:     for (i = 0; i < n; i++) {",
          "321:         l_dnaGetDValue(das, i, &val);",
          "",
          "[Removed Lines]",
          "315:         return (L_DNA *)ERROR_PTR(\"das not defined\", procName, NULL);",
          "",
          "[Added Lines]",
          "375:     if (!pdad)",
          "376:         return ERROR_INT(\"&dad not defined\", procName, 1);",
          "379:         return ERROR_INT(\"das not defined\", procName, 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "327:     }",
          "329:     l_asetDestroy(&set);",
          "331: }",
          "",
          "[Removed Lines]",
          "330:     return dad;",
          "",
          "[Added Lines]",
          "395:     return 0;",
          "396: }",
          "415: l_ok",
          "416: l_dnaUnionByAset(L_DNA   *da1,",
          "417:                  L_DNA   *da2,",
          "418:                  L_DNA  **pdad)",
          "419: {",
          "420: L_DNA  *da3;",
          "422:     PROCNAME(\"l_dnaUnionByAset\");",
          "424:     if (!pdad)",
          "425:         return ERROR_INT(\"&dad not defined\", procName, 1);",
          "426:     if (!da1)",
          "427:         return ERROR_INT(\"da1 not defined\", procName, 1);",
          "428:     if (!da2)",
          "429:         return ERROR_INT(\"da2 not defined\", procName, 1);",
          "432:     da3 = l_dnaCopy(da1);",
          "433:     if (l_dnaJoin(da3, da2, 0, -1) == 1) {",
          "434:         l_dnaDestroy(&da3);",
          "435:         return ERROR_INT(\"join failed for da3\", procName, 1);",
          "436:     }",
          "439:     l_dnaRemoveDupsByAset(da3, pdad);",
          "440:     l_dnaDestroy(&da3);",
          "441:     return 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "351: {",
          "352: l_int32    n1, n2, i, n;",
          "353: l_float64  val;",
          "",
          "[Removed Lines]",
          "348: L_DNA *",
          "349: l_dnaIntersectionByAset(L_DNA  *da1,",
          "350:                         L_DNA  *da2)",
          "",
          "[Added Lines]",
          "461: l_ok",
          "462: l_dnaIntersectionByAset(L_DNA   *da1,",
          "463:                         L_DNA   *da2,",
          "464:                         L_DNA  **pdad)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "358:     PROCNAME(\"l_dnaIntersectionByAset\");",
          "360:     if (!da1)",
          "362:     if (!da2)",
          "366:     n1 = l_dnaGetCount(da1);",
          "",
          "[Removed Lines]",
          "361:         return (L_DNA *)ERROR_PTR(\"da1 not defined\", procName, NULL);",
          "363:         return (L_DNA *)ERROR_PTR(\"da2 not defined\", procName, NULL);",
          "",
          "[Added Lines]",
          "474:     if (!pdad)",
          "475:         return ERROR_INT(\"&dad not defined\", procName, 1);",
          "478:         return ERROR_INT(\"&da1 not defined\", procName, 1);",
          "480:         return ERROR_INT(\"&da2 not defined\", procName, 1);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "385:     l_asetDestroy(&set1);",
          "386:     l_asetDestroy(&set2);",
          "388: }",
          "399: {",
          "407:     if (!da)",
          "411:     n = l_dnaGetCount(da);",
          "412:     for (i = 0; i < n; i++) {",
          "416:     }",
          "419: }",
          "",
          "[Removed Lines]",
          "387:     return dad;",
          "397: L_ASET *",
          "398: l_asetCreateFromDna(L_DNA  *da)",
          "400: l_int32    i, n;",
          "401: l_float64  val;",
          "402: L_ASET    *set;",
          "403: RB_TYPE    key;",
          "405:     PROCNAME(\"l_asetCreateFromDna\");",
          "408:         return (L_ASET *)ERROR_PTR(\"da not defined\", procName, NULL);",
          "410:     set = l_asetCreate(L_FLOAT_TYPE);",
          "413:         l_dnaGetDValue(da, i, &val);",
          "414:         key.ftype = val;",
          "415:         l_asetInsert(set, key);",
          "418:     return set;",
          "",
          "[Added Lines]",
          "505:     return 0;",
          "525: L_HASHMAP *",
          "526: l_hmapCreateFromDna(L_DNA  *da)",
          "528: l_int32      i, n;",
          "529: l_uint64     key;",
          "530: l_float64    dval;",
          "531: L_HASHITEM  *hitem;",
          "532: L_HASHMAP   *hmap;",
          "534:     PROCNAME(\"l_hmapCreateFromDna\");",
          "537:         return (L_HASHMAP *)ERROR_PTR(\"da not defined\", procName, NULL);",
          "540:     hmap = l_hmapCreate(0, 0);",
          "542:         l_dnaGetDValue(da, i, &dval);",
          "543:         hitem = l_hmapLookup(hmap, (l_uint64)dval, i, L_HMAP_CREATE);",
          "545:     return hmap;",
          "546: }",
          "563: l_ok",
          "564: l_dnaRemoveDupsByHmap(L_DNA       *das,",
          "565:                       L_DNA      **pdad,",
          "566:                       L_HASHMAP  **phmap)",
          "567: {",
          "568: l_int32      i, tabsize;",
          "569: l_uint64     key;",
          "570: l_float64    dval;",
          "571: L_DNA       *dad;",
          "572: L_HASHITEM  *hitem;",
          "573: L_HASHMAP   *hmap;",
          "575:     PROCNAME(\"l_dnaRemoveDupsByHmap\");",
          "577:     if (phmap) *phmap = NULL;",
          "578:     if (!pdad)",
          "579:         return ERROR_INT(\"&dad not defined\", procName, 1);",
          "581:     if (!das)",
          "582:         return ERROR_INT(\"das not defined\", procName, 1);",
          "585:     if ((hmap = l_hmapCreateFromDna(das)) == NULL)",
          "586:         return ERROR_INT(\"hmap not made\", procName, 1);",
          "587:     dad = l_dnaCreate(0);",
          "589:     tabsize = hmap->tabsize;",
          "590:     for (i = 0; i < tabsize; i++) {",
          "591:         hitem = hmap->hashtab[i];",
          "592:         while (hitem) {",
          "593:             l_dnaGetDValue(das, hitem->val, &dval);",
          "594:             l_dnaAddNumber(dad, dval);",
          "595:             hitem = hitem->next;",
          "596:         }",
          "597:     }",
          "599:     if (phmap)",
          "601:     else",
          "602:         l_hmapDestroy(&hmap);",
          "603:     return 0;",
          "604: }",
          "620: l_ok",
          "621: l_dnaUnionByHmap(L_DNA   *da1,",
          "622:                  L_DNA   *da2,",
          "623:                  L_DNA  **pdad)",
          "624: {",
          "625: L_DNA  *da3;",
          "627:     PROCNAME(\"l_dnaUnionByHmap\");",
          "629:     if (!pdad)",
          "630:         return ERROR_INT(\"&dad not defined\", procName, 1);",
          "632:     if (!da1)",
          "633:         return ERROR_INT(\"da1 not defined\", procName, 1);",
          "634:     if (!da2)",
          "635:         return ERROR_INT(\"da2 not defined\", procName, 1);",
          "637:     da3 = l_dnaCopy(da1);",
          "638:     if (l_dnaJoin(da3, da2, 0, -1) == 1) {",
          "639:         l_dnaDestroy(&da3);",
          "640:         return ERROR_INT(\"da3 join failed\", procName, 1);",
          "641:     }",
          "642:     l_dnaRemoveDupsByHmap(da3, pdad, NULL);",
          "643:     l_dnaDestroy(&da3);",
          "644:     return 0;",
          "645: }",
          "662: l_ok",
          "663: l_dnaIntersectionByHmap(L_DNA   *da1,",
          "664:                         L_DNA   *da2,",
          "665:                         L_DNA  **pdad)",
          "666: {",
          "667: l_int32      i, n1, n2, n;",
          "668: l_uint64     key;",
          "669: l_float64    dval;",
          "670: L_DNA       *da_small, *da_big, *dad;",
          "671: L_HASHITEM  *hitem;",
          "672: L_HASHMAP   *hmap;",
          "674:     PROCNAME(\"l_dnaIntersectionByHmap\");",
          "676:     if (!pdad)",
          "677:         return ERROR_INT(\"&dad not defined\", procName, 1);",
          "679:     if (!da1)",
          "680:         return ERROR_INT(\"da1 not defined\", procName, 1);",
          "681:     if (!da2)",
          "682:         return ERROR_INT(\"da2 not defined\", procName, 1);",
          "685:     n1 = l_dnaGetCount(da1);",
          "686:     n2 = l_dnaGetCount(da2);",
          "689:     if ((hmap = l_hmapCreateFromDna(da_big)) == NULL)",
          "690:         return ERROR_INT(\"hmap not made\", procName, 1);",
          "697:     dad = l_dnaCreate(0);",
          "699:     n = l_dnaGetCount(da_small);",
          "700:     for (i = 0; i < n; i++) {",
          "701:         l_dnaGetDValue(da_small, i, &dval);",
          "702:         hitem = l_hmapLookup(hmap, (l_uint64)dval, i, L_HMAP_CHECK);",
          "703:         if (!hitem || hitem->count == 0)",
          "704:             continue;",
          "705:         l_dnaAddNumber(dad, dval);",
          "706:         hitem->count = 0;",
          "707:     }",
          "708:     l_hmapDestroy(&hmap);",
          "709:     return 0;",
          "710: }",
          "727: l_ok",
          "728: l_dnaMakeHistoByHmap(L_DNA   *das,",
          "729:                      L_DNA  **pdav,",
          "730:                      L_DNA  **pdac)",
          "731: {",
          "732: l_int32      i, tabsize;",
          "733: l_float64    dval;",
          "734: L_DNA       *dac, *dav;",
          "735: L_HASHITEM  *hitem;",
          "736: L_HASHMAP   *hmap;",
          "738:     PROCNAME(\"l_dnaMakeHistoByHmap\");",
          "740:     if (pdav) *pdav = NULL;",
          "741:     if (pdac) *pdac = NULL;",
          "742:     if (!das)",
          "743:         return ERROR_INT(\"das not defined\", procName, 1);",
          "744:     if (!pdav)",
          "745:         return ERROR_INT(\"&dav not defined\", procName, 1);",
          "746:     if (!pdac)",
          "747:         return ERROR_INT(\"&dac not defined\", procName, 1);",
          "750:     if ((hmap = l_hmapCreateFromDna(das)) == NULL)",
          "751:         return ERROR_INT(\"hmap not made\", procName, 1);",
          "752:     dav = l_dnaCreate(0);",
          "754:     dac = l_dnaCreate(0);",
          "756:     tabsize = hmap->tabsize;",
          "757:     for (i = 0; i < tabsize; i++) {",
          "758:         hitem = hmap->hashtab[i];",
          "759:         while (hitem) {",
          "760:             l_dnaGetDValue(das, hitem->val, &dval);",
          "761:             l_dnaAddNumber(dav, dval);",
          "762:             l_dnaAddNumber(dac, hitem->count);",
          "763:             hitem = hitem->next;",
          "764:         }",
          "765:     }",
          "767:     l_hmapDestroy(&hmap);",
          "768:     return 0;",
          "",
          "---------------"
        ],
        "src/dnahash.c||src/dnahash.c": [
          "File: src/dnahash.c -> src/dnahash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "125: L_DNAHASH *",
          "126: l_dnaHashCreate(l_int32  nbuckets,",
          "127:                 l_int32  initsize)",
          "128: {",
          "129: L_DNAHASH  *dahash;",
          "131:     PROCNAME(\"l_dnaHashCreate\");",
          "133:     if (nbuckets <= 0)",
          "134:         return (L_DNAHASH *)ERROR_PTR(\"negative hash size\", procName, NULL);",
          "135:     dahash = (L_DNAHASH *)LEPT_CALLOC(1, sizeof(L_DNAHASH));",
          "136:     if ((dahash->dna = (L_DNA **)LEPT_CALLOC(nbuckets, sizeof(L_DNA *)))",
          "137:         == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: l_int32     is_prime;",
          "74: l_uint32    newsize;",
          "81:     lept_isPrime(nbuckets, &is_prime, NULL);",
          "82:     if (!is_prime) {",
          "83:         findNextLargerPrime(nbuckets, &newsize);",
          "84:         nbuckets = newsize;",
          "85:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "187: l_int32",
          "188: l_dnaHashGetCount(L_DNAHASH  *dahash)",
          "189: {",
          "191:     PROCNAME(\"l_dnaHashGetCount\");",
          "193:     if (!dahash)",
          "194:         return ERROR_INT(\"dahash not defined\", procName, 0);",
          "195:     return dahash->nbuckets;",
          "196: }",
          "205: l_int32",
          "206: l_dnaHashGetTotalCount(L_DNAHASH  *dahash)",
          "207: {",
          "208: l_int32  i, n;",
          "209: L_DNA   *da;",
          "211:     PROCNAME(\"l_dnaHashGetTotalCount\");",
          "213:     if (!dahash)",
          "214:         return ERROR_INT(\"dahash not defined\", procName, 0);",
          "216:     for (i = 0, n = 0; i < dahash->nbuckets; i++) {",
          "217:         da = l_dnaHashGetDna(dahash, i, L_NOCOPY);",
          "218:         if (da)",
          "219:             n += l_dnaGetCount(da);",
          "220:     }",
          "222:     return n;",
          "223: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:     l_dnaAddNumber(da, value);",
          "289:     return 0;",
          "290: }",
          "",
          "[Removed Lines]",
          "308: L_DNAHASH *",
          "309: l_dnaHashCreateFromDna(L_DNA  *da)",
          "310: {",
          "311: l_int32     i, n;",
          "312: l_uint32    nsize;",
          "313: l_uint64    key;",
          "314: l_float64   val;",
          "315: L_DNAHASH  *dahash;",
          "317:     PROCNAME(\"l_dnaHashCreateFromDna\");",
          "319:     if (!da)",
          "320:         return (L_DNAHASH *)ERROR_PTR(\"da not defined\", procName, NULL);",
          "322:     n = l_dnaGetCount(da);",
          "325:     dahash = l_dnaHashCreate(nsize, 8);",
          "326:     for (i = 0; i < n; i++) {",
          "327:         l_dnaGetDValue(da, i, &val);",
          "328:         l_hashFloat64ToUint64(nsize, val, &key);",
          "329:         l_dnaHashAdd(dahash, key, (l_float64)i);",
          "330:     }",
          "332:     return dahash;",
          "333: }",
          "352: l_ok",
          "353: l_dnaRemoveDupsByHash(L_DNA       *das,",
          "354:                       L_DNA      **pdad,",
          "355:                       L_DNAHASH  **pdahash)",
          "356: {",
          "357: l_int32     i, n, index, items;",
          "358: l_uint32    nsize;",
          "359: l_uint64    key;",
          "360: l_float64   val;",
          "361: L_DNA      *dad;",
          "362: L_DNAHASH  *dahash;",
          "364:     PROCNAME(\"l_dnaRemoveDupsByHash\");",
          "366:     if (pdahash) *pdahash = NULL;",
          "367:     if (!pdad)",
          "368:         return ERROR_INT(\"&dad not defined\", procName, 1);",
          "370:     if (!das)",
          "371:         return ERROR_INT(\"das not defined\", procName, 1);",
          "373:     n = l_dnaGetCount(das);",
          "375:     dahash = l_dnaHashCreate(nsize, 8);",
          "376:     dad = l_dnaCreate(n);",
          "378:     for (i = 0, items = 0; i < n; i++) {",
          "379:         l_dnaGetDValue(das, i, &val);",
          "380:         l_dnaFindValByHash(dad, dahash, val, &index);",
          "382:             l_hashFloat64ToUint64(nsize, val, &key);",
          "383:             l_dnaHashAdd(dahash, key, (l_float64)items);",
          "384:             l_dnaAddNumber(dad, val);",
          "385:             items++;",
          "386:         }",
          "387:     }",
          "389:     if (pdahash)",
          "391:     else",
          "392:         l_dnaHashDestroy(&dahash);",
          "393:     return 0;",
          "394: }",
          "420:                 count = l_dnaGetCount(da_nodups);",
          "429: l_ok",
          "430: l_dnaMakeHistoByHash(L_DNA       *das,",
          "431:                      L_DNAHASH  **pdahash,",
          "432:                      L_DNA      **pdav,",
          "433:                      L_DNA      **pdac)",
          "434: {",
          "435: l_int32     i, n, nitems, index, count;",
          "436: l_uint32    nsize;",
          "437: l_uint64    key;",
          "438: l_float64   val;",
          "439: L_DNA      *dac, *dav;",
          "440: L_DNAHASH  *dahash;",
          "442:     PROCNAME(\"l_dnaMakeHistoByHash\");",
          "444:     if (pdahash) *pdahash = NULL;",
          "445:     if (pdac) *pdac = NULL;",
          "446:     if (pdav) *pdav = NULL;",
          "447:     if (!pdahash)",
          "448:         return ERROR_INT(\"&dahash not defined\", procName, 1);",
          "449:     if (!das)",
          "450:         return ERROR_INT(\"das not defined\", procName, 1);",
          "451:     if ((n = l_dnaGetCount(das)) == 0)",
          "452:         return ERROR_INT(\"no data in das\", procName, 1);",
          "455:     dahash = l_dnaHashCreate(nsize, 8);",
          "458:     for (i = 0, nitems = 0; i < n; i++) {",
          "459:         l_dnaGetDValue(das, i, &val);",
          "461:         l_dnaFindValByHash(dav, dahash, val, &index);",
          "463:             l_dnaGetIValue(dac, (l_float64)index, &count);",
          "464:             l_dnaSetValue(dac, (l_float64)index, count + 1);",
          "466:             l_hashFloat64ToUint64(nsize, val, &key);",
          "467:             l_dnaHashAdd(dahash, key, (l_float64)nitems);",
          "468:             l_dnaAddNumber(dav, val);",
          "469:             l_dnaAddNumber(dac, 1);",
          "470:             nitems++;",
          "471:         }",
          "472:     }",
          "475:     if (pdac)",
          "477:     else",
          "478:         l_dnaDestroy(&dac);",
          "479:     if (pdav)",
          "481:     else",
          "482:         l_dnaDestroy(&dav);",
          "483:     return 0;",
          "484: }",
          "499: L_DNA *",
          "500: l_dnaIntersectionByHash(L_DNA  *da1,",
          "501:                         L_DNA  *da2)",
          "502: {",
          "503: l_int32     n1, n2, nsmall, nbuckets, i, index1, index2;",
          "504: l_uint32    nsize2;",
          "505: l_uint64    key;",
          "506: l_float64   val;",
          "507: L_DNAHASH  *dahash1, *dahash2;",
          "508: L_DNA      *da_small, *da_big, *dad;",
          "510:     PROCNAME(\"l_dnaIntersectionByHash\");",
          "512:     if (!da1)",
          "513:         return (L_DNA *)ERROR_PTR(\"da1 not defined\", procName, NULL);",
          "514:     if (!da2)",
          "515:         return (L_DNA *)ERROR_PTR(\"da2 not defined\", procName, NULL);",
          "518:     n1 = l_dnaGetCount(da1);",
          "519:     n2 = l_dnaGetCount(da2);",
          "522:     dahash1 = l_dnaHashCreateFromDna(da_big);",
          "527:     dad = l_dnaCreate(0);",
          "528:     nsmall = l_dnaGetCount(da_small);",
          "530:     dahash2 = l_dnaHashCreate(nsize2, 0);",
          "531:     nbuckets = l_dnaHashGetCount(dahash2);",
          "532:     for (i = 0; i < nsmall; i++) {",
          "533:         l_dnaGetDValue(da_small, i, &val);",
          "534:         l_dnaFindValByHash(da_big, dahash1, val, &index1);",
          "536:             l_dnaFindValByHash(da_small, dahash2, val, &index2);",
          "538:                 l_dnaAddNumber(dad, val);",
          "539:                 l_hashFloat64ToUint64(nbuckets, val, &key);",
          "540:                 l_dnaHashAdd(dahash2, key, (l_float64)i);",
          "541:             }",
          "542:         }",
          "543:     }",
          "545:     l_dnaHashDestroy(&dahash1);",
          "546:     l_dnaHashDestroy(&dahash2);",
          "547:     return dad;",
          "548: }",
          "567: l_ok",
          "568: l_dnaFindValByHash(L_DNA      *da,",
          "569:                    L_DNAHASH  *dahash,",
          "570:                    l_float64   val,",
          "571:                    l_int32    *pindex)",
          "572: {",
          "573: l_int32    i, nbuckets, nvals, indexval;",
          "574: l_float64  vali;",
          "575: l_uint64   key;",
          "576: L_DNA     *da1;",
          "578:     PROCNAME(\"l_dnaFindValByHash\");",
          "580:     if (!pindex)",
          "581:         return ERROR_INT(\"&index not defined\", procName, 1);",
          "583:     if (!da)",
          "584:         return ERROR_INT(\"da not defined\", procName, 1);",
          "585:     if (!dahash)",
          "586:         return ERROR_INT(\"dahash not defined\", procName, 1);",
          "588:     nbuckets = l_dnaHashGetCount(dahash);",
          "589:     l_hashFloat64ToUint64(nbuckets, val, &key);",
          "590:     da1 = l_dnaHashGetDna(dahash, key, L_NOCOPY);",
          "591:     if (!da1) return 0;",
          "594:     nvals = l_dnaGetCount(da1);",
          "595:     for (i = 0; i < nvals; i++) {",
          "596:         l_dnaGetIValue(da1, i, &indexval);",
          "597:         l_dnaGetDValue(da, indexval, &vali);",
          "598:         if (val == vali) {",
          "600:             return 0;",
          "601:         }",
          "602:     }",
          "604:     return 0;",
          "605: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/fhmtauto.c||src/fhmtauto.c": [
          "File: src/fhmtauto.c -> src/fhmtauto.c"
        ],
        "src/flipdetect.c||src/flipdetect.c": [
          "File: src/flipdetect.c -> src/flipdetect.c"
        ],
        "src/graphics.c||src/graphics.c": [
          "File: src/graphics.c -> src/graphics.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "378:     }",
          "380:     if (removedups)",
          "382:     else",
          "383:         ptad = ptaClone(ptat);",
          "",
          "[Removed Lines]",
          "381:         ptad = ptaRemoveDupsByAset(ptat);",
          "",
          "[Added Lines]",
          "381:         ptaRemoveDupsByAset(ptat, &ptad);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "546:     }",
          "548:     if (removedups)",
          "550:     else",
          "551:         ptad = ptaClone(ptat);",
          "",
          "[Removed Lines]",
          "549:         ptad = ptaRemoveDupsByAset(ptat);",
          "",
          "[Added Lines]",
          "549:         ptaRemoveDupsByAset(ptat, &ptad);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "711:     }",
          "713:     if (removedups)",
          "715:     else",
          "716:         ptad = ptaClone(ptat);",
          "",
          "[Removed Lines]",
          "714:         ptad = ptaRemoveDupsByAset(ptat);",
          "",
          "[Added Lines]",
          "714:         ptaRemoveDupsByAset(ptat, &ptad);",
          "",
          "---------------"
        ],
        "src/hashmap.c||src/hashmap.c": [
          "File: src/hashmap.c -> src/hashmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:  -  Copyright (C) 2001 Leptonica.  All rights reserved.",
          "3:  -",
          "4:  -  Redistribution and use in source and binary forms, with or without",
          "5:  -  modification, are permitted provided that the following conditions",
          "6:  -  are met:",
          "7:  -  1. Redistributions of source code must retain the above copyright",
          "8:  -     notice, this list of conditions and the following disclaimer.",
          "9:  -  2. Redistributions in binary form must reproduce the above",
          "10:  -     copyright notice, this list of conditions and the following",
          "11:  -     disclaimer in the documentation and/or other materials",
          "12:  -     provided with the distribution.",
          "13:  -",
          "14:  -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS",
          "15:  -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT",
          "16:  -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR",
          "17:  -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY",
          "18:  -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,",
          "19:  -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
          "20:  -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR",
          "21:  -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY",
          "22:  -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING",
          "23:  -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS",
          "24:  -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
          "63: #ifdef HAVE_CONFIG_H",
          "64: #include <config_auto.h>",
          "67: #include \"allheaders.h\"",
          "70: static const l_uint32  MaxTabsize = 50000000;",
          "72: static const l_int32   DefaultInitNItems = 2000;",
          "73: static const l_int32   DefaultMaxOcc = 2;",
          "101: L_HASHMAP *",
          "102: l_hmapCreate(l_int32  ninit,",
          "103:              l_int32  maxocc)",
          "104: {",
          "105: l_uint32    size, tabsize;",
          "106: L_HASHMAP  *hmap;",
          "108:     PROCNAME(\"l_hmapCreate\");",
          "110:     ninit = L_MAX(ninit, DefaultInitNItems);",
          "111:     if (maxocc <= 0) maxocc = DefaultMaxOcc;",
          "112:     if (maxocc < 1 || maxocc > 5) {",
          "113:         L_WARNING(\"maxocc = %d; non-optimal value. Set to default = %d\\n\",",
          "114:                   procName, maxocc, DefaultMaxOcc);",
          "115:         maxocc = DefaultMaxOcc;",
          "116:     }",
          "117:     size = ninit / maxocc;",
          "118:     if (size > MaxTabsize) {",
          "119:         L_ERROR(\"ninit/maxocc = %d > MaxTabsize = %d\\n\", procName,",
          "120:                 size, MaxTabsize);",
          "121:         return NULL;",
          "122:     }",
          "124:     hmap = (L_HASHMAP *)LEPT_CALLOC(1, sizeof(L_HASHMAP));",
          "126:     if ((hmap->hashtab =",
          "127:         (L_HASHITEM **)LEPT_CALLOC(tabsize, sizeof(L_HASHITEM *))) == NULL) {",
          "128:         LEPT_FREE(hmap);",
          "129:         return (L_HASHMAP *)ERROR_PTR(\"hashtab not made\", procName, NULL);",
          "130:     }",
          "132:     hmap->nitems = 0;",
          "133:     hmap->ntogo = ninit;",
          "134:     hmap->maxocc = maxocc;",
          "135:     hmap->tabsize = tabsize;",
          "136:     return hmap;",
          "137: }",
          "146: void",
          "147: l_hmapDestroy(L_HASHMAP  **phmap)",
          "148: {",
          "149: l_int32      i;",
          "150: L_HASHITEM  *hitem, *next;",
          "151: L_HASHMAP   *hmap;",
          "153:     PROCNAME(\"l_hmapDestroy\");",
          "155:     if (phmap == NULL) {",
          "156:         L_WARNING(\"ptr address is NULL!\\n\", procName);",
          "157:         return;",
          "158:     }",
          "160:     if ((hmap = *phmap) == NULL)",
          "161:         return;",
          "163:     for (i = 0; i < hmap->tabsize; i++) {",
          "164:         for (hitem = hmap->hashtab[i]; hitem != NULL; hitem = next) {",
          "165:             next = hitem->next;",
          "166:             LEPT_FREE(hitem);",
          "167:         }",
          "168:     }",
          "169:     LEPT_FREE(hmap->hashtab);",
          "170:     LEPT_FREE(hmap);",
          "172: }",
          "202: L_HASHITEM *",
          "203: l_hmapLookup(L_HASHMAP  *hmap,",
          "204:              l_uint64    key,",
          "205:              l_uint64    val,",
          "206:              l_int32     op)",
          "207: {",
          "208: l_uint32     index;",
          "209: L_HASHITEM  *hlist, *hitem;",
          "211:     PROCNAME(\"l_hmapLookup\");",
          "213:     if (!hmap)",
          "214:         return (L_HASHITEM *)ERROR_PTR(\"hmap not defined\", procName, NULL);",
          "215:     if (op != L_HMAP_CHECK && op != L_HMAP_CREATE)",
          "216:         return (L_HASHITEM *)ERROR_PTR(\"invalid op\", procName, NULL);",
          "221:     for (hitem = hlist; hitem != NULL; hitem = hitem->next) {",
          "222:         if (key == hitem->key) {",
          "223:             if (op == L_HMAP_CREATE) hitem->count++;",
          "224:             return hitem;",
          "225:         }",
          "226:     }",
          "227:     if (op == L_HMAP_CHECK) return NULL;",
          "231:     hitem = (L_HASHITEM *)LEPT_CALLOC(1, sizeof(L_HASHITEM));",
          "232:     hitem->key = key;",
          "233:     hitem->val = val;",
          "234:     hitem->count = 1;",
          "235:     hitem->next = hlist;",
          "236:     hmap->hashtab[index] = hitem;",
          "237:     hmap->nitems++;",
          "238:     hmap->ntogo--;",
          "241:     if (hmap->ntogo == 0)",
          "242:         l_hmapRehash(hmap);",
          "244:     return hitem;",
          "245: }",
          "260: l_ok",
          "261: l_hmapRehash(L_HASHMAP  *hmap)",
          "262: {",
          "263: l_int32      i, index;",
          "264: l_uint32     tabsize;",
          "265: L_HASHITEM  *hstore, *hitem, *next;",
          "267:     PROCNAME(\"l_hmapRehash\");",
          "269:     if (!hmap)",
          "270:         return ERROR_INT(\"hmap not defined\", procName, 1);",
          "275:     for (i = 0; i < hmap->tabsize; i++) {",
          "276:         for (hitem = hmap->hashtab[i]; hitem != NULL; hitem = next) {",
          "277:             next = hitem->next;",
          "278:             hitem->next = hstore;",
          "279:             hstore = hitem;",
          "280:         }",
          "281:     }",
          "284:     LEPT_FREE(hmap->hashtab);",
          "285:     findNextLargerPrime(2 * hmap->tabsize, &tabsize);",
          "286:     hmap->tabsize = tabsize;",
          "287:     hmap->hashtab = (L_HASHITEM **)LEPT_CALLOC(tabsize, sizeof(L_HASHITEM *));",
          "288:     if (hmap->hashtab == NULL) {",
          "289:         hmap->tabsize = 0;",
          "290:         return ERROR_INT(\"hashtab ptr array not made\", procName, 1);",
          "291:     }",
          "292:     hmap->ntogo = hmap->maxocc * tabsize - hmap->nitems;",
          "295:     for (hitem = hstore; hitem != NULL; hitem = next) {",
          "296:         next = hitem->next;",
          "300:     }",
          "302:     return 0;",
          "303: }",
          "",
          "---------------"
        ],
        "src/hashmap.h||src/hashmap.h": [
          "File: src/hashmap.h -> src/hashmap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:  -  Copyright (C) 2001 Leptonica.  All rights reserved.",
          "3:  -",
          "4:  -  Redistribution and use in source and binary forms, with or without",
          "5:  -  modification, are permitted provided that the following conditions",
          "6:  -  are met:",
          "7:  -  1. Redistributions of source code must retain the above copyright",
          "8:  -     notice, this list of conditions and the following disclaimer.",
          "9:  -  2. Redistributions in binary form must reproduce the above",
          "10:  -     copyright notice, this list of conditions and the following",
          "11:  -     disclaimer in the documentation and/or other materials",
          "12:  -     provided with the distribution.",
          "13:  -",
          "14:  -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS",
          "15:  -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT",
          "16:  -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR",
          "17:  -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY",
          "18:  -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,",
          "19:  -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
          "20:  -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR",
          "21:  -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY",
          "22:  -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING",
          "23:  -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS",
          "24:  -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
          "27: #ifndef  LEPTONICA_HASHMAP_H",
          "28: #define  LEPTONICA_HASHMAP_H",
          "100: struct L_Hashmap",
          "101: {",
          "108: };",
          "109: typedef struct L_Hashmap  L_HASHMAP;",
          "112:     is a l_uint64, which is hashed by the mod function to find the index",
          "114: struct L_Hashitem",
          "115: {",
          "120: };",
          "121: typedef struct L_Hashitem  L_HASHITEM;",
          "128: enum {",
          "132: };",
          "",
          "---------------"
        ],
        "src/makefile.static||src/makefile.static": [
          "File: src/makefile.static -> src/makefile.static",
          "--- Hunk 1 ---",
          "[Context before]",
          "192:   fmorphauto.c fmorphgen.1.c fmorphgenlow.1.c \\",
          "193:   fpix1.c fpix2.c \\",
          "194:   gifio.c gifiostub.c gplot.c graphics.c \\",
          "196:   jp2kheader.c jp2kheaderstub.c jp2kio.c jp2kiostub.c \\",
          "197:   jpegio.c jpegiostub.c kernel.c \\",
          "198:   libversions.c list.c map.c maze.c \\",
          "",
          "[Removed Lines]",
          "195:   graymorph.c grayquant.c heap.c jbclass.c \\",
          "",
          "[Added Lines]",
          "195:   graymorph.c grayquant.c hashmap.c heap.c jbclass.c \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "232:   array.h arrayaccess.h bbuffer.h \\",
          "233:   bmf.h bmfdata.h bmp.h ccbord.h \\",
          "234:   colorfill.h dewarp.h environ.h gplot.h \\",
          "236:   jbclass.h list.h morph.h \\",
          "237:   pix.h ptra.h queue.h rbtree.h \\",
          "238:   readbarcode.h recog.h regutils.h \\",
          "",
          "[Removed Lines]",
          "235:   heap.h imageio.h \\",
          "",
          "[Added Lines]",
          "235:   hashmap.h heap.h imageio.h \\",
          "",
          "---------------"
        ],
        "src/pix4.c||src/pix4.c": [
          "File: src/pix4.c -> src/pix4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "854:     if (!pixs || pixGetDepth(pixs) != 32)",
          "855:         return ERROR_INT(\"pixs not defined or not 32 bpp\", procName, 1);",
          "856:     da1 = pixConvertDataToDna(pixs);",
          "859:     l_dnaDestroy(&da1);",
          "860:     l_dnaDestroy(&da2);",
          "",
          "[Removed Lines]",
          "857:     l_dnaRemoveDupsByHash(da1, &da2, NULL);",
          "",
          "[Added Lines]",
          "857:     l_dnaRemoveDupsByHmap(da1, &da2, NULL);",
          "",
          "---------------"
        ],
        "src/pixalloc.c||src/pixalloc.c": [
          "File: src/pixalloc.c -> src/pixalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "418:             fprintf(fp, \"Alloc %zu bytes at %p\\n\", nbytes, data);",
          "419:             fclose(fp);",
          "420:         } else {",
          "422:         }",
          "423:     }",
          "424:     return data;",
          "",
          "[Removed Lines]",
          "421:             L_ERROR(\"failed to open stream for %s\\n\", procName, pms->logfile);",
          "",
          "[Added Lines]",
          "421:             L_ERROR(\"failed to open stream for %s\\n\", procName, pms->logfile);",
          "",
          "---------------"
        ],
        "src/ptabasic.c||src/ptabasic.c": [
          "File: src/ptabasic.c -> src/ptabasic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "385:     if (!pta)",
          "386:         return ERROR_INT(\"pta not defined\", procName, 1);",
          "394:     if ((pta->x = (l_float32 *)reallocNew((void **)&pta->x,",
          "395:                                           oldsize, newsize)) == NULL)",
          "396:         return ERROR_INT(\"new x array not returned\", procName, 1);",
          "",
          "[Removed Lines]",
          "388:         return ERROR_INT(\"pta has too many ptrs\", procName, 1);",
          "389:     oldsize = pta->nalloc * sizeof(l_float32);",
          "390:     newsize = 2 * oldsize;",
          "392:         return ERROR_INT(\"newsize > 400 MB; too large\", procName, 1);",
          "",
          "[Added Lines]",
          "388:     if (pta->nalloc > MaxArraySize)",
          "389:         return ERROR_INT(\"pta at maximum size; can't extend\", procName, 1);",
          "390:     oldsize = 4 * pta->nalloc;",
          "391:     if (pta->nalloc > MaxArraySize / 2) {",
          "392:         newsize = 4 * MaxArraySize;",
          "393:         pta->nalloc = MaxArraySize;",
          "394:     } else {",
          "395:         newsize = 2 * oldsize;",
          "396:         pta->nalloc *= 2;",
          "397:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "398:                                           oldsize, newsize)) == NULL)",
          "399:         return ERROR_INT(\"new y array not returned\", procName, 1);",
          "402:     return 0;",
          "403: }",
          "",
          "[Removed Lines]",
          "401:     pta->nalloc *= 2;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/ptafunc1.c||src/ptafunc1.c": [
          "File: src/ptafunc1.c -> src/ptafunc1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:     for (i = istart; i <= iend; i++) {",
          "189:         ptaGetIPt(ptas, i, &x, &y);",
          "191:     }",
          "193:     return 0;",
          "194: }",
          "",
          "[Removed Lines]",
          "190:         ptaAddPt(ptad, x, y);",
          "",
          "[Added Lines]",
          "190:         if (ptaAddPt(ptad, x, y) == 1) {",
          "191:             L_ERROR(\"failed to add pt at i = %d\\n\", procName, i);",
          "192:             return 1;",
          "193:         }",
          "",
          "---------------"
        ],
        "src/ptafunc2.c||src/ptafunc2.c": [
          "File: src/ptafunc2.c -> src/ptafunc2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "440: }",
          "468: {",
          "486: }",
          "504: {",
          "505: l_int32   i, n, x, y;",
          "506: PTA      *ptad;",
          "",
          "[Removed Lines]",
          "465: PTA *",
          "466: ptaUnionByAset(PTA  *pta1,",
          "467:                PTA  *pta2)",
          "469: PTA  *pta3, *ptad;",
          "471:     PROCNAME(\"ptaUnionByAset\");",
          "473:     if (!pta1)",
          "474:         return (PTA *)ERROR_PTR(\"pta1 not defined\", procName, NULL);",
          "475:     if (!pta2)",
          "476:         return (PTA *)ERROR_PTR(\"pta2 not defined\", procName, NULL);",
          "479:     pta3 = ptaCopy(pta1);",
          "480:     ptaJoin(pta3, pta2, 0, -1);",
          "483:     ptad = ptaRemoveDupsByAset(pta3);",
          "484:     ptaDestroy(&pta3);",
          "485:     return ptad;",
          "502: PTA *",
          "503: ptaRemoveDupsByAset(PTA  *ptas)",
          "",
          "[Added Lines]",
          "448: L_ASET *",
          "449: l_asetCreateFromPta(PTA  *pta)",
          "451: l_int32   i, n, x, y;",
          "452: l_uint64  hash;",
          "453: L_ASET   *set;",
          "454: RB_TYPE   key;",
          "456:     PROCNAME(\"l_asetCreateFromPta\");",
          "458:     if (!pta)",
          "459:         return (L_ASET *)ERROR_PTR(\"pta not defined\", procName, NULL);",
          "461:     set = l_asetCreate(L_UINT_TYPE);",
          "462:     n = ptaGetCount(pta);",
          "463:     for (i = 0; i < n; i++) {",
          "464:         ptaGetIPt(pta, i, &x, &y);",
          "465:         l_hashPtToUint64(x, y, &hash);",
          "466:         key.utype = hash;",
          "467:         l_asetInsert(set, key);",
          "468:     }",
          "470:     return set;",
          "488: l_ok",
          "489: ptaRemoveDupsByAset(PTA   *ptas,",
          "490:                     PTA  **pptad)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "511:     PROCNAME(\"ptaRemoveDupsByAset\");",
          "513:     if (!ptas)",
          "516:     set = l_asetCreate(L_UINT_TYPE);",
          "517:     n = ptaGetCount(ptas);",
          "518:     ptad = ptaCreate(n);",
          "519:     for (i = 0; i < n; i++) {",
          "520:         ptaGetIPt(ptas, i, &x, &y);",
          "521:         l_hashPtToUint64(x, y, &hash);",
          "",
          "[Removed Lines]",
          "514:         return (PTA *)ERROR_PTR(\"ptas not defined\", procName, NULL);",
          "",
          "[Added Lines]",
          "500:     if (!pptad)",
          "501:         return ERROR_INT(\"&ptad not defined\", procName, 1);",
          "504:         return ERROR_INT(\"ptas not defined\", procName, 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "527:     }",
          "529:     l_asetDestroy(&set);",
          "531: }",
          "552: {",
          "553: l_int32   n1, n2, i, n, x, y;",
          "554: l_uint64  hash;",
          "",
          "[Removed Lines]",
          "530:     return ptad;",
          "549: PTA *",
          "550: ptaIntersectionByAset(PTA  *pta1,",
          "551:                       PTA  *pta2)",
          "",
          "[Added Lines]",
          "521:     return 0;",
          "522: }",
          "544: l_ok",
          "545: ptaUnionByAset(PTA   *pta1,",
          "546:                PTA   *pta2,",
          "547:                PTA  **pptad)",
          "548: {",
          "549: PTA  *pta3;",
          "551:     PROCNAME(\"ptaUnionByAset\");",
          "553:     if (!pptad)",
          "554:         return ERROR_INT(\"&ptad not defined\", procName, 1);",
          "556:     if (!pta1)",
          "557:         return ERROR_INT(\"pta1 not defined\", procName, 1);",
          "558:     if (!pta2)",
          "559:         return ERROR_INT(\"pta2 not defined\", procName, 1);",
          "562:     pta3 = ptaCopy(pta1);",
          "563:     ptaJoin(pta3, pta2, 0, -1);",
          "566:     ptaRemoveDupsByAset(pta3, pptad);",
          "567:     ptaDestroy(&pta3);",
          "568:     return 0;",
          "589: l_ok",
          "590: ptaIntersectionByAset(PTA   *pta1,",
          "591:                       PTA   *pta2,",
          "592:                       PTA  **pptad)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "559:     PROCNAME(\"ptaIntersectionByAset\");",
          "561:     if (!pta1)",
          "563:     if (!pta2)",
          "567:     n1 = ptaGetCount(pta1);",
          "",
          "[Removed Lines]",
          "562:         return (PTA *)ERROR_PTR(\"pta1 not defined\", procName, NULL);",
          "564:         return (PTA *)ERROR_PTR(\"pta2 not defined\", procName, NULL);",
          "",
          "[Added Lines]",
          "602:     if (!pptad)",
          "603:         return ERROR_INT(\"&ptad not defined\", procName, 1);",
          "606:         return ERROR_INT(\"pta1 not defined\", procName, 1);",
          "608:         return ERROR_INT(\"pta2 not defined\", procName, 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "587:     l_asetDestroy(&set1);",
          "588:     l_asetDestroy(&set2);",
          "590: }",
          "601: {",
          "609:     if (!pta)",
          "613:     n = ptaGetCount(pta);",
          "614:     for (i = 0; i < n; i++) {",
          "615:         ptaGetIPt(pta, i, &x, &y);",
          "619:     }",
          "622: }",
          "691: l_ok",
          "693:                     PTA        **pptad,",
          "695: {",
          "705:     if (!pptad)",
          "706:         return ERROR_INT(\"&ptad not defined\", procName, 1);",
          "708:     if (!ptas)",
          "709:         return ERROR_INT(\"ptas not defined\", procName, 1);",
          "722:             ptaAddPt(ptad, x, y);",
          "724:         }",
          "725:     }",
          "729:     else",
          "731:     return 0;",
          "732: }",
          "751: {",
          "760:     if (!pta1)",
          "762:     if (!pta2)",
          "790:     }",
          "795: }",
          "821: l_ok",
          "869: {",
          "892:     for (i = 0; i < n; i++) {",
          "894:         l_hashPtToUint64(x, y, &key);",
          "896:     }",
          "899: }",
          "",
          "[Removed Lines]",
          "589:     return ptad;",
          "599: L_ASET *",
          "600: l_asetCreateFromPta(PTA  *pta)",
          "602: l_int32   i, n, x, y;",
          "603: l_uint64  hash;",
          "604: L_ASET   *set;",
          "605: RB_TYPE   key;",
          "607:     PROCNAME(\"l_asetCreateFromPta\");",
          "610:         return (L_ASET *)ERROR_PTR(\"pta not defined\", procName, NULL);",
          "612:     set = l_asetCreate(L_UINT_TYPE);",
          "616:         l_hashPtToUint64(x, y, &hash);",
          "617:         key.utype = hash;",
          "618:         l_asetInsert(set, key);",
          "621:     return set;",
          "641: PTA *",
          "642: ptaUnionByHash(PTA  *pta1,",
          "643:                PTA  *pta2)",
          "644: {",
          "645: PTA  *pta3, *ptad;",
          "647:     PROCNAME(\"ptaUnionByHash\");",
          "649:     if (!pta1)",
          "650:         return (PTA *)ERROR_PTR(\"pta1 not defined\", procName, NULL);",
          "651:     if (!pta2)",
          "652:         return (PTA *)ERROR_PTR(\"pta2 not defined\", procName, NULL);",
          "655:     pta3 = ptaCopy(pta1);",
          "656:     ptaJoin(pta3, pta2, 0, -1);",
          "659:     ptaRemoveDupsByHash(pta3, &ptad, NULL);",
          "660:     ptaDestroy(&pta3);",
          "661:     return ptad;",
          "662: }",
          "692: ptaRemoveDupsByHash(PTA         *ptas,",
          "694:                     L_DNAHASH  **pdahash)",
          "696: l_int32     i, n, index, items, x, y;",
          "697: l_uint32    nsize;",
          "698: l_uint64    key;",
          "699: PTA        *ptad;",
          "700: L_DNAHASH  *dahash;",
          "702:     PROCNAME(\"ptaRemoveDupsByHash\");",
          "704:     if (pdahash) *pdahash = NULL;",
          "711:     n = ptaGetCount(ptas);",
          "713:     dahash = l_dnaHashCreate(nsize, 8);",
          "714:     ptad = ptaCreate(n);",
          "716:     for (i = 0, items = 0; i < n; i++) {",
          "717:         ptaGetIPt(ptas, i, &x, &y);",
          "718:         ptaFindPtByHash(ptad, dahash, x, y, &index);",
          "720:             l_hashPtToUint64(x, y, &key);",
          "721:             l_dnaHashAdd(dahash, key, (l_float64)items);",
          "723:             items++;",
          "727:     if (pdahash)",
          "730:         l_dnaHashDestroy(&dahash);",
          "748: PTA *",
          "749: ptaIntersectionByHash(PTA  *pta1,",
          "750:                       PTA  *pta2)",
          "752: l_int32     n1, n2, nsmall, i, x, y, index1, index2;",
          "753: l_uint32    nsize2;",
          "754: l_uint64    key;",
          "755: L_DNAHASH  *dahash1, *dahash2;",
          "756: PTA        *pta_small, *pta_big, *ptad;",
          "758:     PROCNAME(\"ptaIntersectionByHash\");",
          "761:         return (PTA *)ERROR_PTR(\"pta1 not defined\", procName, NULL);",
          "763:         return (PTA *)ERROR_PTR(\"pta2 not defined\", procName, NULL);",
          "766:     n1 = ptaGetCount(pta1);",
          "767:     n2 = ptaGetCount(pta2);",
          "770:     dahash1 = l_dnaHashCreateFromPta(pta_big);",
          "775:     ptad = ptaCreate(0);",
          "776:     nsmall = ptaGetCount(pta_small);",
          "778:     dahash2 = l_dnaHashCreate(nsize2, 0);",
          "779:     for (i = 0; i < nsmall; i++) {",
          "780:         ptaGetIPt(pta_small, i, &x, &y);",
          "781:         ptaFindPtByHash(pta_big, dahash1, x, y, &index1);",
          "783:             ptaFindPtByHash(pta_small, dahash2, x, y, &index2);",
          "785:                 ptaAddPt(ptad, x, y);",
          "786:                 l_hashPtToUint64(x, y, &key);",
          "787:                 l_dnaHashAdd(dahash2, key, (l_float64)i);",
          "788:             }",
          "789:         }",
          "792:     l_dnaHashDestroy(&dahash1);",
          "793:     l_dnaHashDestroy(&dahash2);",
          "794:     return ptad;",
          "822: ptaFindPtByHash(PTA        *pta,",
          "823:                 L_DNAHASH  *dahash,",
          "824:                 l_int32     x,",
          "825:                 l_int32     y,",
          "826:                 l_int32    *pindex)",
          "827: {",
          "828: l_int32   i, nvals, index, xi, yi;",
          "829: l_uint64  key;",
          "830: L_DNA    *da;",
          "832:     PROCNAME(\"ptaFindPtByHash\");",
          "834:     if (!pindex)",
          "835:         return ERROR_INT(\"&index not defined\", procName, 1);",
          "837:     if (!pta)",
          "838:         return ERROR_INT(\"pta not defined\", procName, 1);",
          "839:     if (!dahash)",
          "840:         return ERROR_INT(\"dahash not defined\", procName, 1);",
          "842:     l_hashPtToUint64(x, y, &key);",
          "843:     da = l_dnaHashGetDna(dahash, key, L_NOCOPY);",
          "844:     if (!da) return 0;",
          "847:     nvals = l_dnaGetCount(da);",
          "848:     for (i = 0; i < nvals; i++) {",
          "849:         l_dnaGetIValue(da, i, &index);",
          "850:         ptaGetIPt(pta, index, &xi, &yi);",
          "851:         if (x == xi && y == yi) {",
          "853:             return 0;",
          "854:         }",
          "855:     }",
          "857:     return 0;",
          "858: }",
          "867: L_DNAHASH *",
          "868: l_dnaHashCreateFromPta(PTA  *pta)",
          "870: l_int32     i, n, x, y;",
          "871: l_uint32    nsize;",
          "872: l_uint64    key;",
          "873: L_DNAHASH  *dahash;",
          "875:     PROCNAME(\"l_dnaHashCreateFromPta\");",
          "877:     if (!pta)",
          "878:         return (L_DNAHASH *)ERROR_PTR(\"pta not defined\", procName, NULL);",
          "884:     n = ptaGetCount(pta);",
          "891:     dahash = l_dnaHashCreate(nsize, 8);",
          "893:         ptaGetIPt(pta, i, &x, &y);",
          "895:         l_dnaHashAdd(dahash, key, (l_float64)i);",
          "898:     return dahash;",
          "",
          "[Added Lines]",
          "634:     return 0;",
          "653: L_HASHMAP *",
          "654: l_hmapCreateFromPta(PTA  *pta)",
          "656: l_int32      i, n, x, y;",
          "657: l_uint64     key;",
          "658: L_HASHITEM  *hitem;",
          "659: L_HASHMAP   *hmap;",
          "661:     PROCNAME(\"l_hmapCreateFromPta\");",
          "664:         return (L_HASHMAP *)ERROR_PTR(\"pta not defined\", procName, NULL);",
          "667:     if ((hmap = l_hmapCreate(0.51 * n, 2)) == NULL)",
          "668:         return (L_HASHMAP *)ERROR_PTR(\"hmap not made\", procName, NULL);",
          "671:         l_hashPtToUint64(x, y, &key);",
          "672:         hitem = l_hmapLookup(hmap, key, i, L_HMAP_CREATE);",
          "674:     return hmap;",
          "692: ptaRemoveDupsByHmap(PTA         *ptas,",
          "694:                     L_HASHMAP  **phmap)",
          "696: l_int32      i, x, y, tabsize;",
          "697: l_uint64     key;",
          "698: PTA         *ptad;",
          "699: L_HASHITEM  *hitem;",
          "700: L_HASHMAP   *hmap;",
          "702:     PROCNAME(\"ptaRemoveDupsByHmap\");",
          "704:     if (phmap) *phmap = NULL;",
          "712:     if ((hmap = l_hmapCreateFromPta(ptas)) == NULL)",
          "713:         return ERROR_INT(\"hmap not made\", procName, 1);",
          "714:     ptad = ptaCreate(0);",
          "716:     tabsize = hmap->tabsize;",
          "717:     for (i = 0; i < tabsize; i++) {",
          "718:         hitem = hmap->hashtab[i];",
          "719:         while (hitem) {",
          "720:             ptaGetIPt(ptas, hitem->val, &x, &y);",
          "722:             hitem = hitem->next;",
          "726:     if (phmap)",
          "729:         l_hmapDestroy(&hmap);",
          "747: l_ok",
          "748: ptaUnionByHmap(PTA   *pta1,",
          "749:                PTA   *pta2,",
          "750:                PTA  **pptad)",
          "752: PTA  *pta3;",
          "754:     PROCNAME(\"ptaUnionByHmap\");",
          "756:     if (!pptad)",
          "757:         return ERROR_INT(\"&ptad not defined\", procName, 1);",
          "760:         return ERROR_INT(\"pta1 not defined\", procName, 1);",
          "762:         return ERROR_INT(\"pta2 not defined\", procName, 1);",
          "764:     pta3 = ptaCopy(pta1);",
          "765:     if (ptaJoin(pta3, pta2, 0, -1) == 1) {",
          "766:         ptaDestroy(&pta3);",
          "767:         return ERROR_INT(\"pta join failed\", procName, 1);",
          "769:     ptaRemoveDupsByHmap(pta3, pptad, NULL);",
          "770:     ptaDestroy(&pta3);",
          "771:     return 0;",
          "789: ptaIntersectionByHmap(PTA   *pta1,",
          "790:                       PTA   *pta2,",
          "791:                       PTA  **pptad)",
          "793: l_int32      i, n1, n2, n, x, y;",
          "794: l_uint64     key;",
          "795: PTA         *pta_small, *pta_big, *ptad;",
          "796: L_HASHITEM  *hitem;",
          "797: L_HASHMAP   *hmap;",
          "799:     PROCNAME(\"ptaIntersectionByHmap\");",
          "801:     if (!pptad)",
          "802:         return ERROR_INT(\"&ptad not defined\", procName, 1);",
          "804:     if (!pta1)",
          "805:         return ERROR_INT(\"pta1 not defined\", procName, 1);",
          "806:     if (!pta2)",
          "807:         return ERROR_INT(\"pta2 not defined\", procName, 1);",
          "810:     n1 = ptaGetCount(pta1);",
          "811:     n2 = ptaGetCount(pta2);",
          "814:     if ((hmap = l_hmapCreateFromPta(pta_big)) == NULL)",
          "815:         return ERROR_INT(\"hmap not made\", procName, 1);",
          "822:     ptad = ptaCreate(0);",
          "824:     n = ptaGetCount(pta_small);",
          "826:         ptaGetIPt(pta_small, i, &x, &y);",
          "828:         hitem = l_hmapLookup(hmap, key, i, L_HMAP_CHECK);",
          "829:         if (!hitem || hitem->count == 0)",
          "830:             continue;",
          "831:         ptaAddPt(ptad, x, y);",
          "832:         hitem->count = 0;",
          "834:     l_hmapDestroy(&hmap);",
          "835:     return 0;",
          "",
          "---------------"
        ],
        "src/sarray1.c||src/sarray1.c": [
          "File: src/sarray1.c -> src/sarray1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "500:     if (!sa)",
          "501:         return ERROR_INT(\"sa not defined\", procName, 1);",
          "504:     oldsize = sa->nalloc * sizeof(char *);",
          "509:     if ((sa->array = (char **)reallocNew((void **)&sa->array,",
          "510:                                          oldsize, newsize)) == NULL)",
          "511:         return ERROR_INT(\"new ptr array not returned\", procName, 1);",
          "514:     return 0;",
          "515: }",
          "",
          "[Removed Lines]",
          "503:         return ERROR_INT(\"sa has too many ptrs\", procName, 1);",
          "505:     newsize = 2 * oldsize;",
          "507:         return ERROR_INT(\"newsize > 200 MB; too large\", procName, 1);",
          "513:     sa->nalloc *= 2;",
          "",
          "[Added Lines]",
          "502:     if (sa->nalloc >= MaxPtrArraySize)",
          "503:         return ERROR_INT(\"sa at maximum ptr size; can't extend\", procName, 1);",
          "505:     if (sa->nalloc > MaxPtrArraySize / 2) {",
          "506:         newsize = MaxPtrArraySize * sizeof(char *);",
          "507:         sa->nalloc = MaxPtrArraySize;",
          "508:     } else {",
          "509:         newsize = 2 * oldsize;",
          "510:         sa->nalloc *= 2;",
          "511:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "980:     n = sarrayGetCount(sa2);",
          "981:     for (i = 0; i < n; i++) {",
          "982:         str = sarrayGetString(sa2, i, L_NOCOPY);",
          "984:     }",
          "986:     return 0;",
          "987: }",
          "",
          "[Removed Lines]",
          "983:         sarrayAddString(sa1, str, L_COPY);",
          "",
          "[Added Lines]",
          "985:         if (sarrayAddString(sa1, str, L_COPY) == 1) {",
          "986:             L_ERROR(\"failed to add string at i = %d\\n\", procName, i);",
          "987:             return 1;",
          "988:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1282: SARRAY *",
          "1286: {",
          "1287: char    *str;",
          "1288: l_int32  n, i;",
          "1289: SARRAY  *saout;",
          "1293:     if (!sain)",
          "1294:         return (SARRAY *)ERROR_PTR(\"sain not defined\", procName, NULL);",
          "",
          "[Removed Lines]",
          "1283: sarraySelectByRange(SARRAY  *sain,",
          "1284:                     l_int32  first,",
          "1285:                     l_int32  last)",
          "1291:     PROCNAME(\"sarraySelectByRange\");",
          "",
          "[Added Lines]",
          "1287: sarraySelectRange(SARRAY  *sain,",
          "1288:                   l_int32  first,",
          "1289:                   l_int32  last)",
          "1295:     PROCNAME(\"sarraySelectRange\");",
          "",
          "---------------"
        ],
        "src/sarray2.c||src/sarray2.c": [
          "File: src/sarray2.c -> src/sarray2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "243: {",
          "261: }",
          "",
          "[Removed Lines]",
          "240: SARRAY *",
          "241: sarrayUnionByAset(SARRAY  *sa1,",
          "242:                   SARRAY  *sa2)",
          "244: SARRAY  *sa3, *sad;",
          "246:     PROCNAME(\"sarrayUnionByAset\");",
          "248:     if (!sa1)",
          "249:         return (SARRAY *)ERROR_PTR(\"sa1 not defined\", procName, NULL);",
          "250:     if (!sa2)",
          "251:         return (SARRAY *)ERROR_PTR(\"sa2 not defined\", procName, NULL);",
          "254:     sa3 = sarrayCopy(sa1);",
          "255:     sarrayJoin(sa3, sa2);",
          "258:     sad = sarrayRemoveDupsByAset(sa3);",
          "259:     sarrayDestroy(&sa3);",
          "260:     return sad;",
          "",
          "[Added Lines]",
          "228: L_ASET *",
          "229: l_asetCreateFromSarray(SARRAY  *sa)",
          "231: char     *str;",
          "232: l_int32   i, n;",
          "233: l_uint64  hash;",
          "234: L_ASET   *set;",
          "235: RB_TYPE   key;",
          "237:     PROCNAME(\"l_asetCreateFromSarray\");",
          "239:     if (!sa)",
          "240:         return (L_ASET *)ERROR_PTR(\"sa not defined\", procName, NULL);",
          "242:     set = l_asetCreate(L_UINT_TYPE);",
          "243:     n = sarrayGetCount(sa);",
          "244:     for (i = 0; i < n; i++) {",
          "245:         str = sarrayGetString(sa, i, L_NOCOPY);",
          "246:         l_hashStringToUint64Fast(str, &hash);",
          "247:         key.utype = hash;",
          "248:         l_asetInsert(set, key);",
          "249:     }",
          "251:     return set;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "282: {",
          "283: char     *str;",
          "284: l_int32   i, n;",
          "",
          "[Removed Lines]",
          "280: SARRAY *",
          "281: sarrayRemoveDupsByAset(SARRAY  *sas)",
          "",
          "[Added Lines]",
          "272: l_ok",
          "273: sarrayRemoveDupsByAset(SARRAY   *sas,",
          "274:                        SARRAY  **psad)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "290:     PROCNAME(\"sarrayRemoveDupsByAset\");",
          "292:     if (!sas)",
          "295:     set = l_asetCreate(L_UINT_TYPE);",
          "296:     sad = sarrayCreate(0);",
          "297:     n = sarrayGetCount(sas);",
          "298:     for (i = 0; i < n; i++) {",
          "299:         str = sarrayGetString(sas, i, L_NOCOPY);",
          "301:         key.utype = hash;",
          "302:         if (!l_asetFind(set, key)) {",
          "303:             sarrayAddString(sad, str, L_COPY);",
          "",
          "[Removed Lines]",
          "293:         return (SARRAY *)ERROR_PTR(\"sas not defined\", procName, NULL);",
          "300:         l_hashStringToUint64(str, &hash);",
          "",
          "[Added Lines]",
          "285:     if (!psad)",
          "286:         return ERROR_INT(\"&sad not defined\", procName, 1);",
          "289:         return ERROR_INT(\"sas not defined\", procName, 1);",
          "297:         l_hashStringToUint64Fast(str, &hash);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "306:     }",
          "308:     l_asetDestroy(&set);",
          "310: }",
          "",
          "[Removed Lines]",
          "309:     return sad;",
          "",
          "[Added Lines]",
          "306:     return 0;",
          "307: }",
          "328: l_ok",
          "329: sarrayUnionByAset(SARRAY   *sa1,",
          "330:                   SARRAY   *sa2,",
          "331:                   SARRAY  **psad)",
          "332: {",
          "333: SARRAY  *sa3;",
          "335:     PROCNAME(\"sarrayUnionByAset\");",
          "337:     if (!psad)",
          "338:         return ERROR_INT(\"&sad not defined\", procName, 1);",
          "340:     if (!sa1)",
          "341:         return ERROR_INT(\"sa1 not defined\", procName, 1);",
          "342:     if (!sa2)",
          "343:         return ERROR_INT(\"sa2 not defined\", procName, 1);",
          "346:     sa3 = sarrayCopy(sa1);",
          "347:     if (sarrayJoin(sa3, sa2) == 1) {",
          "348:         sarrayDestroy(&sa3);",
          "349:         return ERROR_INT(\"join failed for sa3\", procName, 1);",
          "350:     }",
          "353:     sarrayRemoveDupsByAset(sa3, psad);",
          "354:     sarrayDestroy(&sa3);",
          "355:     return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "334: {",
          "335: char     *str;",
          "336: l_int32   n1, n2, i, n;",
          "",
          "[Removed Lines]",
          "331: SARRAY *",
          "332: sarrayIntersectionByAset(SARRAY  *sa1,",
          "333:                          SARRAY  *sa2)",
          "",
          "[Added Lines]",
          "379: l_ok",
          "380: sarrayIntersectionByAset(SARRAY   *sa1,",
          "381:                          SARRAY   *sa2,",
          "382:                          SARRAY  **psad)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "342:     PROCNAME(\"sarrayIntersectionByAset\");",
          "344:     if (!sa1)",
          "346:     if (!sa2)",
          "350:     n1 = sarrayGetCount(sa1);",
          "",
          "[Removed Lines]",
          "345:         return (SARRAY *)ERROR_PTR(\"sa1 not defined\", procName, NULL);",
          "347:         return (SARRAY *)ERROR_PTR(\"sa2 not defined\", procName, NULL);",
          "",
          "[Added Lines]",
          "393:     if (!psad)",
          "394:         return ERROR_INT(\"&sad not defined\", procName, 1);",
          "397:         return ERROR_INT(\"sa1 not defined\", procName, 1);",
          "399:         return ERROR_INT(\"sa2 not defined\", procName, 1);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "357:     sad = sarrayCreate(0);",
          "358:     n = sarrayGetCount(sa_small);",
          "359:     set2 = l_asetCreate(L_UINT_TYPE);",
          "360:     for (i = 0; i < n; i++) {",
          "361:         str = sarrayGetString(sa_small, i, L_NOCOPY);",
          "363:         key.utype = hash;",
          "364:         if (l_asetFind(set1, key) && !l_asetFind(set2, key)) {",
          "365:             sarrayAddString(sad, str, L_COPY);",
          "",
          "[Removed Lines]",
          "362:         l_hashStringToUint64(str, &hash);",
          "",
          "[Added Lines]",
          "415:         l_hashStringToUint64Fast(str, &hash);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "370:     l_asetDestroy(&set1);",
          "371:     l_asetDestroy(&set2);",
          "373: }",
          "384: {",
          "393:     if (!sa)",
          "397:     n = sarrayGetCount(sa);",
          "398:     for (i = 0; i < n; i++) {",
          "399:         str = sarrayGetString(sa, i, L_NOCOPY);",
          "403:     }",
          "406: }",
          "434: l_ok",
          "436:                        SARRAY     **psad,",
          "438: {",
          "449:     if (!psad)",
          "450:         return ERROR_INT(\"&sad not defined\", procName, 1);",
          "452:     if (!sas)",
          "453:         return ERROR_INT(\"sas not defined\", procName, 1);",
          "468:         }",
          "469:     }",
          "473:     else",
          "475:     return 0;",
          "476: }",
          "494: {",
          "504:     if (!sa1)",
          "506:     if (!sa2)",
          "534:     }",
          "539: }",
          "565: l_ok",
          "570: {",
          "631:     for (i = 0; i < n; i++) {",
          "635:     }",
          "638: }",
          "",
          "[Removed Lines]",
          "372:     return sad;",
          "382: L_ASET *",
          "383: l_asetCreateFromSarray(SARRAY  *sa)",
          "385: char     *str;",
          "386: l_int32   i, n;",
          "387: l_uint64  hash;",
          "388: L_ASET   *set;",
          "389: RB_TYPE   key;",
          "391:     PROCNAME(\"l_asetCreateFromSarray\");",
          "394:         return (L_ASET *)ERROR_PTR(\"sa not defined\", procName, NULL);",
          "396:     set = l_asetCreate(L_UINT_TYPE);",
          "400:         l_hashStringToUint64(str, &hash);",
          "401:         key.utype = hash;",
          "402:         l_asetInsert(set, key);",
          "405:     return set;",
          "435: sarrayRemoveDupsByHash(SARRAY      *sas,",
          "437:                        L_DNAHASH  **pdahash)",
          "439: char       *str;",
          "440: l_int32     i, n, index, items;",
          "441: l_uint32    nsize;",
          "442: l_uint64    key;",
          "443: SARRAY     *sad;",
          "444: L_DNAHASH  *dahash;",
          "446:     PROCNAME(\"sarrayRemoveDupsByHash\");",
          "448:     if (pdahash) *pdahash = NULL;",
          "455:     n = sarrayGetCount(sas);",
          "457:     dahash = l_dnaHashCreate(nsize, 8);",
          "458:     sad = sarrayCreate(n);",
          "460:     for (i = 0, items = 0; i < n; i++) {",
          "461:         str = sarrayGetString(sas, i, L_NOCOPY);",
          "462:         sarrayFindStringByHash(sad, dahash, str, &index);",
          "464:             l_hashStringToUint64(str, &key);",
          "465:             l_dnaHashAdd(dahash, key, (l_float64)items);",
          "466:             sarrayAddString(sad, str, L_COPY);",
          "467:             items++;",
          "471:     if (pdahash)",
          "474:         l_dnaHashDestroy(&dahash);",
          "491: SARRAY *",
          "492: sarrayIntersectionByHash(SARRAY  *sa1,",
          "493:                          SARRAY  *sa2)",
          "495: char       *str;",
          "496: l_int32     n1, n2, nsmall, i, index1, index2;",
          "497: l_uint32    nsize2;",
          "498: l_uint64    key;",
          "499: L_DNAHASH  *dahash1, *dahash2;",
          "500: SARRAY     *sa_small, *sa_big, *sad;",
          "502:     PROCNAME(\"sarrayIntersectionByHash\");",
          "505:         return (SARRAY *)ERROR_PTR(\"sa1 not defined\", procName, NULL);",
          "507:         return (SARRAY *)ERROR_PTR(\"sa2 not defined\", procName, NULL);",
          "510:     n1 = sarrayGetCount(sa1);",
          "511:     n2 = sarrayGetCount(sa2);",
          "514:     dahash1 = l_dnaHashCreateFromSarray(sa_big);",
          "519:     sad = sarrayCreate(0);",
          "520:     nsmall = sarrayGetCount(sa_small);",
          "522:     dahash2 = l_dnaHashCreate(nsize2, 0);",
          "523:     for (i = 0; i < nsmall; i++) {",
          "524:         str = sarrayGetString(sa_small, i, L_NOCOPY);",
          "525:         sarrayFindStringByHash(sa_big, dahash1, str, &index1);",
          "526:         if (index1 >= 0) {",
          "527:             sarrayFindStringByHash(sa_small, dahash2, str, &index2);",
          "528:             if (index2 == -1) {",
          "529:                 sarrayAddString(sad, str, L_COPY);",
          "530:                 l_hashStringToUint64(str, &key);",
          "531:                 l_dnaHashAdd(dahash2, key, (l_float64)i);",
          "532:             }",
          "533:         }",
          "536:     l_dnaHashDestroy(&dahash1);",
          "537:     l_dnaHashDestroy(&dahash2);",
          "538:     return sad;",
          "566: sarrayFindStringByHash(SARRAY      *sa,",
          "567:                        L_DNAHASH   *dahash,",
          "568:                        const char  *str,",
          "569:                        l_int32     *pindex)",
          "571: char     *stri;",
          "572: l_int32   i, nvals, index;",
          "573: l_uint64  key;",
          "574: L_DNA    *da;",
          "576:     PROCNAME(\"sarrayFindStringByHash\");",
          "578:     if (!pindex)",
          "579:         return ERROR_INT(\"&index not defined\", procName, 1);",
          "581:     if (!sa)",
          "582:         return ERROR_INT(\"sa not defined\", procName, 1);",
          "583:     if (!dahash)",
          "584:         return ERROR_INT(\"dahash not defined\", procName, 1);",
          "586:     l_hashStringToUint64(str, &key);",
          "587:     da = l_dnaHashGetDna(dahash, key, L_NOCOPY);",
          "588:     if (!da) return 0;",
          "591:     nvals = l_dnaGetCount(da);",
          "592:     for (i = 0; i < nvals; i++) {",
          "593:         l_dnaGetIValue(da, i, &index);",
          "594:         stri = sarrayGetString(sa, index, L_NOCOPY);",
          "597:             return 0;",
          "598:         }",
          "599:     }",
          "601:     return 0;",
          "602: }",
          "611: L_DNAHASH *",
          "612: l_dnaHashCreateFromSarray(SARRAY  *sa)",
          "613: {",
          "614: char       *str;",
          "615: l_int32     i, n;",
          "616: l_uint32    nsize;",
          "617: l_uint64    key;",
          "618: L_DNAHASH  *dahash;",
          "623:     n = sarrayGetCount(sa);",
          "630:     dahash = l_dnaHashCreate(nsize, 8);",
          "632:         str = sarrayGetString(sa, i, L_NOCOPY);",
          "633:         l_hashStringToUint64(str, &key);",
          "634:         l_dnaHashAdd(dahash, key, (l_float64)i);",
          "637:     return dahash;",
          "",
          "[Added Lines]",
          "425:     return 0;",
          "438: L_HASHMAP *",
          "439: l_hmapCreateFromSarray(SARRAY  *sa)",
          "441: l_int32      i, n;",
          "442: l_uint64     key;",
          "443: char        *str;",
          "444: L_HASHITEM  *hitem;",
          "445: L_HASHMAP   *hmap;",
          "447:     PROCNAME(\"l_hmapCreateFromSarray\");",
          "450:         return (L_HASHMAP *)ERROR_PTR(\"sa not defined\", procName, NULL);",
          "453:     if ((hmap = l_hmapCreate(0.51 * n, 2)) == NULL)",
          "454:         return (L_HASHMAP *)ERROR_PTR(\"hmap not made\", procName, NULL);",
          "457:         l_hashStringToUint64Fast(str, &key);",
          "458:         hitem = l_hmapLookup(hmap, key, i, L_HMAP_CREATE);",
          "460:     return hmap;",
          "473: sarrayRemoveDupsByHmap(SARRAY      *sas,",
          "475:                        L_HASHMAP  **phmap)",
          "477: l_int32      i, tabsize;",
          "478: l_uint64     key;",
          "479: char        *str;",
          "480: SARRAY      *sad;",
          "481: L_HASHITEM  *hitem;",
          "482: L_HASHMAP   *hmap;",
          "484:     PROCNAME(\"sarrayRemoveDupsByHmap\");",
          "486:     if (phmap) *phmap = NULL;",
          "494:     if ((hmap = l_hmapCreateFromSarray(sas)) == NULL)",
          "495:         return ERROR_INT(\"hmap not made\", procName, 1);",
          "496:     sad = sarrayCreate(0);",
          "498:     tabsize = hmap->tabsize;",
          "499:     for (i = 0; i < tabsize; i++) {",
          "500:         hitem = hmap->hashtab[i];",
          "501:         while (hitem) {",
          "502:             str = sarrayGetString(sas, hitem->val, L_COPY);",
          "503:             sarrayAddString(sad, str, L_INSERT);",
          "504:             hitem = hitem->next;",
          "508:     if (phmap)",
          "511:         l_hmapDestroy(&hmap);",
          "524: l_ok",
          "525: sarrayUnionByHmap(SARRAY   *sa1,",
          "526:                   SARRAY   *sa2,",
          "527:                   SARRAY  **psad)",
          "529: SARRAY  *sa3;",
          "531:     PROCNAME(\"l_hmapUnionSarray\");",
          "533:     if (!psad)",
          "534:         return ERROR_INT(\"&sad not defined\", procName, 1);",
          "537:         return ERROR_INT(\"sa1 not defined\", procName, 1);",
          "539:         return ERROR_INT(\"sa2 not defined\", procName, 1);",
          "541:     sa3 = sarrayCopy(sa1);",
          "542:     if (sarrayJoin(sa3, sa2) == 1) {",
          "543:         sarrayDestroy(&sa3);",
          "544:         return ERROR_INT(\"sa3 join failed\", procName, 1);",
          "546:     sarrayRemoveDupsByHmap(sa3, psad, NULL);",
          "547:     sarrayDestroy(&sa3);",
          "548:     return 0;",
          "561: sarrayIntersectionByHmap(SARRAY   *sa1,",
          "562:                          SARRAY   *sa2,",
          "563:                          SARRAY  **psad)",
          "565: l_int32      i, n1, n2, n;",
          "566: l_uint64     key;",
          "567: char        *str;",
          "568: SARRAY      *sa_small, *sa_big, *sa3, *sad;",
          "569: L_HASHITEM  *hitem;",
          "570: L_HASHMAP   *hmap;",
          "572:     PROCNAME(\"sarrayIntersectionByHmap\");",
          "574:     if (!psad)",
          "575:         return ERROR_INT(\"&sad not defined\", procName, 1);",
          "577:     if (!sa1)",
          "578:         return ERROR_INT(\"sa1 not defined\", procName, 1);",
          "579:     if (!sa2)",
          "580:         return ERROR_INT(\"sa2 not defined\", procName, 1);",
          "583:     n1 = sarrayGetCount(sa1);",
          "584:     n2 = sarrayGetCount(sa2);",
          "587:     if ((hmap = l_hmapCreateFromSarray(sa_big)) == NULL)",
          "588:         return ERROR_INT(\"hmap not made\", procName, 1);",
          "594:     sarrayRemoveDupsByHmap(sa_small, &sa3, NULL);",
          "599:     sad = sarrayCreate(0);",
          "601:     n = sarrayGetCount(sa3);",
          "603:         str = sarrayGetString(sa3, i, L_NOCOPY);",
          "604:         l_hashStringToUint64Fast(str, &key);",
          "605:         hitem = l_hmapLookup(hmap, key, i, L_HMAP_CHECK);",
          "606:         if (hitem)",
          "607:             sarrayAddString(sad, str, L_COPY);",
          "609:     l_hmapDestroy(&hmap);",
          "610:     sarrayDestroy(&sa3);",
          "611:     return 0;",
          "",
          "---------------"
        ],
        "src/sel1.c||src/sel1.c": [
          "File: src/sel1.c -> src/sel1.c"
        ],
        "src/tiffio.c||src/tiffio.c": [
          "File: src/tiffio.c -> src/tiffio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "578:            a raster of image pixels (packedbpl) and the size of the tiff",
          "579:            buffer (tiffbuf) is either 1:1 or approximately 2:1, depending",
          "583:     tiffbpl = TIFFScanlineSize(tif);",
          "584:     packedbpl = (bps * spp * w + 7) / 8;",
          "586: #if 0",
          "587:     if (halfsize)",
          "588:         L_INFO(\"packedbpl = %d is approx. twice tiffbpl = %d\\n\", procName,",
          "",
          "[Removed Lines]",
          "580:            on how the data is stored and subsampled.  Allow some slop",
          "581:            when validating the relation between buffer size and the image",
          "585:     halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;",
          "",
          "[Added Lines]",
          "581:            on how the data is stored and subsampled.  Test this relation",
          "585:     halfsize = (L_ABS(2 * tiffbpl - packedbpl) <= 8);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "595:         return NULL;",
          "596:     }",
          "598:     if ((pix = pixCreate(w, h, d)) == NULL)",
          "599:         return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);",
          "600:     pixSetInputFormat(pix, IFF_TIFF);",
          "601:     data = (l_uint8 *)pixGetData(pix);",
          "602:     wpl = pixGetWpl(pix);",
          "603:     bpl = 4 * wpl;",
          "605:     if (spp == 1) {",
          "607:         for (i = 0; i < h; i++) {",
          "608:             if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {",
          "609:                 LEPT_FREE(linebuf);",
          "",
          "[Removed Lines]",
          "606:         linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));",
          "",
          "[Added Lines]",
          "607:         linebuf = (l_uint8 *)LEPT_CALLOC(4 * wpl, sizeof(l_uint8));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "622:         L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);",
          "623:         pixSetSpp(pix, 4);",
          "625:         pixdata = pixGetData(pix);",
          "626:         for (i = 0; i < h; i++) {",
          "627:             if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {",
          "",
          "[Removed Lines]",
          "624:         linebuf = (l_uint8 *)LEPT_CALLOC(2 * tiffbpl + 1, sizeof(l_uint8));",
          "",
          "[Added Lines]",
          "625:         linebuf = (l_uint8 *)LEPT_CALLOC(4 * wpl, sizeof(l_uint8));",
          "",
          "---------------"
        ],
        "src/utils1.c||src/utils1.c": [
          "File: src/utils1.c -> src/utils1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "776: l_ok",
          "780: {",
          "783:     if (!phash)",
          "784:         return ERROR_INT(\"&hash not defined\", procName, 1);",
          "787:     return 0;",
          "788: }",
          "816: l_ok",
          "820: {",
          "823:     if (!phash)",
          "824:         return ERROR_INT(\"&hash not defined\", procName, 1);",
          "826:     return 0;",
          "827: }",
          "",
          "[Removed Lines]",
          "777: l_hashPtToUint64(l_int32    x,",
          "778:                  l_int32    y,",
          "779:                  l_uint64  *phash)",
          "781:     PROCNAME(\"l_hashPtToUint64\");",
          "817: l_hashFloat64ToUint64(l_int32    nbuckets,",
          "818:                       l_float64  val,",
          "819:                       l_uint64  *phash)",
          "821:     PROCNAME(\"l_hashFloatToUint64\");",
          "",
          "[Added Lines]",
          "770: l_hashStringToUint64Fast(const char  *str,",
          "771:                          l_uint64    *phash)",
          "773: l_uint64  h;",
          "774: l_uint8  *p;",
          "776:     PROCNAME(\"l_hashStringToUint64Fast\");",
          "778:     if (phash) *phash = 0;",
          "779:     if (!str || (str[0] == '\\0'))",
          "780:         return ERROR_INT(\"str not defined or empty\", procName, 1);",
          "784:     h = 0;",
          "785:     for (p = (l_uint8 *)str; *p != '\\0'; p++)",
          "806: l_hashPtToUint64(l_int32    x,",
          "807:                  l_int32    y,",
          "808:                  l_uint64  *phash)",
          "810:     PROCNAME(\"l_hashPtToUint64\");",
          "",
          "---------------"
        ],
        "version-notes.html||version-notes.html": [
          "File: version-notes.html -> version-notes.html",
          "--- Hunk 1 ---",
          "[Context before]",
          "79: <h2 align=center>Version Notes for Leptonica</h2>",
          "82: <hr>",
          "83: <h2 align=center>  <IMG SRC=\"moller52.jpg\" border=1 ALIGN_MIDDLE> </h2>",
          "",
          "[Removed Lines]",
          "80: <h3 align=center>8 Sept 2020</h3>",
          "",
          "[Added Lines]",
          "80: <h3 align=center>1 Apr 2021</h3>",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2011-1585",
  "cve_desc": "The cifs_find_smb_ses function in fs/cifs/connect.c in the Linux kernel before 2.6.36 does not properly determine the associations between users and sessions, which allows local users to bypass CIFS share authentication by leveraging a mount of a share by a different user.",
  "repo": "torvalds/linux",
  "patch_hash": "4ff67b720c02c36e54d55b88c2931879b7db1cd2",
  "patch_info": {
    "commit_hash": "4ff67b720c02c36e54d55b88c2931879b7db1cd2",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2",
    "files": [
      "fs/cifs/cifsglob.h",
      "fs/cifs/connect.c"
    ],
    "message": "cifs: clean up cifs_find_smb_ses (try #2)\n\nThis patch replaces the earlier patch by the same name. The only\ndifference is that MAX_PASSWORD_SIZE has been increased to attempt to\nmatch the limits that windows enforces.\n\nDo a better job of matching sessions by authtype. Matching by username\nfor a Kerberos session is incorrect, and anonymous sessions need special\nhandling.\n\nAlso, in the case where we do match by username, we also need to match\nby password. That ensures that someone else doesn't \"borrow\" an existing\nsession without needing to know the password.\n\nFinally, passwords can be longer than 16 bytes. Bump MAX_PASSWORD_SIZE\nto 512 to match the size that the userspace mount helper allows.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>",
    "before_after_code_files": [
      "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h",
      "fs/cifs/connect.c||fs/cifs/connect.c"
    ]
  },
  "patch_diff": {
    "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h": [
      "File: fs/cifs/cifsglob.h -> fs/cifs/cifsglob.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #define MAX_USERNAME_SIZE 32 /* 32 is to allow for 15 char names + null",
      "42: #define CIFS_MIN_RCV_POOL 4",
      "",
      "[Removed Lines]",
      "40: #define MAX_PASSWORD_SIZE 16",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/cifs/connect.c||fs/cifs/connect.c": [
      "File: fs/cifs/connect.c -> fs/cifs/connect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1644: }",
      "1646: static struct cifsSesInfo *",
      "1648: {",
      "1650:  struct cifsSesInfo *ses;",
      "1652:  write_lock(&cifs_tcp_ses_lock);",
      "1658:   ++ses->ses_count;",
      "1659:   write_unlock(&cifs_tcp_ses_lock);",
      "1660:   return ses;",
      "",
      "[Removed Lines]",
      "1647: cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)",
      "1649:  struct list_head *tmp;",
      "1653:  list_for_each(tmp, &server->smb_ses_list) {",
      "1654:   ses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);",
      "1655:   if (strncmp(ses->userName, username, MAX_USERNAME_SIZE))",
      "1656:    continue;",
      "",
      "[Added Lines]",
      "1647: cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)",
      "1652:  list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {",
      "1653:   switch (server->secType) {",
      "1654:   case Kerberos:",
      "1655:    if (vol->linux_uid != ses->linux_uid)",
      "1656:     continue;",
      "1657:    break;",
      "1658:   default:",
      "1660:    if (strncmp(ses->userName, vol->username,",
      "1661:         MAX_USERNAME_SIZE))",
      "1662:     continue;",
      "1663:    if (strlen(vol->username) != 0 &&",
      "1664:        strncmp(ses->password, vol->password,",
      "1665:         MAX_PASSWORD_SIZE))",
      "1666:     continue;",
      "1667:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1697:  xid = GetXid();",
      "1700:  if (ses) {",
      "1701:   cFYI(1, \"Existing smb sess found (status=%d)\", ses->status);",
      "",
      "[Removed Lines]",
      "1699:  ses = cifs_find_smb_ses(server, volume_info->username);",
      "",
      "[Added Lines]",
      "1709:  ses = cifs_find_smb_ses(server, volume_info);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "69c271f33b949a7b1cbe6f7f39ce3db9e80997a2",
      "candidate_info": {
        "commit_hash": "69c271f33b949a7b1cbe6f7f39ce3db9e80997a2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/69c271f33b949a7b1cbe6f7f39ce3db9e80997a2",
        "files": [
          "drivers/media/IR/lirc_dev.c"
        ],
        "message": "V4L/DVB: IR/lirc_dev: fix locking in lirc_dev_fop_read\n\nOn Wed, Jul 07, 2010 at 02:52:58PM +0200, Jiri Slaby wrote:\n> Hi,\n>\n> stanse found a locking error in lirc_dev_fop_read:\n> if (mutex_lock_interruptible(&ir->irctl_lock))\n>   return -ERESTARTSYS;\n> ...\n> while (written < length && ret == 0) {\n>   if (mutex_lock_interruptible(&ir->irctl_lock)) {    #1\n>     ret = -ERESTARTSYS;\n>     break;\n>   }\n>   ...\n> }\n>\n> remove_wait_queue(&ir->buf->wait_poll, &wait);\n> set_current_state(TASK_RUNNING);\n> mutex_unlock(&ir->irctl_lock);                        #2\n>\n> If lock at #1 fails, it beaks out of the loop, with the lock unlocked,\n> but there is another \"unlock\" at #2.\n\nThis should do the trick. Completely untested beyond compiling, but its\nnot exactly a complicated fix, and in practice, I'm not aware of anyone\never actually tripping that locking bug, so there's zero functional change\nin typical use here.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>",
        "before_after_code_files": [
          "drivers/mediIR/lirc_dev.c||drivers/media/IR/lirc_dev.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mediIR/lirc_dev.c||drivers/media/IR/lirc_dev.c": [
          "File: drivers/mediIR/lirc_dev.c -> drivers/media/IR/lirc_dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "660:     remove_wait_queue(&ir->buf->wait_poll, &wait);",
          "661:     set_current_state(TASK_RUNNING);",
          "662:     goto out_unlocked;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "681: out_unlocked:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0809f6ec18bbce54c996f5c36f4b9d371075c98b",
      "candidate_info": {
        "commit_hash": "0809f6ec18bbce54c996f5c36f4b9d371075c98b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0809f6ec18bbce54c996f5c36f4b9d371075c98b",
        "files": [
          "fs/gfs2/glock.c"
        ],
        "message": "GFS2: Fix recovery stuck bug (try #2)\n\nThis is a clean up of the code which deals with LM_FLAG_NOEXP\nwhich aims to remove any possible race conditions by using\ngl_spin to cover the gap between testing for the LM_FLAG_NOEXP\nand the GL_FROZEN flag.\n\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
        "before_after_code_files": [
          "fs/gfs2/glock.c||fs/gfs2/glock.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/gfs2/glock.c||fs/gfs2/glock.c": [
          "File: fs/gfs2/glock.c -> fs/gfs2/glock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1064:  spin_lock(&gl->gl_spin);",
          "1065:  add_to_queue(gh);",
          "1066:  run_queue(gl, 1);",
          "1067:  spin_unlock(&gl->gl_spin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1066:  if ((LM_FLAG_NOEXP & gh->gh_flags) &&",
          "1067:      test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))",
          "1068:   set_bit(GLF_REPLY_PENDING, &gl->gl_flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1319:   gfs2_glock_put(gl);",
          "1320: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1336: static int gfs2_should_freeze(const struct gfs2_glock *gl)",
          "1337: {",
          "1338:  const struct gfs2_holder *gh;",
          "1340:  if (gl->gl_reply & ~LM_OUT_ST_MASK)",
          "1341:   return 0;",
          "1342:  if (gl->gl_target == LM_ST_UNLOCKED)",
          "1343:   return 0;",
          "1345:  list_for_each_entry(gh, &gl->gl_holders, gh_list) {",
          "1346:   if (test_bit(HIF_HOLDER, &gh->gh_iflags))",
          "1347:    continue;",
          "1348:   if (LM_FLAG_NOEXP & gh->gh_flags)",
          "1349:    return 0;",
          "1350:  }",
          "1352:  return 1;",
          "1353: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1329: void gfs2_glock_complete(struct gfs2_glock *gl, int ret)",
          "1330: {",
          "1331:  struct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;",
          "1332:  gl->gl_reply = ret;",
          "1333:  if (unlikely(test_bit(DFL_BLOCK_LOCKS, &ls->ls_flags))) {",
          "1335:   spin_lock(&gl->gl_spin);",
          "1340:    set_bit(GLF_FROZEN, &gl->gl_flags);",
          "1343:    return;",
          "1344:  }",
          "1345:  set_bit(GLF_REPLY_PENDING, &gl->gl_flags);",
          "1346:  gfs2_glock_hold(gl);",
          "",
          "[Removed Lines]",
          "1334:   struct gfs2_holder *gh;",
          "1336:   gh = find_first_waiter(gl);",
          "1337:   if ((!(gh && (gh->gh_flags & LM_FLAG_NOEXP)) &&",
          "1338:        (gl->gl_target != LM_ST_UNLOCKED)) ||",
          "1339:       ((ret & ~LM_OUT_ST_MASK) != 0))",
          "1341:   spin_unlock(&gl->gl_spin);",
          "1342:   if (test_bit(GLF_FROZEN, &gl->gl_flags))",
          "",
          "[Added Lines]",
          "1370:   if (gfs2_should_freeze(gl)) {",
          "1372:    spin_unlock(&gl->gl_spin);",
          "1374:   }",
          "1375:   spin_unlock(&gl->gl_spin);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "24e6cf92fde1f140d8eb0bf7cd24c2c78149b6b2",
      "candidate_info": {
        "commit_hash": "24e6cf92fde1f140d8eb0bf7cd24c2c78149b6b2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/24e6cf92fde1f140d8eb0bf7cd24c2c78149b6b2",
        "files": [
          "fs/cifs/connect.c"
        ],
        "message": "cifs: check for NULL session password\n\nIt's possible for a cifsSesInfo struct to have a NULL password, so we\nneed to check for that prior to running strncmp on it.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>",
        "before_after_code_files": [
          "fs/cifs/connect.c||fs/cifs/connect.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ],
          "candidate": [
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/cifs/connect.c||fs/cifs/connect.c": [
          "File: fs/cifs/connect.c -> fs/cifs/connect.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1673:         MAX_USERNAME_SIZE))",
          "1674:     continue;",
          "1675:    if (strlen(vol->username) != 0 &&",
          "1676:        strncmp(ses->password,",
          "1677:         vol->password ? vol->password : \"\",",
          "1678:         MAX_PASSWORD_SIZE))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1676:        ses->password != NULL &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "37bb04e5a091a5330faef0cc09930326672b7061",
      "candidate_info": {
        "commit_hash": "37bb04e5a091a5330faef0cc09930326672b7061",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/37bb04e5a091a5330faef0cc09930326672b7061",
        "files": [
          "fs/cifs/connect.c"
        ],
        "message": "CIFS: Simplify connection structure search calls\n\nUse separate functions for comparison between existing structure\nand what we are requesting for to make server, session and tcon\nsearch code easier to use on next superblock match call.\n\nReviewed-by: Jeff Layton <jlayton@samba.org>\nSigned-off-by: Pavel Shilovsky <piastry@etersoft.ru>\nSigned-off-by: Steve French <sfrench@us.ibm.com>",
        "before_after_code_files": [
          "fs/cifs/connect.c||fs/cifs/connect.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ],
          "candidate": [
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/cifs/connect.c||fs/cifs/connect.c": [
          "File: fs/cifs/connect.c -> fs/cifs/connect.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1642:  return true;",
          "1643: }",
          "1645: static struct TCP_Server_Info *",
          "1646: cifs_find_tcp_session(struct sockaddr *addr, struct smb_vol *vol)",
          "1647: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1645: static int match_server(struct TCP_Server_Info *server, struct sockaddr *addr,",
          "1646:     struct smb_vol *vol)",
          "1647: {",
          "1648:  if (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))",
          "1649:   return 0;",
          "1651:  if (!match_address(server, addr,",
          "1652:       (struct sockaddr *)&vol->srcaddr))",
          "1653:   return 0;",
          "1655:  if (!match_port(server, addr))",
          "1656:   return 0;",
          "1658:  if (!match_security(server, vol))",
          "1659:   return 0;",
          "1661:  return 1;",
          "1662: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1650:  spin_lock(&cifs_tcp_ses_lock);",
          "1651:  list_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {",
          "1663:    continue;",
          "1665:   ++server->srv_count;",
          "",
          "[Removed Lines]",
          "1652:   if (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))",
          "1653:    continue;",
          "1655:   if (!match_address(server, addr,",
          "1656:        (struct sockaddr *)&vol->srcaddr))",
          "1657:    continue;",
          "1659:   if (!match_port(server, addr))",
          "1660:    continue;",
          "1662:   if (!match_security(server, vol))",
          "",
          "[Added Lines]",
          "1671:   if (!match_server(server, addr, vol))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1853:  return ERR_PTR(rc);",
          "1854: }",
          "1856: static struct cifsSesInfo *",
          "1857: cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)",
          "1858: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1865: static int match_session(struct cifsSesInfo *ses, struct smb_vol *vol)",
          "1866: {",
          "1867:  switch (ses->server->secType) {",
          "1868:  case Kerberos:",
          "1869:   if (vol->cred_uid != ses->cred_uid)",
          "1870:    return 0;",
          "1871:   break;",
          "1872:  default:",
          "1874:   if (ses->user_name == NULL)",
          "1875:    return 0;",
          "1876:   if (strncmp(ses->user_name, vol->username,",
          "1877:        MAX_USERNAME_SIZE))",
          "1878:    return 0;",
          "1879:   if (strlen(vol->username) != 0 &&",
          "1880:       ses->password != NULL &&",
          "1881:       strncmp(ses->password,",
          "1882:        vol->password ? vol->password : \"\",",
          "1883:        MAX_PASSWORD_SIZE))",
          "1884:    return 0;",
          "1885:  }",
          "1886:  return 1;",
          "1887: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1861:  spin_lock(&cifs_tcp_ses_lock);",
          "1862:  list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {",
          "1882:   ++ses->ses_count;",
          "1883:   spin_unlock(&cifs_tcp_ses_lock);",
          "1884:   return ses;",
          "",
          "[Removed Lines]",
          "1863:   switch (server->secType) {",
          "1864:   case Kerberos:",
          "1865:    if (vol->cred_uid != ses->cred_uid)",
          "1866:     continue;",
          "1867:    break;",
          "1868:   default:",
          "1870:    if (ses->user_name == NULL)",
          "1871:     continue;",
          "1872:    if (strncmp(ses->user_name, vol->username,",
          "1873:         MAX_USERNAME_SIZE))",
          "1874:     continue;",
          "1875:    if (strlen(vol->username) != 0 &&",
          "1876:        ses->password != NULL &&",
          "1877:        strncmp(ses->password,",
          "1878:         vol->password ? vol->password : \"\",",
          "1879:         MAX_PASSWORD_SIZE))",
          "1880:     continue;",
          "1881:   }",
          "",
          "[Added Lines]",
          "1896:   if (!match_session(ses, vol))",
          "1897:    continue;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2021:  return ERR_PTR(rc);",
          "2022: }",
          "2024: static struct cifsTconInfo *",
          "2025: cifs_find_tcon(struct cifsSesInfo *ses, const char *unc)",
          "2026: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2040: static int match_tcon(struct cifsTconInfo *tcon, const char *unc)",
          "2041: {",
          "2042:  if (tcon->tidStatus == CifsExiting)",
          "2043:   return 0;",
          "2044:  if (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))",
          "2045:   return 0;",
          "2046:  return 1;",
          "2047: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2030:  spin_lock(&cifs_tcp_ses_lock);",
          "2031:  list_for_each(tmp, &ses->tcon_list) {",
          "2032:   tcon = list_entry(tmp, struct cifsTconInfo, tcon_list);",
          "2034:    continue;",
          "2038:   ++tcon->tc_count;",
          "2039:   spin_unlock(&cifs_tcp_ses_lock);",
          "2040:   return tcon;",
          "",
          "[Removed Lines]",
          "2033:   if (tcon->tidStatus == CifsExiting)",
          "2035:   if (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))",
          "2036:    continue;",
          "",
          "[Added Lines]",
          "2058:   if (!match_tcon(tcon, unc))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8727c8a85f3951ef0eef36a665f5dceebb4c495d",
      "candidate_info": {
        "commit_hash": "8727c8a85f3951ef0eef36a665f5dceebb4c495d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8727c8a85f3951ef0eef36a665f5dceebb4c495d",
        "files": [
          "fs/cifs/cifs_spnego.c",
          "fs/cifs/cifsencrypt.c",
          "fs/cifs/cifsfs.c",
          "fs/cifs/cifsglob.h",
          "fs/cifs/connect.c",
          "fs/cifs/misc.c",
          "fs/cifs/sess.c"
        ],
        "message": "Allow user names longer than 32 bytes\n\nWe artificially limited the user name to 32 bytes, but modern servers handle\nlarger.  Set the maximum length to a reasonable 256, and make the user name\nstring dynamically allocated rather than a fixed size in session structure.\nAlso clean up old checkpatch warning.\n\nSigned-off-by: Steve French <sfrench@us.ibm.com>",
        "before_after_code_files": [
          "fs/cifs/cifs_spnego.c||fs/cifs/cifs_spnego.c",
          "fs/cifs/cifsencrypt.c||fs/cifs/cifsencrypt.c",
          "fs/cifs/cifsfs.c||fs/cifs/cifsfs.c",
          "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h",
          "fs/cifs/connect.c||fs/cifs/connect.c",
          "fs/cifs/misc.c||fs/cifs/misc.c",
          "fs/cifs/sess.c||fs/cifs/sess.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h",
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ],
          "candidate": [
            "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h",
            "fs/cifs/connect.c||fs/cifs/connect.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/cifs/cifs_spnego.c||fs/cifs/cifs_spnego.c": [
          "File: fs/cifs/cifs_spnego.c -> fs/cifs/cifs_spnego.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:      MAX_MECH_STR_LEN +",
          "114:      UID_KEY_LEN + (sizeof(uid_t) * 2) +",
          "115:      CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +",
          "117:      PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;",
          "119:  spnego_key = ERR_PTR(-ENOMEM);",
          "",
          "[Removed Lines]",
          "116:      USER_KEY_LEN + strlen(sesInfo->userName) +",
          "",
          "[Added Lines]",
          "116:      USER_KEY_LEN + strlen(sesInfo->user_name) +",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:  sprintf(dp, \";creduid=0x%x\", sesInfo->cred_uid);",
          "155:  dp = description + strlen(description);",
          "158:  dp = description + strlen(description);",
          "159:  sprintf(dp, \";pid=0x%x\", current->pid);",
          "",
          "[Removed Lines]",
          "156:  sprintf(dp, \";user=%s\", sesInfo->userName);",
          "",
          "[Added Lines]",
          "156:  sprintf(dp, \";user=%s\", sesInfo->user_name);",
          "",
          "---------------"
        ],
        "fs/cifs/cifsencrypt.c||fs/cifs/cifsencrypt.c": [
          "File: fs/cifs/cifsencrypt.c -> fs/cifs/cifsencrypt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "469:   return rc;",
          "470:  }",
          "474:  user = kmalloc(2 + (len * 2), GFP_KERNEL);",
          "475:  if (user == NULL) {",
          "476:   cERROR(1, \"calc_ntlmv2_hash: user mem alloc failure\\n\");",
          "477:   rc = -ENOMEM;",
          "478:   goto calc_exit_2;",
          "479:  }",
          "481:  UniStrupr(user);",
          "483:  crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,",
          "",
          "[Removed Lines]",
          "473:  len = strlen(ses->userName);",
          "480:  len = cifs_strtoUCS((__le16 *)user, ses->userName, len, nls_cp);",
          "",
          "[Added Lines]",
          "473:  len = strlen(ses->user_name);",
          "480:  len = cifs_strtoUCS((__le16 *)user, ses->user_name, len, nls_cp);",
          "",
          "---------------"
        ],
        "fs/cifs/cifsfs.c||fs/cifs/cifsfs.c": [
          "File: fs/cifs/cifsfs.c -> fs/cifs/cifsfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "413:  if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)",
          "414:   seq_printf(s, \",multiuser\");",
          "418:  if (tcon->ses->domainName)",
          "419:   seq_printf(s, \",domain=%s\", tcon->ses->domainName);",
          "",
          "[Removed Lines]",
          "415:  else if (tcon->ses->userName)",
          "416:   seq_printf(s, \",username=%s\", tcon->ses->userName);",
          "",
          "[Added Lines]",
          "415:  else if (tcon->ses->user_name)",
          "416:   seq_printf(s, \",username=%s\", tcon->ses->user_name);",
          "",
          "---------------"
        ],
        "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h": [
          "File: fs/cifs/cifsglob.h -> fs/cifs/cifsglob.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)",
          "39: #define MAX_SERVER_SIZE 15",
          "45: #define CIFS_MIN_RCV_POOL 4",
          "",
          "[Removed Lines]",
          "41: #define MAX_USERNAME_SIZE 32 /* 32 is to allow for 15 char names + null",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "274:  int capabilities;",
          "275:  char serverName[SERVER_NAME_LEN_WITH_NULL * 2]; /* BB make bigger for",
          "278:  char *domainName;",
          "279:  char *password;",
          "280:  struct session_key auth_key;",
          "",
          "[Removed Lines]",
          "277:  char userName[MAX_USERNAME_SIZE + 1];",
          "",
          "[Added Lines]",
          "276:  char *user_name;",
          "",
          "---------------"
        ],
        "fs/cifs/connect.c||fs/cifs/connect.c": [
          "File: fs/cifs/connect.c -> fs/cifs/connect.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "882:     vol->nullauth = 1;",
          "883:    }",
          "885:     vol->username = value;",
          "886:    } else {",
          "887:     printk(KERN_WARNING \"CIFS: username too long\\n\");",
          "",
          "[Removed Lines]",
          "884:    if (strnlen(value, 200) < 200) {",
          "",
          "[Added Lines]",
          "884:    if (strnlen(value, MAX_USERNAME_SIZE) <",
          "885:       MAX_USERNAME_SIZE) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1808:    break;",
          "1809:   default:",
          "1812:         MAX_USERNAME_SIZE))",
          "1813:     continue;",
          "1814:    if (strlen(vol->username) != 0 &&",
          "",
          "[Removed Lines]",
          "1811:    if (strncmp(ses->userName, vol->username,",
          "",
          "[Added Lines]",
          "1812:    if (ses->user_name == NULL)",
          "1813:     continue;",
          "1814:    if (strncmp(ses->user_name, vol->username,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1906:  else",
          "1907:   sprintf(ses->serverName, \"%pI4\", &addr->sin_addr);",
          "1914:  if (volume_info->password) {",
          "",
          "[Removed Lines]",
          "1909:  if (volume_info->username)",
          "1910:   strncpy(ses->userName, volume_info->username,",
          "1911:    MAX_USERNAME_SIZE);",
          "",
          "[Added Lines]",
          "1912:  if (volume_info->username) {",
          "1913:   ses->user_name = kstrdup(volume_info->username, GFP_KERNEL);",
          "1914:   if (!ses->user_name)",
          "1915:    goto get_ses_fail;",
          "1916:  }",
          "",
          "---------------"
        ],
        "fs/cifs/misc.c||fs/cifs/misc.c": [
          "File: fs/cifs/misc.c -> fs/cifs/misc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:   memset(buf_to_free->password, 0, strlen(buf_to_free->password));",
          "101:   kfree(buf_to_free->password);",
          "102:  }",
          "103:  kfree(buf_to_free->domainName);",
          "104:  kfree(buf_to_free);",
          "105: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103:  kfree(buf_to_free->user_name);",
          "",
          "---------------"
        ],
        "fs/cifs/sess.c||fs/cifs/sess.c": [
          "File: fs/cifs/sess.c -> fs/cifs/sess.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:   bcc_ptr++;",
          "226:  } else {",
          "228:        MAX_USERNAME_SIZE, nls_cp);",
          "229:  }",
          "230:  bcc_ptr += 2 * bytes_ret;",
          "",
          "[Removed Lines]",
          "222:  if (ses->userName == NULL) {",
          "227:   bytes_ret = cifs_strtoUCS((__le16 *) bcc_ptr, ses->userName,",
          "",
          "[Added Lines]",
          "222:  if (ses->user_name == NULL) {",
          "227:   bytes_ret = cifs_strtoUCS((__le16 *) bcc_ptr, ses->user_name,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "247:  if (ses->userName == NULL) {",
          "249:  } else {",
          "250:   strncpy(bcc_ptr, ses->userName, MAX_USERNAME_SIZE);",
          "251:  }",
          "252:  bcc_ptr += strnlen(ses->userName, MAX_USERNAME_SIZE);",
          "",
          "[Added Lines]",
          "247:  if (ses->user_name != NULL)",
          "248:   strncpy(bcc_ptr, ses->user_name, MAX_USERNAME_SIZE);",
          "251:  bcc_ptr += strnlen(ses->user_name, MAX_USERNAME_SIZE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "523:   tmp += len;",
          "524:  }",
          "527:   sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "528:   sec_blob->UserName.Length = 0;",
          "529:   sec_blob->UserName.MaximumLength = 0;",
          "530:   tmp += 2;",
          "531:  } else {",
          "532:   int len;",
          "534:         MAX_USERNAME_SIZE, nls_cp);",
          "536:   sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "",
          "[Removed Lines]",
          "526:  if (ses->userName == NULL) {",
          "533:   len = cifs_strtoUCS((__le16 *)tmp, ses->userName,",
          "",
          "[Added Lines]",
          "525:  if (ses->user_name == NULL) {",
          "532:   len = cifs_strtoUCS((__le16 *)tmp, ses->user_name,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
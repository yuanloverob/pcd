{
  "cve_id": "CVE-2021-29464",
  "cve_desc": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.",
  "repo": "Exiv2/exiv2",
  "patch_hash": "f9308839198aca5e68a65194f151a1de92398f54",
  "patch_info": {
    "commit_hash": "f9308839198aca5e68a65194f151a1de92398f54",
    "repo": "Exiv2/exiv2",
    "commit_url": "https://github.com/Exiv2/exiv2/commit/f9308839198aca5e68a65194f151a1de92398f54",
    "files": [
      "src/jp2image.cpp"
    ],
    "message": "Better bounds checking in Jp2Image::encodeJp2Header()",
    "before_after_code_files": [
      "src/jp2image.cpp||src/jp2image.cpp"
    ]
  },
  "patch_diff": {
    "src/jp2image.cpp||src/jp2image.cpp": [
      "File: src/jp2image.cpp -> src/jp2image.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "646:     void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)",
      "647:     {",
      "648:         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space",
      "651:         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;",
      "654:         char*         p      = (char*) boxBuf.pData_;",
      "655:         bool          bWroteColor = false ;",
      "",
      "[Removed Lines]",
      "649:         int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "650:         int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "652:         int32_t       length = getLong((byte*)&pBox->length, bigEndian);",
      "653:         int32_t       count  = sizeof (Jp2BoxHeader);",
      "",
      "[Added Lines]",
      "649:         long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "650:         long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "652:         uint32_t      length = getLong((byte*)&pBox->length, bigEndian);",
      "653:         uint32_t      count  = sizeof (Jp2BoxHeader);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "667: #ifdef EXIV2_DEBUG_MESSAGES",
      "668:                 std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;",
      "669: #endif",
      "670:                 count        += subBox.length;",
      "671:                 newBox.type   = subBox.type;",
      "672:             } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "670:                 enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "675:                 count = length;",
      "676:             }",
      "679:             if ( newBox.type == kJp2BoxTypeColorHeader ) {",
      "680:                 bWroteColor = true ;",
      "681:                 if ( ! iccProfileDefined() ) {",
      "682:                     const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";",
      "683:                     uint32_t    psize = 15;",
      "684:                     newlen            = sizeof(newBox) + psize ;",
      "685:                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);",
      "686:                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);",
      "687:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));",
      "",
      "[Removed Lines]",
      "678:             int32_t newlen = subBox.length;",
      "",
      "[Added Lines]",
      "679:             uint32_t newlen = subBox.length;",
      "686:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "690:                     const char* pad   = \"\\x02\\x00\\x00\";",
      "691:                     uint32_t    psize = 3;",
      "692:                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;",
      "693:                     ul2Data((byte*)&newBox.length,newlen,bigEndian);",
      "694:                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);",
      "695:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "695:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "697:                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);",
      "698:                 }",
      "699:             } else {",
      "700:                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);",
      "701:             }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "703:                 enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1ad9e52f3ce5c53b344ddfbfe66d2f993150e49e",
      "candidate_info": {
        "commit_hash": "1ad9e52f3ce5c53b344ddfbfe66d2f993150e49e",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/1ad9e52f3ce5c53b344ddfbfe66d2f993150e49e",
        "files": [
          "src/jp2image.cpp"
        ],
        "message": "Fix windows build",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "601: void Jp2Image::encodeJp2Header(const DataBuf& boxBuf, DataBuf& outBuf) {",
          "602:   DataBuf output(boxBuf.size() + iccProfile_.size() + 100);  // allocate sufficient space",
          "603:   size_t outlen = boxHSize;                                  // now many bytes have we written to output?",
          "605:   enforce(boxHSize <= output.size(), ErrorCode::kerCorruptedMetadata);",
          "606:   auto pBox = reinterpret_cast<const Internal::Jp2BoxHeader*>(boxBuf.c_data());",
          "607:   uint32_t length = getLong(reinterpret_cast<const byte*>(&pBox->length), bigEndian);",
          "",
          "[Removed Lines]",
          "604:   long inlen = boxHSize;                                     // how many bytes have we read from boxBuf?",
          "",
          "[Added Lines]",
          "604:   size_t inlen = boxHSize;                                   // how many bytes have we read from boxBuf?",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "651:         const char* pad = \"\\x02\\x00\\x00\";",
          "652:         uint32_t psize = 3;",
          "653:         newlen = sizeof(newBox) + psize + iccProfile_.size();",
          "655:         ul2Data(reinterpret_cast<byte*>(&newBox.length), static_cast<uint32_t>(newlen), bigEndian);",
          "656:         ul2Data(reinterpret_cast<byte*>(&newBox.type), newBox.type, bigEndian);",
          "657:         output.copyBytes(outlen, &newBox, sizeof(newBox));",
          "",
          "[Removed Lines]",
          "654:         enforce(newlen <= static_cast<size_t>(output.size() - outlen), ErrorCode::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "654:         enforce(newlen <= output.size() - outlen, ErrorCode::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "659:         output.copyBytes(outlen + sizeof(newBox) + psize, iccProfile_.c_data(), iccProfile_.size());",
          "660:       }",
          "661:     } else {",
          "663:       output.copyBytes(outlen, boxBuf.c_data(inlen), subBox.length);",
          "664:     }",
          "",
          "[Removed Lines]",
          "662:       enforce(newlen <= static_cast<size_t>(output.size() - outlen), ErrorCode::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "662:       enforce(newlen <= output.size() - outlen, ErrorCode::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "898:   }",
          "899:   bool matched = (memcmp(buf, Jp2Signature.data(), Jp2Signature.size()) == 0);",
          "900:   if (!advance || !matched) {",
          "902:   }",
          "903:   return matched;",
          "904: }",
          "",
          "[Removed Lines]",
          "901:     iIo.seek(-Jp2Signature.size(), BasicIo::cur);  // Return to original position",
          "",
          "[Added Lines]",
          "901:     iIo.seek(-static_cast<long>(Jp2Signature.size()), BasicIo::cur);  // Return to original position",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "aac34630d407dcc6b4a21d1af67b1fd1d9239a22",
      "candidate_info": {
        "commit_hash": "aac34630d407dcc6b4a21d1af67b1fd1d9239a22",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/aac34630d407dcc6b4a21d1af67b1fd1d9239a22",
        "files": [
          "src/jp2image.cpp"
        ],
        "message": "Fix infinite loop caused by subBox with zero size.\n\n(cherry picked from commit 2736126e7b92c5654f56620c097f9a4580c0f73b)",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "670: #ifdef EXIV2_DEBUG_MESSAGES",
          "671:                 std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;",
          "672: #endif",
          "673:                 enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);",
          "674:                 count        += subBox.length;",
          "675:                 newBox.type   = subBox.type;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "673:                 enforce(subBox.length > 0, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ae4df712338948173b33965df654ef378bfbd69a",
      "candidate_info": {
        "commit_hash": "ae4df712338948173b33965df654ef378bfbd69a",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/ae4df712338948173b33965df654ef378bfbd69a",
        "files": [
          "app/actions.cpp",
          "app/exiv2.cpp",
          "include/exiv2/types.hpp",
          "include/exiv2/value.hpp",
          "samples/mmap-test.cpp",
          "src/cr2header_int.cpp",
          "src/crwimage_int.cpp",
          "src/image.cpp",
          "src/image_int.cpp",
          "src/jp2image.cpp",
          "src/jpgimage.cpp",
          "src/makernote_int.cpp",
          "src/pgfimage.cpp",
          "src/pngchunk_int.cpp",
          "src/pngimage.cpp",
          "src/preview.cpp",
          "src/tiffvisitor_int.cpp",
          "src/types.cpp",
          "src/webpimage.cpp"
        ],
        "message": "Remove DataBuf::copyBytes and use std::copy instead",
        "before_after_code_files": [
          "app/actions.cpp||app/actions.cpp",
          "app/exiv2.cpp||app/exiv2.cpp",
          "include/exiv2/types.hpp||include/exiv2/types.hpp",
          "include/exiv2/value.hpp||include/exiv2/value.hpp",
          "samples/mmap-test.cpp||samples/mmap-test.cpp",
          "src/cr2header_int.cpp||src/cr2header_int.cpp",
          "src/crwimage_int.cpp||src/crwimage_int.cpp",
          "src/image.cpp||src/image.cpp",
          "src/image_int.cpp||src/image_int.cpp",
          "src/jp2image.cpp||src/jp2image.cpp",
          "src/jpgimage.cpp||src/jpgimage.cpp",
          "src/makernote_int.cpp||src/makernote_int.cpp",
          "src/pgfimage.cpp||src/pgfimage.cpp",
          "src/pngchunk_int.cpp||src/pngchunk_int.cpp",
          "src/pngimage.cpp||src/pngimage.cpp",
          "src/preview.cpp||src/preview.cpp",
          "src/tiffvisitor_int.cpp||src/tiffvisitor_int.cpp",
          "src/types.cpp||src/types.cpp",
          "src/webpimage.cpp||src/webpimage.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "app/actions.cpp||app/actions.cpp": [
          "File: app/actions.cpp -> app/actions.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:     std::stringstream output(std::stringstream::out | std::stringstream::binary);",
          "172:     result = printStructure(output, option, path);",
          "173:     if (result == 0) {",
          "180:         long chunk = 60;",
          "181:         std::string code = std::string(\"data:\") + ascii.c_str();",
          "182:         size_t length = code.size();",
          "",
          "[Removed Lines]",
          "174:       size_t size = output.str().size();",
          "175:       Exiv2::DataBuf iccProfile(size);",
          "176:       Exiv2::DataBuf ascii(size * 3 + 1);",
          "177:       ascii.write_uint8(size * 3, 0);",
          "178:       iccProfile.copyBytes(0, output.str().c_str(), size);",
          "179:       if (Exiv2::base64encode(iccProfile.c_data(), size, reinterpret_cast<char*>(ascii.data()), size * 3)) {",
          "",
          "[Added Lines]",
          "174:       std::string str = output.str();",
          "175:       Exiv2::DataBuf iccProfile(str.size());",
          "176:       Exiv2::DataBuf ascii(str.size() * 3 + 1);",
          "177:       ascii.write_uint8(str.size() * 3, 0);",
          "178:       std::copy(str.begin(), str.end(), iccProfile.begin());",
          "179:       if (Exiv2::base64encode(iccProfile.c_data(), str.size(), reinterpret_cast<char*>(ascii.data()), str.size() * 3)) {",
          "",
          "---------------"
        ],
        "app/exiv2.cpp||app/exiv2.cpp": [
          "File: app/exiv2.cpp -> app/exiv2.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include \"i18n.h\"  // NLS support.",
          "13: #include \"xmp_exiv2.hpp\"",
          "15: #include <cctype>",
          "16: #include <cstring>",
          "17: #include <fstream>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #include <algorithm>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "941:   std::vector<Exiv2::byte> bytes(buff_size);",
          "942:   int nBytes = 0;",
          "943:   bool more{true};",
          "944:   while (more) {",
          "947:     more = n > 0;",
          "948:     if (more) {",
          "949:       bytes.resize(nBytes + n);",
          "951:       nBytes += n;",
          "952:     }",
          "953:   }",
          "955:   if (nBytes) {",
          "956:     buf.alloc(nBytes);",
          "958:   }",
          "959:   return nBytes;",
          "960: }",
          "",
          "[Removed Lines]",
          "945:     char buff[buff_size];",
          "946:     auto n = static_cast<int>(fread(buff, 1, buff_size, f));",
          "950:       memcpy(bytes.data() + nBytes, buff, n);",
          "957:     buf.copyBytes(0, bytes.data(), nBytes);",
          "",
          "[Added Lines]",
          "945:   std::array<char, buff_size> buff;",
          "947:     auto n = fread(buff.data(), 1, buff_size, f);",
          "951:       std::copy_n(buff.begin(), n, bytes.begin() + nBytes);",
          "958:     std::copy(bytes.begin(), bytes.end(), buf.begin());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1005:   if (!stdinBuf.empty()) {",
          "1006:     buf.alloc(stdinBuf.size());",
          "1008:   }",
          "1009: #ifdef DEBUG",
          "1010:   std::cerr << \"getStdin stdinBuf.size_ = \" << stdinBuf.size() << std::endl;",
          "",
          "[Removed Lines]",
          "1007:     buf.copyBytes(0, stdinBuf.c_data(), buf.size());",
          "",
          "[Added Lines]",
          "1008:     std::copy(stdinBuf.begin(), stdinBuf.end(), buf.begin());",
          "",
          "---------------"
        ],
        "include/exiv2/types.hpp||include/exiv2/types.hpp": [
          "File: include/exiv2/types.hpp -> include/exiv2/types.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "198:   uint64_t read_uint64(size_t offset, ByteOrder byteOrder) const;",
          "199:   void write_uint64(size_t offset, uint64_t x, ByteOrder byteOrder);",
          "205:   int cmpBytes(size_t offset, const void* buf, size_t bufsize) const;",
          "",
          "[Removed Lines]",
          "202:   void copyBytes(size_t offset, const void* buf, size_t bufsize);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/exiv2/value.hpp||include/exiv2/value.hpp": [
          "File: include/exiv2/value.hpp -> include/exiv2/value.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"types.hpp\"",
          "13: #include <cstring>",
          "14: #include <iomanip>",
          "15: #include <map>",
          "",
          "[Removed Lines]",
          "16: #include <cmath>",
          "",
          "[Added Lines]",
          "13: #include <cmath>",
          "",
          "---------------"
        ],
        "samples/mmap-test.cpp||samples/mmap-test.cpp": [
          "File: samples/mmap-test.cpp -> samples/mmap-test.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:     }",
          "30:     const Exiv2::byte* pData = file.mmap();",
          "38:     file.close();",
          "40:     return EXIT_SUCCESS;",
          "",
          "[Removed Lines]",
          "31:     DataBuf buf(file.size());",
          "33:     buf.copyBytes(0, pData, buf.size());",
          "35:     file.write(buf.c_data(), buf.size());",
          "37:     buf.copyBytes(0, pData, buf.size());",
          "",
          "[Added Lines]",
          "31:     std::vector<byte> buf(file.size());",
          "34:     std::copy_n(pData, buf.size(), buf.begin());",
          "37:     file.write(buf.data(), buf.size());",
          "40:     std::copy_n(pData, buf.size(), buf.begin());",
          "",
          "---------------"
        ],
        "src/cr2header_int.cpp||src/cr2header_int.cpp": [
          "File: src/cr2header_int.cpp -> src/cr2header_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:   buf.write_uint16(2, tag(), byteOrder());",
          "46:   buf.write_uint32(4, 0x00000010, byteOrder());",
          "49:   buf.write_uint32(12, 0x00000000, byteOrder());",
          "50:   return buf;",
          "",
          "[Removed Lines]",
          "47:   buf.copyBytes(8, cr2sig_, 4);",
          "",
          "[Added Lines]",
          "47:   std::copy_n(cr2sig_, 4, buf.begin() + 8);",
          "",
          "---------------"
        ],
        "src/crwimage_int.cpp||src/crwimage_int.cpp": [
          "File: src/crwimage_int.cpp -> src/crwimage_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "874:     if (cc && cc->size() > size)",
          "875:       size = cc->size();",
          "876:     DataBuf buf(size);",
          "878:     pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, std::move(buf));",
          "879:   } else {",
          "880:     if (cc) {",
          "",
          "[Removed Lines]",
          "877:     buf.copyBytes(0, comment.data(), comment.size());",
          "",
          "[Added Lines]",
          "877:     std::copy(comment.begin(), comment.end(), buf.begin());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "984:     }",
          "985:     DataBuf buf(size);",
          "986:     if (cc)",
          "988:     if (edX != edEnd && edX->size() == 4) {",
          "989:       edX->copy(buf.data(), pHead->byteOrder());",
          "990:     }",
          "",
          "[Removed Lines]",
          "987:       buf.copyBytes(8, cc->pData() + 8, cc->size() - 8);",
          "",
          "[Added Lines]",
          "987:       std::copy_n(cc->pData() + 8, cc->size() - 8, buf.begin() + 8);",
          "",
          "---------------"
        ],
        "src/image.cpp||src/image.cpp": [
          "File: src/image.cpp -> src/image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "361:       }",
          "363:       enforce(allocate64 <= std::numeric_limits<size_t>::max(), ErrorCode::kerCorruptedMetadata);",
          "368:       const size_t count_x_size = count * size;",
          "",
          "[Removed Lines]",
          "364:       DataBuf buf(allocate64);             // allocate a buffer",
          "365:       buf.copyBytes(0, dir.c_data(8), 4);  // copy dir[8:11] into buffer (short strings)",
          "",
          "[Added Lines]",
          "364:       DataBuf buf(allocate64);                     // allocate a buffer",
          "365:       std::copy_n(dir.c_data(8), 4, buf.begin());  // copy dir[8:11] into buffer (short strings)",
          "",
          "---------------"
        ],
        "src/image_int.cpp||src/image_int.cpp": [
          "File: src/image_int.cpp -> src/image_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:     va_list args;            // variable arg list",
          "26:     va_start(args, format);  // args start after format",
          "27:     rc = vsnprintf(&buffer[0], buffer.size(), format, args);",
          "29:     if (rc > 0)",
          "30:       need = static_cast<size_t>(rc);",
          "31:   } while (buffer.size() <= need);",
          "",
          "[Removed Lines]",
          "28:     va_end(args);     // free the args",
          "",
          "[Added Lines]",
          "28:     va_end(args);  // free the args",
          "",
          "---------------"
        ],
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"tiffimage.hpp\"",
          "17: #include \"types.hpp\"",
          "19: #include <array>",
          "20: #include <iostream>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <algorithm>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:               throw Error(ErrorCode::kerCorruptedMetadata);",
          "225:             }",
          "226:             DataBuf icc(iccLength);",
          "228: #ifdef EXIV2_DEBUG_MESSAGES",
          "229:             const char* iccPath = \"/tmp/libexiv2_jp2.icc\";",
          "230:             FILE* f = fopen(iccPath, \"wb\");",
          "",
          "[Removed Lines]",
          "227:             icc.copyBytes(0, data.c_data(pad), icc.size());",
          "",
          "[Added Lines]",
          "228:             std::copy_n(data.c_data(pad), icc.size(), icc.begin());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "645:         enforce(newlen <= output.size() - outlen, ErrorCode::kerCorruptedMetadata);",
          "646:         ul2Data(reinterpret_cast<byte*>(&newBox.length), psize, bigEndian);",
          "647:         ul2Data(reinterpret_cast<byte*>(&newBox.type), newBox.type, bigEndian);",
          "650:       } else {",
          "651:         const char* pad = \"\\x02\\x00\\x00\";",
          "652:         uint32_t psize = 3;",
          "",
          "[Removed Lines]",
          "648:         output.copyBytes(outlen, &newBox, sizeof(newBox));",
          "649:         output.copyBytes(outlen + sizeof(newBox), pad, psize);",
          "",
          "[Added Lines]",
          "649:         std::copy_n(reinterpret_cast<char*>(&newBox), sizeof(newBox), output.begin() + outlen);",
          "650:         std::copy_n(pad, psize, output.begin() + outlen + sizeof(newBox));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "654:         enforce(newlen <= output.size() - outlen, ErrorCode::kerCorruptedMetadata);",
          "655:         ul2Data(reinterpret_cast<byte*>(&newBox.length), static_cast<uint32_t>(newlen), bigEndian);",
          "656:         ul2Data(reinterpret_cast<byte*>(&newBox.type), newBox.type, bigEndian);",
          "660:       }",
          "661:     } else {",
          "662:       enforce(newlen <= output.size() - outlen, ErrorCode::kerCorruptedMetadata);",
          "664:     }",
          "666:     outlen += newlen;",
          "",
          "[Removed Lines]",
          "657:         output.copyBytes(outlen, &newBox, sizeof(newBox));",
          "658:         output.copyBytes(outlen + sizeof(newBox), pad, psize);",
          "659:         output.copyBytes(outlen + sizeof(newBox) + psize, iccProfile_.c_data(), iccProfile_.size());",
          "663:       output.copyBytes(outlen, boxBuf.c_data(inlen), subBox.length);",
          "",
          "[Added Lines]",
          "658:         std::copy_n(reinterpret_cast<char*>(&newBox), sizeof(newBox), output.begin() + outlen);",
          "659:         std::copy_n(pad, psize, output.begin() + outlen + sizeof(newBox));",
          "660:         std::copy(iccProfile_.begin(), iccProfile_.end(), output.begin() + outlen + sizeof(newBox) + psize);",
          "664:       std::copy_n(boxBuf.c_data(inlen), subBox.length, output.begin() + outlen);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "671:   outBuf.alloc(outlen);",
          "673:   auto oBox = reinterpret_cast<Internal::Jp2BoxHeader*>(outBuf.data());",
          "674:   ul2Data(reinterpret_cast<byte*>(&oBox->type), kJp2BoxTypeHeader, bigEndian);",
          "675:   ul2Data(reinterpret_cast<byte*>(&oBox->length), static_cast<uint32_t>(outlen), bigEndian);",
          "",
          "[Removed Lines]",
          "672:   outBuf.copyBytes(0, output.c_data(), outlen);",
          "",
          "[Added Lines]",
          "673:   std::copy_n(output.c_data(), outlen, outBuf.begin());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "743:     enforce(box.length - 8 <= static_cast<size_t>(io_->size() - io_->tell()), ErrorCode::kerCorruptedMetadata);",
          "748:     io_->readOrThrow(boxBuf.data(8), box.length - 8, ErrorCode::kerInputDataReadFailed);  // Extract box data.",
          "750:     switch (box.type) {",
          "",
          "[Removed Lines]",
          "746:     DataBuf boxBuf(box.length);                   // Box header (8 bytes) + box data.",
          "747:     boxBuf.copyBytes(0, bheaderBuf.c_data(), 8);  // Copy header.",
          "",
          "[Added Lines]",
          "747:     DataBuf boxBuf(box.length);                          // Box header (8 bytes) + box data.",
          "748:     std::copy_n(bheaderBuf.begin(), 8, boxBuf.begin());  // Copy header.",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "767:           ExifParser::encode(blob, littleEndian, exifData_);",
          "768:           if (!blob.empty()) {",
          "769:             DataBuf rawExif(blob.size());",
          "772:             DataBuf boxData(8 + 16 + rawExif.size());",
          "773:             ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), bigEndian);",
          "774:             ul2Data(boxUUIDtype, kJp2BoxTypeUuid, bigEndian);",
          "780: #ifdef EXIV2_DEBUG_MESSAGES",
          "781:             std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Exif metadata (length: \" << boxData.size()",
          "",
          "[Removed Lines]",
          "770:             rawExif.copyBytes(0, &blob[0], blob.size());",
          "775:             boxData.copyBytes(0, boxDataSize, 4);",
          "776:             boxData.copyBytes(4, boxUUIDtype, 4);",
          "777:             boxData.copyBytes(8, kJp2UuidExif, 16);",
          "778:             boxData.copyBytes(8 + 16, rawExif.c_data(), rawExif.size());",
          "",
          "[Added Lines]",
          "771:             std::copy(blob.begin(), blob.end(), rawExif.begin());",
          "776:             std::copy_n(boxDataSize, 4, boxData.begin());",
          "777:             std::copy_n(boxUUIDtype, 4, boxData.begin() + 4);",
          "778:             std::copy_n(kJp2UuidExif, 16, boxData.begin() + 8);",
          "779:             std::copy(rawExif.begin(), rawExif.end(), boxData.begin() + 8 + 16);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "794:             DataBuf boxData(8 + 16 + rawIptc.size());",
          "795:             ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), bigEndian);",
          "796:             ul2Data(boxUUIDtype, kJp2BoxTypeUuid, bigEndian);",
          "802: #ifdef EXIV2_DEBUG_MESSAGES",
          "803:             std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Iptc metadata (length: \" << boxData.size()",
          "",
          "[Removed Lines]",
          "797:             boxData.copyBytes(0, boxDataSize, 4);",
          "798:             boxData.copyBytes(4, boxUUIDtype, 4);",
          "799:             boxData.copyBytes(8, kJp2UuidIptc, 16);",
          "800:             boxData.copyBytes(8 + 16, rawIptc.c_data(), rawIptc.size());",
          "",
          "[Added Lines]",
          "798:             std::copy_n(boxDataSize, 4, boxData.begin());",
          "799:             std::copy_n(boxUUIDtype, 4, boxData.begin() + 4);",
          "800:             std::copy_n(kJp2UuidExif, 16, boxData.begin() + 8);",
          "801:             std::copy(rawIptc.begin(), rawIptc.end(), boxData.begin() + 8 + 16);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "822:           DataBuf boxData(8 + 16 + xmp.size());",
          "823:           ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), bigEndian);",
          "824:           ul2Data(boxUUIDtype, kJp2BoxTypeUuid, bigEndian);",
          "830: #ifdef EXIV2_DEBUG_MESSAGES",
          "831:           std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with XMP metadata (length: \" << boxData.size()",
          "",
          "[Removed Lines]",
          "825:           boxData.copyBytes(0, boxDataSize, 4);",
          "826:           boxData.copyBytes(4, boxUUIDtype, 4);",
          "827:           boxData.copyBytes(8, kJp2UuidXmp, 16);",
          "828:           boxData.copyBytes(8 + 16, xmp.c_data(), xmp.size());",
          "",
          "[Added Lines]",
          "826:           std::copy_n(boxDataSize, 4, boxData.begin());",
          "827:           std::copy_n(boxUUIDtype, 4, boxData.begin() + 4);",
          "828:           std::copy_n(kJp2UuidExif, 16, boxData.begin() + 8);",
          "829:           std::copy(xmp.begin(), xmp.end(), boxData.begin() + 8 + 16);",
          "",
          "---------------"
        ],
        "src/jpgimage.cpp||src/jpgimage.cpp": [
          "File: src/jpgimage.cpp -> src/jpgimage.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "273:   while (marker != sos_ && marker != eoi_ && search > 0) {",
          "276:     uint16_t size = 0;  // Size of the segment, including the 2-byte size field",
          "277:     if (markerHasLength(marker)) {",
          "280:       enforce(size >= 2, ErrorCode::kerFailedToReadImageData);",
          "281:     }",
          "",
          "[Removed Lines]",
          "275:     byte sizebuf[2];",
          "278:       io_->readOrThrow(sizebuf, 2, ErrorCode::kerFailedToReadImageData);",
          "279:       size = getUShort(sizebuf, bigEndian);",
          "",
          "[Added Lines]",
          "275:     std::array<byte, 2> sizebuf;",
          "278:       io_->readOrThrow(sizebuf.data(), sizebuf.size(), ErrorCode::kerFailedToReadImageData);",
          "279:       size = getUShort(sizebuf.data(), bigEndian);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "286:     if (size > 0) {",
          "287:       io_->readOrThrow(buf.data(2), size - 2, ErrorCode::kerFailedToReadImageData);",
          "289:     }",
          "291:     if (!foundExifData && marker == app1_ && size >= 8  // prevent out-of-bounds read in memcmp on next line",
          "",
          "[Removed Lines]",
          "288:       buf.copyBytes(0, sizebuf, 2);",
          "",
          "[Added Lines]",
          "288:       std::copy(sizebuf.begin(), sizebuf.end(), buf.begin());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "364:       DataBuf profile(Safe::add(iccProfile_.size(), icc_size));",
          "365:       if (!iccProfile_.empty()) {",
          "367:       }",
          "369:       setIccProfile(std::move(profile), chunk == chunks);",
          "370:     } else if (pixelHeight_ == 0 && inRange2(marker, sof0_, sof3_, sof5_, sof15_)) {",
          "",
          "[Removed Lines]",
          "366:         profile.copyBytes(0, iccProfile_.c_data(), iccProfile_.size());",
          "368:       profile.copyBytes(iccProfile_.size(), buf.c_data(2 + 14), icc_size);",
          "",
          "[Added Lines]",
          "366:         std::copy(iccProfile_.begin(), iccProfile_.end(), profile.begin());",
          "368:       std::copy_n(buf.c_data(2 + 14), icc_size, profile.data() + iccProfile_.size());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "479:       bool bLF = bPrint;",
          "483:       uint16_t size = 0;",
          "484:       if (markerHasLength(marker)) {",
          "489:         enforce(size >= 2, ErrorCode::kerFailedToReadImageData);",
          "",
          "[Removed Lines]",
          "482:       byte sizebuf[2];",
          "485:         io_->readOrThrow(sizebuf, 2, ErrorCode::kerFailedToReadImageData);",
          "486:         size = getUShort(sizebuf, bigEndian);",
          "",
          "[Added Lines]",
          "482:       std::array<byte, 2> sizebuf;",
          "485:         io_->readOrThrow(sizebuf.data(), sizebuf.size(), ErrorCode::kerFailedToReadImageData);",
          "486:         size = getUShort(sizebuf.data(), bigEndian);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "493:       DataBuf buf(size);",
          "494:       if (size > 0) {",
          "495:         io_->readOrThrow(buf.data(2), size - 2, ErrorCode::kerFailedToReadImageData);",
          "497:       }",
          "499:       if (bPrint && markerHasLength(marker))",
          "",
          "[Removed Lines]",
          "496:         buf.copyBytes(0, sizebuf, 2);",
          "",
          "[Added Lines]",
          "496:         std::copy(sizebuf.begin(), sizebuf.end(), buf.begin());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "733: DataBuf JpegBase::readNextSegment(byte marker) {",
          "736:   uint16_t size = 0;",
          "737:   if (markerHasLength(marker)) {",
          "742:     enforce(size >= 2, ErrorCode::kerFailedToReadImageData);",
          "",
          "[Removed Lines]",
          "735:   byte sizebuf[2];",
          "738:     io_->readOrThrow(sizebuf, 2, ErrorCode::kerFailedToReadImageData);",
          "739:     size = getUShort(sizebuf, bigEndian);",
          "",
          "[Added Lines]",
          "735:   std::array<byte, 2> sizebuf;",
          "738:     io_->readOrThrow(sizebuf.data(), sizebuf.size(), ErrorCode::kerFailedToReadImageData);",
          "739:     size = getUShort(sizebuf.data(), bigEndian);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "746:   DataBuf buf(size);",
          "747:   if (size > 0) {",
          "748:     io_->readOrThrow(buf.data(2), size - 2, ErrorCode::kerFailedToReadImageData);",
          "750:   }",
          "751:   return buf;",
          "752: }",
          "",
          "[Removed Lines]",
          "749:     buf.copyBytes(0, sizebuf, 2);",
          "",
          "[Added Lines]",
          "749:     std::copy(sizebuf.begin(), sizebuf.end(), buf.begin());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "805:       ++search;",
          "806:       if (buf.size() > 8) {",
          "807:         rawExif.alloc(buf.size() - 8);",
          "809:       }",
          "810:     } else if (skipApp1Xmp == notfound && marker == app1_ &&",
          "811:                buf.size() >= 31 &&  // prevent out-of-bounds read in memcmp on next line",
          "",
          "[Removed Lines]",
          "808:         rawExif.copyBytes(0, buf.c_data(8), buf.size() - 8);",
          "",
          "[Added Lines]",
          "808:         std::copy_n(buf.c_data(8), rawExif.size(), rawExif.begin());",
          "",
          "---------------"
        ],
        "src/makernote_int.cpp||src/makernote_int.cpp": [
          "File: src/makernote_int.cpp -> src/makernote_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:   if (!pData || size < sizeOfSignature())",
          "189:     return false;",
          "190:   header_.alloc(sizeOfSignature());",
          "192:   return !(header_.size() < sizeOfSignature() || 0 != header_.cmpBytes(0, signature_, 6));",
          "193: }",
          "",
          "[Removed Lines]",
          "191:   header_.copyBytes(0, pData, header_.size());",
          "",
          "[Added Lines]",
          "191:   std::copy_n(pData, header_.size(), header_.data());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:   if (!pData || size < sizeOfSignature())",
          "224:     return false;",
          "225:   header_.alloc(sizeOfSignature());",
          "227:   return !(header_.size() < sizeOfSignature() || 0 != header_.cmpBytes(0, signature_, 10));",
          "228: }",
          "",
          "[Removed Lines]",
          "226:   header_.copyBytes(0, pData, header_.size());",
          "",
          "[Added Lines]",
          "226:   std::copy_n(pData, header_.size(), header_.data());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "263:   if (!pData || size < sizeOfSignature())",
          "264:     return false;",
          "265:   header_.alloc(sizeOfSignature());",
          "269:   start_ = header_.read_uint32(8, byteOrder_);",
          "",
          "[Removed Lines]",
          "266:   header_.copyBytes(0, pData, header_.size());",
          "",
          "[Added Lines]",
          "266:   std::copy_n(pData, header_.size(), header_.data());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "299:   if (0 != memcmp(pData, signature_, 6))",
          "300:     return false;",
          "301:   buf_.alloc(sizeOfSignature());",
          "303:   start_ = sizeOfSignature();",
          "304:   return true;",
          "305: }  // Nikon2MnHeader::read",
          "",
          "[Removed Lines]",
          "302:   buf_.copyBytes(0, pData, buf_.size());",
          "",
          "[Added Lines]",
          "302:   std::copy_n(pData, buf_.size(), buf_.data());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "319: Nikon3MnHeader::Nikon3MnHeader() : byteOrder_(invalidByteOrder), start_(sizeOfSignature()) {",
          "320:   buf_.alloc(sizeOfSignature());",
          "322: }",
          "324: size_t Nikon3MnHeader::size() const {",
          "",
          "[Removed Lines]",
          "321:   buf_.copyBytes(0, signature_, buf_.size());",
          "",
          "[Added Lines]",
          "321:   std::copy_n(signature_, buf_.size(), buf_.data());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "343:   if (0 != memcmp(pData, signature_, 6))",
          "344:     return false;",
          "345:   buf_.alloc(sizeOfSignature());",
          "347:   TiffHeader th;",
          "348:   if (!th.read(buf_.data(10), 8))",
          "349:     return false;",
          "",
          "[Removed Lines]",
          "346:   buf_.copyBytes(0, pData, buf_.size());",
          "",
          "[Added Lines]",
          "346:   std::copy_n(pData, buf_.size(), buf_.data());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "389:   if (0 != memcmp(pData, signature_, 9))",
          "390:     return false;",
          "391:   buf_.alloc(sizeOfSignature());",
          "393:   start_ = sizeOfSignature();",
          "394:   return true;",
          "395: }  // PanasonicMnHeader::read",
          "",
          "[Removed Lines]",
          "392:   buf_.copyBytes(0, pData, buf_.size());",
          "",
          "[Added Lines]",
          "392:   std::copy_n(pData, buf_.size(), buf_.data());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "425:   if (!pData || size < sizeOfSignature())",
          "426:     return false;",
          "427:   header_.alloc(sizeOfSignature());",
          "429:   return !(header_.size() < sizeOfSignature() || 0 != header_.cmpBytes(0, signature_, 7));",
          "430: }",
          "",
          "[Removed Lines]",
          "428:   header_.copyBytes(0, pData, header_.size());",
          "",
          "[Added Lines]",
          "428:   std::copy_n(pData, header_.size(), header_.data());",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "456:   if (!pData || size < sizeOfSignature())",
          "457:     return false;",
          "458:   header_.alloc(sizeOfSignature());",
          "460:   return !(header_.size() < sizeOfSignature() || 0 != header_.cmpBytes(0, signature_, 3));",
          "461: }",
          "",
          "[Removed Lines]",
          "459:   header_.copyBytes(0, pData, header_.size());",
          "",
          "[Added Lines]",
          "459:   std::copy_n(pData, header_.size(), header_.data());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "510:   if (0 != memcmp(pData, signature1_, 8) && 0 != memcmp(pData, signature2_, 8))",
          "511:     return false;",
          "512:   buf_.alloc(sizeOfSignature());",
          "514:   start_ = sizeOfSignature();",
          "515:   return true;",
          "516: }  // SigmaMnHeader::read",
          "",
          "[Removed Lines]",
          "513:   buf_.copyBytes(0, pData, buf_.size());",
          "",
          "[Added Lines]",
          "513:   std::copy_n(pData, buf_.size(), buf_.data());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "544:   if (0 != memcmp(pData, signature_, sizeOfSignature()))",
          "545:     return false;",
          "546:   buf_.alloc(sizeOfSignature());",
          "548:   start_ = sizeOfSignature();",
          "549:   return true;",
          "550: }  // SonyMnHeader::read",
          "",
          "[Removed Lines]",
          "547:   buf_.copyBytes(0, pData, buf_.size());",
          "",
          "[Added Lines]",
          "547:   std::copy_n(pData, buf_.size(), buf_.data());",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "583:   if (0 != memcmp(pData, signature_, sizeOfSignature()))",
          "584:     return false;",
          "585:   buf_.alloc(sizeOfSignature());",
          "587:   start_ = sizeOfSignature();",
          "588:   return true;",
          "589: }  // Casio2MnHeader::read",
          "",
          "[Removed Lines]",
          "586:   buf_.copyBytes(0, pData, buf_.size());",
          "",
          "[Added Lines]",
          "586:   std::copy_n(pData, buf_.size(), buf_.data());",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "891:     }",
          "892:   }",
          "893:   buf.alloc(size);",
          "895:   ncrypt(buf.data(nci->start_), static_cast<uint32_t>(buf.size()) - nci->start_, count, serial);",
          "896:   return buf;",
          "897: }",
          "",
          "[Removed Lines]",
          "894:   buf.copyBytes(0, pData, buf.size());",
          "",
          "[Added Lines]",
          "894:   std::copy_n(pData, buf.size(), buf.data());",
          "",
          "---------------"
        ],
        "src/pgfimage.cpp||src/pgfimage.cpp": [
          "File: src/pgfimage.cpp -> src/pgfimage.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "181:   uint32_t newHeaderSize = static_cast<uint32_t>(header.size() + imgSize);",
          "182:   DataBuf buffer(4);",
          "184:   byteSwap_(buffer, 0, bSwap_);",
          "185:   if (outIo.write(buffer.c_data(), 4) != 4)",
          "186:     throw Error(ErrorCode::kerImageWriteFailed);",
          "",
          "[Removed Lines]",
          "183:   buffer.copyBytes(0, &newHeaderSize, 4);",
          "",
          "[Added Lines]",
          "183:   std::copy_n(&newHeaderSize, 4, buffer.data());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "259:     throw Error(ErrorCode::kerInputDataReadFailed);",
          "261:   DataBuf work(8);  // don't disturb the binary data - doWriteMetadata reuses it",
          "263:   width = byteSwap_(work, 0, bSwap_);",
          "264:   height = byteSwap_(work, 4, bSwap_);",
          "",
          "[Removed Lines]",
          "262:   work.copyBytes(0, header.c_data(), 8);",
          "",
          "[Added Lines]",
          "262:   std::copy_n(header.c_data(), 8, work.begin());",
          "",
          "---------------"
        ],
        "src/pngchunk_int.cpp||src/pngchunk_int.cpp": [
          "File: src/pngchunk_int.cpp -> src/pngchunk_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "491:   if (iTXt) {",
          "492:     info.alloc(text.size());",
          "494:     return info;",
          "495:   }",
          "",
          "[Removed Lines]",
          "493:     info.copyBytes(0, text.c_data(), text.size());",
          "",
          "[Added Lines]",
          "493:     std::copy(text.cbegin(), text.cend(), info.begin());",
          "",
          "---------------"
        ],
        "src/pngimage.cpp||src/pngimage.cpp": [
          "File: src/pngimage.cpp -> src/pngimage.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "340:           }",
          "342:           if (bSoft && !dataBuf.empty()) {",
          "347:             out << Internal::indent(depth) << buff.c_str() << \": \" << str;",
          "348:             bLF = true;",
          "349:           }",
          "",
          "[Removed Lines]",
          "343:             DataBuf s(dataBuf.size() + 1);                     // allocate buffer with an extra byte",
          "344:             s.copyBytes(0, dataBuf.c_data(), dataBuf.size());  // copy in the dataBuf",
          "345:             s.write_uint8(dataBuf.size(), 0);                  // nul terminate it",
          "346:             const auto str = s.c_str();                        // give it name",
          "",
          "[Added Lines]",
          "343:             DataBuf s(dataBuf.size() + 1);                         // allocate buffer with an extra byte",
          "344:             std::copy(dataBuf.begin(), dataBuf.end(), s.begin());  // copy in the dataBuf",
          "345:             s.write_uint8(dataBuf.size(), 0);                      // nul terminate it",
          "346:             const auto str = s.c_str();                            // give it name",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "528:     DataBuf chunkBuf(8 + dataOffset + 4);                   // Chunk header (8 bytes) + Chunk data + CRC (4 bytes).",
          "530:     bufRead = io_->read(chunkBuf.data(8), dataOffset + 4);  // Extract chunk data + CRC",
          "531:     if (io_->error())",
          "532:       throw Error(ErrorCode::kerFailedToReadImageData);",
          "",
          "[Removed Lines]",
          "529:     chunkBuf.copyBytes(0, cheaderBuf.c_data(), 8);          // Copy header.",
          "",
          "[Added Lines]",
          "529:     std::copy_n(cheaderBuf.begin(), 8, chunkBuf.begin());   // Copy header.",
          "",
          "---------------"
        ],
        "src/preview.cpp||src/preview.cpp": [
          "File: src/preview.cpp -> src/preview.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include \"tiffimage.hpp\"",
          "13: #include \"tiffimage_int.hpp\"",
          "15: #include <climits>",
          "17: namespace {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #include <algorithm>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "740:           enforce(Safe::add(idxBuf, size) <= size_, ErrorCode::kerCorruptedMetadata);",
          "741:           if (size != 0 && Safe::add(offset, size) <= static_cast<uint32_t>(io.size())) {",
          "743:           }",
          "745:           idxBuf += size;",
          "",
          "[Removed Lines]",
          "742:             buf.copyBytes(idxBuf, base + offset, size);",
          "",
          "[Added Lines]",
          "743:             std::copy_n(base + offset, size, buf.begin() + idxBuf);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "953:   const std::string header = \"P6\\n\" + toString(width) + \" \" + toString(height) + \"\\n255\\n\";",
          "954:   const auto headerBytes = reinterpret_cast<const byte *>(header.data());",
          "959:   return dest;",
          "960: }",
          "",
          "[Removed Lines]",
          "956:   DataBuf dest(static_cast<long>(header.size() + rgb.size()));",
          "957:   dest.copyBytes(0, headerBytes, header.size());",
          "958:   dest.copyBytes(header.size(), rgb.c_data(), rgb.size());",
          "",
          "[Added Lines]",
          "957:   DataBuf dest(header.size() + rgb.size());",
          "958:   std::copy_n(headerBytes, header.size(), dest.begin());",
          "959:   std::copy_n(rgb.c_data(), rgb.size(), dest.begin() + header.size());",
          "",
          "---------------"
        ],
        "src/tiffvisitor_int.cpp||src/tiffvisitor_int.cpp": [
          "File: src/tiffvisitor_int.cpp -> src/tiffvisitor_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "512:     if (rawIptc.size() % 4 != 0) {",
          "514:       buf.alloc((rawIptc.size() / 4) * 4 + 4);",
          "516:     } else {",
          "517:       buf = std::move(rawIptc);  // Note: This resets rawIptc",
          "518:     }",
          "",
          "[Removed Lines]",
          "515:       buf.copyBytes(0, rawIptc.c_data(), rawIptc.size());",
          "",
          "[Added Lines]",
          "515:       std::copy(rawIptc.begin(), rawIptc.end(), buf.begin());",
          "",
          "---------------"
        ],
        "src/types.cpp||src/types.cpp": [
          "File: src/types.cpp -> src/types.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "164:   ull2Data(&pData_[offset], x, byteOrder);",
          "165: }",
          "176: int Exiv2::DataBuf::cmpBytes(size_t offset, const void* buf, size_t bufsize) const {",
          "177:   if (pData_.size() < bufsize || offset > pData_.size() - bufsize) {",
          "178:     throw std::overflow_error(\"Overflow in Exiv2::DataBuf::cmpBytes\");",
          "",
          "[Removed Lines]",
          "167: void Exiv2::DataBuf::copyBytes(size_t offset, const void* buf, size_t bufsize) {",
          "168:   if (pData_.size() < bufsize || offset > pData_.size() - bufsize) {",
          "169:     throw std::overflow_error(\"Overflow in Exiv2::DataBuf::copyBytes\");",
          "170:   }",
          "171:   if (bufsize > 0) {",
          "172:     memcpy(&pData_[offset], buf, bufsize);",
          "173:   }",
          "174: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/webpimage.cpp||src/webpimage.cpp": [
          "File: src/webpimage.cpp -> src/webpimage.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "681:       if (s_header) {",
          "682:         us2Data(size_buff2, static_cast<uint16_t>(sizePayload - 6), bigEndian);",
          "685:       }",
          "687:       if (be_header || le_header) {",
          "688:         us2Data(size_buff2, static_cast<uint16_t>(sizePayload - 6), bigEndian);",
          "692:       }",
          "696: #ifdef EXIV2_DEBUG_MESSAGES",
          "697:       std::cout << \"Display Hex Dump [size:\" << static_cast<unsigned long>(sizePayload) << \"]\" << std::endl;",
          "",
          "[Removed Lines]",
          "683:         rawExifData.copyBytes(0, reinterpret_cast<char*>(&exifLongHeader), 4);",
          "684:         rawExifData.copyBytes(4, reinterpret_cast<char*>(&size_buff2), 2);",
          "689:         rawExifData.copyBytes(0, reinterpret_cast<char*>(&exifLongHeader), 4);",
          "690:         rawExifData.copyBytes(4, reinterpret_cast<char*>(&size_buff2), 2);",
          "691:         rawExifData.copyBytes(6, reinterpret_cast<char*>(&exifShortHeader), 6);",
          "694:       rawExifData.copyBytes(offset, payload.c_data(), payload.size());",
          "",
          "[Added Lines]",
          "683:         std::copy_n(reinterpret_cast<char*>(&exifLongHeader), 4, rawExifData.begin());",
          "684:         std::copy_n(reinterpret_cast<char*>(&size_buff2), 2, rawExifData.begin() + 4);",
          "689:         std::copy_n(reinterpret_cast<char*>(&exifLongHeader), 4, rawExifData.begin());",
          "690:         std::copy_n(reinterpret_cast<char*>(&size_buff2), 2, rawExifData.begin() + 4);",
          "691:         std::copy_n(reinterpret_cast<char*>(&exifShortHeader), 6, rawExifData.begin() + 6);",
          "694:       std::copy(payload.begin(), payload.end(), rawExifData.begin() + offset);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b3de96f4b4408347bed57e625963720e8d0dd2ea",
      "candidate_info": {
        "commit_hash": "b3de96f4b4408347bed57e625963720e8d0dd2ea",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/b3de96f4b4408347bed57e625963720e8d0dd2ea",
        "files": [
          "src/jp2image.cpp"
        ],
        "message": "Add more bounds checks in Jp2Image::encodeJp2Header",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "648:         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space",
          "649:         long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
          "650:         long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
          "651:         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;",
          "652:         uint32_t      length = getLong((byte*)&pBox->length, bigEndian);",
          "653:         uint32_t      count  = sizeof (Jp2BoxHeader);",
          "654:         char*         p      = (char*) boxBuf.pData_;",
          "655:         bool          bWroteColor = false ;",
          "657:         while ( count < length || !bWroteColor ) {",
          "658:             Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "651:         enforce(sizeof(Jp2BoxHeader) <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);",
          "654:         enforce(length <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);",
          "660:             enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1545a1bc4aa4323ad15607d007918f3483c71dea",
      "candidate_info": {
        "commit_hash": "1545a1bc4aa4323ad15607d007918f3483c71dea",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/1545a1bc4aa4323ad15607d007918f3483c71dea",
        "files": [
          "src/CMakeLists.txt",
          "src/jp2image.cpp",
          "src/jp2image_int.cpp",
          "src/jp2image_int.hpp",
          "unitTests/CMakeLists.txt",
          "unitTests/test_jp2image_int.cpp"
        ],
        "message": "JP2 - stronger checks on Signatuer and FileType boxes",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp",
          "src/jp2image_int.cpp||src/jp2image_int.cpp",
          "src/jp2image_int.hpp||src/jp2image_int.hpp",
          "unitTests/test_jp2image_int.cpp||unitTests/test_jp2image_int.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include \"config.h\"",
          "6: #include \"basicio.hpp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include \"jp2image.hpp\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9: #include \"futils.hpp\"",
          "10: #include \"image.hpp\"",
          "11: #include \"image_int.hpp\"",
          "13: #include \"safe_op.hpp\"",
          "14: #include \"tiffimage.hpp\"",
          "15: #include \"types.hpp\"",
          "",
          "[Removed Lines]",
          "12: #include \"jp2image.hpp\"",
          "",
          "[Added Lines]",
          "14: #include \"jp2image_int.hpp\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "28: constexpr uint32_t kJp2BoxTypeUuid = 0x75756964;         // 'uuid'",
          "29: constexpr uint32_t kJp2BoxTypeClose = 0x6a703263;        // 'jp2c'",
          "",
          "[Removed Lines]",
          "31: const uint32_t brandJp2 = 0x6a703220;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "40: constexpr unsigned char kJp2UuidXmp[] = \"\\xbe\\x7a\\xcf\\xcb\\x97\\xa9\\x42\\xe8\\x9c\\x71\\x99\\x94\\x91\\xe3\\xaf\\xac\";",
          "44:     0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a,",
          "45: };",
          "48:     0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a, 0x00, 0x00, 0x00, 0x14, 0x66, 0x74,",
          "49:     0x79, 0x70, 0x6a, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x2d,",
          "50:     0x6a, 0x70, 0x32, 0x68, 0x00, 0x00, 0x00, 0x16, 0x69, 0x68, 0x64, 0x72, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,",
          "",
          "[Removed Lines]",
          "43: constexpr unsigned char Jp2Signature[] = {",
          "47: constexpr unsigned char Jp2Blank[] = {",
          "",
          "[Added Lines]",
          "43: constexpr std::array<byte, 12> Jp2Signature{",
          "47: constexpr std::array<byte, 249> Jp2Blank{",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "61:     0x00, 0x00, 0xff, 0x93, 0xcf, 0xb4, 0x04, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0xd9,",
          "62: };",
          "85: void lf(std::ostream& out, bool& bLF) {",
          "86:   if (bLF) {",
          "",
          "[Removed Lines]",
          "64: struct Jp2BoxHeader {",
          "65:   uint32_t length;",
          "66:   uint32_t type;",
          "67: };",
          "69: struct Jp2ImageHeaderBox {",
          "70:   uint32_t imageHeight;",
          "71:   uint32_t imageWidth;",
          "72:   uint16_t componentCount;",
          "73:   uint8_t bpc;   //<! Bits per component",
          "74:   uint8_t c;     //<! Compression type",
          "75:   uint8_t unkC;  //<! Colourspace unknown",
          "76:   uint8_t ipr;   //<! Intellectual property",
          "77: };",
          "79: struct Jp2UuidBox {",
          "80:   uint8_t uuid[16];",
          "81: };",
          "83: const size_t boxHSize = sizeof(Jp2BoxHeader);",
          "",
          "[Added Lines]",
          "64: const size_t boxHSize = sizeof(Internal::Jp2BoxHeader);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "128:       std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;",
          "129: #endif",
          "130:       IoCloser closer(*io_);",
          "132: #ifdef EXIV2_DEBUG_MESSAGES",
          "133:         std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;",
          "134: #endif",
          "",
          "[Removed Lines]",
          "131:       if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank)) {",
          "",
          "[Added Lines]",
          "112:       if (io_->write(Jp2Blank.data(), Jp2Blank.size()) != Jp2Blank.size()) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "153:     throw Error(ErrorCode::kerDataSourceOpenFailed, io_->path(), strError());",
          "154:   }",
          "155:   IoCloser closer(*io_);",
          "157:     throw Error(ErrorCode::kerNotAnImage, \"JPEG-2000\");",
          "158:   }",
          "164:   size_t boxesCount = 0;",
          "167:   while (io_->read(reinterpret_cast<byte*>(&box), boxHSize) == boxHSize) {",
          "168:     boxes_check(boxesCount++, boxem);",
          "",
          "[Removed Lines]",
          "156:   if (!isJp2Type(*io_, true)) {",
          "160:   Jp2BoxHeader box = {0, 0};",
          "161:   Jp2BoxHeader subBox = {0, 0};",
          "162:   Jp2ImageHeaderBox ihdr = {0, 0, 0, 0, 0, 0, 0};",
          "163:   Jp2UuidBox uuid = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};",
          "165:   size_t boxem = 1000;  // boxes max",
          "",
          "[Added Lines]",
          "137:   if (!isJp2Type(*io_, false)) {",
          "141:   Internal::Jp2BoxHeader box = {0, 0};",
          "142:   Internal::Jp2BoxHeader subBox = {0, 0};",
          "143:   Internal::Jp2ImageHeaderBox ihdr = {0, 0, 0, 0, 0, 0, 0};",
          "144:   Internal::Jp2UuidBox uuid = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};",
          "146:   const size_t boxem = 1000;  // boxes max",
          "147:   uint32_t lastBoxTypeRead = 0;",
          "148:   bool boxSignatureFound = false;",
          "149:   bool boxFileTypeFound = false;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "180:       return;",
          "182:     if (box.length == 1) {",
          "184:     }",
          "186:     switch (box.type) {",
          "187:       case kJp2BoxTypeSignature: {",
          "191:         break;",
          "192:       }",
          "193:       case kJp2BoxTypeFileTypeBox: {",
          "207:           throw Error(ErrorCode::kerCorruptedMetadata);",
          "208:         break;",
          "209:       }",
          "",
          "[Removed Lines]",
          "188: #ifdef EXIV2_DEBUG_MESSAGES",
          "189:         std::cout << \"Exiv2::Jp2Image::readMetadata: JPEG 2000 Signature box found\" << std::endl;",
          "190: #endif",
          "196:         assert(box.length >= 20);  // 8 (box) + 4 (BR) + 4(MinV) + >=4 (CLn)",
          "197:         DataBuf data(box.length - boxHSize);",
          "198:         io_->read(data.data(), data.size());",
          "199:         const uint32_t brand = data.read_uint32(0, bigEndian);",
          "200:         const uint32_t minorVersion = data.read_uint32(4, bigEndian);",
          "201:         const uint32_t compatibilityList = data.read_uint32(8, bigEndian);",
          "206:         if (brand != brandJp2 || minorVersion != 0 || compatibilityList != brandJp2)",
          "",
          "[Added Lines]",
          "172:         if (boxSignatureFound)  // Only one is allowed",
          "173:           throw Error(ErrorCode::kerCorruptedMetadata);",
          "174:         boxSignatureFound = true;",
          "179:         if (boxFileTypeFound || lastBoxTypeRead != kJp2BoxTypeSignature) {  // Only one is allowed",
          "180:           throw Error(ErrorCode::kerCorruptedMetadata);",
          "181:         }",
          "182:         boxFileTypeFound = true;",
          "183:         std::vector<byte> boxData(box.length - boxHSize);",
          "184:         io_->readOrThrow(boxData.data(), boxData.size(), ErrorCode::kerCorruptedMetadata);",
          "185:         if (!Internal::isValidBoxFileType(boxData))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "397:         break;",
          "398:       }",
          "399:     }",
          "402:     io_->seek(static_cast<long>(position - boxHSize + box.length), BasicIo::beg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "379:     lastBoxTypeRead = box.type;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "422:   bool bICC = option == kpsIccProfile;",
          "423:   bool bXMP = option == kpsXMP;",
          "424:   bool bIPTCErase = option == kpsIptcErase;",
          "426:   if (bPrint) {",
          "427:     out << \"STRUCTURE OF JPEG2000 FILE: \" << io_->path() << std::endl;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "405:   bool boxSignatureFound = false;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "429:   }",
          "431:   if (bPrint || bXMP || bICC || bIPTCErase) {",
          "435:     bool bLF = false;",
          "437:     while (box.length && box.type != kJp2BoxTypeClose &&",
          "",
          "[Removed Lines]",
          "432:     Jp2BoxHeader box = {1, 1};",
          "433:     Jp2BoxHeader subBox = {1, 1};",
          "434:     Jp2UuidBox uuid = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};",
          "",
          "[Added Lines]",
          "413:     Internal::Jp2BoxHeader box = {1, 1};",
          "414:     Internal::Jp2BoxHeader subBox = {1, 1};",
          "415:     Internal::Jp2UuidBox uuid = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "454:       switch (box.type) {",
          "455:         case kJp2BoxTypeSignature: {",
          "461:             throw Error(ErrorCode::kerCorruptedMetadata);",
          "463:           break;",
          "464:         }",
          "465:         case kJp2BoxTypeFileTypeBox: {",
          "474:             throw Error(ErrorCode::kerCorruptedMetadata);",
          "475:           break;",
          "476:         }",
          "",
          "[Removed Lines]",
          "457:           assert(box.length == 12);",
          "458:           DataBuf data(4);",
          "459:           io_->read(data.data(), data.size());",
          "460:           if (data.read_uint32(0, bigEndian) != 0x0D0A870A) {",
          "462:           }",
          "468:           DataBuf data(12);",
          "469:           io_->read(data.data(), data.size());",
          "470:           uint32_t brand = data.read_uint32(0, bigEndian);",
          "471:           uint32_t minorVersion = data.read_uint32(4, bigEndian);",
          "472:           uint32_t compatibilityList = data.read_uint32(8, bigEndian);",
          "473:           if (brand != brandJp2 || minorVersion != 0 || compatibilityList != brandJp2)",
          "",
          "[Added Lines]",
          "437:           if (boxSignatureFound)  // Only one is allowed",
          "439:           boxSignatureFound = true;",
          "445:           std::vector<byte> boxData(box.length - boxHSize);",
          "446:           io_->readOrThrow(boxData.data(), boxData.size(), ErrorCode::kerCorruptedMetadata);",
          "447:           if (!Internal::isValidBoxFileType(boxData))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "629:   size_t outlen = boxHSize;                                  // now many bytes have we written to output?",
          "630:   long inlen = boxHSize;                                     // how many bytes have we read from boxBuf?",
          "631:   enforce(boxHSize <= output.size(), ErrorCode::kerCorruptedMetadata);",
          "633:   uint32_t length = getLong(reinterpret_cast<const byte*>(&pBox->length), bigEndian);",
          "634:   enforce(length <= output.size(), ErrorCode::kerCorruptedMetadata);",
          "635:   uint32_t count = boxHSize;",
          "",
          "[Removed Lines]",
          "632:   auto pBox = reinterpret_cast<const Jp2BoxHeader*>(boxBuf.c_data());",
          "",
          "[Added Lines]",
          "606:   auto pBox = reinterpret_cast<const Internal::Jp2BoxHeader*>(boxBuf.c_data());",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "639:   while (count < length && !bWroteColor) {",
          "640:     enforce(boxHSize <= length - count, ErrorCode::kerCorruptedMetadata);",
          "645:     memcpy(&subBox, pSubBox, boxHSize);",
          "648:     if (count < length) {",
          "649:       subBox.length = getLong(reinterpret_cast<byte*>(&subBox.length), bigEndian);",
          "",
          "[Removed Lines]",
          "641:     auto pSubBox = reinterpret_cast<const Jp2BoxHeader*>(p + count);",
          "644:     Jp2BoxHeader subBox;",
          "646:     Jp2BoxHeader newBox = subBox;",
          "",
          "[Added Lines]",
          "615:     auto pSubBox = reinterpret_cast<const Internal::Jp2BoxHeader*>(p + count);",
          "618:     Internal::Jp2BoxHeader subBox;",
          "620:     Internal::Jp2BoxHeader newBox = subBox;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "697:   outBuf.alloc(outlen);",
          "698:   outBuf.copyBytes(0, output.c_data(), outlen);",
          "700:   ul2Data(reinterpret_cast<byte*>(&oBox->type), kJp2BoxTypeHeader, bigEndian);",
          "701:   ul2Data(reinterpret_cast<byte*>(&oBox->length), static_cast<uint32_t>(outlen), bigEndian);",
          "702: }",
          "",
          "[Removed Lines]",
          "699:   auto oBox = reinterpret_cast<Jp2BoxHeader*>(outBuf.data());",
          "",
          "[Added Lines]",
          "673:   auto oBox = reinterpret_cast<Internal::Jp2BoxHeader*>(outBuf.data());",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "722:   }",
          "726:     throw Error(ErrorCode::kerImageWriteFailed);",
          "728: #ifdef EXIV2_DEBUG_MESSAGES",
          "729:   std::cout << \"Jp2Image::doWriteMetadata: JPEG 2000 Signature box written\" << std::endl;",
          "730: #endif",
          "734:   byte boxDataSize[4];",
          "735:   byte boxUUIDtype[4];",
          "",
          "[Removed Lines]",
          "725:   if (outIo.write(Jp2Signature, 12) != 12)",
          "732:   Jp2BoxHeader box = {0, 0};",
          "",
          "[Added Lines]",
          "699:   if (outIo.write(Jp2Signature.data(), Jp2Signature.size()) != 12)",
          "706:   Internal::Jp2BoxHeader box = {0, 0};",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "917: }",
          "919: bool isJp2Type(BasicIo& iIo, bool advance) {",
          "924:     return false;",
          "925:   }",
          "927:   if (!advance || !matched) {",
          "929:   }",
          "930:   return matched;",
          "931: }",
          "",
          "[Removed Lines]",
          "920:   const int32_t len = 12;",
          "921:   byte buf[len];",
          "922:   const size_t bytesRead = iIo.read(buf, len);",
          "923:   if (iIo.error() || iIo.eof() || bytesRead != len) {",
          "926:   bool matched = (memcmp(buf, Jp2Signature, len) == 0);",
          "928:     iIo.seek(-len, BasicIo::cur);  // Return to original position",
          "",
          "[Added Lines]",
          "894:   byte buf[Jp2Signature.size()];",
          "895:   const size_t bytesRead = iIo.read(buf, Jp2Signature.size());",
          "896:   if (iIo.error() || iIo.eof() || bytesRead != Jp2Signature.size()) {",
          "899:   bool matched = (memcmp(buf, Jp2Signature.data(), Jp2Signature.size()) == 0);",
          "901:     iIo.seek(-Jp2Signature.size(), BasicIo::cur);  // Return to original position",
          "",
          "---------------"
        ],
        "src/jp2image_int.cpp||src/jp2image_int.cpp": [
          "File: src/jp2image_int.cpp -> src/jp2image_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #include \"jp2image_int.hpp\"",
          "5: #include \"error.hpp\"",
          "6: #include \"types.hpp\"",
          "8: #include <cassert>",
          "10: namespace Exiv2::Internal {",
          "12: bool isValidBoxFileType(const std::vector<uint8_t> &boxData) {",
          "14:   if ((boxData.size() - 8u) % 4u != 0) {",
          "15:     return false;",
          "16:   }",
          "18:   const size_t N = (boxData.size() - 8u) / 4u;",
          "19:   const uint32_t brand = getULong(boxData.data(), bigEndian);",
          "20:   const uint32_t minorVersion = getULong(boxData.data() + 4, bigEndian);",
          "22:   bool clWithRightBrand = false;",
          "23:   for (size_t i = 0; i < N; i++) {",
          "24:     uint32_t compatibilityList = getULong(boxData.data() + 8 + i * 4, bigEndian);",
          "25:     if (compatibilityList == brandJp2) {",
          "26:       clWithRightBrand = true;",
          "27:       break;",
          "28:     }",
          "29:   }",
          "30:   return (brand == brandJp2 && minorVersion == 0 && clWithRightBrand);",
          "31: }",
          "32: }  // namespace Exiv2::Internal",
          "",
          "---------------"
        ],
        "src/jp2image_int.hpp||src/jp2image_int.hpp": [
          "File: src/jp2image_int.hpp -> src/jp2image_int.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #ifndef JP2IMAGE_INT_HPP",
          "4: #define JP2IMAGE_INT_HPP",
          "6: #include <cstdint>",
          "7: #include <vector>",
          "9: namespace Exiv2::Internal {",
          "11: struct Jp2BoxHeader {",
          "12:   uint32_t length;",
          "13:   uint32_t type;",
          "14: };",
          "16: struct Jp2ImageHeaderBox {",
          "17:   uint32_t imageHeight;",
          "18:   uint32_t imageWidth;",
          "19:   uint16_t componentCount;",
          "20:   uint8_t bpc;   //<! Bits per component",
          "21:   uint8_t c;     //<! Compression type",
          "22:   uint8_t unkC;  //<! Colourspace unknown",
          "23:   uint8_t ipr;   //<! Intellectual property",
          "24: };",
          "26: struct Jp2UuidBox {",
          "27:   uint8_t uuid[16];",
          "28: };",
          "30: constexpr uint32_t brandJp2{0x6a703220};",
          "33: bool isValidBoxFileType(const std::vector<std::uint8_t>& boxData);",
          "34: }  // namespace Exiv2::Internal",
          "36: #endif  // JP2IMAGE_INT_HPP",
          "",
          "---------------"
        ],
        "unitTests/test_jp2image_int.cpp||unitTests/test_jp2image_int.cpp": [
          "File: unitTests/test_jp2image_int.cpp -> unitTests/test_jp2image_int.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #include \"jp2image_int.hpp\"  // Internals of JPEG-2000 standard",
          "5: #include <gtest/gtest.h>",
          "7: using namespace Exiv2::Internal;",
          "9: namespace {",
          "10: void setValidValues(std::vector<std::uint8_t>& boxData) {",
          "12:   boxData[0] = 'j';",
          "13:   boxData[1] = 'p';",
          "14:   boxData[2] = '2';",
          "15:   boxData[3] = '\\040';",
          "20:   boxData[8] = 'j';",
          "21:   boxData[9] = 'p';",
          "22:   boxData[10] = '2';",
          "23:   boxData[11] = '\\040';",
          "24: }",
          "25: }  // namespace",
          "27: TEST(Jp2_FileTypeBox, isNotValidWithoutProperValuesSet) {",
          "28:   const std::vector<std::uint8_t> boxData(12);",
          "29:   ASSERT_FALSE(isValidBoxFileType(boxData));",
          "30: }",
          "32: TEST(Jp2_FileTypeBox, isValidWithMinimumPossibleSizeAndValidValues) {",
          "33:   std::vector<std::uint8_t> boxData(12);",
          "34:   setValidValues(boxData);",
          "35:   ASSERT_TRUE(isValidBoxFileType(boxData));",
          "36: }",
          "38: TEST(Jp2_FileTypeBox, isNotValidWithMinimumPossibleSizeButInvalidBrand) {",
          "39:   std::vector<std::uint8_t> boxData(12);",
          "40:   setValidValues(boxData);",
          "41:   boxData[2] = '3';  // Change byte in the brand field",
          "43:   ASSERT_FALSE(isValidBoxFileType(boxData));",
          "44: }",
          "46: TEST(Jp2_FileTypeBox, isNotValidWithMinimumPossibleSizeButInvalidCL1) {",
          "47:   std::vector<std::uint8_t> boxData(12);",
          "48:   setValidValues(boxData);",
          "49:   boxData[10] = '3';  // Change byte in the CL1",
          "51:   ASSERT_FALSE(isValidBoxFileType(boxData));",
          "52: }",
          "56: TEST(Jp2_FileTypeBox, withInvalidBoxDataSizeIsInvalid) {",
          "57:   std::vector<std::uint8_t> boxData(13);  // 12 + 1 (the extra byte causes problems)",
          "58:   ASSERT_FALSE(isValidBoxFileType(boxData));",
          "59: }",
          "61: TEST(Jp2_FileTypeBox, with2CLs_lastOneWithBrandValue_isValid) {",
          "62:   std::vector<std::uint8_t> boxData(16);",
          "64:   boxData[0] = 'j';",
          "65:   boxData[1] = 'p';",
          "66:   boxData[2] = '2';",
          "67:   boxData[3] = '\\040';",
          "72:   boxData[12] = 'j';",
          "73:   boxData[13] = 'p';",
          "74:   boxData[14] = '2';",
          "75:   boxData[15] = '\\040';",
          "77:   ASSERT_TRUE(isValidBoxFileType(boxData));",
          "78: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
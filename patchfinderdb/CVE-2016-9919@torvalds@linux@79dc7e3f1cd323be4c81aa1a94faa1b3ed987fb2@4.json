{
  "cve_id": "CVE-2016-9919",
  "cve_desc": "The icmp6_send function in net/ipv6/icmp.c in the Linux kernel through 4.8.12 omits a certain check of the dst data structure, which allows remote attackers to cause a denial of service (panic) via a fragmented IPv6 packet.",
  "repo": "torvalds/linux",
  "patch_hash": "79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2",
  "patch_info": {
    "commit_hash": "79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2",
    "files": [
      "net/ipv6/icmp.c"
    ],
    "message": "net: handle no dst on skb in icmp6_send\n\nAndrey reported the following while fuzzing the kernel with syzkaller:\n\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 0 PID: 3859 Comm: a.out Not tainted 4.9.0-rc6+ #429\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\ntask: ffff8800666d4200 task.stack: ffff880067348000\nRIP: 0010:[<ffffffff833617ec>]  [<ffffffff833617ec>]\nicmp6_send+0x5fc/0x1e30 net/ipv6/icmp.c:451\nRSP: 0018:ffff88006734f2c0  EFLAGS: 00010206\nRAX: ffff8800666d4200 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: dffffc0000000000 RDI: 0000000000000018\nRBP: ffff88006734f630 R08: ffff880064138418 R09: 0000000000000003\nR10: dffffc0000000000 R11: 0000000000000005 R12: 0000000000000000\nR13: ffffffff84e7e200 R14: ffff880064138484 R15: ffff8800641383c0\nFS:  00007fb3887a07c0(0000) GS:ffff88006cc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 000000006b040000 CR4: 00000000000006f0\nStack:\n ffff8800666d4200 ffff8800666d49f8 ffff8800666d4200 ffffffff84c02460\n ffff8800666d4a1a 1ffff1000ccdaa2f ffff88006734f498 0000000000000046\n ffff88006734f440 ffffffff832f4269 ffff880064ba7456 0000000000000000\nCall Trace:\n [<ffffffff83364ddc>] icmpv6_param_prob+0x2c/0x40 net/ipv6/icmp.c:557\n [<     inline     >] ip6_tlvopt_unknown net/ipv6/exthdrs.c:88\n [<ffffffff83394405>] ip6_parse_tlv+0x555/0x670 net/ipv6/exthdrs.c:157\n [<ffffffff8339a759>] ipv6_parse_hopopts+0x199/0x460 net/ipv6/exthdrs.c:663\n [<ffffffff832ee773>] ipv6_rcv+0xfa3/0x1dc0 net/ipv6/ip6_input.c:191\n ...\n\nicmp6_send / icmpv6_send is invoked for both rx and tx paths. In both\ncases the dst->dev should be preferred for determining the L3 domain\nif the dst has been set on the skb. Fallback to the skb->dev if it has\nnot. This covers the case reported here where icmp6_send is invoked on\nRx before the route lookup.\n\nFixes: 5d41ce29e (\"net: icmp6_send should use dst dev to determine L3 domain\")\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/icmp.c||net/ipv6/icmp.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/icmp.c||net/ipv6/icmp.c": [
      "File: net/ipv6/icmp.c -> net/ipv6/icmp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "448:  if (__ipv6_addr_needs_scope_id(addr_type))",
      "449:   iif = skb->dev->ifindex;",
      "",
      "[Removed Lines]",
      "450:  else",
      "451:   iif = l3mdev_master_ifindex(skb_dst(skb)->dev);",
      "",
      "[Added Lines]",
      "450:  else {",
      "451:   dst = skb_dst(skb);",
      "452:   iif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);",
      "453:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5d41ce29e3b91ef305f88d23f72b3359de329cec",
      "candidate_info": {
        "commit_hash": "5d41ce29e3b91ef305f88d23f72b3359de329cec",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5d41ce29e3b91ef305f88d23f72b3359de329cec",
        "files": [
          "net/ipv6/icmp.c"
        ],
        "message": "net: icmp6_send should use dst dev to determine L3 domain\n\nicmp6_send is called in response to some event. The skb may not have\nthe device set (skb->dev is NULL), but it is expected to have a dst set.\nUpdate icmp6_send to use the dst on the skb to determine L3 domain.\n\nFixes: ca254490c8dfd (\"net: Add VRF support to IPv6 stack\")\nSigned-off-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/icmp.c||net/ipv6/icmp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/icmp.c||net/ipv6/icmp.c"
          ],
          "candidate": [
            "net/ipv6/icmp.c||net/ipv6/icmp.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/icmp.c||net/ipv6/icmp.c": [
          "File: net/ipv6/icmp.c -> net/ipv6/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "448:  if (__ipv6_addr_needs_scope_id(addr_type))",
          "449:   iif = skb->dev->ifindex;",
          "450:  else",
          "",
          "[Removed Lines]",
          "451:   iif = l3mdev_master_ifindex(skb->dev);",
          "",
          "[Added Lines]",
          "451:   iif = l3mdev_master_ifindex(skb_dst(skb)->dev);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
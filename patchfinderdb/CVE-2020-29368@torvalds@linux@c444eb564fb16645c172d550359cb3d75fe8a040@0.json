{
  "cve_id": "CVE-2020-29368",
  "cve_desc": "An issue was discovered in __split_huge_pmd in mm/huge_memory.c in the Linux kernel before 5.7.5. The copy-on-write implementation can grant unintended write access because of a race condition in a THP mapcount check, aka CID-c444eb564fb1.",
  "repo": "torvalds/linux",
  "patch_hash": "c444eb564fb16645c172d550359cb3d75fe8a040",
  "patch_info": {
    "commit_hash": "c444eb564fb16645c172d550359cb3d75fe8a040",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c444eb564fb16645c172d550359cb3d75fe8a040",
    "files": [
      "mm/huge_memory.c"
    ],
    "message": "mm: thp: make the THP mapcount atomic against __split_huge_pmd_locked()\n\nWrite protect anon page faults require an accurate mapcount to decide\nif to break the COW or not. This is implemented in the THP path with\nreuse_swap_page() ->\npage_trans_huge_map_swapcount()/page_trans_huge_mapcount().\n\nIf the COW triggers while the other processes sharing the page are\nunder a huge pmd split, to do an accurate reading, we must ensure the\nmapcount isn't computed while it's being transferred from the head\npage to the tail pages.\n\nreuse_swap_cache() already runs serialized by the page lock, so it's\nenough to add the page lock around __split_huge_pmd_locked too, in\norder to add the missing serialization.\n\nNote: the commit in \"Fixes\" is just to facilitate the backporting,\nbecause the code before such commit didn't try to do an accurate THP\nmapcount calculation and it instead used the page_count() to decide if\nto COW or not. Both the page_count and the pin_count are THP-wide\nrefcounts, so they're inaccurate if used in\nreuse_swap_page(). Reverting such commit (besides the unrelated fix to\nthe local anon_vma assignment) would have also opened the window for\nmemory corruption side effects to certain workloads as documented in\nsuch commit header.\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nSuggested-by: Jann Horn <jannh@google.com>\nReported-by: Jann Horn <jannh@google.com>\nAcked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nFixes: 6d0a07edd17c (\"mm: thp: calculate the mapcount correctly for THP pages during WP faults\")\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/huge_memory.c||mm/huge_memory.c"
    ]
  },
  "patch_diff": {
    "mm/huge_memory.c||mm/huge_memory.c": [
      "File: mm/huge_memory.c -> mm/huge_memory.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2385: {",
      "2386:  spinlock_t *ptl;",
      "2387:  struct mmu_notifier_range range;",
      "2389:  mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,",
      "2390:     address & HPAGE_PMD_MASK,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2388:  bool was_locked = false;",
      "2389:  pmd_t _pmd;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2399:  VM_BUG_ON(freeze && !page);",
      "2403:  if (pmd_trans_huge(*pmd)) {",
      "2405:   if (PageMlocked(page))",
      "2406:    clear_page_mlock(page);",
      "2407:  } else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))",
      "",
      "[Removed Lines]",
      "2400:  if (page && page != pmd_page(*pmd))",
      "2401:          goto out;",
      "2404:   page = pmd_page(*pmd);",
      "",
      "[Added Lines]",
      "2402:  if (page) {",
      "2403:   VM_WARN_ON_ONCE(!PageLocked(page));",
      "2404:   was_locked = true;",
      "2405:   if (page != pmd_page(*pmd))",
      "2406:    goto out;",
      "2407:  }",
      "2409: repeat:",
      "2411:   if (!page) {",
      "2412:    page = pmd_page(*pmd);",
      "2413:    if (unlikely(!trylock_page(page))) {",
      "2414:     get_page(page);",
      "2415:     _pmd = *pmd;",
      "2416:     spin_unlock(ptl);",
      "2417:     lock_page(page);",
      "2418:     spin_lock(ptl);",
      "2419:     if (unlikely(!pmd_same(*pmd, _pmd))) {",
      "2420:      unlock_page(page);",
      "2421:      put_page(page);",
      "2422:      page = NULL;",
      "2423:      goto repeat;",
      "2424:     }",
      "2425:     put_page(page);",
      "2426:    }",
      "2427:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2409:  __split_huge_pmd_locked(vma, pmd, range.start, freeze);",
      "2410: out:",
      "2411:  spin_unlock(ptl);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2435:  if (!was_locked && page)",
      "2436:   unlock_page(page);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1c2f67308af4c102b4e1e6cd6f69819ae59408e0",
      "candidate_info": {
        "commit_hash": "1c2f67308af4c102b4e1e6cd6f69819ae59408e0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1c2f67308af4c102b4e1e6cd6f69819ae59408e0",
        "files": [
          "mm/huge_memory.c"
        ],
        "message": "mm: thp: fix MADV_REMOVE deadlock on shmem THP\n\nSergey reported deadlock between kswapd correctly doing its usual\nlock_page(page) followed by down_read(page->mapping->i_mmap_rwsem), and\nmadvise(MADV_REMOVE) on an madvise(MADV_HUGEPAGE) area doing\ndown_write(page->mapping->i_mmap_rwsem) followed by lock_page(page).\n\nThis happened when shmem_fallocate(punch hole)'s unmap_mapping_range()\nreaches zap_pmd_range()'s call to __split_huge_pmd().  The same deadlock\ncould occur when partially truncating a mapped huge tmpfs file, or using\nfallocate(FALLOC_FL_PUNCH_HOLE) on it.\n\n__split_huge_pmd()'s page lock was added in 5.8, to make sure that any\nconcurrent use of reuse_swap_page() (holding page lock) could not catch\nthe anon THP's mapcounts and swapcounts while they were being split.\n\nFortunately, reuse_swap_page() is never applied to a shmem or file THP\n(not even by khugepaged, which checks PageSwapCache before calling), and\nanonymous THPs are never created in shmem or file areas: so that\n__split_huge_pmd()'s page lock can only be necessary for anonymous THPs,\non which there is no risk of deadlock with i_mmap_rwsem.\n\nLink: https://lkml.kernel.org/r/alpine.LSU.2.11.2101161409470.2022@eggly.anvils\nFixes: c444eb564fb1 (\"mm: thp: make the THP mapcount atomic against __split_huge_pmd_locked()\")\nSigned-off-by: Hugh Dickins <hughd@google.com>\nReported-by: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>\nReviewed-by: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/huge_memory.c||mm/huge_memory.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/huge_memory.c||mm/huge_memory.c"
          ],
          "candidate": [
            "mm/huge_memory.c||mm/huge_memory.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2202: {",
          "2203:  spinlock_t *ptl;",
          "2204:  struct mmu_notifier_range range;",
          "2206:  pmd_t _pmd;",
          "2208:  mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,",
          "",
          "[Removed Lines]",
          "2205:  bool was_locked = false;",
          "",
          "[Added Lines]",
          "2205:  bool do_unlock_page = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2218:  VM_BUG_ON(freeze && !page);",
          "2219:  if (page) {",
          "2220:   VM_WARN_ON_ONCE(!PageLocked(page));",
          "2222:   if (page != pmd_page(*pmd))",
          "2223:    goto out;",
          "2224:  }",
          "",
          "[Removed Lines]",
          "2221:   was_locked = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2227:  if (pmd_trans_huge(*pmd)) {",
          "2228:   if (!page) {",
          "2229:    page = pmd_page(*pmd);",
          "2238:      put_page(page);",
          "2241:     }",
          "2243:    }",
          "2244:   }",
          "2245:   if (PageMlocked(page))",
          "",
          "[Removed Lines]",
          "2230:    if (unlikely(!trylock_page(page))) {",
          "2231:     get_page(page);",
          "2232:     _pmd = *pmd;",
          "2233:     spin_unlock(ptl);",
          "2234:     lock_page(page);",
          "2235:     spin_lock(ptl);",
          "2236:     if (unlikely(!pmd_same(*pmd, _pmd))) {",
          "2237:      unlock_page(page);",
          "2239:      page = NULL;",
          "2240:      goto repeat;",
          "2242:     put_page(page);",
          "",
          "[Added Lines]",
          "2236:    if (PageAnon(page)) {",
          "2237:     if (unlikely(!trylock_page(page))) {",
          "2238:      get_page(page);",
          "2239:      _pmd = *pmd;",
          "2240:      spin_unlock(ptl);",
          "2241:      lock_page(page);",
          "2242:      spin_lock(ptl);",
          "2243:      if (unlikely(!pmd_same(*pmd, _pmd))) {",
          "2244:       unlock_page(page);",
          "2245:       put_page(page);",
          "2246:       page = NULL;",
          "2247:       goto repeat;",
          "2248:      }",
          "2251:     do_unlock_page = true;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2249:  __split_huge_pmd_locked(vma, pmd, range.start, freeze);",
          "2250: out:",
          "2251:  spin_unlock(ptl);",
          "2253:   unlock_page(page);",
          "",
          "[Removed Lines]",
          "2252:  if (!was_locked && page)",
          "",
          "[Added Lines]",
          "2261:  if (do_unlock_page)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
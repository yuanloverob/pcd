{
  "cve_id": "CVE-2019-10902",
  "cve_desc": "In Wireshark 3.0.0, the TSDNS dissector could crash. This was addressed in epan/dissectors/packet-tsdns.c by splitting strings safely.",
  "repo": "wireshark/wireshark",
  "patch_hash": "19d54ac364150cd6c76488d2c2a5b6fd081daa5a",
  "patch_info": {
    "commit_hash": "19d54ac364150cd6c76488d2c2a5b6fd081daa5a",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/19d54ac364150cd6c76488d2c2a5b6fd081daa5a",
    "files": [
      "epan/dissectors/packet-tsdns.c",
      "epan/wmem/wmem_strutl.h"
    ],
    "message": "TSDNS: Add more wmem_strsplit return checks.\n\nwmem_strsplit might return NULL, or it might return fewer tokens than\nrequested. Add checks accordingly. Update the API documentation while\nwe're here.\n\nBug: 15619\nChange-Id: I55ae05a36d05252cf57e5c7047a441ef1b438a81\nReviewed-on: https://code.wireshark.org/review/32494\nReviewed-by: Gerald Combs <gerald@wireshark.org>\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c",
      "epan/wmem/wmem_strutl.h||epan/wmem/wmem_strutl.h"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c": [
      "File: epan/dissectors/packet-tsdns.c -> epan/dissectors/packet-tsdns.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "73:     address_item = proto_tree_add_item(tsdns_tree, hf_tsdns_response_address, tvb, offset, pLen, ENC_ASCII|ENC_NA);",
      "74:     gchar** splitAddress;",
      "75:     splitAddress = wmem_strsplit(wmem_packet_scope(), tvb_format_text(tvb, 0, pLen), \":\", 1); // unsure if TSDNS also does IPv6...",
      "77:       expert_add_info(pinfo, address_item, &ei_response_port_malformed);",
      "78:     } else {",
      "79:       proto_tree_add_string(tsdns_tree, hf_tsdns_response_ip, tvb, 0, pLen, splitAddress[0]);",
      "",
      "[Removed Lines]",
      "76:     if (splitAddress[1] == NULL) {",
      "",
      "[Added Lines]",
      "76:     if (splitAddress == NULL || splitAddress[0] == NULL || splitAddress[1] == NULL) {",
      "",
      "---------------"
    ],
    "epan/wmem/wmem_strutl.h||epan/wmem/wmem_strutl.h": [
      "File: epan/wmem/wmem_strutl.h -> epan/wmem/wmem_strutl.h"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "95571f17d5e2de39735e62e5251583f930c06d51",
      "candidate_info": {
        "commit_hash": "95571f17d5e2de39735e62e5251583f930c06d51",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/95571f17d5e2de39735e62e5251583f930c06d51",
        "files": [
          "epan/dissectors/packet-tsdns.c",
          "epan/wmem/wmem_strutl.h"
        ],
        "message": "TSDNS: Add more wmem_strsplit return checks.\n\nwmem_strsplit might return NULL, or it might return fewer tokens than\nrequested. Add checks accordingly. Update the API documentation while\nwe're here.\n\nBug: 15619\nChange-Id: I55ae05a36d05252cf57e5c7047a441ef1b438a81\nReviewed-on: https://code.wireshark.org/review/32494\nReviewed-by: Gerald Combs <gerald@wireshark.org>\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 19d54ac364150cd6c76488d2c2a5b6fd081daa5a)\nReviewed-on: https://code.wireshark.org/review/32505",
        "before_after_code_files": [
          "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c",
          "epan/wmem/wmem_strutl.h||epan/wmem/wmem_strutl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c",
            "epan/wmem/wmem_strutl.h||epan/wmem/wmem_strutl.h"
          ],
          "candidate": [
            "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c",
            "epan/wmem/wmem_strutl.h||epan/wmem/wmem_strutl.h"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c": [
          "File: epan/dissectors/packet-tsdns.c -> epan/dissectors/packet-tsdns.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:     address_item = proto_tree_add_item(tsdns_tree, hf_tsdns_response_address, tvb, offset, pLen, ENC_ASCII|ENC_NA);",
          "74:     gchar** splitAddress;",
          "75:     splitAddress = wmem_strsplit(wmem_packet_scope(), tvb_format_text(tvb, 0, pLen), \":\", 1); // unsure if TSDNS also does IPv6...",
          "77:       expert_add_info(pinfo, address_item, &ei_response_port_malformed);",
          "78:     } else {",
          "79:       proto_tree_add_string(tsdns_tree, hf_tsdns_response_ip, tvb, 0, pLen, splitAddress[0]);",
          "",
          "[Removed Lines]",
          "76:     if (splitAddress[1] == NULL) {",
          "",
          "[Added Lines]",
          "76:     if (splitAddress == NULL || splitAddress[0] == NULL || splitAddress[1] == NULL) {",
          "",
          "---------------"
        ],
        "epan/wmem/wmem_strutl.h||epan/wmem/wmem_strutl.h": [
          "File: epan/wmem/wmem_strutl.h -> epan/wmem/wmem_strutl.h"
        ]
      }
    },
    {
      "candidate_hash": "5490e4f8c48b36d3dd2e7014d94062318cd09378",
      "candidate_info": {
        "commit_hash": "5490e4f8c48b36d3dd2e7014d94062318cd09378",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/5490e4f8c48b36d3dd2e7014d94062318cd09378",
        "files": [
          "docbook/release-notes.asciidoc",
          "epan/dissectors/CMakeLists.txt",
          "epan/dissectors/packet-tsdns.c"
        ],
        "message": "Add TSDNS (TeamSpeak 3 DNS) dissector\n\nChange-Id: I1f828df1735bd10ef8849d208e10ea1339ba37e2\nReviewed-on: https://code.wireshark.org/review/26403\nReviewed-by: Michael Mann <mmann78@netscape.net>\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "docbook/release-notes.asciidoc||docbook/release-notes.asciidoc",
          "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c"
          ],
          "candidate": [
            "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c"
          ]
        }
      },
      "candidate_diff": {
        "docbook/release-notes.asciidoc||docbook/release-notes.asciidoc": [
          "File: docbook/release-notes.asciidoc -> docbook/release-notes.asciidoc",
          "--- Hunk 1 ---",
          "[Context before]",
          "92: S101 Lawo Emberplus transport frame",
          "93: STCSIG (Spirent Test Center Signature decoding for Ethernet and FibreChannel, disabled by default)",
          "94: systemd Journal Export",
          "95: TDS (Sybase-specific portions of the protocol)",
          "96: TPM 2.0 protocol",
          "97: Ubiquiti Discovery Protocol (UBDP)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: TeamSpeak 3 DNS",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-tsdns.c||epan/dissectors/packet-tsdns.c": [
          "File: epan/dissectors/packet-tsdns.c -> epan/dissectors/packet-tsdns.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"config.h\"",
          "14: #include <epan/packet.h>",
          "15: #include <epan/expert.h>",
          "16: #include <wsutil/strtoi.h>",
          "20: void proto_register_tsdns(void);",
          "21: void proto_reg_handoff_tsdns(void);",
          "23: static int proto_tsdns = -1;",
          "25: static int hf_tsdns_data = -1;",
          "26: static int hf_tsdns_request = -1;",
          "27: static int hf_tsdns_request_domain = -1;",
          "28: static int hf_tsdns_response = -1;",
          "29: static int hf_tsdns_response_ip = -1;",
          "30: static int hf_tsdns_response_address = -1;",
          "31: static int hf_tsdns_response_port = -1;",
          "33: static expert_field ei_response_port_malformed = EI_INIT;",
          "35: static gint ett_tsdns = -1;",
          "37: static int dissect_tsdns(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)",
          "38: {",
          "40:   int         offset    = 0;",
          "41:   gboolean    request   = FALSE;",
          "43:   if (pinfo->destport == pinfo->match_uint) {",
          "44:     request = TRUE;",
          "45:   }",
          "47:   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"TSDNS\");",
          "49:   int pLen = tvb_reported_length(tvb);",
          "51:   if (request) {",
          "52:     col_set_str(pinfo->cinfo, COL_INFO, \"Request\");",
          "53:     col_append_fstr(pinfo->cinfo, COL_INFO, \" %.*s\", pLen - 5, tvb_get_string_enc(wmem_packet_scope(), tvb, 0, pLen - 5, ENC_ASCII|ENC_NA));",
          "54:   } else {",
          "55:     col_set_str(pinfo->cinfo, COL_INFO, \"Response\");",
          "56:     col_append_fstr(pinfo->cinfo, COL_INFO, \" %.*s\", pLen, tvb_get_string_enc(wmem_packet_scope(), tvb, 0, pLen, ENC_ASCII|ENC_NA));",
          "57:   }",
          "59:   proto_tree *tsdns_tree;",
          "60:   proto_item *ti, *hidden_item, *address_item;",
          "62:   ti = proto_tree_add_item(tree, proto_tsdns, tvb, offset, -1, ENC_NA);",
          "63:   tsdns_tree = proto_item_add_subtree(ti, ett_tsdns);",
          "65:   hidden_item = proto_tree_add_item(tsdns_tree, hf_tsdns_data, tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "66:   PROTO_ITEM_SET_HIDDEN(hidden_item);",
          "68:   if (request) { // request is DOMAIN\\n\\r\\r\\r\\n",
          "69:     hidden_item = proto_tree_add_boolean(tsdns_tree, hf_tsdns_request, tvb, 0, 0, 1); // using pLen - 5 as the last chars are \\n\\r\\r\\r\\n which are just indicating the end of the request",
          "70:     proto_tree_add_item(tsdns_tree, hf_tsdns_request_domain, tvb, offset, pLen - 5, ENC_ASCII|ENC_NA);",
          "71:   } else { // response is IP:PORT",
          "72:     hidden_item = proto_tree_add_boolean(tsdns_tree, hf_tsdns_response, tvb, 0, 0, 1);",
          "73:     address_item = proto_tree_add_item(tsdns_tree, hf_tsdns_response_address, tvb, offset, pLen, ENC_ASCII|ENC_NA);",
          "74:     gchar** splitAddress;",
          "75:     splitAddress = wmem_strsplit(wmem_packet_scope(), tvb_format_text(tvb, 0, pLen), \":\", 1); // unsure if TSDNS also does IPv6...",
          "76:     if (splitAddress[1] == NULL) {",
          "77:       expert_add_info(pinfo, address_item, &ei_response_port_malformed);",
          "78:     } else {",
          "79:       proto_tree_add_string(tsdns_tree, hf_tsdns_response_ip, tvb, 0, pLen, splitAddress[0]);",
          "80:       guint32 port;",
          "81:       if (ws_strtou32(splitAddress[1], NULL, &port))",
          "82:         proto_tree_add_uint(tsdns_tree, hf_tsdns_response_port, tvb, 0, pLen, port);",
          "83:     }",
          "84:   }",
          "85:   PROTO_ITEM_SET_HIDDEN(hidden_item);",
          "87:   return tvb_captured_length(tvb);",
          "91: void proto_register_tsdns(void)",
          "92: {",
          "94:   static hf_register_info hf[] = {",
          "95:     { &hf_tsdns_data,",
          "96:       { \"Data\",    \"tsdns.data\",",
          "97:         FT_STRING,       BASE_NONE,      NULL,   0x0,",
          "98:         NULL, HFILL }},",
          "99:     { &hf_tsdns_request,",
          "100:       { \"Request\", \"tsdns.request\",",
          "101:         FT_BOOLEAN,     BASE_NONE,      NULL,   0x0,",
          "102:         \"TRUE if TSDNS Request\", HFILL }},",
          "103:     { &hf_tsdns_request_domain,",
          "104:       { \"Requested Domain\", \"tsdns.request.domain\",",
          "105:         FT_STRING,     BASE_NONE,      NULL,   0x0,",
          "106:         NULL, HFILL }},",
          "107:     { &hf_tsdns_response,",
          "108:       { \"Response\",\"tsdns.response\",",
          "109:         FT_BOOLEAN,     BASE_NONE,      NULL,   0x0,",
          "110:         \"TRUE if TSDNS Response\", HFILL }},",
          "111:     { &hf_tsdns_response_address,",
          "112:        { \"Response Address\",\"tsdns.response.address\",",
          "113:          FT_STRING,     BASE_NONE,      NULL,   0x0,",
          "114:          NULL, HFILL }},",
          "115:     { &hf_tsdns_response_ip,",
          "116:       { \"Response IP\",\"tsdns.response.ip\",",
          "117:         FT_STRING,     BASE_NONE,      NULL,   0x0,",
          "118:         NULL, HFILL }},",
          "119:     { &hf_tsdns_response_port,",
          "120:       { \"Response Port\",\"tsdns.response.port\",",
          "121:         FT_UINT16,     BASE_DEC,      NULL,   0x0,",
          "122:         NULL, HFILL }}",
          "123:   };",
          "125:   static ei_register_info ei[] = {",
          "126:           { &ei_response_port_malformed, { \"tsdns.response.port.malformed\", PI_MALFORMED, PI_ERROR, \"Address port is not an integer or not contained in address\", EXPFILL }}",
          "127:   };",
          "128:   expert_module_t* expert_tsdns;",
          "130:   static gint *ett[] = {",
          "131:     &ett_tsdns",
          "132:   };",
          "134:   proto_tsdns = proto_register_protocol(\"TeamSpeak3 DNS\", \"TSDNS\", \"tsdns\");",
          "135:   proto_register_field_array(proto_tsdns, hf, array_length(hf));",
          "136:   proto_register_subtree_array(ett, array_length(ett));",
          "137:   expert_tsdns = expert_register_protocol(proto_tsdns);",
          "138:   expert_register_field_array(expert_tsdns, ei, array_length(ei));",
          "139: }",
          "141: void proto_reg_handoff_tsdns(void)",
          "142: {",
          "143:   dissector_handle_t tsdns_handle;",
          "145:   tsdns_handle = create_dissector_handle(dissect_tsdns, proto_tsdns);",
          "147:   dissector_add_uint_with_preference(\"tcp.port\", TSDNS_PORT, tsdns_handle);",
          "148: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2011-4087",
  "cve_desc": "The br_parse_ip_options function in net/bridge/br_netfilter.c in the Linux kernel before 2.6.39 does not properly initialize a certain data structure, which allows remote attackers to cause a denial of service by leveraging connectivity to a network interface that uses an Ethernet bridge device.",
  "repo": "torvalds/linux",
  "patch_hash": "f8e9881c2aef1e982e5abc25c046820cd0b7cf64",
  "patch_info": {
    "commit_hash": "f8e9881c2aef1e982e5abc25c046820cd0b7cf64",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64",
    "files": [
      "net/bridge/br_netfilter.c"
    ],
    "message": "bridge: reset IPCB in br_parse_ip_options\n\nCommit 462fb2af9788a82 (bridge : Sanitize skb before it enters the IP\nstack), missed one IPCB init before calling ip_options_compile()\n\nThanks to Scot Doyle for his tests and bug reports.\n\nReported-by: Scot Doyle <lkml@scotdoyle.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Hiroaki SHIMODA <shimoda.hiroaki@gmail.com>\nAcked-by: Bandan Das <bandan.das@stratus.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nCc: Jan L\u00fcbbe <jluebbe@debian.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/bridge/br_netfilter.c||net/bridge/br_netfilter.c"
    ]
  },
  "patch_diff": {
    "net/bridge/br_netfilter.c||net/bridge/br_netfilter.c": [
      "File: net/bridge/br_netfilter.c -> net/bridge/br_netfilter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "249:   goto drop;",
      "250:  }",
      "255:   return 0;",
      "258:  opt->optlen = iph->ihl*4 - sizeof(struct iphdr);",
      "259:  if (ip_options_compile(dev_net(dev), opt, skb))",
      "",
      "[Removed Lines]",
      "253:  if (iph->ihl == 5) {",
      "254:   memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));",
      "256:  }",
      "",
      "[Added Lines]",
      "252:  memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));",
      "253:  if (iph->ihl == 5)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "462fb2af9788a82a534f8184abfde31574e1cfa0",
      "candidate_info": {
        "commit_hash": "462fb2af9788a82a534f8184abfde31574e1cfa0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/462fb2af9788a82a534f8184abfde31574e1cfa0",
        "files": [
          "net/bridge/br_netfilter.c",
          "net/ipv4/ip_options.c"
        ],
        "message": "bridge : Sanitize skb before it enters the IP stack\n\nRelated dicussion here : http://lkml.org/lkml/2010/9/3/16\n\nIntroduce a function br_parse_ip_options that will audit the\nskb and possibly refill IP options before a packet enters the\nIP stack. If no options are present, the function will zero out\nthe skb cb area so that it is not misinterpreted as options by some\nunsuspecting IP layer routine. If packet consistency fails, drop it.\n\nSigned-off-by: Bandan Das <bandan.das@stratus.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/bridge/br_netfilter.c||net/bridge/br_netfilter.c",
          "net/ipv4/ip_options.c||net/ipv4/ip_options.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bridge/br_netfilter.c||net/bridge/br_netfilter.c"
          ],
          "candidate": [
            "net/bridge/br_netfilter.c||net/bridge/br_netfilter.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bridge/br_netfilter.c||net/bridge/br_netfilter.c": [
          "File: net/bridge/br_netfilter.c -> net/bridge/br_netfilter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "209:   skb->protocol = htons(ETH_P_PPP_SES);",
          "210: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217: int br_parse_ip_options(struct sk_buff *skb)",
          "218: {",
          "219:  struct ip_options *opt;",
          "220:  struct iphdr *iph;",
          "221:  struct net_device *dev = skb->dev;",
          "222:  u32 len;",
          "224:  iph = ip_hdr(skb);",
          "225:  opt = &(IPCB(skb)->opt);",
          "228:  if (iph->ihl < 5 || iph->version != 4)",
          "229:   goto inhdr_error;",
          "231:  if (!pskb_may_pull(skb, iph->ihl*4))",
          "232:   goto inhdr_error;",
          "234:  iph = ip_hdr(skb);",
          "235:  if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))",
          "236:   goto inhdr_error;",
          "238:  len = ntohs(iph->tot_len);",
          "239:  if (skb->len < len) {",
          "240:   IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);",
          "241:   goto drop;",
          "242:  } else if (len < (iph->ihl*4))",
          "243:   goto inhdr_error;",
          "245:  if (pskb_trim_rcsum(skb, len)) {",
          "246:   IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);",
          "247:   goto drop;",
          "248:  }",
          "251:  if (iph->ihl == 5) {",
          "252:   memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));",
          "253:   return 0;",
          "254:  }",
          "256:  opt->optlen = iph->ihl*4 - sizeof(struct iphdr);",
          "257:  if (ip_options_compile(dev_net(dev), opt, skb))",
          "258:   goto inhdr_error;",
          "261:  if (unlikely(opt->srr)) {",
          "262:   struct in_device *in_dev = __in_dev_get_rcu(dev);",
          "263:   if (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))",
          "264:    goto drop;",
          "266:   if (ip_options_rcv_srr(skb))",
          "267:    goto drop;",
          "268:  }",
          "270:  return 0;",
          "272: inhdr_error:",
          "273:  IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);",
          "274: drop:",
          "275:  return -1;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "549: {",
          "550:  struct net_bridge_port *p;",
          "551:  struct net_bridge *br;",
          "553:  __u32 len = nf_bridge_encap_header_len(skb);",
          "555:  if (unlikely(!pskb_may_pull(skb, len)))",
          "",
          "[Removed Lines]",
          "552:  struct iphdr *iph;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "579:  nf_bridge_pull_encap_header_rcsum(skb);",
          "604:  nf_bridge_put(skb->nf_bridge);",
          "605:  if (!nf_bridge_alloc(skb))",
          "",
          "[Removed Lines]",
          "581:  if (!pskb_may_pull(skb, sizeof(struct iphdr)))",
          "582:   goto inhdr_error;",
          "584:  iph = ip_hdr(skb);",
          "585:  if (iph->ihl < 5 || iph->version != 4)",
          "586:   goto inhdr_error;",
          "588:  if (!pskb_may_pull(skb, 4 * iph->ihl))",
          "589:   goto inhdr_error;",
          "591:  iph = ip_hdr(skb);",
          "592:  if (ip_fast_csum((__u8 *) iph, iph->ihl) != 0)",
          "593:   goto inhdr_error;",
          "595:  len = ntohs(iph->tot_len);",
          "596:  if (skb->len < len || len < 4 * iph->ihl)",
          "597:   goto inhdr_error;",
          "599:  pskb_trim_rcsum(skb, len);",
          "602:  memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));",
          "",
          "[Added Lines]",
          "646:  if (br_parse_ip_options(skb))",
          "648:   goto out;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "615:  return NF_STOLEN;",
          "619: out:",
          "620:  return NF_DROP;",
          "621: }",
          "",
          "[Removed Lines]",
          "617: inhdr_error:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "759: #if defined(CONFIG_NF_CONNTRACK_IPV4) || defined(CONFIG_NF_CONNTRACK_IPV4_MODULE)",
          "760: static int br_nf_dev_queue_xmit(struct sk_buff *skb)",
          "761: {",
          "762:  if (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&",
          "763:      skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&",
          "764:      !skb_is_gso(skb)) {",
          "768:  } else",
          "770: }",
          "771: #else",
          "772: static int br_nf_dev_queue_xmit(struct sk_buff *skb)",
          "",
          "[Removed Lines]",
          "766:   memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));",
          "767:   return ip_fragment(skb, br_dev_queue_push_xmit);",
          "769:   return br_dev_queue_push_xmit(skb);",
          "",
          "[Added Lines]",
          "806:  int ret;",
          "811:   if (br_parse_ip_options(skb))",
          "813:    return NF_DROP;",
          "814:   ret = ip_fragment(skb, br_dev_queue_push_xmit);",
          "816:   ret = br_dev_queue_push_xmit(skb);",
          "818:  return ret;",
          "",
          "---------------"
        ],
        "net/ipv4/ip_options.c||net/ipv4/ip_options.c": [
          "File: net/ipv4/ip_options.c -> net/ipv4/ip_options.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "466:  }",
          "467:  return -EINVAL;",
          "468: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "469: EXPORT_SYMBOL(ip_options_compile);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "646:  }",
          "647:  return 0;",
          "648: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "649: EXPORT_SYMBOL(ip_options_rcv_srr);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
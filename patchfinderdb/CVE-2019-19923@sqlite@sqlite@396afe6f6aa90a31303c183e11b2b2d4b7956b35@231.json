{
  "cve_id": "CVE-2019-19923",
  "cve_desc": "flattenSubquery in select.c in SQLite 3.30.1 mishandles certain uses of SELECT DISTINCT involving a LEFT JOIN in which the right-hand side is a view. This can cause a NULL pointer dereference (or incorrect results).",
  "repo": "sqlite/sqlite",
  "patch_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
  "patch_info": {
    "commit_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/join.test"
    ],
    "message": "Continue to back away from the LEFT JOIN optimization of check-in [41c27bc0ff1d3135] by disallowing query flattening if the outer query is DISTINCT.  Without this fix, if an index scan is run on the table within the view on the right-hand side of the LEFT JOIN, stale result registers might be accessed yielding incorrect results, and/or an OP_IfNullRow opcode might be invoked on the un-opened table, resulting in a NULL-pointer dereference.  This problem was found by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: 862974312edf00e9d1068115d1a39b7235b7db68b6d86b81d38a12f025a4748e",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/join.test||test/join.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 289158aa24b066c453d2bce4bc2dead1c56fb0b23c3f7c4810b34b13627cef34",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3797:   if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){",
      "3798:     isLeftJoin = 1;",
      "3801:       return 0;",
      "3802:     }",
      "3803:   }",
      "",
      "[Removed Lines]",
      "3799:     if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){",
      "",
      "[Added Lines]",
      "3804:     ){",
      "",
      "---------------"
    ],
    "test/join.test||test/join.test": [
      "File: test/join.test -> test/join.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "975:   SELECT 24, * FROM t1 LEFT JOIN t0 ON +aa ISNULL;",
      "976: } {13 1 {} 14 1 {} 23 1 {} 24 1 {}}",
      "978: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "978: # 2019-12-18 problem with a LEFT JOIN where the RHS is a view.",
      "979: # Detected by Yongheng and Rui.",
      "980: # Follows from the optimization attempt of check-in 41c27bc0ff1d3135",
      "981: # on 2017-04-18",
      "982: #",
      "983: reset_db",
      "984: do_execsql_test join-22.10 {",
      "985:   CREATE TABLE t0(a, b);",
      "986:   CREATE INDEX t0a ON t0(a);",
      "987:   INSERT INTO t0 VALUES(10,10),(10,11),(10,12);",
      "988:   SELECT DISTINCT c FROM t0 LEFT JOIN (SELECT a+1 AS c FROM t0) ORDER BY c ;",
      "989: } {11}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c5a93d4c85ef5b7c4219ec251d60a37306b625a6",
      "candidate_info": {
        "commit_hash": "c5a93d4c85ef5b7c4219ec251d60a37306b625a6",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c5a93d4c85ef5b7c4219ec251d60a37306b625a6",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c",
          "src/build.c",
          "src/prepare.c",
          "src/sqliteInt.h",
          "src/trigger.c",
          "src/vdbe.c",
          "test/corruptL.test",
          "test/corruptM.test",
          "test/dbfuzz001.test"
        ],
        "message": "Validate the type, name, and tbl_name fields of the sqlite_master table when loading the schema, unless writable_schema is engaged.\n\nFossilOrigin-Name: 724f4df9ccc2b683f7091a3f7a8c20ee210f44d7a610cd1b4c49da1c274add08",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c",
          "src/build.c||src/build.c",
          "src/prepare.c||src/prepare.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/trigger.c||src/trigger.c",
          "src/vdbe.c||src/vdbe.c",
          "test/corruptL.test||test/corruptL.test",
          "test/corruptM.test||test/corruptM.test",
          "test/dbfuzz001.test||test/dbfuzz001.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: da01ba4fa47c6508b31533ccd769e637af04bd37f51463372fbc6c848d892a4d",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "136:   if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){",
          "137:     goto exit_rename_table;",
          "138:   }",
          "141:   }",
          "143: #ifndef SQLITE_OMIT_VIEW",
          "",
          "[Removed Lines]",
          "139:   if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){ goto",
          "140:     exit_rename_table;",
          "",
          "[Added Lines]",
          "139:   if( SQLITE_OK!=sqlite3CheckObjectName(pParse,zName,\"table\",zName) ){",
          "140:     goto exit_rename_table;",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "839:   }",
          "840:   return SQLITE_OK;",
          "841: }",
          "",
          "[Removed Lines]",
          "833: int sqlite3CheckObjectName(Parse *pParse, const char *zName){",
          "834:   if( !pParse->db->init.busy && pParse->nested==0",
          "835:           && sqlite3WritableSchema(pParse->db)==0",
          "836:           && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7) ){",
          "837:     sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\", zName);",
          "838:     return SQLITE_ERROR;",
          "",
          "[Added Lines]",
          "837: int sqlite3CheckObjectName(",
          "842: ){",
          "843:   sqlite3 *db = pParse->db;",
          "844:   if( sqlite3WritableSchema(db) || db->init.imposterTable ){",
          "846:     return SQLITE_OK;",
          "847:   }",
          "848:   if( db->init.busy ){",
          "849:     if( sqlite3_stricmp(zType, db->init.azInit[0])",
          "850:      || sqlite3_stricmp(zName, db->init.azInit[1])",
          "851:      || sqlite3_stricmp(zTblName, db->init.azInit[2])",
          "852:     ){",
          "854:       return SQLITE_ERROR;",
          "855:     }",
          "856:   }else{",
          "857:     if( pParse->nested==0",
          "858:      && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7)",
          "859:     ){",
          "860:       sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\",",
          "861:                       zName);",
          "862:       return SQLITE_ERROR;",
          "863:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "916:   }",
          "917:   pParse->sNameToken = *pName;",
          "918:   if( zName==0 ) return;",
          "920:     goto begin_table_error;",
          "921:   }",
          "922:   if( db->init.iDb==1 ) isTemp = 1;",
          "",
          "[Removed Lines]",
          "919:   if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){",
          "",
          "[Added Lines]",
          "944:   if( sqlite3CheckObjectName(pParse, zName, isView?\"view\":\"table\", zName) ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3275:     zName = sqlite3NameFromToken(db, pName);",
          "3276:     if( zName==0 ) goto exit_create_index;",
          "3277:     assert( pName->z!=0 );",
          "3279:       goto exit_create_index;",
          "3280:     }",
          "3281:     if( !IN_RENAME_OBJECT ){",
          "",
          "[Removed Lines]",
          "3278:     if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){",
          "",
          "[Added Lines]",
          "3303:     if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName,\"index\",pTab->zName) ){",
          "",
          "---------------"
        ],
        "src/prepare.c||src/prepare.c": [
          "File: src/prepare.c -> src/prepare.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:   sqlite3 *db = pData->db;",
          "75:   int iDb = pData->iDb;",
          "78:   UNUSED_PARAMETER2(NotUsed, argc);",
          "79:   assert( sqlite3_mutex_held(db->mutex) );",
          "80:   DbClearProperty(db, iDb, DB_Empty);",
          "81:   pData->nInitRow++;",
          "82:   if( db->mallocFailed ){",
          "84:     return 1;",
          "85:   }",
          "87:   assert( iDb>=0 && iDb<db->nDb );",
          "",
          "[Removed Lines]",
          "77:   assert( argc==3 );",
          "83:     corruptSchema(pData, argv[0], 0);",
          "89:   if( argv[1]==0 ){",
          "90:     corruptSchema(pData, argv[0], 0);",
          "91:   }else if( sqlite3_strnicmp(argv[2],\"create \",7)==0 ){",
          "",
          "[Added Lines]",
          "79:   assert( argc==5 );",
          "85:     corruptSchema(pData, argv[1], 0);",
          "91:   if( argv[3]==0 ){",
          "92:     corruptSchema(pData, argv[1], 0);",
          "93:   }else if( sqlite3_strnicmp(argv[4],\"create \",7)==0 ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:     assert( db->init.busy );",
          "103:     db->init.iDb = iDb;",
          "105:     db->init.orphanTrigger = 0;",
          "107:     rc = db->errCode;",
          "108:     assert( (rc&0xFF)==(rcp&0xFF) );",
          "109:     db->init.iDb = saved_iDb;",
          "",
          "[Removed Lines]",
          "104:     db->init.newTnum = sqlite3Atoi(argv[1]);",
          "106:     TESTONLY(rcp = ) sqlite3_prepare(db, argv[2], -1, &pStmt, 0);",
          "",
          "[Added Lines]",
          "106:     db->init.newTnum = sqlite3Atoi(argv[3]);",
          "108:     db->init.azInit = argv;",
          "109:     TESTONLY(rcp = ) sqlite3_prepare(db, argv[4], -1, &pStmt, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "116:         if( rc==SQLITE_NOMEM ){",
          "117:           sqlite3OomFault(db);",
          "118:         }else if( rc!=SQLITE_INTERRUPT && (rc&0xFF)!=SQLITE_LOCKED ){",
          "120:         }",
          "121:       }",
          "122:     }",
          "123:     sqlite3_finalize(pStmt);",
          "126:   }else{",
          "",
          "[Removed Lines]",
          "119:           corruptSchema(pData, argv[0], sqlite3_errmsg(db));",
          "124:   }else if( argv[0]==0 || (argv[2]!=0 && argv[2][0]!=0) ){",
          "125:     corruptSchema(pData, argv[0], 0);",
          "",
          "[Added Lines]",
          "122:           corruptSchema(pData, argv[1], sqlite3_errmsg(db));",
          "127:   }else if( argv[1]==0 || (argv[4]!=0 && argv[4][0]!=0) ){",
          "128:     corruptSchema(pData, argv[1], 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "133:     Index *pIndex;",
          "135:     if( pIndex==0",
          "137:      || pIndex->tnum<2",
          "138:      || sqlite3IndexHasDuplicateRootPage(pIndex)",
          "139:     ){",
          "141:     }",
          "142:   }",
          "143:   return 0;",
          "",
          "[Removed Lines]",
          "134:     pIndex = sqlite3FindIndex(db, argv[0], db->aDb[iDb].zDbSName);",
          "136:      || sqlite3GetInt32(argv[1],&pIndex->tnum)==0",
          "140:       corruptSchema(pData, argv[0], pIndex?\"invalid rootpage\":\"orphan index\");",
          "",
          "[Added Lines]",
          "137:     pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);",
          "139:      || sqlite3GetInt32(argv[3],&pIndex->tnum)==0",
          "143:       corruptSchema(pData, argv[1], pIndex?\"invalid rootpage\":\"orphan index\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "158:   int size;",
          "159: #endif",
          "160:   Db *pDb;",
          "162:   int meta[5];",
          "163:   InitData initData;",
          "164:   const char *zMasterName;",
          "",
          "[Removed Lines]",
          "161:   char const *azArg[4];",
          "",
          "[Added Lines]",
          "164:   char const *azArg[6];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "183:                             \"rootpage int,sql text)\";",
          "185:   initData.db = db;",
          "186:   initData.iDb = iDb;",
          "187:   initData.rc = SQLITE_OK;",
          "188:   initData.pzErrMsg = pzErrMsg;",
          "189:   initData.mInitFlags = mFlags;",
          "190:   initData.nInitRow = 0;",
          "192:   if( initData.rc ){",
          "193:     rc = initData.rc;",
          "194:     goto error_out;",
          "",
          "[Removed Lines]",
          "180:   azArg[0] = zMasterName = SCHEMA_TABLE(iDb);",
          "181:   azArg[1] = \"1\";",
          "182:   azArg[2] = \"CREATE TABLE x(type text,name text,tbl_name text,\"",
          "184:   azArg[3] = 0;",
          "191:   sqlite3InitCallback(&initData, 3, (char **)azArg, 0);",
          "",
          "[Added Lines]",
          "183:   azArg[0] = \"table\";",
          "184:   azArg[1] = zMasterName = SCHEMA_TABLE(iDb);",
          "185:   azArg[2] = azArg[1];",
          "186:   azArg[3] = \"1\";",
          "187:   azArg[4] = \"CREATE TABLE x(type text,name text,tbl_name text,\"",
          "189:   azArg[5] = 0;",
          "196:   sqlite3InitCallback(&initData, 5, (char **)azArg, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "314:   {",
          "315:     char *zSql;",
          "316:     zSql = sqlite3MPrintf(db,",
          "318:         db->aDb[iDb].zDbSName, zMasterName);",
          "319: #ifndef SQLITE_OMIT_AUTHORIZATION",
          "320:     {",
          "",
          "[Removed Lines]",
          "317:         \"SELECT name, rootpage, sql FROM \\\"%w\\\".%s ORDER BY rowid\",",
          "",
          "[Added Lines]",
          "322:         \"SELECT*FROM\\\"%w\\\".%s ORDER BY rowid\",",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4268: Expr *sqlite3ExprSkipCollate(Expr*);",
          "4269: int sqlite3CheckCollSeq(Parse *, CollSeq *);",
          "4270: int sqlite3WritableSchema(sqlite3*);",
          "4272: void sqlite3VdbeSetChanges(sqlite3 *, int);",
          "4273: int sqlite3AddInt64(i64*,i64);",
          "4274: int sqlite3SubInt64(i64*,i64);",
          "",
          "[Removed Lines]",
          "4271: int sqlite3CheckObjectName(Parse *, const char *);",
          "",
          "[Added Lines]",
          "4272: int sqlite3CheckObjectName(Parse*, const char*,const char*,const char*);",
          "",
          "---------------"
        ],
        "src/trigger.c||src/trigger.c": [
          "File: src/trigger.c -> src/trigger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "179:   zName = sqlite3NameFromToken(db, pName);",
          "181:     goto trigger_cleanup;",
          "182:   }",
          "183:   assert( sqlite3SchemaMutexHeld(db, iDb, 0) );",
          "",
          "[Removed Lines]",
          "180:   if( !zName || SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){",
          "",
          "[Added Lines]",
          "180:   if( zName==0 ){",
          "181:     assert( db->mallocFailed );",
          "182:     goto trigger_cleanup;",
          "183:   }",
          "184:   if( sqlite3CheckObjectName(pParse, zName, \"trigger\", pTab->zName) ){",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5963:     initData.pzErrMsg = &p->zErrMsg;",
          "5964:     initData.mInitFlags = 0;",
          "5965:     zSql = sqlite3MPrintf(db,",
          "5967:        db->aDb[iDb].zDbSName, zMaster, pOp->p4.z);",
          "5968:     if( zSql==0 ){",
          "5969:       rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Removed Lines]",
          "5966:        \"SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid\",",
          "",
          "[Added Lines]",
          "5966:        \"SELECT*FROM\\\"%w\\\".%s WHERE %s ORDER BY rowid\",",
          "",
          "---------------"
        ],
        "test/corruptL.test||test/corruptL.test": [
          "File: test/corruptL.test -> test/corruptL.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "228: }]} {}",
          "230: do_execsql_test 2.1 {",
          "231:   INSERT INTO t1(b) VALUES(X'a0fee3669f9fddefc5cba913e4225d4b6ce2b04f26b87fad3ee6f9b7d90a1ea62a169bf41e5d32707a6ca5c3d05e4bde05c9d89eaaa8c50e74333d2e9fcd7dfe95528a3a016aac1102d825c5cd70cf99d8a88e0ea7f798d4334386518b7ad359beb168b93aba059a2a3bd93112d65b44c12b9904ea786b204d80531cdf0504bf9b203dbe927061974caf7b9f30cbc3397b61f802e732012a6663d41c3607d6f1c0dbcfd489adac05ca500c0b04439d894cd93a840159225ef73b627e178b9f84b3ffe66cf22a963a8368813ff7961fc47f573211ccec95e0220dcbb3bf429f4a50ba54d7a53784ac51bfef346e6ac8ae0d0e7c3175946e62ba2b');",
          "232: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "231:   PRAGMA writable_schema=ON; -- bypass improved sqlite_master consistency checking",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "377: }]} {}",
          "379: do_catchsql_test 4.1 {",
          "380:   INSERT INTO t3 SELECT * FROM t2;",
          "381: } {1 {database disk image is malformed}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "381:   PRAGMA writable_schema=ON; -- bypass improved sqlite_master consistency checking",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "605: |   3872: 75 65 6e 63 65 04 43 52 45 41 54 45 20 54 41 42   uence.CREATE TAB",
          "606: |   3888: 4c 45 20 73 71 6c 69 74 65 5f 73 65 71 75 65 6e   LE sqlite_sequen",
          "607: |   3904: 63 65 28 6e 61 6d 65 2c 73 65 71 29 81 04 01 07   ce(name,seq)....",
          "609: |   3936: 43 52 45 41 54 45 20 54 41 42 4c 45 20 74 31 28   CREATE TABLE t1(",
          "610: |   3952: 61 20 52 45 41 4c 20 4e 4f 54 20 4e 55 4c 4c 20   a REAL NOT NULL",
          "611: |   3968: 44 45 46 41 55 4c 54 28 32 35 2b 33 32 29 2c 62   DEFAULT(25+32),b",
          "",
          "[Removed Lines]",
          "608: |   3920: 17 11 11 01 81 73 74 61 c2 6c 65 74 31 74 31 02   .....sta.let1t1.",
          "",
          "[Added Lines]",
          "610: |   3920: 17 11 11 01 81 73 74 61 62 6c 65 74 31 74 31 02   .....stablet1t1.",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "837: do_catchsql_test 8.1 {",
          "838:   INSERT INTO t3 SELECT * FROM t2;",
          "839: } {1 {database disk image is malformed}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "840:   PRAGMA writable_schema=ON; -- bypass improved sqlite_master consistency checking",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1004: }]} {}",
          "1006: do_catchsql_test 10.1 {",
          "1007:   SELECT * FROM t1 WHERE a<='2019-05-09' ORDER BY a DESC;",
          "1008: } {1 {database disk image is malformed}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1010:   PRAGMA writable_schema=ON; -- bypass improved sqlite_master consistency checking",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1057: }]} {}",
          "1059: do_catchsql_test 11.1 {",
          "1060:   DELETE FROM t3 WHERE x IN (SELECT x FROM t4);",
          "1061: } {1 {database disk image is malformed}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1064:   PRAGMA writable_schema=ON; -- bypass improved sqlite_master consistency checking",
          "",
          "---------------"
        ],
        "test/corruptM.test||test/corruptM.test": [
          "File: test/corruptM.test -> test/corruptM.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019-08-12",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # Check to ensure that the type, name, and tbl_name fields of the",
          "13: # sqlite_master table are validated and errors are reported if they",
          "14: # are inconsistent with the sql.",
          "15: #",
          "17: set testdir [file dirname $argv0]",
          "18: source $testdir/tester.tcl",
          "19: set testprefix corruptM",
          "21: # These tests deal with corrupt database files",
          "22: #",
          "23: database_may_be_corrupt",
          "25: db close",
          "26: forcedelete test.db",
          "27: sqlite3 db test.db",
          "28: do_execsql_test corruptM-100 {",
          "29:   CREATE TABLE t1(a,b,c);",
          "30:   INSERT INTO t1 VALUES(111,222,333);",
          "31:   CREATE INDEX i1 ON t1(b);",
          "32:   CREATE VIEW v2 AS SELECT 15,22;",
          "33:   CREATE TRIGGER r1 AFTER INSERT ON t1 BEGIN SELECT 5; END;",
          "34:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "35: } {table t1 t1 | index i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "36: do_execsql_test corruptM-101 {",
          "37:   PRAGMA writable_schema=on;",
          "38:   UPDATE sqlite_master SET tbl_name=NULL WHERE name='t1';",
          "39:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "40: } {table t1 {} | index i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "41: sqlite3 db2 test.db",
          "42: do_test corruptM-102 {",
          "43:   catchsql {",
          "44:     PRAGMA quick_check;",
          "45:   } db2",
          "46: } {1 {malformed database schema (t1)}}",
          "47: db2 close",
          "49: do_execsql_test corruptM-110 {",
          "50:   UPDATE sqlite_master SET tbl_name='tx' WHERE name='t1';",
          "51:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "52: } {table t1 tx | index i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "53: sqlite3 db2 test.db",
          "54: do_test corruptM-111 {",
          "55:   catchsql {",
          "56:     PRAGMA quick_check;",
          "57:   } db2",
          "58: } {1 {malformed database schema (t1)}}",
          "59: db2 close",
          "60: do_execsql_test corruptM-112 {",
          "61:   UPDATE sqlite_master SET tbl_name='t1', type='tabl' WHERE name='t1';",
          "62:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "63: } {tabl t1 t1 | index i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "64: sqlite3 db2 test.db",
          "65: do_test corruptM-113 {",
          "66:   catchsql {",
          "67:     PRAGMA quick_check;",
          "68:   } db2",
          "69: } {1 {malformed database schema (t1)}}",
          "70: db2 close",
          "71: do_execsql_test corruptM-114 {",
          "72:   UPDATE sqlite_master SET tbl_name='t9',type='table',name='t9'WHERE name='t1';",
          "73:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "74: } {table t9 t9 | index i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "75: sqlite3 db2 test.db",
          "76: do_test corruptM-114 {",
          "77:   catchsql {",
          "78:     PRAGMA quick_check;",
          "79:   } db2",
          "80: } {1 {malformed database schema (t9)}}",
          "81: db2 close",
          "83: do_execsql_test corruptM-120 {",
          "84:   UPDATE sqlite_master SET name='t1',tbl_name='T1' WHERE name='t9';",
          "85:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "86: } {table t1 T1 | index i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "87: sqlite3 db2 test.db",
          "88: do_test corruptM-121 {",
          "89:   catchsql {",
          "90:     PRAGMA quick_check;",
          "91:     SELECT * FROM t1, v2;",
          "92:   } db2",
          "93: } {0 {ok 111 222 333 15 22}}",
          "94: db2 close",
          "96: do_execsql_test corruptM-130 {",
          "97:   UPDATE sqlite_master SET type='view' WHERE name='t1';",
          "98:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "99: } {view t1 T1 | index i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "100: sqlite3 db2 test.db",
          "101: do_test corruptM-131 {",
          "102:   catchsql {",
          "103:     PRAGMA quick_check;",
          "104:     SELECT * FROM t1, v2;",
          "105:   } db2",
          "106: } {1 {malformed database schema (t1)}}",
          "107: db2 close",
          "109: do_execsql_test corruptM-140 {",
          "110:   UPDATE sqlite_master SET type='table', tbl_name='t1' WHERE name='t1';",
          "111:   UPDATE sqlite_master SET tbl_name='tx' WHERE name='i1';",
          "112:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "113: } {table t1 t1 | index i1 tx | view v2 v2 | trigger r1 t1 |}",
          "114: sqlite3 db2 test.db",
          "115: do_test corruptM-141 {",
          "116:   catchsql {",
          "117:     PRAGMA quick_check;",
          "118:     SELECT * FROM t1, v2;",
          "119:   } db2",
          "120: } {1 {malformed database schema (i1)}}",
          "121: db2 close",
          "123: do_execsql_test corruptM-150 {",
          "124:   UPDATE sqlite_master SET type='table', tbl_name='t1' WHERE name='i1';",
          "125:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "126: } {table t1 t1 | table i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "127: sqlite3 db2 test.db",
          "128: do_test corruptM-151 {",
          "129:   catchsql {",
          "130:     PRAGMA quick_check;",
          "131:     SELECT * FROM t1, v2;",
          "132:   } db2",
          "133: } {1 {malformed database schema (i1)}}",
          "134: db2 close",
          "136: do_execsql_test corruptM-160 {",
          "137:   UPDATE sqlite_master SET type='view', tbl_name='t1' WHERE name='i1';",
          "138:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "139: } {table t1 t1 | view i1 t1 | view v2 v2 | trigger r1 t1 |}",
          "140: sqlite3 db2 test.db",
          "141: do_test corruptM-161 {",
          "142:   catchsql {",
          "143:     PRAGMA quick_check;",
          "144:     SELECT * FROM t1, v2;",
          "145:   } db2",
          "146: } {1 {malformed database schema (i1)}}",
          "147: db2 close",
          "149: do_execsql_test corruptM-170 {",
          "150:   UPDATE sqlite_master SET type='index', tbl_name='t1' WHERE name='i1';",
          "151:   UPDATE sqlite_master SET type='table', tbl_name='v2' WHERE name='v2';",
          "152:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "153: } {table t1 t1 | index i1 t1 | table v2 v2 | trigger r1 t1 |}",
          "154: sqlite3 db2 test.db",
          "155: do_test corruptM-171 {",
          "156:   catchsql {",
          "157:     PRAGMA quick_check;",
          "158:     SELECT * FROM t1, v2;",
          "159:   } db2",
          "160: } {1 {malformed database schema (v2)}}",
          "161: db2 close",
          "163: do_execsql_test corruptM-180 {",
          "164:   UPDATE sqlite_master SET type='view',name='v3',tbl_name='v3' WHERE name='v2';",
          "165:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "166: } {table t1 t1 | index i1 t1 | view v3 v3 | trigger r1 t1 |}",
          "167: sqlite3 db2 test.db",
          "168: do_test corruptM-181 {",
          "169:   catchsql {",
          "170:     PRAGMA quick_check;",
          "171:     SELECT * FROM t1, v2;",
          "172:   } db2",
          "173: } {1 {malformed database schema (v3)}}",
          "174: db2 close",
          "176: do_execsql_test corruptM-190 {",
          "177:   UPDATE sqlite_master SET type='view',name='v2',tbl_name='v2' WHERE name='v3';",
          "178:   UPDATE sqlite_master SET type='view' WHERE name='r1';",
          "179:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "180: } {table t1 t1 | index i1 t1 | view v2 v2 | view r1 t1 |}",
          "181: sqlite3 db2 test.db",
          "182: do_test corruptM-191 {",
          "183:   catchsql {",
          "184:     PRAGMA quick_check;",
          "185:     SELECT * FROM t1, v2;",
          "186:   } db2",
          "187: } {1 {malformed database schema (r1)}}",
          "188: db2 close",
          "189: do_execsql_test corruptM-192 {",
          "190:   UPDATE sqlite_master SET type='trigger',tbl_name='v2' WHERE name='r1';",
          "191:   SELECT type, name, tbl_name, '|' FROM sqlite_master;",
          "192: } {table t1 t1 | index i1 t1 | view v2 v2 | trigger r1 v2 |}",
          "193: sqlite3 db2 test.db",
          "194: do_test corruptM-193 {",
          "195:   catchsql {",
          "196:     PRAGMA quick_check;",
          "197:     SELECT * FROM t1, v2;",
          "198:   } db2",
          "199: } {1 {malformed database schema (r1)}}",
          "200: db2 close",
          "202: finish_test",
          "",
          "---------------"
        ],
        "test/dbfuzz001.test||test/dbfuzz001.test": [
          "File: test/dbfuzz001.test -> test/dbfuzz001.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "305: |    384: 32 28 63 2c 64 29 28 05 06 17 11 11 01 3d 74 61   2(c,d)(......=ta",
          "306: |    400: 62 6c 65 74 33 74 33 07 43 52 45 41 54 45 20 54   blet3t3.CREATE T",
          "307: |    416: 41 42 4c 45 20 74 33 28 63 2c 78 2c 65 2c 66 29   ABLE t3(c,x,e,f)",
          "309: |    448: 32 32 43 52 45 41 54 45 20 54 41 42 4c 45 20 74   22CREATE TABLE t",
          "310: |    464: 32 28 63 2c 64 2c 65 2c 66 29 24 01 06 17 11 11   2(c,d,e,f)$.....",
          "311: |    480: 01 35 74 61 62 6c 65 74 31 74 31 02 43 52 45 41   .5tablet1t1.CREA",
          "",
          "[Removed Lines]",
          "308: |    432: 28 02 06 17 11 11 01 3d 74 61 74 65 6c 03 62 74   (......=tatel.bt",
          "",
          "[Added Lines]",
          "308: |    432: 28 02 06 17 11 11 01 3d 74 61 62 6c 65 74 32 74   (......=tablet2t",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "15750a26fa7127af7b1aa3e3a2046f5379eaca43",
      "candidate_info": {
        "commit_hash": "15750a26fa7127af7b1aa3e3a2046f5379eaca43",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/15750a26fa7127af7b1aa3e3a2046f5379eaca43",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "src/whereInt.h",
          "src/wherecode.c",
          "test/nulls1.test"
        ],
        "message": "Add support for using indexes for some ORDER BY clauses that use non-default NULL handling. Still some problems on this branch.\n\nFossilOrigin-Name: 81069d7196857e909c94195d67388f71bc9f832eafd9156d8c5cdddb63513b4a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "src/whereInt.h||src/whereInt.h",
          "src/wherecode.c||src/wherecode.c",
          "test/nulls1.test||test/nulls1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 07babb0f897fc8c9cb5b30481899c32fdd743f3f3ca508d8d957826252107dd5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3799:         if( pIndex ){",
          "3800:           iColumn = pIndex->aiColumn[j];",
          "3802:           if( iColumn==pIndex->pTable->iPKey ) iColumn = XN_ROWID;",
          "3803:         }else{",
          "3804:           iColumn = XN_ROWID;",
          "",
          "[Removed Lines]",
          "3801:           revIdx = pIndex->aSortOrder[j];",
          "",
          "[Added Lines]",
          "3801:           revIdx = pIndex->aSortOrder[j] & KEYINFO_ORDER_DESC;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3836:               continue;",
          "3837:             }",
          "3838:           }",
          "3840:           if( iColumn!=XN_ROWID ){",
          "3841:             pColl = sqlite3ExprNNCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);",
          "3842:             if( sqlite3StrICmp(pColl->zName, pIndex->azColl[j])!=0 ) continue;",
          "",
          "[Removed Lines]",
          "3839:           if( pOrderBy->a[i].sortFlags & KEYINFO_ORDER_BIGNULL ) continue;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3850:         if( isMatch && (wctrlFlags & WHERE_GROUPBY)==0 ){",
          "3854:           if( revSet ){",
          "3856:           }else{",
          "3858:             if( rev ) *pRevMask |= MASKBIT(iLoop);",
          "3859:             revSet = 1;",
          "3860:           }",
          "3861:         }",
          "3862:         if( isMatch ){",
          "3863:           if( iColumn==XN_ROWID ){",
          "3864:             testcase( distinctColumns==0 );",
          "3865:             distinctColumns = 1;",
          "3866:           }",
          "3867:           obSat |= MASKBIT(i);",
          "3871:         }else{",
          "3873:           if( j==0 || j<nKeyCol ){",
          "",
          "[Removed Lines]",
          "3853:           assert( (pOrderBy->a[i].sortFlags & KEYINFO_ORDER_BIGNULL)==0 );",
          "3855:             if( (rev ^ revIdx)!=pOrderBy->a[i].sortFlags ) isMatch = 0;",
          "3857:             rev = revIdx ^ pOrderBy->a[i].sortFlags;",
          "3868:           if( (wctrlFlags & WHERE_ORDERBY_MIN) && j==pLoop->u.btree.nEq ){",
          "3869:             pLoop->wsFlags |= WHERE_MIN_ORDERED;",
          "3870:           }",
          "",
          "[Added Lines]",
          "3853:             if( (rev ^ revIdx)!=(pOrderBy->a[i].sortFlags&KEYINFO_ORDER_DESC) ){",
          "3854:               isMatch = 0;",
          "3855:             }",
          "3857:             rev = revIdx ^ (pOrderBy->a[i].sortFlags & KEYINFO_ORDER_DESC);",
          "3862:         if( isMatch && (pOrderBy->a[i].sortFlags & KEYINFO_ORDER_BIGNULL) ){",
          "3863:           if( j==pLoop->u.btree.nEq ){",
          "3864:             pLoop->wsFlags |= WHERE_BIGNULL_SORT;",
          "3865:           }else{",
          "3866:             isMatch = 0;",
          "3867:           }",
          "3868:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5061:         sqlite3VdbeSetP4KeyInfo(pParse, pIx);",
          "5062:         if( (pLoop->wsFlags & WHERE_CONSTRAINT)!=0",
          "5063:          && (pLoop->wsFlags & (WHERE_COLUMN_RANGE|WHERE_SKIPSCAN))==0",
          "5064:          && (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0",
          "5065:          && pWInfo->eDistinct!=WHERE_DISTINCT_ORDERED",
          "5066:         ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5068:          && (pLoop->wsFlags & WHERE_BIGNULL_SORT)==0",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5202:       VdbeCoverageIf(v, pLevel->op==OP_Next);",
          "5203:       VdbeCoverageIf(v, pLevel->op==OP_Prev);",
          "5204:       VdbeCoverageIf(v, pLevel->op==OP_VNext);",
          "5205: #ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT",
          "5206:       if( addrSeek ) sqlite3VdbeJumpHere(v, addrSeek);",
          "5207: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5210:       if( pLevel->regBignull ){",
          "5211:         sqlite3VdbeResolveLabel(v, pLevel->addrBignull);",
          "5212:         addr = sqlite3VdbeAddOp1(v, OP_If, pLevel->regBignull);",
          "5213:         sqlite3VdbeAddOp2(v, OP_Integer, 1, pLevel->regBignull);",
          "5214:         sqlite3VdbeAddOp2(v, OP_Goto, 0, pLevel->p2-1);",
          "5215:         sqlite3VdbeChangeP5(v, pLevel->p5);",
          "5216:         VdbeCoverage(v);",
          "5217:         VdbeCoverageIf(v, pLevel->op==OP_Next);",
          "5218:         VdbeCoverageIf(v, pLevel->op==OP_Prev);",
          "5219:         sqlite3VdbeJumpHere(v, addr);",
          "5220:       }",
          "",
          "---------------"
        ],
        "src/whereInt.h||src/whereInt.h": [
          "File: src/whereInt.h -> src/whereInt.h"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1554:     pIdx = pLoop->u.btree.pIndex;",
          "1555:     iIdxCur = pLevel->iIdxCur;",
          "1556:     assert( nEq>=pLoop->nSkip );",
          "",
          "[Removed Lines]",
          "1566:     assert( (pWInfo->pOrderBy!=0 && pWInfo->pOrderBy->nExpr==1)",
          "1567:          || (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0 );",
          "1568:     if( pLoop->wsFlags & WHERE_MIN_ORDERED ){",
          "1569:       assert( (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN) );",
          "1570:       assert( pWInfo->nOBSat );",
          "1571:       assert( pIdx->nColumn>nEq );",
          "1572:       assert( pLoop->nSkip==0 );",
          "1573:       bSeekPastNull = 1;",
          "1574:       nExtraReg = 1;",
          "1575:     }",
          "",
          "[Added Lines]",
          "1552:     int regBignull = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1614:     }",
          "1615:     assert( pRangeEnd==0 || (pRangeEnd->wtFlags & TERM_VNULL)==0 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1605:     addrNxt = pLevel->addrNxt;",
          "1606:     if( (pLoop->wsFlags & (WHERE_TOP_LIMIT|WHERE_BTM_LIMIT))==0",
          "1607:      && (pLoop->wsFlags & WHERE_BIGNULL_SORT)!=0",
          "1608:     ){",
          "1609:       assert( bSeekPastNull==0 && nExtraReg==0 && nBtm==0 && nTop==0 );",
          "1610:       assert( pRangeEnd==0 && pRangeStart==0 );",
          "1611:       assert( pLoop->nSkip==0 );",
          "1612:       nExtraReg = 1;",
          "1613:       bSeekPastNull = 1;",
          "1614:       pLevel->regBignull = regBignull = ++pParse->nMem;",
          "1615:       addrNxt = pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);",
          "1616:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1636:     if( zStartAff && nTop ){",
          "1637:       zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);",
          "1638:     }",
          "1641:     testcase( pRangeStart && (pRangeStart->eOperator & WO_LE)!=0 );",
          "1642:     testcase( pRangeStart && (pRangeStart->eOperator & WO_GE)!=0 );",
          "",
          "[Removed Lines]",
          "1639:     addrNxt = pLevel->addrNxt;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1674:       nConstraint++;",
          "1675:       startEq = 0;",
          "1676:       start_constraints = 1;",
          "1677:     }",
          "1678:     codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);",
          "1679:     if( pLoop->nSkip>0 && nConstraint==pLoop->nSkip ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1677:     }else if( regBignull ){",
          "1678:       sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);",
          "1679:       start_constraints = 1;",
          "1680:       nConstraint++;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1684:       if( pLoop->wsFlags & WHERE_IN_EARLYOUT ){",
          "1685:         sqlite3VdbeAddOp1(v, OP_SeekHit, iIdxCur);",
          "1686:       }",
          "1687:       op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];",
          "1688:       assert( op!=0 );",
          "1689:       sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1691:       if( regBignull ){",
          "1692:         sqlite3VdbeAddOp2(v, OP_Integer, 0, regBignull);",
          "1693:       }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1695:       VdbeCoverageIf(v, op==OP_SeekLE);  testcase( op==OP_SeekLE );",
          "1696:       VdbeCoverageIf(v, op==OP_SeekLT);  testcase( op==OP_SeekLT );",
          "1707:         sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+2);",
          "1715:       }",
          "1716:     }",
          "",
          "[Removed Lines]",
          "1698:       if( bSeekPastNull && (pLoop->wsFlags & WHERE_TOP_LIMIT)==0 ){",
          "1704:         assert( startEq==0 && (op==OP_SeekGT || op==OP_SeekLT) );",
          "1705:         assert( (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)!=0 && pWInfo->nOBSat>0 );",
          "1706:         sqlite3VdbeChangeP2(v, -1, sqlite3VdbeCurrentAddr(v)+1);",
          "1709:         op = aStartOp[(start_constraints<<2) + (1<<1) + bRev];",
          "1710:         assert( op==OP_SeekGE || op==OP_SeekLE );",
          "1711:         sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);",
          "1712:         VdbeCoverage(v);",
          "1713:         VdbeCoverageIf(v, op==OP_SeekGE);  testcase( op==OP_SeekGE );",
          "1714:         VdbeCoverageIf(v, op==OP_SeekLE);  testcase( op==OP_SeekLE );",
          "",
          "[Added Lines]",
          "1706:       if( regBignull ){",
          "1708:         if( bStopAtNull ){",
          "1709:           start_constraints = (nConstraint>1);",
          "1710:           op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];",
          "1711:           sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint-1);",
          "1712:         }else{",
          "1713:           op = aStartOp[(start_constraints<<2) + ((!startEq)<<1) + bRev];",
          "1714:           sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);",
          "1715:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1744:         endEq = 1;",
          "1745:       }",
          "1746:     }else if( bStopAtNull ){",
          "1749:       nConstraint++;",
          "1750:     }",
          "1751:     sqlite3DbFree(db, zStartAff);",
          "",
          "[Removed Lines]",
          "1747:       sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);",
          "1748:       endEq = 0;",
          "",
          "[Added Lines]",
          "1748:       if( regBignull==0 ){",
          "1749:         sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);",
          "1750:         endEq = 0;",
          "1751:       }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1758:     if( nConstraint ){",
          "1759:       op = aEndOp[bRev*2 + endEq];",
          "1760:       sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);",
          "1761:       testcase( op==OP_IdxGT );  VdbeCoverageIf(v, op==OP_IdxGT );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1762:       if( regBignull ){",
          "1763:         sqlite3VdbeAddOp2(v, OP_If, regBignull, sqlite3VdbeCurrentAddr(v)+3);",
          "1764:       }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1763:       testcase( op==OP_IdxLT );  VdbeCoverageIf(v, op==OP_IdxLT );",
          "1764:       testcase( op==OP_IdxLE );  VdbeCoverageIf(v, op==OP_IdxLE );",
          "1765:     }",
          "1767:     if( pLoop->wsFlags & WHERE_IN_EARLYOUT ){",
          "1768:       sqlite3VdbeAddOp2(v, OP_SeekHit, iIdxCur, 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1772:     if( regBignull ){",
          "1773:       sqlite3VdbeAddOp2(v, OP_IfNot, regBignull, sqlite3VdbeCurrentAddr(v)+2);",
          "1774:       if( bStopAtNull ){",
          "1775:         op = aEndOp[bRev*2 + 0];",
          "1776:         sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);",
          "1777:       }else{",
          "1778:         op = aEndOp[bRev*2 + endEq];",
          "1779:         sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint+1);",
          "1780:       }",
          "1781:     }",
          "",
          "---------------"
        ],
        "test/nulls1.test||test/nulls1.test": [
          "File: test/nulls1.test -> test/nulls1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: # This file implements regression tests for SQLite library.",
          "12: #",
          "18: set testdir [file dirname $argv0]",
          "19: source $testdir/tester.tcl",
          "20: set testprefix nulls1",
          "22: do_execsql_test 1.0 {",
          "23:   DROP TABLE IF EXISTS t3;",
          "24:   CREATE TABLE t3(a INTEGER);",
          "25:   INSERT INTO t3 VALUES(NULL), (10), (30), (20), (NULL);",
          "26: } {}",
          "29:   foreach {tn limit} {",
          "30:     1 \"\"",
          "31:     2 \"LIMIT 10\"",
          "",
          "[Removed Lines]",
          "14: ####################################################",
          "15: # DO NOT EDIT! THIS FILE IS AUTOMATICALLY GENERATED!",
          "16: ####################################################",
          "28: for {set a 0} {$a < 2} {incr a} {",
          "",
          "[Added Lines]",
          "18: if 1 {",
          "26: for {set a 0} {$a < 3} {incr a} {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:     \" {30   20   10   {}   {}}",
          "48:   }",
          "51: }",
          "53: finish_test",
          "",
          "[Removed Lines]",
          "50:   catchsql { CREATE INDEX i1 ON t3(a) }",
          "",
          "[Added Lines]",
          "48:   switch $a {",
          "49:     0 {",
          "50:       execsql { CREATE INDEX i1 ON t3(a) }",
          "51:     }",
          "52:     1 {",
          "53:       execsql { DROP INDEX i1 ; CREATE INDEX i1 ON t3(a DESC) }",
          "54:     }",
          "55:   }",
          "56: }",
          "58: }",
          "60: #-------------------------------------------------------------------------",
          "61: reset_db",
          "62: do_execsql_test 2.0 {",
          "63:   CREATE TABLE t2(a, b, c);",
          "64:   CREATE INDEX i2 ON t2(a, b);",
          "65:   INSERT INTO t2 VALUES(1, 1, 1);",
          "66:   INSERT INTO t2 VALUES(1, NULL, 2);",
          "67:   INSERT INTO t2 VALUES(1, NULL, 3);",
          "68:   INSERT INTO t2 VALUES(1, 4, 4);",
          "69: }",
          "71: do_execsql_test 2.1 {",
          "72:   SELECT * FROM t2 WHERE a=1 ORDER BY b NULLS LAST",
          "73: } {",
          "74:   1 1 1    1 4 4   1 {} 2   1 {} 3",
          "77: do_execsql_test 2.2 {",
          "78:   SELECT * FROM t2 WHERE a=1 ORDER BY b DESC NULLS FIRST",
          "79: } {",
          "80:   1 {} 3",
          "81:   1 {} 2",
          "82:   1 4 4",
          "83:   1 1 1",
          "84: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4413265d4eb6eab7dc6c8fde05738fb68990d901",
      "candidate_info": {
        "commit_hash": "4413265d4eb6eab7dc6c8fde05738fb68990d901",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4413265d4eb6eab7dc6c8fde05738fb68990d901",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/speedtest1.c"
        ],
        "message": "Add new cases to speedtest1 for measuring performance of binary to/from decimal conversions of floating point values.\n\nFossilOrigin-Name: b84e7057c05338347b4267f7ccc1d7b9b6d4e9a941ce8b76bf2c27c26772000c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/speedtest1.c||test/speedtest1.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ed250b4e18ea042d681bbe8d7ed00895564f4525c22928a003a84585b4756ec3",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/speedtest1.c||test/speedtest1.c": [
          "File: test/speedtest1.c -> test/speedtest1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1191:     speedtest1_run();",
          "1192:   }",
          "1193:   speedtest1_end_test();",
          "1194: }",
          "1196: #ifdef SQLITE_ENABLE_RTREE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1195:   n = g.szTest*5000;",
          "1196:   speedtest1_begin_test(140, \"%d calls to round()\", n);",
          "1197:   speedtest1_exec(\"SELECT sum(round(a,2)+round(b,4)) FROM t1;\");",
          "1198:   speedtest1_end_test();",
          "1201:   speedtest1_begin_test(150, \"%d printf() calls\", n*4);",
          "1202:   speedtest1_exec(",
          "1203:     \"WITH c(fmt) AS (VALUES('%%g'),('%%e'),('%%!g'),('%%.20f'))\"",
          "1204:     \"SELECT sum(printf(fmt,a)) FROM t1, c\"",
          "1205:   );",
          "1206:   speedtest1_end_test();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8d40673c8458f9b26a9cb72b8ed9f5a10fe26e6f",
      "candidate_info": {
        "commit_hash": "8d40673c8458f9b26a9cb72b8ed9f5a10fe26e6f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/8d40673c8458f9b26a9cb72b8ed9f5a10fe26e6f",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/prepare.c",
          "src/sqliteInt.h"
        ],
        "message": "Detect if two indexes of the same table share a common rootpage while parsing the schema, and throw an error immediately.\n\nFossilOrigin-Name: f21c6f1343edc4ba68f9f8e68caac34da0d1c651526ecaf61c0e2d66593a555e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/prepare.c||src/prepare.c",
          "src/sqliteInt.h||src/sqliteInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: dc794d8f518ed46536928a77a560d46e4f9365c30a00cd108f000d8556a66c00",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3497:       db->mDbFlags |= DBFLAG_SchemaChange;",
          "3498:       if( pTblName!=0 ){",
          "3499:         pIndex->tnum = db->init.newTnum;",
          "3500:       }",
          "3501:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3500:         if( sqlite3IndexHasDuplicateRootPage(pIndex) ){",
          "3501:           sqlite3ErrorMsg(pParse, \"invalid root page\");",
          "3502:           pParse->rc = SQLITE_CORRUPT_BKPT;",
          "3503:           goto exit_create_index;",
          "3504:         }",
          "",
          "---------------"
        ],
        "src/prepare.c||src/prepare.c": [
          "File: src/prepare.c -> src/prepare.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:   }",
          "45: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: int sqlite3IndexHasDuplicateRootPage(Index *pIndex){",
          "53:   Index *p;",
          "54:   for(p=pIndex->pTable->pIndex; p; p=p->pNext){",
          "55:     if( p->tnum==pIndex->tnum && p!=pIndex ) return 1;",
          "56:   }",
          "57:   return 0;",
          "58: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122:     if( pIndex==0",
          "123:      || sqlite3GetInt32(argv[1],&pIndex->tnum)==0",
          "124:      || pIndex->tnum<2",
          "125:     ){",
          "126:       corruptSchema(pData, argv[0], pIndex?\"invalid rootpage\":\"orphan index\");",
          "127:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:      || sqlite3IndexHasDuplicateRootPage(pIndex)",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3844: void sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);",
          "3845: void sqlite3ExprListDelete(sqlite3*, ExprList*);",
          "3846: u32 sqlite3ExprListFlags(const ExprList*);",
          "3847: int sqlite3Init(sqlite3*, char**);",
          "3848: int sqlite3InitCallback(void*, int, char**, char**);",
          "3849: int sqlite3InitOne(sqlite3*, int, char**, u32);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3847: int sqlite3IndexHasDuplicateRootPage(Index*);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0167ef202b2279af622956a4a1a073531759c216",
      "candidate_info": {
        "commit_hash": "0167ef202b2279af622956a4a1a073531759c216",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/0167ef202b2279af622956a4a1a073531759c216",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c"
        ],
        "message": "Fix an obsolete comment that defines the meaning of one of the parameters to the sqlite3FindInIndex() subroutine.  No changes to code.\n\nFossilOrigin-Name: 0c946f0846b2835f8facca806a4d4ecc2b2e97343de245a0d91716d998b2a829",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 0658c16e311393c8a347b1bd41fa5dbfd2e184aa75d84c011aa8dbac79b632e9",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-3153",
  "cve_desc": "The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5 does not ensure that calls have two different futex addresses, which allows local users to gain privileges via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification.",
  "repo": "torvalds/linux",
  "patch_hash": "13fbca4c6ecd96ec1a1cfa2e4f2ce191fe928a5e",
  "patch_info": {
    "commit_hash": "13fbca4c6ecd96ec1a1cfa2e4f2ce191fe928a5e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/13fbca4c6ecd96ec1a1cfa2e4f2ce191fe928a5e",
    "files": [
      "kernel/futex.c"
    ],
    "message": "futex: Always cleanup owner tid in unlock_pi\n\nIf the owner died bit is set at futex_unlock_pi, we currently do not\ncleanup the user space futex.  So the owner TID of the current owner\n(the unlocker) persists.  That's observable inconsistant state,\nespecially when the ownership of the pi state got transferred.\n\nClean it up unconditionally.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Kees Cook <keescook@chromium.org>\nCc: Will Drewry <wad@chromium.org>\nCc: Darren Hart <dvhart@linux.intel.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "kernel/futex.c||kernel/futex.c"
    ]
  },
  "patch_diff": {
    "kernel/futex.c||kernel/futex.c": [
      "File: kernel/futex.c -> kernel/futex.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1052:  struct task_struct *new_owner;",
      "1053:  struct futex_pi_state *pi_state = this->pi_state;",
      "1054:  u32 uninitialized_var(curval), newval;",
      "1056:  if (!pi_state)",
      "1057:   return -EINVAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1055:  int ret = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1075:   new_owner = this->task;",
      "1095:  }",
      "1097:  raw_spin_lock_irq(&pi_state->owner->pi_lock);",
      "",
      "[Removed Lines]",
      "1082:  if (!(uval & FUTEX_OWNER_DIED)) {",
      "1083:   int ret = 0;",
      "1085:   newval = FUTEX_WAITERS | task_pid_vnr(new_owner);",
      "1087:   if (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))",
      "1088:    ret = -EFAULT;",
      "1089:   else if (curval != uval)",
      "1090:    ret = -EINVAL;",
      "1091:   if (ret) {",
      "1092:    raw_spin_unlock(&pi_state->pi_mutex.wait_lock);",
      "1093:    return ret;",
      "1094:   }",
      "",
      "[Added Lines]",
      "1083:  newval = FUTEX_WAITERS | task_pid_vnr(new_owner);",
      "1085:  if (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))",
      "1086:   ret = -EFAULT;",
      "1087:  else if (curval != uval)",
      "1088:   ret = -EINVAL;",
      "1089:  if (ret) {",
      "1090:   raw_spin_unlock(&pi_state->pi_mutex.wait_lock);",
      "1091:   return ret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2357:      cmpxchg_futex_value_locked(&uval, uaddr, vpid, 0))",
      "2358:   goto pi_faulted;",
      "",
      "[Removed Lines]",
      "2356:  if (!(uval & FUTEX_OWNER_DIED) &&",
      "",
      "[Added Lines]",
      "2354:  if (!(uval & ~FUTEX_TID_MASK) &&",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2392: out_unlock:",
      "2393:  spin_unlock(&hb->lock);",
      "",
      "[Removed Lines]",
      "2386:  if (!(uval & FUTEX_OWNER_DIED)) {",
      "2387:   ret = unlock_futex_pi(uaddr, uval);",
      "2388:   if (ret == -EFAULT)",
      "2389:    goto pi_faulted;",
      "2390:  }",
      "",
      "[Added Lines]",
      "2384:  ret = unlock_futex_pi(uaddr, uval);",
      "2385:  if (ret == -EFAULT)",
      "2386:   goto pi_faulted;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ccf9e6a80d9e1b9df69c98e6b9745cf49869ee15",
      "candidate_info": {
        "commit_hash": "ccf9e6a80d9e1b9df69c98e6b9745cf49869ee15",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ccf9e6a80d9e1b9df69c98e6b9745cf49869ee15",
        "files": [
          "kernel/futex.c"
        ],
        "message": "futex: Make unlock_pi more robust\n\nThe kernel tries to atomically unlock the futex without checking\nwhether there is kernel state associated to the futex.\n\nSo if user space manipulated the user space value, this will leave\nkernel internal state around associated to the owner task. \n\nFor robustness sake, lookup first whether there are waiters on the\nfutex. If there are waiters, wake the top priority waiter with all the\nproper sanity checks applied.\n\nIf there are no waiters, do the atomic release. We do not have to\npreserve the waiters bit in this case, because a potentially incoming\nwaiter is blocked on the hb->lock and will acquire the futex\natomically. We neither have to preserve the owner died bit. The caller\nis the owner and it was supposed to cleanup the mess.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Darren Hart <darren@dvhart.com>\nCc: Davidlohr Bueso <davidlohr@hp.com>\nCc: Kees Cook <kees@outflux.net>\nCc: wad@chromium.org\nLink: http://lkml.kernel.org/r/20140611204237.016987332@linutronix.de\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>",
        "before_after_code_files": [
          "kernel/futex.c||kernel/futex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/futex.c||kernel/futex.c"
          ],
          "candidate": [
            "kernel/futex.c||kernel/futex.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/futex.c||kernel/futex.c": [
          "File: kernel/futex.c -> kernel/futex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1186:  return 0;",
          "1187: }",
          "",
          "[Removed Lines]",
          "1189: static int unlock_futex_pi(u32 __user *uaddr, u32 uval)",
          "1190: {",
          "1191:  u32 uninitialized_var(oldval);",
          "1197:  if (cmpxchg_futex_value_locked(&oldval, uaddr, uval, 0))",
          "1198:   return -EFAULT;",
          "1199:  if (oldval != uval)",
          "1200:   return -EAGAIN;",
          "1202:  return 0;",
          "1203: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2402: static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)",
          "2403: {",
          "2406:  union futex_key key = FUTEX_KEY_INIT;",
          "2408:  int ret;",
          "2410: retry:",
          "",
          "[Removed Lines]",
          "2404:  struct futex_hash_bucket *hb;",
          "2405:  struct futex_q *this, *next;",
          "2407:  u32 uval, vpid = task_pid_vnr(current);",
          "",
          "[Added Lines]",
          "2388:  u32 uninitialized_var(curval), uval, vpid = task_pid_vnr(current);",
          "2390:  struct futex_hash_bucket *hb;",
          "2391:  struct futex_q *match;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2417:   return -EPERM;",
          "2419:  ret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_WRITE);",
          "2423:  hb = hash_futex(&key);",
          "2424:  spin_lock(&hb->lock);",
          "2455:   if (ret == -EFAULT)",
          "2456:    goto pi_faulted;",
          "2457:   goto out_unlock;",
          "2458:  }",
          "2464:   goto pi_faulted;",
          "2466: out_unlock:",
          "2467:  spin_unlock(&hb->lock);",
          "2468:  put_futex_key(&key);",
          "2471:  return ret;",
          "2473: pi_faulted:",
          "",
          "[Removed Lines]",
          "2420:  if (unlikely(ret != 0))",
          "2421:   goto out;",
          "2432:  if (!(uval & ~FUTEX_TID_MASK) &&",
          "2433:      cmpxchg_futex_value_locked(&uval, uaddr, vpid, 0))",
          "2434:   goto pi_faulted;",
          "2439:  if (unlikely(uval == vpid))",
          "2440:   goto out_unlock;",
          "2446:  plist_for_each_entry_safe(this, next, &hb->chain, list) {",
          "2447:   if (!match_futex (&this->key, &key))",
          "2448:    continue;",
          "2449:   ret = wake_futex_pi(uaddr, uval, this);",
          "2462:  ret = unlock_futex_pi(uaddr, uval);",
          "2463:  if (ret == -EFAULT)",
          "2470: out:",
          "",
          "[Added Lines]",
          "2404:  if (ret)",
          "2405:   return ret;",
          "2415:  match = futex_top_waiter(hb, &key);",
          "2416:  if (match) {",
          "2417:   ret = wake_futex_pi(uaddr, uval, match);",
          "2434:  if (cmpxchg_futex_value_locked(&curval, uaddr, uval, 0))",
          "2440:  ret = (curval == uval) ? 0 : -EAGAIN;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
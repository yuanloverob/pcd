{
  "cve_id": "CVE-2020-6018",
  "cve_desc": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles long encrypted messages in function AES_GCM_DecryptContext::Decrypt() when compiled using libsodium, leading to a Stack-Based Buffer Overflow and resulting in a memory corruption and possibly even a remote code execution.",
  "repo": "ValveSoftware/GameNetworkingSockets",
  "patch_hash": "bea84e2844b647532a9b7fbc3a6a8989d66e49e3",
  "patch_info": {
    "commit_hash": "bea84e2844b647532a9b7fbc3a6a8989d66e49e3",
    "repo": "ValveSoftware/GameNetworkingSockets",
    "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/bea84e2844b647532a9b7fbc3a6a8989d66e49e3",
    "files": [
      "src/common/crypto_libsodium.cpp"
    ],
    "message": "Check if output buffer is too small.\n\nIt really seems like libsodium (whose entire purpose is to make crypto\nidiot-proof) making me mess with these details is a flaw in the API design.\n\nAlso, correct Hungarian.",
    "before_after_code_files": [
      "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
    ]
  },
  "patch_diff": {
    "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp": [
      "File: src/common/crypto_libsodium.cpp -> src/common/crypto_libsodium.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "50:  void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
      "51:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
      "52: ) {",
      "55:     crypto_aead_aes256gcm_encrypt_afternm(",
      "57:   static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,",
      "58:   static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,",
      "59:   nullptr,",
      "",
      "[Removed Lines]",
      "53:     unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;",
      "56:   static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,",
      "",
      "[Added Lines]",
      "55:  if ( cbPlaintextData + crypto_aead_aes256gcm_ABYTES > *pcbEncryptedDataAndTag )",
      "56:  {",
      "58:   return false;",
      "59:  }",
      "61:     unsigned long long cbEncryptedDataAndTag_longlong;",
      "63:   static_cast<unsigned char*>( pEncryptedDataAndTag ), &cbEncryptedDataAndTag_longlong,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "72:  void *pPlaintextData, uint32 *pcbPlaintextData,",
      "73:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
      "74: ) {",
      "77:     const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(",
      "79:   nullptr,",
      "80:   static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,",
      "81:   static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,",
      "82:   static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )",
      "83:  );",
      "87:     return nDecryptResult == 0;",
      "88: }",
      "",
      "[Removed Lines]",
      "75:     unsigned long long pcbPlaintextData_longlong;",
      "78:   static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,",
      "",
      "[Added Lines]",
      "83:  if ( cbEncryptedDataAndTag > *pcbPlaintextData + crypto_aead_aes256gcm_ABYTES )",
      "84:  {",
      "86:   return false;",
      "87:  }",
      "89:     unsigned long long cbPlaintextData_longlong;",
      "91:   static_cast<unsigned char*>( pPlaintextData ), &cbPlaintextData_longlong,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d885e72b436b0f76d73c8926de7368c1a2fad173",
      "candidate_info": {
        "commit_hash": "d885e72b436b0f76d73c8926de7368c1a2fad173",
        "repo": "ValveSoftware/GameNetworkingSockets",
        "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/d885e72b436b0f76d73c8926de7368c1a2fad173",
        "files": [
          "src/common/crypto_libsodium.cpp"
        ],
        "message": "Wrap long lines\n\n(No functional change yet.)",
        "before_after_code_files": [
          "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
          ],
          "candidate": [
            "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp": [
          "File: src/common/crypto_libsodium.cpp -> src/common/crypto_libsodium.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:     return true;",
          "45: }",
          "49:     unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;",
          "55:     return true;",
          "56: }",
          "60:     unsigned long long pcbPlaintextData_longlong;",
          "",
          "[Removed Lines]",
          "47: bool AES_GCM_EncryptContext::Encrypt( const void *pPlaintextData, size_t cbPlaintextData, const void *pIV, void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag, const void *pAdditionalAuthenticationData, size_t cbAuthenticationData )",
          "48: {",
          "51:     crypto_aead_aes256gcm_encrypt_afternm( static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong, static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData, static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData, nullptr, static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx ) );",
          "58: bool AES_GCM_DecryptContext::Decrypt( const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag, const void *pIV, void *pPlaintextData, uint32 *pcbPlaintextData, const void *pAdditionalAuthenticationData, size_t cbAuthenticationData )",
          "59: {",
          "62:     const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm( static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong, nullptr, static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag, static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData, static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx ));",
          "",
          "[Added Lines]",
          "47: bool AES_GCM_EncryptContext::Encrypt(",
          "48:  const void *pPlaintextData, size_t cbPlaintextData,",
          "49:  const void *pIV,",
          "50:  void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "51:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "52: ) {",
          "55:     crypto_aead_aes256gcm_encrypt_afternm(",
          "56:   static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,",
          "57:   static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,",
          "58:   static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,",
          "59:   nullptr,",
          "60:   static_cast<const unsigned char*>( pIV ),",
          "61:   static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )",
          "62:  );",
          "69: bool AES_GCM_DecryptContext::Decrypt(",
          "70:  const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "71:  const void *pIV,",
          "72:  void *pPlaintextData, uint32 *pcbPlaintextData,",
          "73:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "74: ) {",
          "77:     const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(",
          "78:   static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,",
          "79:   nullptr,",
          "80:   static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,",
          "81:   static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,",
          "82:   static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )",
          "83:  );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e6a91dae1c03774955aba00008f42e7ddcea877a",
      "candidate_info": {
        "commit_hash": "e6a91dae1c03774955aba00008f42e7ddcea877a",
        "repo": "ValveSoftware/GameNetworkingSockets",
        "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/e6a91dae1c03774955aba00008f42e7ddcea877a",
        "files": [
          "src/common/crypto_25519_libsodium.cpp",
          "src/common/crypto_25519_openssl.cpp",
          "src/common/crypto_bcrypt.cpp",
          "src/common/crypto_libsodium.cpp",
          "src/common/crypto_openssl.cpp",
          "src/common/crypto_textencode.cpp"
        ],
        "message": "crypto: normalize indentation via editorconfig, NFC\n\nSigned-off-by: Steven Noonan <steven@valvesoftware.com>",
        "before_after_code_files": [
          "src/common/crypto_25519_libsodium.cpp||src/common/crypto_25519_libsodium.cpp",
          "src/common/crypto_25519_openssl.cpp||src/common/crypto_25519_openssl.cpp",
          "src/common/crypto_bcrypt.cpp||src/common/crypto_bcrypt.cpp",
          "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp",
          "src/common/crypto_openssl.cpp||src/common/crypto_openssl.cpp",
          "src/common/crypto_textencode.cpp||src/common/crypto_textencode.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
          ],
          "candidate": [
            "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/common/crypto_25519_libsodium.cpp||src/common/crypto_25519_libsodium.cpp": [
          "File: src/common/crypto_25519_libsodium.cpp -> src/common/crypto_25519_libsodium.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: uint32 CEC25519KeyBase::GetRawData( void *pData ) const",
          "21: {",
          "23: }",
          "25: void CEC25519KeyBase::Wipe()",
          "26: {",
          "28: }",
          "30: bool CEC25519KeyBase::SetRawData( const void *pData, size_t cbData )",
          "31: {",
          "33:   return false;",
          "34:  return CCryptoKeyBase_RawBuffer::SetRawData( pData, cbData );",
          "35: }",
          "37: bool CCrypto::PerformKeyExchange( const CECKeyExchangePrivateKey &localPrivateKey, const CECKeyExchangePublicKey &remotePublicKey, SHA256Digest_t *pSharedSecretOut )",
          "38: {",
          "70: }",
          "72: void CECSigningPrivateKey::GenerateSignature( const void *pData, size_t cbData, CryptoSignature_t *pSignatureOut ) const",
          "73: {",
          "75:  {",
          "76:   AssertMsg( false, \"Key not initialized, cannot generate signature\" );",
          "78:   return;",
          "79:  }",
          "96: }",
          "98: bool CECSigningPublicKey::VerifySignature( const void *pData, size_t cbData, const CryptoSignature_t &signature ) const",
          "99: {",
          "101:  {",
          "102:   AssertMsg( false, \"Key not initialized, cannot verify signature\" );",
          "103:   return false;",
          "104:  }",
          "107: }",
          "109: bool CEC25519PrivateKeyBase::CachePublicKey()",
          "110: {",
          "115:   return false;",
          "119:  {",
          "146: }",
          "148: #endif",
          "",
          "[Removed Lines]",
          "22:     return CCryptoKeyBase_RawBuffer::GetRawData( pData );",
          "27:     CCryptoKeyBase_RawBuffer::Wipe();",
          "32:     if ( cbData != 32 )",
          "39:     Assert( localPrivateKey.IsValid() );",
          "40:     Assert( remotePublicKey.IsValid() );",
          "42:     if ( !localPrivateKey.IsValid() || !remotePublicKey.IsValid() )",
          "43:     {",
          "45:         GenerateRandomBlock( *pSharedSecretOut, sizeof( SHA256Digest_t ) );",
          "46:         return false;",
          "47:     }",
          "49:     uint8 bufSharedSecret[32];",
          "50:     uint8 bufLocalPrivate[32];",
          "51:     uint8 bufRemotePublic[32];",
          "53:     localPrivateKey.GetRawData(bufLocalPrivate);",
          "54:     remotePublicKey.GetRawData(bufRemotePublic);",
          "56:     const int nResult = crypto_scalarmult_curve25519(bufSharedSecret, bufLocalPrivate, bufRemotePublic);",
          "58:     SecureZeroMemory( bufLocalPrivate, 32 );",
          "59:     SecureZeroMemory( bufRemotePublic, 32 );",
          "61:     if(nResult != 0)",
          "62:     {",
          "63:         return false;",
          "64:     }",
          "66:     GenerateSHA256Digest( bufSharedSecret, sizeof(bufSharedSecret), pSharedSecretOut );",
          "67:     SecureZeroMemory( bufSharedSecret, 32 );",
          "69:     return true;",
          "74:     if ( !IsValid() )",
          "77:         sodium_memzero( pSignatureOut, sizeof( CryptoSignature_t ) );",
          "85:     uint8 bufSodiumSecret[crypto_sign_ed25519_SECRETKEYBYTES];",
          "87:     Assert( CCryptoKeyBase_RawBuffer::GetRawDataSize() == 32 );",
          "88:     Assert( sizeof(m_publicKey) == 32 );",
          "89:     Assert( crypto_sign_ed25519_SECRETKEYBYTES == 64 );",
          "91:     memcpy(bufSodiumSecret, CCryptoKeyBase_RawBuffer::GetRawDataPtr(), 32 );",
          "92:     memcpy(bufSodiumSecret + 32, m_publicKey, sizeof(m_publicKey));",
          "94:     crypto_sign_ed25519_detached(*pSignatureOut, nullptr, static_cast<const unsigned char*>( pData ), cbData, bufSodiumSecret );",
          "95:     sodium_memzero(bufSodiumSecret, sizeof(bufSodiumSecret) );",
          "100:     if ( !IsValid() )",
          "106:     return crypto_sign_ed25519_verify_detached( signature, static_cast<const unsigned char*>( pData ), cbData, CCryptoKeyBase_RawBuffer::GetRawDataPtr() ) == 0;",
          "113:     if ( !IsValid() )",
          "114:     {",
          "116:     }",
          "118:     if ( m_eKeyType == k_ECryptoKeyTypeKeyExchangePrivate )",
          "121:         AssertMsg( sizeof(m_publicKey) == crypto_scalarmult_curve25519_bytes(), \"Public key size mismatch.\" );",
          "122:         AssertMsg( CCryptoKeyBase_RawBuffer::GetRawDataSize() == crypto_scalarmult_curve25519_scalarbytes(), \"Private key size mismatch.\" );",
          "124:         crypto_scalarmult_curve25519_base( m_publicKey, CCryptoKeyBase_RawBuffer::GetRawDataPtr() );",
          "125:     }",
          "126:     else if ( m_eKeyType == k_ECryptoKeyTypeSigningPrivate )",
          "127:     {",
          "130:         AssertMsg( sizeof(m_publicKey) == crypto_sign_ed25519_publickeybytes(), \"Public key size mismatch.\" );",
          "131:         AssertMsg( CCryptoKeyBase_RawBuffer::GetRawDataSize() == crypto_sign_ed25519_seedbytes(), \"Private key size mismatch.\" );",
          "133:         unsigned char h[crypto_hash_sha512_BYTES];",
          "135:         crypto_sign_ed25519_seed_keypair( m_publicKey, h, static_cast<const unsigned char*>( CCryptoKeyBase_RawBuffer::GetRawDataPtr() ) );",
          "137:         sodium_memzero(h, sizeof(h));",
          "138:     }",
          "139:     else",
          "140:     {",
          "141:         Assert( false );",
          "142:         return false;",
          "143:     }",
          "145:     return true;",
          "",
          "[Added Lines]",
          "22:  return CCryptoKeyBase_RawBuffer::GetRawData( pData );",
          "27:  CCryptoKeyBase_RawBuffer::Wipe();",
          "32:  if ( cbData != 32 )",
          "39:  Assert( localPrivateKey.IsValid() );",
          "40:  Assert( remotePublicKey.IsValid() );",
          "42:  if ( !localPrivateKey.IsValid() || !remotePublicKey.IsValid() )",
          "43:  {",
          "45:   GenerateRandomBlock( *pSharedSecretOut, sizeof( SHA256Digest_t ) );",
          "46:   return false;",
          "47:  }",
          "49:  uint8 bufSharedSecret[32];",
          "50:  uint8 bufLocalPrivate[32];",
          "51:  uint8 bufRemotePublic[32];",
          "53:  localPrivateKey.GetRawData(bufLocalPrivate);",
          "54:  remotePublicKey.GetRawData(bufRemotePublic);",
          "56:  const int nResult = crypto_scalarmult_curve25519(bufSharedSecret, bufLocalPrivate, bufRemotePublic);",
          "58:  SecureZeroMemory( bufLocalPrivate, 32 );",
          "59:  SecureZeroMemory( bufRemotePublic, 32 );",
          "61:  if(nResult != 0)",
          "62:  {",
          "63:   return false;",
          "64:  }",
          "66:  GenerateSHA256Digest( bufSharedSecret, sizeof(bufSharedSecret), pSharedSecretOut );",
          "67:  SecureZeroMemory( bufSharedSecret, 32 );",
          "69:  return true;",
          "74:  if ( !IsValid() )",
          "77:   sodium_memzero( pSignatureOut, sizeof( CryptoSignature_t ) );",
          "85:  uint8 bufSodiumSecret[crypto_sign_ed25519_SECRETKEYBYTES];",
          "87:  Assert( CCryptoKeyBase_RawBuffer::GetRawDataSize() == 32 );",
          "88:  Assert( sizeof(m_publicKey) == 32 );",
          "89:  Assert( crypto_sign_ed25519_SECRETKEYBYTES == 64 );",
          "91:  memcpy(bufSodiumSecret, CCryptoKeyBase_RawBuffer::GetRawDataPtr(), 32 );",
          "92:  memcpy(bufSodiumSecret + 32, m_publicKey, sizeof(m_publicKey));",
          "94:  crypto_sign_ed25519_detached(*pSignatureOut, nullptr, static_cast<const unsigned char*>( pData ), cbData, bufSodiumSecret );",
          "95:  sodium_memzero(bufSodiumSecret, sizeof(bufSodiumSecret) );",
          "100:  if ( !IsValid() )",
          "106:  return crypto_sign_ed25519_verify_detached( signature, static_cast<const unsigned char*>( pData ), cbData, CCryptoKeyBase_RawBuffer::GetRawDataPtr() ) == 0;",
          "113:  if ( !IsValid() )",
          "114:  {",
          "116:  }",
          "118:  if ( m_eKeyType == k_ECryptoKeyTypeKeyExchangePrivate )",
          "121:   AssertMsg( sizeof(m_publicKey) == crypto_scalarmult_curve25519_bytes(), \"Public key size mismatch.\" );",
          "122:   AssertMsg( CCryptoKeyBase_RawBuffer::GetRawDataSize() == crypto_scalarmult_curve25519_scalarbytes(), \"Private key size mismatch.\" );",
          "124:   crypto_scalarmult_curve25519_base( m_publicKey, CCryptoKeyBase_RawBuffer::GetRawDataPtr() );",
          "125:  }",
          "126:  else if ( m_eKeyType == k_ECryptoKeyTypeSigningPrivate )",
          "127:  {",
          "130:   AssertMsg( sizeof(m_publicKey) == crypto_sign_ed25519_publickeybytes(), \"Public key size mismatch.\" );",
          "131:   AssertMsg( CCryptoKeyBase_RawBuffer::GetRawDataSize() == crypto_sign_ed25519_seedbytes(), \"Private key size mismatch.\" );",
          "133:   unsigned char h[crypto_hash_sha512_BYTES];",
          "135:   crypto_sign_ed25519_seed_keypair( m_publicKey, h, static_cast<const unsigned char*>( CCryptoKeyBase_RawBuffer::GetRawDataPtr() ) );",
          "137:   sodium_memzero(h, sizeof(h));",
          "138:  }",
          "139:  else",
          "140:  {",
          "141:   Assert( false );",
          "142:   return false;",
          "143:  }",
          "145:  return true;",
          "",
          "---------------"
        ],
        "src/common/crypto_25519_openssl.cpp||src/common/crypto_25519_openssl.cpp": [
          "File: src/common/crypto_25519_openssl.cpp -> src/common/crypto_25519_openssl.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <openssl/evp.h>",
          "10: #if OPENSSL_VERSION_NUMBER < 0x10101000",
          "13: #endif",
          "15: CEC25519KeyBase::~CEC25519KeyBase()",
          "",
          "[Removed Lines]",
          "12:  #error \"Raw access to 25519 keys requires OpenSSL 1.1.1\"",
          "",
          "[Added Lines]",
          "12: #error \"Raw access to 25519 keys requires OpenSSL 1.1.1\"",
          "",
          "---------------"
        ],
        "src/common/crypto_bcrypt.cpp||src/common/crypto_bcrypt.cpp": [
          "File: src/common/crypto_bcrypt.cpp -> src/common/crypto_bcrypt.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: void CCrypto::Init()",
          "51: {",
          "52:  BCryptOpenAlgorithmProvider(",
          "58:  AssertFatal( hAlgRandom != INVALID_HANDLE_VALUE );",
          "59:  BCryptOpenAlgorithmProvider(",
          "65:  AssertFatal( hAlgSHA256 != INVALID_HANDLE_VALUE );",
          "66:  BCryptOpenAlgorithmProvider(",
          "72:  AssertFatal( hAlgHMACSHA256 != INVALID_HANDLE_VALUE );",
          "73: }",
          "",
          "[Removed Lines]",
          "53:   &hAlgRandom,",
          "54:   BCRYPT_RNG_ALGORITHM,",
          "55:   nullptr,",
          "56:   0",
          "57:  );",
          "60:   &hAlgSHA256,",
          "61:   BCRYPT_SHA256_ALGORITHM,",
          "62:   nullptr,",
          "63:   0",
          "64:  );",
          "67:   &hAlgHMACSHA256,",
          "68:   BCRYPT_SHA256_ALGORITHM,",
          "69:   nullptr,",
          "70:   BCRYPT_ALG_HANDLE_HMAC_FLAG",
          "71:  );",
          "",
          "[Added Lines]",
          "53:    &hAlgRandom,",
          "54:    BCRYPT_RNG_ALGORITHM,",
          "55:    nullptr,",
          "56:    0",
          "57:    );",
          "60:    &hAlgSHA256,",
          "61:    BCRYPT_SHA256_ALGORITHM,",
          "62:    nullptr,",
          "63:    0",
          "64:    );",
          "67:    &hAlgHMACSHA256,",
          "68:    BCRYPT_SHA256_ALGORITHM,",
          "69:    nullptr,",
          "70:    BCRYPT_ALG_HANDLE_HMAC_FLAG",
          "71:    );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122: }",
          "124: bool AES_GCM_EncryptContext::Encrypt(",
          "130: {",
          "131:  BCryptContext *ctx = (BCryptContext *)(this->m_ctx);",
          "132:  BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO paddingInfo;",
          "",
          "[Removed Lines]",
          "125:  const void *pPlaintextData, size_t cbPlaintextData,",
          "126:  const void *pIV,",
          "127:  void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "128:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData // Optional additional authentication data.  Not encrypted, but will be included in the tag, so it can be authenticated.",
          "129: )",
          "",
          "[Added Lines]",
          "125:   const void *pPlaintextData, size_t cbPlaintextData,",
          "126:   const void *pIV,",
          "127:   void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "128:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData // Optional additional authentication data.  Not encrypted, but will be included in the tag, so it can be authenticated.",
          "129:   )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "141:  paddingInfo.pbAuthData = cbAuthenticationData ? (PUCHAR)pAdditionalAuthenticationData : NULL;",
          "142:  ULONG ct_size;",
          "143:  NTSTATUS status = BCryptEncrypt(",
          "151:  AssertFatal( ( ct_size + m_cbTag ) < *pcbEncryptedDataAndTag );",
          "152:  memcpy( ( PUCHAR )( pEncryptedDataAndTag ) + ct_size, buffer, m_cbTag );",
          "153:  ct_size += m_cbTag;",
          "",
          "[Removed Lines]",
          "144:   ctx->hKey,",
          "145:   ( PUCHAR )pPlaintextData, (ULONG)cbPlaintextData,",
          "146:   &paddingInfo,",
          "147:   NULL, 0,",
          "148:   ( PUCHAR )pEncryptedDataAndTag, *pcbEncryptedDataAndTag,",
          "149:   &ct_size,",
          "150:   0 );",
          "",
          "[Added Lines]",
          "144:    ctx->hKey,",
          "145:    ( PUCHAR )pPlaintextData, (ULONG)cbPlaintextData,",
          "146:    &paddingInfo,",
          "147:    NULL, 0,",
          "148:    ( PUCHAR )pEncryptedDataAndTag, *pcbEncryptedDataAndTag,",
          "149:    &ct_size,",
          "150:    0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156: }",
          "158: bool AES_GCM_DecryptContext::Decrypt(",
          "164: {",
          "165:  BCryptContext *ctx = (BCryptContext *)(this->m_ctx);",
          "166:  BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO paddingInfo;",
          "",
          "[Removed Lines]",
          "159:  const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "160:  const void *pIV,",
          "161:  void *pPlaintextData, uint32 *pcbPlaintextData,",
          "162:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "163: )",
          "",
          "[Added Lines]",
          "159:   const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "160:   const void *pIV,",
          "161:   void *pPlaintextData, uint32 *pcbPlaintextData,",
          "162:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "163:   )",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "178:  paddingInfo.pbAuthData = cbAuthenticationData ? (PUCHAR)pAdditionalAuthenticationData : NULL;",
          "179:  ULONG pt_size;",
          "180:  NTSTATUS status = BCryptDecrypt(",
          "189:  return NT_SUCCESS(status);",
          "190: }",
          "",
          "[Removed Lines]",
          "181:   ctx->hKey,",
          "182:   ( PUCHAR )pEncryptedDataAndTag, (ULONG)cbEncryptedDataAndTag,",
          "183:   &paddingInfo,",
          "184:   NULL, 0,",
          "185:   ( PUCHAR )pPlaintextData, *pcbPlaintextData,",
          "186:   &pt_size,",
          "187:   0 );",
          "",
          "[Added Lines]",
          "181:    ctx->hKey,",
          "182:    ( PUCHAR )pEncryptedDataAndTag, (ULONG)cbEncryptedDataAndTag,",
          "183:    &paddingInfo,",
          "184:    NULL, 0,",
          "185:    ( PUCHAR )pPlaintextData, *pcbPlaintextData,",
          "186:    &pt_size,",
          "187:    0 );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "232:  AssertFatal( cubDest >= 0 );",
          "234:  NTSTATUS status = BCryptGenRandom(",
          "240:  AssertFatal( NT_SUCCESS( status) );",
          "241: }",
          "",
          "[Removed Lines]",
          "235:   hAlgRandom,",
          "236:   (PUCHAR)pvDest,",
          "237:   (ULONG)cubDest,",
          "238:   0",
          "239:  );",
          "",
          "[Added Lines]",
          "235:    hAlgRandom,",
          "236:    (PUCHAR)pvDest,",
          "237:    (ULONG)cubDest,",
          "238:    0",
          "239:    );",
          "",
          "---------------"
        ],
        "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp": [
          "File: src/common/crypto_libsodium.cpp -> src/common/crypto_libsodium.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #ifdef STEAMNETWORKINGSOCKETS_CRYPTO_LIBSODIUM",
          "12: SymmetricCryptContextBase::SymmetricCryptContextBase()",
          "14: {",
          "15: }",
          "17: void SymmetricCryptContextBase::Wipe()",
          "18: {",
          "24: }",
          "26: bool AES_GCM_CipherContext::InitCipher( const void *pKey, size_t cbKey, size_t cbIV, size_t cbTag, bool bEncrypt )",
          "27: {",
          "45: }",
          "47: bool AES_GCM_EncryptContext::Encrypt(",
          "55:  if ( cbPlaintextData + crypto_aead_aes256gcm_ABYTES > *pcbEncryptedDataAndTag )",
          "",
          "[Removed Lines]",
          "13:     : m_ctx(nullptr), m_cbIV(0), m_cbTag(0)",
          "19:     sodium_free(m_ctx);",
          "21:     m_ctx = nullptr;",
          "22:     m_cbIV = 0;",
          "23:     m_cbTag = 0;",
          "33:     AssertMsg( crypto_aead_aes256gcm_is_available() == 1, \"No hardware AES support on this CPU.\" );",
          "34:     AssertMsg( cbKey == crypto_aead_aes256gcm_KEYBYTES, \"AES key sizes other than 256 are unsupported.\" );",
          "35:     AssertMsg( cbIV == crypto_aead_aes256gcm_NPUBBYTES, \"Nonce size is unsupported\" );",
          "37:     if(m_ctx == nullptr)",
          "38:     {",
          "39:         m_ctx = sodium_malloc( sizeof(crypto_aead_aes256gcm_state) );",
          "40:     }",
          "42:     crypto_aead_aes256gcm_beforenm( static_cast<crypto_aead_aes256gcm_state*>( m_ctx ), static_cast<const unsigned char*>( pKey ) );",
          "44:     return true;",
          "48:  const void *pPlaintextData, size_t cbPlaintextData,",
          "49:  const void *pIV,",
          "50:  void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "51:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "52: ) {",
          "",
          "[Added Lines]",
          "13:  : m_ctx(nullptr), m_cbIV(0), m_cbTag(0)",
          "19:  sodium_free(m_ctx);",
          "21:  m_ctx = nullptr;",
          "22:  m_cbIV = 0;",
          "23:  m_cbTag = 0;",
          "33:  AssertMsg( crypto_aead_aes256gcm_is_available() == 1, \"No hardware AES support on this CPU.\" );",
          "34:  AssertMsg( cbKey == crypto_aead_aes256gcm_KEYBYTES, \"AES key sizes other than 256 are unsupported.\" );",
          "35:  AssertMsg( cbIV == crypto_aead_aes256gcm_NPUBBYTES, \"Nonce size is unsupported\" );",
          "37:  if(m_ctx == nullptr)",
          "38:  {",
          "39:   m_ctx = sodium_malloc( sizeof(crypto_aead_aes256gcm_state) );",
          "40:  }",
          "42:  crypto_aead_aes256gcm_beforenm( static_cast<crypto_aead_aes256gcm_state*>( m_ctx ), static_cast<const unsigned char*>( pKey ) );",
          "44:  return true;",
          "48:   const void *pPlaintextData, size_t cbPlaintextData,",
          "49:   const void *pIV,",
          "50:   void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "51:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "52:   )",
          "53: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:   return false;",
          "59:  }",
          "74: }",
          "76: bool AES_GCM_DecryptContext::Decrypt(",
          "83:  if ( cbEncryptedDataAndTag > *pcbPlaintextData + crypto_aead_aes256gcm_ABYTES )",
          "84:  {",
          "",
          "[Removed Lines]",
          "61:     unsigned long long cbEncryptedDataAndTag_longlong;",
          "62:     crypto_aead_aes256gcm_encrypt_afternm(",
          "63:   static_cast<unsigned char*>( pEncryptedDataAndTag ), &cbEncryptedDataAndTag_longlong,",
          "64:   static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,",
          "65:   static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,",
          "66:   nullptr,",
          "67:   static_cast<const unsigned char*>( pIV ),",
          "68:   static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )",
          "69:  );",
          "73:     return true;",
          "77:  const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "78:  const void *pIV,",
          "79:  void *pPlaintextData, uint32 *pcbPlaintextData,",
          "80:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "81: ) {",
          "",
          "[Added Lines]",
          "62:  unsigned long long cbEncryptedDataAndTag_longlong;",
          "63:  crypto_aead_aes256gcm_encrypt_afternm(",
          "64:    static_cast<unsigned char*>( pEncryptedDataAndTag ), &cbEncryptedDataAndTag_longlong,",
          "65:    static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,",
          "66:    static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,",
          "67:    nullptr,",
          "68:    static_cast<const unsigned char*>( pIV ),",
          "69:    static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )",
          "70:    );",
          "74:  return true;",
          "78:   const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "79:   const void *pIV,",
          "80:   void *pPlaintextData, uint32 *pcbPlaintextData,",
          "81:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "82:   )",
          "83: {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "86:   return false;",
          "87:  }",
          "101: }",
          "103: void CCrypto::Init()",
          "104: {",
          "111: }",
          "113: void CCrypto::GenerateRandomBlock( void *pubDest, int cubDest )",
          "114: {",
          "116:  AssertFatal( cubDest >= 0 );",
          "119: }",
          "121: void CCrypto::GenerateSHA256Digest( const void *pData, size_t cbData, SHA256Digest_t *pOutputDigest )",
          "122: {",
          "124:  Assert( pData );",
          "128: }",
          "130: void CCrypto::GenerateHMAC256( const uint8 *pubData, uint32 cubData, const uint8 *pubKey, uint32 cubKey, SHA256Digest_t *pOutputDigest )",
          "131: {",
          "133:  Assert( pubData );",
          "134:  Assert( cubData > 0 );",
          "135:  Assert( pubKey );",
          "136:  Assert( cubKey > 0 );",
          "137:  Assert( pOutputDigest );",
          "143: }",
          "145: #endif",
          "",
          "[Removed Lines]",
          "89:     unsigned long long cbPlaintextData_longlong;",
          "90:     const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(",
          "91:   static_cast<unsigned char*>( pPlaintextData ), &cbPlaintextData_longlong,",
          "92:   nullptr,",
          "93:   static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,",
          "94:   static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,",
          "95:   static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )",
          "96:  );",
          "100:     return nDecryptResult == 0;",
          "107:     if(sodium_init() < 0)",
          "108:     {",
          "109:         AssertMsg( false, \"libsodium didn't init\" );",
          "110:     }",
          "115:     VPROF_BUDGET( \"CCrypto::GenerateRandomBlock\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "118:     randombytes_buf( pubDest, cubDest );",
          "123:     VPROF_BUDGET( \"CCrypto::GenerateSHA256Digest\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "125:     Assert( pOutputDigest );",
          "127:     crypto_hash_sha256( *pOutputDigest, static_cast<const unsigned char*>(pData), cbData );",
          "132:     VPROF_BUDGET( \"CCrypto::GenerateHMAC256\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "139:     Assert( sizeof(*pOutputDigest) == crypto_auth_hmacsha256_BYTES );",
          "140:     Assert( cubKey == crypto_auth_hmacsha256_KEYBYTES );",
          "142:     crypto_auth_hmacsha256( *pOutputDigest, pubData, cubData, pubKey );",
          "",
          "[Added Lines]",
          "91:  unsigned long long cbPlaintextData_longlong;",
          "92:  const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(",
          "93:    static_cast<unsigned char*>( pPlaintextData ), &cbPlaintextData_longlong,",
          "94:    nullptr,",
          "95:    static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,",
          "96:    static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,",
          "97:    static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )",
          "98:    );",
          "102:  return nDecryptResult == 0;",
          "109:  if(sodium_init() < 0)",
          "110:  {",
          "111:   AssertMsg( false, \"libsodium didn't init\" );",
          "112:  }",
          "117:  VPROF_BUDGET( \"CCrypto::GenerateRandomBlock\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "120:  randombytes_buf( pubDest, cubDest );",
          "125:  VPROF_BUDGET( \"CCrypto::GenerateSHA256Digest\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "127:  Assert( pOutputDigest );",
          "129:  crypto_hash_sha256( *pOutputDigest, static_cast<const unsigned char*>(pData), cbData );",
          "134:  VPROF_BUDGET( \"CCrypto::GenerateHMAC256\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "141:  Assert( sizeof(*pOutputDigest) == crypto_auth_hmacsha256_BYTES );",
          "142:  Assert( cubKey == crypto_auth_hmacsha256_KEYBYTES );",
          "144:  crypto_auth_hmacsha256( *pOutputDigest, pubData, cubData, pubKey );",
          "",
          "---------------"
        ],
        "src/common/crypto_openssl.cpp||src/common/crypto_openssl.cpp": [
          "File: src/common/crypto_openssl.cpp -> src/common/crypto_openssl.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: template < typename CTXType, void(*CleanupFunc)(CTXType)>",
          "55: class EVPCTXPointer",
          "56: {",
          "63: };",
          "65: SymmetricCryptContextBase::SymmetricCryptContextBase()",
          "",
          "[Removed Lines]",
          "57: public:",
          "58:  CTXType ctx;",
          "60:  EVPCTXPointer() { this->ctx = NULL; }",
          "61:  EVPCTXPointer(CTXType ctx) { this->ctx = ctx; }",
          "62:  ~EVPCTXPointer() { CleanupFunc(ctx); }",
          "",
          "[Added Lines]",
          "57:  public:",
          "58:   CTXType ctx;",
          "60:   EVPCTXPointer() { this->ctx = NULL; }",
          "61:   EVPCTXPointer(CTXType ctx) { this->ctx = ctx; }",
          "62:   ~EVPCTXPointer() { CleanupFunc(ctx); }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:  if ( m_ctx )",
          "75:  {",
          "76:   EVP_CIPHER_CTX *ctx = (EVP_CIPHER_CTX*)m_ctx;",
          "83:   m_ctx = nullptr;",
          "84:  }",
          "85:  m_cbIV = 0;",
          "",
          "[Removed Lines]",
          "77:   #if OPENSSL_VERSION_NUMBER < 0x10100000",
          "78:    EVP_CIPHER_CTX_cleanup( ctx );",
          "79:    delete ctx;",
          "80:   #else",
          "81:    EVP_CIPHER_CTX_free( ctx );",
          "82:   #endif",
          "",
          "[Added Lines]",
          "77: #if OPENSSL_VERSION_NUMBER < 0x10100000",
          "78:   EVP_CIPHER_CTX_cleanup( ctx );",
          "79:   delete ctx;",
          "80: #else",
          "81:   EVP_CIPHER_CTX_free( ctx );",
          "82: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "91:  EVP_CIPHER_CTX *ctx = (EVP_CIPHER_CTX*)m_ctx;",
          "92:  if ( ctx )",
          "93:  {",
          "100:  }",
          "101:  else",
          "102:  {",
          "113:   m_ctx = ctx;",
          "114:  }",
          "",
          "[Removed Lines]",
          "94:   #if OPENSSL_VERSION_NUMBER < 0x10100000",
          "95:    EVP_CIPHER_CTX_cleanup( ctx );",
          "96:    EVP_CIPHER_CTX_init( ctx );",
          "97:   #else",
          "98:    EVP_CIPHER_CTX_reset( ctx );",
          "99:   #endif",
          "103:   #if OPENSSL_VERSION_NUMBER < 0x10100000",
          "104:    ctx = new EVP_CIPHER_CTX;",
          "105:    if ( !ctx )",
          "106:     return false;",
          "107:    EVP_CIPHER_CTX_init( ctx );",
          "108:   #else",
          "109:    ctx = EVP_CIPHER_CTX_new();",
          "110:    if ( !ctx )",
          "111:     return false;",
          "112:   #endif",
          "",
          "[Added Lines]",
          "94: #if OPENSSL_VERSION_NUMBER < 0x10100000",
          "95:   EVP_CIPHER_CTX_cleanup( ctx );",
          "96:   EVP_CIPHER_CTX_init( ctx );",
          "97: #else",
          "98:   EVP_CIPHER_CTX_reset( ctx );",
          "99: #endif",
          "103: #if OPENSSL_VERSION_NUMBER < 0x10100000",
          "104:   ctx = new EVP_CIPHER_CTX;",
          "105:   if ( !ctx )",
          "106:    return false;",
          "107:   EVP_CIPHER_CTX_init( ctx );",
          "108: #else",
          "109:   ctx = EVP_CIPHER_CTX_new();",
          "110:   if ( !ctx )",
          "111:    return false;",
          "112: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150: }",
          "152: bool AES_GCM_EncryptContext::Encrypt(",
          "158: {",
          "159:  EVP_CIPHER_CTX *ctx = (EVP_CIPHER_CTX*)m_ctx;",
          "160:  if ( !ctx )",
          "",
          "[Removed Lines]",
          "153:  const void *pPlaintextData, size_t cbPlaintextData,",
          "154:  const void *pIV,",
          "155:  void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "156:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData // Optional additional authentication data.  Not encrypted, but will be included in the tag, so it can be authenticated.",
          "157: )",
          "",
          "[Added Lines]",
          "153:   const void *pPlaintextData, size_t cbPlaintextData,",
          "154:   const void *pIV,",
          "155:   void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "156:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData // Optional additional authentication data.  Not encrypted, but will be included in the tag, so it can be authenticated.",
          "157:   )",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "222: }",
          "224: bool AES_GCM_DecryptContext::Decrypt(",
          "230: {",
          "232:  EVP_CIPHER_CTX *ctx = (EVP_CIPHER_CTX*)m_ctx;",
          "",
          "[Removed Lines]",
          "225:  const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "226:  const void *pIV,",
          "227:  void *pPlaintextData, uint32 *pcbPlaintextData,",
          "228:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "229: )",
          "",
          "[Added Lines]",
          "225:   const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "226:   const void *pIV,",
          "227:   void *pPlaintextData, uint32 *pcbPlaintextData,",
          "228:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData",
          "229:   )",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "314: bool CCrypto::SymmetricAuthEncryptWithIV(",
          "",
          "[Removed Lines]",
          "315:  const void *pPlaintextData, size_t cbPlaintextData,",
          "316:  const void *pIV, size_t cbIV,",
          "317:  void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "318:  const void *pKey, size_t cbKey,",
          "319:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData,",
          "320:  size_t cbTag",
          "321: ) {",
          "",
          "[Added Lines]",
          "315:   const void *pPlaintextData, size_t cbPlaintextData,",
          "316:   const void *pIV, size_t cbIV,",
          "317:   void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,",
          "318:   const void *pKey, size_t cbKey,",
          "319:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData,",
          "320:   size_t cbTag",
          "321:   )",
          "322: {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "334: bool CCrypto::SymmetricAuthDecryptWithIV(",
          "344:  AES_GCM_DecryptContext ctx;",
          "",
          "[Removed Lines]",
          "335:  const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "336:  const void *pIV, size_t cbIV,",
          "337:  void *pPlaintextData, uint32 *pcbPlaintextData,",
          "338:  const void *pKey, size_t cbKey,",
          "339:  const void *pAdditionalAuthenticationData, size_t cbAuthenticationData,",
          "340:  size_t cbTag",
          "341: ) {",
          "",
          "[Added Lines]",
          "336:   const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,",
          "337:   const void *pIV, size_t cbIV,",
          "338:   void *pPlaintextData, uint32 *pcbPlaintextData,",
          "339:   const void *pKey, size_t cbKey,",
          "340:   const void *pAdditionalAuthenticationData, size_t cbAuthenticationData,",
          "341:   size_t cbTag",
          "342:   )",
          "343: {",
          "",
          "---------------"
        ],
        "src/common/crypto_textencode.cpp||src/common/crypto_textencode.cpp": [
          "File: src/common/crypto_textencode.cpp -> src/common/crypto_textencode.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "326:   AssertMsg( *pcubDecodedData == 0, \"NULL output buffer with non-zero size passed to Base64Decode\" );",
          "327:   cubDecodedDataOrig = cubDecodedData = ~0u;",
          "328:  }",
          "332:  static const signed char rgchInvBase64[] = {",
          "333:   62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,",
          "334:   -1, -1, -1, -2, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,",
          "336:   23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31,",
          "337:   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,",
          "338:   47, 48, 49, 50, 51",
          "",
          "[Removed Lines]",
          "335:    8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,",
          "",
          "[Added Lines]",
          "335:   8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b2ae48a2603909862d472ae484a956b1ee7d740f",
      "candidate_info": {
        "commit_hash": "b2ae48a2603909862d472ae484a956b1ee7d740f",
        "repo": "ValveSoftware/GameNetworkingSockets",
        "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/b2ae48a2603909862d472ae484a956b1ee7d740f",
        "files": [
          ".travis/build-cmake.sh",
          ".travis/build-meson.sh",
          ".travis/install-alpine.sh",
          ".travis/install-archlinux.sh",
          ".travis/install-fedora.sh",
          ".travis/install-ubuntu.sh",
          "CMakeLists.txt",
          "cmake/Findsodium.cmake",
          "meson_options.txt",
          "src/CMakeLists.txt",
          "src/common/crypto_25519_libsodium.cpp",
          "src/common/crypto_libsodium.cpp",
          "src/meson.build",
          "tests/test_crypto.cpp"
        ],
        "message": "implement libsodium support\n\n - Added support for using libsodium for encryption rather than OpenSSL\n - Removed AES-GCM tests with keys shorter than 256; libsodium only supports 256\n - Added a build with libsodium to the CI matrix\n\nSigned-off-by: Andrew Simpson <andy@aiusepsi.co.uk>\n\nsteven@ edited and rebased:\n\n - integrated with new USE_CRYPTO/USE_CRYPTO25519 options in CMake/meson\n - separated using libsodium for ed25519/curve25519 and AES/SHA256.\n - ensured libsodium simple crypto tests run on all builders instead of\n   a single isolated builder.\n - prevented building with -DUSE_CRYPTO=libsodium for non-x86 hardware,\n   as libsodium's AES implementation depends on AES-NI. it is still\n   possible to configure with -DUSE_CRYPTO25519=libsodium on arbitrary\n   hardware targets.\n\nFixes #88.\n\nSigned-off-by: Steven Noonan <steven@valvesoftware.com>",
        "before_after_code_files": [
          ".travis/build-cmake.sh||.travis/build-cmake.sh",
          ".travis/build-meson.sh||.travis/build-meson.sh",
          ".travis/install-alpine.sh||.travis/install-alpine.sh",
          ".travis/install-archlinux.sh||.travis/install-archlinux.sh",
          ".travis/install-fedora.sh||.travis/install-fedora.sh",
          ".travis/install-ubuntu.sh||.travis/install-ubuntu.sh",
          "cmake/Findsodium.cmake||cmake/Findsodium.cmake",
          "src/common/crypto_25519_libsodium.cpp||src/common/crypto_25519_libsodium.cpp",
          "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp",
          "src/meson.build||src/meson.build",
          "tests/test_crypto.cpp||tests/test_crypto.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
          ],
          "candidate": [
            "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp"
          ]
        }
      },
      "candidate_diff": {
        ".travis/build-cmake.sh||.travis/build-cmake.sh": [
          "File: .travis/build-cmake.sh -> .travis/build-cmake.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: cleanup() {",
          "22:  echo \"Cleaning up CMake build directories\" >&2",
          "24: }",
          "26: trap cleanup EXIT",
          "",
          "[Removed Lines]",
          "23:  rm -rf build-{a,ub,t}san build-cmake build-cmake-ref",
          "",
          "[Added Lines]",
          "23:  rm -rf build-{a,ub,t}san build-cmake{,-ref,-sodium{,25519}}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: # Foreign architecture docker containers don't support sanitizers.",
          "49: [[ $(uname -m) != x86_64 ]] && grep -q -e AuthenticAMD -e GenuineIntel /proc/cpuinfo && BUILD_SANITIZERS=0",
          "51: set -x",
          "53: # Build some tests with sanitizers",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: BUILD_LIBSODIUM=1",
          "54: # libsodium's AES implementation only works on x86_64",
          "55: [[ $(uname -m) != x86_64 ]] && BUILD_LIBSODIUM=0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "67: cmake_configure build-cmake-ref ${CMAKE_ARGS[@]} -DCMAKE_BUILD_TYPE=RelWithDebInfo -DUSE_CRYPTO25519=Reference ..",
          "68: cmake_build build-cmake-ref",
          "70: # Build specific extended tests for code correctness validation",
          "71: if [[ $BUILD_SANITIZERS -ne 0 ]]; then",
          "72:  cmake_build build-asan test_connection test_crypto",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76: # Build binaries with libsodium for ed25519/curve25519 only",
          "77: cmake_configure build-cmake-sodium25519 ${CMAKE_ARGS[@]} -DCMAKE_BUILD_TYPE=RelWithDebInfo -DUSE_CRYPTO25519=libsodium ..",
          "78: cmake_build build-cmake-sodium25519",
          "80: # Build binaries with libsodium",
          "81: if [[ $BUILD_LIBSODIUM -ne 0 ]]; then",
          "82:  cmake_configure build-cmake-sodium ${CMAKE_ARGS[@]} -DCMAKE_BUILD_TYPE=RelWithDebInfo -DUSE_CRYPTO=libsodium -DUSE_CRYPTO25519=libsodium ..",
          "83:  cmake_build build-cmake-sodium",
          "84: fi",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "79: # Run basic tests",
          "80: build-cmake-ref/tests/test_crypto",
          "81: build-cmake/tests/test_crypto",
          "82: build-cmake/tests/test_connection",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97: [[ $BUILD_LIBSODIUM -ne 0 ]] && build-cmake-sodium/tests/test_crypto",
          "98: build-cmake-sodium25519/tests/test_crypto",
          "",
          "---------------"
        ],
        ".travis/build-meson.sh||.travis/build-meson.sh": [
          "File: .travis/build-meson.sh -> .travis/build-meson.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: cleanup() {",
          "9:  echo \"Cleaning up Meson build directories\" >&2",
          "11: }",
          "13: trap cleanup EXIT",
          "",
          "[Removed Lines]",
          "10:  rm -rf build-meson build-meson-ref",
          "",
          "[Added Lines]",
          "10:  rm -rf build-meson{,-ref,-sodium{,25519}}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18:  -DWerror=true",
          "19: )",
          "21: set -x",
          "23: # Build lightweight test builds",
          "24: meson . build-meson ${MESON_ARGS[@]} --buildtype debugoptimized",
          "25: meson . build-meson-ref ${MESON_ARGS[@]} --buildtype debugoptimized -Duse_crypto25519=Reference",
          "27: # Build all targets",
          "28: ninja -v -C build-meson",
          "29: ninja -v -C build-meson-ref",
          "31: # Run basic tests",
          "32: build-meson/tests/test_crypto",
          "33: build-meson-ref/tests/test_crypto",
          "35: set +x",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: BUILD_LIBSODIUM=1",
          "23: # libsodium's AES implementation only works on x86_64",
          "24: [[ $(uname -m) != x86_64 ]] && BUILD_LIBSODIUM=0",
          "31: [[ $BUILD_LIBSODIUM -ne 0 ]] && meson . build-meson-sodium ${MESON_ARGS[@]} --buildtype debugoptimized -Duse_crypto=libsodium -Duse_crypto25519=libsodium",
          "32: meson . build-meson-sodium25519 ${MESON_ARGS[@]} --buildtype debugoptimized -Duse_crypto25519=libsodium",
          "36: [[ $BUILD_LIBSODIUM -ne 0 ]] && ninja -v -C build-meson-sodium",
          "37: ninja -v -C build-meson-sodium25519",
          "42: [[ $BUILD_LIBSODIUM -ne 0 ]] && build-meson-sodium/tests/test_crypto",
          "43: build-meson-sodium25519/tests/test_crypto",
          "",
          "---------------"
        ],
        ".travis/install-alpine.sh||.travis/install-alpine.sh": [
          "File: .travis/install-alpine.sh -> .travis/install-alpine.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: PACKAGES+=(protobuf-dev)",
          "22: PACKAGES+=(openssl-dev)",
          "24: apk add \"${PACKAGES[@]}\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: PACKAGES+=(libsodium-dev)",
          "",
          "---------------"
        ],
        ".travis/install-archlinux.sh||.travis/install-archlinux.sh": [
          "File: .travis/install-archlinux.sh -> .travis/install-archlinux.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: PACKAGES+=(protobuf)",
          "17: PACKAGES+=(openssl)",
          "19: pacman --noconfirm -Sy \"${PACKAGES[@]}\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: PACKAGES+=(libsodium)",
          "",
          "---------------"
        ],
        ".travis/install-fedora.sh||.travis/install-fedora.sh": [
          "File: .travis/install-fedora.sh -> .travis/install-fedora.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: PACKAGES+=(protobuf-compiler protobuf-devel)",
          "20: PACKAGES+=(openssl-devel)",
          "22: dnf install -y \"${PACKAGES[@]}\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: PACKAGES+=(libsodium-devel)",
          "",
          "---------------"
        ],
        ".travis/install-ubuntu.sh||.travis/install-ubuntu.sh": [
          "File: .travis/install-ubuntu.sh -> .travis/install-ubuntu.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: PACKAGES+=(libprotobuf-dev protobuf-compiler)",
          "14: PACKAGES+=(libssl-dev)",
          "16: apt-get install -y \"${PACKAGES[@]}\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: PACKAGES+=(libsodium-dev)",
          "",
          "---------------"
        ],
        "cmake/Findsodium.cmake||cmake/Findsodium.cmake": [
          "File: cmake/Findsodium.cmake -> cmake/Findsodium.cmake",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Written in 2016 by Henrik Steffen Ga\u00dfmann <henrik@gassmann.onl>",
          "2: #",
          "3: # To the extent possible under law, the author(s) have dedicated all copyright",
          "4: # and related and neighboring rights to this software to the public domain",
          "5: # worldwide. This software is distributed without any warranty.",
          "6: #",
          "7: # You should have received a copy of the CC0 Public Domain Dedication along with",
          "8: # this software. If not, see",
          "9: #",
          "10: # http://creativecommons.org/publicdomain/zero/1.0/",
          "11: #",
          "12: # ##############################################################################",
          "13: # Tries to find the local libsodium installation.",
          "14: #",
          "15: # On Windows the sodium_DIR environment variable is used as a default hint which",
          "16: # can be overridden by setting the corresponding cmake variable.",
          "17: #",
          "18: # Once done the following variables will be defined:",
          "19: #",
          "20: # sodium_FOUND sodium_INCLUDE_DIR sodium_LIBRARY_DEBUG sodium_LIBRARY_RELEASE",
          "21: # sodium_VERSION_STRING",
          "22: #",
          "23: # Furthermore an imported \"sodium\" target is created.",
          "24: #",
          "26: if(CMAKE_C_COMPILER_ID STREQUAL \"GNU\" OR CMAKE_C_COMPILER_ID STREQUAL \"Clang\")",
          "27:   set(_GCC_COMPATIBLE 1)",
          "28: endif()",
          "30: # static library option",
          "31: if(NOT DEFINED sodium_USE_STATIC_LIBS)",
          "32:   option(sodium_USE_STATIC_LIBS \"enable to statically link against sodium\" OFF)",
          "33: endif()",
          "34: if(NOT (sodium_USE_STATIC_LIBS EQUAL sodium_USE_STATIC_LIBS_LAST))",
          "35:   unset(sodium_LIBRARY CACHE)",
          "36:   unset(sodium_LIBRARY_DEBUG CACHE)",
          "37:   unset(sodium_LIBRARY_RELEASE CACHE)",
          "38:   unset(sodium_DLL_DEBUG CACHE)",
          "39:   unset(sodium_DLL_RELEASE CACHE)",
          "40:   set(sodium_USE_STATIC_LIBS_LAST",
          "41:       ${sodium_USE_STATIC_LIBS}",
          "42:       CACHE INTERNAL \"internal change tracking variable\")",
          "43: endif()",
          "45: # ##############################################################################",
          "46: # UNIX",
          "47: if(UNIX)",
          "48:   # import pkg-config",
          "49:   find_package(PkgConfig QUIET)",
          "50:   if(PKG_CONFIG_FOUND)",
          "51:     pkg_check_modules(sodium_PKG QUIET libsodium)",
          "52:   endif()",
          "54:   if(sodium_USE_STATIC_LIBS)",
          "55:     if(sodium_PKG_STATIC_LIBRARIES)",
          "56:       foreach(_libname ${sodium_PKG_STATIC_LIBRARIES})",
          "57:         if(NOT _libname MATCHES \"^lib.*\\\\.a$\") # ignore strings already ending",
          "58:                                                # with .a",
          "59:           list(INSERT sodium_PKG_STATIC_LIBRARIES 0 \"lib${_libname}.a\")",
          "60:         endif()",
          "61:       endforeach()",
          "62:       list(REMOVE_DUPLICATES sodium_PKG_STATIC_LIBRARIES)",
          "63:     else()",
          "64:       # if pkgconfig for libsodium doesn't provide static lib info, then",
          "65:       # override PKG_STATIC here..",
          "66:       set(sodium_PKG_STATIC_LIBRARIES libsodium.a)",
          "67:     endif()",
          "69:     set(XPREFIX sodium_PKG_STATIC)",
          "70:   else()",
          "71:     if(sodium_PKG_LIBRARIES STREQUAL \"\")",
          "72:       set(sodium_PKG_LIBRARIES sodium)",
          "73:     endif()",
          "75:     set(XPREFIX sodium_PKG)",
          "76:   endif()",
          "78:   find_path(sodium_INCLUDE_DIR sodium.h HINTS ${${XPREFIX}_INCLUDE_DIRS})",
          "79:   find_library(sodium_LIBRARY_DEBUG",
          "80:                NAMES ${${XPREFIX}_LIBRARIES}",
          "81:                HINTS ${${XPREFIX}_LIBRARY_DIRS})",
          "82:   find_library(sodium_LIBRARY_RELEASE",
          "83:                NAMES ${${XPREFIX}_LIBRARIES}",
          "84:                HINTS ${${XPREFIX}_LIBRARY_DIRS})",
          "86:   # ############################################################################",
          "87:   # Windows",
          "88: elseif(WIN32)",
          "89:   set(sodium_DIR \"$ENV{sodium_DIR}\" CACHE FILEPATH \"sodium install directory\")",
          "90:   mark_as_advanced(sodium_DIR)",
          "92:   find_path(sodium_INCLUDE_DIR sodium.h",
          "93:             HINTS ${sodium_DIR}",
          "94:             PATH_SUFFIXES include)",
          "96:   if(MSVC)",
          "97:     # detect target architecture",
          "98:     file(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/arch.c\" [=[",
          "99:             #if defined _M_IX86",
          "100:             #error ARCH_VALUE x86_32",
          "101:             #elif defined _M_X64",
          "102:             #error ARCH_VALUE x86_64",
          "103:             #endif",
          "104:             #error ARCH_VALUE unknown",
          "105:         ]=])",
          "106:     try_compile(_UNUSED_VAR \"${CMAKE_CURRENT_BINARY_DIR}\"",
          "107:                 \"${CMAKE_CURRENT_BINARY_DIR}/arch.c\"",
          "108:                 OUTPUT_VARIABLE _COMPILATION_LOG)",
          "109:     string(REGEX",
          "110:            REPLACE \".*ARCH_VALUE ([a-zA-Z0-9_]+).*\"",
          "111:                    \"\\\\1\"",
          "112:                    _TARGET_ARCH",
          "113:                    \"${_COMPILATION_LOG}\")",
          "115:     # construct library path",
          "116:     if(_TARGET_ARCH STREQUAL \"x86_32\")",
          "117:       string(APPEND _PLATFORM_PATH \"Win32\")",
          "118:     elseif(_TARGET_ARCH STREQUAL \"x86_64\")",
          "119:       string(APPEND _PLATFORM_PATH \"x64\")",
          "120:     else()",
          "121:       message(",
          "122:         FATAL_ERROR",
          "123:           \"the ${_TARGET_ARCH} architecture is not supported by Findsodium.cmake.\"",
          "124:         )",
          "125:     endif()",
          "126:     string(APPEND _PLATFORM_PATH \"/$$CONFIG$$\")",
          "128:     if(MSVC_VERSION LESS 1900)",
          "129:       math(EXPR _VS_VERSION \"${MSVC_VERSION} / 10 - 60\")",
          "130:     else()",
          "131:       math(EXPR _VS_VERSION \"${MSVC_VERSION} / 10 - 50\")",
          "132:     endif()",
          "133:     string(APPEND _PLATFORM_PATH \"/v${_VS_VERSION}\")",
          "135:     if(sodium_USE_STATIC_LIBS)",
          "136:       string(APPEND _PLATFORM_PATH \"/static\")",
          "137:     else()",
          "138:       string(APPEND _PLATFORM_PATH \"/dynamic\")",
          "139:     endif()",
          "141:     string(REPLACE \"$$CONFIG$$\"",
          "142:                    \"Debug\"",
          "143:                    _DEBUG_PATH_SUFFIX",
          "144:                    \"${_PLATFORM_PATH}\")",
          "145:     string(REPLACE \"$$CONFIG$$\"",
          "146:                    \"Release\"",
          "147:                    _RELEASE_PATH_SUFFIX",
          "148:                    \"${_PLATFORM_PATH}\")",
          "150:     find_library(sodium_LIBRARY_DEBUG libsodium.lib",
          "151:                  HINTS ${sodium_DIR}",
          "152:                  PATH_SUFFIXES ${_DEBUG_PATH_SUFFIX})",
          "153:     find_library(sodium_LIBRARY_RELEASE libsodium.lib",
          "154:                  HINTS ${sodium_DIR}",
          "155:                  PATH_SUFFIXES ${_RELEASE_PATH_SUFFIX})",
          "156:     if(NOT sodium_USE_STATIC_LIBS)",
          "157:       set(CMAKE_FIND_LIBRARY_SUFFIXES_BCK ${CMAKE_FIND_LIBRARY_SUFFIXES})",
          "158:       set(CMAKE_FIND_LIBRARY_SUFFIXES \".dll\")",
          "159:       find_library(sodium_DLL_DEBUG libsodium",
          "160:                    HINTS ${sodium_DIR}",
          "161:                    PATH_SUFFIXES ${_DEBUG_PATH_SUFFIX})",
          "162:       find_library(sodium_DLL_RELEASE libsodium",
          "163:                    HINTS ${sodium_DIR}",
          "164:                    PATH_SUFFIXES ${_RELEASE_PATH_SUFFIX})",
          "165:       set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES_BCK})",
          "166:     endif()",
          "168:   elseif(_GCC_COMPATIBLE)",
          "169:     if(sodium_USE_STATIC_LIBS)",
          "170:       find_library(sodium_LIBRARY_DEBUG libsodium.a",
          "171:                    HINTS ${sodium_DIR}",
          "172:                    PATH_SUFFIXES lib)",
          "173:       find_library(sodium_LIBRARY_RELEASE libsodium.a",
          "174:                    HINTS ${sodium_DIR}",
          "175:                    PATH_SUFFIXES lib)",
          "176:     else()",
          "177:       find_library(sodium_LIBRARY_DEBUG libsodium.dll.a",
          "178:                    HINTS ${sodium_DIR}",
          "179:                    PATH_SUFFIXES lib)",
          "180:       find_library(sodium_LIBRARY_RELEASE libsodium.dll.a",
          "181:                    HINTS ${sodium_DIR}",
          "182:                    PATH_SUFFIXES lib)",
          "184:       file(GLOB _DLL",
          "185:            LIST_DIRECTORIES false",
          "186:            RELATIVE \"${sodium_DIR}/bin\"",
          "187:            \"${sodium_DIR}/bin/libsodium*.dll\")",
          "188:       find_library(sodium_DLL_DEBUG ${_DLL} libsodium",
          "189:                    HINTS ${sodium_DIR}",
          "190:                    PATH_SUFFIXES bin)",
          "191:       find_library(sodium_DLL_RELEASE ${_DLL} libsodium",
          "192:                    HINTS ${sodium_DIR}",
          "193:                    PATH_SUFFIXES bin)",
          "194:     endif()",
          "195:   else()",
          "196:     message(FATAL_ERROR \"this platform is not supported by FindSodium.cmake\")",
          "197:   endif()",
          "199:   # ############################################################################",
          "200:   # unsupported",
          "201: else()",
          "202:   message(FATAL_ERROR \"this platform is not supported by FindSodium.cmake\")",
          "203: endif()",
          "205: # ##############################################################################",
          "206: # common stuff",
          "208: # extract sodium version",
          "209: if(sodium_INCLUDE_DIR)",
          "210:   set(_VERSION_HEADER \"${sodium_INCLUDE_DIR}/sodium/version.h\")",
          "211:   if(EXISTS \"${_VERSION_HEADER}\")",
          "212:     file(READ \"${_VERSION_HEADER}\" _VERSION_HEADER_CONTENT)",
          "213:     string(REGEX",
          "214:            REPLACE \".*define[ \\t]+SODIUM_VERSION_STRING[^\\\"]+\\\"([^\\\"]+)\\\".*\"",
          "215:                    \"\\\\1\"",
          "216:                    sodium_VERSION_STRING",
          "217:                    \"${_VERSION_HEADER_CONTENT}\")",
          "218:     set(sodium_VERSION_STRING \"${sodium_VERSION_STRING}\")",
          "219:   endif()",
          "220: endif()",
          "222: # communicate results",
          "223: include(FindPackageHandleStandardArgs)",
          "224: find_package_handle_standard_args(sodium",
          "225:                                   REQUIRED_VARS",
          "226:                                   sodium_LIBRARY_RELEASE",
          "227:                                   sodium_LIBRARY_DEBUG",
          "228:                                   sodium_INCLUDE_DIR",
          "229:                                   VERSION_VAR",
          "230:                                   sodium_VERSION_STRING)",
          "232: # mark file paths as advanced",
          "233: mark_as_advanced(sodium_INCLUDE_DIR)",
          "234: mark_as_advanced(sodium_LIBRARY_DEBUG)",
          "235: mark_as_advanced(sodium_LIBRARY_RELEASE)",
          "236: if(WIN32)",
          "237:   mark_as_advanced(sodium_DLL_DEBUG)",
          "238:   mark_as_advanced(sodium_DLL_RELEASE)",
          "239: endif()",
          "241: # create imported target",
          "242: if(sodium_USE_STATIC_LIBS)",
          "243:   set(_LIB_TYPE STATIC)",
          "244: else()",
          "245:   set(_LIB_TYPE SHARED)",
          "246: endif()",
          "247: add_library(sodium ${_LIB_TYPE} IMPORTED)",
          "249: set_target_properties(sodium",
          "250:                       PROPERTIES INTERFACE_INCLUDE_DIRECTORIES",
          "251:                                  \"${sodium_INCLUDE_DIR}\"",
          "252:                                  IMPORTED_LINK_INTERFACE_LANGUAGES",
          "253:                                  \"C\")",
          "255: if(sodium_USE_STATIC_LIBS)",
          "256:   set_target_properties(sodium",
          "257:                         PROPERTIES INTERFACE_COMPILE_DEFINITIONS",
          "258:                                    \"SODIUM_STATIC\"",
          "259:                                    IMPORTED_LOCATION",
          "260:                                    \"${sodium_LIBRARY_RELEASE}\"",
          "261:                                    IMPORTED_LOCATION_DEBUG",
          "262:                                    \"${sodium_LIBRARY_DEBUG}\")",
          "263: else()",
          "264:   if(UNIX)",
          "265:     set_target_properties(sodium",
          "266:                           PROPERTIES IMPORTED_LOCATION",
          "267:                                      \"${sodium_LIBRARY_RELEASE}\"",
          "268:                                      IMPORTED_LOCATION_DEBUG",
          "269:                                      \"${sodium_LIBRARY_DEBUG}\")",
          "270:   elseif(WIN32)",
          "271:     set_target_properties(sodium",
          "272:                           PROPERTIES IMPORTED_IMPLIB",
          "273:                                      \"${sodium_LIBRARY_RELEASE}\"",
          "274:                                      IMPORTED_IMPLIB_DEBUG",
          "275:                                      \"${sodium_LIBRARY_DEBUG}\")",
          "276:     if(NOT (sodium_DLL_DEBUG MATCHES \".*-NOTFOUND\"))",
          "277:       set_target_properties(sodium",
          "278:                             PROPERTIES IMPORTED_LOCATION_DEBUG",
          "279:                                        \"${sodium_DLL_DEBUG}\")",
          "280:     endif()",
          "281:     if(NOT (sodium_DLL_RELEASE MATCHES \".*-NOTFOUND\"))",
          "282:       set_target_properties(sodium",
          "283:                             PROPERTIES IMPORTED_LOCATION_RELWITHDEBINFO",
          "284:                                        \"${sodium_DLL_RELEASE}\"",
          "285:                                        IMPORTED_LOCATION_MINSIZEREL",
          "286:                                        \"${sodium_DLL_RELEASE}\"",
          "287:                                        IMPORTED_LOCATION_RELEASE",
          "288:                                        \"${sodium_DLL_RELEASE}\")",
          "289:     endif()",
          "290:   endif()",
          "291: endif()",
          "",
          "---------------"
        ],
        "src/common/crypto_25519_libsodium.cpp||src/common/crypto_25519_libsodium.cpp": [
          "File: src/common/crypto_25519_libsodium.cpp -> src/common/crypto_25519_libsodium.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"crypto.h\"",
          "3: #ifdef STEAMNETWORKINGSOCKETS_CRYPTO_25519_LIBSODIUM",
          "5: #include <sodium.h>",
          "7: CEC25519KeyBase::~CEC25519KeyBase()",
          "8: {",
          "9:  Wipe();",
          "10: }",
          "12: bool CEC25519KeyBase::IsValid() const",
          "13: {",
          "14:  return CCryptoKeyBase_RawBuffer::IsValid();",
          "15: }",
          "17: uint32 CEC25519KeyBase::GetRawData( void *pData ) const",
          "18: {",
          "19:     return CCryptoKeyBase_RawBuffer::GetRawData( pData );",
          "20: }",
          "22: void CEC25519KeyBase::Wipe()",
          "23: {",
          "24:     CCryptoKeyBase_RawBuffer::Wipe();",
          "25: }",
          "27: bool CEC25519KeyBase::SetRawData( const void *pData, size_t cbData )",
          "28: {",
          "29:     if ( cbData != 32 )",
          "30:   return false;",
          "31:  return CCryptoKeyBase_RawBuffer::SetRawData( pData, cbData );",
          "32: }",
          "34: bool CCrypto::PerformKeyExchange( const CECKeyExchangePrivateKey &localPrivateKey, const CECKeyExchangePublicKey &remotePublicKey, SHA256Digest_t *pSharedSecretOut )",
          "35: {",
          "36:     Assert( localPrivateKey.IsValid() );",
          "37:     Assert( remotePublicKey.IsValid() );",
          "39:     if ( !localPrivateKey.IsValid() || !remotePublicKey.IsValid() )",
          "40:     {",
          "42:         GenerateRandomBlock( *pSharedSecretOut, sizeof( SHA256Digest_t ) );",
          "43:         return false;",
          "44:     }",
          "46:     uint8 bufSharedSecret[32];",
          "47:     uint8 bufLocalPrivate[32];",
          "48:     uint8 bufRemotePublic[32];",
          "50:     localPrivateKey.GetRawData(bufLocalPrivate);",
          "51:     remotePublicKey.GetRawData(bufRemotePublic);",
          "53:     const int nResult = crypto_scalarmult_curve25519(bufSharedSecret, bufLocalPrivate, bufRemotePublic);",
          "55:     SecureZeroMemory( bufLocalPrivate, 32 );",
          "56:     SecureZeroMemory( bufRemotePublic, 32 );",
          "58:     if(nResult != 0)",
          "59:     {",
          "60:         return false;",
          "61:     }",
          "63:     GenerateSHA256Digest( bufSharedSecret, sizeof(bufSharedSecret), pSharedSecretOut );",
          "64:     SecureZeroMemory( bufSharedSecret, 32 );",
          "66:     return true;",
          "67: }",
          "69: void CECSigningPrivateKey::GenerateSignature( const void *pData, size_t cbData, CryptoSignature_t *pSignatureOut ) const",
          "70: {",
          "71:     if ( !IsValid() )",
          "72:  {",
          "73:   AssertMsg( false, \"Key not initialized, cannot generate signature\" );",
          "74:         sodium_memzero( pSignatureOut, sizeof( CryptoSignature_t ) );",
          "75:   return;",
          "76:  }",
          "82:     uint8 bufSodiumSecret[crypto_sign_ed25519_SECRETKEYBYTES];",
          "84:     Assert( CCryptoKeyBase_RawBuffer::GetRawDataSize() == 32 );",
          "85:     Assert( sizeof(m_publicKey) == 32 );",
          "86:     Assert( crypto_sign_ed25519_SECRETKEYBYTES == 64 );",
          "88:     memcpy(bufSodiumSecret, CCryptoKeyBase_RawBuffer::GetRawDataPtr(), 32 );",
          "89:     memcpy(bufSodiumSecret + 32, m_publicKey, sizeof(m_publicKey));",
          "91:     crypto_sign_ed25519_detached(*pSignatureOut, nullptr, static_cast<const unsigned char*>( pData ), cbData, bufSodiumSecret );",
          "92:     sodium_memzero(bufSodiumSecret, sizeof(bufSodiumSecret) );",
          "93: }",
          "95: bool CECSigningPublicKey::VerifySignature( const void *pData, size_t cbData, const CryptoSignature_t &signature ) const",
          "96: {",
          "97:     if ( !IsValid() )",
          "98:  {",
          "99:   AssertMsg( false, \"Key not initialized, cannot verify signature\" );",
          "100:   return false;",
          "101:  }",
          "103:     return crypto_sign_ed25519_verify_detached( signature, static_cast<const unsigned char*>( pData ), cbData, CCryptoKeyBase_RawBuffer::GetRawDataPtr() ) == 0;",
          "104: }",
          "106: bool CEC25519PrivateKeyBase::CachePublicKey()",
          "107: {",
          "110:     if ( !IsValid() )",
          "111:     {",
          "112:   return false;",
          "113:     }",
          "115:     if ( m_eKeyType == k_ECryptoKeyTypeKeyExchangePrivate )",
          "116:  {",
          "118:         AssertMsg( sizeof(m_publicKey) == crypto_scalarmult_curve25519_bytes(), \"Public key size mismatch.\" );",
          "119:         AssertMsg( CCryptoKeyBase_RawBuffer::GetRawDataSize() == crypto_scalarmult_curve25519_scalarbytes(), \"Private key size mismatch.\" );",
          "121:         crypto_scalarmult_curve25519_base( m_publicKey, CCryptoKeyBase_RawBuffer::GetRawDataPtr() );",
          "122:     }",
          "123:     else if ( m_eKeyType == k_ECryptoKeyTypeSigningPrivate )",
          "124:     {",
          "127:         AssertMsg( sizeof(m_publicKey) == crypto_sign_ed25519_publickeybytes(), \"Public key size mismatch.\" );",
          "128:         AssertMsg( CCryptoKeyBase_RawBuffer::GetRawDataSize() == crypto_sign_ed25519_seedbytes(), \"Private key size mismatch.\" );",
          "130:         unsigned char h[crypto_hash_sha512_BYTES];",
          "132:         crypto_sign_ed25519_seed_keypair( m_publicKey, h, static_cast<const unsigned char*>( CCryptoKeyBase_RawBuffer::GetRawDataPtr() ) );",
          "134:         sodium_memzero(h, sizeof(h));",
          "135:     }",
          "136:     else",
          "137:     {",
          "138:         Assert( false );",
          "139:         return false;",
          "140:     }",
          "142:     return true;",
          "143: }",
          "145: #endif",
          "",
          "---------------"
        ],
        "src/common/crypto_libsodium.cpp||src/common/crypto_libsodium.cpp": [
          "File: src/common/crypto_libsodium.cpp -> src/common/crypto_libsodium.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"crypto.h\"",
          "3: #include <tier0/vprof.h>",
          "5: #include \"tier0/memdbgoff.h\"",
          "6: #include <sodium.h>",
          "7: #include \"tier0/memdbgon.h\"",
          "9: #ifdef STEAMNETWORKINGSOCKETS_CRYPTO_LIBSODIUM",
          "11: SymmetricCryptContextBase::SymmetricCryptContextBase()",
          "12:     : m_ctx(nullptr), m_cbIV(0), m_cbTag(0)",
          "13: {",
          "14: }",
          "16: void SymmetricCryptContextBase::Wipe()",
          "17: {",
          "18:     sodium_free(m_ctx);",
          "20:     m_ctx = nullptr;",
          "21:     m_cbIV = 0;",
          "22:     m_cbTag = 0;",
          "23: }",
          "25: bool AES_GCM_CipherContext::InitCipher( const void *pKey, size_t cbKey, size_t cbIV, size_t cbTag, bool bEncrypt )",
          "26: {",
          "32:     AssertMsg( crypto_aead_aes256gcm_is_available() == 1, \"No hardware AES support on this CPU.\" );",
          "33:     AssertMsg( cbKey == crypto_aead_aes256gcm_KEYBYTES, \"AES key sizes other than 256 are unsupported.\" );",
          "34:     AssertMsg( cbIV == crypto_aead_aes256gcm_NPUBBYTES, \"Nonce size is unsupported\" );",
          "36:     if(m_ctx == nullptr)",
          "37:     {",
          "38:         m_ctx = sodium_malloc( sizeof(crypto_aead_aes256gcm_state) );",
          "39:     }",
          "41:     crypto_aead_aes256gcm_beforenm( static_cast<crypto_aead_aes256gcm_state*>( m_ctx ), static_cast<const unsigned char*>( pKey ) );",
          "43:     return true;",
          "44: }",
          "46: bool AES_GCM_EncryptContext::Encrypt( const void *pPlaintextData, size_t cbPlaintextData, const void *pIV, void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag, const void *pAdditionalAuthenticationData, size_t cbAuthenticationData )",
          "47: {",
          "48:     unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;",
          "50:     crypto_aead_aes256gcm_encrypt_afternm( static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong, static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData, static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData, nullptr, static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx ) );",
          "54:     return true;",
          "55: }",
          "57: bool AES_GCM_DecryptContext::Decrypt( const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag, const void *pIV, void *pPlaintextData, uint32 *pcbPlaintextData, const void *pAdditionalAuthenticationData, size_t cbAuthenticationData )",
          "58: {",
          "59:     unsigned long long pcbPlaintextData_longlong;",
          "61:     const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm( static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong, nullptr, static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag, static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData, static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx ));",
          "65:     return nDecryptResult == 0;",
          "66: }",
          "68: void CCrypto::Init()",
          "69: {",
          "72:     if(sodium_init() < 0)",
          "73:     {",
          "74:         AssertMsg( false, \"libsodium didn't init\" );",
          "75:     }",
          "76: }",
          "78: void CCrypto::GenerateRandomBlock( void *pubDest, int cubDest )",
          "79: {",
          "80:     VPROF_BUDGET( \"CCrypto::GenerateRandomBlock\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "81:  AssertFatal( cubDest >= 0 );",
          "83:     randombytes_buf( pubDest, cubDest );",
          "84: }",
          "86: void CCrypto::GenerateSHA256Digest( const void *pData, size_t cbData, SHA256Digest_t *pOutputDigest )",
          "87: {",
          "88:     VPROF_BUDGET( \"CCrypto::GenerateSHA256Digest\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "89:  Assert( pData );",
          "90:     Assert( pOutputDigest );",
          "92:     crypto_hash_sha256( *pOutputDigest, static_cast<const unsigned char*>(pData), cbData );",
          "93: }",
          "95: void CCrypto::GenerateHMAC256( const uint8 *pubData, uint32 cubData, const uint8 *pubKey, uint32 cubKey, SHA256Digest_t *pOutputDigest )",
          "96: {",
          "97:     VPROF_BUDGET( \"CCrypto::GenerateHMAC256\", VPROF_BUDGETGROUP_ENCRYPTION );",
          "98:  Assert( pubData );",
          "99:  Assert( cubData > 0 );",
          "100:  Assert( pubKey );",
          "101:  Assert( cubKey > 0 );",
          "102:  Assert( pOutputDigest );",
          "104:     Assert( sizeof(*pOutputDigest) == crypto_auth_hmacsha256_BYTES );",
          "105:     Assert( cubKey == crypto_auth_hmacsha256_KEYBYTES );",
          "107:     crypto_auth_hmacsha256( *pOutputDigest, pubData, cubData, pubKey );",
          "108: }",
          "110: #endif",
          "",
          "---------------"
        ],
        "src/meson.build||src/meson.build": [
          "File: src/meson.build -> src/meson.build",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:   endif",
          "37: endif",
          "39: dependencies += [",
          "40:   dep_threads,",
          "41:   dependency('protobuf', version: '>=3.0.0'),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: if use_crypto == 'libsodium' or use_crypto25519 == 'libsodium'",
          "40:   dependencies += [ dependency('libsodium') ]",
          "41: endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:   sources += [ 'common/crypto_bcrypt.cpp' ]",
          "103: endif",
          "105: if use_crypto25519 == 'OpenSSL'",
          "106:   cpp_flags += [ '-DSTEAMNETWORKINGSOCKETS_CRYPTO_25519_OPENSSL' ]",
          "107:   sources += [ 'common/crypto_25519_openssl.cpp' ]",
          "108: endif",
          "110: if use_crypto25519 == 'Reference'",
          "111:   cpp_flags += [ '-DVALVE_CRYPTO_25519_DONNA' ]",
          "112:   sources += [",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109: if use_crypto == 'libsodium'",
          "110:   if target_machine.cpu_family() != 'x86' and target_machine.cpu_family() != 'x86_64'",
          "111:     error('-Duse_crypto=libsodium invalid, libsodium AES implementation only works on x86/x86_64 CPUs')",
          "112:   endif",
          "113:   cpp_flags += [ '-DSTEAMNETWORKINGSOCKETS_CRYPTO_LIBSODIUM' ]",
          "114:   sources += [ 'common/crypto_libsodium.cpp' ]",
          "115: endif",
          "122: if use_crypto25519 == 'libsodium'",
          "123:   cpp_flags += [ '-DSTEAMNETWORKINGSOCKETS_CRYPTO_25519_LIBSODIUM' ]",
          "124:   sources += [ 'common/crypto_25519_libsodium.cpp' ]",
          "125: endif",
          "",
          "---------------"
        ],
        "tests/test_crypto.cpp||tests/test_crypto.cpp": [
          "File: tests/test_crypto.cpp -> tests/test_crypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:  #endif",
          "312:  TestSymmetricAuthCrypto_EncryptTestVectorFile( TEST_VECTOR_DIR \"gcmEncryptExtIV256.rsp\" );",
          "313: }",
          "",
          "[Removed Lines]",
          "310:  TestSymmetricAuthCrypto_EncryptTestVectorFile( TEST_VECTOR_DIR \"gcmEncryptExtIV128.rsp\" );",
          "311:  TestSymmetricAuthCrypto_EncryptTestVectorFile( TEST_VECTOR_DIR \"gcmEncryptExtIV192.rsp\" );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
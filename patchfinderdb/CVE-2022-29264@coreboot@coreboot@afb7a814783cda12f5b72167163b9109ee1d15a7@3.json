{
  "cve_id": "CVE-2022-29264",
  "cve_desc": "An issue was discovered in coreboot 4.13 through 4.16. On APs, arbitrary code execution in SMM may occur.",
  "repo": "coreboot/coreboot",
  "patch_hash": "afb7a814783cda12f5b72167163b9109ee1d15a7",
  "patch_info": {
    "commit_hash": "afb7a814783cda12f5b72167163b9109ee1d15a7",
    "repo": "coreboot/coreboot",
    "commit_url": "https://github.com/coreboot/coreboot/commit/afb7a814783cda12f5b72167163b9109ee1d15a7",
    "files": [
      "Documentation/releases/coreboot-4.13-relnotes.md",
      "src/cpu/x86/Kconfig",
      "src/cpu/x86/mp_init.c",
      "src/cpu/x86/smm/Makefile.inc",
      "src/cpu/x86/smm/smm_module_loaderv2.c",
      "src/include/cpu/x86/smm.h"
    ],
    "message": "cpu/x86/smm: Introduce SMM module loader version 2\n\nXeon-SP Skylake Scalable Processor can have 36 CPU threads (18 cores).\nCurrent coreboot SMM is unable to handle more than ~32 CPU threads.\nThis patch introduces a version 2 of the SMM module loader which\naddresses this problem. Having two versions of the SMM module loader\nprevents any issues to current projects. Future Xeon-SP products will\nbe using this version of the SMM loader.  Subsequent patches will\nenable board specific functionality for Xeon-SP.\n\nThe reason for moving to version 2 is the state save area begins to\nencroach upon the SMI handling code when more than 32 CPU threads are\nin the system. This can cause system hangs, reboots, etc. The second\nchange is related to staggered entry points with simple near jumps. In\nthe current loader, near jumps will not work because the CPU is jumping\nwithin the same code segment. In version 2, \"far\" address jumps are\nnecessary therefore protected mode must be enabled first. The SMM\nlayout and how the CPUs are staggered are documented in the code.\n\nBy making the modifications above, this allows the smm module loader to\nexpand easily as more CPU threads are added.\n\nTEST=build for Tiogapass platform under OCP mainboard. Enable the\nfollowing in Kconfig.\n        select CPU_INTEL_COMMON_SMM\n        select SOC_INTEL_COMMON_BLOCK_SMM\n        select SMM_TSEG\n        select HAVE_SMI_HANDLER\n        select ACPI_INTEL_HARDWARE_SLEEP_VALUES\n\nDebug console will show all 36 cores relocated. Further tested by\ngenerating SMI's to port 0xb2 using XDP/ITP HW debugger and ensured all\ncores entering and exiting SMM properly. In addition, booted to Linux\n5.4 kernel and observed no issues during mp init.\n\nChange-Id: I00a23a5f2a46110536c344254868390dbb71854c\nSigned-off-by: Rocky Phagura <rphagura@fb.com>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/43684\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: Angel Pons <th3fanbus@gmail.com>",
    "before_after_code_files": [
      "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
      "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc",
      "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
      "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
    ]
  },
  "patch_diff": {
    "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c": [
      "File: src/cpu/x86/mp_init.c -> src/cpu/x86/mp_init.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "729:  perm_smbase = mp_state.perm_smbase;",
      "730:  perm_smbase -= cpu * runtime->save_state_size;",
      "735:  mp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);",
      "737:  if (CONFIG(STM)) {",
      "",
      "[Removed Lines]",
      "732:  printk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);",
      "",
      "[Added Lines]",
      "729: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "730:  perm_smbase = smm_get_cpu_smbase(cpu);",
      "731:  mp_state.perm_smbase = perm_smbase;",
      "732:  if (!perm_smbase) {",
      "733:   printk(BIOS_ERR, \"%s: bad SMBASE for CPU %d\\n\", __func__, cpu);",
      "734:   return;",
      "735:  }",
      "736: #else",
      "739: #endif",
      "742:  printk(BIOS_INFO, \"%s : curr_smbase 0x%x perm_smbase 0x%x, cpu = %d\\n\",",
      "743:   __func__, (int)curr_smbase, (int)perm_smbase, cpu);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "759: static int install_relocation_handler(int num_cpus, size_t save_state_size)",
      "760: {",
      "761:  struct smm_loader_params smm_params = {",
      "762:   .per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,",
      "764:   .per_cpu_save_state_size = save_state_size,",
      "765:   .num_concurrent_save_states = 1,",
      "766:   .handler = smm_do_relocation,",
      "",
      "[Removed Lines]",
      "763:   .num_concurrent_stacks = num_cpus,",
      "",
      "[Added Lines]",
      "770:  int cpus = num_cpus;",
      "771: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "775:  cpus = 1;",
      "776: #endif",
      "780:   .num_concurrent_stacks = cpus,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "770:  if (mp_state.ops.adjust_smm_params != NULL)",
      "771:   mp_state.ops.adjust_smm_params(&smm_params, 0);",
      "774:   return -1;",
      "776:  adjust_smm_apic_id_map(&smm_params);",
      "778:  return 0;",
      "",
      "[Removed Lines]",
      "773:  if (smm_setup_relocation_handler(&smm_params))",
      "",
      "[Added Lines]",
      "790:  if (smm_setup_relocation_handler(&smm_params)) {",
      "791:   printk(BIOS_ERR, \"%s: smm setup failed\\n\", __func__);",
      "793:  }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "794:  if (mp_state.ops.adjust_smm_params != NULL)",
      "795:   mp_state.ops.adjust_smm_params(&smm_params, 1);",
      "799:  if (smm_load_module((void *)smbase, smsize, &smm_params))",
      "800:   return -1;",
      "",
      "[Removed Lines]",
      "797:  printk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);",
      "",
      "[Added Lines]",
      "820:  printk(BIOS_DEBUG, \"Installing permanent SMM handler to 0x%08lx\\n\", smbase);",
      "",
      "---------------"
    ],
    "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc": [
      "File: src/cpu/x86/smm/Makefile.inc -> src/cpu/x86/smm/Makefile.inc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: ## SPDX-License-Identifier: GPL-2.0-only",
      "3: ramstage-y += smm_module_loader.c",
      "4: ramstage-y += smi_trigger.c",
      "6: ifeq ($(CONFIG_ARCH_RAMSTAGE_X86_32),y)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: ifeq ($(CONFIG_X86_SMM_LOADER_VERSION2),y)",
      "4: ramstage-y += smm_module_loaderv2.c",
      "5: else",
      "7: endif",
      "",
      "---------------"
    ],
    "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c": [
      "File: src/cpu/x86/smm/smm_module_loaderv2.c -> src/cpu/x86/smm/smm_module_loaderv2.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: #include <stdint.h>",
      "4: #include <string.h>",
      "5: #include <rmodule.h>",
      "6: #include <cpu/x86/smm.h>",
      "7: #include <commonlib/helpers.h>",
      "8: #include <console/console.h>",
      "9: #include <security/intel/stm/SmmStm.h>",
      "11: #define FXSAVE_SIZE 512",
      "12: #define SMM_CODE_SEGMENT_SIZE 0x10000",
      "14:    SMM stub code relies on the FXSAVE area being non-zero to enable SSE",
      "16: static uint8_t fxsave_area_relocation[CONFIG_MAX_CPUS][FXSAVE_SIZE]",
      "17: __attribute__((aligned(16)));",
      "31: struct smm_stub_params {",
      "32:  u32 stack_size;",
      "33:  u32 stack_top;",
      "34:  u32 c_handler;",
      "35:  u32 c_handler_arg;",
      "36:  u32 fxsave_area;",
      "37:  u32 fxsave_area_size;",
      "38:  struct smm_runtime runtime;",
      "39: } __packed;",
      "45: extern unsigned char _binary_smmstub_start[];",
      "48: #define SMM_MINIMUM_STACK_SIZE 32",
      "50: struct cpu_smm_info {",
      "51:  uint8_t active;",
      "52:  uintptr_t smbase;",
      "53:  uintptr_t entry;",
      "54:  uintptr_t ss_start;",
      "55:  uintptr_t code_start;",
      "56:  uintptr_t code_end;",
      "57: };",
      "58: struct cpu_smm_info cpus[CONFIG_MAX_CPUS] = { 0 };",
      "97: static int smm_create_map(uintptr_t smbase, unsigned int num_cpus,",
      "98:    const struct smm_loader_params *params)",
      "99: {",
      "100:  unsigned int i;",
      "101:  struct rmodule smm_stub;",
      "102:  unsigned int ss_size = params->per_cpu_save_state_size, stub_size;",
      "103:  unsigned int smm_entry_offset = params->smm_main_entry_offset;",
      "104:  unsigned int seg_count = 0, segments = 0, available;",
      "105:  unsigned int cpus_in_segment = 0;",
      "106:  unsigned int base = smbase;",
      "108:  if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {",
      "109:   printk(BIOS_ERR, \"%s: unable to get SMM module size\\n\", __func__);",
      "110:   return 0;",
      "111:  }",
      "113:  stub_size = rmodule_memory_size(&smm_stub);",
      "115:  available = 0xFFFF - smm_entry_offset - ss_size - stub_size;",
      "116:  if (available > 0) {",
      "117:   cpus_in_segment = available / ss_size;",
      "119:   segments = num_cpus / cpus_in_segment + 1;",
      "120:   printk(BIOS_DEBUG,",
      "121:    \"%s: cpus allowed in one segment %d\\n\", __func__, cpus_in_segment);",
      "122:   printk(BIOS_DEBUG,",
      "123:    \"%s: min # of segments needed %d\\n\", __func__, segments);",
      "124:  } else {",
      "125:   printk(BIOS_ERR, \"%s: not enough space in SMM to setup all CPUs\\n\", __func__);",
      "126:   printk(BIOS_ERR, \"    save state & stub size need to be reduced\\n\");",
      "127:   printk(BIOS_ERR, \"    or increase SMRAM size\\n\");",
      "128:   return 0;",
      "129:  }",
      "131:  if (sizeof(cpus) / sizeof(struct cpu_smm_info) < num_cpus) {",
      "132:   printk(BIOS_ERR,",
      "133:    \"%s: increase MAX_CPUS in Kconfig\\n\", __func__);",
      "134:   return 0;",
      "135:  }",
      "137:  for (i = 0; i < num_cpus; i++) {",
      "138:   cpus[i].smbase = base;",
      "139:   cpus[i].entry = base + smm_entry_offset;",
      "140:   cpus[i].ss_start = cpus[i].entry + (smm_entry_offset - ss_size);",
      "141:   cpus[i].code_start = cpus[i].entry;",
      "142:   cpus[i].code_end = cpus[i].entry + stub_size;",
      "143:   cpus[i].active = 1;",
      "144:   base -= ss_size;",
      "145:   seg_count++;",
      "146:   if (seg_count >= cpus_in_segment) {",
      "147:    base -= smm_entry_offset;",
      "148:    seg_count = 0;",
      "149:   }",
      "150:  }",
      "152:  if (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= BIOS_DEBUG) {",
      "153:   seg_count = 0;",
      "154:   for (i = 0; i < num_cpus; i++) {",
      "155:    printk(BIOS_DEBUG, \"CPU 0x%x\\n\", i);",
      "156:    printk(BIOS_DEBUG,",
      "157:     \"    smbase %zx  entry %zx\\n\",",
      "158:     cpus[i].smbase, cpus[i].entry);",
      "159:    printk(BIOS_DEBUG,",
      "160:     \"           ss_start %zx  code_end %zx\\n\",",
      "161:     cpus[i].ss_start, cpus[i].code_end);",
      "162:    seg_count++;",
      "163:    if (seg_count >= cpus_in_segment) {",
      "164:     printk(BIOS_DEBUG,",
      "165:      \"-------------NEW CODE SEGMENT --------------\\n\");",
      "166:     seg_count = 0;",
      "167:    }",
      "168:   }",
      "169:  }",
      "170:  return 1;",
      "171: }",
      "180: u32 smm_get_cpu_smbase(unsigned int cpu_num)",
      "181: {",
      "182:  if (cpu_num < CONFIG_MAX_CPUS) {",
      "183:   if (cpus[cpu_num].active)",
      "184:    return cpus[cpu_num].smbase;",
      "185:  }",
      "186:  return 0;",
      "187: }",
      "217: static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,",
      "218:     unsigned int stack_top, const struct smm_loader_params *params)",
      "219: {",
      "220:  unsigned int i;",
      "221:  unsigned int size;",
      "222:  if (smm_create_map(smbase, num_cpus, params)) {",
      "228:   if (cpus[num_cpus].active) {",
      "229:    if (cpus[num_cpus - 1].smbase +",
      "230:     params->smm_main_entry_offset < stack_top) {",
      "231:     printk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);",
      "232:     printk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",",
      "233:      __func__, cpus[num_cpus].smbase, stack_top);",
      "234:     return 0;",
      "235:    }",
      "236:   }",
      "237:  } else {",
      "238:   printk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);",
      "239:   return 0;",
      "240:  }",
      "242:  printk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\n\",",
      "243:   __func__, cpus[num_cpus-1].smbase, stack_top);",
      "246:  size = cpus[0].code_end - cpus[0].code_start;",
      "247:  for (i = 1; i < num_cpus; i++) {",
      "248:   memcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);",
      "249:   printk(BIOS_DEBUG,",
      "250:    \"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\\n\",",
      "251:    cpus[i].code_start, i);",
      "252:   printk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",",
      "253:    __func__, cpus[0].code_start, cpus[i].code_start, size);",
      "254:  }",
      "255:  return 1;",
      "256: }",
      "262: static void *smm_stub_place_stacks(char *base, size_t size,",
      "263:        struct smm_loader_params *params)",
      "264: {",
      "265:  size_t total_stack_size;",
      "266:  char *stacks_top;",
      "270:  total_stack_size = params->per_cpu_stack_size *",
      "271:       params->num_concurrent_stacks;",
      "272:  printk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",",
      "273:   __func__, params->num_concurrent_stacks,",
      "274:   total_stack_size);",
      "275:  printk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",",
      "276:   size, params->per_cpu_stack_size);",
      "279:  if (params->num_concurrent_stacks < 1)",
      "280:   return NULL;",
      "283:  if (total_stack_size > size)",
      "284:   return NULL;",
      "287:  stacks_top = &base[total_stack_size];",
      "288:  printk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);",
      "290:  return stacks_top;",
      "291: }",
      "298: static int smm_stub_place_staggered_entry_points(char *base,",
      "299:  const struct smm_loader_params *params, const struct rmodule *smm_stub)",
      "300: {",
      "301:  size_t stub_entry_offset;",
      "302:  int rc = 1;",
      "303:  stub_entry_offset = rmodule_entry_offset(smm_stub);",
      "307:  if (params->num_concurrent_save_states > 1 || stub_entry_offset != 0) {",
      "308:   rc = smm_place_entry_code((unsigned int)base,",
      "309:    params->num_concurrent_save_states,",
      "310:    (unsigned int)params->stack_top, params);",
      "311:  }",
      "312:  return rc;",
      "313: }",
      "336: static int smm_module_setup_stub(void *smbase, size_t smm_size,",
      "337:      struct smm_loader_params *params,",
      "338:      void *fxsave_area)",
      "339: {",
      "340:  size_t total_save_state_size;",
      "341:  size_t smm_stub_size;",
      "342:  size_t stub_entry_offset;",
      "343:  char *smm_stub_loc;",
      "344:  void *stacks_top;",
      "345:  size_t size;",
      "346:  char *base;",
      "347:  size_t i;",
      "348:  struct smm_stub_params *stub_params;",
      "349:  struct rmodule smm_stub;",
      "350:  unsigned int total_size_all;",
      "351:  base = smbase;",
      "352:  size = smm_size;",
      "355:  if (params->num_concurrent_stacks > CONFIG_MAX_CPUS) {",
      "356:   printk(BIOS_ERR, \"%s: not enough stacks\\n\", __func__);",
      "357:   return -1;",
      "358:  }",
      "361:  if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {",
      "362:   printk(BIOS_ERR, \"%s: unable to parse smm stub\\n\", __func__);",
      "363:   return -1;",
      "364:  }",
      "367:  total_save_state_size = params->per_cpu_save_state_size *",
      "368:     params->num_concurrent_save_states;",
      "369:  if (total_save_state_size > size) {",
      "370:   printk(BIOS_ERR,",
      "371:    \"%s: more state save space needed:need -> %zx:available->%zx\\n\",",
      "372:    __func__, total_save_state_size, size);",
      "373:   return -1;",
      "374:  }",
      "376:  size -= total_save_state_size;",
      "379:  if (size <= params->smm_main_entry_offset) {",
      "380:   printk(BIOS_ERR, \"%s: encroachment over SMM entry point\\n\", __func__);",
      "381:   printk(BIOS_ERR, \"%s: state save size: %zx : smm_entry_offset -> %x\\n\",",
      "382:    __func__, size, params->smm_main_entry_offset);",
      "383:   return -1;",
      "384:  }",
      "387:  if (params->per_cpu_stack_size <= SMM_MINIMUM_STACK_SIZE ||",
      "388:      (params->per_cpu_stack_size & 3) != 0) {",
      "389:   printk(BIOS_ERR, \"%s: need minimum stack size\\n\", __func__);",
      "390:   return -1;",
      "391:  }",
      "393:  smm_stub_loc = NULL;",
      "394:  smm_stub_size = rmodule_memory_size(&smm_stub);",
      "395:  stub_entry_offset = rmodule_entry_offset(&smm_stub);",
      "398:  smm_stub_loc = &base[params->smm_main_entry_offset];",
      "401:  if (smm_stub_size > (size - params->smm_main_entry_offset)) {",
      "402:   printk(BIOS_ERR, \"%s: stub is too big to fit\\n\", __func__);",
      "403:   return -1;",
      "404:  }",
      "410:  size = params->num_concurrent_stacks * params->per_cpu_stack_size;",
      "411:  stacks_top = smm_stub_place_stacks((char *)params->smram_start, size, params);",
      "412:  if (stacks_top == NULL) {",
      "413:   printk(BIOS_ERR, \"%s: not enough space for stacks\\n\", __func__);",
      "414:   printk(BIOS_ERR, \"%s: ....need -> %p : available -> %zx\\n\", __func__,",
      "415:    base, size);",
      "416:   return -1;",
      "417:  }",
      "418:  params->stack_top = stacks_top;",
      "420:  if (rmodule_load(smm_stub_loc, &smm_stub)) {",
      "421:   printk(BIOS_ERR, \"%s: load module failed\\n\", __func__);",
      "422:   return -1;",
      "423:  }",
      "425:  if (!smm_stub_place_staggered_entry_points(base, params, &smm_stub)) {",
      "426:   printk(BIOS_ERR, \"%s: staggered entry points failed\\n\", __func__);",
      "427:   return -1;",
      "428:  }",
      "431:  stub_params = rmodule_parameters(&smm_stub);",
      "432:  stub_params->stack_top = (uintptr_t)stacks_top;",
      "433:  stub_params->stack_size = params->per_cpu_stack_size;",
      "434:  stub_params->c_handler = (uintptr_t)params->handler;",
      "435:  stub_params->c_handler_arg = (uintptr_t)params->handler_arg;",
      "436:  stub_params->fxsave_area = (uintptr_t)fxsave_area;",
      "437:  stub_params->fxsave_area_size = FXSAVE_SIZE;",
      "438:  stub_params->runtime.smbase = (uintptr_t)smbase;",
      "439:  stub_params->runtime.smm_size = smm_size;",
      "440:  stub_params->runtime.save_state_size = params->per_cpu_save_state_size;",
      "441:  stub_params->runtime.num_cpus = params->num_concurrent_stacks;",
      "443:  printk(BIOS_DEBUG, \"%s: stack_end = 0x%x\\n\",",
      "444:   __func__, stub_params->runtime.smbase);",
      "445:  printk(BIOS_DEBUG,",
      "446:   \"%s: stack_top = 0x%x\\n\", __func__, stub_params->stack_top);",
      "447:  printk(BIOS_DEBUG, \"%s: stack_size = 0x%x\\n\",",
      "448:   __func__, stub_params->stack_size);",
      "449:  printk(BIOS_DEBUG, \"%s: runtime.smbase = 0x%x\\n\",",
      "450:   __func__, stub_params->runtime.smbase);",
      "451:  printk(BIOS_DEBUG, \"%s: runtime.start32_offset = 0x%x\\n\", __func__,",
      "452:   stub_params->runtime.start32_offset);",
      "453:  printk(BIOS_DEBUG, \"%s: runtime.smm_size = 0x%zx\\n\",",
      "454:   __func__, smm_size);",
      "455:  printk(BIOS_DEBUG, \"%s: per_cpu_save_state_size = 0x%x\\n\",",
      "456:   __func__, stub_params->runtime.save_state_size);",
      "457:  printk(BIOS_DEBUG, \"%s: num_cpus = 0x%x\\n\", __func__,",
      "458:   stub_params->runtime.num_cpus);",
      "459:  printk(BIOS_DEBUG, \"%s: total_save_state_size = 0x%x\\n\",",
      "460:   __func__, (stub_params->runtime.save_state_size *",
      "461:   stub_params->runtime.num_cpus));",
      "462:  total_size_all = stub_params->stack_size +",
      "463:   (stub_params->runtime.save_state_size *",
      "464:   stub_params->runtime.num_cpus);",
      "465:  printk(BIOS_DEBUG, \"%s: total_size_all = 0x%x\\n\", __func__,",
      "466:   total_size_all);",
      "469:  for (i = 0; i < params->num_concurrent_stacks; i++)",
      "470:   stub_params->runtime.apic_id_to_cpu[i] = i;",
      "473:  params->runtime = &stub_params->runtime;",
      "475:  printk(BIOS_DEBUG, \"SMM Module: stub loaded at %p. Will call %p(%p)\\n\",",
      "476:         smm_stub_loc, params->handler, params->handler_arg);",
      "477:  return 0;",
      "478: }",
      "486: int smm_setup_relocation_handler(struct smm_loader_params *params)",
      "487: {",
      "488:  void *smram = (void *)(SMM_DEFAULT_BASE);",
      "489:  printk(BIOS_SPEW, \"%s: enter\\n\", __func__);",
      "492:  if (params->num_concurrent_save_states > 1)",
      "493:   return -1;",
      "496:  if (params->handler == NULL)",
      "497:   return -1;",
      "501:  if (params->num_concurrent_stacks == 0)",
      "502:   params->num_concurrent_stacks = CONFIG_MAX_CPUS;",
      "504:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
      "505:  params->smram_start = SMM_DEFAULT_BASE;",
      "506:  params->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;",
      "507:  return smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,",
      "508:     params, fxsave_area_relocation);",
      "509:  printk(BIOS_SPEW, \"%s: exit\\n\", __func__);",
      "510: }",
      "538: int smm_load_module(void *smram, size_t size, struct smm_loader_params *params)",
      "539: {",
      "540:  struct rmodule smm_mod;",
      "541:  size_t total_stack_size;",
      "542:  size_t handler_size;",
      "543:  size_t module_alignment;",
      "544:  size_t alignment_size;",
      "545:  size_t fxsave_size;",
      "546:  void *fxsave_area;",
      "547:  size_t total_size = 0;",
      "548:  char *base;",
      "550:  if (size <= SMM_DEFAULT_SIZE)",
      "551:   return -1;",
      "556:  base = smram;",
      "557:  base += size;",
      "558:  params->smram_start = (uintptr_t)smram;",
      "559:  params->smram_end = params->smram_start + size;",
      "560:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
      "563:  if (rmodule_parse(&_binary_smm_start, &smm_mod))",
      "564:   return -1;",
      "567:  if (CONFIG(DEBUG_SMI))",
      "568:   memset(smram, 0xcd, size);",
      "570:  total_stack_size = params->per_cpu_stack_size *",
      "571:       params->num_concurrent_stacks;",
      "572:  total_size += total_stack_size;",
      "574:  params->stack_top = smram + total_stack_size;",
      "577:  if (CONFIG(STM)) {",
      "578:   base -= CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;",
      "579:   total_size += CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;",
      "580:  }",
      "583:  if (CONFIG(SSE)) {",
      "584:   fxsave_size = FXSAVE_SIZE * params->num_concurrent_stacks;",
      "585:   fxsave_area = base - fxsave_size;",
      "586:   base -= fxsave_size;",
      "587:   total_size += fxsave_size;",
      "588:  } else {",
      "589:   fxsave_size = 0;",
      "590:   fxsave_area = NULL;",
      "591:  }",
      "594:  handler_size = rmodule_memory_size(&smm_mod);",
      "595:  base -= handler_size;",
      "596:  total_size += handler_size;",
      "597:  module_alignment = rmodule_load_alignment(&smm_mod);",
      "598:  alignment_size = module_alignment -",
      "599:     ((uintptr_t)base % module_alignment);",
      "600:  if (alignment_size != module_alignment) {",
      "601:   handler_size += alignment_size;",
      "602:   base += alignment_size;",
      "603:  }",
      "605:  printk(BIOS_DEBUG,",
      "606:   \"%s: total_smm_space_needed %zx, available -> %zx\\n\",",
      "607:    __func__, total_size, size);",
      "610:  if (total_size > size) {",
      "611:   printk(BIOS_ERR, \"%s: need more SMRAM\\n\", __func__);",
      "612:   return -1;",
      "613:  }",
      "614:  if (handler_size > SMM_CODE_SEGMENT_SIZE) {",
      "615:   printk(BIOS_ERR, \"%s: increase SMM_CODE_SEGMENT_SIZE: handler_size = %zx\\n\",",
      "616:    __func__, handler_size);",
      "617:   return -1;",
      "618:  }",
      "620:  if (rmodule_load(base, &smm_mod))",
      "621:   return -1;",
      "623:  params->handler = rmodule_entry(&smm_mod);",
      "624:  params->handler_arg = rmodule_parameters(&smm_mod);",
      "626:  printk(BIOS_DEBUG, \"%s: smram_start: 0x%p\\n\",",
      "627:    __func__, smram);",
      "628:  printk(BIOS_DEBUG, \"%s: smram_end: %p\\n\",",
      "629:    __func__, smram + size);",
      "630:  printk(BIOS_DEBUG, \"%s: stack_top: %p\\n\",",
      "631:    __func__, params->stack_top);",
      "632:  printk(BIOS_DEBUG, \"%s: handler start %p\\n\",",
      "633:    __func__, params->handler);",
      "634:  printk(BIOS_DEBUG, \"%s: handler_size %zx\\n\",",
      "635:    __func__, handler_size);",
      "636:  printk(BIOS_DEBUG, \"%s: handler_arg %p\\n\",",
      "637:    __func__, params->handler_arg);",
      "638:  printk(BIOS_DEBUG, \"%s: fxsave_area %p\\n\",",
      "639:    __func__, fxsave_area);",
      "640:  printk(BIOS_DEBUG, \"%s: fxsave_size %zx\\n\",",
      "641:    __func__, fxsave_size);",
      "642:  printk(BIOS_DEBUG, \"%s: CONFIG_MSEG_SIZE 0x%x\\n\",",
      "643:    __func__, CONFIG_MSEG_SIZE);",
      "644:  printk(BIOS_DEBUG, \"%s: CONFIG_BIOS_RESOURCE_LIST_SIZE 0x%x\\n\",",
      "645:    __func__, CONFIG_BIOS_RESOURCE_LIST_SIZE);",
      "650:  base -= SMM_CODE_SEGMENT_SIZE;",
      "651:  printk(BIOS_DEBUG, \"%s: cpu0 entry: %p\\n\",",
      "652:    __func__, base);",
      "653:  params->smm_entry = (uintptr_t)base + params->smm_main_entry_offset;",
      "654:  return smm_module_setup_stub(base, size, params, fxsave_area);",
      "655: }",
      "",
      "---------------"
    ],
    "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h": [
      "File: src/include/cpu/x86/smm.h -> src/include/cpu/x86/smm.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "141:  void *handler_arg;",
      "143:  struct smm_runtime *runtime;",
      "144: };",
      "147: int smm_setup_relocation_handler(struct smm_loader_params *params);",
      "148: int smm_load_module(void *smram, size_t size, struct smm_loader_params *params);",
      "151: void *backup_default_smm_area(void);",
      "152: void restore_default_smm_area(void *smm_save_area);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "152: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "153:  unsigned int smm_entry;",
      "154:  unsigned int smm_main_entry_offset;",
      "155:  unsigned int smram_start;",
      "156:  unsigned int smram_end;",
      "157: #endif",
      "164: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "165: u32 smm_get_cpu_smbase(unsigned int cpu_num);",
      "166: #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9036bd7cb1b4939797372a4e517914a45e29155b",
      "candidate_info": {
        "commit_hash": "9036bd7cb1b4939797372a4e517914a45e29155b",
        "repo": "coreboot/coreboot",
        "commit_url": "https://github.com/coreboot/coreboot/commit/9036bd7cb1b4939797372a4e517914a45e29155b",
        "files": [
          "src/cpu/x86/mp_init.c",
          "src/include/cpu/x86/smm.h"
        ],
        "message": "cpu/x86/mp_init.c: Drop unnecessary preprocessor usage\n\nChange-Id: If67bcbf0c8ffbd041e2e4cab8496f4634de26552\nSigned-off-by: Arthur Heymans <arthur@aheymans.xyz>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/51185\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: Angel Pons <th3fanbus@gmail.com>",
        "before_after_code_files": [
          "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
          "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ],
          "candidate": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ]
        }
      },
      "candidate_diff": {
        "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c": [
          "File: src/cpu/x86/mp_init.c -> src/cpu/x86/mp_init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:  }",
          "745:  printk(BIOS_INFO, \"%s : curr_smbase 0x%x perm_smbase 0x%x, cpu = %d\\n\",",
          "",
          "[Removed Lines]",
          "733: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "734:  perm_smbase = smm_get_cpu_smbase(cpu);",
          "735:  if (!perm_smbase) {",
          "736:   printk(BIOS_ERR, \"%s: bad SMBASE for CPU %d\\n\", __func__, cpu);",
          "737:   return;",
          "739: #else",
          "740:  perm_smbase = mp_state.perm_smbase;",
          "741:  perm_smbase -= cpu * mp_state.smm_save_state_size;",
          "742: #endif",
          "",
          "[Added Lines]",
          "733:  if (CONFIG(X86_SMM_LOADER_VERSION2)) {",
          "734:   perm_smbase = smm_get_cpu_smbase(cpu);",
          "735:   if (!perm_smbase) {",
          "736:    printk(BIOS_ERR, \"%s: bad SMBASE for CPU %d\\n\", __func__, cpu);",
          "737:    return;",
          "738:   }",
          "739:  } else {",
          "740:   perm_smbase = mp_state.perm_smbase;",
          "741:   perm_smbase -= cpu * mp_state.smm_save_state_size;",
          "",
          "---------------"
        ],
        "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h": [
          "File: src/include/cpu/x86/smm.h -> src/include/cpu/x86/smm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "151: int smm_setup_relocation_handler(struct smm_loader_params *params);",
          "152: int smm_load_module(void *smram, size_t size, struct smm_loader_params *params);",
          "155: u32 smm_get_cpu_smbase(unsigned int cpu_num);",
          "159: void *backup_default_smm_area(void);",
          "",
          "[Removed Lines]",
          "154: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "156: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b17f11e19d50ea0c34eabdc4c7189291fb96536a",
      "candidate_info": {
        "commit_hash": "b17f11e19d50ea0c34eabdc4c7189291fb96536a",
        "repo": "coreboot/coreboot",
        "commit_url": "https://github.com/coreboot/coreboot/commit/b17f11e19d50ea0c34eabdc4c7189291fb96536a",
        "files": [
          "src/cpu/x86/smm/smm_module_loaderv2.c"
        ],
        "message": "cpu/x86/smm/smm_module_loaderv2.c: Use more variables\n\nReusing the 'size' variable for a different purpose later on in the\nfunction makes the code harder to read.\n\nChange-Id: Iceb10aa40ad473b41b7da0310554725585e3c2c2\nSigned-off-by: Arthur Heymans <arthur@aheymans.xyz>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/47070\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: David Hendricks <david.hendricks@gmail.com>\nReviewed-by: Angel Pons <th3fanbus@gmail.com>",
        "before_after_code_files": [
          "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c"
          ],
          "candidate": [
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c"
          ]
        }
      },
      "candidate_diff": {
        "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c": [
          "File: src/cpu/x86/smm/smm_module_loaderv2.c -> src/cpu/x86/smm/smm_module_loaderv2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "418:  if (stacks_top == NULL) {",
          "419:   printk(BIOS_ERR, \"%s: not enough space for stacks\\n\", __func__);",
          "420:   printk(BIOS_ERR, \"%s: ....need -> %p : available -> %zx\\n\", __func__,",
          "422:   return -1;",
          "423:  }",
          "424:  params->stack_top = stacks_top;",
          "",
          "[Removed Lines]",
          "416:  size = params->num_concurrent_stacks * params->per_cpu_stack_size;",
          "417:  stacks_top = smm_stub_place_stacks((char *)params->smram_start, size, params);",
          "421:    base, size);",
          "",
          "[Added Lines]",
          "416:  const size_t total_stack_size = params->num_concurrent_stacks *",
          "417:   params->per_cpu_stack_size;",
          "418:  stacks_top = smm_stub_place_stacks((char *)params->smram_start, total_stack_size,",
          "419:         params);",
          "423:    base, total_stack_size);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-13099",
  "cve_desc": "An issue was discovered in fs/f2fs/inline.c in the Linux kernel through 4.4. A denial of service (out-of-bounds memory access and BUG) can occur for a modified f2fs filesystem image in which an inline inode contains an invalid reserved blkaddr.",
  "repo": "torvalds/linux",
  "patch_hash": "4dbe38dc386910c668c75ae616b99b823b59f3eb",
  "patch_info": {
    "commit_hash": "4dbe38dc386910c668c75ae616b99b823b59f3eb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4dbe38dc386910c668c75ae616b99b823b59f3eb",
    "files": [
      "fs/f2fs/inline.c"
    ],
    "message": "f2fs: fix to do sanity check with reserved blkaddr of inline inode\n\nAs Wen Xu reported in bugzilla, after image was injected with random data\nby fuzzing, inline inode would contain invalid reserved blkaddr, then\nduring inline conversion, we will encounter illegal memory accessing\nreported by KASAN, the root cause of this is when writing out converted\ninline page, we will use invalid reserved blkaddr to update sit bitmap,\nresult in accessing memory beyond sit bitmap boundary.\n\nIn order to fix this issue, let's do sanity check with reserved block\naddress of inline inode to avoid above condition.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200179\n\n[ 1428.846352] BUG: KASAN: use-after-free in update_sit_entry+0x80/0x7f0\n[ 1428.846618] Read of size 4 at addr ffff880194483540 by task a.out/2741\n\n[ 1428.846855] CPU: 0 PID: 2741 Comm: a.out Tainted: G        W         4.17.0+ #1\n[ 1428.846858] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[ 1428.846860] Call Trace:\n[ 1428.846868]  dump_stack+0x71/0xab\n[ 1428.846875]  print_address_description+0x6b/0x290\n[ 1428.846881]  kasan_report+0x28e/0x390\n[ 1428.846888]  ? update_sit_entry+0x80/0x7f0\n[ 1428.846898]  update_sit_entry+0x80/0x7f0\n[ 1428.846906]  f2fs_allocate_data_block+0x6db/0xc70\n[ 1428.846914]  ? f2fs_get_node_info+0x14f/0x590\n[ 1428.846920]  do_write_page+0xc8/0x150\n[ 1428.846928]  f2fs_outplace_write_data+0xfe/0x210\n[ 1428.846935]  ? f2fs_do_write_node_page+0x170/0x170\n[ 1428.846941]  ? radix_tree_tag_clear+0xff/0x130\n[ 1428.846946]  ? __mod_node_page_state+0x22/0xa0\n[ 1428.846951]  ? inc_zone_page_state+0x54/0x100\n[ 1428.846956]  ? __test_set_page_writeback+0x336/0x5d0\n[ 1428.846964]  f2fs_convert_inline_page+0x407/0x6d0\n[ 1428.846971]  ? f2fs_read_inline_data+0x3b0/0x3b0\n[ 1428.846978]  ? __get_node_page+0x335/0x6b0\n[ 1428.846987]  f2fs_convert_inline_inode+0x41b/0x500\n[ 1428.846994]  ? f2fs_convert_inline_page+0x6d0/0x6d0\n[ 1428.847000]  ? kasan_unpoison_shadow+0x31/0x40\n[ 1428.847005]  ? kasan_kmalloc+0xa6/0xd0\n[ 1428.847024]  f2fs_file_mmap+0x79/0xc0\n[ 1428.847029]  mmap_region+0x58b/0x880\n[ 1428.847037]  ? arch_get_unmapped_area+0x370/0x370\n[ 1428.847042]  do_mmap+0x55b/0x7a0\n[ 1428.847048]  vm_mmap_pgoff+0x16f/0x1c0\n[ 1428.847055]  ? vma_is_stack_for_current+0x50/0x50\n[ 1428.847062]  ? __fsnotify_update_child_dentry_flags.part.1+0x160/0x160\n[ 1428.847068]  ? do_sys_open+0x206/0x2a0\n[ 1428.847073]  ? __fget+0xb4/0x100\n[ 1428.847079]  ksys_mmap_pgoff+0x278/0x360\n[ 1428.847085]  ? find_mergeable_anon_vma+0x50/0x50\n[ 1428.847091]  do_syscall_64+0x73/0x160\n[ 1428.847098]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[ 1428.847102] RIP: 0033:0x7fb1430766ba\n[ 1428.847103] Code: 89 f5 41 54 49 89 fc 55 53 74 35 49 63 e8 48 63 da 4d 89 f9 49 89 e8 4d 63 d6 48 89 da 4c 89 ee 4c 89 e7 b8 09 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 56 5b 5d 41 5c 41 5d 41 5e 41 5f c3 0f 1f 00\n[ 1428.847162] RSP: 002b:00007ffc651d9388 EFLAGS: 00000246 ORIG_RAX: 0000000000000009\n[ 1428.847167] RAX: ffffffffffffffda RBX: 0000000000000001 RCX: 00007fb1430766ba\n[ 1428.847170] RDX: 0000000000000001 RSI: 0000000000001000 RDI: 0000000000000000\n[ 1428.847173] RBP: 0000000000000003 R08: 0000000000000003 R09: 0000000000000000\n[ 1428.847176] R10: 0000000000008002 R11: 0000000000000246 R12: 0000000000000000\n[ 1428.847179] R13: 0000000000001000 R14: 0000000000008002 R15: 0000000000000000\n\n[ 1428.847252] Allocated by task 2683:\n[ 1428.847372]  kasan_kmalloc+0xa6/0xd0\n[ 1428.847380]  kmem_cache_alloc+0xc8/0x1e0\n[ 1428.847385]  getname_flags+0x73/0x2b0\n[ 1428.847390]  user_path_at_empty+0x1d/0x40\n[ 1428.847395]  vfs_statx+0xc1/0x150\n[ 1428.847401]  __do_sys_newlstat+0x7e/0xd0\n[ 1428.847405]  do_syscall_64+0x73/0x160\n[ 1428.847411]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[ 1428.847466] Freed by task 2683:\n[ 1428.847566]  __kasan_slab_free+0x137/0x190\n[ 1428.847571]  kmem_cache_free+0x85/0x1e0\n[ 1428.847575]  filename_lookup+0x191/0x280\n[ 1428.847580]  vfs_statx+0xc1/0x150\n[ 1428.847585]  __do_sys_newlstat+0x7e/0xd0\n[ 1428.847590]  do_syscall_64+0x73/0x160\n[ 1428.847596]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[ 1428.847648] The buggy address belongs to the object at ffff880194483300\n                which belongs to the cache names_cache of size 4096\n[ 1428.847946] The buggy address is located 576 bytes inside of\n                4096-byte region [ffff880194483300, ffff880194484300)\n[ 1428.848234] The buggy address belongs to the page:\n[ 1428.848366] page:ffffea0006512000 count:1 mapcount:0 mapping:ffff8801f3586380 index:0x0 compound_mapcount: 0\n[ 1428.848606] flags: 0x17fff8000008100(slab|head)\n[ 1428.848737] raw: 017fff8000008100 dead000000000100 dead000000000200 ffff8801f3586380\n[ 1428.848931] raw: 0000000000000000 0000000000070007 00000001ffffffff 0000000000000000\n[ 1428.849122] page dumped because: kasan: bad access detected\n\n[ 1428.849305] Memory state around the buggy address:\n[ 1428.849436]  ffff880194483400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.849620]  ffff880194483480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.849804] >ffff880194483500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.849985]                                            ^\n[ 1428.850120]  ffff880194483580: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.850303]  ffff880194483600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.850498] ==================================================================\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/inline.c||fs/f2fs/inline.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/inline.c||fs/f2fs/inline.c": [
      "File: fs/f2fs/inline.c -> fs/f2fs/inline.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130:  if (err)",
      "131:   return err;",
      "133:  f2fs_bug_on(F2FS_P_SB(page), PageWriteback(page));",
      "135:  f2fs_do_read_inline_data(page, dn->inode_page);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:  if (unlikely(dn->data_blkaddr != NEW_ADDR)) {",
      "134:   f2fs_put_dnode(dn);",
      "135:   set_sbi_flag(fio.sbi, SBI_NEED_FSCK);",
      "136:   f2fs_msg(fio.sbi->sb, KERN_WARNING,",
      "137:    \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"",
      "138:    \"run fsck to fix.\",",
      "139:    __func__, dn->inode->i_ino, dn->data_blkaddr);",
      "140:   return -EINVAL;",
      "141:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "363:  if (err)",
      "364:   goto out;",
      "366:  f2fs_wait_on_page_writeback(page, DATA, true);",
      "368:  dentry_blk = page_address(page);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "376:  if (unlikely(dn.data_blkaddr != NEW_ADDR)) {",
      "377:   f2fs_put_dnode(&dn);",
      "378:   set_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);",
      "379:   f2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,",
      "380:    \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"",
      "381:    \"run fsck to fix.\",",
      "382:    __func__, dir->i_ino, dn.data_blkaddr);",
      "383:   err = -EINVAL;",
      "384:   goto out;",
      "385:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9b3d9bb3e4deef41095e513c2ffbebab20f9a982",
      "candidate_info": {
        "commit_hash": "9b3d9bb3e4deef41095e513c2ffbebab20f9a982",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9b3d9bb3e4deef41095e513c2ffbebab20f9a982",
        "files": [
          "drivers/cpufreq/cpufreq.c"
        ],
        "message": "cpufreq: Fix a circular lock dependency problem\n\nWith lockdep turned on, the following circular lock dependency problem\nwas reported:\n\n[   57.470040] ======================================================\n[   57.502900] WARNING: possible circular locking dependency detected\n[   57.535208] 4.18.0-0.rc3.1.el8+7.x86_64+debug #1 Tainted: G\n[   57.577761] ------------------------------------------------------\n[   57.609714] tuned/1505 is trying to acquire lock:\n[   57.633808] 00000000559deec5 (cpu_hotplug_lock.rw_sem){++++}, at: store+0x27/0x120\n[   57.672880]\n[   57.672880] but task is already holding lock:\n[   57.702184] 000000002136ca64 (kn->count#118){++++}, at: kernfs_fop_write+0x1d0/0x410\n[   57.742176]\n[   57.742176] which lock already depends on the new lock.\n[   57.742176]\n[   57.785220]\n[   57.785220] the existing dependency chain (in reverse order) is:\n    :\n[   58.932512] other info that might help us debug this:\n[   58.932512]\n[   58.973344] Chain exists of:\n[   58.973344]   cpu_hotplug_lock.rw_sem --> subsys mutex#5 --> kn->count#118\n[   58.973344]\n[   59.030795]  Possible unsafe locking scenario:\n[   59.030795]\n[   59.061248]        CPU0                    CPU1\n[   59.085377]        ----                    ----\n[   59.108160]   lock(kn->count#118);\n[   59.124935]                                lock(subsys mutex#5);\n[   59.156330]                                lock(kn->count#118);\n[   59.186088]   lock(cpu_hotplug_lock.rw_sem);\n[   59.208541]\n[   59.208541]  *** DEADLOCK ***\n\nIn the cpufreq_register_driver() function, the lock sequence is:\n\n  cpus_read_lock --> kn->count\n\nFor the cpufreq sysfs store method, the lock sequence is:\n\n  kn->count --> cpus_read_lock\n\nThese sequences are actually safe as they are taking a share lock on\ncpu_hotplug_lock. However, the current lockdep code doesn't check for\nshare locking when detecting circular lock dependency.  Fixing that\ncould be a substantial effort.\n\nInstead, we can work around this problem by using cpus_read_trylock()\nin the store method which is much simpler. The chance of not getting\nthe read lock is very small. If that happens, the userspace application\nthat writes the sysfs file will get an error.\n\nSigned-off-by: Waiman Long <longman@redhat.com>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
        "before_after_code_files": [
          "drivers/cpufreq/cpufreq.c||drivers/cpufreq/cpufreq.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/cpufreq/cpufreq.c||drivers/cpufreq/cpufreq.c": [
          "File: drivers/cpufreq/cpufreq.c -> drivers/cpufreq/cpufreq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "923:  struct freq_attr *fattr = to_attr(attr);",
          "924:  ssize_t ret = -EINVAL;",
          "928:  if (cpu_online(policy->cpu)) {",
          "929:   down_write(&policy->rwsem);",
          "",
          "[Removed Lines]",
          "926:  cpus_read_lock();",
          "",
          "[Added Lines]",
          "930:  if (!cpus_read_trylock())",
          "931:   return -EBUSY;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b17b113e0c38e94c2f8c0763926c6a2168293201",
      "candidate_info": {
        "commit_hash": "b17b113e0c38e94c2f8c0763926c6a2168293201",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b17b113e0c38e94c2f8c0763926c6a2168293201",
        "files": [
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h"
        ],
        "message": "mlxsw: spectrum_acl: Add support for C-TCAM eRPs\n\nThe number of eRPs that can be used by a single A-TCAM region is limited\nto 16. When more eRPs are needed, an ordinary circuit TCAM (C-TCAM) can\nbe used to hold the extra eRPs.\n\nUnlike the A-TCAM, only a single (last) lookup is performed in the\nC-TCAM and not a lookup per-eRP. However, modeling the C-TCAM as extra\neRPs will allow us to easily introduce support for pruning in a\nfollow-up patch set and is also logically correct.\n\nThe following diagram depicts the relation between both TCAMs:\n                                                                 C-TCAM\n+-------------------+               +--------------------+    +-----------+\n|                   |               |                    |    |           |\n|  eRP #1 (A-TCAM)  +----> ... +----+  eRP #16 (A-TCAM)  +----+  eRP #17  |\n|                   |               |                    |    |    ...    |\n+-------------------+               +--------------------+    |  eRP #N   |\n                                                              |           |\n                                                              +-----------+\nLookup order is from left to right.\n\nExtend the eRP core APIs with a C-TCAM parameter which indicates whether\nthe requested eRP is to be used with the C-TCAM or not.\n\nSince the C-TCAM is only meant to absorb rules that can't fit in the\nA-TCAM due to exceeded number of eRPs or key collision, an error is\nreturned when a C-TCAM eRP needs to be created when the eRP state\nmachine is in its initial state (i.e., 'no masks'). This should only\nhappen in the face of very unlikely errors when trying to push rules\ninto the A-TCAM.\n\nIn order not to perform unnecessary lookups, the eRP core will only\nenable a C-TCAM lookup for a given region if it knows there are C-TCAM\neRPs present.\n\nSigned-off-by: Ido Schimmel <idosch@mellanox.com>\nReviewed-by: Jiri Pirko <jiri@mellanox.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c": [
          "File: drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c -> drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: struct mlxsw_sp_acl_erp_key {",
          "62:  char mask[MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN];",
          "63: };",
          "65: struct mlxsw_sp_acl_erp {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:  bool ctcam;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:  unsigned long base_index;",
          "91:  unsigned int num_atcam_erps;",
          "92:  unsigned int num_max_atcam_erps;",
          "93: };",
          "95: static const struct rhashtable_params mlxsw_sp_acl_erp_ht_params = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:  unsigned int num_ctcam_erps;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448: }",
          "450: static int",
          "452: {",
          "453:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "454:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "455:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "458:          erp_table->base_index, 0);",
          "459:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "460:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "451: mlxsw_sp_acl_erp_table_enable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "457:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "453: mlxsw_sp_acl_erp_table_enable(struct mlxsw_sp_acl_erp_table *erp_table,",
          "454:          bool ctcam_le)",
          "460:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "471:  struct mlxsw_sp_acl_erp *master_rp;",
          "473:  master_rp = mlxsw_sp_acl_erp_table_master_rp(erp_table);",
          "477:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, false, 0, 0,",
          "479:  mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);",
          "480: }",
          "",
          "[Removed Lines]",
          "474:  if (!master_rp)",
          "475:   return;",
          "478:          master_rp->id);",
          "",
          "[Added Lines]",
          "482:          master_rp ? master_rp->id : 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "506:  unsigned int num_erps, old_num_erps = erp_table->num_max_atcam_erps;",
          "507:  struct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;",
          "508:  unsigned long old_base_index = erp_table->base_index;",
          "509:  int err;",
          "511:  if (erp_table->num_atcam_erps < erp_table->num_max_atcam_erps)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "513:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "526:  if (err)",
          "527:   goto err_table_relocate;",
          "530:  if (err)",
          "531:   goto err_table_enable;",
          "",
          "[Removed Lines]",
          "529:  err = mlxsw_sp_acl_erp_table_enable(erp_table);",
          "",
          "[Added Lines]",
          "534:  err = mlxsw_sp_acl_erp_table_enable(erp_table, ctcam_le);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "579:  if (err)",
          "580:   goto err_table_master_rp_add;",
          "583:  if (err)",
          "584:   goto err_table_enable;",
          "",
          "[Removed Lines]",
          "582:  err = mlxsw_sp_acl_erp_table_enable(erp_table);",
          "",
          "[Added Lines]",
          "587:  err = mlxsw_sp_acl_erp_table_enable(erp_table, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "619: {",
          "620:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "621:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "622:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "625:          erp_table->base_index, 0);",
          "626:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "627:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "624:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "627:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "630:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "635:  struct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;",
          "636:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "637:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "638:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "641:          erp_table->base_index, 0);",
          "642:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "643:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "640:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "644:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "647:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "646:  mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);",
          "647: }",
          "649: static struct mlxsw_sp_acl_erp *",
          "650: mlxsw_sp_acl_erp_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "651:         struct mlxsw_sp_acl_erp_key *key)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656: static int",
          "657: mlxsw_sp_acl_erp_region_ctcam_enable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "658: {",
          "660:  if (erp_table->num_ctcam_erps > 1)",
          "661:   return 0;",
          "663:  return mlxsw_sp_acl_erp_table_enable(erp_table, true);",
          "664: }",
          "666: static void",
          "667: mlxsw_sp_acl_erp_region_ctcam_disable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "668: {",
          "670:  if (erp_table->num_ctcam_erps > 1)",
          "671:   return;",
          "673:  mlxsw_sp_acl_erp_table_enable(erp_table, false);",
          "674: }",
          "676: static void",
          "677: mlxsw_sp_acl_erp_ctcam_table_ops_set(struct mlxsw_sp_acl_erp_table *erp_table)",
          "678: {",
          "679:  switch (erp_table->num_atcam_erps) {",
          "680:  case 2:",
          "685:   erp_table->ops = &erp_two_masks_ops;",
          "686:   break;",
          "687:  case 1:",
          "693:   mlxsw_sp_acl_erp_region_master_mask_trans(erp_table);",
          "694:   erp_table->ops = &erp_single_mask_ops;",
          "695:   break;",
          "696:  case 0:",
          "700:   mlxsw_sp_acl_erp_table_disable(erp_table);",
          "701:   mlxsw_sp_acl_erp_table_free(erp_table->erp_core,",
          "702:          erp_table->num_max_atcam_erps,",
          "703:          erp_table->aregion->type,",
          "704:          erp_table->base_index);",
          "705:   erp_table->ops = &erp_no_mask_ops;",
          "706:   break;",
          "707:  default:",
          "708:   break;",
          "709:  }",
          "710: }",
          "712: static struct mlxsw_sp_acl_erp *",
          "713: __mlxsw_sp_acl_erp_ctcam_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "714:          struct mlxsw_sp_acl_erp_key *key)",
          "715: {",
          "716:  struct mlxsw_sp_acl_erp *erp;",
          "717:  int err;",
          "719:  erp = kzalloc(sizeof(*erp), GFP_KERNEL);",
          "720:  if (!erp)",
          "721:   return ERR_PTR(-ENOMEM);",
          "723:  memcpy(&erp->key, key, sizeof(*key));",
          "724:  bitmap_from_arr32(erp->mask_bitmap, (u32 *) key->mask,",
          "725:      MLXSW_SP_ACL_TCAM_MASK_LEN);",
          "726:  refcount_set(&erp->refcnt, 1);",
          "727:  erp_table->num_ctcam_erps++;",
          "728:  erp->erp_table = erp_table;",
          "730:  err = mlxsw_sp_acl_erp_master_mask_set(erp_table, erp);",
          "731:  if (err)",
          "732:   goto err_master_mask_set;",
          "734:  err = rhashtable_insert_fast(&erp_table->erp_ht, &erp->ht_node,",
          "735:          mlxsw_sp_acl_erp_ht_params);",
          "736:  if (err)",
          "737:   goto err_rhashtable_insert;",
          "739:  err = mlxsw_sp_acl_erp_region_ctcam_enable(erp_table);",
          "740:  if (err)",
          "741:   goto err_erp_region_ctcam_enable;",
          "744:  erp_table->ops = &erp_multiple_masks_ops;",
          "746:  return erp;",
          "748: err_erp_region_ctcam_enable:",
          "749:  rhashtable_remove_fast(&erp_table->erp_ht, &erp->ht_node,",
          "750:           mlxsw_sp_acl_erp_ht_params);",
          "751: err_rhashtable_insert:",
          "752:  mlxsw_sp_acl_erp_master_mask_clear(erp_table, erp);",
          "753: err_master_mask_set:",
          "754:  erp_table->num_ctcam_erps--;",
          "755:  kfree(erp);",
          "756:  return ERR_PTR(err);",
          "757: }",
          "759: static struct mlxsw_sp_acl_erp *",
          "760: mlxsw_sp_acl_erp_ctcam_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "761:        struct mlxsw_sp_acl_erp_key *key)",
          "762: {",
          "763:  struct mlxsw_sp_acl_erp *erp;",
          "764:  int err;",
          "773:  err = mlxsw_sp_acl_erp_region_table_trans(erp_table);",
          "774:  if (err)",
          "775:   return ERR_PTR(err);",
          "777:  erp = __mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "778:  if (IS_ERR(erp)) {",
          "779:   err = PTR_ERR(erp);",
          "780:   goto err_erp_create;",
          "781:  }",
          "783:  return erp;",
          "785: err_erp_create:",
          "786:  mlxsw_sp_acl_erp_region_master_mask_trans(erp_table);",
          "787:  return ERR_PTR(err);",
          "788: }",
          "790: static void",
          "791: mlxsw_sp_acl_erp_ctcam_mask_destroy(struct mlxsw_sp_acl_erp *erp)",
          "792: {",
          "793:  struct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;",
          "795:  mlxsw_sp_acl_erp_region_ctcam_disable(erp_table);",
          "796:  rhashtable_remove_fast(&erp_table->erp_ht, &erp->ht_node,",
          "797:           mlxsw_sp_acl_erp_ht_params);",
          "798:  mlxsw_sp_acl_erp_master_mask_clear(erp_table, erp);",
          "799:  erp_table->num_ctcam_erps--;",
          "800:  kfree(erp);",
          "806:  if (erp_table->num_ctcam_erps > 0)",
          "807:   return;",
          "808:  mlxsw_sp_acl_erp_ctcam_table_ops_set(erp_table);",
          "809: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "653:  struct mlxsw_sp_acl_erp *erp;",
          "654:  int err;",
          "657:  err = mlxsw_sp_acl_erp_table_expand(erp_table);",
          "658:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "818:  if (key->ctcam)",
          "819:   return __mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "691: mlxsw_sp_acl_erp_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,",
          "692:          struct mlxsw_sp_acl_erp *erp)",
          "693: {",
          "694:  mlxsw_sp_acl_erp_region_erp_del(erp);",
          "695:  mlxsw_sp_acl_erp_table_erp_del(erp);",
          "696:  mlxsw_sp_acl_erp_index_put(erp_table, erp->index);",
          "697:  mlxsw_sp_acl_erp_generic_destroy(erp);",
          "700:   erp_table->ops = &erp_two_masks_ops;",
          "701: }",
          "",
          "[Removed Lines]",
          "699:  if (erp_table->num_atcam_erps == 2)",
          "",
          "[Added Lines]",
          "859:  if (erp->key.ctcam)",
          "860:   return mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);",
          "867:  if (erp_table->num_atcam_erps == 2 && erp_table->num_ctcam_erps == 0)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "707:  struct mlxsw_sp_acl_erp *erp;",
          "708:  int err;",
          "711:  err = mlxsw_sp_acl_erp_region_table_trans(erp_table);",
          "712:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878:  if (key->ctcam)",
          "879:   return mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "749: mlxsw_sp_acl_erp_second_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,",
          "750:          struct mlxsw_sp_acl_erp *erp)",
          "751: {",
          "752:  mlxsw_sp_acl_erp_region_erp_del(erp);",
          "753:  mlxsw_sp_acl_erp_table_erp_del(erp);",
          "754:  mlxsw_sp_acl_erp_index_put(erp_table, erp->index);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "923:  if (erp->key.ctcam)",
          "924:   return mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "765: {",
          "766:  struct mlxsw_sp_acl_erp *erp;",
          "768:  erp = mlxsw_sp_acl_erp_generic_create(erp_table, key);",
          "769:  if (IS_ERR(erp))",
          "770:   return erp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "942:  if (key->ctcam)",
          "943:   return ERR_PTR(-EINVAL);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "792: struct mlxsw_sp_acl_erp *",
          "793: mlxsw_sp_acl_erp_get(struct mlxsw_sp_acl_atcam_region *aregion,",
          "795: {",
          "796:  struct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;",
          "797:  struct mlxsw_sp_acl_erp_key key;",
          "",
          "[Removed Lines]",
          "794:        const char *mask)",
          "",
          "[Added Lines]",
          "971:        const char *mask, bool ctcam)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "803:  ASSERT_RTNL();",
          "805:  memcpy(key.mask, mask, MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);",
          "806:  erp = rhashtable_lookup_fast(&erp_table->erp_ht, &key,",
          "807:          mlxsw_sp_acl_erp_ht_params);",
          "808:  if (erp) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "983:  key.ctcam = ctcam;",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h": [
          "File: drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h -> drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "179: u8 mlxsw_sp_acl_erp_id(const struct mlxsw_sp_acl_erp *erp);",
          "180: struct mlxsw_sp_acl_erp *",
          "181: mlxsw_sp_acl_erp_get(struct mlxsw_sp_acl_atcam_region *aregion,",
          "183: void mlxsw_sp_acl_erp_put(struct mlxsw_sp_acl_atcam_region *aregion,",
          "184:      struct mlxsw_sp_acl_erp *erp);",
          "185: int mlxsw_sp_acl_erp_region_init(struct mlxsw_sp_acl_atcam_region *aregion);",
          "",
          "[Removed Lines]",
          "182:        const char *mask);",
          "",
          "[Added Lines]",
          "182:        const char *mask, bool ctcam);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "10d255c3540239c7920f52d2eb223756e186af56",
      "candidate_info": {
        "commit_hash": "10d255c3540239c7920f52d2eb223756e186af56",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/10d255c3540239c7920f52d2eb223756e186af56",
        "files": [
          "fs/f2fs/gc.c"
        ],
        "message": "f2fs: fix to skip GC if type in SSA and SIT is inconsistent\n\nIf segment type in SSA and SIT is inconsistent, we will encounter below\nBUG_ON during GC, to avoid this panic, let's just skip doing GC on such\nsegment.\n\nThe bug is triggered with image reported in below link:\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200223\n\n[  388.060262] ------------[ cut here ]------------\n[  388.060268] kernel BUG at /home/y00370721/git/devf2fs/gc.c:989!\n[  388.061172] invalid opcode: 0000 [#1] SMP\n[  388.061773] Modules linked in: f2fs(O) bluetooth ecdh_generic xt_tcpudp iptable_filter ip_tables x_tables lp ttm drm_kms_helper drm intel_rapl sb_edac crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcbc aesni_intel fb_sys_fops ppdev aes_x86_64 syscopyarea crypto_simd sysfillrect parport_pc joydev sysimgblt glue_helper parport cryptd i2c_piix4 serio_raw mac_hid btrfs hid_generic usbhid hid raid6_pq psmouse pata_acpi floppy\n[  388.064247] CPU: 7 PID: 4151 Comm: f2fs_gc-7:0 Tainted: G           O    4.13.0-rc1+ #26\n[  388.065306] Hardware name: Xen HVM domU, BIOS 4.1.2_115-900.260_ 11/06/2015\n[  388.066058] task: ffff880201583b80 task.stack: ffffc90004d7c000\n[  388.069948] RIP: 0010:do_garbage_collect+0xcc8/0xcd0 [f2fs]\n[  388.070766] RSP: 0018:ffffc90004d7fc68 EFLAGS: 00010202\n[  388.071783] RAX: ffff8801ed227000 RBX: 0000000000000001 RCX: ffffea0007b489c0\n[  388.072700] RDX: ffff880000000000 RSI: 0000000000000001 RDI: ffffea0007b489c0\n[  388.073607] RBP: ffffc90004d7fd58 R08: 0000000000000003 R09: ffffea0007b489dc\n[  388.074619] R10: 0000000000000000 R11: 0052782ab317138d R12: 0000000000000018\n[  388.075625] R13: 0000000000000018 R14: ffff880211ceb000 R15: ffff880211ceb000\n[  388.076687] FS:  0000000000000000(0000) GS:ffff880214fc0000(0000) knlGS:0000000000000000\n[  388.083277] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  388.084536] CR2: 0000000000e18c60 CR3: 00000001ecf2e000 CR4: 00000000001406e0\n[  388.085748] Call Trace:\n[  388.086690]  ? find_next_bit+0xb/0x10\n[  388.088091]  f2fs_gc+0x1a8/0x9d0 [f2fs]\n[  388.088888]  ? lock_timer_base+0x7d/0xa0\n[  388.090213]  ? try_to_del_timer_sync+0x44/0x60\n[  388.091698]  gc_thread_func+0x342/0x4b0 [f2fs]\n[  388.092892]  ? wait_woken+0x80/0x80\n[  388.094098]  kthread+0x109/0x140\n[  388.095010]  ? f2fs_gc+0x9d0/0x9d0 [f2fs]\n[  388.096043]  ? kthread_park+0x60/0x60\n[  388.097281]  ret_from_fork+0x25/0x30\n[  388.098401] Code: ff ff 48 83 e8 01 48 89 44 24 58 e9 27 f8 ff ff 48 83 e8 01 e9 78 fc ff ff 48 8d 78 ff e9 17 fb ff ff 48 83 ef 01 e9 4d f4 ff ff <0f> 0b 66 0f 1f 44 00 00 0f 1f 44 00 00 55 48 89 e5 41 56 41 55\n[  388.100864] RIP: do_garbage_collect+0xcc8/0xcd0 [f2fs] RSP: ffffc90004d7fc68\n[  388.101810] ---[ end trace 81c73d6e6b7da61d ]---\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/gc.c||fs/f2fs/gc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/gc.c||fs/f2fs/gc.c": [
          "File: fs/f2fs/gc.c -> fs/f2fs/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "986:    goto next;",
          "988:   sum = page_address(sum_page);",
          "",
          "[Removed Lines]",
          "989:   f2fs_bug_on(sbi, type != GET_SUM_TYPE((&sum->footer)));",
          "",
          "[Added Lines]",
          "989:   if (type != GET_SUM_TYPE((&sum->footer))) {",
          "990:    f2fs_msg(sbi->sb, KERN_ERR, \"Inconsistent segment (%u) \"",
          "991:     \"type [%d, %d] in SSA and SIT\",",
          "992:     segno, type, GET_SUM_TYPE((&sum->footer)));",
          "993:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "994:    goto next;",
          "995:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b512719f771a82180211c9a315b8a7f628832b3d",
      "candidate_info": {
        "commit_hash": "b512719f771a82180211c9a315b8a7f628832b3d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b512719f771a82180211c9a315b8a7f628832b3d",
        "files": [
          "include/linux/delayacct.h"
        ],
        "message": "delayacct: fix crash in delayacct_blkio_end() after delayacct init failure\n\nWhile forking, if delayacct init fails due to memory shortage, it\ncontinues expecting all delayacct users to check task->delays pointer\nagainst NULL before dereferencing it, which all of them used to do.\n\nCommit c96f5471ce7d (\"delayacct: Account blkio completion on the correct\ntask\"), while updating delayacct_blkio_end() to take the target task\ninstead of always using %current, made the function test NULL on\n%current->delays and then continue to operated on @p->delays.  If\n%current succeeded init while @p didn't, it leads to the following\ncrash.\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000004\n IP: __delayacct_blkio_end+0xc/0x40\n PGD 8000001fd07e1067 P4D 8000001fd07e1067 PUD 1fcffbb067 PMD 0\n Oops: 0000 [#1] SMP PTI\n CPU: 4 PID: 25774 Comm: QIOThread0 Not tainted 4.16.0-9_fbk1_rc2_1180_g6b593215b4d7 #9\n RIP: 0010:__delayacct_blkio_end+0xc/0x40\n Call Trace:\n  try_to_wake_up+0x2c0/0x600\n  autoremove_wake_function+0xe/0x30\n  __wake_up_common+0x74/0x120\n  wake_up_page_bit+0x9c/0xe0\n  mpage_end_io+0x27/0x70\n  blk_update_request+0x78/0x2c0\n  scsi_end_request+0x2c/0x1e0\n  scsi_io_completion+0x20b/0x5f0\n  blk_mq_complete_request+0xa2/0x100\n  ata_scsi_qc_complete+0x79/0x400\n  ata_qc_complete_multiple+0x86/0xd0\n  ahci_handle_port_interrupt+0xc9/0x5c0\n  ahci_handle_port_intr+0x54/0xb0\n  ahci_single_level_irq_intr+0x3b/0x60\n  __handle_irq_event_percpu+0x43/0x190\n  handle_irq_event_percpu+0x20/0x50\n  handle_irq_event+0x2a/0x50\n  handle_edge_irq+0x80/0x1c0\n  handle_irq+0xaf/0x120\n  do_IRQ+0x41/0xc0\n  common_interrupt+0xf/0xf\n\nFix it by updating delayacct_blkio_end() check @p->delays instead.\n\nLink: http://lkml.kernel.org/r/20180724175542.GP1934745@devbig577.frc2.facebook.com\nFixes: c96f5471ce7d (\"delayacct: Account blkio completion on the correct task\")\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Dave Jones <dsj@fb.com>\nDebugged-by: Dave Jones <dsj@fb.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Josh Snyder <joshs@netflix.com>\nCc: <stable@vger.kernel.org>\t[4.15+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/delayacct.h||include/linux/delayacct.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/linux/delayacct.h||include/linux/delayacct.h": [
          "File: include/linux/delayacct.h -> include/linux/delayacct.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "125: static inline void delayacct_blkio_end(struct task_struct *p)",
          "126: {",
          "128:   __delayacct_blkio_end(p);",
          "129:  delayacct_clear_flag(DELAYACCT_PF_BLKIO);",
          "130: }",
          "",
          "[Removed Lines]",
          "127:  if (current->delays)",
          "",
          "[Added Lines]",
          "127:  if (p->delays)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1863c387259b629e4ebfb255495f67cd06aa229b",
      "candidate_info": {
        "commit_hash": "1863c387259b629e4ebfb255495f67cd06aa229b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1863c387259b629e4ebfb255495f67cd06aa229b",
        "files": [
          "kernel/trace/trace_events_trigger.c"
        ],
        "message": "tracing: Fix double free of event_trigger_data\n\nRunning the following:\n\n # cd /sys/kernel/debug/tracing\n # echo 500000 > buffer_size_kb\n[ Or some other number that takes up most of memory ]\n # echo snapshot > events/sched/sched_switch/trigger\n\nTriggers the following bug:\n\n ------------[ cut here ]------------\n kernel BUG at mm/slub.c:296!\n invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC PTI\n CPU: 6 PID: 6878 Comm: bash Not tainted 4.18.0-rc6-test+ #1066\n Hardware name: Hewlett-Packard HP Compaq Pro 6300 SFF/339A, BIOS K01 v03.03 07/14/2016\n RIP: 0010:kfree+0x16c/0x180\n Code: 05 41 0f b6 72 51 5b 5d 41 5c 4c 89 d7 e9 ac b3 f8 ff 48 89 d9 48 89 da 41 b8 01 00 00 00 5b 5d 41 5c 4c 89 d6 e9 f4 f3 ff ff <0f> 0b 0f 0b 48 8b 3d d9 d8 f9 00 e9 c1 fe ff ff 0f 1f 40 00 0f 1f\n RSP: 0018:ffffb654436d3d88 EFLAGS: 00010246\n RAX: ffff91a9d50f3d80 RBX: ffff91a9d50f3d80 RCX: ffff91a9d50f3d80\n RDX: 00000000000006a4 RSI: ffff91a9de5a60e0 RDI: ffff91a9d9803500\n RBP: ffffffff8d267c80 R08: 00000000000260e0 R09: ffffffff8c1a56be\n R10: fffff0d404543cc0 R11: 0000000000000389 R12: ffffffff8c1a56be\n R13: ffff91a9d9930e18 R14: ffff91a98c0c2890 R15: ffffffff8d267d00\n FS:  00007f363ea64700(0000) GS:ffff91a9de580000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000055c1cacc8e10 CR3: 00000000d9b46003 CR4: 00000000001606e0\n Call Trace:\n  event_trigger_callback+0xee/0x1d0\n  event_trigger_write+0xfc/0x1a0\n  __vfs_write+0x33/0x190\n  ? handle_mm_fault+0x115/0x230\n  ? _cond_resched+0x16/0x40\n  vfs_write+0xb0/0x190\n  ksys_write+0x52/0xc0\n  do_syscall_64+0x5a/0x160\n  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n RIP: 0033:0x7f363e16ab50\n Code: 73 01 c3 48 8b 0d 38 83 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 79 db 2c 00 00 75 10 b8 01 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 1e e3 01 00 48 89 04 24\n RSP: 002b:00007fff9a4c6378 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n RAX: ffffffffffffffda RBX: 0000000000000009 RCX: 00007f363e16ab50\n RDX: 0000000000000009 RSI: 000055c1cacc8e10 RDI: 0000000000000001\n RBP: 000055c1cacc8e10 R08: 00007f363e435740 R09: 00007f363ea64700\n R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000009\n R13: 0000000000000001 R14: 00007f363e4345e0 R15: 00007f363e4303c0\n Modules linked in: ip6table_filter ip6_tables snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_seq snd_seq_device i915 snd_pcm snd_timer i2c_i801 snd soundcore i2c_algo_bit drm_kms_helper\n86_pkg_temp_thermal video kvm_intel kvm irqbypass wmi e1000e\n ---[ end trace d301afa879ddfa25 ]---\n\nThe cause is because the register_snapshot_trigger() call failed to\nallocate the snapshot buffer, and then called unregister_trigger()\nwhich freed the data that was passed to it. Then on return to the\nfunction that called register_snapshot_trigger(), as it sees it\nfailed to register, it frees the trigger_data again and causes\na double free.\n\nBy calling event_trigger_init() on the trigger_data (which only ups\nthe reference counter for it), and then event_trigger_free() afterward,\nthe trigger_data would not get freed by the registering trigger function\nas it would only up and lower the ref count for it. If the register\ntrigger function fails, then the event_trigger_free() called after it\nwill free the trigger data normally.\n\nLink: http://lkml.kernel.org/r/20180724191331.738eb819@gandalf.local.home\n\nCc: stable@vger.kerne.org\nFixes: 93e31ffbf417 (\"tracing: Add 'snapshot' event trigger command\")\nReported-by: Masami Hiramatsu <mhiramat@kernel.org>\nReviewed-by: Masami Hiramatsu <mhiramat@kernel.org>\nSigned-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>",
        "before_after_code_files": [
          "kernel/trace/trace_events_trigger.c||kernel/trace/trace_events_trigger.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/trace/trace_events_trigger.c||kernel/trace/trace_events_trigger.c": [
          "File: kernel/trace/trace_events_trigger.c -> kernel/trace/trace_events_trigger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "679:   goto out_free;",
          "681:  out_reg:",
          "682:  ret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "683:  event_trigger_init(trigger_ops, trigger_data);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "688:  if (!ret) {",
          "689:   ret = -ENOENT;",
          "694:  out:",
          "695:  return ret;",
          "",
          "[Removed Lines]",
          "690:   goto out_free;",
          "691:  } else if (ret < 0)",
          "692:   goto out_free;",
          "693:  ret = 0;",
          "",
          "[Added Lines]",
          "691:   cmd_ops->unreg(glob, trigger_ops, trigger_data, file);",
          "693:  } else if (ret > 0)",
          "694:   ret = 0;",
          "697:  event_trigger_free(trigger_ops, trigger_data);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
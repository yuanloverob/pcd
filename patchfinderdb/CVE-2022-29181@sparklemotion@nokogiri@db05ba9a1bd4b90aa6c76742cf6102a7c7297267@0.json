{
  "cve_id": "CVE-2022-29181",
  "cve_desc": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri prior to version 1.13.6 does not type-check all inputs into the XML and HTML4 SAX parsers, allowing specially crafted untrusted inputs to cause illegal memory access errors (segfault) or reads from unrelated memory. Version 1.13.6 contains a patch for this issue. As a workaround, ensure the untrusted input is a `String` by calling `#to_s` or equivalent.",
  "repo": "sparklemotion/nokogiri",
  "patch_hash": "db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
  "patch_info": {
    "commit_hash": "db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
    "repo": "sparklemotion/nokogiri",
    "commit_url": "https://github.com/sparklemotion/nokogiri/commit/db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
    "files": [
      "CHANGELOG.md",
      "ext/java/nokogiri/Html4SaxParserContext.java",
      "ext/java/nokogiri/XmlSaxParserContext.java",
      "ext/java/nokogiri/internals/ParserContext.java",
      "ext/nokogiri/html4_sax_parser_context.c",
      "ext/nokogiri/xml_sax_parser_context.c",
      "lib/nokogiri/html4/sax/parser.rb",
      "test/html4/sax/test_parser.rb",
      "test/html4/sax/test_parser_context.rb",
      "test/xml/sax/test_parser.rb",
      "test/xml/sax/test_parser_context.rb"
    ],
    "message": "fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types\n\nPreviously, arguments of the wrong type might cause segfault on CRuby.",
    "before_after_code_files": [
      "ext/java/nokogiri/Html4SaxParserContext.java||ext/java/nokogiri/Html4SaxParserContext.java",
      "ext/java/nokogiri/XmlSaxParserContext.java||ext/java/nokogiri/XmlSaxParserContext.java",
      "ext/java/nokogiri/internals/ParserContext.java||ext/java/nokogiri/internals/ParserContext.java",
      "ext/nokogiri/html4_sax_parser_context.c||ext/nokogiri/html4_sax_parser_context.c",
      "ext/nokogiri/xml_sax_parser_context.c||ext/nokogiri/xml_sax_parser_context.c",
      "lib/nokogiri/html4/sax/parser.rb||lib/nokogiri/html4/sax/parser.rb",
      "test/html4/sax/test_parser.rb||test/html4/sax/test_parser.rb",
      "test/html4/sax/test_parser_context.rb||test/html4/sax/test_parser_context.rb",
      "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb",
      "test/xml/sax/test_parser_context.rb||test/xml/sax/test_parser_context.rb"
    ]
  },
  "patch_diff": {
    "ext/java/nokogiri/Html4SaxParserContext.java||ext/java/nokogiri/Html4SaxParserContext.java": [
      "File: ext/java/nokogiri/Html4SaxParserContext.java -> ext/java/nokogiri/Html4SaxParserContext.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "231:              IRubyObject data,",
      "232:              IRubyObject encoding)",
      "233:   {",
      "234:     Html4SaxParserContext ctx = Html4SaxParserContext.newInstance(context.runtime, (RubyClass) klass);",
      "235:     ctx.setInputSourceFile(context, data);",
      "236:     String javaEncoding = findEncodingName(context, encoding);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "234:     if (!(data instanceof RubyString)) {",
      "235:       throw context.getRuntime().newTypeError(\"data must be kind_of String\");",
      "236:     }",
      "237:     if (!(encoding instanceof RubyString)) {",
      "238:       throw context.getRuntime().newTypeError(\"data must be kind_of String\");",
      "239:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "247:            IRubyObject data,",
      "248:            IRubyObject encoding)",
      "249:   {",
      "250:     Html4SaxParserContext ctx = Html4SaxParserContext.newInstance(context.runtime, (RubyClass) klass);",
      "251:     ctx.setIOInputSource(context, data, context.nil);",
      "252:     String javaEncoding = findEncodingName(context, encoding);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "257:     if (!(encoding instanceof RubyFixnum)) {",
      "258:       throw context.getRuntime().newTypeError(\"encoding must be kind_of String\");",
      "259:     }",
      "",
      "---------------"
    ],
    "ext/java/nokogiri/XmlSaxParserContext.java||ext/java/nokogiri/XmlSaxParserContext.java": [
      "File: ext/java/nokogiri/XmlSaxParserContext.java -> ext/java/nokogiri/XmlSaxParserContext.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "131:   parse_io(ThreadContext context,",
      "132:            IRubyObject klazz,",
      "133:            IRubyObject data,",
      "135:   {",
      "137:     final Ruby runtime = context.runtime;",
      "138:     XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);",
      "139:     ctx.initialize(runtime);",
      "",
      "[Removed Lines]",
      "134:            IRubyObject enc)",
      "",
      "[Added Lines]",
      "134:            IRubyObject encoding)",
      "137:     if (!(encoding instanceof RubyFixnum)) {",
      "138:       throw context.getRuntime().newTypeError(\"encoding must be kind_of String\");",
      "139:     }",
      "",
      "---------------"
    ],
    "ext/java/nokogiri/internals/ParserContext.java||ext/java/nokogiri/internals/ParserContext.java": [
      "File: ext/java/nokogiri/internals/ParserContext.java -> ext/java/nokogiri/internals/ParserContext.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "60:     source = new InputSource();",
      "61:     ParserContext.setUrl(context, source, url);",
      "63:     source.setByteStream(new IOInputStream(data));",
      "64:     if (java_encoding != null) {",
      "65:       source.setEncoding(java_encoding);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "63:     Ruby ruby = context.getRuntime();",
      "65:     if (!(data.respondsTo(\"read\"))) {",
      "66:       throw ruby.newTypeError(\"must respond to :read\");",
      "67:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "75:     Ruby ruby = context.getRuntime();",
      "77:     if (!(data instanceof RubyString)) {",
      "79:     }",
      "81:     RubyString stringData = (RubyString) data;",
      "",
      "[Removed Lines]",
      "78:       throw ruby.newArgumentError(\"must be kind_of String\");",
      "",
      "[Added Lines]",
      "84:       throw ruby.newTypeError(\"must be kind_of String\");",
      "",
      "---------------"
    ],
    "ext/nokogiri/html4_sax_parser_context.c||ext/nokogiri/html4_sax_parser_context.c": [
      "File: ext/nokogiri/html4_sax_parser_context.c -> ext/nokogiri/html4_sax_parser_context.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "19: {",
      "20:   htmlParserCtxtPtr ctxt;",
      "25:   if (!(int)RSTRING_LEN(data)) {",
      "26:     rb_raise(rb_eRuntimeError, \"data cannot be empty\");",
      "27:   }",
      "",
      "[Removed Lines]",
      "22:   if (NIL_P(data)) {",
      "23:     rb_raise(rb_eArgError, \"data cannot be nil\");",
      "24:   }",
      "",
      "[Added Lines]",
      "22:   Check_Type(data, T_STRING);",
      "",
      "---------------"
    ],
    "ext/nokogiri/xml_sax_parser_context.c||ext/nokogiri/xml_sax_parser_context.c": [
      "File: ext/nokogiri/xml_sax_parser_context.c -> ext/nokogiri/xml_sax_parser_context.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: VALUE cNokogiriXmlSaxParserContext ;",
      "5: static void",
      "6: deallocate(xmlParserCtxtPtr ctxt)",
      "7: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5: static ID id_read;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "26:   xmlParserCtxtPtr ctxt;",
      "27:   xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);",
      "29:   ctxt = xmlCreateIOParserCtxt(NULL, NULL,",
      "30:                                (xmlInputReadCallback)noko_io_read,",
      "31:                                (xmlInputCloseCallback)noko_io_close,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "31:   if (!rb_respond_to(io, id_read)) {",
      "32:     rb_raise(rb_eTypeError, \"argument expected to respond to :read\");",
      "33:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "62: {",
      "63:   xmlParserCtxtPtr ctxt;",
      "68:   if (!(int)RSTRING_LEN(data)) {",
      "69:     rb_raise(rb_eRuntimeError, \"data cannot be empty\");",
      "70:   }",
      "",
      "[Removed Lines]",
      "65:   if (NIL_P(data)) {",
      "66:     rb_raise(rb_eArgError, \"data cannot be nil\");",
      "67:   }",
      "",
      "[Added Lines]",
      "71:   Check_Type(data, T_STRING);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "278:   rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);",
      "279:   rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);",
      "280:   rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);",
      "281: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "287:   id_read = rb_intern(\"read\");",
      "",
      "---------------"
    ],
    "lib/nokogiri/html4/sax/parser.rb||lib/nokogiri/html4/sax/parser.rb": [
      "File: lib/nokogiri/html4/sax/parser.rb -> lib/nokogiri/html4/sax/parser.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "28:         ###",
      "29:         # Parse html stored in +data+ using +encoding+",
      "30:         def parse_memory(data, encoding = \"UTF-8\")",
      "32:           return if data.empty?",
      "34:           ctx = ParserContext.memory(data, encoding)",
      "",
      "[Removed Lines]",
      "31:           raise ArgumentError unless data",
      "",
      "[Added Lines]",
      "31:           raise TypeError unless String === data",
      "",
      "---------------"
    ],
    "test/html4/sax/test_parser.rb||test/html4/sax/test_parser.rb": [
      "File: test/html4/sax/test_parser.rb -> test/html4/sax/test_parser.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "54:         end",
      "56:         def test_parse_memory_nil",
      "58:             @parser.parse_memory(nil)",
      "59:           end",
      "60:         end",
      "",
      "[Removed Lines]",
      "57:           assert_raises(ArgumentError) do",
      "",
      "[Added Lines]",
      "57:           assert_raises(TypeError) do",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "161:         def test_empty_processing_instruction",
      "162:           @parser.parse_memory(\"<strong>this will segfault<?strong>\")",
      "163:         end",
      "164:       end",
      "165:     end",
      "166:   end",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "165:         it \"handles invalid types gracefully\" do",
      "166:           assert_raises(TypeError) { Nokogiri::HTML::SAX::Parser.new.parse(0xcafecafe) }",
      "167:           assert_raises(TypeError) { Nokogiri::HTML::SAX::Parser.new.parse_memory(0xcafecafe) }",
      "168:           assert_raises(TypeError) { Nokogiri::HTML::SAX::Parser.new.parse_io(0xcafecafe) }",
      "169:         end",
      "",
      "---------------"
    ],
    "test/html4/sax/test_parser_context.rb||test/html4/sax/test_parser_context.rb": [
      "File: test/html4/sax/test_parser_context.rb -> test/html4/sax/test_parser_context.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "40:           ctx.parse_with(parser)",
      "41:           # end",
      "42:         end",
      "43:       end",
      "44:     end",
      "45:   end",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44:         def test_graceful_handling_of_invalid_types",
      "45:           assert_raises(TypeError) { ParserContext.new(0xcafecafe) }",
      "46:           assert_raises(TypeError) { ParserContext.memory(0xcafecafe, \"UTF-8\") }",
      "47:           assert_raises(TypeError) { ParserContext.io(0xcafecafe, 1) }",
      "48:           assert_raises(TypeError) { ParserContext.io(StringIO.new(\"asdf\"), \"should be an index into ENCODINGS\") }",
      "49:           assert_raises(TypeError) { ParserContext.file(0xcafecafe, \"UTF-8\") }",
      "50:           assert_raises(TypeError) { ParserContext.file(\"path/to/file\", 0xcafecafe) }",
      "51:         end",
      "",
      "---------------"
    ],
    "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb": [
      "File: test/xml/sax/test_parser.rb -> test/xml/sax/test_parser.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "73:           end",
      "74:         end",
      "76:         it :test_namespace_declaration_order_is_saved do",
      "77:           parser.parse(<<~EOF)",
      "78:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "76:         it \"handles invalid types gracefully\" do",
      "77:           assert_raises(TypeError) { Nokogiri::XML::SAX::Parser.new.parse(0xcafecafe) }",
      "78:           assert_raises(TypeError) { Nokogiri::XML::SAX::Parser.new.parse_memory(0xcafecafe) }",
      "79:           assert_raises(TypeError) { Nokogiri::XML::SAX::Parser.new.parse_io(0xcafecafe) }",
      "80:         end",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "263:         end",
      "265:         it :test_render_parse_nil_param do",
      "267:         end",
      "269:         it :test_bad_encoding_args do",
      "",
      "[Removed Lines]",
      "266:           assert_raises(ArgumentError) { parser.parse_memory(nil) }",
      "",
      "[Added Lines]",
      "272:           assert_raises(TypeError) { parser.parse_memory(nil) }",
      "",
      "---------------"
    ],
    "test/xml/sax/test_parser_context.rb||test/xml/sax/test_parser_context.rb": [
      "File: test/xml/sax/test_parser_context.rb -> test/xml/sax/test_parser_context.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "80:           assert(pc.recovery)",
      "81:         end",
      "83:         def test_from_io",
      "84:           ctx = ParserContext.new(StringIO.new(\"fo\"), \"UTF-8\")",
      "85:           assert(ctx)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "83:         def test_graceful_handling_of_invalid_types",
      "84:           assert_raises(TypeError) { ParserContext.new(0xcafecafe) }",
      "85:           assert_raises(TypeError) { ParserContext.memory(0xcafecafe) }",
      "86:           assert_raises(TypeError) { ParserContext.io(0xcafecafe, 1) }",
      "87:           assert_raises(TypeError) { ParserContext.io(StringIO.new(\"asdf\"), \"should be an index into ENCODINGS\") }",
      "88:         end",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d43f6f509f02a0744b0c1d4b9508f33beb4d00f6",
      "candidate_info": {
        "commit_hash": "d43f6f509f02a0744b0c1d4b9508f33beb4d00f6",
        "repo": "sparklemotion/nokogiri",
        "commit_url": "https://github.com/sparklemotion/nokogiri/commit/d43f6f509f02a0744b0c1d4b9508f33beb4d00f6",
        "files": [
          ".rubocop_todo.yml",
          "test/html4/test_html_module.rb",
          "test/test_nokogiri.rb",
          "test/test_xslt_transforms.rb",
          "test/xml/node/test_attribute_methods.rb",
          "test/xml/sax/test_parser.rb",
          "test/xml/sax/test_push_parser.rb"
        ],
        "message": "style(rubocop): Style/ClassAndModuleChildren",
        "before_after_code_files": [
          "test/html4/test_html_module.rb||test/html4/test_html_module.rb",
          "test/test_nokogiri.rb||test/test_nokogiri.rb",
          "test/test_xslt_transforms.rb||test/test_xslt_transforms.rb",
          "test/xml/node/test_attribute_methods.rb||test/xml/node/test_attribute_methods.rb",
          "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb",
          "test/xml/sax/test_push_parser.rb||test/xml/sax/test_push_parser.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb"
          ],
          "candidate": [
            "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb"
          ]
        }
      },
      "candidate_diff": {
        "test/html4/test_html_module.rb||test/html4/test_html_module.rb": [
          "File: test/html4/test_html_module.rb -> test/html4/test_html_module.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: require \"helper\"",
          "9:     end",
          "15:     end",
          "16:   end",
          "17: end",
          "",
          "[Removed Lines]",
          "5: class Nokogiri::TestCase",
          "6:   describe Nokogiri::HTML do",
          "7:     it \"is the same as Nokogiri::HTML4\" do",
          "8:       assert_same(Nokogiri::HTML, Nokogiri::HTML4)",
          "10:   end",
          "12:   describe \"Nokogiri.HTML()\" do",
          "13:     it \"is the same as Nokogiri.HTML4()\" do",
          "14:       assert_equal(Nokogiri.method(:HTML), Nokogiri.method(:HTML4))",
          "",
          "[Added Lines]",
          "5: module Nokogiri",
          "6:   class TestCase",
          "7:     describe Nokogiri::HTML do",
          "8:       it \"is the same as Nokogiri::HTML4\" do",
          "9:         assert_same(Nokogiri::HTML, Nokogiri::HTML4)",
          "10:       end",
          "13:     describe \"Nokogiri.HTML()\" do",
          "14:       it \"is the same as Nokogiri.HTML4()\" do",
          "15:         assert_equal(Nokogiri.method(:HTML), Nokogiri.method(:HTML4))",
          "16:       end",
          "",
          "---------------"
        ],
        "test/test_nokogiri.rb||test/test_nokogiri.rb": [
          "File: test/test_nokogiri.rb -> test/test_nokogiri.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: require \"helper\"",
          "54:     end",
          "55:   end",
          "56: end",
          "",
          "[Removed Lines]",
          "5: class Nokogiri::TestCase",
          "6:   describe Nokogiri do",
          "7:     def test_libxml_iconv",
          "8:       skip_unless_libxml2(\"this constant is only set in the C extension when libxml2 is used\")",
          "9:       assert(Nokogiri.const_defined?(:LIBXML_ICONV_ENABLED))",
          "10:     end",
          "12:     def test_parse_with_io",
          "13:       doc = Nokogiri.parse(StringIO.new(\"<html><head><title></title><body></body></html>\"))",
          "14:       assert_instance_of(Nokogiri::HTML::Document, doc)",
          "15:     end",
          "17:     def test_xml?",
          "18:       doc = Nokogiri.parse(File.read(XML_FILE))",
          "19:       assert(doc.xml?)",
          "20:       refute(doc.html?)",
          "21:     end",
          "23:     def test_atom_is_xml?",
          "24:       doc = Nokogiri.parse(File.read(XML_ATOM_FILE))",
          "25:       assert(doc.xml?)",
          "26:       refute(doc.html?)",
          "27:     end",
          "29:     def test_html?",
          "30:       doc = Nokogiri.parse(File.read(HTML_FILE))",
          "31:       refute(doc.xml?)",
          "32:       assert(doc.html?)",
          "33:     end",
          "35:     def test_nokogiri_method_with_html",
          "36:       doc1 = Nokogiri(File.read(HTML_FILE))",
          "37:       doc2 = Nokogiri.parse(File.read(HTML_FILE))",
          "38:       assert_equal(doc1.serialize, doc2.serialize)",
          "39:     end",
          "41:     def test_nokogiri_method_with_block",
          "42:       doc = Nokogiri { b(\"bold tag\") }",
          "43:       assert_equal(\"<b>bold tag</b>\", doc.to_html.chomp)",
          "44:     end",
          "46:     def test_make_with_html",
          "47:       doc = Nokogiri.make(\"<b>bold tag</b>\")",
          "48:       assert_equal(\"<b>bold tag</b>\", doc.to_html.chomp)",
          "49:     end",
          "51:     def test_make_with_block",
          "52:       doc = Nokogiri.make { b(\"bold tag\") }",
          "53:       assert_equal(\"<b>bold tag</b>\", doc.to_html.chomp)",
          "",
          "[Added Lines]",
          "5: module Nokogiri",
          "6:   class TestCase",
          "7:     describe Nokogiri do",
          "8:       def test_libxml_iconv",
          "9:         skip_unless_libxml2(\"this constant is only set in the C extension when libxml2 is used\")",
          "10:         assert(Nokogiri.const_defined?(:LIBXML_ICONV_ENABLED))",
          "11:       end",
          "13:       def test_parse_with_io",
          "14:         doc = Nokogiri.parse(StringIO.new(\"<html><head><title></title><body></body></html>\"))",
          "15:         assert_instance_of(Nokogiri::HTML::Document, doc)",
          "16:       end",
          "18:       def test_xml?",
          "19:         doc = Nokogiri.parse(File.read(XML_FILE))",
          "20:         assert(doc.xml?)",
          "21:         refute(doc.html?)",
          "22:       end",
          "24:       def test_atom_is_xml?",
          "25:         doc = Nokogiri.parse(File.read(XML_ATOM_FILE))",
          "26:         assert(doc.xml?)",
          "27:         refute(doc.html?)",
          "28:       end",
          "30:       def test_html?",
          "31:         doc = Nokogiri.parse(File.read(HTML_FILE))",
          "32:         refute(doc.xml?)",
          "33:         assert(doc.html?)",
          "34:       end",
          "36:       def test_nokogiri_method_with_html",
          "37:         doc1 = Nokogiri(File.read(HTML_FILE))",
          "38:         doc2 = Nokogiri.parse(File.read(HTML_FILE))",
          "39:         assert_equal(doc1.serialize, doc2.serialize)",
          "40:       end",
          "42:       def test_nokogiri_method_with_block",
          "43:         doc = Nokogiri { b(\"bold tag\") }",
          "44:         assert_equal(\"<b>bold tag</b>\", doc.to_html.chomp)",
          "45:       end",
          "47:       def test_make_with_html",
          "48:         doc = Nokogiri.make(\"<b>bold tag</b>\")",
          "49:         assert_equal(\"<b>bold tag</b>\", doc.to_html.chomp)",
          "50:       end",
          "52:       def test_make_with_block",
          "53:         doc = Nokogiri.make { b(\"bold tag\") }",
          "54:         assert_equal(\"<b>bold tag</b>\", doc.to_html.chomp)",
          "55:       end",
          "",
          "---------------"
        ],
        "test/test_xslt_transforms.rb||test/test_xslt_transforms.rb": [
          "File: test/test_xslt_transforms.rb -> test/test_xslt_transforms.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: require \"helper\"",
          "10:       end",
          "209:         assert_match(",
          "212:         )",
          "213:       end",
          "216:       end",
          "350:       end",
          "359:       end",
          "370:             <xsl:template match=\"/\">",
          "372:             </xsl:template>",
          "373:           </xsl:stylesheet>",
          "390:       end",
          "395:       end",
          "401:       end",
          "421:       end",
          "434:       end",
          "435:     end",
          "436:   end",
          "",
          "[Removed Lines]",
          "5: class Nokogiri::TestCase",
          "6:   describe Nokogiri::XSLT::Stylesheet do",
          "7:     def check_params(result_doc, params)",
          "8:       result_doc.xpath(\"/root/params/*\").each do |p|",
          "9:         assert_equal(p.content, params[p.name.intern])",
          "11:     end",
          "13:     let(:doc) { Nokogiri::XML(File.open(XML_FILE)) }",
          "15:     def test_class_methods",
          "16:       style = Nokogiri::XSLT(File.read(XSLT_FILE))",
          "18:       assert(result = style.apply_to(doc, [\"title\", '\"Grandma\"']))",
          "19:       assert_match(%r{<h1>Grandma</h1>}, result)",
          "20:     end",
          "22:     def test_transform",
          "23:       assert(style = Nokogiri::XSLT.parse(File.read(XSLT_FILE)))",
          "25:       assert(result = style.apply_to(doc, [\"title\", '\"Booyah\"']))",
          "26:       assert_match(%r{<h1>Booyah</h1>}, result)",
          "27:       assert_match(%r{<th.*Employee ID</th>}, result)",
          "28:       assert_match(%r{<th.*Name</th>}, result)",
          "29:       assert_match(%r{<th.*Position</th>}, result)",
          "30:       assert_match(%r{<th.*Salary</th>}, result)",
          "31:       assert_match(%r{<td>EMP0003</td>}, result)",
          "32:       assert_match(%r{<td>Margaret Martin</td>}, result)",
          "33:       assert_match(%r{<td>Computer Specialist</td>}, result)",
          "34:       assert_match(%r{<td>100,000</td>}, result)",
          "35:       refute_match(/Dallas|Texas/, result)",
          "36:       refute_match(/Female/, result)",
          "38:       assert(result = style.apply_to(doc, [\"title\", '\"Grandma\"']))",
          "39:       assert_match(%r{<h1>Grandma</h1>}, result)",
          "41:       assert(result = style.apply_to(doc))",
          "42:       assert_match(%r{<h1></h1>|<h1/>}, result)",
          "43:     end",
          "45:     def test_xml_declaration",
          "46:       input_xml = <<~EOS",
          "47:         <?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "48:         <report>",
          "49:           <title>My Report</title>",
          "50:         </report>",
          "51:       EOS",
          "53:       input_xsl = <<~EOS",
          "54:         <?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "55:         <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "56:           <xsl:output method=\"xml\" version=\"1.0\" encoding=\"utf-8\" indent=\"yes\"/>",
          "57:           <xsl:template match=\"/\">",
          "58:             <html>",
          "59:               <head>",
          "60:                 <title><xsl:value-of select=\"report/title\"/></title>",
          "61:               </head>",
          "62:               <body>",
          "63:                 <h1><xsl:value-of select=\"report/title\"/></h1>",
          "64:               </body>",
          "65:             </html>",
          "66:           </xsl:template>",
          "67:         </xsl:stylesheet>",
          "68:       EOS",
          "70:       require \"nokogiri\"",
          "72:       xml = ::Nokogiri::XML(input_xml)",
          "73:       xsl = ::Nokogiri::XSLT(input_xsl)",
          "75:       assert_includes(xsl.apply_to(xml), '<?xml version=\"1.0\" encoding=\"utf-8\"?>')",
          "76:     end",
          "78:     def test_transform_with_output_style",
          "79:       xslt = if Nokogiri.jruby?",
          "80:         Nokogiri::XSLT(<<~eoxslt)",
          "81:           <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>",
          "83:           <xsl:stylesheet version=\"1.0\"",
          "84:           xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "85:           <xsl:output method=\"text\" version=\"1.0\"",
          "86:           encoding=\"iso-8859-1\" indent=\"yes\"/>",
          "88:           <xsl:param name=\"title\"/>",
          "90:           <xsl:template match=\"/\">",
          "91:             <html>",
          "92:             <body>",
          "93:               <xsl:for-each select=\"staff/employee\">",
          "94:               <tr>",
          "95:                 <td><xsl:value-of select=\"employeeId\"/></td>",
          "96:                 <td><xsl:value-of select=\"name\"/></td>",
          "97:                 <td><xsl:value-of select=\"position\"/></td>",
          "98:                 <td><xsl:value-of select=\"salary\"/></td>",
          "99:               </tr>",
          "100:               </xsl:for-each>",
          "101:             </body>",
          "102:             </html>",
          "103:           </xsl:template>",
          "105:           </xsl:stylesheet>",
          "106:         eoxslt",
          "107:       else",
          "108:         Nokogiri::XSLT(<<~eoxslt)",
          "109:           <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>",
          "111:           <xsl:stylesheet version=\"1.0\"",
          "112:           xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "113:           <xsl:output method=\"text\" version=\"1.0\"",
          "114:           encoding=\"iso-8859-1\" indent=\"yes\"/>",
          "116:           <xsl:param name=\"title\"/>",
          "118:           <xsl:template match=\"/\">",
          "119:             <html>",
          "120:             <body>",
          "121:               <xsl:for-each select=\"staff/employee\">",
          "122:               <tr>",
          "123:                 <td><xsl:value-of select=\"employeeId\"/></td>",
          "124:                 <td><xsl:value-of select=\"name\"/></td>",
          "125:                 <td><xsl:value-of select=\"position\"/></td>",
          "126:                 <td><xsl:value-of select=\"salary\"/></td>",
          "127:               </tr>",
          "128:               </xsl:for-each>",
          "129:               </table>",
          "130:             </body>",
          "131:             </html>",
          "132:           </xsl:template>",
          "134:           </xsl:stylesheet>",
          "135:         eoxslt",
          "136:       end",
          "137:       result = xslt.apply_to(doc, [\"title\", \"foo\"])",
          "138:       refute_match(/<td>/, result)",
          "140:       # the entity-form is for systems with this bug with Encodings.properties",
          "141:       # https://issues.apache.org/jira/browse/XALANJ-2618",
          "142:       # a.k.a. \"Attempt to output character of integral value 48 that is not represented in specified output encoding of iso-8859-1.\"",
          "143:       assert_match(",
          "144:         /This is an adjacent|&#84;&#104;&#105;&#115;&#32;&#105;&#115;&#32;&#97;&#110;&#32;&#97;&#100;&#106;&#97;&#99;&#101;&#110;&#116;/, result",
          "145:       )",
          "146:     end",
          "148:     def test_transform_arg_error",
          "149:       assert(style = Nokogiri::XSLT(File.read(XSLT_FILE)))",
          "150:       assert_raises(TypeError) do",
          "151:         style.transform(doc, :foo)",
          "152:       end",
          "153:     end",
          "155:     def test_transform_with_hash",
          "156:       assert(style = Nokogiri::XSLT(File.read(XSLT_FILE)))",
          "157:       result = style.transform(doc, { \"title\" => '\"Booyah\"' })",
          "158:       assert(result.html?)",
          "159:       assert_equal(\"Booyah\", result.at_css(\"h1\").content)",
          "160:     end",
          "162:     def test_transform2",
          "163:       assert(style = Nokogiri::XSLT(File.open(XSLT_FILE)))",
          "164:       assert(result_doc = style.transform(doc))",
          "165:       assert(result_doc.html?)",
          "166:       assert_equal(\"\", result_doc.at_css(\"h1\").content)",
          "168:       assert(style = Nokogiri::XSLT(File.read(XSLT_FILE)))",
          "169:       assert(result_doc = style.transform(doc, [\"title\", '\"Booyah\"']))",
          "170:       assert(result_doc.html?)",
          "171:       assert_equal(\"Booyah\", result_doc.at_css(\"h1\").content)",
          "173:       assert(result_string = style.apply_to(doc, [\"title\", '\"Booyah\"']))",
          "174:       assert_equal(result_string, style.serialize(result_doc))",
          "175:     end",
          "177:     def test_transform_with_quote_params",
          "178:       assert(style = Nokogiri::XSLT(File.open(XSLT_FILE)))",
          "179:       assert(result_doc = style.transform(doc, Nokogiri::XSLT.quote_params([\"title\", \"Booyah\"])))",
          "180:       assert(result_doc.html?)",
          "181:       assert_equal(\"Booyah\", result_doc.at_css(\"h1\").content)",
          "183:       assert(style = Nokogiri::XSLT.parse(File.read(XSLT_FILE)))",
          "184:       assert(result_doc = style.transform(doc, Nokogiri::XSLT.quote_params({ \"title\" => \"Booyah\" })))",
          "185:       assert(result_doc.html?)",
          "186:       assert_equal(\"Booyah\", result_doc.at_css(\"h1\").content)",
          "187:     end",
          "189:     def test_exslt",
          "190:       # see http://yokolet.blogspot.com/2010/10/pure-java-nokogiri-xslt-extension.html\")",
          "191:       skip_unless_libxml2(\"cannot get it working on JRuby\")",
          "193:       assert(doc = Nokogiri::XML.parse(File.read(EXML_FILE)))",
          "194:       assert(doc.xml?)",
          "196:       assert(style = Nokogiri::XSLT.parse(File.read(EXSLT_FILE)))",
          "197:       params = {",
          "198:         p1: \"xxx\",",
          "199:         p2: \"x'x'x\",",
          "200:         p3: 'x\"x\"x',",
          "201:         p4: '\"xxx\"',",
          "202:       }",
          "203:       result_doc = Nokogiri::XML.parse(style.apply_to(doc,",
          "204:         Nokogiri::XSLT.quote_params(params)))",
          "206:       assert_equal(\"func-result\", result_doc.at(\"/root/function\").content)",
          "207:       assert_equal(3, result_doc.at(\"/root/max\").content.to_i)",
          "208:       if Nokogiri::VersionInfo.instance.libxslt_has_datetime?",
          "210:           /\\d{4}-\\d\\d-\\d\\d([-|+]\\d\\d:\\d\\d)?/,",
          "211:           result_doc.at(\"/root/date\").content",
          "214:       result_doc.xpath(\"/root/params/*\").each do |p|",
          "215:         assert_equal(p.content, params[p.name.intern])",
          "217:       check_params(result_doc, params)",
          "218:       result_doc = Nokogiri::XML.parse(style.apply_to(doc,",
          "219:         Nokogiri::XSLT.quote_params(params.to_a.flatten)))",
          "220:       check_params(result_doc, params)",
          "221:     end",
          "223:     def test_xslt_paramaters",
          "224:       # see http://yokolet.blogspot.com/2010/10/pure-java-nokogiri-xslt-extension.html\")",
          "225:       skip_unless_libxml2(\"cannot get it working on JRuby\")",
          "227:       xslt_str = <<~EOX",
          "228:         <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" >",
          "229:           <xsl:template match=\"/\">",
          "230:             <xsl:value-of select=\"$foo\" />",
          "231:           </xsl:template>",
          "232:         </xsl:stylesheet>",
          "233:       EOX",
          "235:       xslt = Nokogiri::XSLT(xslt_str)",
          "236:       doc = Nokogiri::XML(\"<root />\")",
          "237:       assert_match(/bar/, xslt.transform(doc, Nokogiri::XSLT.quote_params(\"foo\" => \"bar\")).to_s)",
          "238:     end",
          "240:     def test_xslt_transform_error",
          "241:       # see http://yokolet.blogspot.com/2010/10/pure-java-nokogiri-xslt-extension.html\")",
          "242:       skip_unless_libxml2(\"cannot get it working on JRuby\")",
          "244:       xslt_str = <<~EOX",
          "245:         <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" >",
          "246:           <xsl:template match=\"/\">",
          "247:             <xsl:value-of select=\"$foo\" />",
          "248:           </xsl:template>",
          "249:         </xsl:stylesheet>",
          "250:       EOX",
          "252:       xslt = Nokogiri::XSLT(xslt_str)",
          "253:       doc = Nokogiri::XML(\"<root />\")",
          "254:       assert_raises(RuntimeError) { xslt.transform(doc) }",
          "255:     end",
          "257:     def test_xslt_parse_error",
          "258:       xslt_str = <<~EOX",
          "259:         <xsl:stylesheet version=\"1.0\"",
          "260:          xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "261:           <!-- Not well-formed: -->",
          "262:           <xsl:template match=\"/\"/>",
          "263:             <values>",
          "264:               <xsl:for-each select=\"//*\">",
          "265:                 <value>",
          "266:                   <xsl:value-of select=\"@id\"/>",
          "267:                 </value>",
          "268:               </xsl:for-each>",
          "269:             </values>",
          "270:           </xsl:template>",
          "271:         </xsl:stylesheet>}",
          "272:       EOX",
          "273:       assert_raises(RuntimeError) { Nokogiri::XSLT.parse(xslt_str) }",
          "274:     end",
          "276:     def test_passing_a_non_document_to_transform",
          "277:       xsl = Nokogiri::XSLT('<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"></xsl:stylesheet>')",
          "278:       assert_raises(ArgumentError) { xsl.transform(\"<div></div>\") }",
          "279:       assert_raises(ArgumentError) { xsl.transform(Nokogiri::HTML(\"\").css(\"body\")) }",
          "280:     end",
          "282:     def test_non_html_xslt_transform",
          "283:       xml = Nokogiri.XML(<<~EOXML)",
          "284:         <a>",
          "285:           <b>",
          "286:           <c>123</c>",
          "287:             </b>",
          "288:           </a>",
          "289:       EOXML",
          "291:       xsl = Nokogiri.XSLT(<<~EOXSL)",
          "292:         <xsl:stylesheet version=\"1.0\"",
          "293:                         xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "295:           <xsl:output encoding=\"UTF-8\" indent=\"yes\" method=\"xml\" />",
          "297:           <xsl:template match=\"/\">",
          "298:             <a><xsl:value-of select=\"/a\" /></a>",
          "299:           </xsl:template>",
          "300:         </xsl:stylesheet>",
          "301:       EOXSL",
          "303:       result = xsl.transform(xml)",
          "304:       refute(result.html?)",
          "305:     end",
          "307:     it \"should not crash when given XPath 2.0 features\" do",
          "308:       #",
          "309:       #  https://github.com/sparklemotion/nokogiri/issues/1802",
          "310:       #",
          "311:       #  note that here the XPath 2.0 feature is `decimal`.",
          "312:       #  this test case is taken from the example provided in the original issue.",
          "313:       #",
          "314:       xml = <<~EOXML",
          "315:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "316:         <Invoice xmlns=\"urn:oasis:names:specification:ubl:schema:xsd:Invoice-2\"",
          "317:                  xmlns:cac=\"urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2\"",
          "318:                  xmlns:cbc=\"urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2\"",
          "319:                  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
          "320:                  xsi:schemaLocation=\"urn:oasis:names:specification:ubl:schema:xsd:Invoice-2\">",
          "321:           <cac:TaxTotal>",
          "322:             <cbc:TaxAmount currencyID=\"EUR\">48.00</cbc:TaxAmount>",
          "323:           </cac:TaxTotal>",
          "324:         </Invoice>",
          "325:       EOXML",
          "327:       xsl = <<~EOXSL",
          "328:         <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>",
          "329:         <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"",
          "330:                         xmlns:cbc=\"urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2\"",
          "331:                         xmlns:cac=\"urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2\"",
          "332:                         xmlns:ubl=\"urn:oasis:names:specification:ubl:schema:xsd:Invoice-2\"",
          "333:                         xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"",
          "334:                         version=\"1.0\">",
          "335:           <xsl:template match=\"/\">",
          "336:             <xsl:apply-templates select=\"/\" mode=\"qwerty\"/>",
          "337:           </xsl:template>",
          "338:           <xsl:template match=\"/ubl:Invoice/cac:TaxTotal\" priority=\"1001\" mode=\"qwerty\">",
          "339:             <xsl:choose>",
          "340:               <xsl:when test=\"(round(xs:decimal(child::cbc:TaxAmount)))\"/>",
          "341:             </xsl:choose>",
          "342:           </xsl:template>",
          "343:         </xsl:stylesheet>",
          "344:       EOXSL",
          "346:       doc = Nokogiri::XML(xml)",
          "347:       xslt = Nokogiri::XSLT(xsl)",
          "348:       exception = assert_raises(RuntimeError) do",
          "349:         xslt.transform(doc)",
          "351:       assert_match(/decimal/, exception.message)",
          "352:     end",
          "354:     describe \"DEFAULT_XSLT parse options\" do",
          "355:       it \"is the union of DEFAULT_XML and libxslt's XSLT_PARSE_OPTIONS\" do",
          "356:         xslt_parse_options = Nokogiri::XML::ParseOptions.new.noent.dtdload.dtdattr.nocdata",
          "357:         expected = Nokogiri::XML::ParseOptions::DEFAULT_XML | xslt_parse_options.options",
          "358:         assert_equal(expected, Nokogiri::XML::ParseOptions::DEFAULT_XSLT)",
          "361:       it \"parses docs the same as xsltproc\" do",
          "362:         skip_unless_libxml2(\"JRuby implementation disallows this edge case XSLT\")",
          "364:         # see https://github.com/sparklemotion/nokogiri/issues/1940",
          "365:         xml = \"<t></t>\"",
          "366:         xsl = <<~EOF",
          "367:           <?xml version=\"1.0\"?>",
          "368:           <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "369:           <xsl:output method=\"text\" omit-xml-declaration=\"no\" />",
          "371:               <xsl:text disable-output-escaping=\"yes\"><![CDATA[<>]]></xsl:text>",
          "374:         EOF",
          "376:         doc = Nokogiri::XML(xml)",
          "377:         stylesheet = Nokogiri::XSLT(xsl)",
          "379:         # TODO: ideally I'd like to be able to access the parse options in the final object",
          "380:         # assert_equal(Nokogiri::XML::ParseOptions::DEFAULT_XSLT, stylesheet.document.parse_options)",
          "382:         result = stylesheet.transform(doc)",
          "383:         assert_equal(\"<>\", result.children.to_xml)",
          "384:       end",
          "385:     end",
          "387:     describe \"XSLT.quote_params\" do",
          "388:       it \"returns quoted values\" do",
          "389:         assert_equal([\"asdf\", \"'qwer'\"], Nokogiri::XSLT.quote_params({ \"asdf\" => \"qwer\" }))",
          "392:       it \"stringifies non-string keys and values\" do",
          "393:         assert_equal([\"asdf\", \"'1234'\"], Nokogiri::XSLT.quote_params({ asdf: 1234 }))",
          "394:         assert_equal([\"1234\", \"'asdf'\"], Nokogiri::XSLT.quote_params({ 1234 => :asdf }))",
          "397:       it \"handles multiple key-value pairs\" do",
          "398:         actual = Nokogiri::XSLT.quote_params({ \"abcd\" => \"efgh\", \"ijkl\" => \"mnop\" })",
          "399:         expected = [\"abcd\", \"'efgh'\", \"ijkl\", \"'mnop'\"]",
          "400:         assert_equal(expected, actual)",
          "403:       it \"handles an array of pairs\" do",
          "404:         actual = Nokogiri::XSLT.quote_params([\"abcd\", \"efgh\", \"ijkl\", \"mnop\"])",
          "405:         expected = [\"abcd\", \"'efgh'\", \"ijkl\", \"'mnop'\"]",
          "406:         assert_equal(expected, actual)",
          "407:       end",
          "409:       it \"handles double quotes\" do",
          "410:         assert_equal([\"a\", %{'\"asdf\"'}], Nokogiri::XSLT.quote_params({ \"a\" => %{\"asdf\"} }))",
          "411:       end",
          "413:       it \"handles single quotes\" do",
          "414:         actual = Nokogiri::XSLT.quote_params({ \"a\" => %{'asdf'} })",
          "415:         expected = [\"a\", %{concat('', \"'\", 'asdf', \"'\", '')}]",
          "416:         assert_equal(expected, actual)",
          "418:         actual = Nokogiri::XSLT.quote_params({ \"a\" => %{a'sd'f} })",
          "419:         expected = [\"a\", %{concat('a', \"'\", 'sd', \"'\", 'f')}]",
          "420:         assert_equal(expected, actual)",
          "423:       it \"does not change the input parameters\" do",
          "424:         input_h = { \"abcd\" => \"efgh\", \"ijkl\" => \"mnop\" }",
          "425:         expected_h = input_h.dup",
          "426:         input_a = input_h.to_a.flatten",
          "427:         expected_a = input_a.dup",
          "429:         Nokogiri::XSLT.quote_params(input_h)",
          "430:         assert_equal(expected_h, input_h)",
          "432:         Nokogiri::XSLT.quote_params(input_a)",
          "433:         assert_equal(expected_a, input_a)",
          "",
          "[Added Lines]",
          "5: module Nokogiri",
          "6:   class TestCase",
          "7:     describe Nokogiri::XSLT::Stylesheet do",
          "8:       def check_params(result_doc, params)",
          "9:         result_doc.xpath(\"/root/params/*\").each do |p|",
          "10:           assert_equal(p.content, params[p.name.intern])",
          "11:         end",
          "14:       let(:doc) { Nokogiri::XML(File.open(XML_FILE)) }",
          "16:       def test_class_methods",
          "17:         style = Nokogiri::XSLT(File.read(XSLT_FILE))",
          "19:         assert(result = style.apply_to(doc, [\"title\", '\"Grandma\"']))",
          "20:         assert_match(%r{<h1>Grandma</h1>}, result)",
          "21:       end",
          "23:       def test_transform",
          "24:         assert(style = Nokogiri::XSLT.parse(File.read(XSLT_FILE)))",
          "26:         assert(result = style.apply_to(doc, [\"title\", '\"Booyah\"']))",
          "27:         assert_match(%r{<h1>Booyah</h1>}, result)",
          "28:         assert_match(%r{<th.*Employee ID</th>}, result)",
          "29:         assert_match(%r{<th.*Name</th>}, result)",
          "30:         assert_match(%r{<th.*Position</th>}, result)",
          "31:         assert_match(%r{<th.*Salary</th>}, result)",
          "32:         assert_match(%r{<td>EMP0003</td>}, result)",
          "33:         assert_match(%r{<td>Margaret Martin</td>}, result)",
          "34:         assert_match(%r{<td>Computer Specialist</td>}, result)",
          "35:         assert_match(%r{<td>100,000</td>}, result)",
          "36:         refute_match(/Dallas|Texas/, result)",
          "37:         refute_match(/Female/, result)",
          "39:         assert(result = style.apply_to(doc, [\"title\", '\"Grandma\"']))",
          "40:         assert_match(%r{<h1>Grandma</h1>}, result)",
          "42:         assert(result = style.apply_to(doc))",
          "43:         assert_match(%r{<h1></h1>|<h1/>}, result)",
          "44:       end",
          "46:       def test_xml_declaration",
          "47:         input_xml = <<~EOS",
          "48:           <?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "49:           <report>",
          "50:             <title>My Report</title>",
          "51:           </report>",
          "52:         EOS",
          "54:         input_xsl = <<~EOS",
          "55:           <?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "56:           <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "57:             <xsl:output method=\"xml\" version=\"1.0\" encoding=\"utf-8\" indent=\"yes\"/>",
          "58:             <xsl:template match=\"/\">",
          "59:               <html>",
          "60:                 <head>",
          "61:                   <title><xsl:value-of select=\"report/title\"/></title>",
          "62:                 </head>",
          "63:                 <body>",
          "64:                   <h1><xsl:value-of select=\"report/title\"/></h1>",
          "65:                 </body>",
          "66:               </html>",
          "67:             </xsl:template>",
          "68:           </xsl:stylesheet>",
          "69:         EOS",
          "71:         require \"nokogiri\"",
          "73:         xml = ::Nokogiri::XML(input_xml)",
          "74:         xsl = ::Nokogiri::XSLT(input_xsl)",
          "76:         assert_includes(xsl.apply_to(xml), '<?xml version=\"1.0\" encoding=\"utf-8\"?>')",
          "77:       end",
          "79:       def test_transform_with_output_style",
          "80:         xslt = if Nokogiri.jruby?",
          "81:           Nokogiri::XSLT(<<~eoxslt)",
          "82:             <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>",
          "84:             <xsl:stylesheet version=\"1.0\"",
          "85:             xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "86:             <xsl:output method=\"text\" version=\"1.0\"",
          "87:             encoding=\"iso-8859-1\" indent=\"yes\"/>",
          "89:             <xsl:param name=\"title\"/>",
          "91:             <xsl:template match=\"/\">",
          "92:               <html>",
          "93:               <body>",
          "94:                 <xsl:for-each select=\"staff/employee\">",
          "95:                 <tr>",
          "96:                   <td><xsl:value-of select=\"employeeId\"/></td>",
          "97:                   <td><xsl:value-of select=\"name\"/></td>",
          "98:                   <td><xsl:value-of select=\"position\"/></td>",
          "99:                   <td><xsl:value-of select=\"salary\"/></td>",
          "100:                 </tr>",
          "101:                 </xsl:for-each>",
          "102:               </body>",
          "103:               </html>",
          "104:             </xsl:template>",
          "106:             </xsl:stylesheet>",
          "107:           eoxslt",
          "108:         else",
          "109:           Nokogiri::XSLT(<<~eoxslt)",
          "110:             <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>",
          "112:             <xsl:stylesheet version=\"1.0\"",
          "113:             xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "114:             <xsl:output method=\"text\" version=\"1.0\"",
          "115:             encoding=\"iso-8859-1\" indent=\"yes\"/>",
          "117:             <xsl:param name=\"title\"/>",
          "119:             <xsl:template match=\"/\">",
          "120:               <html>",
          "121:               <body>",
          "122:                 <xsl:for-each select=\"staff/employee\">",
          "123:                 <tr>",
          "124:                   <td><xsl:value-of select=\"employeeId\"/></td>",
          "125:                   <td><xsl:value-of select=\"name\"/></td>",
          "126:                   <td><xsl:value-of select=\"position\"/></td>",
          "127:                   <td><xsl:value-of select=\"salary\"/></td>",
          "128:                 </tr>",
          "129:                 </xsl:for-each>",
          "130:                 </table>",
          "131:               </body>",
          "132:               </html>",
          "133:             </xsl:template>",
          "135:             </xsl:stylesheet>",
          "136:           eoxslt",
          "137:         end",
          "138:         result = xslt.apply_to(doc, [\"title\", \"foo\"])",
          "139:         refute_match(/<td>/, result)",
          "141:         # the entity-form is for systems with this bug with Encodings.properties",
          "142:         # https://issues.apache.org/jira/browse/XALANJ-2618",
          "143:         # a.k.a. \"Attempt to output character of integral value 48 that is not represented in specified output encoding of iso-8859-1.\"",
          "145:           /This is an adjacent|&#84;&#104;&#105;&#115;&#32;&#105;&#115;&#32;&#97;&#110;&#32;&#97;&#100;&#106;&#97;&#99;&#101;&#110;&#116;/, result",
          "149:       def test_transform_arg_error",
          "150:         assert(style = Nokogiri::XSLT(File.read(XSLT_FILE)))",
          "151:         assert_raises(TypeError) do",
          "152:           style.transform(doc, :foo)",
          "153:         end",
          "156:       def test_transform_with_hash",
          "157:         assert(style = Nokogiri::XSLT(File.read(XSLT_FILE)))",
          "158:         result = style.transform(doc, { \"title\" => '\"Booyah\"' })",
          "159:         assert(result.html?)",
          "160:         assert_equal(\"Booyah\", result.at_css(\"h1\").content)",
          "161:       end",
          "163:       def test_transform2",
          "164:         assert(style = Nokogiri::XSLT(File.open(XSLT_FILE)))",
          "165:         assert(result_doc = style.transform(doc))",
          "166:         assert(result_doc.html?)",
          "167:         assert_equal(\"\", result_doc.at_css(\"h1\").content)",
          "169:         assert(style = Nokogiri::XSLT(File.read(XSLT_FILE)))",
          "170:         assert(result_doc = style.transform(doc, [\"title\", '\"Booyah\"']))",
          "171:         assert(result_doc.html?)",
          "172:         assert_equal(\"Booyah\", result_doc.at_css(\"h1\").content)",
          "174:         assert(result_string = style.apply_to(doc, [\"title\", '\"Booyah\"']))",
          "175:         assert_equal(result_string, style.serialize(result_doc))",
          "176:       end",
          "178:       def test_transform_with_quote_params",
          "179:         assert(style = Nokogiri::XSLT(File.open(XSLT_FILE)))",
          "180:         assert(result_doc = style.transform(doc, Nokogiri::XSLT.quote_params([\"title\", \"Booyah\"])))",
          "181:         assert(result_doc.html?)",
          "182:         assert_equal(\"Booyah\", result_doc.at_css(\"h1\").content)",
          "184:         assert(style = Nokogiri::XSLT.parse(File.read(XSLT_FILE)))",
          "185:         assert(result_doc = style.transform(doc, Nokogiri::XSLT.quote_params({ \"title\" => \"Booyah\" })))",
          "186:         assert(result_doc.html?)",
          "187:         assert_equal(\"Booyah\", result_doc.at_css(\"h1\").content)",
          "190:       def test_exslt",
          "191:         # see http://yokolet.blogspot.com/2010/10/pure-java-nokogiri-xslt-extension.html\")",
          "192:         skip_unless_libxml2(\"cannot get it working on JRuby\")",
          "194:         assert(doc = Nokogiri::XML.parse(File.read(EXML_FILE)))",
          "195:         assert(doc.xml?)",
          "197:         assert(style = Nokogiri::XSLT.parse(File.read(EXSLT_FILE)))",
          "198:         params = {",
          "199:           p1: \"xxx\",",
          "200:           p2: \"x'x'x\",",
          "201:           p3: 'x\"x\"x',",
          "202:           p4: '\"xxx\"',",
          "203:         }",
          "204:         result_doc = Nokogiri::XML.parse(style.apply_to(doc,",
          "205:           Nokogiri::XSLT.quote_params(params)))",
          "207:         assert_equal(\"func-result\", result_doc.at(\"/root/function\").content)",
          "208:         assert_equal(3, result_doc.at(\"/root/max\").content.to_i)",
          "209:         if Nokogiri::VersionInfo.instance.libxslt_has_datetime?",
          "210:           assert_match(",
          "211:             /\\d{4}-\\d\\d-\\d\\d([-|+]\\d\\d:\\d\\d)?/,",
          "212:             result_doc.at(\"/root/date\").content",
          "213:           )",
          "214:         end",
          "215:         result_doc.xpath(\"/root/params/*\").each do |p|",
          "216:           assert_equal(p.content, params[p.name.intern])",
          "217:         end",
          "218:         check_params(result_doc, params)",
          "219:         result_doc = Nokogiri::XML.parse(style.apply_to(doc,",
          "220:           Nokogiri::XSLT.quote_params(params.to_a.flatten)))",
          "221:         check_params(result_doc, params)",
          "224:       def test_xslt_paramaters",
          "225:         # see http://yokolet.blogspot.com/2010/10/pure-java-nokogiri-xslt-extension.html\")",
          "226:         skip_unless_libxml2(\"cannot get it working on JRuby\")",
          "228:         xslt_str = <<~EOX",
          "229:           <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" >",
          "231:               <xsl:value-of select=\"$foo\" />",
          "234:         EOX",
          "236:         xslt = Nokogiri::XSLT(xslt_str)",
          "237:         doc = Nokogiri::XML(\"<root />\")",
          "238:         assert_match(/bar/, xslt.transform(doc, Nokogiri::XSLT.quote_params(\"foo\" => \"bar\")).to_s)",
          "239:       end",
          "241:       def test_xslt_transform_error",
          "242:         # see http://yokolet.blogspot.com/2010/10/pure-java-nokogiri-xslt-extension.html\")",
          "243:         skip_unless_libxml2(\"cannot get it working on JRuby\")",
          "245:         xslt_str = <<~EOX",
          "246:           <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" >",
          "247:             <xsl:template match=\"/\">",
          "248:               <xsl:value-of select=\"$foo\" />",
          "249:             </xsl:template>",
          "250:           </xsl:stylesheet>",
          "251:         EOX",
          "253:         xslt = Nokogiri::XSLT(xslt_str)",
          "254:         doc = Nokogiri::XML(\"<root />\")",
          "255:         assert_raises(RuntimeError) { xslt.transform(doc) }",
          "258:       def test_xslt_parse_error",
          "259:         xslt_str = <<~EOX",
          "260:           <xsl:stylesheet version=\"1.0\"",
          "261:            xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "262:             <!-- Not well-formed: -->",
          "263:             <xsl:template match=\"/\"/>",
          "264:               <values>",
          "265:                 <xsl:for-each select=\"//*\">",
          "266:                   <value>",
          "267:                     <xsl:value-of select=\"@id\"/>",
          "268:                   </value>",
          "269:                 </xsl:for-each>",
          "270:               </values>",
          "271:             </xsl:template>",
          "272:           </xsl:stylesheet>}",
          "273:         EOX",
          "274:         assert_raises(RuntimeError) { Nokogiri::XSLT.parse(xslt_str) }",
          "277:       def test_passing_a_non_document_to_transform",
          "278:         xsl = Nokogiri::XSLT('<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"></xsl:stylesheet>')",
          "279:         assert_raises(ArgumentError) { xsl.transform(\"<div></div>\") }",
          "280:         assert_raises(ArgumentError) { xsl.transform(Nokogiri::HTML(\"\").css(\"body\")) }",
          "283:       def test_non_html_xslt_transform",
          "284:         xml = Nokogiri.XML(<<~EOXML)",
          "285:           <a>",
          "286:             <b>",
          "287:             <c>123</c>",
          "288:               </b>",
          "289:             </a>",
          "290:         EOXML",
          "292:         xsl = Nokogiri.XSLT(<<~EOXSL)",
          "293:           <xsl:stylesheet version=\"1.0\"",
          "294:                           xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "296:             <xsl:output encoding=\"UTF-8\" indent=\"yes\" method=\"xml\" />",
          "298:             <xsl:template match=\"/\">",
          "299:               <a><xsl:value-of select=\"/a\" /></a>",
          "300:             </xsl:template>",
          "301:           </xsl:stylesheet>",
          "302:         EOXSL",
          "304:         result = xsl.transform(xml)",
          "305:         refute(result.html?)",
          "308:       it \"should not crash when given XPath 2.0 features\" do",
          "309:         #",
          "310:         #  https://github.com/sparklemotion/nokogiri/issues/1802",
          "311:         #",
          "312:         #  note that here the XPath 2.0 feature is `decimal`.",
          "313:         #  this test case is taken from the example provided in the original issue.",
          "314:         #",
          "315:         xml = <<~EOXML",
          "316:           <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "317:           <Invoice xmlns=\"urn:oasis:names:specification:ubl:schema:xsd:Invoice-2\"",
          "318:                    xmlns:cac=\"urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2\"",
          "319:                    xmlns:cbc=\"urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2\"",
          "320:                    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
          "321:                    xsi:schemaLocation=\"urn:oasis:names:specification:ubl:schema:xsd:Invoice-2\">",
          "322:             <cac:TaxTotal>",
          "323:               <cbc:TaxAmount currencyID=\"EUR\">48.00</cbc:TaxAmount>",
          "324:             </cac:TaxTotal>",
          "325:           </Invoice>",
          "326:         EOXML",
          "328:         xsl = <<~EOXSL",
          "329:           <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>",
          "330:           <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"",
          "331:                           xmlns:cbc=\"urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2\"",
          "332:                           xmlns:cac=\"urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2\"",
          "333:                           xmlns:ubl=\"urn:oasis:names:specification:ubl:schema:xsd:Invoice-2\"",
          "334:                           xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"",
          "335:                           version=\"1.0\">",
          "336:             <xsl:template match=\"/\">",
          "337:               <xsl:apply-templates select=\"/\" mode=\"qwerty\"/>",
          "338:             </xsl:template>",
          "339:             <xsl:template match=\"/ubl:Invoice/cac:TaxTotal\" priority=\"1001\" mode=\"qwerty\">",
          "340:               <xsl:choose>",
          "341:                 <xsl:when test=\"(round(xs:decimal(child::cbc:TaxAmount)))\"/>",
          "342:               </xsl:choose>",
          "343:             </xsl:template>",
          "344:           </xsl:stylesheet>",
          "345:         EOXSL",
          "347:         doc = Nokogiri::XML(xml)",
          "348:         xslt = Nokogiri::XSLT(xsl)",
          "349:         exception = assert_raises(RuntimeError) do",
          "350:           xslt.transform(doc)",
          "351:         end",
          "352:         assert_match(/decimal/, exception.message)",
          "353:       end",
          "355:       describe \"DEFAULT_XSLT parse options\" do",
          "356:         it \"is the union of DEFAULT_XML and libxslt's XSLT_PARSE_OPTIONS\" do",
          "357:           xslt_parse_options = Nokogiri::XML::ParseOptions.new.noent.dtdload.dtdattr.nocdata",
          "358:           expected = Nokogiri::XML::ParseOptions::DEFAULT_XML | xslt_parse_options.options",
          "359:           assert_equal(expected, Nokogiri::XML::ParseOptions::DEFAULT_XSLT)",
          "360:         end",
          "362:         it \"parses docs the same as xsltproc\" do",
          "363:           skip_unless_libxml2(\"JRuby implementation disallows this edge case XSLT\")",
          "365:           # see https://github.com/sparklemotion/nokogiri/issues/1940",
          "366:           xml = \"<t></t>\"",
          "367:           xsl = <<~EOF",
          "368:             <?xml version=\"1.0\"?>",
          "369:             <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
          "370:             <xsl:output method=\"text\" omit-xml-declaration=\"no\" />",
          "371:               <xsl:template match=\"/\">",
          "372:                 <xsl:text disable-output-escaping=\"yes\"><![CDATA[<>]]></xsl:text>",
          "373:               </xsl:template>",
          "374:             </xsl:stylesheet>",
          "375:           EOF",
          "377:           doc = Nokogiri::XML(xml)",
          "378:           stylesheet = Nokogiri::XSLT(xsl)",
          "380:           # TODO: ideally I'd like to be able to access the parse options in the final object",
          "381:           # assert_equal(Nokogiri::XML::ParseOptions::DEFAULT_XSLT, stylesheet.document.parse_options)",
          "383:           result = stylesheet.transform(doc)",
          "384:           assert_equal(\"<>\", result.children.to_xml)",
          "385:         end",
          "386:       end",
          "388:       describe \"XSLT.quote_params\" do",
          "389:         it \"returns quoted values\" do",
          "390:           assert_equal([\"asdf\", \"'qwer'\"], Nokogiri::XSLT.quote_params({ \"asdf\" => \"qwer\" }))",
          "391:         end",
          "393:         it \"stringifies non-string keys and values\" do",
          "394:           assert_equal([\"asdf\", \"'1234'\"], Nokogiri::XSLT.quote_params({ asdf: 1234 }))",
          "395:           assert_equal([\"1234\", \"'asdf'\"], Nokogiri::XSLT.quote_params({ 1234 => :asdf }))",
          "396:         end",
          "398:         it \"handles multiple key-value pairs\" do",
          "399:           actual = Nokogiri::XSLT.quote_params({ \"abcd\" => \"efgh\", \"ijkl\" => \"mnop\" })",
          "400:           expected = [\"abcd\", \"'efgh'\", \"ijkl\", \"'mnop'\"]",
          "401:           assert_equal(expected, actual)",
          "402:         end",
          "404:         it \"handles an array of pairs\" do",
          "405:           actual = Nokogiri::XSLT.quote_params([\"abcd\", \"efgh\", \"ijkl\", \"mnop\"])",
          "406:           expected = [\"abcd\", \"'efgh'\", \"ijkl\", \"'mnop'\"]",
          "407:           assert_equal(expected, actual)",
          "408:         end",
          "410:         it \"handles double quotes\" do",
          "411:           assert_equal([\"a\", %{'\"asdf\"'}], Nokogiri::XSLT.quote_params({ \"a\" => %{\"asdf\"} }))",
          "412:         end",
          "414:         it \"handles single quotes\" do",
          "415:           actual = Nokogiri::XSLT.quote_params({ \"a\" => %{'asdf'} })",
          "416:           expected = [\"a\", %{concat('', \"'\", 'asdf', \"'\", '')}]",
          "417:           assert_equal(expected, actual)",
          "419:           actual = Nokogiri::XSLT.quote_params({ \"a\" => %{a'sd'f} })",
          "420:           expected = [\"a\", %{concat('a', \"'\", 'sd', \"'\", 'f')}]",
          "421:           assert_equal(expected, actual)",
          "422:         end",
          "424:         it \"does not change the input parameters\" do",
          "425:           input_h = { \"abcd\" => \"efgh\", \"ijkl\" => \"mnop\" }",
          "426:           expected_h = input_h.dup",
          "427:           input_a = input_h.to_a.flatten",
          "428:           expected_a = input_a.dup",
          "430:           Nokogiri::XSLT.quote_params(input_h)",
          "431:           assert_equal(expected_h, input_h)",
          "433:           Nokogiri::XSLT.quote_params(input_a)",
          "434:           assert_equal(expected_a, input_a)",
          "435:         end",
          "",
          "---------------"
        ],
        "test/xml/node/test_attribute_methods.rb||test/xml/node/test_attribute_methods.rb": [
          "File: test/xml/node/test_attribute_methods.rb -> test/xml/node/test_attribute_methods.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: require \"helper\"",
          "103:         <div>",
          "104:           <p class=\" foo  bar foo \">test</p>",
          "105:           <p class=\"\">test</p>",
          "106:         </div>",
          "118:         <div>",
          "119:           <p class=\" foo  bar foo \">test</p>",
          "120:           <p class=\"\">test</p>",
          "121:         </div>",
          "138:         <div>",
          "139:           <p class=\" foo  bar foo \">test</p>",
          "140:           <p class=\"\">test</p>",
          "141:         </div>",
          "158:         <div>",
          "159:           <p class=\" foo  bar baz foo \">test</p>",
          "160:           <p class=\" foo  bar baz foo \">test</p>",
          "161:           <p class=\"foo foo\">test</p>",
          "162:           <p class=\"\">test</p>",
          "163:         </div>",
          "201:         end",
          "206:           end",
          "216:           end",
          "243:           end",
          "250:           end",
          "311:           end",
          "318:           end",
          "319:         end",
          "324:       end",
          "325:     end",
          "326:   end",
          "",
          "[Removed Lines]",
          "5: class Nokogiri::XML::Node",
          "6:   class TestAttributeMethods < Nokogiri::TestCase",
          "7:     def setup",
          "8:       super",
          "9:       @xml = Nokogiri::XML(File.read(XML_FILE), XML_FILE)",
          "10:     end",
          "12:     def test_each",
          "13:       attributes = []",
          "14:       @xml.xpath(\"//address\")[1].each do |key, value|",
          "15:         attributes << [key, value]",
          "16:       end",
          "17:       assert_equal([[\"domestic\", \"Yes\"], [\"street\", \"Yes\"]], attributes)",
          "18:     end",
          "20:     def test_remove_attribute",
          "21:       address = @xml.xpath(\"/staff/employee/address\").first",
          "22:       assert_equal(\"Yes\", address[\"domestic\"])",
          "23:       attr = address.attributes[\"domestic\"]",
          "25:       returned_attr = address.remove_attribute(\"domestic\")",
          "26:       assert_nil(address[\"domestic\"])",
          "27:       assert_equal(attr, returned_attr)",
          "28:     end",
          "30:     def test_remove_attribute_when_not_found",
          "31:       address = @xml.xpath(\"/staff/employee/address\").first",
          "32:       attr = address.remove_attribute(\"not-an-attribute\")",
          "33:       assert_nil(attr)",
          "34:     end",
          "36:     def test_attribute_setter_accepts_non_string",
          "37:       address = @xml.xpath(\"/staff/employee/address\").first",
          "38:       assert_equal(\"Yes\", address[:domestic])",
          "39:       address[:domestic] = \"Altered Yes\"",
          "40:       assert_equal(\"Altered Yes\", address[:domestic])",
          "41:     end",
          "43:     def test_attribute_accessor_accepts_non_string",
          "44:       address = @xml.xpath(\"/staff/employee/address\").first",
          "45:       assert_equal(\"Yes\", address[\"domestic\"])",
          "46:       assert_equal(\"Yes\", address[:domestic])",
          "47:     end",
          "49:     def test_empty_attribute_reading",
          "50:       node = Nokogiri::XML('<foo empty=\"\" whitespace=\"  \"/>')",
          "52:       assert_equal(\"\", node.root[\"empty\"])",
          "53:       assert_equal(\"  \", node.root[\"whitespace\"])",
          "54:     end",
          "56:     def test_delete",
          "57:       address = @xml.xpath(\"/staff/employee/address\").first",
          "58:       assert_equal(\"Yes\", address[\"domestic\"])",
          "59:       address.delete(\"domestic\")",
          "60:       assert_nil(address[\"domestic\"])",
          "61:     end",
          "63:     def test_attributes",
          "64:       assert(node = @xml.search(\"//address\").first)",
          "65:       assert_nil(node[\"asdfasdfasdf\"])",
          "66:       assert_equal(\"Yes\", node[\"domestic\"])",
          "68:       assert(node = @xml.search(\"//address\")[2])",
          "69:       attr = node.attributes",
          "70:       assert_equal(2, attr.size)",
          "71:       assert_equal(\"Yes\", attr[\"domestic\"].value)",
          "72:       assert_equal(\"Yes\", attr[\"domestic\"].to_s)",
          "73:       assert_equal(\"No\", attr[\"street\"].value)",
          "74:     end",
          "76:     def test_values",
          "77:       assert_equal([\"Yes\", \"Yes\"], @xml.xpath(\"//address\")[1].values)",
          "78:     end",
          "80:     def test_value?",
          "81:       refute(@xml.xpath(\"//address\")[1].value?(\"no_such_value\"))",
          "82:       assert(@xml.xpath(\"//address\")[1].value?(\"Yes\"))",
          "83:     end",
          "85:     def test_keys",
          "86:       assert_equal([\"domestic\", \"street\"], @xml.xpath(\"//address\")[1].keys)",
          "87:     end",
          "89:     def test_attribute_with_symbol",
          "90:       assert_equal(\"Yes\", @xml.css(\"address\").first[:domestic])",
          "91:     end",
          "93:     def test_non_existent_attribute_should_return_nil",
          "94:       node = @xml.root.first_element_child",
          "95:       assert_nil(node.attribute(\"type\"))",
          "96:     end",
          "98:     #",
          "99:     #  CSS classes, specifically",
          "100:     #",
          "101:     def test_classes",
          "102:       xml = Nokogiri::XML(<<-eoxml)",
          "107:       eoxml",
          "108:       div = xml.at_xpath(\"//div\")",
          "109:       p1, p2 = xml.xpath(\"//p\")",
          "111:       assert_empty(div.classes)",
          "112:       assert_equal([\"foo\", \"bar\", \"foo\"], p1.classes)",
          "113:       assert_empty(p2.classes)",
          "114:     end",
          "116:     def test_add_class",
          "117:       xml = Nokogiri::XML(<<-eoxml)",
          "122:       eoxml",
          "123:       div = xml.at_xpath(\"//div\")",
          "124:       p1, p2 = xml.xpath(\"//p\")",
          "126:       assert_same(div, div.add_class(\"main\"))",
          "127:       assert_equal(\"main\", div[\"class\"])",
          "129:       assert_same(p1, p1.add_class(\"baz foo\"))",
          "130:       assert_equal(\"foo bar foo baz\", p1[\"class\"])",
          "132:       assert_same(p2, p2.add_class(\"foo baz foo\"))",
          "133:       assert_equal(\"foo baz foo\", p2[\"class\"])",
          "134:     end",
          "136:     def test_append_class",
          "137:       xml = Nokogiri::XML(<<-eoxml)",
          "142:       eoxml",
          "143:       div = xml.at_xpath(\"//div\")",
          "144:       p1, p2 = xml.xpath(\"//p\")",
          "146:       assert_same(div, div.append_class(\"main\"))",
          "147:       assert_equal(\"main\", div[\"class\"])",
          "149:       assert_same(p1, p1.append_class(\"baz foo\"))",
          "150:       assert_equal(\"foo bar foo baz foo\", p1[\"class\"])",
          "152:       assert_same(p2, p2.append_class(\"foo baz foo\"))",
          "153:       assert_equal(\"foo baz foo\", p2[\"class\"])",
          "154:     end",
          "156:     def test_remove_class",
          "157:       xml = Nokogiri::XML(<<-eoxml)",
          "164:       eoxml",
          "165:       div = xml.at_xpath(\"//div\")",
          "166:       p1, p2, p3, p4 = xml.xpath(\"//p\")",
          "168:       assert_same(div, div.remove_class(\"main\"))",
          "169:       assert_nil(div[\"class\"])",
          "171:       assert_same(p1, p1.remove_class(\"bar baz\"))",
          "172:       assert_equal(\"foo foo\", p1[\"class\"])",
          "174:       assert_same(p2, p2.remove_class)",
          "175:       assert_nil(p2[\"class\"])",
          "177:       assert_same(p3, p3.remove_class(\"foo\"))",
          "178:       assert_nil(p3[\"class\"])",
          "180:       assert_same(p4, p4.remove_class(\"foo\"))",
          "181:       assert_nil(p4[\"class\"])",
          "182:     end",
          "184:     #",
          "185:     #  keyword attributes, generally",
          "186:     #",
          "187:     describe \"keyword attribute helpers\" do",
          "188:       let(:node) do",
          "189:         Nokogiri::XML::DocumentFragment.parse(<<~EOM).at_css(\"div\")",
          "190:           <div blargh=\" foo  bar baz bar foo  quux foo manx \">hello</div>",
          "191:         EOM",
          "192:       end",
          "194:       describe \"setup\" do",
          "195:         it { _(node.get_attribute(\"noob\")).must_be_nil }",
          "196:       end",
          "198:       describe \"#kwattr_values\" do",
          "199:         it \"returns an array of space-delimited values\" do",
          "200:           _(node.kwattr_values(\"blargh\")).must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"])",
          "203:         describe \"when no attribute exists\" do",
          "204:           it \"returns an empty array\" do",
          "205:             _(node.kwattr_values(\"noob\")).must_equal([])",
          "207:         end",
          "209:         describe \"when an empty attribute exists\" do",
          "210:           it \"returns an empty array\" do",
          "211:             node.set_attribute(\"noob\", \"\")",
          "212:             _(node.kwattr_values(\"noob\")).must_equal([])",
          "214:             node.set_attribute(\"noob\", \"  \")",
          "215:             _(node.kwattr_values(\"noob\")).must_equal([])",
          "217:         end",
          "218:       end",
          "220:       describe \"kwattr_add\" do",
          "221:         it \"returns the node for chaining\" do",
          "222:           _(node.kwattr_add(\"noob\", \"asdf\")).must_be_same_as(node)",
          "223:         end",
          "225:         it \"creates a new attribute when necessary\" do",
          "226:           _(node.kwattr_add(\"noob\", \"asdf\").get_attribute(\"noob\")).wont_be_nil",
          "227:         end",
          "229:         it \"adds a new bare keyword string\" do",
          "230:           _(node.kwattr_add(\"blargh\", \"jimmy\").kwattr_values(\"blargh\"))",
          "231:             .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\"])",
          "232:         end",
          "234:         it \"does not add a repeated bare keyword string\" do",
          "235:           _(node.kwattr_add(\"blargh\", \"foo\").kwattr_values(\"blargh\"))",
          "236:             .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"])",
          "237:         end",
          "239:         describe \"given a string of keywords\" do",
          "240:           it \"adds new keywords and ignores existing keywords\" do",
          "241:             _(node.kwattr_add(\"blargh\", \"foo jimmy\\tjohnny\").kwattr_values(\"blargh\"))",
          "242:               .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\", \"johnny\"])",
          "244:         end",
          "246:         describe \"given an array of keywords\" do",
          "247:           it \"adds new keywords and ignores existing keywords\" do",
          "248:             _(node.kwattr_add(\"blargh\", [\"foo\", \"jimmy\"]).kwattr_values(\"blargh\"))",
          "249:               .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\"])",
          "251:         end",
          "252:       end",
          "254:       describe \"kwattr_append\" do",
          "255:         it \"returns the node for chaining\" do",
          "256:           _(node.kwattr_append(\"noob\", \"asdf\")).must_be_same_as(node)",
          "257:         end",
          "259:         it \"creates a new attribute when necessary\" do",
          "260:           _(node.kwattr_append(\"noob\", \"asdf\").get_attribute(\"noob\")).wont_be_nil",
          "261:         end",
          "263:         it \"adds a new bare keyword string\" do",
          "264:           _(node.kwattr_append(\"blargh\", \"jimmy\").kwattr_values(\"blargh\"))",
          "265:             .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\"])",
          "266:         end",
          "268:         it \"adds a repeated bare keyword string\" do",
          "269:           _(node.kwattr_append(\"blargh\", \"foo\").kwattr_values(\"blargh\"))",
          "270:             .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"foo\"])",
          "271:         end",
          "273:         describe \"given a string of keywords\" do",
          "274:           it \"adds new keywords and existing keywords\" do",
          "275:             _(node.kwattr_append(\"blargh\", \"foo jimmy\\tjohnny\").kwattr_values(\"blargh\"))",
          "276:               .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"foo\", \"jimmy\", \"johnny\"])",
          "277:           end",
          "278:         end",
          "280:         describe \"given an array of keywords\" do",
          "281:           it \"adds new keywords and existing keywords\" do",
          "282:             _(node.kwattr_append(\"blargh\", [\"foo\", \"jimmy\"]).kwattr_values(\"blargh\"))",
          "283:               .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"foo\", \"jimmy\"])",
          "284:           end",
          "285:         end",
          "286:       end",
          "288:       describe \"kwattr_remove\" do",
          "289:         it \"returns the node for chaining\" do",
          "290:           _(node.kwattr_remove(\"noob\", \"asdf\")).must_be_same_as(node)",
          "291:         end",
          "293:         it \"gracefully handles a non-existent attribute\" do",
          "294:           _(node.kwattr_remove(\"noob\", \"asdf\").get_attribute(\"noob\")).must_be_nil",
          "295:         end",
          "297:         it \"removes an existing bare keyword string\" do",
          "298:           _(node.kwattr_remove(\"blargh\", \"foo\").kwattr_values(\"blargh\"))",
          "299:             .must_equal([\"bar\", \"baz\", \"bar\", \"quux\", \"manx\"])",
          "300:         end",
          "302:         it \"gracefully ignores a non-existent bare keyword string\" do",
          "303:           _(node.kwattr_remove(\"blargh\", \"jimmy\").kwattr_values(\"blargh\"))",
          "304:             .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"])",
          "305:         end",
          "307:         describe \"given a string of keywords\" do",
          "308:           it \"removes existing keywords and ignores other keywords\" do",
          "309:             _(node.kwattr_remove(\"blargh\", \"foo jimmy\\tjohnny\").kwattr_values(\"blargh\"))",
          "310:               .must_equal([\"bar\", \"baz\", \"bar\", \"quux\", \"manx\"])",
          "312:         end",
          "314:         describe \"given an array of keywords\" do",
          "315:           it \"adds new keywords and existing keywords\" do",
          "316:             _(node.kwattr_remove(\"blargh\", [\"foo\", \"jimmy\"]).kwattr_values(\"blargh\"))",
          "317:               .must_equal([\"bar\", \"baz\", \"bar\", \"quux\", \"manx\"])",
          "321:         it \"removes the attribute when no values are left\" do",
          "322:           _(node.kwattr_remove(\"blargh\", [\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"]).get_attribute(\"blargh\")).must_be_nil",
          "323:         end",
          "",
          "[Added Lines]",
          "5: module Nokogiri",
          "6:   module XML",
          "7:     class Node",
          "8:       class TestAttributeMethods < Nokogiri::TestCase",
          "9:         def setup",
          "10:           super",
          "11:           @xml = Nokogiri::XML(File.read(XML_FILE), XML_FILE)",
          "12:         end",
          "14:         def test_each",
          "15:           attributes = []",
          "16:           @xml.xpath(\"//address\")[1].each do |key, value|",
          "17:             attributes << [key, value]",
          "18:           end",
          "19:           assert_equal([[\"domestic\", \"Yes\"], [\"street\", \"Yes\"]], attributes)",
          "20:         end",
          "22:         def test_remove_attribute",
          "23:           address = @xml.xpath(\"/staff/employee/address\").first",
          "24:           assert_equal(\"Yes\", address[\"domestic\"])",
          "25:           attr = address.attributes[\"domestic\"]",
          "27:           returned_attr = address.remove_attribute(\"domestic\")",
          "28:           assert_nil(address[\"domestic\"])",
          "29:           assert_equal(attr, returned_attr)",
          "30:         end",
          "32:         def test_remove_attribute_when_not_found",
          "33:           address = @xml.xpath(\"/staff/employee/address\").first",
          "34:           attr = address.remove_attribute(\"not-an-attribute\")",
          "35:           assert_nil(attr)",
          "36:         end",
          "38:         def test_attribute_setter_accepts_non_string",
          "39:           address = @xml.xpath(\"/staff/employee/address\").first",
          "40:           assert_equal(\"Yes\", address[:domestic])",
          "41:           address[:domestic] = \"Altered Yes\"",
          "42:           assert_equal(\"Altered Yes\", address[:domestic])",
          "43:         end",
          "45:         def test_attribute_accessor_accepts_non_string",
          "46:           address = @xml.xpath(\"/staff/employee/address\").first",
          "47:           assert_equal(\"Yes\", address[\"domestic\"])",
          "48:           assert_equal(\"Yes\", address[:domestic])",
          "49:         end",
          "51:         def test_empty_attribute_reading",
          "52:           node = Nokogiri::XML('<foo empty=\"\" whitespace=\"  \"/>')",
          "54:           assert_equal(\"\", node.root[\"empty\"])",
          "55:           assert_equal(\"  \", node.root[\"whitespace\"])",
          "56:         end",
          "58:         def test_delete",
          "59:           address = @xml.xpath(\"/staff/employee/address\").first",
          "60:           assert_equal(\"Yes\", address[\"domestic\"])",
          "61:           address.delete(\"domestic\")",
          "62:           assert_nil(address[\"domestic\"])",
          "63:         end",
          "65:         def test_attributes",
          "66:           assert(node = @xml.search(\"//address\").first)",
          "67:           assert_nil(node[\"asdfasdfasdf\"])",
          "68:           assert_equal(\"Yes\", node[\"domestic\"])",
          "70:           assert(node = @xml.search(\"//address\")[2])",
          "71:           attr = node.attributes",
          "72:           assert_equal(2, attr.size)",
          "73:           assert_equal(\"Yes\", attr[\"domestic\"].value)",
          "74:           assert_equal(\"Yes\", attr[\"domestic\"].to_s)",
          "75:           assert_equal(\"No\", attr[\"street\"].value)",
          "76:         end",
          "78:         def test_values",
          "79:           assert_equal([\"Yes\", \"Yes\"], @xml.xpath(\"//address\")[1].values)",
          "80:         end",
          "82:         def test_value?",
          "83:           refute(@xml.xpath(\"//address\")[1].value?(\"no_such_value\"))",
          "84:           assert(@xml.xpath(\"//address\")[1].value?(\"Yes\"))",
          "85:         end",
          "87:         def test_keys",
          "88:           assert_equal([\"domestic\", \"street\"], @xml.xpath(\"//address\")[1].keys)",
          "89:         end",
          "91:         def test_attribute_with_symbol",
          "92:           assert_equal(\"Yes\", @xml.css(\"address\").first[:domestic])",
          "93:         end",
          "95:         def test_non_existent_attribute_should_return_nil",
          "96:           node = @xml.root.first_element_child",
          "97:           assert_nil(node.attribute(\"type\"))",
          "98:         end",
          "100:         #",
          "101:         #  CSS classes, specifically",
          "102:         #",
          "103:         def test_classes",
          "104:           xml = Nokogiri::XML(<<-eoxml)",
          "109:           eoxml",
          "110:           div = xml.at_xpath(\"//div\")",
          "111:           p1, p2 = xml.xpath(\"//p\")",
          "113:           assert_empty(div.classes)",
          "114:           assert_equal([\"foo\", \"bar\", \"foo\"], p1.classes)",
          "115:           assert_empty(p2.classes)",
          "116:         end",
          "118:         def test_add_class",
          "119:           xml = Nokogiri::XML(<<-eoxml)",
          "124:           eoxml",
          "125:           div = xml.at_xpath(\"//div\")",
          "126:           p1, p2 = xml.xpath(\"//p\")",
          "128:           assert_same(div, div.add_class(\"main\"))",
          "129:           assert_equal(\"main\", div[\"class\"])",
          "131:           assert_same(p1, p1.add_class(\"baz foo\"))",
          "132:           assert_equal(\"foo bar foo baz\", p1[\"class\"])",
          "134:           assert_same(p2, p2.add_class(\"foo baz foo\"))",
          "135:           assert_equal(\"foo baz foo\", p2[\"class\"])",
          "136:         end",
          "138:         def test_append_class",
          "139:           xml = Nokogiri::XML(<<-eoxml)",
          "144:           eoxml",
          "145:           div = xml.at_xpath(\"//div\")",
          "146:           p1, p2 = xml.xpath(\"//p\")",
          "148:           assert_same(div, div.append_class(\"main\"))",
          "149:           assert_equal(\"main\", div[\"class\"])",
          "151:           assert_same(p1, p1.append_class(\"baz foo\"))",
          "152:           assert_equal(\"foo bar foo baz foo\", p1[\"class\"])",
          "154:           assert_same(p2, p2.append_class(\"foo baz foo\"))",
          "155:           assert_equal(\"foo baz foo\", p2[\"class\"])",
          "156:         end",
          "158:         def test_remove_class",
          "159:           xml = Nokogiri::XML(<<-eoxml)",
          "166:           eoxml",
          "167:           div = xml.at_xpath(\"//div\")",
          "168:           p1, p2, p3, p4 = xml.xpath(\"//p\")",
          "170:           assert_same(div, div.remove_class(\"main\"))",
          "171:           assert_nil(div[\"class\"])",
          "173:           assert_same(p1, p1.remove_class(\"bar baz\"))",
          "174:           assert_equal(\"foo foo\", p1[\"class\"])",
          "176:           assert_same(p2, p2.remove_class)",
          "177:           assert_nil(p2[\"class\"])",
          "179:           assert_same(p3, p3.remove_class(\"foo\"))",
          "180:           assert_nil(p3[\"class\"])",
          "182:           assert_same(p4, p4.remove_class(\"foo\"))",
          "183:           assert_nil(p4[\"class\"])",
          "186:         #",
          "187:         #  keyword attributes, generally",
          "188:         #",
          "189:         describe \"keyword attribute helpers\" do",
          "190:           let(:node) do",
          "191:             Nokogiri::XML::DocumentFragment.parse(<<~EOM).at_css(\"div\")",
          "192:               <div blargh=\" foo  bar baz bar foo  quux foo manx \">hello</div>",
          "193:             EOM",
          "196:           describe \"setup\" do",
          "197:             it { _(node.get_attribute(\"noob\")).must_be_nil }",
          "200:           describe \"#kwattr_values\" do",
          "201:             it \"returns an array of space-delimited values\" do",
          "202:               _(node.kwattr_values(\"blargh\")).must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"])",
          "203:             end",
          "205:             describe \"when no attribute exists\" do",
          "206:               it \"returns an empty array\" do",
          "207:                 _(node.kwattr_values(\"noob\")).must_equal([])",
          "208:               end",
          "209:             end",
          "211:             describe \"when an empty attribute exists\" do",
          "212:               it \"returns an empty array\" do",
          "213:                 node.set_attribute(\"noob\", \"\")",
          "214:                 _(node.kwattr_values(\"noob\")).must_equal([])",
          "216:                 node.set_attribute(\"noob\", \"  \")",
          "217:                 _(node.kwattr_values(\"noob\")).must_equal([])",
          "218:               end",
          "219:             end",
          "222:           describe \"kwattr_add\" do",
          "223:             it \"returns the node for chaining\" do",
          "224:               _(node.kwattr_add(\"noob\", \"asdf\")).must_be_same_as(node)",
          "225:             end",
          "227:             it \"creates a new attribute when necessary\" do",
          "228:               _(node.kwattr_add(\"noob\", \"asdf\").get_attribute(\"noob\")).wont_be_nil",
          "229:             end",
          "231:             it \"adds a new bare keyword string\" do",
          "232:               _(node.kwattr_add(\"blargh\", \"jimmy\").kwattr_values(\"blargh\"))",
          "233:                 .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\"])",
          "234:             end",
          "236:             it \"does not add a repeated bare keyword string\" do",
          "237:               _(node.kwattr_add(\"blargh\", \"foo\").kwattr_values(\"blargh\"))",
          "238:                 .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"])",
          "239:             end",
          "241:             describe \"given a string of keywords\" do",
          "242:               it \"adds new keywords and ignores existing keywords\" do",
          "243:                 _(node.kwattr_add(\"blargh\", \"foo jimmy\\tjohnny\").kwattr_values(\"blargh\"))",
          "244:                   .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\", \"johnny\"])",
          "245:               end",
          "246:             end",
          "248:             describe \"given an array of keywords\" do",
          "249:               it \"adds new keywords and ignores existing keywords\" do",
          "250:                 _(node.kwattr_add(\"blargh\", [\"foo\", \"jimmy\"]).kwattr_values(\"blargh\"))",
          "251:                   .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\"])",
          "252:               end",
          "253:             end",
          "256:           describe \"kwattr_append\" do",
          "257:             it \"returns the node for chaining\" do",
          "258:               _(node.kwattr_append(\"noob\", \"asdf\")).must_be_same_as(node)",
          "259:             end",
          "261:             it \"creates a new attribute when necessary\" do",
          "262:               _(node.kwattr_append(\"noob\", \"asdf\").get_attribute(\"noob\")).wont_be_nil",
          "263:             end",
          "265:             it \"adds a new bare keyword string\" do",
          "266:               _(node.kwattr_append(\"blargh\", \"jimmy\").kwattr_values(\"blargh\"))",
          "267:                 .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"jimmy\"])",
          "268:             end",
          "270:             it \"adds a repeated bare keyword string\" do",
          "271:               _(node.kwattr_append(\"blargh\", \"foo\").kwattr_values(\"blargh\"))",
          "272:                 .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"foo\"])",
          "273:             end",
          "275:             describe \"given a string of keywords\" do",
          "276:               it \"adds new keywords and existing keywords\" do",
          "277:                 _(node.kwattr_append(\"blargh\", \"foo jimmy\\tjohnny\").kwattr_values(\"blargh\"))",
          "278:                   .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"foo\", \"jimmy\", \"johnny\"])",
          "279:               end",
          "280:             end",
          "282:             describe \"given an array of keywords\" do",
          "283:               it \"adds new keywords and existing keywords\" do",
          "284:                 _(node.kwattr_append(\"blargh\", [\"foo\", \"jimmy\"]).kwattr_values(\"blargh\"))",
          "285:                   .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\", \"foo\", \"jimmy\"])",
          "286:               end",
          "287:             end",
          "290:           describe \"kwattr_remove\" do",
          "291:             it \"returns the node for chaining\" do",
          "292:               _(node.kwattr_remove(\"noob\", \"asdf\")).must_be_same_as(node)",
          "293:             end",
          "295:             it \"gracefully handles a non-existent attribute\" do",
          "296:               _(node.kwattr_remove(\"noob\", \"asdf\").get_attribute(\"noob\")).must_be_nil",
          "297:             end",
          "299:             it \"removes an existing bare keyword string\" do",
          "300:               _(node.kwattr_remove(\"blargh\", \"foo\").kwattr_values(\"blargh\"))",
          "301:                 .must_equal([\"bar\", \"baz\", \"bar\", \"quux\", \"manx\"])",
          "302:             end",
          "304:             it \"gracefully ignores a non-existent bare keyword string\" do",
          "305:               _(node.kwattr_remove(\"blargh\", \"jimmy\").kwattr_values(\"blargh\"))",
          "306:                 .must_equal([\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"])",
          "307:             end",
          "309:             describe \"given a string of keywords\" do",
          "310:               it \"removes existing keywords and ignores other keywords\" do",
          "311:                 _(node.kwattr_remove(\"blargh\", \"foo jimmy\\tjohnny\").kwattr_values(\"blargh\"))",
          "312:                   .must_equal([\"bar\", \"baz\", \"bar\", \"quux\", \"manx\"])",
          "313:               end",
          "314:             end",
          "316:             describe \"given an array of keywords\" do",
          "317:               it \"adds new keywords and existing keywords\" do",
          "318:                 _(node.kwattr_remove(\"blargh\", [\"foo\", \"jimmy\"]).kwattr_values(\"blargh\"))",
          "319:                   .must_equal([\"bar\", \"baz\", \"bar\", \"quux\", \"manx\"])",
          "320:               end",
          "321:             end",
          "323:             it \"removes the attribute when no values are left\" do",
          "324:               _(node.kwattr_remove(\"blargh\", [\"foo\", \"bar\", \"baz\", \"bar\", \"foo\", \"quux\", \"foo\", \"manx\"]).get_attribute(\"blargh\")).must_be_nil",
          "325:             end",
          "",
          "---------------"
        ],
        "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb": [
          "File: test/xml/sax/test_parser.rb -> test/xml/sax/test_parser.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: require \"helper\"",
          "18:       end",
          "460:     end",
          "461:   end",
          "462: end",
          "",
          "[Removed Lines]",
          "5: class Nokogiri::SAX::TestCase",
          "6:   describe Nokogiri::XML::SAX::Parser do",
          "7:     let(:parser) { Nokogiri::XML::SAX::Parser.new(Doc.new) }",
          "9:     it :test_parser_context_yielded_io do",
          "10:       doc = Doc.new",
          "11:       parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "12:       xml = \"<foo a='&amp;b'/>\"",
          "14:       block_called = false",
          "15:       parser.parse(StringIO.new(xml)) do |ctx|",
          "16:         block_called = true",
          "17:         ctx.replace_entities = true",
          "20:       assert(block_called)",
          "22:       assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "23:     end",
          "25:     it :test_parser_context_yielded_in_memory do",
          "26:       doc = Doc.new",
          "27:       parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "28:       xml = \"<foo a='&amp;b'/>\"",
          "30:       block_called = false",
          "31:       parser.parse(xml) do |ctx|",
          "32:         block_called = true",
          "33:         ctx.replace_entities = true",
          "34:       end",
          "36:       assert(block_called)",
          "38:       assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "39:     end",
          "41:     it :test_empty_decl do",
          "42:       parser = Nokogiri::XML::SAX::Parser.new(Doc.new)",
          "44:       xml = \"<root />\"",
          "45:       parser.parse(xml)",
          "46:       assert(parser.document.start_document_called)",
          "47:       assert_nil(parser.document.xmldecls)",
          "48:     end",
          "50:     it :test_xml_decl do",
          "51:       [",
          "52:         ['<?xml version=\"1.0\" ?>', [\"1.0\"]],",
          "53:         ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],",
          "54:         ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],",
          "55:         ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],",
          "56:         ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],",
          "57:         ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],",
          "58:       ].each do |decl, value|",
          "59:         parser = Nokogiri::XML::SAX::Parser.new(Doc.new)",
          "61:         xml = \"#{decl}\\n<root />\"",
          "62:         parser.parse(xml)",
          "63:         assert(parser.document.start_document_called)",
          "64:         assert_equal(value, parser.document.xmldecls)",
          "65:       end",
          "66:     end",
          "68:     it :test_parse_empty do",
          "69:       assert_raises(RuntimeError) do",
          "70:         parser.parse(\"\")",
          "71:       end",
          "72:     end",
          "74:     it :test_namespace_declaration_order_is_saved do",
          "75:       parser.parse(<<~EOF)",
          "76:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "77:           <a foo:bar='hello' />",
          "78:         </root>",
          "79:       EOF",
          "80:       assert_equal(2, parser.document.start_elements_namespace.length)",
          "81:       el = parser.document.start_elements_namespace.first",
          "82:       namespaces = el.last",
          "83:       assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)",
          "84:       assert_equal([nil, \"http://example.com/\"], namespaces.last)",
          "85:     end",
          "87:     it :test_bad_document_calls_error_handler do",
          "88:       parser.parse(\"<foo><bar></foo>\")",
          "89:       assert(parser.document.errors)",
          "90:       refute_empty(parser.document.errors)",
          "91:     end",
          "93:     it :test_namespace_are_super_fun_to_parse do",
          "94:       parser.parse(<<~EOF)",
          "95:         <root xmlns:foo='http://foo.example.com/'>",
          "96:           <a foo:bar='hello' />",
          "97:           <b xmlns:foo='http://bar.example.com/'>",
          "98:             <a foo:bar='hello' />",
          "99:           </b>",
          "100:           <foo:bar>hello world</foo:bar>",
          "101:         </root>",
          "102:       EOF",
          "104:       refute_empty(parser.document.start_elements_namespace)",
          "105:       el = parser.document.start_elements_namespace[1]",
          "106:       assert_equal(\"a\", el.first)",
          "107:       assert_equal(1, el[1].length)",
          "109:       attribute = el[1].first",
          "110:       assert_equal(\"bar\", attribute.localname)",
          "111:       assert_equal(\"foo\", attribute.prefix)",
          "112:       assert_equal(\"hello\", attribute.value)",
          "113:       assert_equal(\"http://foo.example.com/\", attribute.uri)",
          "114:     end",
          "116:     it :test_sax_v1_namespace_attribute_declarations do",
          "117:       parser.parse(<<~EOF)",
          "118:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "119:           <a foo:bar='hello' />",
          "120:           <b xmlns:foo='http://bar.example.com/'>",
          "121:             <a foo:bar='hello' />",
          "122:           </b>",
          "123:           <foo:bar>hello world</foo:bar>",
          "124:         </root>",
          "125:       EOF",
          "126:       refute_empty(parser.document.start_elements)",
          "127:       elm = parser.document.start_elements.first",
          "128:       assert_equal(\"root\", elm.first)",
          "129:       assert_includes(elm[1], [\"xmlns:foo\", \"http://foo.example.com/\"])",
          "130:       assert_includes(elm[1], [\"xmlns\", \"http://example.com/\"])",
          "131:     end",
          "133:     it :test_sax_v1_namespace_nodes do",
          "134:       parser.parse(<<~EOF)",
          "135:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "136:           <a foo:bar='hello' />",
          "137:           <b xmlns:foo='http://bar.example.com/'>",
          "138:             <a foo:bar='hello' />",
          "139:           </b>",
          "140:           <foo:bar>hello world</foo:bar>",
          "141:         </root>",
          "142:       EOF",
          "143:       assert_equal(5, parser.document.start_elements.length)",
          "144:       assert_includes(parser.document.start_elements.map(&:first), \"foo:bar\")",
          "145:       assert_includes(parser.document.end_elements.map(&:first), \"foo:bar\")",
          "146:     end",
          "148:     it :test_start_is_called_without_namespace do",
          "149:       parser.parse(<<~EOF)",
          "150:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "151:         <foo:f><bar></foo:f>",
          "152:         </root>",
          "153:       EOF",
          "154:       assert_equal(",
          "155:         [\"root\", \"foo:f\", \"bar\"],",
          "156:         parser.document.start_elements.map(&:first)",
          "157:       )",
          "158:     end",
          "160:     it :test_parser_sets_encoding do",
          "161:       parser = Nokogiri::XML::SAX::Parser.new(Doc.new, \"UTF-8\")",
          "162:       assert_equal(\"UTF-8\", parser.encoding)",
          "163:     end",
          "165:     it :test_errors_set_after_parsing_bad_dom do",
          "166:       doc = Nokogiri::XML(\"<foo><bar></foo>\")",
          "167:       assert(doc.errors)",
          "169:       parser.parse(\"<foo><bar></foo>\")",
          "170:       assert(parser.document.errors)",
          "171:       refute_empty(parser.document.errors)",
          "173:       doc.errors.each do |error|",
          "174:         assert_equal(\"UTF-8\", error.message.encoding.name)",
          "175:       end",
          "177:       # when using JRuby Nokogiri, more errors will be generated as the DOM",
          "178:       # parser continue to parse an ill formed document, while the sax parser",
          "179:       # will stop at the first error",
          "180:       unless Nokogiri.jruby?",
          "181:         assert_equal(doc.errors.length, parser.document.errors.length)",
          "182:       end",
          "183:     end",
          "185:     it :test_parse_with_memory_argument do",
          "186:       parser.parse(File.read(XML_FILE))",
          "187:       refute_empty(parser.document.cdata_blocks)",
          "188:     end",
          "190:     it :test_parse_with_io_argument do",
          "191:       File.open(XML_FILE, \"rb\") do |f|",
          "192:         parser.parse(f)",
          "193:       end",
          "194:       refute_empty(parser.document.cdata_blocks)",
          "195:     end",
          "197:     it :test_parse_io do",
          "198:       call_parse_io_with_encoding(\"UTF-8\")",
          "199:     end",
          "201:     # issue #828",
          "202:     it :test_parse_io_lower_case_encoding do",
          "203:       call_parse_io_with_encoding(\"utf-8\")",
          "204:     end",
          "206:     def call_parse_io_with_encoding(encoding)",
          "207:       File.open(XML_FILE, \"rb\") do |f|",
          "208:         parser.parse_io(f, encoding)",
          "209:       end",
          "210:       refute_empty(parser.document.cdata_blocks)",
          "212:       called = false",
          "213:       parser.document.start_elements.flatten.each do |thing|",
          "214:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "215:         called = true",
          "216:       end",
          "217:       assert(called)",
          "219:       called = false",
          "220:       parser.document.end_elements.flatten.each do |thing|",
          "221:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "222:         called = true",
          "223:       end",
          "224:       assert(called)",
          "226:       called = false",
          "227:       parser.document.data.each do |thing|",
          "228:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "229:         called = true",
          "230:       end",
          "231:       assert(called)",
          "233:       called = false",
          "234:       parser.document.comments.flatten.each do |thing|",
          "235:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "236:         called = true",
          "237:       end",
          "238:       assert(called)",
          "240:       called = false",
          "241:       parser.document.cdata_blocks.flatten.each do |thing|",
          "242:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "243:         called = true",
          "244:       end",
          "245:       assert(called)",
          "246:     end",
          "248:     it :test_parse_file do",
          "249:       parser.parse_file(XML_FILE)",
          "251:       assert_raises(ArgumentError) do",
          "252:         parser.parse_file(nil)",
          "253:       end",
          "255:       assert_raises(Errno::ENOENT) do",
          "256:         parser.parse_file(\"\")",
          "257:       end",
          "258:       assert_raises(Errno::EISDIR) do",
          "259:         parser.parse_file(File.expand_path(File.dirname(__FILE__)))",
          "260:       end",
          "261:     end",
          "263:     it :test_render_parse_nil_param do",
          "264:       assert_raises(ArgumentError) { parser.parse_memory(nil) }",
          "265:     end",
          "267:     it :test_bad_encoding_args do",
          "268:       assert_raises(ArgumentError) { Nokogiri::XML::SAX::Parser.new(Doc.new, \"not an encoding\") }",
          "269:       assert_raises(ArgumentError) { parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }",
          "270:     end",
          "272:     it :test_ctag do",
          "273:       parser.parse_memory(<<~EOF)",
          "274:         <p id=\"asdfasdf\">",
          "275:           <![CDATA[ This is a comment ]]>",
          "276:           Paragraph 1",
          "277:         </p>",
          "278:       EOF",
          "279:       assert_equal([\" This is a comment \"], parser.document.cdata_blocks)",
          "280:     end",
          "282:     it :test_comment do",
          "283:       parser.parse_memory(<<~EOF)",
          "284:         <p id=\"asdfasdf\">",
          "285:           <!-- This is a comment -->",
          "286:           Paragraph 1",
          "287:         </p>",
          "288:       EOF",
          "289:       assert_equal([\" This is a comment \"], parser.document.comments)",
          "290:     end",
          "292:     it :test_characters do",
          "293:       parser.parse_memory(<<~EOF)",
          "294:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "295:       EOF",
          "296:       assert_equal([\"Paragraph 1\"], parser.document.data)",
          "297:     end",
          "299:     it :test_end_document do",
          "300:       parser.parse_memory(<<~EOF)",
          "301:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "302:       EOF",
          "303:       assert(parser.document.end_document_called)",
          "304:     end",
          "306:     it :test_end_element do",
          "307:       parser.parse_memory(<<~EOF)",
          "308:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "309:       EOF",
          "310:       assert_equal([[\"p\"]], parser.document.end_elements)",
          "311:     end",
          "313:     it :test_start_element_attrs do",
          "314:       parser.parse_memory(<<~EOF)",
          "315:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "316:       EOF",
          "317:       assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], parser.document.start_elements)",
          "318:     end",
          "320:     it :test_start_element_attrs_include_namespaces do",
          "321:       parser.parse_memory(<<~EOF)",
          "322:         <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>",
          "323:       EOF",
          "324:       assert_equal(",
          "325:         [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "326:         parser.document.start_elements",
          "327:       )",
          "328:     end",
          "330:     it :test_processing_instruction do",
          "331:       parser.parse_memory(<<~EOF)",
          "332:         <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>",
          "333:         <?xml version=\"1.0\"?>",
          "334:       EOF",
          "335:       assert_equal(",
          "336:         [[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],",
          "337:         parser.document.processing_instructions",
          "338:       )",
          "339:     end",
          "341:     it :test_parse_document do",
          "342:       skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")",
          "343:       parser.parse_memory(<<~EOF)",
          "344:         <p>Paragraph 1</p>",
          "345:         <p>Paragraph 2</p>",
          "346:       EOF",
          "347:     end",
          "349:     it :test_parser_attributes do",
          "350:       xml = <<~EOF",
          "351:         <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>",
          "352:       EOF",
          "354:       block_called = false",
          "355:       parser.parse(xml) do |ctx|",
          "356:         block_called = true",
          "357:         ctx.replace_entities = true",
          "358:       end",
          "360:       assert(block_called)",
          "362:       assert_equal(",
          "363:         [[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], parser.document.start_elements",
          "364:       )",
          "365:     end",
          "367:     it :test_recovery_from_incorrect_xml do",
          "368:       xml = <<~EOF",
          "369:         <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>",
          "370:       EOF",
          "372:       block_called = false",
          "373:       parser.parse(xml) do |ctx|",
          "374:         block_called = true",
          "375:         ctx.recovery = true",
          "376:       end",
          "378:       assert(block_called)",
          "380:       assert_equal(",
          "381:         [[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],",
          "382:         parser.document.start_elements",
          "383:       )",
          "384:     end",
          "386:     it :test_square_bracket_in_text do",
          "387:       # issue 1261",
          "388:       xml = <<~EOF",
          "389:         <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">",
          "390:           <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>",
          "391:           <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>",
          "392:         </tu>",
          "393:       EOF",
          "394:       parser.parse(xml)",
          "395:       assert_includes(parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")",
          "396:     end",
          "398:     it :test_large_cdata_is_handled do",
          "399:       skip(\"see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200\") if Nokogiri.uses_libxml?(\"<=2.9.10\")",
          "401:       template = <<~EOF",
          "402:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "403:         <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">",
          "404:            <soapenv:Header>",
          "405:               <AuthHeader xsi:type=\"ns:vAuthHeader\">",
          "406:               <userName xsi:type=\"xsd:string\">gorilla</userName>",
          "407:               <password xsi:type=\"xsd:string\">secret</password>",
          "408:             </AuthHeader>",
          "409:            </soapenv:Header>",
          "410:           <soapenv:Body>",
          "411:             <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">",
          "412:               <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>",
          "413:             </ns:checkToken>",
          "414:            </soapenv:Body>",
          "415:         </soapenv:Envelope>",
          "416:       EOF",
          "418:       factor = 10",
          "419:       huge_data = \"a\" * (1024 * 1024 * factor)",
          "420:       xml = StringIO.new(template % huge_data)",
          "422:       handler = Nokogiri::SAX::TestCase::Doc.new",
          "423:       parser = Nokogiri::XML::SAX::Parser.new(handler)",
          "424:       parser.parse(xml)",
          "426:       assert_predicate(handler.errors, :empty?)",
          "427:     end",
          "429:     it \"does not resolve entities by default\" do",
          "430:       xml = <<~EOF",
          "431:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "432:         <!DOCTYPE doc [",
          "433:           <!ENTITY local SYSTEM \"file:///#{File.expand_path(__FILE__)}\">",
          "434:           <!ENTITY custom \"resolved>",
          "435:         ]>",
          "436:         <doc><foo>&local;</foo><foo>&custom;</foo></doc>",
          "437:       EOF",
          "439:       doc = Doc.new",
          "440:       parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "441:       parser.parse(xml)",
          "443:       assert_nil(doc.data)",
          "444:     end",
          "446:     it \"does not resolve network external entities by default\" do",
          "447:       xml = <<~EOF",
          "448:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "449:         <!DOCTYPE doc [",
          "450:           <!ENTITY remote SYSTEM \"http://0.0.0.0:8080/evil.dtd\">",
          "451:         ]>",
          "452:         <doc><foo>&remote;</foo></doc>",
          "453:       EOF",
          "455:       doc = Doc.new",
          "456:       parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "457:       parser.parse(xml)",
          "459:       assert_nil(doc.data)",
          "",
          "[Added Lines]",
          "5: module Nokogiri",
          "6:   module SAX",
          "7:     class TestCase",
          "8:       describe Nokogiri::XML::SAX::Parser do",
          "9:         let(:parser) { Nokogiri::XML::SAX::Parser.new(Doc.new) }",
          "11:         it :test_parser_context_yielded_io do",
          "12:           doc = Doc.new",
          "13:           parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "14:           xml = \"<foo a='&amp;b'/>\"",
          "16:           block_called = false",
          "17:           parser.parse(StringIO.new(xml)) do |ctx|",
          "18:             block_called = true",
          "19:             ctx.replace_entities = true",
          "20:           end",
          "22:           assert(block_called)",
          "24:           assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "25:         end",
          "27:         it :test_parser_context_yielded_in_memory do",
          "28:           doc = Doc.new",
          "29:           parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "30:           xml = \"<foo a='&amp;b'/>\"",
          "32:           block_called = false",
          "33:           parser.parse(xml) do |ctx|",
          "34:             block_called = true",
          "35:             ctx.replace_entities = true",
          "36:           end",
          "38:           assert(block_called)",
          "40:           assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "41:         end",
          "43:         it :test_empty_decl do",
          "44:           parser = Nokogiri::XML::SAX::Parser.new(Doc.new)",
          "46:           xml = \"<root />\"",
          "47:           parser.parse(xml)",
          "48:           assert(parser.document.start_document_called)",
          "49:           assert_nil(parser.document.xmldecls)",
          "50:         end",
          "52:         it :test_xml_decl do",
          "53:           [",
          "54:             ['<?xml version=\"1.0\" ?>', [\"1.0\"]],",
          "55:             ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],",
          "56:             ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],",
          "57:             ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],",
          "58:             ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],",
          "59:             ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],",
          "60:           ].each do |decl, value|",
          "61:             parser = Nokogiri::XML::SAX::Parser.new(Doc.new)",
          "63:             xml = \"#{decl}\\n<root />\"",
          "64:             parser.parse(xml)",
          "65:             assert(parser.document.start_document_called)",
          "66:             assert_equal(value, parser.document.xmldecls)",
          "67:           end",
          "68:         end",
          "70:         it :test_parse_empty do",
          "71:           assert_raises(RuntimeError) do",
          "72:             parser.parse(\"\")",
          "73:           end",
          "74:         end",
          "76:         it :test_namespace_declaration_order_is_saved do",
          "77:           parser.parse(<<~EOF)",
          "78:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "79:               <a foo:bar='hello' />",
          "80:             </root>",
          "81:           EOF",
          "82:           assert_equal(2, parser.document.start_elements_namespace.length)",
          "83:           el = parser.document.start_elements_namespace.first",
          "84:           namespaces = el.last",
          "85:           assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)",
          "86:           assert_equal([nil, \"http://example.com/\"], namespaces.last)",
          "87:         end",
          "89:         it :test_bad_document_calls_error_handler do",
          "90:           parser.parse(\"<foo><bar></foo>\")",
          "91:           assert(parser.document.errors)",
          "92:           refute_empty(parser.document.errors)",
          "93:         end",
          "95:         it :test_namespace_are_super_fun_to_parse do",
          "96:           parser.parse(<<~EOF)",
          "97:             <root xmlns:foo='http://foo.example.com/'>",
          "98:               <a foo:bar='hello' />",
          "99:               <b xmlns:foo='http://bar.example.com/'>",
          "100:                 <a foo:bar='hello' />",
          "101:               </b>",
          "102:               <foo:bar>hello world</foo:bar>",
          "103:             </root>",
          "104:           EOF",
          "106:           refute_empty(parser.document.start_elements_namespace)",
          "107:           el = parser.document.start_elements_namespace[1]",
          "108:           assert_equal(\"a\", el.first)",
          "109:           assert_equal(1, el[1].length)",
          "111:           attribute = el[1].first",
          "112:           assert_equal(\"bar\", attribute.localname)",
          "113:           assert_equal(\"foo\", attribute.prefix)",
          "114:           assert_equal(\"hello\", attribute.value)",
          "115:           assert_equal(\"http://foo.example.com/\", attribute.uri)",
          "116:         end",
          "118:         it :test_sax_v1_namespace_attribute_declarations do",
          "119:           parser.parse(<<~EOF)",
          "120:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "121:               <a foo:bar='hello' />",
          "122:               <b xmlns:foo='http://bar.example.com/'>",
          "123:                 <a foo:bar='hello' />",
          "124:               </b>",
          "125:               <foo:bar>hello world</foo:bar>",
          "126:             </root>",
          "127:           EOF",
          "128:           refute_empty(parser.document.start_elements)",
          "129:           elm = parser.document.start_elements.first",
          "130:           assert_equal(\"root\", elm.first)",
          "131:           assert_includes(elm[1], [\"xmlns:foo\", \"http://foo.example.com/\"])",
          "132:           assert_includes(elm[1], [\"xmlns\", \"http://example.com/\"])",
          "133:         end",
          "135:         it :test_sax_v1_namespace_nodes do",
          "136:           parser.parse(<<~EOF)",
          "137:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "138:               <a foo:bar='hello' />",
          "139:               <b xmlns:foo='http://bar.example.com/'>",
          "140:                 <a foo:bar='hello' />",
          "141:               </b>",
          "142:               <foo:bar>hello world</foo:bar>",
          "143:             </root>",
          "144:           EOF",
          "145:           assert_equal(5, parser.document.start_elements.length)",
          "146:           assert_includes(parser.document.start_elements.map(&:first), \"foo:bar\")",
          "147:           assert_includes(parser.document.end_elements.map(&:first), \"foo:bar\")",
          "148:         end",
          "150:         it :test_start_is_called_without_namespace do",
          "151:           parser.parse(<<~EOF)",
          "152:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "153:             <foo:f><bar></foo:f>",
          "154:             </root>",
          "155:           EOF",
          "156:           assert_equal(",
          "157:             [\"root\", \"foo:f\", \"bar\"],",
          "158:             parser.document.start_elements.map(&:first)",
          "159:           )",
          "160:         end",
          "162:         it :test_parser_sets_encoding do",
          "163:           parser = Nokogiri::XML::SAX::Parser.new(Doc.new, \"UTF-8\")",
          "164:           assert_equal(\"UTF-8\", parser.encoding)",
          "165:         end",
          "167:         it :test_errors_set_after_parsing_bad_dom do",
          "168:           doc = Nokogiri::XML(\"<foo><bar></foo>\")",
          "169:           assert(doc.errors)",
          "171:           parser.parse(\"<foo><bar></foo>\")",
          "172:           assert(parser.document.errors)",
          "173:           refute_empty(parser.document.errors)",
          "175:           doc.errors.each do |error|",
          "176:             assert_equal(\"UTF-8\", error.message.encoding.name)",
          "177:           end",
          "179:           # when using JRuby Nokogiri, more errors will be generated as the DOM",
          "180:           # parser continue to parse an ill formed document, while the sax parser",
          "181:           # will stop at the first error",
          "182:           unless Nokogiri.jruby?",
          "183:             assert_equal(doc.errors.length, parser.document.errors.length)",
          "184:           end",
          "185:         end",
          "187:         it :test_parse_with_memory_argument do",
          "188:           parser.parse(File.read(XML_FILE))",
          "189:           refute_empty(parser.document.cdata_blocks)",
          "190:         end",
          "192:         it :test_parse_with_io_argument do",
          "193:           File.open(XML_FILE, \"rb\") do |f|",
          "194:             parser.parse(f)",
          "195:           end",
          "196:           refute_empty(parser.document.cdata_blocks)",
          "197:         end",
          "199:         it :test_parse_io do",
          "200:           call_parse_io_with_encoding(\"UTF-8\")",
          "201:         end",
          "203:         # issue #828",
          "204:         it :test_parse_io_lower_case_encoding do",
          "205:           call_parse_io_with_encoding(\"utf-8\")",
          "206:         end",
          "208:         def call_parse_io_with_encoding(encoding)",
          "209:           File.open(XML_FILE, \"rb\") do |f|",
          "210:             parser.parse_io(f, encoding)",
          "211:           end",
          "212:           refute_empty(parser.document.cdata_blocks)",
          "214:           called = false",
          "215:           parser.document.start_elements.flatten.each do |thing|",
          "216:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "217:             called = true",
          "218:           end",
          "219:           assert(called)",
          "221:           called = false",
          "222:           parser.document.end_elements.flatten.each do |thing|",
          "223:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "224:             called = true",
          "225:           end",
          "226:           assert(called)",
          "228:           called = false",
          "229:           parser.document.data.each do |thing|",
          "230:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "231:             called = true",
          "232:           end",
          "233:           assert(called)",
          "235:           called = false",
          "236:           parser.document.comments.flatten.each do |thing|",
          "237:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "238:             called = true",
          "239:           end",
          "240:           assert(called)",
          "242:           called = false",
          "243:           parser.document.cdata_blocks.flatten.each do |thing|",
          "244:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "245:             called = true",
          "246:           end",
          "247:           assert(called)",
          "248:         end",
          "250:         it :test_parse_file do",
          "251:           parser.parse_file(XML_FILE)",
          "253:           assert_raises(ArgumentError) do",
          "254:             parser.parse_file(nil)",
          "255:           end",
          "257:           assert_raises(Errno::ENOENT) do",
          "258:             parser.parse_file(\"\")",
          "259:           end",
          "260:           assert_raises(Errno::EISDIR) do",
          "261:             parser.parse_file(File.expand_path(File.dirname(__FILE__)))",
          "262:           end",
          "263:         end",
          "265:         it :test_render_parse_nil_param do",
          "266:           assert_raises(ArgumentError) { parser.parse_memory(nil) }",
          "267:         end",
          "269:         it :test_bad_encoding_args do",
          "270:           assert_raises(ArgumentError) { Nokogiri::XML::SAX::Parser.new(Doc.new, \"not an encoding\") }",
          "271:           assert_raises(ArgumentError) { parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }",
          "272:         end",
          "274:         it :test_ctag do",
          "275:           parser.parse_memory(<<~EOF)",
          "276:             <p id=\"asdfasdf\">",
          "277:               <![CDATA[ This is a comment ]]>",
          "278:               Paragraph 1",
          "279:             </p>",
          "280:           EOF",
          "281:           assert_equal([\" This is a comment \"], parser.document.cdata_blocks)",
          "282:         end",
          "284:         it :test_comment do",
          "285:           parser.parse_memory(<<~EOF)",
          "286:             <p id=\"asdfasdf\">",
          "287:               <!-- This is a comment -->",
          "288:               Paragraph 1",
          "289:             </p>",
          "290:           EOF",
          "291:           assert_equal([\" This is a comment \"], parser.document.comments)",
          "292:         end",
          "294:         it :test_characters do",
          "295:           parser.parse_memory(<<~EOF)",
          "296:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "297:           EOF",
          "298:           assert_equal([\"Paragraph 1\"], parser.document.data)",
          "299:         end",
          "301:         it :test_end_document do",
          "302:           parser.parse_memory(<<~EOF)",
          "303:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "304:           EOF",
          "305:           assert(parser.document.end_document_called)",
          "306:         end",
          "308:         it :test_end_element do",
          "309:           parser.parse_memory(<<~EOF)",
          "310:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "311:           EOF",
          "312:           assert_equal([[\"p\"]], parser.document.end_elements)",
          "313:         end",
          "315:         it :test_start_element_attrs do",
          "316:           parser.parse_memory(<<~EOF)",
          "317:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "318:           EOF",
          "319:           assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], parser.document.start_elements)",
          "320:         end",
          "322:         it :test_start_element_attrs_include_namespaces do",
          "323:           parser.parse_memory(<<~EOF)",
          "324:             <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>",
          "325:           EOF",
          "326:           assert_equal(",
          "327:             [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "328:             parser.document.start_elements",
          "329:           )",
          "330:         end",
          "332:         it :test_processing_instruction do",
          "333:           parser.parse_memory(<<~EOF)",
          "334:             <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>",
          "335:             <?xml version=\"1.0\"?>",
          "336:           EOF",
          "337:           assert_equal(",
          "338:             [[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],",
          "339:             parser.document.processing_instructions",
          "340:           )",
          "341:         end",
          "343:         it :test_parse_document do",
          "344:           skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")",
          "345:           parser.parse_memory(<<~EOF)",
          "346:             <p>Paragraph 1</p>",
          "347:             <p>Paragraph 2</p>",
          "348:           EOF",
          "349:         end",
          "351:         it :test_parser_attributes do",
          "352:           xml = <<~EOF",
          "353:             <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>",
          "354:           EOF",
          "356:           block_called = false",
          "357:           parser.parse(xml) do |ctx|",
          "358:             block_called = true",
          "359:             ctx.replace_entities = true",
          "360:           end",
          "362:           assert(block_called)",
          "364:           assert_equal(",
          "365:             [[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], parser.document.start_elements",
          "366:           )",
          "367:         end",
          "369:         it :test_recovery_from_incorrect_xml do",
          "370:           xml = <<~EOF",
          "371:             <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>",
          "372:           EOF",
          "374:           block_called = false",
          "375:           parser.parse(xml) do |ctx|",
          "376:             block_called = true",
          "377:             ctx.recovery = true",
          "378:           end",
          "380:           assert(block_called)",
          "382:           assert_equal(",
          "383:             [[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],",
          "384:             parser.document.start_elements",
          "385:           )",
          "386:         end",
          "388:         it :test_square_bracket_in_text do",
          "389:           # issue 1261",
          "390:           xml = <<~EOF",
          "391:             <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">",
          "392:               <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>",
          "393:               <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>",
          "394:             </tu>",
          "395:           EOF",
          "396:           parser.parse(xml)",
          "397:           assert_includes(parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")",
          "398:         end",
          "400:         it :test_large_cdata_is_handled do",
          "401:           skip(\"see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200\") if Nokogiri.uses_libxml?(\"<=2.9.10\")",
          "403:           template = <<~EOF",
          "404:             <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "405:             <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">",
          "406:                <soapenv:Header>",
          "407:                   <AuthHeader xsi:type=\"ns:vAuthHeader\">",
          "408:                   <userName xsi:type=\"xsd:string\">gorilla</userName>",
          "409:                   <password xsi:type=\"xsd:string\">secret</password>",
          "410:                 </AuthHeader>",
          "411:                </soapenv:Header>",
          "412:               <soapenv:Body>",
          "413:                 <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">",
          "414:                   <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>",
          "415:                 </ns:checkToken>",
          "416:                </soapenv:Body>",
          "417:             </soapenv:Envelope>",
          "418:           EOF",
          "420:           factor = 10",
          "421:           huge_data = \"a\" * (1024 * 1024 * factor)",
          "422:           xml = StringIO.new(template % huge_data)",
          "424:           handler = Nokogiri::SAX::TestCase::Doc.new",
          "425:           parser = Nokogiri::XML::SAX::Parser.new(handler)",
          "426:           parser.parse(xml)",
          "428:           assert_predicate(handler.errors, :empty?)",
          "429:         end",
          "431:         it \"does not resolve entities by default\" do",
          "432:           xml = <<~EOF",
          "433:             <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "434:             <!DOCTYPE doc [",
          "435:               <!ENTITY local SYSTEM \"file:///#{File.expand_path(__FILE__)}\">",
          "436:               <!ENTITY custom \"resolved>",
          "437:             ]>",
          "438:             <doc><foo>&local;</foo><foo>&custom;</foo></doc>",
          "439:           EOF",
          "441:           doc = Doc.new",
          "442:           parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "443:           parser.parse(xml)",
          "445:           assert_nil(doc.data)",
          "446:         end",
          "448:         it \"does not resolve network external entities by default\" do",
          "449:           xml = <<~EOF",
          "450:             <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "451:             <!DOCTYPE doc [",
          "452:               <!ENTITY remote SYSTEM \"http://0.0.0.0:8080/evil.dtd\">",
          "453:             ]>",
          "454:             <doc><foo>&remote;</foo></doc>",
          "455:           EOF",
          "457:           doc = Doc.new",
          "458:           parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "459:           parser.parse(xml)",
          "461:           assert_nil(doc.data)",
          "462:         end",
          "",
          "---------------"
        ],
        "test/xml/sax/test_push_parser.rb||test/xml/sax/test_push_parser.rb": [
          "File: test/xml/sax/test_push_parser.rb -> test/xml/sax/test_push_parser.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: require \"helper\"",
          "52:         end",
          "214:       end",
          "215:     end",
          "242:   end",
          "243: end",
          "",
          "[Removed Lines]",
          "6: class Nokogiri::SAX::TestCase",
          "7:   describe Nokogiri::XML::SAX::PushParser do",
          "8:     let(:parser) { Nokogiri::XML::SAX::PushParser.new(Doc.new) }",
          "10:     it :test_exception do",
          "11:       assert_raises(Nokogiri::XML::SyntaxError) do",
          "12:         parser << \"<foo /><foo />\"",
          "13:       end",
          "15:       assert_raises(Nokogiri::XML::SyntaxError) do",
          "16:         parser << nil",
          "17:       end",
          "18:     end",
          "20:     it :test_early_finish do",
          "21:       parser << \"<foo>\"",
          "22:       assert_raises(Nokogiri::XML::SyntaxError) do",
          "23:         parser.finish",
          "24:       end",
          "25:     end",
          "27:     it :test_write_last_chunk do",
          "28:       parser << \"<foo>\"",
          "29:       parser.write(\"</foo>\", true)",
          "30:       assert_equal [[\"foo\", []]], parser.document.start_elements",
          "31:       assert_equal [[\"foo\"]], parser.document.end_elements",
          "32:     end",
          "34:     it :test_empty_doc do",
          "35:       parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "36:       parser.write(\"\", true)",
          "37:       assert_nil parser.document.start_elements",
          "38:       assert_nil parser.document.end_elements",
          "39:     end",
          "41:     it :test_finish_should_rethrow_last_error do",
          "42:       expected = assert_raises(Nokogiri::XML::SyntaxError) { parser << \"</foo>\" }",
          "43:       actual = assert_raises(Nokogiri::XML::SyntaxError) { parser.finish }",
          "44:       assert_equal actual.message, expected.message",
          "45:     end",
          "47:     it :test_should_throw_error_returned_by_document do",
          "48:       doc = Doc.new",
          "49:       class << doc",
          "50:         def error(msg)",
          "51:           raise \"parse error\"",
          "53:       end",
          "54:       parser = Nokogiri::XML::SAX::PushParser.new(doc)",
          "56:       exception = assert_raises(RuntimeError) { parser << \"</foo>\" }",
          "57:       assert_equal(\"parse error\", exception.message)",
          "58:     end",
          "60:     it :test_writing_nil do",
          "61:       assert_equal parser.write(nil), parser",
          "62:     end",
          "64:     it :test_end_document_called do",
          "65:       parser.<<(<<~EOF)",
          "66:         <p id=\"asdfasdf\">",
          "67:           <!-- This is a comment -->",
          "68:           Paragraph 1",
          "69:         </p>",
          "70:       EOF",
          "71:       refute parser.document.end_document_called",
          "72:       parser.finish",
          "73:       assert parser.document.end_document_called",
          "74:     end",
          "76:     it :test_start_element do",
          "77:       parser.<<(<<~EOF)",
          "78:         <p id=\"asdfasdf\">",
          "79:       EOF",
          "81:       assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],",
          "82:         parser.document.start_elements",
          "84:       parser.<<(<<~EOF)",
          "85:           <!-- This is a comment -->",
          "86:           Paragraph 1",
          "87:         </p>",
          "88:       EOF",
          "89:       assert_equal [\" This is a comment \"], parser.document.comments",
          "90:       parser.finish",
          "91:     end",
          "93:     it :test_start_element_with_namespaces do",
          "94:       parser.<<(<<~EOF)",
          "95:         <p xmlns:foo=\"http://foo.example.com/\">",
          "96:       EOF",
          "98:       assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "99:         parser.document.start_elements",
          "101:       parser.<<(<<~EOF)",
          "102:           <!-- This is a comment -->",
          "103:           Paragraph 1",
          "104:         </p>",
          "105:       EOF",
          "106:       assert_equal [\" This is a comment \"], parser.document.comments",
          "107:       parser.finish",
          "108:     end",
          "110:     it :test_start_element_ns do",
          "111:       parser.<<(<<~EOF)",
          "112:         <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>",
          "113:       EOF",
          "115:       assert_equal 1, parser.document.start_elements_namespace.length",
          "116:       el = parser.document.start_elements_namespace.first",
          "118:       assert_equal \"stream\", el.first",
          "119:       assert_equal 2, el[1].length",
          "120:       assert_equal [[\"version\", \"1.0\"], [\"size\", \"large\"]],",
          "121:         el[1].map { |x| [x.localname, x.value] }",
          "123:       assert_equal \"stream\", el[2]",
          "124:       assert_equal \"http://etherx.jabber.org/streams\", el[3]",
          "125:       parser.finish",
          "126:     end",
          "128:     it :test_end_element_ns do",
          "129:       parser.<<(<<~EOF)",
          "130:         <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>",
          "131:       EOF",
          "133:       assert_equal [[\"stream\", \"stream\", \"http://etherx.jabber.org/streams\"]],",
          "134:         parser.document.end_elements_namespace",
          "135:       parser.finish",
          "136:     end",
          "138:     it :test_chevron_partial_xml do",
          "139:       parser.<<(<<~EOF)",
          "140:         <p id=\"asdfasdf\">",
          "141:       EOF",
          "143:       parser.<<(<<~EOF)",
          "144:           <!-- This is a comment -->",
          "145:           Paragraph 1",
          "146:         </p>",
          "147:       EOF",
          "148:       assert_equal [\" This is a comment \"], parser.document.comments",
          "149:       parser.finish",
          "150:     end",
          "152:     it :test_chevron do",
          "153:       parser.<<(<<~EOF)",
          "154:         <p id=\"asdfasdf\">",
          "155:           <!-- This is a comment -->",
          "156:           Paragraph 1",
          "157:         </p>",
          "158:       EOF",
          "159:       parser.finish",
          "160:       assert_equal [\" This is a comment \"], parser.document.comments",
          "161:     end",
          "163:     it :test_default_options do",
          "164:       assert_equal 0, parser.options",
          "165:     end",
          "167:     it :test_recover do",
          "168:       parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "169:       parser.<<(<<~EOF)",
          "170:         <p>",
          "171:           Foo",
          "172:           <bar>",
          "173:           Bar",
          "174:         </p>",
          "175:       EOF",
          "176:       parser.finish",
          "177:       assert(parser.document.errors.size >= 1)",
          "178:       assert_equal [[\"p\", []], [\"bar\", []]], parser.document.start_elements",
          "179:       assert_equal \"FooBar\", parser.document.data.map { |x|",
          "180:         x.gsub(/\\s/, \"\")",
          "181:       }.join",
          "182:     end",
          "184:     it :test_broken_encoding do",
          "185:       skip_unless_libxml2(\"ultra hard to fix for pure Java version\")",
          "186:       parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "187:       # This is ISO_8859-1:",
          "188:       parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"",
          "189:       parser.finish",
          "190:       assert(parser.document.errors.size >= 1)",
          "191:       assert_equal \"Gau\\337\", parser.document.data.join",
          "192:       assert_equal [[\"r\"]], parser.document.end_elements",
          "193:     end",
          "195:     it :test_replace_entities_attribute_behavior do",
          "196:       if Nokogiri.uses_libxml?",
          "197:         # initially false",
          "198:         refute parser.replace_entities",
          "200:         # can be set to true",
          "201:         parser.replace_entities = true",
          "202:         assert parser.replace_entities",
          "204:         # can be set to false",
          "205:         parser.replace_entities = false",
          "206:         refute parser.replace_entities",
          "207:       else",
          "208:         # initially true",
          "209:         assert parser.replace_entities",
          "211:         # ignore attempts to set to false",
          "212:         parser.replace_entities = false # TODO: should we raise an exception here?",
          "213:         assert parser.replace_entities",
          "217:     it :test_untouched_entities do",
          "218:       skip_unless_libxml2(\"entities are always replaced in pure Java version\")",
          "219:       parser.<<(<<~EOF)",
          "220:         <p id=\"asdf&amp;asdf\">",
          "221:           <!-- This is a comment -->",
          "222:           Paragraph 1 &amp; 2",
          "223:         </p>",
          "224:       EOF",
          "225:       parser.finish",
          "226:       assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], parser.document.start_elements",
          "227:       assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip",
          "228:     end",
          "230:     it :test_replaced_entities do",
          "231:       parser.replace_entities = true",
          "232:       parser.<<(<<~EOF)",
          "233:         <p id=\"asdf&amp;asdf\">",
          "234:           <!-- This is a comment -->",
          "235:           Paragraph 1 &amp; 2",
          "236:         </p>",
          "237:       EOF",
          "238:       parser.finish",
          "239:       assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], parser.document.start_elements",
          "240:       assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip",
          "241:     end",
          "",
          "[Added Lines]",
          "6: module Nokogiri",
          "7:   module SAX",
          "8:     class TestCase",
          "9:       describe Nokogiri::XML::SAX::PushParser do",
          "10:         let(:parser) { Nokogiri::XML::SAX::PushParser.new(Doc.new) }",
          "12:         it :test_exception do",
          "13:           assert_raises(Nokogiri::XML::SyntaxError) do",
          "14:             parser << \"<foo /><foo />\"",
          "15:           end",
          "17:           assert_raises(Nokogiri::XML::SyntaxError) do",
          "18:             parser << nil",
          "19:           end",
          "20:         end",
          "22:         it :test_early_finish do",
          "23:           parser << \"<foo>\"",
          "24:           assert_raises(Nokogiri::XML::SyntaxError) do",
          "25:             parser.finish",
          "26:           end",
          "27:         end",
          "29:         it :test_write_last_chunk do",
          "30:           parser << \"<foo>\"",
          "31:           parser.write(\"</foo>\", true)",
          "32:           assert_equal [[\"foo\", []]], parser.document.start_elements",
          "33:           assert_equal [[\"foo\"]], parser.document.end_elements",
          "34:         end",
          "36:         it :test_empty_doc do",
          "37:           parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "38:           parser.write(\"\", true)",
          "39:           assert_nil parser.document.start_elements",
          "40:           assert_nil parser.document.end_elements",
          "41:         end",
          "43:         it :test_finish_should_rethrow_last_error do",
          "44:           expected = assert_raises(Nokogiri::XML::SyntaxError) { parser << \"</foo>\" }",
          "45:           actual = assert_raises(Nokogiri::XML::SyntaxError) { parser.finish }",
          "46:           assert_equal actual.message, expected.message",
          "47:         end",
          "49:         it :test_should_throw_error_returned_by_document do",
          "50:           doc = Doc.new",
          "51:           class << doc",
          "52:             def error(msg)",
          "53:               raise \"parse error\"",
          "54:             end",
          "55:           end",
          "56:           parser = Nokogiri::XML::SAX::PushParser.new(doc)",
          "58:           exception = assert_raises(RuntimeError) { parser << \"</foo>\" }",
          "59:           assert_equal(\"parse error\", exception.message)",
          "60:         end",
          "62:         it :test_writing_nil do",
          "63:           assert_equal parser.write(nil), parser",
          "64:         end",
          "66:         it :test_end_document_called do",
          "67:           parser.<<(<<~EOF)",
          "68:             <p id=\"asdfasdf\">",
          "69:               <!-- This is a comment -->",
          "70:               Paragraph 1",
          "71:             </p>",
          "72:           EOF",
          "73:           refute parser.document.end_document_called",
          "74:           parser.finish",
          "75:           assert parser.document.end_document_called",
          "78:         it :test_start_element do",
          "79:           parser.<<(<<~EOF)",
          "80:             <p id=\"asdfasdf\">",
          "81:           EOF",
          "83:           assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],",
          "84:             parser.document.start_elements",
          "86:           parser.<<(<<~EOF)",
          "87:               <!-- This is a comment -->",
          "88:               Paragraph 1",
          "89:             </p>",
          "90:           EOF",
          "91:           assert_equal [\" This is a comment \"], parser.document.comments",
          "92:           parser.finish",
          "93:         end",
          "95:         it :test_start_element_with_namespaces do",
          "96:           parser.<<(<<~EOF)",
          "97:             <p xmlns:foo=\"http://foo.example.com/\">",
          "98:           EOF",
          "100:           assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "101:             parser.document.start_elements",
          "103:           parser.<<(<<~EOF)",
          "104:               <!-- This is a comment -->",
          "105:               Paragraph 1",
          "106:             </p>",
          "107:           EOF",
          "108:           assert_equal [\" This is a comment \"], parser.document.comments",
          "109:           parser.finish",
          "110:         end",
          "112:         it :test_start_element_ns do",
          "113:           parser.<<(<<~EOF)",
          "114:             <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>",
          "115:           EOF",
          "117:           assert_equal 1, parser.document.start_elements_namespace.length",
          "118:           el = parser.document.start_elements_namespace.first",
          "120:           assert_equal \"stream\", el.first",
          "121:           assert_equal 2, el[1].length",
          "122:           assert_equal [[\"version\", \"1.0\"], [\"size\", \"large\"]],",
          "123:             el[1].map { |x| [x.localname, x.value] }",
          "125:           assert_equal \"stream\", el[2]",
          "126:           assert_equal \"http://etherx.jabber.org/streams\", el[3]",
          "127:           parser.finish",
          "128:         end",
          "130:         it :test_end_element_ns do",
          "131:           parser.<<(<<~EOF)",
          "132:             <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>",
          "133:           EOF",
          "135:           assert_equal [[\"stream\", \"stream\", \"http://etherx.jabber.org/streams\"]],",
          "136:             parser.document.end_elements_namespace",
          "137:           parser.finish",
          "138:         end",
          "140:         it :test_chevron_partial_xml do",
          "141:           parser.<<(<<~EOF)",
          "142:             <p id=\"asdfasdf\">",
          "143:           EOF",
          "145:           parser.<<(<<~EOF)",
          "146:               <!-- This is a comment -->",
          "147:               Paragraph 1",
          "148:             </p>",
          "149:           EOF",
          "150:           assert_equal [\" This is a comment \"], parser.document.comments",
          "151:           parser.finish",
          "152:         end",
          "154:         it :test_chevron do",
          "155:           parser.<<(<<~EOF)",
          "156:             <p id=\"asdfasdf\">",
          "157:               <!-- This is a comment -->",
          "158:               Paragraph 1",
          "159:             </p>",
          "160:           EOF",
          "161:           parser.finish",
          "162:           assert_equal [\" This is a comment \"], parser.document.comments",
          "163:         end",
          "165:         it :test_default_options do",
          "166:           assert_equal 0, parser.options",
          "167:         end",
          "169:         it :test_recover do",
          "170:           parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "171:           parser.<<(<<~EOF)",
          "172:             <p>",
          "173:               Foo",
          "174:               <bar>",
          "175:               Bar",
          "176:             </p>",
          "177:           EOF",
          "178:           parser.finish",
          "179:           assert(parser.document.errors.size >= 1)",
          "180:           assert_equal [[\"p\", []], [\"bar\", []]], parser.document.start_elements",
          "181:           assert_equal \"FooBar\", parser.document.data.map { |x|",
          "182:             x.gsub(/\\s/, \"\")",
          "183:           }.join",
          "184:         end",
          "186:         it :test_broken_encoding do",
          "187:           skip_unless_libxml2(\"ultra hard to fix for pure Java version\")",
          "188:           parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "189:           # This is ISO_8859-1:",
          "190:           parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"",
          "191:           parser.finish",
          "192:           assert(parser.document.errors.size >= 1)",
          "193:           assert_equal \"Gau\\337\", parser.document.data.join",
          "194:           assert_equal [[\"r\"]], parser.document.end_elements",
          "195:         end",
          "197:         it :test_replace_entities_attribute_behavior do",
          "198:           if Nokogiri.uses_libxml?",
          "199:             # initially false",
          "200:             refute parser.replace_entities",
          "202:             # can be set to true",
          "203:             parser.replace_entities = true",
          "204:             assert parser.replace_entities",
          "206:             # can be set to false",
          "207:             parser.replace_entities = false",
          "208:             refute parser.replace_entities",
          "209:           else",
          "210:             # initially true",
          "211:             assert parser.replace_entities",
          "213:             # ignore attempts to set to false",
          "214:             parser.replace_entities = false # TODO: should we raise an exception here?",
          "215:             assert parser.replace_entities",
          "216:           end",
          "217:         end",
          "219:         it :test_untouched_entities do",
          "220:           skip_unless_libxml2(\"entities are always replaced in pure Java version\")",
          "221:           parser.<<(<<~EOF)",
          "222:             <p id=\"asdf&amp;asdf\">",
          "223:               <!-- This is a comment -->",
          "224:               Paragraph 1 &amp; 2",
          "225:             </p>",
          "226:           EOF",
          "227:           parser.finish",
          "228:           assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], parser.document.start_elements",
          "229:           assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip",
          "230:         end",
          "232:         it :test_replaced_entities do",
          "233:           parser.replace_entities = true",
          "234:           parser.<<(<<~EOF)",
          "235:             <p id=\"asdf&amp;asdf\">",
          "236:               <!-- This is a comment -->",
          "237:               Paragraph 1 &amp; 2",
          "238:             </p>",
          "239:           EOF",
          "240:           parser.finish",
          "241:           assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], parser.document.start_elements",
          "242:           assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip",
          "243:         end",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e93a22e8b7faaf971a19c01df7c533f0a9541b81",
      "candidate_info": {
        "commit_hash": "e93a22e8b7faaf971a19c01df7c533f0a9541b81",
        "repo": "sparklemotion/nokogiri",
        "commit_url": "https://github.com/sparklemotion/nokogiri/commit/e93a22e8b7faaf971a19c01df7c533f0a9541b81",
        "files": [
          "test/xml/sax/test_parser.rb",
          "test/xml/sax/test_push_parser.rb"
        ],
        "message": "format: test files\n\n- xml/sax/test_parser.rb\n- xml/sax/test_push_parser.rb",
        "before_after_code_files": [
          "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb",
          "test/xml/sax/test_push_parser.rb||test/xml/sax/test_push_parser.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb"
          ],
          "candidate": [
            "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb"
          ]
        }
      },
      "candidate_diff": {
        "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb": [
          "File: test/xml/sax/test_parser.rb -> test/xml/sax/test_parser.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: require \"helper\"",
          "423:       end",
          "424:     end",
          "425:   end",
          "426: end",
          "",
          "[Removed Lines]",
          "5: module Nokogiri",
          "6:   module XML",
          "7:     module SAX",
          "8:       class TestParser < Nokogiri::SAX::TestCase",
          "9:         def setup",
          "10:           super",
          "11:           @parser = XML::SAX::Parser.new(Doc.new)",
          "12:         end",
          "14:         def test_parser_context_yielded_io",
          "15:           doc = Doc.new",
          "16:           parser = XML::SAX::Parser.new(doc)",
          "17:           xml = \"<foo a='&amp;b'/>\"",
          "19:           block_called = false",
          "20:           parser.parse(StringIO.new(xml)) do |ctx|",
          "21:             block_called = true",
          "22:             ctx.replace_entities = true",
          "23:           end",
          "25:           assert(block_called)",
          "27:           assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "28:         end",
          "30:         def test_parser_context_yielded_in_memory",
          "31:           doc = Doc.new",
          "32:           parser = XML::SAX::Parser.new(doc)",
          "33:           xml = \"<foo a='&amp;b'/>\"",
          "35:           block_called = false",
          "36:           parser.parse(xml) do |ctx|",
          "37:             block_called = true",
          "38:             ctx.replace_entities = true",
          "39:           end",
          "41:           assert(block_called)",
          "43:           assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "44:         end",
          "46:         def test_empty_decl",
          "47:           parser = XML::SAX::Parser.new(Doc.new)",
          "49:           xml = \"<root />\"",
          "50:           parser.parse(xml)",
          "51:           assert(parser.document.start_document_called, xml)",
          "52:           assert_nil(parser.document.xmldecls, xml)",
          "53:         end",
          "55:         def test_xml_decl",
          "56:           [",
          "57:             ['<?xml version=\"1.0\" ?>', [\"1.0\"]],",
          "58:             ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],",
          "59:             ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],",
          "60:             ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],",
          "61:             ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],",
          "62:             ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],",
          "63:           ].each do |decl, value|",
          "64:             parser = XML::SAX::Parser.new(Doc.new)",
          "66:             xml = \"#{decl}\\n<root />\"",
          "67:             parser.parse(xml)",
          "68:             assert(parser.document.start_document_called, xml)",
          "69:             assert_equal(value, parser.document.xmldecls, xml)",
          "70:           end",
          "71:         end",
          "73:         def test_parse_empty",
          "74:           assert_raises(RuntimeError) do",
          "75:             @parser.parse(\"\")",
          "76:           end",
          "77:         end",
          "79:         def test_namespace_declaration_order_is_saved",
          "80:           @parser.parse(<<~eoxml)",
          "81:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "82:               <a foo:bar='hello' />",
          "83:             </root>",
          "84:           eoxml",
          "85:           assert_equal(2, @parser.document.start_elements_namespace.length)",
          "86:           el = @parser.document.start_elements_namespace.first",
          "87:           namespaces = el.last",
          "88:           assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)",
          "89:           assert_equal([nil, \"http://example.com/\"], namespaces.last)",
          "90:         end",
          "92:         def test_bad_document_calls_error_handler",
          "93:           @parser.parse(\"<foo><bar></foo>\")",
          "94:           assert(@parser.document.errors)",
          "95:           assert(@parser.document.errors.length > 0)",
          "96:         end",
          "98:         def test_namespace_are_super_fun_to_parse",
          "99:           @parser.parse(<<~eoxml)",
          "100:             <root xmlns:foo='http://foo.example.com/'>",
          "101:               <a foo:bar='hello' />",
          "102:               <b xmlns:foo='http://bar.example.com/'>",
          "103:                 <a foo:bar='hello' />",
          "104:               </b>",
          "105:               <foo:bar>hello world</foo:bar>",
          "106:             </root>",
          "107:           eoxml",
          "109:           assert(@parser.document.start_elements_namespace.length > 0)",
          "110:           el = @parser.document.start_elements_namespace[1]",
          "111:           assert_equal(\"a\", el.first)",
          "112:           assert_equal(1, el[1].length)",
          "114:           attribute = el[1].first",
          "115:           assert_equal(\"bar\", attribute.localname)",
          "116:           assert_equal(\"foo\", attribute.prefix)",
          "117:           assert_equal(\"hello\", attribute.value)",
          "118:           assert_equal(\"http://foo.example.com/\", attribute.uri)",
          "119:         end",
          "121:         def test_sax_v1_namespace_attribute_declarations",
          "122:           @parser.parse(<<~eoxml)",
          "123:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "124:               <a foo:bar='hello' />",
          "125:               <b xmlns:foo='http://bar.example.com/'>",
          "126:                 <a foo:bar='hello' />",
          "127:               </b>",
          "128:               <foo:bar>hello world</foo:bar>",
          "129:             </root>",
          "130:           eoxml",
          "131:           assert(@parser.document.start_elements.length > 0)",
          "132:           elm = @parser.document.start_elements.first",
          "133:           assert_equal(\"root\", elm.first)",
          "134:           assert(elm[1].include?([\"xmlns:foo\", \"http://foo.example.com/\"]))",
          "135:           assert(elm[1].include?([\"xmlns\", \"http://example.com/\"]))",
          "136:         end",
          "138:         def test_sax_v1_namespace_nodes",
          "139:           @parser.parse(<<~eoxml)",
          "140:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "141:               <a foo:bar='hello' />",
          "142:               <b xmlns:foo='http://bar.example.com/'>",
          "143:                 <a foo:bar='hello' />",
          "144:               </b>",
          "145:               <foo:bar>hello world</foo:bar>",
          "146:             </root>",
          "147:           eoxml",
          "148:           assert_equal(5, @parser.document.start_elements.length)",
          "149:           assert(@parser.document.start_elements.map(&:first).include?(\"foo:bar\"))",
          "150:           assert(@parser.document.end_elements.map(&:first).include?(\"foo:bar\"))",
          "151:         end",
          "153:         def test_start_is_called_without_namespace",
          "154:           @parser.parse(<<~eoxml)",
          "155:             <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "156:             <foo:f><bar></foo:f>",
          "157:             </root>",
          "158:           eoxml",
          "159:           assert_equal([\"root\", \"foo:f\", \"bar\"],",
          "160:                        @parser.document.start_elements.map(&:first))",
          "161:         end",
          "163:         def test_parser_sets_encoding",
          "164:           parser = XML::SAX::Parser.new(Doc.new, \"UTF-8\")",
          "165:           assert_equal(\"UTF-8\", parser.encoding)",
          "166:         end",
          "168:         def test_errors_set_after_parsing_bad_dom",
          "169:           doc = Nokogiri::XML(\"<foo><bar></foo>\")",
          "170:           assert(doc.errors)",
          "172:           @parser.parse(\"<foo><bar></foo>\")",
          "173:           assert(@parser.document.errors)",
          "174:           assert(@parser.document.errors.length > 0)",
          "176:           doc.errors.each do |error|",
          "177:             assert_equal(\"UTF-8\", error.message.encoding.name)",
          "178:           end",
          "180:           # when using JRuby Nokogiri, more errors will be generated as the DOM",
          "181:           # parser continue to parse an ill formed document, while the sax parser",
          "182:           # will stop at the first error",
          "183:           unless Nokogiri.jruby?",
          "184:             assert_equal(doc.errors.length, @parser.document.errors.length)",
          "185:           end",
          "186:         end",
          "188:         def test_parse_with_memory_argument",
          "189:           @parser.parse(File.read(XML_FILE))",
          "190:           assert(@parser.document.cdata_blocks.length > 0)",
          "191:         end",
          "193:         def test_parse_with_io_argument",
          "194:           File.open(XML_FILE, \"rb\") do |f|",
          "195:             @parser.parse(f)",
          "196:           end",
          "197:           assert(@parser.document.cdata_blocks.length > 0)",
          "198:         end",
          "200:         def test_parse_io",
          "201:           call_parse_io_with_encoding(\"UTF-8\")",
          "202:         end",
          "204:         # issue #828",
          "205:         def test_parse_io_lower_case_encoding",
          "206:           call_parse_io_with_encoding(\"utf-8\")",
          "207:         end",
          "209:         def call_parse_io_with_encoding(encoding)",
          "210:           File.open(XML_FILE, \"rb\") do |f|",
          "211:             @parser.parse_io(f, encoding)",
          "212:           end",
          "213:           assert(@parser.document.cdata_blocks.length > 0)",
          "215:           called = false",
          "216:           @parser.document.start_elements.flatten.each do |thing|",
          "217:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "218:             called = true",
          "219:           end",
          "220:           assert(called)",
          "222:           called = false",
          "223:           @parser.document.end_elements.flatten.each do |thing|",
          "224:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "225:             called = true",
          "226:           end",
          "227:           assert(called)",
          "229:           called = false",
          "230:           @parser.document.data.each do |thing|",
          "231:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "232:             called = true",
          "233:           end",
          "234:           assert(called)",
          "236:           called = false",
          "237:           @parser.document.comments.flatten.each do |thing|",
          "238:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "239:             called = true",
          "240:           end",
          "241:           assert(called)",
          "243:           called = false",
          "244:           @parser.document.cdata_blocks.flatten.each do |thing|",
          "245:             assert_equal(\"UTF-8\", thing.encoding.name)",
          "246:             called = true",
          "247:           end",
          "248:           assert(called)",
          "249:         end",
          "251:         def test_parse_file",
          "252:           @parser.parse_file(XML_FILE)",
          "254:           assert_raises(ArgumentError) do",
          "255:             @parser.parse_file(nil)",
          "256:           end",
          "258:           assert_raises(Errno::ENOENT) do",
          "259:             @parser.parse_file(\"\")",
          "260:           end",
          "261:           assert_raises(Errno::EISDIR) do",
          "262:             @parser.parse_file(File.expand_path(File.dirname(__FILE__)))",
          "263:           end",
          "264:         end",
          "266:         def test_render_parse_nil_param",
          "267:           assert_raises(ArgumentError) { @parser.parse_memory(nil) }",
          "268:         end",
          "270:         def test_bad_encoding_args",
          "271:           assert_raises(ArgumentError) { XML::SAX::Parser.new(Doc.new, \"not an encoding\") }",
          "272:           assert_raises(ArgumentError) { @parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }",
          "273:         end",
          "275:         def test_ctag",
          "276:           @parser.parse_memory(<<~eoxml)",
          "277:             <p id=\"asdfasdf\">",
          "278:               <![CDATA[ This is a comment ]]>",
          "279:               Paragraph 1",
          "280:             </p>",
          "281:           eoxml",
          "282:           assert_equal([\" This is a comment \"], @parser.document.cdata_blocks)",
          "283:         end",
          "285:         def test_comment",
          "286:           @parser.parse_memory(<<~eoxml)",
          "287:             <p id=\"asdfasdf\">",
          "288:               <!-- This is a comment -->",
          "289:               Paragraph 1",
          "290:             </p>",
          "291:           eoxml",
          "292:           assert_equal([\" This is a comment \"], @parser.document.comments)",
          "293:         end",
          "295:         def test_characters",
          "296:           @parser.parse_memory(<<~eoxml)",
          "297:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "298:           eoxml",
          "299:           assert_equal([\"Paragraph 1\"], @parser.document.data)",
          "300:         end",
          "302:         def test_end_document",
          "303:           @parser.parse_memory(<<~eoxml)",
          "304:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "305:           eoxml",
          "306:           assert(@parser.document.end_document_called)",
          "307:         end",
          "309:         def test_end_element",
          "310:           @parser.parse_memory(<<~eoxml)",
          "311:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "312:           eoxml",
          "313:           assert_equal([[\"p\"]], @parser.document.end_elements)",
          "314:         end",
          "316:         def test_start_element_attrs",
          "317:           @parser.parse_memory(<<~eoxml)",
          "318:             <p id=\"asdfasdf\">Paragraph 1</p>",
          "319:           eoxml",
          "320:           assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], @parser.document.start_elements)",
          "321:         end",
          "323:         def test_start_element_attrs_include_namespaces",
          "324:           @parser.parse_memory(<<~eoxml)",
          "325:             <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>",
          "326:           eoxml",
          "327:           assert_equal([[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "328:                        @parser.document.start_elements)",
          "329:         end",
          "331:         def test_processing_instruction",
          "332:           @parser.parse_memory(<<~eoxml)",
          "333:             <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>",
          "334:             <?xml version=\"1.0\"?>",
          "335:           eoxml",
          "336:           assert_equal([[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],",
          "337:                        @parser.document.processing_instructions)",
          "338:         end",
          "340:         def test_parse_document",
          "341:           skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")",
          "342:           @parser.parse_memory(<<~eoxml)",
          "343:             <p>Paragraph 1</p>",
          "344:             <p>Paragraph 2</p>",
          "345:           eoxml",
          "346:         end",
          "348:         def test_parser_attributes",
          "349:           xml = <<~eoxml",
          "350:             <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>",
          "351:           eoxml",
          "353:           block_called = false",
          "354:           @parser.parse(xml) do |ctx|",
          "355:             block_called = true",
          "356:             ctx.replace_entities = true",
          "357:           end",
          "359:           assert(block_called)",
          "361:           assert_equal([[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], @parser.document.start_elements)",
          "362:         end",
          "364:         def test_recovery_from_incorrect_xml",
          "365:           xml = <<~eoxml",
          "366:             <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>",
          "367:           eoxml",
          "369:           block_called = false",
          "370:           @parser.parse(xml) do |ctx|",
          "371:             block_called = true",
          "372:             ctx.recovery = true",
          "373:           end",
          "375:           assert(block_called)",
          "377:           assert_equal([[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],",
          "378:                        @parser.document.start_elements)",
          "379:         end",
          "381:         def test_square_bracket_in_text # issue 1261",
          "382:           xml = <<~eoxml",
          "383:             <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">",
          "384:               <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>",
          "385:               <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>",
          "386:             </tu>",
          "387:           eoxml",
          "388:           @parser.parse(xml)",
          "389:           assert_includes(@parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")",
          "390:         end",
          "392:         def test_large_cdata_is_handled",
          "393:           # see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200",
          "394:           skip(\"Upstream libxml2 <= 2.9.10 needs to be patched\") if Nokogiri::VersionInfo.instance.libxml2_using_system?",
          "396:           template = <<~EOF",
          "397:             <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "398:             <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">",
          "399:                <soapenv:Header>",
          "400:                   <AuthHeader xsi:type=\"ns:vAuthHeader\">",
          "401:                   <userName xsi:type=\"xsd:string\">gorilla</userName>",
          "402:                   <password xsi:type=\"xsd:string\">secret</password>",
          "403:                 </AuthHeader>",
          "404:                </soapenv:Header>",
          "405:               <soapenv:Body>",
          "406:                 <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">",
          "407:                   <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>",
          "408:                 </ns:checkToken>",
          "409:                </soapenv:Body>",
          "410:             </soapenv:Envelope>",
          "411:           EOF",
          "413:           factor = 10",
          "414:           huge_data = \"a\" * (1024 * 1024 * factor)",
          "415:           xml = StringIO.new(template % (huge_data))",
          "417:           handler = Nokogiri::SAX::TestCase::Doc.new",
          "418:           parser = Nokogiri::XML::SAX::Parser.new(handler)",
          "419:           parser.parse(xml)",
          "421:           assert_predicate(handler.errors, :empty?)",
          "422:         end",
          "",
          "[Added Lines]",
          "5: class Nokogiri::SAX::TestCase",
          "6:   describe Nokogiri::XML::SAX::Parser do",
          "7:     let(:parser) { Nokogiri::XML::SAX::Parser.new(Doc.new) }",
          "9:     it :test_parser_context_yielded_io do",
          "10:       doc = Doc.new",
          "11:       parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "12:       xml = \"<foo a='&amp;b'/>\"",
          "14:       block_called = false",
          "15:       parser.parse(StringIO.new(xml)) do |ctx|",
          "16:         block_called = true",
          "17:         ctx.replace_entities = true",
          "20:       assert(block_called)",
          "22:       assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "23:     end",
          "25:     it :test_parser_context_yielded_in_memory do",
          "26:       doc = Doc.new",
          "27:       parser = Nokogiri::XML::SAX::Parser.new(doc)",
          "28:       xml = \"<foo a='&amp;b'/>\"",
          "30:       block_called = false",
          "31:       parser.parse(xml) do |ctx|",
          "32:         block_called = true",
          "33:         ctx.replace_entities = true",
          "34:       end",
          "36:       assert(block_called)",
          "38:       assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)",
          "39:     end",
          "41:     it :test_empty_decl do",
          "42:       parser = Nokogiri::XML::SAX::Parser.new(Doc.new)",
          "44:       xml = \"<root />\"",
          "45:       parser.parse(xml)",
          "46:       assert(parser.document.start_document_called, xml)",
          "47:       assert_nil(parser.document.xmldecls, xml)",
          "48:     end",
          "50:     it :test_xml_decl do",
          "51:       [",
          "52:         ['<?xml version=\"1.0\" ?>', [\"1.0\"]],",
          "53:         ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],",
          "54:         ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],",
          "55:         ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],",
          "56:         ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],",
          "57:         ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],",
          "58:       ].each do |decl, value|",
          "59:         parser = Nokogiri::XML::SAX::Parser.new(Doc.new)",
          "61:         xml = \"#{decl}\\n<root />\"",
          "62:         parser.parse(xml)",
          "63:         assert(parser.document.start_document_called, xml)",
          "64:         assert_equal(value, parser.document.xmldecls, xml)",
          "65:       end",
          "66:     end",
          "68:     it :test_parse_empty do",
          "69:       assert_raises(RuntimeError) do",
          "70:         parser.parse(\"\")",
          "71:       end",
          "72:     end",
          "74:     it :test_namespace_declaration_order_is_saved do",
          "75:       parser.parse(<<~EOF)",
          "76:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "77:           <a foo:bar='hello' />",
          "78:         </root>",
          "79:       EOF",
          "80:       assert_equal(2, parser.document.start_elements_namespace.length)",
          "81:       el = parser.document.start_elements_namespace.first",
          "82:       namespaces = el.last",
          "83:       assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)",
          "84:       assert_equal([nil, \"http://example.com/\"], namespaces.last)",
          "85:     end",
          "87:     it :test_bad_document_calls_error_handler do",
          "88:       parser.parse(\"<foo><bar></foo>\")",
          "89:       assert(parser.document.errors)",
          "90:       assert(parser.document.errors.length > 0)",
          "91:     end",
          "93:     it :test_namespace_are_super_fun_to_parse do",
          "94:       parser.parse(<<~EOF)",
          "95:         <root xmlns:foo='http://foo.example.com/'>",
          "96:           <a foo:bar='hello' />",
          "97:           <b xmlns:foo='http://bar.example.com/'>",
          "98:             <a foo:bar='hello' />",
          "99:           </b>",
          "100:           <foo:bar>hello world</foo:bar>",
          "101:         </root>",
          "102:       EOF",
          "104:       assert(parser.document.start_elements_namespace.length > 0)",
          "105:       el = parser.document.start_elements_namespace[1]",
          "106:       assert_equal(\"a\", el.first)",
          "107:       assert_equal(1, el[1].length)",
          "109:       attribute = el[1].first",
          "110:       assert_equal(\"bar\", attribute.localname)",
          "111:       assert_equal(\"foo\", attribute.prefix)",
          "112:       assert_equal(\"hello\", attribute.value)",
          "113:       assert_equal(\"http://foo.example.com/\", attribute.uri)",
          "114:     end",
          "116:     it :test_sax_v1_namespace_attribute_declarations do",
          "117:       parser.parse(<<~EOF)",
          "118:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "119:           <a foo:bar='hello' />",
          "120:           <b xmlns:foo='http://bar.example.com/'>",
          "121:             <a foo:bar='hello' />",
          "122:           </b>",
          "123:           <foo:bar>hello world</foo:bar>",
          "124:         </root>",
          "125:       EOF",
          "126:       assert(parser.document.start_elements.length > 0)",
          "127:       elm = parser.document.start_elements.first",
          "128:       assert_equal(\"root\", elm.first)",
          "129:       assert(elm[1].include?([\"xmlns:foo\", \"http://foo.example.com/\"]))",
          "130:       assert(elm[1].include?([\"xmlns\", \"http://example.com/\"]))",
          "131:     end",
          "133:     it :test_sax_v1_namespace_nodes do",
          "134:       parser.parse(<<~EOF)",
          "135:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "136:           <a foo:bar='hello' />",
          "137:           <b xmlns:foo='http://bar.example.com/'>",
          "138:             <a foo:bar='hello' />",
          "139:           </b>",
          "140:           <foo:bar>hello world</foo:bar>",
          "141:         </root>",
          "142:       EOF",
          "143:       assert_equal(5, parser.document.start_elements.length)",
          "144:       assert(parser.document.start_elements.map(&:first).include?(\"foo:bar\"))",
          "145:       assert(parser.document.end_elements.map(&:first).include?(\"foo:bar\"))",
          "146:     end",
          "148:     it :test_start_is_called_without_namespace do",
          "149:       parser.parse(<<~EOF)",
          "150:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "151:         <foo:f><bar></foo:f>",
          "152:         </root>",
          "153:       EOF",
          "154:       assert_equal(",
          "155:         [\"root\", \"foo:f\", \"bar\"],",
          "156:         parser.document.start_elements.map(&:first)",
          "157:       )",
          "158:     end",
          "160:     it :test_parser_sets_encoding do",
          "161:       parser = Nokogiri::XML::SAX::Parser.new(Doc.new, \"UTF-8\")",
          "162:       assert_equal(\"UTF-8\", parser.encoding)",
          "163:     end",
          "165:     it :test_errors_set_after_parsing_bad_dom do",
          "166:       doc = Nokogiri::XML(\"<foo><bar></foo>\")",
          "167:       assert(doc.errors)",
          "169:       parser.parse(\"<foo><bar></foo>\")",
          "170:       assert(parser.document.errors)",
          "171:       assert(parser.document.errors.length > 0)",
          "173:       doc.errors.each do |error|",
          "174:         assert_equal(\"UTF-8\", error.message.encoding.name)",
          "175:       end",
          "177:       # when using JRuby Nokogiri, more errors will be generated as the DOM",
          "178:       # parser continue to parse an ill formed document, while the sax parser",
          "179:       # will stop at the first error",
          "180:       unless Nokogiri.jruby?",
          "181:         assert_equal(doc.errors.length, parser.document.errors.length)",
          "182:       end",
          "183:     end",
          "185:     it :test_parse_with_memory_argument do",
          "186:       parser.parse(File.read(XML_FILE))",
          "187:       assert(parser.document.cdata_blocks.length > 0)",
          "188:     end",
          "190:     it :test_parse_with_io_argument do",
          "191:       File.open(XML_FILE, \"rb\") do |f|",
          "192:         parser.parse(f)",
          "193:       end",
          "194:       assert(parser.document.cdata_blocks.length > 0)",
          "195:     end",
          "197:     it :test_parse_io do",
          "198:       call_parse_io_with_encoding(\"UTF-8\")",
          "199:     end",
          "201:     # issue #828",
          "202:     it :test_parse_io_lower_case_encoding do",
          "203:       call_parse_io_with_encoding(\"utf-8\")",
          "204:     end",
          "206:     def call_parse_io_with_encoding(encoding)",
          "207:       File.open(XML_FILE, \"rb\") do |f|",
          "208:         parser.parse_io(f, encoding)",
          "209:       end",
          "210:       assert(parser.document.cdata_blocks.length > 0)",
          "212:       called = false",
          "213:       parser.document.start_elements.flatten.each do |thing|",
          "214:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "215:         called = true",
          "216:       end",
          "217:       assert(called)",
          "219:       called = false",
          "220:       parser.document.end_elements.flatten.each do |thing|",
          "221:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "222:         called = true",
          "223:       end",
          "224:       assert(called)",
          "226:       called = false",
          "227:       parser.document.data.each do |thing|",
          "228:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "229:         called = true",
          "230:       end",
          "231:       assert(called)",
          "233:       called = false",
          "234:       parser.document.comments.flatten.each do |thing|",
          "235:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "236:         called = true",
          "237:       end",
          "238:       assert(called)",
          "240:       called = false",
          "241:       parser.document.cdata_blocks.flatten.each do |thing|",
          "242:         assert_equal(\"UTF-8\", thing.encoding.name)",
          "243:         called = true",
          "244:       end",
          "245:       assert(called)",
          "246:     end",
          "248:     it :test_parse_file do",
          "249:       parser.parse_file(XML_FILE)",
          "251:       assert_raises(ArgumentError) do",
          "252:         parser.parse_file(nil)",
          "253:       end",
          "255:       assert_raises(Errno::ENOENT) do",
          "256:         parser.parse_file(\"\")",
          "257:       end",
          "258:       assert_raises(Errno::EISDIR) do",
          "259:         parser.parse_file(File.expand_path(File.dirname(__FILE__)))",
          "260:       end",
          "261:     end",
          "263:     it :test_render_parse_nil_param do",
          "264:       assert_raises(ArgumentError) { parser.parse_memory(nil) }",
          "265:     end",
          "267:     it :test_bad_encoding_args do",
          "268:       assert_raises(ArgumentError) { Nokogiri::XML::SAX::Parser.new(Doc.new, \"not an encoding\") }",
          "269:       assert_raises(ArgumentError) { parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }",
          "270:     end",
          "272:     it :test_ctag do",
          "273:       parser.parse_memory(<<~EOF)",
          "274:         <p id=\"asdfasdf\">",
          "275:           <![CDATA[ This is a comment ]]>",
          "276:           Paragraph 1",
          "277:         </p>",
          "278:       EOF",
          "279:       assert_equal([\" This is a comment \"], parser.document.cdata_blocks)",
          "280:     end",
          "282:     it :test_comment do",
          "283:       parser.parse_memory(<<~EOF)",
          "284:         <p id=\"asdfasdf\">",
          "285:           <!-- This is a comment -->",
          "286:           Paragraph 1",
          "287:         </p>",
          "288:       EOF",
          "289:       assert_equal([\" This is a comment \"], parser.document.comments)",
          "290:     end",
          "292:     it :test_characters do",
          "293:       parser.parse_memory(<<~EOF)",
          "294:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "295:       EOF",
          "296:       assert_equal([\"Paragraph 1\"], parser.document.data)",
          "297:     end",
          "299:     it :test_end_document do",
          "300:       parser.parse_memory(<<~EOF)",
          "301:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "302:       EOF",
          "303:       assert(parser.document.end_document_called)",
          "304:     end",
          "306:     it :test_end_element do",
          "307:       parser.parse_memory(<<~EOF)",
          "308:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "309:       EOF",
          "310:       assert_equal([[\"p\"]], parser.document.end_elements)",
          "311:     end",
          "313:     it :test_start_element_attrs do",
          "314:       parser.parse_memory(<<~EOF)",
          "315:         <p id=\"asdfasdf\">Paragraph 1</p>",
          "316:       EOF",
          "317:       assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], parser.document.start_elements)",
          "318:     end",
          "320:     it :test_start_element_attrs_include_namespaces do",
          "321:       parser.parse_memory(<<~EOF)",
          "322:         <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>",
          "323:       EOF",
          "324:       assert_equal(",
          "325:         [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "326:         parser.document.start_elements",
          "327:       )",
          "328:     end",
          "330:     it :test_processing_instruction do",
          "331:       parser.parse_memory(<<~EOF)",
          "332:         <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>",
          "333:         <?xml version=\"1.0\"?>",
          "334:       EOF",
          "335:       assert_equal(",
          "336:         [[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],",
          "337:         parser.document.processing_instructions",
          "338:       )",
          "339:     end",
          "341:     it :test_parse_document do",
          "342:       skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")",
          "343:       parser.parse_memory(<<~EOF)",
          "344:         <p>Paragraph 1</p>",
          "345:         <p>Paragraph 2</p>",
          "346:       EOF",
          "347:     end",
          "349:     it :test_parser_attributes do",
          "350:       xml = <<~EOF",
          "351:         <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>",
          "352:       EOF",
          "354:       block_called = false",
          "355:       parser.parse(xml) do |ctx|",
          "356:         block_called = true",
          "357:         ctx.replace_entities = true",
          "358:       end",
          "360:       assert(block_called)",
          "362:       assert_equal(",
          "363:         [[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], parser.document.start_elements",
          "364:       )",
          "365:     end",
          "367:     it :test_recovery_from_incorrect_xml do",
          "368:       xml = <<~EOF",
          "369:         <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>",
          "370:       EOF",
          "372:       block_called = false",
          "373:       parser.parse(xml) do |ctx|",
          "374:         block_called = true",
          "375:         ctx.recovery = true",
          "376:       end",
          "378:       assert(block_called)",
          "380:       assert_equal(",
          "381:         [[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],",
          "382:         parser.document.start_elements",
          "383:       )",
          "384:     end",
          "386:     it :test_square_bracket_in_text do",
          "387:       # issue 1261",
          "388:       xml = <<~EOF",
          "389:         <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">",
          "390:           <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>",
          "391:           <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>",
          "392:         </tu>",
          "393:       EOF",
          "394:       parser.parse(xml)",
          "395:       assert_includes(parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")",
          "396:     end",
          "398:     it :test_large_cdata_is_handled do",
          "399:       # see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200",
          "400:       skip(\"Upstream libxml2 <= 2.9.10 needs to be patched\") if Nokogiri::VersionInfo.instance.libxml2_using_system?",
          "402:       template = <<~EOF",
          "403:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "404:         <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">",
          "405:            <soapenv:Header>",
          "406:               <AuthHeader xsi:type=\"ns:vAuthHeader\">",
          "407:               <userName xsi:type=\"xsd:string\">gorilla</userName>",
          "408:               <password xsi:type=\"xsd:string\">secret</password>",
          "409:             </AuthHeader>",
          "410:            </soapenv:Header>",
          "411:           <soapenv:Body>",
          "412:             <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">",
          "413:               <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>",
          "414:             </ns:checkToken>",
          "415:            </soapenv:Body>",
          "416:         </soapenv:Envelope>",
          "417:       EOF",
          "419:       factor = 10",
          "420:       huge_data = \"a\" * (1024 * 1024 * factor)",
          "421:       xml = StringIO.new(template % huge_data)",
          "423:       handler = Nokogiri::SAX::TestCase::Doc.new",
          "424:       parser = Nokogiri::XML::SAX::Parser.new(handler)",
          "425:       parser.parse(xml)",
          "427:       assert_predicate(handler.errors, :empty?)",
          "",
          "---------------"
        ],
        "test/xml/sax/test_push_parser.rb||test/xml/sax/test_push_parser.rb": [
          "File: test/xml/sax/test_push_parser.rb -> test/xml/sax/test_push_parser.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # -*- coding: utf-8 -*-",
          "3: require \"helper\"",
          "60:         end",
          "264:     end",
          "265:   end",
          "266: end",
          "",
          "[Removed Lines]",
          "5: module Nokogiri",
          "6:   module XML",
          "7:     module SAX",
          "8:       class TestPushParser < Nokogiri::SAX::TestCase",
          "9:         def setup",
          "10:           super",
          "11:           @parser = XML::SAX::PushParser.new(Doc.new)",
          "12:         end",
          "14:         def test_exception",
          "15:           assert_raises(SyntaxError) do",
          "16:             @parser << \"<foo /><foo />\"",
          "17:           end",
          "19:           assert_raises(SyntaxError) do",
          "20:             @parser << nil",
          "21:           end",
          "22:         end",
          "24:         def test_early_finish",
          "25:           @parser << \"<foo>\"",
          "26:           assert_raises(SyntaxError) do",
          "27:             @parser.finish",
          "28:           end",
          "29:         end",
          "31:         def test_write_last_chunk",
          "32:           @parser << \"<foo>\"",
          "33:           @parser.write \"</foo>\", true",
          "34:           assert_equal [[\"foo\", []]], @parser.document.start_elements",
          "35:           assert_equal [[\"foo\"]], @parser.document.end_elements",
          "36:         end",
          "38:         def test_empty_doc",
          "39:           @parser.options |= XML::ParseOptions::RECOVER",
          "40:           @parser.write \"\", true",
          "41:           assert_nil @parser.document.start_elements",
          "42:           assert_nil @parser.document.end_elements",
          "43:         end",
          "46:         def test_finish_should_rethrow_last_error",
          "47:           begin",
          "48:             @parser << \"</foo>\"",
          "49:           rescue => e",
          "50:             expected = e",
          "51:           end",
          "53:           begin",
          "54:             @parser.finish",
          "55:           rescue => e",
          "56:             actual = e",
          "57:           end",
          "59:           assert_equal actual.message, expected.message",
          "62:         def test_should_throw_error_returned_by_document",
          "63:           doc = Doc.new",
          "64:           class << doc",
          "65:             def error msg",
          "66:               raise \"parse error\"",
          "67:             end",
          "68:           end",
          "70:           @parser = XML::SAX::PushParser.new(doc)",
          "71:           begin",
          "72:             @parser << \"</foo>\"",
          "73:           rescue => e",
          "74:             actual = e",
          "75:           end",
          "76:           fail 'PushParser should throw error when fed ill-formed data' if actual.nil?",
          "78:           assert_equal actual.message, \"parse error\"",
          "79:         end",
          "81:         def test_writing_nil",
          "82:           assert_equal @parser.write(nil), @parser",
          "83:         end",
          "85:         def test_end_document_called",
          "86:           @parser.<<(<<-eoxml)",
          "87:             <p id=\"asdfasdf\">",
          "88:               <!-- This is a comment -->",
          "89:               Paragraph 1",
          "90:             </p>",
          "91:           eoxml",
          "92:           assert ! @parser.document.end_document_called",
          "93:           @parser.finish",
          "94:           assert @parser.document.end_document_called",
          "95:         end",
          "97:         def test_start_element",
          "98:           @parser.<<(<<-eoxml)",
          "99:             <p id=\"asdfasdf\">",
          "100:           eoxml",
          "102:           assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],",
          "103:             @parser.document.start_elements",
          "105:           @parser.<<(<<-eoxml)",
          "106:               <!-- This is a comment -->",
          "107:               Paragraph 1",
          "108:             </p>",
          "109:           eoxml",
          "110:           assert_equal [' This is a comment '], @parser.document.comments",
          "111:           @parser.finish",
          "112:         end",
          "114:         def test_start_element_with_namespaces",
          "115:           @parser.<<(<<-eoxml)",
          "116:             <p xmlns:foo=\"http://foo.example.com/\">",
          "117:           eoxml",
          "119:           assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "120:             @parser.document.start_elements",
          "122:           @parser.<<(<<-eoxml)",
          "123:               <!-- This is a comment -->",
          "124:               Paragraph 1",
          "125:             </p>",
          "126:           eoxml",
          "127:           assert_equal [' This is a comment '], @parser.document.comments",
          "128:           @parser.finish",
          "129:         end",
          "131:         def test_start_element_ns",
          "132:           @parser.<<(<<-eoxml)",
          "133:             <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>",
          "134:           eoxml",
          "136:           assert_equal 1, @parser.document.start_elements_namespace.length",
          "137:           el = @parser.document.start_elements_namespace.first",
          "139:           assert_equal 'stream', el.first",
          "140:           assert_equal 2, el[1].length",
          "141:           assert_equal [['version', '1.0'], ['size', 'large']],",
          "142:             el[1].map { |x| [x.localname, x.value] }",
          "144:           assert_equal 'stream', el[2]",
          "145:           assert_equal 'http://etherx.jabber.org/streams', el[3]",
          "146:           @parser.finish",
          "147:         end",
          "149:         def test_end_element_ns",
          "150:           @parser.<<(<<-eoxml)",
          "151:             <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>",
          "152:           eoxml",
          "154:           assert_equal [['stream', 'stream', 'http://etherx.jabber.org/streams']],",
          "155:             @parser.document.end_elements_namespace",
          "156:           @parser.finish",
          "157:         end",
          "159:         def test_chevron_partial_xml",
          "160:           @parser.<<(<<-eoxml)",
          "161:             <p id=\"asdfasdf\">",
          "162:           eoxml",
          "164:           @parser.<<(<<-eoxml)",
          "165:               <!-- This is a comment -->",
          "166:               Paragraph 1",
          "167:             </p>",
          "168:           eoxml",
          "169:           assert_equal [' This is a comment '], @parser.document.comments",
          "170:           @parser.finish",
          "171:         end",
          "173:         def test_chevron",
          "174:           @parser.<<(<<-eoxml)",
          "175:             <p id=\"asdfasdf\">",
          "176:               <!-- This is a comment -->",
          "177:               Paragraph 1",
          "178:             </p>",
          "179:           eoxml",
          "180:           @parser.finish",
          "181:           assert_equal [' This is a comment '], @parser.document.comments",
          "182:         end",
          "184:         def test_default_options",
          "185:           assert_equal 0, @parser.options",
          "186:         end",
          "188:         def test_recover",
          "189:           @parser.options |= XML::ParseOptions::RECOVER",
          "190:           @parser.<<(<<-eoxml)",
          "191:             <p>",
          "192:               Foo",
          "193:               <bar>",
          "194:               Bar",
          "195:             </p>",
          "196:           eoxml",
          "197:           @parser.finish",
          "198:           assert(@parser.document.errors.size >= 1)",
          "199:           assert_equal [[\"p\", []], [\"bar\", []]], @parser.document.start_elements",
          "200:           assert_equal \"FooBar\", @parser.document.data.map { |x|",
          "201:             x.gsub(/\\s/, '')",
          "202:           }.join",
          "203:         end",
          "205:         def test_broken_encoding",
          "206:           skip_unless_libxml2(\"ultra hard to fix for pure Java version\")",
          "207:           @parser.options |= XML::ParseOptions::RECOVER",
          "208:           # This is ISO_8859-1:",
          "209:           @parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"",
          "210:           @parser.finish",
          "211:           assert(@parser.document.errors.size >= 1)",
          "212:           assert_equal \"Gau\\337\", @parser.document.data.join",
          "213:           assert_equal [[\"r\"]], @parser.document.end_elements",
          "214:         end",
          "216:         def test_replace_entities_attribute_behavior",
          "217:           if Nokogiri.uses_libxml?",
          "218:             # initially false",
          "219:             assert_equal false, @parser.replace_entities",
          "221:             # can be set to true",
          "222:             @parser.replace_entities = true",
          "223:             assert_equal true, @parser.replace_entities",
          "225:             # can be set to false",
          "226:             @parser.replace_entities = false",
          "227:             assert_equal false, @parser.replace_entities",
          "228:           else",
          "229:             # initially true",
          "230:             assert_equal true, @parser.replace_entities",
          "232:             # ignore attempts to set to false",
          "233:             @parser.replace_entities = false # TODO: should we raise an exception here?",
          "234:             assert_equal true, @parser.replace_entities",
          "235:           end",
          "236:         end",
          "238:         def test_untouched_entities",
          "239:           skip_unless_libxml2(\"entities are always replaced in pure Java version\")",
          "240:           @parser.<<(<<-eoxml)",
          "241:             <p id=\"asdf&amp;asdf\">",
          "242:               <!-- This is a comment -->",
          "243:               Paragraph 1 &amp; 2",
          "244:             </p>",
          "245:           eoxml",
          "246:           @parser.finish",
          "247:           assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], @parser.document.start_elements",
          "248:           assert_equal \"Paragraph 1 & 2\", @parser.document.data.join.strip",
          "249:         end",
          "251:         def test_replaced_entities",
          "252:           @parser.replace_entities = true",
          "253:           @parser.<<(<<-eoxml)",
          "254:             <p id=\"asdf&amp;asdf\">",
          "255:               <!-- This is a comment -->",
          "256:               Paragraph 1 &amp; 2",
          "257:             </p>",
          "258:           eoxml",
          "259:           @parser.finish",
          "260:           assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], @parser.document.start_elements",
          "261:           assert_equal \"Paragraph 1 & 2\", @parser.document.data.join.strip",
          "262:         end",
          "263:       end",
          "",
          "[Added Lines]",
          "2: # frozen_string_literal: true",
          "6: class Nokogiri::SAX::TestCase",
          "7:   describe Nokogiri::XML::SAX::PushParser do",
          "8:     let(:parser) { Nokogiri::XML::SAX::PushParser.new(Doc.new) }",
          "10:     it :test_exception do",
          "11:       assert_raises(Nokogiri::XML::SyntaxError) do",
          "12:         parser << \"<foo /><foo />\"",
          "13:       end",
          "15:       assert_raises(Nokogiri::XML::SyntaxError) do",
          "16:         parser << nil",
          "17:       end",
          "18:     end",
          "20:     it :test_early_finish do",
          "21:       parser << \"<foo>\"",
          "22:       assert_raises(Nokogiri::XML::SyntaxError) do",
          "23:         parser.finish",
          "24:       end",
          "25:     end",
          "27:     it :test_write_last_chunk do",
          "28:       parser << \"<foo>\"",
          "29:       parser.write(\"</foo>\", true)",
          "30:       assert_equal [[\"foo\", []]], parser.document.start_elements",
          "31:       assert_equal [[\"foo\"]], parser.document.end_elements",
          "32:     end",
          "34:     it :test_empty_doc do",
          "35:       parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "36:       parser.write(\"\", true)",
          "37:       assert_nil parser.document.start_elements",
          "38:       assert_nil parser.document.end_elements",
          "39:     end",
          "41:     it :test_finish_should_rethrow_last_error do",
          "42:       expected = assert_raise(Nokogiri::XML::SyntaxError) { parser << \"</foo>\" }",
          "43:       actual = assert_raise(Nokogiri::XML::SyntaxError) { parser.finish }",
          "44:       assert_equal actual.message, expected.message",
          "45:     end",
          "47:     it :test_should_throw_error_returned_by_document do",
          "48:       doc = Doc.new",
          "49:       class << doc",
          "50:         def error(msg)",
          "51:           raise \"parse error\"",
          "53:       end",
          "54:       parser = Nokogiri::XML::SAX::PushParser.new(doc)",
          "56:       exception = assert_raise(RuntimeError) { parser << \"</foo>\" }",
          "57:       assert_equal exception.message, \"parse error\"",
          "58:     end",
          "60:     it :test_writing_nil do",
          "61:       assert_equal parser.write(nil), parser",
          "62:     end",
          "64:     it :test_end_document_called do",
          "65:       parser.<<(<<~EOF)",
          "66:         <p id=\"asdfasdf\">",
          "67:           <!-- This is a comment -->",
          "68:           Paragraph 1",
          "69:         </p>",
          "70:       EOF",
          "71:       assert !parser.document.end_document_called",
          "72:       parser.finish",
          "73:       assert parser.document.end_document_called",
          "74:     end",
          "76:     it :test_start_element do",
          "77:       parser.<<(<<~EOF)",
          "78:         <p id=\"asdfasdf\">",
          "79:       EOF",
          "81:       assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],",
          "82:         parser.document.start_elements",
          "84:       parser.<<(<<~EOF)",
          "85:           <!-- This is a comment -->",
          "86:           Paragraph 1",
          "87:         </p>",
          "88:       EOF",
          "89:       assert_equal [\" This is a comment \"], parser.document.comments",
          "90:       parser.finish",
          "91:     end",
          "93:     it :test_start_element_with_namespaces do",
          "94:       parser.<<(<<~EOF)",
          "95:         <p xmlns:foo=\"http://foo.example.com/\">",
          "96:       EOF",
          "98:       assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],",
          "99:         parser.document.start_elements",
          "101:       parser.<<(<<~EOF)",
          "102:           <!-- This is a comment -->",
          "103:           Paragraph 1",
          "104:         </p>",
          "105:       EOF",
          "106:       assert_equal [\" This is a comment \"], parser.document.comments",
          "107:       parser.finish",
          "108:     end",
          "110:     it :test_start_element_ns do",
          "111:       parser.<<(<<~EOF)",
          "112:         <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>",
          "113:       EOF",
          "115:       assert_equal 1, parser.document.start_elements_namespace.length",
          "116:       el = parser.document.start_elements_namespace.first",
          "118:       assert_equal \"stream\", el.first",
          "119:       assert_equal 2, el[1].length",
          "120:       assert_equal [[\"version\", \"1.0\"], [\"size\", \"large\"]],",
          "121:         el[1].map { |x| [x.localname, x.value] }",
          "123:       assert_equal \"stream\", el[2]",
          "124:       assert_equal \"http://etherx.jabber.org/streams\", el[3]",
          "125:       parser.finish",
          "126:     end",
          "128:     it :test_end_element_ns do",
          "129:       parser.<<(<<~EOF)",
          "130:         <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>",
          "131:       EOF",
          "133:       assert_equal [[\"stream\", \"stream\", \"http://etherx.jabber.org/streams\"]],",
          "134:         parser.document.end_elements_namespace",
          "135:       parser.finish",
          "136:     end",
          "138:     it :test_chevron_partial_xml do",
          "139:       parser.<<(<<~EOF)",
          "140:         <p id=\"asdfasdf\">",
          "141:       EOF",
          "143:       parser.<<(<<~EOF)",
          "144:           <!-- This is a comment -->",
          "145:           Paragraph 1",
          "146:         </p>",
          "147:       EOF",
          "148:       assert_equal [\" This is a comment \"], parser.document.comments",
          "149:       parser.finish",
          "150:     end",
          "152:     it :test_chevron do",
          "153:       parser.<<(<<~EOF)",
          "154:         <p id=\"asdfasdf\">",
          "155:           <!-- This is a comment -->",
          "156:           Paragraph 1",
          "157:         </p>",
          "158:       EOF",
          "159:       parser.finish",
          "160:       assert_equal [\" This is a comment \"], parser.document.comments",
          "161:     end",
          "163:     it :test_default_options do",
          "164:       assert_equal 0, parser.options",
          "165:     end",
          "167:     it :test_recover do",
          "168:       parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "169:       parser.<<(<<~EOF)",
          "170:         <p>",
          "171:           Foo",
          "172:           <bar>",
          "173:           Bar",
          "174:         </p>",
          "175:       EOF",
          "176:       parser.finish",
          "177:       assert(parser.document.errors.size >= 1)",
          "178:       assert_equal [[\"p\", []], [\"bar\", []]], parser.document.start_elements",
          "179:       assert_equal \"FooBar\", parser.document.data.map { |x|",
          "180:         x.gsub(/\\s/, \"\")",
          "181:       }.join",
          "182:     end",
          "184:     it :test_broken_encoding do",
          "185:       skip_unless_libxml2(\"ultra hard to fix for pure Java version\")",
          "186:       parser.options |= Nokogiri::XML::ParseOptions::RECOVER",
          "187:       # This is ISO_8859-1:",
          "188:       parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"",
          "189:       parser.finish",
          "190:       assert(parser.document.errors.size >= 1)",
          "191:       assert_equal \"Gau\\337\", parser.document.data.join",
          "192:       assert_equal [[\"r\"]], parser.document.end_elements",
          "193:     end",
          "195:     it :test_replace_entities_attribute_behavior do",
          "196:       if Nokogiri.uses_libxml?",
          "197:         # initially false",
          "198:         assert_equal false, parser.replace_entities",
          "200:         # can be set to true",
          "201:         parser.replace_entities = true",
          "202:         assert_equal true, parser.replace_entities",
          "204:         # can be set to false",
          "205:         parser.replace_entities = false",
          "206:         assert_equal false, parser.replace_entities",
          "207:       else",
          "208:         # initially true",
          "209:         assert_equal true, parser.replace_entities",
          "211:         # ignore attempts to set to false",
          "212:         parser.replace_entities = false # TODO: should we raise an exception here?",
          "213:         assert_equal true, parser.replace_entities",
          "214:       end",
          "215:     end",
          "217:     it :test_untouched_entities do",
          "218:       skip_unless_libxml2(\"entities are always replaced in pure Java version\")",
          "219:       parser.<<(<<~EOF)",
          "220:         <p id=\"asdf&amp;asdf\">",
          "221:           <!-- This is a comment -->",
          "222:           Paragraph 1 &amp; 2",
          "223:         </p>",
          "224:       EOF",
          "225:       parser.finish",
          "226:       assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], parser.document.start_elements",
          "227:       assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip",
          "228:     end",
          "230:     it :test_replaced_entities do",
          "231:       parser.replace_entities = true",
          "232:       parser.<<(<<~EOF)",
          "233:         <p id=\"asdf&amp;asdf\">",
          "234:           <!-- This is a comment -->",
          "235:           Paragraph 1 &amp; 2",
          "236:         </p>",
          "237:       EOF",
          "238:       parser.finish",
          "239:       assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], parser.document.start_elements",
          "240:       assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "83cc451c3f29df397caa890afc3b714eae6ab8f7",
      "candidate_info": {
        "commit_hash": "83cc451c3f29df397caa890afc3b714eae6ab8f7",
        "repo": "sparklemotion/nokogiri",
        "commit_url": "https://github.com/sparklemotion/nokogiri/commit/83cc451c3f29df397caa890afc3b714eae6ab8f7",
        "files": [
          "ext/java/nokogiri/Html4SaxParserContext.java",
          "ext/java/nokogiri/XmlSaxParserContext.java",
          "ext/java/nokogiri/internals/ParserContext.java",
          "ext/nokogiri/html4_sax_parser_context.c",
          "ext/nokogiri/xml_sax_parser_context.c",
          "lib/nokogiri/html4/sax/parser.rb",
          "test/html4/sax/test_parser.rb",
          "test/html4/sax/test_parser_context.rb",
          "test/xml/sax/test_parser.rb",
          "test/xml/sax/test_parser_context.rb"
        ],
        "message": "fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types\n\nPreviously, arguments of the wrong type might cause segfault on CRuby.",
        "before_after_code_files": [
          "ext/java/nokogiri/Html4SaxParserContext.java||ext/java/nokogiri/Html4SaxParserContext.java",
          "ext/java/nokogiri/XmlSaxParserContext.java||ext/java/nokogiri/XmlSaxParserContext.java",
          "ext/java/nokogiri/internals/ParserContext.java||ext/java/nokogiri/internals/ParserContext.java",
          "ext/nokogiri/html4_sax_parser_context.c||ext/nokogiri/html4_sax_parser_context.c",
          "ext/nokogiri/xml_sax_parser_context.c||ext/nokogiri/xml_sax_parser_context.c",
          "lib/nokogiri/html4/sax/parser.rb||lib/nokogiri/html4/sax/parser.rb",
          "test/html4/sax/test_parser.rb||test/html4/sax/test_parser.rb",
          "test/html4/sax/test_parser_context.rb||test/html4/sax/test_parser_context.rb",
          "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb",
          "test/xml/sax/test_parser_context.rb||test/xml/sax/test_parser_context.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "ext/java/nokogiri/Html4SaxParserContext.java||ext/java/nokogiri/Html4SaxParserContext.java",
            "ext/java/nokogiri/XmlSaxParserContext.java||ext/java/nokogiri/XmlSaxParserContext.java",
            "ext/java/nokogiri/internals/ParserContext.java||ext/java/nokogiri/internals/ParserContext.java",
            "ext/nokogiri/html4_sax_parser_context.c||ext/nokogiri/html4_sax_parser_context.c",
            "ext/nokogiri/xml_sax_parser_context.c||ext/nokogiri/xml_sax_parser_context.c",
            "lib/nokogiri/html4/sax/parser.rb||lib/nokogiri/html4/sax/parser.rb",
            "test/html4/sax/test_parser.rb||test/html4/sax/test_parser.rb",
            "test/html4/sax/test_parser_context.rb||test/html4/sax/test_parser_context.rb",
            "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb",
            "test/xml/sax/test_parser_context.rb||test/xml/sax/test_parser_context.rb"
          ],
          "candidate": [
            "ext/java/nokogiri/Html4SaxParserContext.java||ext/java/nokogiri/Html4SaxParserContext.java",
            "ext/java/nokogiri/XmlSaxParserContext.java||ext/java/nokogiri/XmlSaxParserContext.java",
            "ext/java/nokogiri/internals/ParserContext.java||ext/java/nokogiri/internals/ParserContext.java",
            "ext/nokogiri/html4_sax_parser_context.c||ext/nokogiri/html4_sax_parser_context.c",
            "ext/nokogiri/xml_sax_parser_context.c||ext/nokogiri/xml_sax_parser_context.c",
            "lib/nokogiri/html4/sax/parser.rb||lib/nokogiri/html4/sax/parser.rb",
            "test/html4/sax/test_parser.rb||test/html4/sax/test_parser.rb",
            "test/html4/sax/test_parser_context.rb||test/html4/sax/test_parser_context.rb",
            "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb",
            "test/xml/sax/test_parser_context.rb||test/xml/sax/test_parser_context.rb"
          ]
        }
      },
      "candidate_diff": {
        "ext/java/nokogiri/Html4SaxParserContext.java||ext/java/nokogiri/Html4SaxParserContext.java": [
          "File: ext/java/nokogiri/Html4SaxParserContext.java -> ext/java/nokogiri/Html4SaxParserContext.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "231:              IRubyObject data,",
          "232:              IRubyObject encoding)",
          "233:   {",
          "234:     Html4SaxParserContext ctx = Html4SaxParserContext.newInstance(context.runtime, (RubyClass) klass);",
          "235:     ctx.setInputSourceFile(context, data);",
          "236:     String javaEncoding = findEncodingName(context, encoding);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "234:     if (!(data instanceof RubyString)) {",
          "235:       throw context.getRuntime().newTypeError(\"data must be kind_of String\");",
          "236:     }",
          "237:     if (!(encoding instanceof RubyString)) {",
          "238:       throw context.getRuntime().newTypeError(\"data must be kind_of String\");",
          "239:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:            IRubyObject data,",
          "248:            IRubyObject encoding)",
          "249:   {",
          "250:     Html4SaxParserContext ctx = Html4SaxParserContext.newInstance(context.runtime, (RubyClass) klass);",
          "251:     ctx.setIOInputSource(context, data, context.nil);",
          "252:     String javaEncoding = findEncodingName(context, encoding);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "257:     if (!(encoding instanceof RubyFixnum)) {",
          "258:       throw context.getRuntime().newTypeError(\"encoding must be kind_of String\");",
          "259:     }",
          "",
          "---------------"
        ],
        "ext/java/nokogiri/XmlSaxParserContext.java||ext/java/nokogiri/XmlSaxParserContext.java": [
          "File: ext/java/nokogiri/XmlSaxParserContext.java -> ext/java/nokogiri/XmlSaxParserContext.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:   parse_io(ThreadContext context,",
          "131:            IRubyObject klazz,",
          "132:            IRubyObject data,",
          "134:   {",
          "136:     final Ruby runtime = context.runtime;",
          "137:     XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);",
          "138:     ctx.initialize(runtime);",
          "",
          "[Removed Lines]",
          "133:            IRubyObject enc)",
          "",
          "[Added Lines]",
          "133:            IRubyObject encoding)",
          "136:     if (!(encoding instanceof RubyFixnum)) {",
          "137:       throw context.getRuntime().newTypeError(\"encoding must be kind_of String\");",
          "138:     }",
          "",
          "---------------"
        ],
        "ext/java/nokogiri/internals/ParserContext.java||ext/java/nokogiri/internals/ParserContext.java": [
          "File: ext/java/nokogiri/internals/ParserContext.java -> ext/java/nokogiri/internals/ParserContext.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:     source = new InputSource();",
          "59:     ParserContext.setUrl(context, source, url);",
          "61:     source.setByteStream(new IOInputStream(data));",
          "62:     if (java_encoding != null) {",
          "63:       source.setEncoding(java_encoding);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61:     Ruby ruby = context.getRuntime();",
          "63:     if (!(data.respondsTo(\"read\"))) {",
          "64:       throw ruby.newTypeError(\"must respond to :read\");",
          "65:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:     Ruby ruby = context.getRuntime();",
          "75:     if (!(data instanceof RubyString)) {",
          "77:     }",
          "79:     RubyString stringData = (RubyString) data;",
          "",
          "[Removed Lines]",
          "76:       throw ruby.newArgumentError(\"must be kind_of String\");",
          "",
          "[Added Lines]",
          "82:       throw ruby.newTypeError(\"must be kind_of String\");",
          "",
          "---------------"
        ],
        "ext/nokogiri/html4_sax_parser_context.c||ext/nokogiri/html4_sax_parser_context.c": [
          "File: ext/nokogiri/html4_sax_parser_context.c -> ext/nokogiri/html4_sax_parser_context.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: {",
          "20:   htmlParserCtxtPtr ctxt;",
          "25:   if (!(int)RSTRING_LEN(data)) {",
          "26:     rb_raise(rb_eRuntimeError, \"data cannot be empty\");",
          "27:   }",
          "",
          "[Removed Lines]",
          "22:   if (NIL_P(data)) {",
          "23:     rb_raise(rb_eArgError, \"data cannot be nil\");",
          "24:   }",
          "",
          "[Added Lines]",
          "22:   Check_Type(data, T_STRING);",
          "",
          "---------------"
        ],
        "ext/nokogiri/xml_sax_parser_context.c||ext/nokogiri/xml_sax_parser_context.c": [
          "File: ext/nokogiri/xml_sax_parser_context.c -> ext/nokogiri/xml_sax_parser_context.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: VALUE cNokogiriXmlSaxParserContext ;",
          "5: static void",
          "6: deallocate(xmlParserCtxtPtr ctxt)",
          "7: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: static ID id_read;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:   xmlParserCtxtPtr ctxt;",
          "27:   xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);",
          "29:   ctxt = xmlCreateIOParserCtxt(NULL, NULL,",
          "30:                                (xmlInputReadCallback)noko_io_read,",
          "31:                                (xmlInputCloseCallback)noko_io_close,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31:   if (!rb_respond_to(io, id_read)) {",
          "32:     rb_raise(rb_eTypeError, \"argument expected to respond to :read\");",
          "33:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "62: {",
          "63:   xmlParserCtxtPtr ctxt;",
          "68:   if (!(int)RSTRING_LEN(data)) {",
          "69:     rb_raise(rb_eRuntimeError, \"data cannot be empty\");",
          "70:   }",
          "",
          "[Removed Lines]",
          "65:   if (NIL_P(data)) {",
          "66:     rb_raise(rb_eArgError, \"data cannot be nil\");",
          "67:   }",
          "",
          "[Added Lines]",
          "71:   Check_Type(data, T_STRING);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "278:   rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);",
          "279:   rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);",
          "280:   rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);",
          "281: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "287:   id_read = rb_intern(\"read\");",
          "",
          "---------------"
        ],
        "lib/nokogiri/html4/sax/parser.rb||lib/nokogiri/html4/sax/parser.rb": [
          "File: lib/nokogiri/html4/sax/parser.rb -> lib/nokogiri/html4/sax/parser.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:         ###",
          "29:         # Parse html stored in +data+ using +encoding+",
          "30:         def parse_memory(data, encoding = \"UTF-8\")",
          "32:           return if data.empty?",
          "34:           ctx = ParserContext.memory(data, encoding)",
          "",
          "[Removed Lines]",
          "31:           raise ArgumentError unless data",
          "",
          "[Added Lines]",
          "31:           raise TypeError unless String === data",
          "",
          "---------------"
        ],
        "test/html4/sax/test_parser.rb||test/html4/sax/test_parser.rb": [
          "File: test/html4/sax/test_parser.rb -> test/html4/sax/test_parser.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:         end",
          "56:         def test_parse_memory_nil",
          "58:             @parser.parse_memory(nil)",
          "59:           end",
          "60:         end",
          "",
          "[Removed Lines]",
          "57:           assert_raises(ArgumentError) do",
          "",
          "[Added Lines]",
          "57:           assert_raises(TypeError) do",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "161:         def test_empty_processing_instruction",
          "162:           @parser.parse_memory(\"<strong>this will segfault<?strong>\")",
          "163:         end",
          "164:       end",
          "165:     end",
          "166:   end",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165:         it \"handles invalid types gracefully\" do",
          "166:           assert_raises(TypeError) { Nokogiri::HTML::SAX::Parser.new.parse(0xcafecafe) }",
          "167:           assert_raises(TypeError) { Nokogiri::HTML::SAX::Parser.new.parse_memory(0xcafecafe) }",
          "168:           assert_raises(TypeError) { Nokogiri::HTML::SAX::Parser.new.parse_io(0xcafecafe) }",
          "169:         end",
          "",
          "---------------"
        ],
        "test/html4/sax/test_parser_context.rb||test/html4/sax/test_parser_context.rb": [
          "File: test/html4/sax/test_parser_context.rb -> test/html4/sax/test_parser_context.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:           ctx.parse_with(parser)",
          "41:           # end",
          "42:         end",
          "43:       end",
          "44:     end",
          "45:   end",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44:         def test_graceful_handling_of_invalid_types",
          "45:           assert_raises(TypeError) { ParserContext.new(0xcafecafe) }",
          "46:           assert_raises(TypeError) { ParserContext.memory(0xcafecafe, \"UTF-8\") }",
          "47:           assert_raises(TypeError) { ParserContext.io(0xcafecafe, 1) }",
          "48:           assert_raises(TypeError) { ParserContext.io(StringIO.new(\"asdf\"), \"should be an index into ENCODINGS\") }",
          "49:           assert_raises(TypeError) { ParserContext.file(0xcafecafe, \"UTF-8\") }",
          "50:           assert_raises(TypeError) { ParserContext.file(\"path/to/file\", 0xcafecafe) }",
          "51:         end",
          "",
          "---------------"
        ],
        "test/xml/sax/test_parser.rb||test/xml/sax/test_parser.rb": [
          "File: test/xml/sax/test_parser.rb -> test/xml/sax/test_parser.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:       end",
          "72:     end",
          "74:     it :test_namespace_declaration_order_is_saved do",
          "75:       parser.parse(<<~EOF)",
          "76:         <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74:     it \"handles invalid types gracefully\" do",
          "75:       assert_raises(TypeError) { Nokogiri::XML::SAX::Parser.new.parse(0xcafecafe) }",
          "76:       assert_raises(TypeError) { Nokogiri::XML::SAX::Parser.new.parse_memory(0xcafecafe) }",
          "77:       assert_raises(TypeError) { Nokogiri::XML::SAX::Parser.new.parse_io(0xcafecafe) }",
          "78:     end",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "261:     end",
          "263:     it :test_render_parse_nil_param do",
          "265:     end",
          "267:     it :test_bad_encoding_args do",
          "",
          "[Removed Lines]",
          "264:       assert_raises(ArgumentError) { parser.parse_memory(nil) }",
          "",
          "[Added Lines]",
          "270:       assert_raises(TypeError) { parser.parse_memory(nil) }",
          "",
          "---------------"
        ],
        "test/xml/sax/test_parser_context.rb||test/xml/sax/test_parser_context.rb": [
          "File: test/xml/sax/test_parser_context.rb -> test/xml/sax/test_parser_context.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:           assert(pc.recovery)",
          "81:         end",
          "83:         def test_from_io",
          "84:           ctx = ParserContext.new(StringIO.new(\"fo\"), \"UTF-8\")",
          "85:           assert(ctx)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:         def test_graceful_handling_of_invalid_types",
          "84:           assert_raises(TypeError) { ParserContext.new(0xcafecafe) }",
          "85:           assert_raises(TypeError) { ParserContext.memory(0xcafecafe) }",
          "86:           assert_raises(TypeError) { ParserContext.io(0xcafecafe, 1) }",
          "87:           assert_raises(TypeError) { ParserContext.io(StringIO.new(\"asdf\"), \"should be an index into ENCODINGS\") }",
          "88:         end",
          "",
          "---------------"
        ]
      }
    }
  ]
}
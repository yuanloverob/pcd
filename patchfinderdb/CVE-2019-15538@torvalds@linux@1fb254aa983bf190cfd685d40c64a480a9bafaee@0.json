{
  "cve_id": "CVE-2019-15538",
  "cve_desc": "An issue was discovered in xfs_setattr_nonsize in fs/xfs/xfs_iops.c in the Linux kernel through 5.2.9. XFS partially wedges when a chgrp fails on account of being out of disk quota. xfs_setattr_nonsize is failing to unlock the ILOCK after the xfs_qm_vop_chown_reserve call fails. This is primarily a local DoS attack vector, but it might result as well in remote DoS if the XFS filesystem is exported for instance via NFS.",
  "repo": "torvalds/linux",
  "patch_hash": "1fb254aa983bf190cfd685d40c64a480a9bafaee",
  "patch_info": {
    "commit_hash": "1fb254aa983bf190cfd685d40c64a480a9bafaee",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee",
    "files": [
      "fs/xfs/xfs_iops.c"
    ],
    "message": "xfs: fix missing ILOCK unlock when xfs_setattr_nonsize fails due to EDQUOT\n\nBenjamin Moody reported to Debian that XFS partially wedges when a chgrp\nfails on account of being out of disk quota.  I ran his reproducer\nscript:\n\n# adduser dummy\n# adduser dummy plugdev\n\n# dd if=/dev/zero bs=1M count=100 of=test.img\n# mkfs.xfs test.img\n# mount -t xfs -o gquota test.img /mnt\n# mkdir -p /mnt/dummy\n# chown -c dummy /mnt/dummy\n# xfs_quota -xc 'limit -g bsoft=100k bhard=100k plugdev' /mnt\n\n(and then as user dummy)\n\n$ dd if=/dev/urandom bs=1M count=50 of=/mnt/dummy/foo\n$ chgrp plugdev /mnt/dummy/foo\n\nand saw:\n\n================================================\nWARNING: lock held when returning to user space!\n5.3.0-rc5 #rc5 Tainted: G        W\n------------------------------------------------\nchgrp/47006 is leaving the kernel with locks still held!\n1 lock held by chgrp/47006:\n #0: 000000006664ea2d (&xfs_nondir_ilock_class){++++}, at: xfs_ilock+0xd2/0x290 [xfs]\n\n...which is clearly caused by xfs_setattr_nonsize failing to unlock the\nILOCK after the xfs_qm_vop_chown_reserve call fails.  Add the missing\nunlock.\n\nReported-by: benjamin.moody@gmail.com\nFixes: 253f4911f297 (\"xfs: better xfs_trans_alloc interface\")\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>\nReviewed-by: Dave Chinner <dchinner@redhat.com>\nTested-by: Salvatore Bonaccorso <carnil@debian.org>",
    "before_after_code_files": [
      "fs/xfs/xfs_iops.c||fs/xfs/xfs_iops.c"
    ]
  },
  "patch_diff": {
    "fs/xfs/xfs_iops.c||fs/xfs/xfs_iops.c": [
      "File: fs/xfs/xfs_iops.c -> fs/xfs/xfs_iops.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "794: out_cancel:",
      "795:  xfs_trans_cancel(tp);",
      "796: out_dqrele:",
      "797:  xfs_qm_dqrele(udqp);",
      "798:  xfs_qm_dqrele(gdqp);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "796:  xfs_iunlock(ip, XFS_ILOCK_EXCL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2671828c3ff4ffadf777f793a1f3232d6e51394a",
      "candidate_info": {
        "commit_hash": "2671828c3ff4ffadf777f793a1f3232d6e51394a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2671828c3ff4ffadf777f793a1f3232d6e51394a",
        "files": [
          "arch/arm64/include/asm/exception.h",
          "arch/arm64/kernel/entry.S",
          "arch/arm64/kernel/traps.c"
        ],
        "message": "arm64: entry: Move ct_user_exit before any other exception\n\nWhen taking an SError or Debug exception from EL0, we run the C\nhandler for these exceptions before updating the context tracking\ncode and unmasking lower priority interrupts.\n\nWhen booting with nohz_full lockdep tells us we got this wrong:\n| =============================\n| WARNING: suspicious RCU usage\n| 5.3.0-rc2-00010-gb4b5e9dcb11b-dirty #11271 Not tainted\n| -----------------------------\n| include/linux/rcupdate.h:643 rcu_read_unlock() used illegally wh!\n|\n| other info that might help us debug this:\n|\n|\n| RCU used illegally from idle CPU!\n| rcu_scheduler_active = 2, debug_locks = 1\n| RCU used illegally from extended quiescent state!\n| 1 lock held by a.out/432:\n|  #0: 00000000c7a79515 (rcu_read_lock){....}, at: brk_handler+0x00\n|\n| stack backtrace:\n| CPU: 1 PID: 432 Comm: a.out Not tainted 5.3.0-rc2-00010-gb4b5e9d1\n| Hardware name: ARM LTD ARM Juno Development Platform/ARM Juno De8\n| Call trace:\n|  dump_backtrace+0x0/0x140\n|  show_stack+0x14/0x20\n|  dump_stack+0xbc/0x104\n|  lockdep_rcu_suspicious+0xf8/0x108\n|  brk_handler+0x164/0x1b0\n|  do_debug_exception+0x11c/0x278\n|  el0_dbg+0x14/0x20\n\nMoving the ct_user_exit calls to be before do_debug_exception() means\nthey are also before trace_hardirqs_off() has been updated. Add a new\nct_user_exit_irqoff macro to avoid the context-tracking code using\nirqsave/restore before we've updated trace_hardirqs_off(). To be\nconsistent, do this everywhere.\n\nThe C helper is called enter_from_user_mode() to match x86 in the hope\nwe can merge them into kernel/context_tracking.c later.\n\nCc: Masami Hiramatsu <mhiramat@kernel.org>\nFixes: 6c81fe7925cc4c42 (\"arm64: enable context tracking\")\nSigned-off-by: James Morse <james.morse@arm.com>\nSigned-off-by: Will Deacon <will@kernel.org>",
        "before_after_code_files": [
          "arch/arm64/include/asm/exception.h||arch/arm64/include/asm/exception.h",
          "arch/arm64/kernel/entry.S||arch/arm64/kernel/entry.S",
          "arch/arm64/kernel/traps.c||arch/arm64/kernel/traps.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm64/include/asm/exception.h||arch/arm64/include/asm/exception.h": [
          "File: arch/arm64/include/asm/exception.h -> arch/arm64/include/asm/exception.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:  return esr;",
          "31: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: asmlinkage void enter_from_user_mode(void);",
          "",
          "---------------"
        ],
        "arch/arm64/kernel/entry.S||arch/arm64/kernel/entry.S": [
          "File: arch/arm64/kernel/entry.S -> arch/arm64/kernel/entry.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #ifdef CONFIG_CONTEXT_TRACKING",
          "36: #endif",
          "37:  .endm",
          "",
          "[Removed Lines]",
          "33:  .macro ct_user_exit",
          "35:  bl context_tracking_user_exit",
          "",
          "[Added Lines]",
          "33:  .macro ct_user_exit_irqoff",
          "35:  bl enter_from_user_mode",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "795:  enable_daif",
          "797:  mov x0, x25",
          "798:  mov x1, sp",
          "799:  bl do_cp15instr",
          "",
          "[Removed Lines]",
          "796:  ct_user_exit",
          "",
          "[Added Lines]",
          "795:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "807:  mrs x26, far_el1",
          "808:  enable_daif",
          "810:  clear_address_tag x0, x26",
          "811:  mov x1, x25",
          "812:  mov x2, sp",
          "",
          "[Removed Lines]",
          "809:  ct_user_exit",
          "",
          "[Added Lines]",
          "808:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "819:  mrs x26, far_el1",
          "820:  gic_prio_kentry_setup tmp=x0",
          "821:  enable_da_f",
          "822: #ifdef CONFIG_TRACE_IRQFLAGS",
          "823:  bl trace_hardirqs_off",
          "824: #endif",
          "826:  mov x0, x26",
          "827:  mov x1, x25",
          "828:  mov x2, sp",
          "",
          "[Removed Lines]",
          "825:  ct_user_exit",
          "",
          "[Added Lines]",
          "821:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "835:  enable_daif",
          "837:  mov x0, x25",
          "838:  mov x1, sp",
          "839:  bl do_fpsimd_acc",
          "",
          "[Removed Lines]",
          "836:  ct_user_exit",
          "",
          "[Added Lines]",
          "835:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "845:  enable_daif",
          "847:  mov x0, x25",
          "848:  mov x1, sp",
          "849:  bl do_sve_acc",
          "",
          "[Removed Lines]",
          "846:  ct_user_exit",
          "",
          "[Added Lines]",
          "845:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "855:  enable_daif",
          "857:  mov x0, x25",
          "858:  mov x1, sp",
          "859:  bl do_fpsimd_exc",
          "",
          "[Removed Lines]",
          "856:  ct_user_exit",
          "",
          "[Added Lines]",
          "855:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "870:  gic_prio_kentry_setup tmp=x0",
          "871:  enable_da_f",
          "872: #ifdef CONFIG_TRACE_IRQFLAGS",
          "873:  bl trace_hardirqs_off",
          "874: #endif",
          "876:  mov x0, x26",
          "877:  mov x1, x25",
          "878:  mov x2, sp",
          "",
          "[Removed Lines]",
          "875:  ct_user_exit",
          "",
          "[Added Lines]",
          "871:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "885:  enable_daif",
          "887:  mov x0, sp",
          "888:  bl do_undefinstr",
          "889:  b ret_to_user",
          "",
          "[Removed Lines]",
          "886:  ct_user_exit",
          "",
          "[Added Lines]",
          "885:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "894:  enable_daif",
          "896:  mov x0, x25",
          "897:  mov x1, sp",
          "898:  bl do_sysinstr",
          "",
          "[Removed Lines]",
          "895:  ct_user_exit",
          "",
          "[Added Lines]",
          "894:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "904:  tbnz x24, #0, el0_inv  // EL0 only",
          "905:  gic_prio_kentry_setup tmp=x3",
          "907:  mov x1, x25",
          "908:  mov x2, sp",
          "909:  bl do_debug_exception",
          "910:  enable_da_f",
          "912:  b ret_to_user",
          "913: el0_inv:",
          "914:  enable_daif",
          "916:  mov x0, sp",
          "917:  mov x1, #BAD_SYNC",
          "918:  mov x2, x25",
          "",
          "[Removed Lines]",
          "906:  mrs x0, far_el1",
          "911:  ct_user_exit",
          "915:  ct_user_exit",
          "",
          "[Added Lines]",
          "905:  mrs x24, far_el1",
          "907:  ct_user_exit_irqoff",
          "908:  mov x0, x24",
          "915:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "925:  kernel_entry 0",
          "926: el0_irq_naked:",
          "927:  gic_prio_irq_setup pmr=x20, tmp=x0",
          "928:  enable_da_f",
          "930: #ifdef CONFIG_TRACE_IRQFLAGS",
          "931:  bl trace_hardirqs_off",
          "932: #endif",
          "935: #ifdef CONFIG_HARDEN_BRANCH_PREDICTOR",
          "936:  tbz x22, #55, 1f",
          "937:  bl do_el0_irq_bp_hardening",
          "",
          "[Removed Lines]",
          "934:  ct_user_exit",
          "",
          "[Added Lines]",
          "929:  ct_user_exit_irqoff",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "958: el0_error:",
          "959:  kernel_entry 0",
          "960: el0_error_naked:",
          "962:  gic_prio_kentry_setup tmp=x2",
          "963:  enable_dbg",
          "964:  mov x0, sp",
          "965:  bl do_serror",
          "966:  enable_da_f",
          "968:  b ret_to_user",
          "969: ENDPROC(el0_error)",
          "",
          "[Removed Lines]",
          "961:  mrs x1, esr_el1",
          "967:  ct_user_exit",
          "",
          "[Added Lines]",
          "962:  mrs x25, esr_el1",
          "964:  ct_user_exit_irqoff",
          "967:  mov x1, x25",
          "",
          "---------------"
        ],
        "arch/arm64/kernel/traps.c||arch/arm64/kernel/traps.c": [
          "File: arch/arm64/kernel/traps.c -> arch/arm64/kernel/traps.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include <linux/bug.h>",
          "10: #include <linux/signal.h>",
          "11: #include <linux/personality.h>",
          "12: #include <linux/kallsyms.h>",
          "13: #include <linux/spinlock.h>",
          "14: #include <linux/uaccess.h>",
          "15: #include <linux/hardirq.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <linux/context_tracking.h>",
          "14: #include <linux/kprobes.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "900:   nmi_exit();",
          "901: }",
          "903: void __pte_error(const char *file, int line, unsigned long val)",
          "904: {",
          "905:  pr_err(\"%s:%d: bad pte %016lx.\\n\", file, line, val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "905: asmlinkage void enter_from_user_mode(void)",
          "906: {",
          "907:  CT_WARN_ON(ct_state() != CONTEXT_USER);",
          "908:  user_exit_irqoff();",
          "909: }",
          "910: NOKPROBE_SYMBOL(enter_from_user_mode);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "86968ef21596515958d5f0a40233d02be78ecec0",
      "candidate_info": {
        "commit_hash": "86968ef21596515958d5f0a40233d02be78ecec0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/86968ef21596515958d5f0a40233d02be78ecec0",
        "files": [
          "fs/ceph/xattr.c"
        ],
        "message": "ceph: fix buffer free while holding i_ceph_lock in __ceph_setxattr()\n\nCalling ceph_buffer_put() in __ceph_setxattr() may end up freeing the\ni_xattrs.prealloc_blob buffer while holding the i_ceph_lock.  This can be\nfixed by postponing the call until later, when the lock is released.\n\nThe following backtrace was triggered by fstests generic/117.\n\n  BUG: sleeping function called from invalid context at mm/vmalloc.c:2283\n  in_atomic(): 1, irqs_disabled(): 0, pid: 650, name: fsstress\n  3 locks held by fsstress/650:\n   #0: 00000000870a0fe8 (sb_writers#8){.+.+}, at: mnt_want_write+0x20/0x50\n   #1: 00000000ba0c4c74 (&type->i_mutex_dir_key#6){++++}, at: vfs_setxattr+0x55/0xa0\n   #2: 000000008dfbb3f2 (&(&ci->i_ceph_lock)->rlock){+.+.}, at: __ceph_setxattr+0x297/0x810\n  CPU: 1 PID: 650 Comm: fsstress Not tainted 5.2.0+ #437\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58-prebuilt.qemu.org 04/01/2014\n  Call Trace:\n   dump_stack+0x67/0x90\n   ___might_sleep.cold+0x9f/0xb1\n   vfree+0x4b/0x60\n   ceph_buffer_release+0x1b/0x60\n   __ceph_setxattr+0x2b4/0x810\n   __vfs_setxattr+0x66/0x80\n   __vfs_setxattr_noperm+0x59/0xf0\n   vfs_setxattr+0x81/0xa0\n   setxattr+0x115/0x230\n   ? filename_lookup+0xc9/0x140\n   ? rcu_read_lock_sched_held+0x74/0x80\n   ? rcu_sync_lockdep_assert+0x2e/0x60\n   ? __sb_start_write+0x142/0x1a0\n   ? mnt_want_write+0x20/0x50\n   path_setxattr+0xba/0xd0\n   __x64_sys_lsetxattr+0x24/0x30\n   do_syscall_64+0x50/0x1c0\n   entry_SYSCALL_64_after_hwframe+0x49/0xbe\n  RIP: 0033:0x7ff23514359a\n\nSigned-off-by: Luis Henriques <lhenriques@suse.com>\nReviewed-by: Jeff Layton <jlayton@kernel.org>\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>",
        "before_after_code_files": [
          "fs/ceph/xattr.c||fs/ceph/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ceph/xattr.c||fs/ceph/xattr.c": [
          "File: fs/ceph/xattr.c -> fs/ceph/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1036:  struct ceph_inode_info *ci = ceph_inode(inode);",
          "1037:  struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;",
          "1038:  struct ceph_cap_flush *prealloc_cf = NULL;",
          "1039:  int issued;",
          "1040:  int err;",
          "1041:  int dirty = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1039:  struct ceph_buffer *old_blob = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1109:   struct ceph_buffer *blob;",
          "1111:   spin_unlock(&ci->i_ceph_lock);",
          "1113:   blob = ceph_buffer_new(required_blob_size, GFP_NOFS);",
          "1114:   if (!blob)",
          "1115:    goto do_sync_unlocked;",
          "1116:   spin_lock(&ci->i_ceph_lock);",
          "1117:   if (ci->i_xattrs.prealloc_blob)",
          "1119:   ci->i_xattrs.prealloc_blob = blob;",
          "1120:   goto retry;",
          "1121:  }",
          "",
          "[Removed Lines]",
          "1112:   dout(\" preaallocating new blob size=%d\\n\", required_blob_size);",
          "1118:    ceph_buffer_put(ci->i_xattrs.prealloc_blob);",
          "",
          "[Added Lines]",
          "1114:   dout(\" pre-allocating new blob size=%d\\n\", required_blob_size);",
          "1121:    old_blob = ci->i_xattrs.prealloc_blob;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1131:  }",
          "1133:  spin_unlock(&ci->i_ceph_lock);",
          "1134:  if (lock_snap_rwsem)",
          "1135:   up_read(&mdsc->snap_rwsem);",
          "1136:  if (dirty)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1137:  ceph_buffer_put(old_blob);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12fe3dda7ed89c95cc0ef7abc001ad1ad3e092f8",
      "candidate_info": {
        "commit_hash": "12fe3dda7ed89c95cc0ef7abc001ad1ad3e092f8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/12fe3dda7ed89c95cc0ef7abc001ad1ad3e092f8",
        "files": [
          "fs/ceph/caps.c",
          "fs/ceph/snap.c",
          "fs/ceph/super.h",
          "fs/ceph/xattr.c"
        ],
        "message": "ceph: fix buffer free while holding i_ceph_lock in __ceph_build_xattrs_blob()\n\nCalling ceph_buffer_put() in __ceph_build_xattrs_blob() may result in\nfreeing the i_xattrs.blob buffer while holding the i_ceph_lock.  This can\nbe fixed by having this function returning the old blob buffer and have\nthe callers of this function freeing it when the lock is released.\n\nThe following backtrace was triggered by fstests generic/117.\n\n  BUG: sleeping function called from invalid context at mm/vmalloc.c:2283\n  in_atomic(): 1, irqs_disabled(): 0, pid: 649, name: fsstress\n  4 locks held by fsstress/649:\n   #0: 00000000a7478e7e (&type->s_umount_key#19){++++}, at: iterate_supers+0x77/0xf0\n   #1: 00000000f8de1423 (&(&ci->i_ceph_lock)->rlock){+.+.}, at: ceph_check_caps+0x7b/0xc60\n   #2: 00000000562f2b27 (&s->s_mutex){+.+.}, at: ceph_check_caps+0x3bd/0xc60\n   #3: 00000000f83ce16a (&mdsc->snap_rwsem){++++}, at: ceph_check_caps+0x3ed/0xc60\n  CPU: 1 PID: 649 Comm: fsstress Not tainted 5.2.0+ #439\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58-prebuilt.qemu.org 04/01/2014\n  Call Trace:\n   dump_stack+0x67/0x90\n   ___might_sleep.cold+0x9f/0xb1\n   vfree+0x4b/0x60\n   ceph_buffer_release+0x1b/0x60\n   __ceph_build_xattrs_blob+0x12b/0x170\n   __send_cap+0x302/0x540\n   ? __lock_acquire+0x23c/0x1e40\n   ? __mark_caps_flushing+0x15c/0x280\n   ? _raw_spin_unlock+0x24/0x30\n   ceph_check_caps+0x5f0/0xc60\n   ceph_flush_dirty_caps+0x7c/0x150\n   ? __ia32_sys_fdatasync+0x20/0x20\n   ceph_sync_fs+0x5a/0x130\n   iterate_supers+0x8f/0xf0\n   ksys_sync+0x4f/0xb0\n   __ia32_sys_sync+0xa/0x10\n   do_syscall_64+0x50/0x1c0\n   entry_SYSCALL_64_after_hwframe+0x49/0xbe\n  RIP: 0033:0x7fc6409ab617\n\nSigned-off-by: Luis Henriques <lhenriques@suse.com>\nReviewed-by: Jeff Layton <jlayton@kernel.org>\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>",
        "before_after_code_files": [
          "fs/ceph/caps.c||fs/ceph/caps.c",
          "fs/ceph/snap.c||fs/ceph/snap.c",
          "fs/ceph/super.h||fs/ceph/super.h",
          "fs/ceph/xattr.c||fs/ceph/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ceph/caps.c||fs/ceph/caps.c": [
          "File: fs/ceph/caps.c -> fs/ceph/caps.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1301: {",
          "1302:  struct ceph_inode_info *ci = cap->ci;",
          "1303:  struct inode *inode = &ci->vfs_inode;",
          "1304:  struct cap_msg_args arg;",
          "1305:  int held, revoking;",
          "1306:  int wake = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1304:  struct ceph_buffer *old_blob = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1365:  ci->i_requested_max_size = arg.max_size;",
          "1367:  if (flushing & CEPH_CAP_XATTR_EXCL) {",
          "1369:   arg.xattr_version = ci->i_xattrs.version;",
          "1370:   arg.xattr_buf = ci->i_xattrs.blob;",
          "1371:  } else {",
          "",
          "[Removed Lines]",
          "1368:   __ceph_build_xattrs_blob(ci);",
          "",
          "[Added Lines]",
          "1369:   old_blob = __ceph_build_xattrs_blob(ci);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1410:  spin_unlock(&ci->i_ceph_lock);",
          "1412:  ret = send_cap_msg(&arg);",
          "1413:  if (ret < 0) {",
          "1414:   dout(\"error sending cap msg, must requeue %p\\n\", inode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1413:  ceph_buffer_put(old_blob);",
          "",
          "---------------"
        ],
        "fs/ceph/snap.c||fs/ceph/snap.c": [
          "File: fs/ceph/snap.c -> fs/ceph/snap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "465:  struct inode *inode = &ci->vfs_inode;",
          "466:  struct ceph_cap_snap *capsnap;",
          "467:  struct ceph_snap_context *old_snapc, *new_snapc;",
          "468:  int used, dirty;",
          "470:  capsnap = kzalloc(sizeof(*capsnap), GFP_NOFS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "468:  struct ceph_buffer *old_blob = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "541:  capsnap->gid = inode->i_gid;",
          "543:  if (dirty & CEPH_CAP_XATTR_EXCL) {",
          "545:   capsnap->xattr_blob =",
          "546:    ceph_buffer_get(ci->i_xattrs.blob);",
          "547:   capsnap->xattr_version = ci->i_xattrs.version;",
          "",
          "[Removed Lines]",
          "544:   __ceph_build_xattrs_blob(ci);",
          "",
          "[Added Lines]",
          "545:   old_blob = __ceph_build_xattrs_blob(ci);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "584:  }",
          "585:  spin_unlock(&ci->i_ceph_lock);",
          "587:  kfree(capsnap);",
          "588:  ceph_put_snap_context(old_snapc);",
          "589: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "588:  ceph_buffer_put(old_blob);",
          "",
          "---------------"
        ],
        "fs/ceph/super.h||fs/ceph/super.h": [
          "File: fs/ceph/super.h -> fs/ceph/super.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "926: int __ceph_setxattr(struct inode *, const char *, const void *, size_t, int);",
          "927: ssize_t __ceph_getxattr(struct inode *, const char *, void *, size_t);",
          "928: extern ssize_t ceph_listxattr(struct dentry *, char *, size_t);",
          "930: extern void __ceph_destroy_xattrs(struct ceph_inode_info *ci);",
          "931: extern const struct xattr_handler *ceph_xattr_handlers[];",
          "",
          "[Removed Lines]",
          "929: extern void __ceph_build_xattrs_blob(struct ceph_inode_info *ci);",
          "",
          "[Added Lines]",
          "929: extern struct ceph_buffer *__ceph_build_xattrs_blob(struct ceph_inode_info *ci);",
          "",
          "---------------"
        ],
        "fs/ceph/xattr.c||fs/ceph/xattr.c": [
          "File: fs/ceph/xattr.c -> fs/ceph/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "760: {",
          "761:  struct rb_node *p;",
          "762:  struct ceph_inode_xattr *xattr = NULL;",
          "763:  void *dest;",
          "765:  dout(\"__build_xattrs_blob %p\\n\", &ci->vfs_inode);",
          "",
          "[Removed Lines]",
          "759: void __ceph_build_xattrs_blob(struct ceph_inode_info *ci)",
          "",
          "[Added Lines]",
          "761: struct ceph_buffer *__ceph_build_xattrs_blob(struct ceph_inode_info *ci)",
          "765:  struct ceph_buffer *old_blob = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "790:    dest - ci->i_xattrs.prealloc_blob->vec.iov_base;",
          "792:   if (ci->i_xattrs.blob)",
          "794:   ci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;",
          "795:   ci->i_xattrs.prealloc_blob = NULL;",
          "796:   ci->i_xattrs.dirty = false;",
          "797:   ci->i_xattrs.version++;",
          "798:  }",
          "799: }",
          "801: static inline int __get_request_mask(struct inode *in) {",
          "",
          "[Removed Lines]",
          "793:    ceph_buffer_put(ci->i_xattrs.blob);",
          "",
          "[Added Lines]",
          "796:    old_blob = ci->i_xattrs.blob;",
          "803:  return old_blob;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cecf5d87ff2035127bb5a9ee054d0023a4a7cad3",
      "candidate_info": {
        "commit_hash": "cecf5d87ff2035127bb5a9ee054d0023a4a7cad3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cecf5d87ff2035127bb5a9ee054d0023a4a7cad3",
        "files": [
          "block/blk-core.c",
          "block/blk-mq-sysfs.c",
          "block/blk-sysfs.c",
          "block/blk.h",
          "block/elevator.c",
          "include/linux/blkdev.h"
        ],
        "message": "block: split .sysfs_lock into two locks\n\nThe kernfs built-in lock of 'kn->count' is held in sysfs .show/.store\npath. Meantime, inside block's .show/.store callback, q->sysfs_lock is\nrequired.\n\nHowever, when mq & iosched kobjects are removed via\nblk_mq_unregister_dev() & elv_unregister_queue(), q->sysfs_lock is held\ntoo. This way causes AB-BA lock because the kernfs built-in lock of\n'kn-count' is required inside kobject_del() too, see the lockdep warning[1].\n\nOn the other hand, it isn't necessary to acquire q->sysfs_lock for\nboth blk_mq_unregister_dev() & elv_unregister_queue() because\nclearing REGISTERED flag prevents storing to 'queue/scheduler'\nfrom being happened. Also sysfs write(store) is exclusive, so no\nnecessary to hold the lock for elv_unregister_queue() when it is\ncalled in switching elevator path.\n\nSo split .sysfs_lock into two: one is still named as .sysfs_lock for\ncovering sync .store, the other one is named as .sysfs_dir_lock\nfor covering kobjects and related status change.\n\nsysfs itself can handle the race between add/remove kobjects and\nshowing/storing attributes under kobjects. For switching scheduler\nvia storing to 'queue/scheduler', we use the queue flag of\nQUEUE_FLAG_REGISTERED with .sysfs_lock for avoiding the race, then\nwe can avoid to hold .sysfs_lock during removing/adding kobjects.\n\n[1]  lockdep warning\n    ======================================================\n    WARNING: possible circular locking dependency detected\n    5.3.0-rc3-00044-g73277fc75ea0 #1380 Not tainted\n    ------------------------------------------------------\n    rmmod/777 is trying to acquire lock:\n    00000000ac50e981 (kn->count#202){++++}, at: kernfs_remove_by_name_ns+0x59/0x72\n\n    but task is already holding lock:\n    00000000fb16ae21 (&q->sysfs_lock){+.+.}, at: blk_unregister_queue+0x78/0x10b\n\n    which lock already depends on the new lock.\n\n    the existing dependency chain (in reverse order) is:\n\n    -> #1 (&q->sysfs_lock){+.+.}:\n           __lock_acquire+0x95f/0xa2f\n           lock_acquire+0x1b4/0x1e8\n           __mutex_lock+0x14a/0xa9b\n           blk_mq_hw_sysfs_show+0x63/0xb6\n           sysfs_kf_seq_show+0x11f/0x196\n           seq_read+0x2cd/0x5f2\n           vfs_read+0xc7/0x18c\n           ksys_read+0xc4/0x13e\n           do_syscall_64+0xa7/0x295\n           entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\n    -> #0 (kn->count#202){++++}:\n           check_prev_add+0x5d2/0xc45\n           validate_chain+0xed3/0xf94\n           __lock_acquire+0x95f/0xa2f\n           lock_acquire+0x1b4/0x1e8\n           __kernfs_remove+0x237/0x40b\n           kernfs_remove_by_name_ns+0x59/0x72\n           remove_files+0x61/0x96\n           sysfs_remove_group+0x81/0xa4\n           sysfs_remove_groups+0x3b/0x44\n           kobject_del+0x44/0x94\n           blk_mq_unregister_dev+0x83/0xdd\n           blk_unregister_queue+0xa0/0x10b\n           del_gendisk+0x259/0x3fa\n           null_del_dev+0x8b/0x1c3 [null_blk]\n           null_exit+0x5c/0x95 [null_blk]\n           __se_sys_delete_module+0x204/0x337\n           do_syscall_64+0xa7/0x295\n           entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\n    other info that might help us debug this:\n\n     Possible unsafe locking scenario:\n\n           CPU0                    CPU1\n           ----                    ----\n      lock(&q->sysfs_lock);\n                                   lock(kn->count#202);\n                                   lock(&q->sysfs_lock);\n      lock(kn->count#202);\n\n     *** DEADLOCK ***\n\n    2 locks held by rmmod/777:\n     #0: 00000000e69bd9de (&lock){+.+.}, at: null_exit+0x2e/0x95 [null_blk]\n     #1: 00000000fb16ae21 (&q->sysfs_lock){+.+.}, at: blk_unregister_queue+0x78/0x10b\n\n    stack backtrace:\n    CPU: 0 PID: 777 Comm: rmmod Not tainted 5.3.0-rc3-00044-g73277fc75ea0 #1380\n    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS ?-20180724_192412-buildhw-07.phx4\n    Call Trace:\n     dump_stack+0x9a/0xe6\n     check_noncircular+0x207/0x251\n     ? print_circular_bug+0x32a/0x32a\n     ? find_usage_backwards+0x84/0xb0\n     check_prev_add+0x5d2/0xc45\n     validate_chain+0xed3/0xf94\n     ? check_prev_add+0xc45/0xc45\n     ? mark_lock+0x11b/0x804\n     ? check_usage_forwards+0x1ca/0x1ca\n     __lock_acquire+0x95f/0xa2f\n     lock_acquire+0x1b4/0x1e8\n     ? kernfs_remove_by_name_ns+0x59/0x72\n     __kernfs_remove+0x237/0x40b\n     ? kernfs_remove_by_name_ns+0x59/0x72\n     ? kernfs_next_descendant_post+0x7d/0x7d\n     ? strlen+0x10/0x23\n     ? strcmp+0x22/0x44\n     kernfs_remove_by_name_ns+0x59/0x72\n     remove_files+0x61/0x96\n     sysfs_remove_group+0x81/0xa4\n     sysfs_remove_groups+0x3b/0x44\n     kobject_del+0x44/0x94\n     blk_mq_unregister_dev+0x83/0xdd\n     blk_unregister_queue+0xa0/0x10b\n     del_gendisk+0x259/0x3fa\n     ? disk_events_poll_msecs_store+0x12b/0x12b\n     ? check_flags+0x1ea/0x204\n     ? mark_held_locks+0x1f/0x7a\n     null_del_dev+0x8b/0x1c3 [null_blk]\n     null_exit+0x5c/0x95 [null_blk]\n     __se_sys_delete_module+0x204/0x337\n     ? free_module+0x39f/0x39f\n     ? blkcg_maybe_throttle_current+0x8a/0x718\n     ? rwlock_bug+0x62/0x62\n     ? __blkcg_punt_bio_submit+0xd0/0xd0\n     ? trace_hardirqs_on_thunk+0x1a/0x20\n     ? mark_held_locks+0x1f/0x7a\n     ? do_syscall_64+0x4c/0x295\n     do_syscall_64+0xa7/0x295\n     entry_SYSCALL_64_after_hwframe+0x49/0xbe\n    RIP: 0033:0x7fb696cdbe6b\n    Code: 73 01 c3 48 8b 0d 1d 20 0c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 008\n    RSP: 002b:00007ffec9588788 EFLAGS: 00000206 ORIG_RAX: 00000000000000b0\n    RAX: ffffffffffffffda RBX: 0000559e589137c0 RCX: 00007fb696cdbe6b\n    RDX: 000000000000000a RSI: 0000000000000800 RDI: 0000559e58913828\n    RBP: 0000000000000000 R08: 00007ffec9587701 R09: 0000000000000000\n    R10: 00007fb696d4eae0 R11: 0000000000000206 R12: 00007ffec95889b0\n    R13: 00007ffec95896b3 R14: 0000559e58913260 R15: 0000559e589137c0\n\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Hannes Reinecke <hare@suse.com>\nCc: Greg KH <gregkh@linuxfoundation.org>\nCc: Mike Snitzer <snitzer@redhat.com>\nReviewed-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Ming Lei <ming.lei@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "block/blk-core.c||block/blk-core.c",
          "block/blk-mq-sysfs.c||block/blk-mq-sysfs.c",
          "block/blk-sysfs.c||block/blk-sysfs.c",
          "block/blk.h||block/blk.h",
          "block/elevator.c||block/elevator.c",
          "include/linux/blkdev.h||include/linux/blkdev.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "block/blk-core.c||block/blk-core.c": [
          "File: block/blk-core.c -> block/blk-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "520:  mutex_init(&q->blk_trace_mutex);",
          "521: #endif",
          "522:  mutex_init(&q->sysfs_lock);",
          "523:  spin_lock_init(&q->queue_lock);",
          "525:  init_waitqueue_head(&q->mq_freeze_wq);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "523:  mutex_init(&q->sysfs_dir_lock);",
          "",
          "---------------"
        ],
        "block/blk-mq-sysfs.c||block/blk-mq-sysfs.c": [
          "File: block/blk-mq-sysfs.c -> block/blk-mq-sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "270:  struct blk_mq_hw_ctx *hctx;",
          "271:  int i;",
          "275:  queue_for_each_hw_ctx(q, hctx, i)",
          "276:   blk_mq_unregister_hctx(hctx);",
          "",
          "[Removed Lines]",
          "273:  lockdep_assert_held(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "273:  lockdep_assert_held(&q->sysfs_dir_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "320:  int ret, i;",
          "322:  WARN_ON_ONCE(!q->kobj.parent);",
          "325:  ret = kobject_add(q->mq_kobj, kobject_get(&dev->kobj), \"%s\", \"mq\");",
          "326:  if (ret < 0)",
          "",
          "[Removed Lines]",
          "323:  lockdep_assert_held(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "323:  lockdep_assert_held(&q->sysfs_dir_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "354:  struct blk_mq_hw_ctx *hctx;",
          "355:  int i;",
          "358:  if (!q->mq_sysfs_init_done)",
          "359:   goto unlock;",
          "",
          "[Removed Lines]",
          "357:  mutex_lock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "357:  mutex_lock(&q->sysfs_dir_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "362:   blk_mq_unregister_hctx(hctx);",
          "364: unlock:",
          "366: }",
          "368: int blk_mq_sysfs_register(struct request_queue *q)",
          "",
          "[Removed Lines]",
          "365:  mutex_unlock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "365:  mutex_unlock(&q->sysfs_dir_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "370:  struct blk_mq_hw_ctx *hctx;",
          "371:  int i, ret = 0;",
          "374:  if (!q->mq_sysfs_init_done)",
          "375:   goto unlock;",
          "",
          "[Removed Lines]",
          "373:  mutex_lock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "373:  mutex_lock(&q->sysfs_dir_lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "381:  }",
          "383: unlock:",
          "386:  return ret;",
          "387: }",
          "",
          "[Removed Lines]",
          "384:  mutex_unlock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "384:  mutex_unlock(&q->sysfs_dir_lock);",
          "",
          "---------------"
        ],
        "block/blk-sysfs.c||block/blk-sysfs.c": [
          "File: block/blk-sysfs.c -> block/blk-sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "938:  int ret;",
          "939:  struct device *dev = disk_to_dev(disk);",
          "940:  struct request_queue *q = disk->queue;",
          "942:  if (WARN_ON(!q))",
          "943:   return -ENXIO;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "941:  bool has_elevator = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "945:  WARN_ONCE(blk_queue_registered(q),",
          "946:     \"%s is registering an already registered queue\\n\",",
          "947:     kobject_name(&dev->kobj));",
          "",
          "[Removed Lines]",
          "948:  blk_queue_flag_set(QUEUE_FLAG_REGISTERED, q);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "965:  if (ret)",
          "966:   return ret;",
          "971:  ret = kobject_add(&q->kobj, kobject_get(&dev->kobj), \"%s\", \"queue\");",
          "972:  if (ret < 0) {",
          "",
          "[Removed Lines]",
          "969:  mutex_lock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "968:  mutex_lock(&q->sysfs_dir_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "987:   blk_mq_debugfs_register(q);",
          "988:  }",
          "996:  if (q->elevator) {",
          "998:   if (ret) {",
          "1001:    kobject_del(&q->kobj);",
          "1002:    blk_trace_remove_sysfs(dev);",
          "1003:    kobject_put(&dev->kobj);",
          "1004:    return ret;",
          "1005:   }",
          "1006:  }",
          "1007:  ret = 0;",
          "1008: unlock:",
          "1010:  return ret;",
          "1011: }",
          "1012: EXPORT_SYMBOL_GPL(blk_register_queue);",
          "",
          "[Removed Lines]",
          "990:  kobject_uevent(&q->kobj, KOBJ_ADD);",
          "992:  wbt_enable_default(q);",
          "994:  blk_throtl_register_queue(q);",
          "997:   ret = elv_register_queue(q);",
          "999:    mutex_unlock(&q->sysfs_lock);",
          "1000:    kobject_uevent(&q->kobj, KOBJ_REMOVE);",
          "1009:  mutex_unlock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "994:   ret = elv_register_queue(q, false);",
          "996:    mutex_unlock(&q->sysfs_dir_lock);",
          "1002:   has_elevator = true;",
          "1005:  mutex_lock(&q->sysfs_lock);",
          "1006:  blk_queue_flag_set(QUEUE_FLAG_REGISTERED, q);",
          "1007:  wbt_enable_default(q);",
          "1008:  blk_throtl_register_queue(q);",
          "1011:  kobject_uevent(&q->kobj, KOBJ_ADD);",
          "1012:  if (has_elevator)",
          "1013:   kobject_uevent(&q->elevator->kobj, KOBJ_ADD);",
          "1014:  mutex_unlock(&q->sysfs_lock);",
          "1018:  mutex_unlock(&q->sysfs_dir_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1021: void blk_unregister_queue(struct gendisk *disk)",
          "1022: {",
          "1023:  struct request_queue *q = disk->queue;",
          "1025:  if (WARN_ON(!q))",
          "1026:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1033:  bool has_elevator;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1037:  mutex_lock(&q->sysfs_lock);",
          "1039:  blk_queue_flag_clear(QUEUE_FLAG_REGISTERED, q);",
          "1045:  if (queue_is_mq(q))",
          "1046:   blk_mq_unregister_dev(disk_to_dev(disk), q);",
          "1049:  kobject_uevent(&q->kobj, KOBJ_REMOVE);",
          "1050:  kobject_del(&q->kobj);",
          "1051:  blk_trace_remove_sysfs(disk_to_dev(disk));",
          "1055:   elv_unregister_queue(q);",
          "1058:  kobject_put(&disk_to_dev(disk)->kobj);",
          "1059: }",
          "",
          "[Removed Lines]",
          "1047:  mutex_unlock(&q->sysfs_lock);",
          "1053:  mutex_lock(&q->sysfs_lock);",
          "1054:  if (q->elevator)",
          "1056:  mutex_unlock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "1049:  has_elevator = !!q->elevator;",
          "1050:  mutex_unlock(&q->sysfs_lock);",
          "1052:  mutex_lock(&q->sysfs_dir_lock);",
          "1064:  if (has_elevator)",
          "1066:  mutex_unlock(&q->sysfs_dir_lock);",
          "",
          "---------------"
        ],
        "block/blk.h||block/blk.h": [
          "File: block/blk.h -> block/blk.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: int elevator_switch_mq(struct request_queue *q,",
          "189:          struct elevator_type *new_e);",
          "190: void __elevator_exit(struct request_queue *, struct elevator_queue *);",
          "192: void elv_unregister_queue(struct request_queue *q);",
          "194: static inline void elevator_exit(struct request_queue *q,",
          "",
          "[Removed Lines]",
          "191: int elv_register_queue(struct request_queue *q);",
          "",
          "[Added Lines]",
          "191: int elv_register_queue(struct request_queue *q, bool uevent);",
          "",
          "---------------"
        ],
        "block/elevator.c||block/elevator.c": [
          "File: block/elevator.c -> block/elevator.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "470:  .release = elevator_release,",
          "471: };",
          "474: {",
          "475:  struct elevator_queue *e = q->elevator;",
          "476:  int error;",
          "480:  error = kobject_add(&e->kobj, &q->kobj, \"%s\", \"iosched\");",
          "481:  if (!error) {",
          "482:   struct elv_fs_entry *attr = e->type->elevator_attrs;",
          "",
          "[Removed Lines]",
          "473: int elv_register_queue(struct request_queue *q)",
          "478:  lockdep_assert_held(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "478: int elv_register_queue(struct request_queue *q, bool uevent)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "487:     attr++;",
          "488:    }",
          "489:   }",
          "491:   e->registered = 1;",
          "492:  }",
          "493:  return error;",
          "494: }",
          "496: void elv_unregister_queue(struct request_queue *q)",
          "497: {",
          "500:  if (q) {",
          "501:   struct elevator_queue *e = q->elevator;",
          "503:   kobject_uevent(&e->kobj, KOBJ_REMOVE);",
          "504:   kobject_del(&e->kobj);",
          "505:   e->registered = 0;",
          "507:   wbt_enable_default(q);",
          "508:  }",
          "509: }",
          "",
          "[Removed Lines]",
          "490:   kobject_uevent(&e->kobj, KOBJ_ADD);",
          "498:  lockdep_assert_held(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "493:   if (uevent)",
          "494:    kobject_uevent(&e->kobj, KOBJ_ADD);",
          "496:   mutex_lock(&q->sysfs_lock);",
          "498:   mutex_unlock(&q->sysfs_lock);",
          "516:   mutex_lock(&q->sysfs_lock);",
          "520:   mutex_unlock(&q->sysfs_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "567:  lockdep_assert_held(&q->sysfs_lock);",
          "569:  if (q->elevator) {",
          "571:    elv_unregister_queue(q);",
          "572:   ioc_clear_queue(q);",
          "573:   elevator_exit(q, q->elevator);",
          "574:  }",
          "576:  ret = blk_mq_init_sched(q, new_e);",
          "",
          "[Removed Lines]",
          "570:   if (q->elevator->registered)",
          "",
          "[Added Lines]",
          "583:   if (q->elevator->registered) {",
          "584:    mutex_unlock(&q->sysfs_lock);",
          "597:    mutex_lock(&q->sysfs_lock);",
          "598:   }",
          "607:   if (!blk_queue_registered(q))",
          "608:    return 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "578:   goto out;",
          "580:  if (new_e) {",
          "582:   if (ret) {",
          "583:    elevator_exit(q, q->elevator);",
          "584:    goto out;",
          "",
          "[Removed Lines]",
          "581:   ret = elv_register_queue(q);",
          "",
          "[Added Lines]",
          "616:   mutex_unlock(&q->sysfs_lock);",
          "618:   ret = elv_register_queue(q, true);",
          "620:   mutex_lock(&q->sysfs_lock);",
          "",
          "---------------"
        ],
        "include/linux/blkdev.h||include/linux/blkdev.h": [
          "File: include/linux/blkdev.h -> include/linux/blkdev.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "535:  struct delayed_work requeue_work;",
          "537:  struct mutex  sysfs_lock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "538:  struct mutex  sysfs_dir_lock;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "77715906921251bd9f75bcf4825f176df3f91208",
      "candidate_info": {
        "commit_hash": "77715906921251bd9f75bcf4825f176df3f91208",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/77715906921251bd9f75bcf4825f176df3f91208",
        "files": [
          "drivers/gpu/drm/i915/gem/i915_gem_throttle.c",
          "drivers/gpu/drm/i915/i915_drv.c",
          "drivers/gpu/drm/i915/i915_drv.h",
          "drivers/gpu/drm/i915/i915_request.c"
        ],
        "message": "drm/i915: Keep drm_i915_file_private around under RCU\n\nEnsure that the drm_i915_file_private continues to exist as we attempt\nto remove a request from its list, which may race with the destruction\nof the file.\n\n<6> [38.380714] [IGT] gem_ctx_create: starting subtest basic-files\n<0> [42.201329] BUG: spinlock bad magic on CPU#0, kworker/u16:0/7\n<4> [42.201356] general protection fault: 0000 [#1] PREEMPT SMP PTI\n<4> [42.201371] CPU: 0 PID: 7 Comm: kworker/u16:0 Tainted: G     U            5.3.0-rc5-CI-Patchwork_14169+ #1\n<4> [42.201391] Hardware name: Dell Inc.                 OptiPlex 745                 /0GW726, BIOS 2.3.1  05/21/2007\n<4> [42.201594] Workqueue: i915 retire_work_handler [i915]\n<4> [42.201614] RIP: 0010:spin_dump+0x5a/0x90\n<4> [42.201625] Code: 00 48 8d 88 c0 06 00 00 48 c7 c7 00 71 09 82 e8 35 ef 00 00 48 85 db 44 8b 4d 08 41 b8 ff ff ff ff 48 c7 c1 0b cd 0f 82 74 0e <44> 8b 83 e0 04 00 00 48 8d 8b c0 06 00 00 8b 55 04 48 89 ee 48 c7\n<4> [42.201660] RSP: 0018:ffffc9000004bd80 EFLAGS: 00010202\n<4> [42.201673] RAX: 0000000000000031 RBX: 6b6b6b6b6b6b6b6b RCX: ffffffff820fcd0b\n<4> [42.201688] RDX: 0000000000000000 RSI: ffff88803de266f8 RDI: 00000000ffffffff\n<4> [42.201703] RBP: ffff888038381ff8 R08: 00000000ffffffff R09: 000000006b6b6b6b\n<4> [42.201718] R10: 0000000041cb0b89 R11: 646162206b636f6c R12: ffff88802a618500\n<4> [42.201733] R13: ffff88802b32c288 R14: ffff888038381ff8 R15: ffff88802b32c250\n<4> [42.201748] FS:  0000000000000000(0000) GS:ffff88803de00000(0000) knlGS:0000000000000000\n<4> [42.201765] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4> [42.201778] CR2: 00007f2cefc6d180 CR3: 00000000381ee000 CR4: 00000000000006f0\n<4> [42.201793] Call Trace:\n<4> [42.201805]  do_raw_spin_lock+0x66/0xb0\n<4> [42.201898]  i915_request_retire+0x548/0x7c0 [i915]\n<4> [42.201989]  retire_requests+0x4d/0x60 [i915]\n<4> [42.202078]  i915_retire_requests+0x144/0x2e0 [i915]\n<4> [42.202169]  retire_work_handler+0x10/0x40 [i915]\n\nRecently, in commit 44c22f3f1a0a (\"drm/i915: Serialize insertion into the\nfile->mm.request_list\"), we fixed a race on insertion. Now, it appears\nwe also have a race with destruction!\n\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Matthew Auld <matthew.auld@intel.com>\nReviewed-by: Matthew Auld <matthew.auld@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20190823181455.31910-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/gem/i915_gem_throttle.c||drivers/gpu/drm/i915/gem/i915_gem_throttle.c",
          "drivers/gpu/drm/i915/i915_drv.c||drivers/gpu/drm/i915/i915_drv.c",
          "drivers/gpu/drm/i915/i915_drv.h||drivers/gpu/drm/i915/i915_drv.h",
          "drivers/gpu/drm/i915/i915_request.c||drivers/gpu/drm/i915/i915_request.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/gem/i915_gem_throttle.c||drivers/gpu/drm/i915/gem/i915_gem_throttle.c": [
          "File: drivers/gpu/drm/i915/gem/i915_gem_throttle.c -> drivers/gpu/drm/i915/gem/i915_gem_throttle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:   if (time_after_eq(request->emitted_jiffies, recent_enough))",
          "51:    break;",
          "54:    list_del(&target->client_link);",
          "58:   target = request;",
          "59:  }",
          "",
          "[Removed Lines]",
          "53:   if (target) {",
          "55:    target->file_priv = NULL;",
          "56:   }",
          "",
          "[Added Lines]",
          "53:   if (target && xchg(&target->file_priv, NULL))",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/i915_drv.c||drivers/gpu/drm/i915/i915_drv.c": [
          "File: drivers/gpu/drm/i915/i915_drv.c -> drivers/gpu/drm/i915/i915_drv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1730:  i915_gem_release(dev, file);",
          "1731:  mutex_unlock(&dev->struct_mutex);",
          "1736:  i915_gem_flush_free_objects(to_i915(dev));",
          "",
          "[Removed Lines]",
          "1733:  kfree(file_priv);",
          "",
          "[Added Lines]",
          "1733:  kfree_rcu(file_priv, rcu);",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/i915_drv.h||drivers/gpu/drm/i915/i915_drv.h": [
          "File: drivers/gpu/drm/i915/i915_drv.h -> drivers/gpu/drm/i915/i915_drv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "186: struct drm_i915_file_private {",
          "187:  struct drm_i915_private *dev_priv;",
          "190:  struct {",
          "191:   spinlock_t lock;",
          "",
          "[Removed Lines]",
          "188:  struct drm_file *file;",
          "",
          "[Added Lines]",
          "189:  union {",
          "190:   struct drm_file *file;",
          "191:   struct rcu_head rcu;",
          "192:  };",
          "",
          "---------------"
        ],
        "drivers/gpu/drm/i915/i915_request.c||drivers/gpu/drm/i915/i915_request.c": [
          "File: drivers/gpu/drm/i915/i915_request.c -> drivers/gpu/drm/i915/i915_request.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169: {",
          "170:  struct drm_i915_file_private *file_priv;",
          "174:   return;",
          "178:   list_del(&request->client_link);",
          "180:  }",
          "182: }",
          "184: static void free_capture_list(struct i915_request *request)",
          "",
          "[Removed Lines]",
          "172:  file_priv = READ_ONCE(request->file_priv);",
          "173:  if (!file_priv)",
          "176:  spin_lock(&file_priv->mm.lock);",
          "177:  if (request->file_priv) {",
          "179:   request->file_priv = NULL;",
          "181:  spin_unlock(&file_priv->mm.lock);",
          "",
          "[Added Lines]",
          "172:  if (!READ_ONCE(request->file_priv))",
          "175:  rcu_read_lock();",
          "176:  file_priv = xchg(&request->file_priv, NULL);",
          "177:  if (file_priv) {",
          "178:   spin_lock(&file_priv->mm.lock);",
          "180:   spin_unlock(&file_priv->mm.lock);",
          "182:  rcu_read_unlock();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
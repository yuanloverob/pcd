{
  "cve_id": "CVE-2018-7492",
  "cve_desc": "A NULL pointer dereference was found in the net/rds/rdma.c __rds_rdma_map() function in the Linux kernel before 4.14.7 allowing local attackers to cause a system panic and a denial-of-service, related to RDS_GET_MR and RDS_GET_MR_FOR_DEST.",
  "repo": "torvalds/linux",
  "patch_hash": "f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
  "patch_info": {
    "commit_hash": "f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
    "files": [
      "net/rds/rdma.c"
    ],
    "message": "rds: Fix NULL pointer dereference in __rds_rdma_map\n\nThis is a fix for syzkaller719569, where memory registration was\nattempted without any underlying transport being loaded.\n\nAnalysis of the case reveals that it is the setsockopt() RDS_GET_MR\n(2) and RDS_GET_MR_FOR_DEST (7) that are vulnerable.\n\nHere is an example stack trace when the bug is hit:\n\nBUG: unable to handle kernel NULL pointer dereference at 00000000000000c0\nIP: __rds_rdma_map+0x36/0x440 [rds]\nPGD 2f93d03067 P4D 2f93d03067 PUD 2f93d02067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: bridge stp llc tun rpcsec_gss_krb5 nfsv4\ndns_resolver nfs fscache rds binfmt_misc sb_edac intel_powerclamp\ncoretemp kvm_intel kvm irqbypass crct10dif_pclmul c rc32_pclmul\nghash_clmulni_intel pcbc aesni_intel crypto_simd glue_helper cryptd\niTCO_wdt mei_me sg iTCO_vendor_support ipmi_si mei ipmi_devintf nfsd\nshpchp pcspkr i2c_i801 ioatd ma ipmi_msghandler wmi lpc_ich mfd_core\nauth_rpcgss nfs_acl lockd grace sunrpc ip_tables ext4 mbcache jbd2\nmgag200 i2c_algo_bit drm_kms_helper ixgbe syscopyarea ahci sysfillrect\nsysimgblt libahci mdio fb_sys_fops ttm ptp libata sd_mod mlx4_core drm\ncrc32c_intel pps_core megaraid_sas i2c_core dca dm_mirror\ndm_region_hash dm_log dm_mod\nCPU: 48 PID: 45787 Comm: repro_set2 Not tainted 4.14.2-3.el7uek.x86_64 #2\nHardware name: Oracle Corporation ORACLE SERVER X5-2L/ASM,MOBO TRAY,2U, BIOS 31110000 03/03/2017\ntask: ffff882f9190db00 task.stack: ffffc9002b994000\nRIP: 0010:__rds_rdma_map+0x36/0x440 [rds]\nRSP: 0018:ffffc9002b997df0 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: ffff882fa2182580 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffffc9002b997e40 RDI: ffff882fa2182580\nRBP: ffffc9002b997e30 R08: 0000000000000000 R09: 0000000000000002\nR10: ffff885fb29e3838 R11: 0000000000000000 R12: ffff882fa2182580\nR13: ffff882fa2182580 R14: 0000000000000002 R15: 0000000020000ffc\nFS:  00007fbffa20b700(0000) GS:ffff882fbfb80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000000000c0 CR3: 0000002f98a66006 CR4: 00000000001606e0\nCall Trace:\n rds_get_mr+0x56/0x80 [rds]\n rds_setsockopt+0x172/0x340 [rds]\n ? __fget_light+0x25/0x60\n ? __fdget+0x13/0x20\n SyS_setsockopt+0x80/0xe0\n do_syscall_64+0x67/0x1b0\n entry_SYSCALL64_slow_path+0x25/0x25\nRIP: 0033:0x7fbff9b117f9\nRSP: 002b:00007fbffa20aed8 EFLAGS: 00000293 ORIG_RAX: 0000000000000036\nRAX: ffffffffffffffda RBX: 00000000000c84a4 RCX: 00007fbff9b117f9\nRDX: 0000000000000002 RSI: 0000400000000114 RDI: 000000000000109b\nRBP: 00007fbffa20af10 R08: 0000000000000020 R09: 00007fbff9dd7860\nR10: 0000000020000ffc R11: 0000000000000293 R12: 0000000000000000\nR13: 00007fbffa20b9c0 R14: 00007fbffa20b700 R15: 0000000000000021\n\nCode: 41 56 41 55 49 89 fd 41 54 53 48 83 ec 18 8b 87 f0 02 00 00 48\n89 55 d0 48 89 4d c8 85 c0 0f 84 2d 03 00 00 48 8b 87 00 03 00 00 <48>\n83 b8 c0 00 00 00 00 0f 84 25 03 00 0 0 48 8b 06 48 8b 56 08\n\nThe fix is to check the existence of an underlying transport in\n__rds_rdma_map().\n\nSigned-off-by: H\u00e5kon Bugge <haakon.bugge@oracle.com>\nReported-by: syzbot <syzkaller@googlegroups.com>\nAcked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/rds/rdma.c||net/rds/rdma.c"
    ]
  },
  "patch_diff": {
    "net/rds/rdma.c||net/rds/rdma.c": [
      "File: net/rds/rdma.c -> net/rds/rdma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "183:  long i;",
      "184:  int ret;",
      "188:   goto out;",
      "189:  }",
      "",
      "[Removed Lines]",
      "186:  if (rs->rs_bound_addr == 0) {",
      "",
      "[Added Lines]",
      "186:  if (rs->rs_bound_addr == 0 || !rs->rs_transport) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "510353a63796d467b41237ab4f136136f68c297d",
      "candidate_info": {
        "commit_hash": "510353a63796d467b41237ab4f136136f68c297d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/510353a63796d467b41237ab4f136136f68c297d",
        "files": [
          "drivers/gpu/drm/bridge/analogix/analogix_dp_core.c"
        ],
        "message": "drm/bridge: analogix dp: Fix runtime PM state in get_modes() callback\n\nget_modes() callback might be called asynchronously from the DRM core and\nit is not synchronized with bridge_enable(), which sets proper runtime PM\nstate of the main DP device. Fix this by calling pm_runtime_get_sync()\nbefore calling drm_get_edid(), which in turn calls drm_dp_i2c_xfer() and\nanalogix_dp_transfer() to ensure that main DP device is runtime active\nwhen doing any access to its registers.\n\nThis fixes the following kernel issue on Samsung Exynos5250 Snow board:\nUnhandled fault: imprecise external abort (0x406) at 0x00000000\npgd = c0004000\n[00000000] *pgd=00000000\nInternal error: : 406 [#1] PREEMPT SMP ARM\nModules linked in:\nCPU: 0 PID: 62 Comm: kworker/0:2 Not tainted 4.13.0-rc2-00364-g4a97a3da420b #3357\nHardware name: SAMSUNG EXYNOS (Flattened Device Tree)\nWorkqueue: events output_poll_execute\ntask: edc14800 task.stack: edcb2000\nPC is at analogix_dp_transfer+0x15c/0x2fc\nLR is at analogix_dp_transfer+0x134/0x2fc\npc : [<c0468538>]    lr : [<c0468510>]    psr: 60000013\nsp : edcb3be8  ip : 0000002a  fp : 00000001\nr10: 00000000  r9 : edcb3cd8  r8 : edcb3c40\nr7 : 00000000  r6 : edd3b380  r5 : edd3b010  r4 : 00000064\nr3 : 00000000  r2 : f0ad3000  r1 : edcb3c40  r0 : edd3b010\nFlags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\nControl: 10c5387d  Table: 4000406a  DAC: 00000051\nProcess kworker/0:2 (pid: 62, stack limit = 0xedcb2210)\nStack: (0xedcb3be8 to 0xedcb4000)\n[<c0468538>] (analogix_dp_transfer) from [<c0424ba4>] (drm_dp_i2c_do_msg+0x8c/0x2b4)\n[<c0424ba4>] (drm_dp_i2c_do_msg) from [<c0424e64>] (drm_dp_i2c_xfer+0x98/0x214)\n[<c0424e64>] (drm_dp_i2c_xfer) from [<c057b2d8>] (__i2c_transfer+0x140/0x29c)\n[<c057b2d8>] (__i2c_transfer) from [<c057b4a4>] (i2c_transfer+0x70/0xe4)\n[<c057b4a4>] (i2c_transfer) from [<c0441de4>] (drm_do_probe_ddc_edid+0xb4/0x114)\n[<c0441de4>] (drm_do_probe_ddc_edid) from [<c0441e5c>] (drm_probe_ddc+0x18/0x28)\n[<c0441e5c>] (drm_probe_ddc) from [<c0445728>] (drm_get_edid+0x124/0x2d4)\n[<c0445728>] (drm_get_edid) from [<c0465ea0>] (analogix_dp_get_modes+0x90/0x114)\n[<c0465ea0>] (analogix_dp_get_modes) from [<c0425e8c>] (drm_helper_probe_single_connector_modes+0x198/0x68c)\n[<c0425e8c>] (drm_helper_probe_single_connector_modes) from [<c04325d4>] (drm_setup_crtcs+0x1b4/0xd18)\n[<c04325d4>] (drm_setup_crtcs) from [<c04344a8>] (drm_fb_helper_hotplug_event+0x94/0xd0)\n[<c04344a8>] (drm_fb_helper_hotplug_event) from [<c0425a50>] (drm_kms_helper_hotplug_event+0x24/0x28)\n[<c0425a50>] (drm_kms_helper_hotplug_event) from [<c04263ec>] (output_poll_execute+0x6c/0x174)\n[<c04263ec>] (output_poll_execute) from [<c0136f18>] (process_one_work+0x188/0x3fc)\n[<c0136f18>] (process_one_work) from [<c01371f4>] (worker_thread+0x30/0x4b8)\n[<c01371f4>] (worker_thread) from [<c013daf8>] (kthread+0x128/0x164)\n[<c013daf8>] (kthread) from [<c0108510>] (ret_from_fork+0x14/0x24)\nCode: 0a000002 ea000009 e2544001 0a00004a (e59537c8)\n---[ end trace cddc7919c79f7878 ]---\n\nReported-by: Misha Komarovskiy <zombah@gmail.com>\nCC: stable@vger.kernel.org # v4.10+\nSigned-off-by: Marek Szyprowski <m.szyprowski@samsung.com>\n\nSigned-off-by: Archit Taneja <architt@codeaurora.org>\nLink: https://patchwork.freedesktop.org/patch/msgid/20171121074936.22520-1-m.szyprowski@samsung.com",
        "before_after_code_files": [
          "drivers/gpu/drm/bridge/analogix/analogix_dp_core.c||drivers/gpu/drm/bridge/analogix/analogix_dp_core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/bridge/analogix/analogix_dp_core.c||drivers/gpu/drm/bridge/analogix/analogix_dp_core.c": [
          "File: drivers/gpu/drm/bridge/analogix/analogix_dp_core.c -> drivers/gpu/drm/bridge/analogix/analogix_dp_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "946:    return 0;",
          "947:   }",
          "949:   edid = drm_get_edid(connector, &dp->aux.ddc);",
          "950:   if (edid) {",
          "951:    drm_mode_connector_update_edid_property(&dp->connector,",
          "952:         edid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "949:   pm_runtime_get_sync(dp->dev);",
          "951:   pm_runtime_put(dp->dev);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef78970ace74bb606e641a1f27ea36547716a775",
      "candidate_info": {
        "commit_hash": "ef78970ace74bb606e641a1f27ea36547716a775",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ef78970ace74bb606e641a1f27ea36547716a775",
        "files": [
          "drivers/gpu/drm/i915/i915_gem.c"
        ],
        "message": "drm/i915: Call i915_gem_init_userptr() before taking struct_mutex\n\nWe don't need struct_mutex to initialise userptr (it just allocates a\nworkqueue for itself etc), but we do need struct_mutex later on in\ni915_gem_init() in order to feed requests onto the HW.\n\nThis should break the chain\n\n[  385.697902] ======================================================\n[  385.697907] WARNING: possible circular locking dependency detected\n[  385.697913] 4.14.0-CI-Patchwork_7234+ #1 Tainted: G     U\n[  385.697917] ------------------------------------------------------\n[  385.697922] perf_pmu/2631 is trying to acquire lock:\n[  385.697927]  (&mm->mmap_sem){++++}, at: [<ffffffff811bfe1e>] __might_fault+0x3e/0x90\n[  385.697941]\n               but task is already holding lock:\n[  385.697946]  (&cpuctx_mutex){+.+.}, at: [<ffffffff8116fe8c>] perf_event_ctx_lock_nested+0xbc/0x1d0\n[  385.697957]\n               which lock already depends on the new lock.\n\n[  385.697963]\n               the existing dependency chain (in reverse order) is:\n[  385.697970]\n               -> #4 (&cpuctx_mutex){+.+.}:\n[  385.697980]        __mutex_lock+0x86/0x9b0\n[  385.697985]        perf_event_init_cpu+0x5a/0x90\n[  385.697991]        perf_event_init+0x178/0x1a4\n[  385.697997]        start_kernel+0x27f/0x3f1\n[  385.698003]        verify_cpu+0x0/0xfb\n[  385.698006]\n               -> #3 (pmus_lock){+.+.}:\n[  385.698015]        __mutex_lock+0x86/0x9b0\n[  385.698020]        perf_event_init_cpu+0x21/0x90\n[  385.698025]        cpuhp_invoke_callback+0xca/0xc00\n[  385.698030]        _cpu_up+0xa7/0x170\n[  385.698035]        do_cpu_up+0x57/0x70\n[  385.698039]        smp_init+0x62/0xa6\n[  385.698044]        kernel_init_freeable+0x97/0x193\n[  385.698050]        kernel_init+0xa/0x100\n[  385.698055]        ret_from_fork+0x27/0x40\n[  385.698058]\n               -> #2 (cpu_hotplug_lock.rw_sem){++++}:\n[  385.698068]        cpus_read_lock+0x39/0xa0\n[  385.698073]        apply_workqueue_attrs+0x12/0x50\n[  385.698078]        __alloc_workqueue_key+0x1d8/0x4d8\n[  385.698134]        i915_gem_init_userptr+0x5f/0x80 [i915]\n[  385.698176]        i915_gem_init+0x7c/0x390 [i915]\n[  385.698213]        i915_driver_load+0x99e/0x15c0 [i915]\n[  385.698250]        i915_pci_probe+0x33/0x90 [i915]\n[  385.698256]        pci_device_probe+0xa1/0x130\n[  385.698262]        driver_probe_device+0x293/0x440\n[  385.698267]        __driver_attach+0xde/0xe0\n[  385.698272]        bus_for_each_dev+0x5c/0x90\n[  385.698277]        bus_add_driver+0x16d/0x260\n[  385.698282]        driver_register+0x57/0xc0\n[  385.698287]        do_one_initcall+0x3e/0x160\n[  385.698292]        do_init_module+0x5b/0x1fa\n[  385.698297]        load_module+0x2374/0x2dc0\n[  385.698302]        SyS_finit_module+0xaa/0xe0\n[  385.698307]        entry_SYSCALL_64_fastpath+0x1c/0xb1\n[  385.698311]\n               -> #1 (&dev->struct_mutex){+.+.}:\n[  385.698320]        __mutex_lock+0x86/0x9b0\n[  385.698361]        i915_mutex_lock_interruptible+0x4c/0x130 [i915]\n[  385.698403]        i915_gem_fault+0x206/0x760 [i915]\n[  385.698409]        __do_fault+0x1a/0x70\n[  385.698413]        __handle_mm_fault+0x7c4/0xdb0\n[  385.698417]        handle_mm_fault+0x154/0x300\n[  385.698440]        __do_page_fault+0x2d6/0x570\n[  385.698445]        page_fault+0x22/0x30\n[  385.698449]\n               -> #0 (&mm->mmap_sem){++++}:\n[  385.698459]        lock_acquire+0xaf/0x200\n[  385.698464]        __might_fault+0x68/0x90\n[  385.698470]        _copy_to_user+0x1e/0x70\n[  385.698475]        perf_read+0x1aa/0x290\n[  385.698480]        __vfs_read+0x23/0x120\n[  385.698484]        vfs_read+0xa3/0x150\n[  385.698488]        SyS_read+0x45/0xb0\n[  385.698493]        entry_SYSCALL_64_fastpath+0x1c/0xb1\n[  385.698497]\n               other info that might help us debug this:\n\n[  385.698505] Chain exists of:\n                 &mm->mmap_sem --> pmus_lock --> &cpuctx_mutex\n\n[  385.698517]  Possible unsafe locking scenario:\n\n[  385.698522]        CPU0                    CPU1\n[  385.698526]        ----                    ----\n[  385.698529]   lock(&cpuctx_mutex);\n[  385.698553]                                lock(pmus_lock);\n[  385.698558]                                lock(&cpuctx_mutex);\n[  385.698564]   lock(&mm->mmap_sem);\n[  385.698568]\n                *** DEADLOCK ***\n\n[  385.698574] 1 lock held by perf_pmu/2631:\n[  385.698578]  #0:  (&cpuctx_mutex){+.+.}, at: [<ffffffff8116fe8c>] perf_event_ctx_lock_nested+0xbc/0x1d0\n[  385.698589]\n               stack backtrace:\n[  385.698595] CPU: 3 PID: 2631 Comm: perf_pmu Tainted: G     U          4.14.0-CI-Patchwork_7234+ #1\n[  385.698602] Hardware name:                  /NUC6CAYB, BIOS AYAPLCEL.86A.0040.2017.0619.1722 06/19/2017\n[  385.698609] Call Trace:\n[  385.698615]  dump_stack+0x5f/0x86\n[  385.698621]  print_circular_bug.isra.18+0x1d0/0x2c0\n[  385.698627]  __lock_acquire+0x19c3/0x1b60\n[  385.698634]  ? generic_exec_single+0x77/0xe0\n[  385.698640]  ? lock_acquire+0xaf/0x200\n[  385.698644]  lock_acquire+0xaf/0x200\n[  385.698650]  ? __might_fault+0x3e/0x90\n[  385.698655]  __might_fault+0x68/0x90\n[  385.698660]  ? __might_fault+0x3e/0x90\n[  385.698665]  _copy_to_user+0x1e/0x70\n[  385.698670]  perf_read+0x1aa/0x290\n[  385.698675]  __vfs_read+0x23/0x120\n[  385.698682]  ? __fget+0x101/0x1f0\n[  385.698686]  vfs_read+0xa3/0x150\n[  385.698691]  SyS_read+0x45/0xb0\n[  385.698696]  entry_SYSCALL_64_fastpath+0x1c/0xb1\n[  385.698701] RIP: 0033:0x7ff1c46876ed\n[  385.698705] RSP: 002b:00007fff13552f90 EFLAGS: 00000293 ORIG_RAX: 0000000000000000\n[  385.698712] RAX: ffffffffffffffda RBX: ffffc90000647ff0 RCX: 00007ff1c46876ed\n[  385.698718] RDX: 0000000000000010 RSI: 00007fff13552fa0 RDI: 0000000000000005\n[  385.698723] RBP: 000056063d300580 R08: 0000000000000000 R09: 0000000000000060\n[  385.698729] R10: 0000000000000000 R11: 0000000000000293 R12: 0000000000000046\n[  385.698734] R13: 00007fff13552c6f R14: 00007ff1c6279d00 R15: 00007ff1c6279a40\n\nTestcase: igt/perf_pmu\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20171122172621.16158-1-chris@chris-wilson.co.uk\nReviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\n(cherry picked from commit ee48700dd57d9ce783ec40f035b324d0b75632e4)\nSigned-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/i915_gem.c||drivers/gpu/drm/i915/i915_gem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/i915_gem.c||drivers/gpu/drm/i915/i915_gem.c": [
          "File: drivers/gpu/drm/i915/i915_gem.c -> drivers/gpu/drm/i915/i915_gem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4948: {",
          "4949:  int ret;",
          "",
          "[Removed Lines]",
          "4951:  mutex_lock(&dev_priv->drm.struct_mutex);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4969:   dev_priv->gt.cleanup_engine = intel_logical_ring_cleanup;",
          "4970:  }",
          "4978:  intel_uncore_forcewake_get(dev_priv, FORCEWAKE_ALL);",
          "4984:  ret = i915_gem_init_ggtt(dev_priv);",
          "4985:  if (ret)",
          "4986:   goto out_unlock;",
          "",
          "[Removed Lines]",
          "4980:  ret = i915_gem_init_userptr(dev_priv);",
          "4981:  if (ret)",
          "4982:   goto out_unlock;",
          "",
          "[Added Lines]",
          "4970:  ret = i915_gem_init_userptr(dev_priv);",
          "4971:  if (ret)",
          "4972:   return ret;",
          "4980:  mutex_lock(&dev_priv->drm.struct_mutex);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a6a0445d1edb28fc89fd12b49cda2d5114e2665",
      "candidate_info": {
        "commit_hash": "5a6a0445d1edb28fc89fd12b49cda2d5114e2665",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5a6a0445d1edb28fc89fd12b49cda2d5114e2665",
        "files": [
          "drivers/net/ethernet/stmicro/stmmac/stmmac_main.c"
        ],
        "message": "net: stmmac: fix broken dma_interrupt handling for multi-queues\n\nThere is nothing that says that number of TX queues == number of RX\nqueues. E.g. the ARTPEC-6 SoC has 2 TX queues and 1 RX queue.\n\nThis code is obviously wrong:\nfor (chan = 0; chan < tx_channel_count; chan++) {\n    struct stmmac_rx_queue *rx_q = &priv->rx_queue[chan];\n\npriv->rx_queue has size MTL_MAX_RX_QUEUES, so this will send an\nuninitialized napi_struct to __napi_schedule(), causing us to\ncrash in net_rx_action(), because napi_struct->poll is zero.\n\n[12846.759880] Unable to handle kernel NULL pointer dereference at virtual address 00000000\n[12846.768014] pgd = (ptrval)\n[12846.770742] [00000000] *pgd=39ec7831, *pte=00000000, *ppte=00000000\n[12846.777023] Internal error: Oops: 80000007 [#1] PREEMPT SMP ARM\n[12846.782942] Modules linked in:\n[12846.785998] CPU: 0 PID: 161 Comm: dropbear Not tainted 4.15.0-rc2-00285-gf5fb5f2f39a7 #36\n[12846.794177] Hardware name: Axis ARTPEC-6 Platform\n[12846.798879] task: (ptrval) task.stack: (ptrval)\n[12846.803407] PC is at 0x0\n[12846.805942] LR is at net_rx_action+0x274/0x43c\n[12846.810383] pc : [<00000000>]    lr : [<80bff064>]    psr: 200e0113\n[12846.816648] sp : b90d9ae8  ip : b90d9ae8  fp : b90d9b44\n[12846.821871] r10: 00000008  r9 : 0013250e  r8 : 00000100\n[12846.827094] r7 : 0000012c  r6 : 00000000  r5 : 00000001  r4 : bac84900\n[12846.833619] r3 : 00000000  r2 : b90d9b08  r1 : 00000000  r0 : bac84900\n\nSince each DMA channel can be used for rx and tx simultaneously,\nthe current code should probably be rewritten so that napi_struct is\nembedded in a new struct stmmac_channel.\nThat way, stmmac_poll() can call stmmac_tx_clean() on just the tx queue\nwhere we got the IRQ, instead of looping through all tx queues.\nThis is also how the xgbe driver does it (another driver for this IP).\n\nFixes: c22a3f48ef99 (\"net: stmmac: adding multiple napi mechanism\")\nSigned-off-by: Niklas Cassel <niklas.cassel@axis.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/stmicro/stmmac/stmmac_main.c||drivers/net/ethernet/stmicro/stmmac/stmmac_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/stmicro/stmmac/stmmac_main.c||drivers/net/ethernet/stmicro/stmmac/stmmac_main.c": [
          "File: drivers/net/ethernet/stmicro/stmmac/stmmac_main.c -> drivers/net/ethernet/stmicro/stmmac/stmmac_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1997: static void stmmac_dma_interrupt(struct stmmac_priv *priv)",
          "1998: {",
          "1999:  u32 tx_channel_count = priv->plat->tx_queues_to_use;",
          "2001:  u32 chan;",
          "2009:    if (likely(napi_schedule_prep(&rx_q->napi))) {",
          "2010:     stmmac_disable_dma_irq(priv, chan);",
          "2011:     __napi_schedule(&rx_q->napi);",
          "2012:    }",
          "2013:   }",
          "2017:    if (unlikely(priv->xstats.threshold != SF_DMA_MODE) &&",
          "2018:        (tc <= 256)) {",
          "",
          "[Removed Lines]",
          "2000:  int status;",
          "2003:  for (chan = 0; chan < tx_channel_count; chan++) {",
          "2004:   struct stmmac_rx_queue *rx_q = &priv->rx_queue[chan];",
          "2006:   status = priv->hw->dma->dma_interrupt(priv->ioaddr,",
          "2007:             &priv->xstats, chan);",
          "2008:   if (likely((status & handle_rx)) || (status & handle_tx)) {",
          "2015:   if (unlikely(status & tx_hard_error_bump_tc)) {",
          "",
          "[Added Lines]",
          "2000:  u32 rx_channel_count = priv->plat->rx_queues_to_use;",
          "2001:  u32 channels_to_check = tx_channel_count > rx_channel_count ?",
          "2002:     tx_channel_count : rx_channel_count;",
          "2004:  bool poll_scheduled = false;",
          "2005:  int status[channels_to_check];",
          "2013:  for (chan = 0; chan < channels_to_check; chan++)",
          "2014:   status[chan] = priv->hw->dma->dma_interrupt(priv->ioaddr,",
          "2015:            &priv->xstats,",
          "2016:            chan);",
          "2018:  for (chan = 0; chan < rx_channel_count; chan++) {",
          "2019:   if (likely(status[chan] & handle_rx)) {",
          "2020:    struct stmmac_rx_queue *rx_q = &priv->rx_queue[chan];",
          "2025:     poll_scheduled = true;",
          "2026:    }",
          "2027:   }",
          "2028:  }",
          "2034:  if (!poll_scheduled) {",
          "2035:   for (chan = 0; chan < tx_channel_count; chan++) {",
          "2036:    if (status[chan] & handle_tx) {",
          "2040:     struct stmmac_rx_queue *rx_q =",
          "2041:      &priv->rx_queue[0];",
          "2043:     if (likely(napi_schedule_prep(&rx_q->napi))) {",
          "2044:      stmmac_disable_dma_irq(priv, chan);",
          "2045:      __napi_schedule(&rx_q->napi);",
          "2046:     }",
          "2047:     break;",
          "2050:  }",
          "2052:  for (chan = 0; chan < tx_channel_count; chan++) {",
          "2053:   if (unlikely(status[chan] & tx_hard_error_bump_tc)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2029:             chan);",
          "2030:     priv->xstats.threshold = tc;",
          "2031:    }",
          "2033:    stmmac_tx_err(priv, chan);",
          "2034:   }",
          "2035:  }",
          "",
          "[Removed Lines]",
          "2032:   } else if (unlikely(status == tx_hard_error)) {",
          "",
          "[Added Lines]",
          "2070:   } else if (unlikely(status[chan] == tx_hard_error)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "672ecbe1c977616aa720c9397589665b33e72610",
      "candidate_info": {
        "commit_hash": "672ecbe1c977616aa720c9397589665b33e72610",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/672ecbe1c977616aa720c9397589665b33e72610",
        "files": [
          "net/tipc/server.c"
        ],
        "message": "tipc: fix a null pointer deref on error path\n\nIn tipc_topsrv_kern_subscr() when s->tipc_conn_new() fails\nwe call tipc_close_conn() to clean up, but in this case\ncalling conn_put() is just enough.\n\nThis fixes the folllowing crash:\n\n kasan: GPF could be caused by NULL-ptr deref or user memory access\n general protection fault: 0000 [#1] SMP KASAN\n Dumping ftrace buffer:\n    (ftrace buffer empty)\n Modules linked in:\n CPU: 0 PID: 3085 Comm: syzkaller064164 Not tainted 4.15.0-rc1+ #137\n Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n task: 00000000c24413a5 task.stack: 000000005e8160b5\n RIP: 0010:__lock_acquire+0xd55/0x47f0 kernel/locking/lockdep.c:3378\n RSP: 0018:ffff8801cb5474a8 EFLAGS: 00010002\n RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000004 RSI: 0000000000000000 RDI: ffffffff85ecb400\n RBP: ffff8801cb547830 R08: 0000000000000001 R09: 0000000000000000\n R10: 0000000000000000 R11: ffffffff87489d60 R12: ffff8801cd2980c0\n R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000020\n FS:  00000000014ee880(0000) GS:ffff8801db400000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007ffee2426e40 CR3: 00000001cb85a000 CR4: 00000000001406f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  lock_acquire+0x1d5/0x580 kernel/locking/lockdep.c:4004\n  __raw_spin_lock_bh include/linux/spinlock_api_smp.h:135 [inline]\n  _raw_spin_lock_bh+0x31/0x40 kernel/locking/spinlock.c:175\n  spin_lock_bh include/linux/spinlock.h:320 [inline]\n  tipc_subscrb_subscrp_delete+0x8f/0x470 net/tipc/subscr.c:201\n  tipc_subscrb_delete net/tipc/subscr.c:238 [inline]\n  tipc_subscrb_release_cb+0x17/0x30 net/tipc/subscr.c:316\n  tipc_close_conn+0x171/0x270 net/tipc/server.c:204\n  tipc_topsrv_kern_subscr+0x724/0x810 net/tipc/server.c:514\n  tipc_group_create+0x702/0x9c0 net/tipc/group.c:184\n  tipc_sk_join net/tipc/socket.c:2747 [inline]\n  tipc_setsockopt+0x249/0xc10 net/tipc/socket.c:2861\n  SYSC_setsockopt net/socket.c:1851 [inline]\n  SyS_setsockopt+0x189/0x360 net/socket.c:1830\n  entry_SYSCALL_64_fastpath+0x1f/0x96\n\nFixes: 14c04493cb77 (\"tipc: add ability to order and receive topology events in driver\")\nReported-by: syzbot <syzkaller@googlegroups.com>\nCc: Jon Maloy <jon.maloy@ericsson.com>\nCc: Ying Xue <ying.xue@windriver.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/tipc/server.c||net/tipc/server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/tipc/server.c||net/tipc/server.c": [
          "File: net/tipc/server.c -> net/tipc/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "511:  s = con->server;",
          "512:  scbr = s->tipc_conn_new(*conid);",
          "513:  if (!scbr) {",
          "515:   return false;",
          "516:  }",
          "",
          "[Removed Lines]",
          "514:   tipc_close_conn(con);",
          "",
          "[Added Lines]",
          "514:   conn_put(con);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6ab405114b0b229151ef06f4e31c7834dd09d0c0",
      "candidate_info": {
        "commit_hash": "6ab405114b0b229151ef06f4e31c7834dd09d0c0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6ab405114b0b229151ef06f4e31c7834dd09d0c0",
        "files": [
          "net/netfilter/xt_bpf.c"
        ],
        "message": "netfilter: xt_bpf: add overflow checks\n\nCheck whether inputs from userspace are too long (explicit length field too\nbig or string not null-terminated) to avoid out-of-bounds reads.\n\nAs far as I can tell, this can at worst lead to very limited kernel heap\nmemory disclosure or oopses.\n\nThis bug can be triggered by an unprivileged user even if the xt_bpf module\nis not loaded: iptables is available in network namespaces, and the xt_bpf\nmodule can be autoloaded.\n\nTriggering the bug with a classic BPF filter with fake length 0x1000 causes\nthe following KASAN report:\n\n==================================================================\nBUG: KASAN: slab-out-of-bounds in bpf_prog_create+0x84/0xf0\nRead of size 32768 at addr ffff8801eff2c494 by task test/4627\n\nCPU: 0 PID: 4627 Comm: test Not tainted 4.15.0-rc1+ #1\n[...]\nCall Trace:\n dump_stack+0x5c/0x85\n print_address_description+0x6a/0x260\n kasan_report+0x254/0x370\n ? bpf_prog_create+0x84/0xf0\n memcpy+0x1f/0x50\n bpf_prog_create+0x84/0xf0\n bpf_mt_check+0x90/0xd6 [xt_bpf]\n[...]\nAllocated by task 4627:\n kasan_kmalloc+0xa0/0xd0\n __kmalloc_node+0x47/0x60\n xt_alloc_table_info+0x41/0x70 [x_tables]\n[...]\nThe buggy address belongs to the object at ffff8801eff2c3c0\n                which belongs to the cache kmalloc-2048 of size 2048\nThe buggy address is located 212 bytes inside of\n                2048-byte region [ffff8801eff2c3c0, ffff8801eff2cbc0)\n[...]\n==================================================================\n\nFixes: e6f30c731718 (\"netfilter: x_tables: add xt_bpf match\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/netfilter/xt_bpf.c||net/netfilter/xt_bpf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/netfilter/xt_bpf.c||net/netfilter/xt_bpf.c": [
          "File: net/netfilter/xt_bpf.c -> net/netfilter/xt_bpf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: {",
          "28:  struct sock_fprog_kern program;",
          "30:  program.len = len;",
          "31:  program.filter = insns;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30:  if (len > XT_BPF_MAX_NUM_INSTR)",
          "31:   return -EINVAL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:  mm_segment_t oldfs = get_fs();",
          "56:  int retval, fd;",
          "58:  set_fs(KERNEL_DS);",
          "59:  fd = bpf_obj_get_user(path, 0);",
          "60:  set_fs(oldfs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61:  if (strnlen(path, XT_BPF_PATH_MAX) == XT_BPF_PATH_MAX)",
          "62:   return -EINVAL;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
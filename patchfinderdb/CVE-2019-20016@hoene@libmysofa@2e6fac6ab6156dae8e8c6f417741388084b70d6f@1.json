{
  "cve_id": "CVE-2019-20016",
  "cve_desc": "libmysofa before 2019-11-24 does not properly restrict recursive function calls, as demonstrated by reports of stack consumption in readOHDRHeaderMessageDatatype in dataobject.c and directblockRead in fractalhead.c. NOTE: a download of v0.9 after 2019-12-06 should fully remediate this issue.",
  "repo": "hoene/libmysofa",
  "patch_hash": "2e6fac6ab6156dae8e8c6f417741388084b70d6f",
  "patch_info": {
    "commit_hash": "2e6fac6ab6156dae8e8c6f417741388084b70d6f",
    "repo": "hoene/libmysofa",
    "commit_url": "https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f",
    "files": [
      "src/hdf/fractalhead.c",
      "src/hdf/reader.h",
      "src/hrtf/reader.c"
    ],
    "message": "Fixed recursive function calls",
    "before_after_code_files": [
      "src/hdf/fractalhead.c||src/hdf/fractalhead.c",
      "src/hdf/reader.h||src/hdf/reader.h",
      "src/hrtf/reader.c||src/hrtf/reader.c"
    ]
  },
  "patch_diff": {
    "src/hdf/fractalhead.c||src/hdf/fractalhead.c": [
      "File: src/hdf/fractalhead.c -> src/hdf/fractalhead.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "33:  UNUSED(block_size);",
      "34:  UNUSED(block_offset);",
      "37:  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {",
      "38:   log(\"cannot read signature of fractal heap indirect block\\n\");",
      "39:   return MYSOFA_INVALID_FORMAT;",
      "40:  }",
      "43:  if (fgetc(reader->fhd) != 0) {",
      "44:   log(\"object FHDB must have version 0\\n\");",
      "",
      "[Removed Lines]",
      "41:  log(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);",
      "",
      "[Added Lines]",
      "36:  if(reader->recursive_counter >= 10)",
      "37:   return MYSOFA_INVALID_FORMAT;",
      "38:  else",
      "39:   reader->recursive_counter++;",
      "46:  log(\"%08\" PRIX64 \" %.4s stack %d\\n\", (uint64_t )ftell(reader->fhd) - 4, buf, reader->recursive_counter);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "219:  } while (typeandversion != 0);",
      "221:  return MYSOFA_OK;",
      "222: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "226:  reader->recursive_counter--;",
      "",
      "---------------"
    ],
    "src/hdf/reader.h||src/hdf/reader.h": [
      "File: src/hdf/reader.h -> src/hdf/reader.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "182:  struct SUPERBLOCK superblock;",
      "184:  struct GCOL *gcol;",
      "185: };",
      "187: int validAddress(struct READER *reader, uint64_t address);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "186:  int recursive_counter;",
      "",
      "---------------"
    ],
    "src/hrtf/reader.c||src/hrtf/reader.c": [
      "File: src/hrtf/reader.c -> src/hrtf/reader.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "244:  }",
      "245:  reader.gcol = NULL;",
      "246:  reader.all = NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "247:  reader.recursive_counter = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "90f0089eb796813ed6d3608a36c23aa3eab9c8f6",
      "candidate_info": {
        "commit_hash": "90f0089eb796813ed6d3608a36c23aa3eab9c8f6",
        "repo": "hoene/libmysofa",
        "commit_url": "https://github.com/hoene/libmysofa/commit/90f0089eb796813ed6d3608a36c23aa3eab9c8f6",
        "files": [
          "src/hdf/dataobject.c",
          "src/hdf/fractalhead.c"
        ],
        "message": "Coverity fixes",
        "before_after_code_files": [
          "src/hdf/dataobject.c||src/hdf/dataobject.c",
          "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ],
          "candidate": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hdf/dataobject.c||src/hdf/dataobject.c": [
          "File: src/hdf/dataobject.c -> src/hdf/dataobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "617:   int i, j;",
          "618:   uint16_t filter_identification_value, flags, number_client_data_values,",
          "619:       namelength;",
          "622:   if (readValue(reader, 6) != 0) {",
          "623:     mylog(\"reserved values not zero\\n\");",
          "",
          "[Removed Lines]",
          "620:   uint32_t client_data;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "655:       return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE",
          "657:     for (j = 0; j < number_client_data_values; j++) {",
          "659:     }",
          "660:     if ((number_client_data_values & 1) == 1)",
          "661:       readValue(reader, 4);",
          "",
          "[Removed Lines]",
          "658:       client_data = readValue(reader, 4);",
          "",
          "[Added Lines]",
          "657:       readValue(reader, 4);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "713:   filterversion = fgetc(reader->fhd);",
          "714:   filters = fgetc(reader->fhd);",
          "717:     return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE",
          "719:   if (filters > 32) {",
          "",
          "[Removed Lines]",
          "716:   if (filterversion == EOF || filters == EOF)",
          "",
          "[Added Lines]",
          "715:   if (filterversion < 0 || filters < 0)",
          "",
          "---------------"
        ],
        "src/hdf/fractalhead.c||src/hdf/fractalhead.c": [
          "File: src/hdf/fractalhead.c -> src/hdf/fractalhead.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "350:         unknown4 = (int)readValue(reader, 8);",
          "351:         if (unknown4 != 0x00000001 && unknown4 != 0x02000002) {",
          "353:                 unknown4);                  // LCOV_EXCL_LINE",
          "354:           free(name);                       // LCOV_EXCL_LINE",
          "355:           return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE",
          "",
          "[Removed Lines]",
          "352:           mylog(\"FHDB type 3 unsupported values: unknown4 %08LX\\n\",",
          "",
          "[Added Lines]",
          "352:           mylog(\"FHDB type 3 unsupported values: unknown4 %\" PRIX64 \"\\n\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e54affc9993eaf27484685cc3f5a2194e5450ac",
      "candidate_info": {
        "commit_hash": "6e54affc9993eaf27484685cc3f5a2194e5450ac",
        "repo": "hoene/libmysofa",
        "commit_url": "https://github.com/hoene/libmysofa/commit/6e54affc9993eaf27484685cc3f5a2194e5450ac",
        "files": [
          "src/hdf/dataobject.c",
          "src/hdf/fractalhead.c"
        ],
        "message": "Some more",
        "before_after_code_files": [
          "src/hdf/dataobject.c||src/hdf/dataobject.c",
          "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ],
          "candidate": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hdf/dataobject.c||src/hdf/dataobject.c": [
          "File: src/hdf/dataobject.c -> src/hdf/dataobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:   case 2:",
          "139:     return readOHDRHeaderMessageDataspace2(reader, ds);",
          "140:   default:",
          "143:     return MYSOFA_INVALID_FORMAT;",
          "144:   }",
          "145: }",
          "",
          "[Removed Lines]",
          "141:     log(\"object OHDR dataspace message must have version 1 or 2 but is %X\\n\",",
          "142:         version);",
          "",
          "[Added Lines]",
          "141:     log(\"object OHDR dataspace message must have version 1 or 2 but is %X at \"",
          "142:         \"%06X\\n\",",
          "143:         version, ftell(reader->fhd) - 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197:   dt->class_and_version = (uint8_t)fgetc(reader->fhd);",
          "198:   if ((dt->class_and_version & 0xf0) != 0x10 &&",
          "199:       (dt->class_and_version & 0xf0) != 0x30) {",
          "202:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "203:   }",
          "",
          "[Removed Lines]",
          "200:     log(\"object OHDR datatype message must have version 1 not %d\\n\",",
          "201:         dt->class_and_version >> 4);",
          "",
          "[Added Lines]",
          "201:     log(\"object OHDR datatype message must have version 1 not %d at %06X\\n\",",
          "202:         dt->class_and_version >> 4, ftell(reader->fhd) - 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "212:     dt->u.i.bit_offset = readValue(reader, 2);",
          "213:     dt->u.i.bit_precision = readValue(reader, 2);",
          "215:     break;",
          "",
          "[Removed Lines]",
          "214:     log(\"    INT bit %d %d\\n\", dt->u.i.bit_offset, dt->u.i.bit_precision);",
          "",
          "[Added Lines]",
          "215:     log(\"    INT bit %d %d %d %d\\n\", dt->u.i.bit_offset, dt->u.i.bit_precision,",
          "216:         dt->class_and_version >> 4, dt->size);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "328:     }",
          "329:     break;",
          "332:     break;",
          "",
          "[Removed Lines]",
          "331:     log(\"   REFERENCE %d %02X\\n\", dt->size, dt->class_bit_field);",
          "",
          "[Added Lines]",
          "333:     log(\"    REFERENCE %d %02X\\n\", dt->size, dt->class_bit_field);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "360:   uint8_t fillValueWriteTime = fgetc(reader->fhd);",
          "361:   uint8_t fillValueDefined = fgetc(reader->fhd);",
          "364:       (fillValueDefined & ~1) != 0) {",
          "366:         spaceAllocationTime, fillValueWriteTime, fillValueDefined);",
          "367:     return MYSOFA_INVALID_FORMAT;",
          "368:   }",
          "",
          "[Removed Lines]",
          "363:   if (spaceAllocationTime != 2 || fillValueWriteTime != 2 ||",
          "365:     log(\"spaceAllocationTime %d fillValueWriteTime %d fillValueDefined %d\",",
          "",
          "[Added Lines]",
          "365:   if ((spaceAllocationTime & ~1) != 2 || fillValueWriteTime != 2 ||",
          "367:     log(\"spaceAllocationTime %d fillValueWriteTime %d fillValueDefined %d\\n\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "413:   flags = (uint8_t)fgetc(reader->fhd);",
          "414: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "418: static int readOHDRHeaderMessageDataFillOld(struct READER *reader) {",
          "420:   uint32_t size;",
          "422:   size = (uint32_t)readValue(reader, 4);",
          "423:   if (fseek(reader->fhd, size, SEEK_CUR) < 0)",
          "424:     return errno;",
          "426:   return MYSOFA_OK;",
          "427: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "809:   }",
          "811:   name[name_size] = 0;",
          "814:   if (version == 3 && (flags & 3)) {",
          "815:     log(\"object OHDR attribute message must not have any flags set\\n\");",
          "",
          "[Removed Lines]",
          "812:   log(\"  attribute name %s %d %d\\n\", name, datatype_size, dataspace_size);",
          "",
          "[Added Lines]",
          "825:   log(\"  attribute name %s %d %d %X\\n\", name, datatype_size, dataspace_size,",
          "826:       ftell(reader->fhd));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "822:     free(name);",
          "823:     return MYSOFA_INVALID_FORMAT;",
          "824:   }",
          "825:   err = readOHDRHeaderMessageDataspace(reader, &d.ds);",
          "826:   if (err) {",
          "827:     log(\"object OHDR attribute message read dataspace error\\n\");",
          "828:     free(name);",
          "829:     return MYSOFA_INVALID_FORMAT;",
          "830:   }",
          "831:   err = readData(reader, &d, &d.dt, &d.ds);",
          "832:   if (err) {",
          "833:     log(\"object OHDR attribute message read data error\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "839:   if (version == 1)",
          "840:     fseek(reader->fhd, (8 - datatype_size) & 7, SEEK_CUR);",
          "848:   if (version == 1)",
          "849:     fseek(reader->fhd, (8 - dataspace_size) & 7, SEEK_CUR);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "928:       if (!!(err = readOHDRHeaderMessageDatatype(reader, &dataobject->dt)))",
          "929:         return err;",
          "930:       break;",
          "932:       if (!!(err = readOHDRHeaderMessageDataFill(reader)))",
          "933:         return err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "952:       if (!!(err = readOHDRHeaderMessageDataFillOld(reader)))",
          "953:         return err;",
          "954:       break;",
          "",
          "---------------"
        ],
        "src/hdf/fractalhead.c||src/hdf/fractalhead.c": [
          "File: src/hdf/fractalhead.c -> src/hdf/fractalhead.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <assert.h>",
          "13: #include <inttypes.h>",
          "20: static int directblockRead(struct READER *reader, struct DATAOBJECT *dataobject,",
          "228: }",
          "",
          "[Removed Lines]",
          "7: #include <stdlib.h>",
          "8: #include <stdio.h>",
          "9: #include <string.h>",
          "10: #include <math.h>",
          "11: #include <errno.h>",
          "14: #include \"reader.h\"",
          "16: static int log2i(int a) {",
          "17:  return round(log2(a));",
          "18: }",
          "21:   struct FRACTALHEAP *fractalheap) {",
          "23:  char buf[4], *name, *value;",
          "24:  int size, offset_size, length_size, err, len;",
          "25:  uint8_t typeandversion;",
          "26:  uint64_t unknown, heap_header_address, block_offset, block_size, offset,",
          "27:    length;",
          "28:  long store;",
          "29:  struct DIR *dir;",
          "30:  struct MYSOFA_ATTRIBUTE *attr;",
          "32:  UNUSED(offset);",
          "33:  UNUSED(block_size);",
          "34:  UNUSED(block_offset);",
          "36:  if(reader->recursive_counter >= 10)",
          "37:   return MYSOFA_INVALID_FORMAT;",
          "38:  else",
          "39:   reader->recursive_counter++;",
          "42:  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {",
          "43:   log(\"cannot read signature of fractal heap indirect block\\n\");",
          "44:   return MYSOFA_INVALID_FORMAT;",
          "45:  }",
          "46:  log(\"%08\" PRIX64 \" %.4s stack %d\\n\", (uint64_t )ftell(reader->fhd) - 4, buf, reader->recursive_counter);",
          "48:  if (fgetc(reader->fhd) != 0) {",
          "49:   log(\"object FHDB must have version 0\\n\");",
          "50:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "51:  }",
          "54:  if (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)",
          "55:   return errno;",
          "57:  size = (fractalheap->maximum_heap_size + 7) / 8;",
          "58:  block_offset = readValue(reader, size);",
          "60:  if (fractalheap->flags & 2)",
          "61:   if (fseek(reader->fhd, 4, SEEK_CUR))",
          "62:    return errno;",
          "64:  offset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);",
          "65:  if (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)",
          "66:   length_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);",
          "67:  else",
          "68:   length_size = ceilf(log2f(fractalheap->maximum_size) / 8);",
          "70:  log(\" %d %\" PRIu64 \" %d\\n\",size,block_offset,offset_size);",
          "74:   00003e10  00 00 00 83 8d ac f6 >03  00 0c 00 08 00 04 00 00  |................|",
          "75:   00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00 13 00 00 00  |Conventions.....|",
          "76:   00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03 00 08 00  |........SOFA....|",
          "77:   00003e40  08 00 04 00 00 56 65 72  73 69 6f 6e 00 13 00 00  |.....Version....|",
          "78:   00003e50  00 03 00 00 00 02 00 00  00 30 2e 36 03 00 10 00  |.........0.6....|",
          "79:   00003e60  08 00 04 00 00 53 4f 46  41 43 6f 6e 76 65 6e 74  |.....SOFAConvent|",
          "80:   00003e70  69 6f 6e 73 00 13 00 00  00 13 00 00 00 02 00 00  |ions............|",
          "81:   00003e80  00 53 69 6d 70 6c 65 46  72 65 65 46 69 65 6c 64  |.SimpleFreeField|",
          "82:   00003e90  48 52 49 52 03 00 17 00  08 00 04 00 00 53 4f 46  |HRIR.........SOF|",
          "83:   00003ea0  41 43 6f 6e 76 65 6e 74  69 6f 6e 73 56 65 72 73  |AConventionsVers|",
          "84:   00003eb0  69 6f 6e 00 13 00 00 00  03 00 00 00 02 00 00 00  |ion.............|",
          "87:  do {",
          "88:   typeandversion = (uint8_t) fgetc(reader->fhd);",
          "89:   offset = readValue(reader, offset_size);",
          "90:   length = readValue(reader, length_size);",
          "91:   if (offset > 0x10000000 || length > 0x10000000)",
          "92:    return MYSOFA_UNSUPPORTED_FORMAT;",
          "94:   log(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\",typeandversion,offset,length,ftell(reader->fhd));",
          "97:   if (typeandversion == 3) {",
          "102:    if (readValue(reader, 5) != 0x0000040008) {",
          "103:     log(\"FHDB type 3 unsupported values\");",
          "104:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "105:    }",
          "107:    if (!(name = malloc(length+1)))",
          "108:     return MYSOFA_NO_MEMORY;",
          "109:    if (fread(name, 1, length, reader->fhd) != length) {",
          "110:     free(name);",
          "111:     return MYSOFA_READ_ERROR;",
          "112:    }",
          "113:    name[length]=0;",
          "115:    if (readValue(reader, 4) != 0x00000013) {",
          "116:     log(\"FHDB type 3 unsupported values\");",
          "117:     free(name);",
          "118:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "119:    }",
          "121:    len = (int) readValue(reader, 2);",
          "122:    if (len > 0x1000 || len < 0) {",
          "123:     free(name);",
          "124:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "125:    }",
          "128:    unknown = readValue(reader, 6);",
          "129:    if (unknown == 0x000000020200)",
          "130:     value = NULL;",
          "131:    else if (unknown == 0x000000020000) {",
          "132:     if (!(value = malloc(len + 1))) {",
          "133:      free(name);",
          "134:      return MYSOFA_NO_MEMORY;",
          "135:     }",
          "136:     if (fread(value, 1, len, reader->fhd) != len) {",
          "137:      free(value);",
          "138:      free(name);",
          "139:      return MYSOFA_READ_ERROR;",
          "140:     }",
          "141:     value[len] = 0;",
          "142:    } else if (unknown == 0x20000020000) {",
          "143:     if (!(value = malloc(5))) {",
          "144:      free(name);",
          "145:      return MYSOFA_NO_MEMORY;",
          "146:     }",
          "147:     strcpy(value, \"\");",
          "148:    } else {",
          "149:     log(\"FHDB type 3 unsupported values: %12\" PRIX64 \"\\n\",unknown);",
          "150:     free(name);",
          "152:     return MYSOFA_OK;",
          "153:    }",
          "154:    log(\" %s = %s\\n\", name, value);",
          "156:    attr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));",
          "157:    attr->name = name;",
          "158:    attr->value = value;",
          "159:    attr->next = dataobject->attributes;",
          "160:    dataobject->attributes = attr;",
          "162:   } else if (typeandversion == 1) {",
          "166:    unknown = readValue(reader, 6);",
          "167:    if (unknown) {",
          "168:     log(\"FHDB type 1 unsupported values\\n\");",
          "169:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "170:    }",
          "172:    len = fgetc(reader->fhd);",
          "173:    if (len < 0)",
          "174:     return MYSOFA_READ_ERROR;",
          "175:    assert(len < 0x100);",
          "177:    if (!(name = malloc(len + 1)))",
          "178:     return MYSOFA_NO_MEMORY;",
          "179:    if (fread(name, 1, len, reader->fhd) != len) {",
          "180:     free(name);",
          "181:     return MYSOFA_READ_ERROR;",
          "182:    }",
          "183:    name[len] = 0;",
          "185:    heap_header_address = readValue(reader,",
          "186:      reader->superblock.size_of_offsets);",
          "188:    log(\"\\nfractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64 \"\\n\", length, name, heap_header_address);",
          "190:    dir = malloc(sizeof(struct DIR));",
          "191:    if (!dir) {",
          "192:     free(name);",
          "193:     return MYSOFA_NO_MEMORY;",
          "194:    }",
          "195:    memset(dir, 0, sizeof(*dir));",
          "197:    dir->next = dataobject->directory;",
          "198:    dataobject->directory = dir;",
          "200:    store = ftell(reader->fhd);",
          "201:    if (fseek(reader->fhd, heap_header_address, SEEK_SET)) {",
          "202:     free(name);",
          "203:     return errno;",
          "204:    }",
          "206:    err = dataobjectRead(reader, &dir->dataobject, name);",
          "207:    if (err) {",
          "208:     return err;",
          "209:    }",
          "211:    if (store < 0) {",
          "212:     return errno;",
          "213:    }",
          "214:    if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "215:     return errno;",
          "217:   } else if (typeandversion != 0) {",
          "219:    log(\"fractal head unknown type %d\\n\", typeandversion);",
          "221:    return MYSOFA_OK;",
          "222:   }",
          "224:  } while (typeandversion != 0);",
          "226:  reader->recursive_counter--;",
          "227:  return MYSOFA_OK;",
          "",
          "[Added Lines]",
          "7: #include \"reader.h\"",
          "9: #include <errno.h>",
          "11: #include <math.h>",
          "12: #include <stdio.h>",
          "13: #include <stdlib.h>",
          "14: #include <string.h>",
          "16: static int log2i(int a) { return round(log2(a)); }",
          "19:                            struct FRACTALHEAP *fractalheap) {",
          "21:   char buf[4], *name, *value;",
          "22:   int size, offset_size, length_size, err, len;",
          "23:   uint8_t typeandversion;",
          "24:   uint64_t unknown, heap_header_address, block_offset, block_size, offset,",
          "25:       length;",
          "26:   long store;",
          "27:   struct DIR *dir;",
          "28:   struct MYSOFA_ATTRIBUTE *attr;",
          "30:   UNUSED(offset);",
          "31:   UNUSED(block_size);",
          "32:   UNUSED(block_offset);",
          "34:   if (reader->recursive_counter >= 10)",
          "35:     return MYSOFA_INVALID_FORMAT;",
          "36:   else",
          "37:     reader->recursive_counter++;",
          "40:   if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {",
          "41:     log(\"cannot read signature of fractal heap indirect block\\n\");",
          "42:     return MYSOFA_INVALID_FORMAT;",
          "43:   }",
          "44:   log(\"%08\" PRIX64 \" %.4s stack %d\\n\", (uint64_t)ftell(reader->fhd) - 4, buf,",
          "45:       reader->recursive_counter);",
          "47:   if (fgetc(reader->fhd) != 0) {",
          "48:     log(\"object FHDB must have version 0\\n\");",
          "49:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "50:   }",
          "53:   if (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)",
          "54:     return errno;",
          "56:   size = (fractalheap->maximum_heap_size + 7) / 8;",
          "57:   block_offset = readValue(reader, size);",
          "59:   if (fractalheap->flags & 2)",
          "60:     if (fseek(reader->fhd, 4, SEEK_CUR))",
          "61:       return errno;",
          "63:   offset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);",
          "64:   if (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)",
          "65:     length_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);",
          "66:   else",
          "67:     length_size = ceilf(log2f(fractalheap->maximum_size) / 8);",
          "69:   log(\" %d %\" PRIu64 \" %d\\n\", size, block_offset, offset_size);",
          "73:    |.FHDB.@.........| 00003e10  00 00 00 83 8d ac f6 >03  00 0c 00 08 00 04 00",
          "74:    00  |................| 00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00 13 00",
          "75:    00 00  |Conventions.....| 00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03",
          "76:    00 08 00  |........SOFA....| 00003e40  08 00 04 00 00 56 65 72  73 69 6f 6e",
          "77:    00 13 00 00  |.....Version....| 00003e50  00 03 00 00 00 02 00 00  00 30 2e",
          "78:    36 03 00 10 00  |.........0.6....| 00003e60  08 00 04 00 00 53 4f 46  41 43",
          "79:    6f 6e 76 65 6e 74  |.....SOFAConvent| 00003e70  69 6f 6e 73 00 13 00 00  00",
          "80:    13 00 00 00 02 00 00  |ions............| 00003e80  00 53 69 6d 70 6c 65 46 72",
          "81:    65 65 46 69 65 6c 64  |.SimpleFreeField| 00003e90  48 52 49 52 03 00 17 00 08",
          "82:    00 04 00 00 53 4f 46  |HRIR.........SOF| 00003ea0  41 43 6f 6e 76 65 6e 74 69",
          "83:    6f 6e 73 56 65 72 73  |AConventionsVers| 00003eb0  69 6f 6e 00 13 00 00 00 03",
          "84:    00 00 00 02 00 00 00  |ion.............|",
          "87:   do {",
          "88:     typeandversion = (uint8_t)fgetc(reader->fhd);",
          "89:     offset = readValue(reader, offset_size);",
          "90:     length = readValue(reader, length_size);",
          "91:     if (offset > 0x10000000 || length > 0x10000000)",
          "92:       return MYSOFA_UNSUPPORTED_FORMAT;",
          "94:     log(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\", typeandversion, offset, length,",
          "95:         ftell(reader->fhd));",
          "98:     if (typeandversion == 3) {",
          "103:       if (readValue(reader, 5) != 0x0000040008) {",
          "104:         log(\"FHDB type 3 unsupported values\");",
          "105:         return MYSOFA_UNSUPPORTED_FORMAT;",
          "106:       }",
          "108:       if (!(name = malloc(length + 1)))",
          "109:         return MYSOFA_NO_MEMORY;",
          "110:       if (fread(name, 1, length, reader->fhd) != length) {",
          "111:         free(name);",
          "112:         return MYSOFA_READ_ERROR;",
          "113:       }",
          "114:       name[length] = 0;",
          "116:       if (readValue(reader, 4) != 0x00000013) {",
          "117:         log(\"FHDB type 3 unsupported values\");",
          "118:         free(name);",
          "119:         return MYSOFA_UNSUPPORTED_FORMAT;",
          "120:       }",
          "122:       len = (int)readValue(reader, 2);",
          "123:       if (len > 0x1000 || len < 0) {",
          "124:         free(name);",
          "125:         return MYSOFA_UNSUPPORTED_FORMAT;",
          "126:       }",
          "129:       unknown = readValue(reader, 6);",
          "130:       if (unknown == 0x000000020200)",
          "131:         value = NULL;",
          "132:       else if (unknown == 0x000000020000) {",
          "133:         if (!(value = malloc(len + 1))) {",
          "134:           free(name);",
          "135:           return MYSOFA_NO_MEMORY;",
          "136:         }",
          "137:         if (fread(value, 1, len, reader->fhd) != len) {",
          "138:           free(value);",
          "139:           free(name);",
          "140:           return MYSOFA_READ_ERROR;",
          "141:         }",
          "142:         value[len] = 0;",
          "143:       } else if (unknown == 0x20000020000) {",
          "144:         if (!(value = malloc(5))) {",
          "145:           free(name);",
          "146:           return MYSOFA_NO_MEMORY;",
          "147:         }",
          "148:         strcpy(value, \"\");",
          "149:       } else {",
          "150:         log(\"FHDB type 3 unsupported values: %12\" PRIX64 \"\\n\", unknown);",
          "151:         free(name);",
          "153:         return MYSOFA_OK;",
          "154:       }",
          "155:       log(\" %s = %s\\n\", name, value);",
          "157:       attr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));",
          "158:       attr->name = name;",
          "159:       attr->value = value;",
          "160:       attr->next = dataobject->attributes;",
          "161:       dataobject->attributes = attr;",
          "163:     } else if (typeandversion == 1) {",
          "167:       unknown = readValue(reader, 6);",
          "168:       if (unknown) {",
          "169:         log(\"FHDB type 1 unsupported values\\n\");",
          "170:         return MYSOFA_UNSUPPORTED_FORMAT;",
          "171:       }",
          "173:       len = fgetc(reader->fhd);",
          "174:       if (len < 0)",
          "175:         return MYSOFA_READ_ERROR;",
          "176:       assert(len < 0x100);",
          "178:       if (!(name = malloc(len + 1)))",
          "179:         return MYSOFA_NO_MEMORY;",
          "180:       if (fread(name, 1, len, reader->fhd) != len) {",
          "181:         free(name);",
          "182:         return MYSOFA_READ_ERROR;",
          "183:       }",
          "184:       name[len] = 0;",
          "186:       heap_header_address =",
          "187:           readValue(reader, reader->superblock.size_of_offsets);",
          "189:       log(\"fractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64",
          "190:           \"\\n\",",
          "191:           length, name, heap_header_address);",
          "193:       dir = malloc(sizeof(struct DIR));",
          "194:       if (!dir) {",
          "195:         free(name);",
          "196:         return MYSOFA_NO_MEMORY;",
          "197:       }",
          "198:       memset(dir, 0, sizeof(*dir));",
          "200:       dir->next = dataobject->directory;",
          "201:       dataobject->directory = dir;",
          "203:       store = ftell(reader->fhd);",
          "204:       if (fseek(reader->fhd, heap_header_address, SEEK_SET)) {",
          "205:         free(name);",
          "206:         return errno;",
          "207:       }",
          "209:       err = dataobjectRead(reader, &dir->dataobject, name);",
          "210:       if (err) {",
          "211:         return err;",
          "212:       }",
          "214:       if (store < 0) {",
          "215:         return errno;",
          "216:       }",
          "217:       if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "218:         return errno;",
          "220:     } else if (typeandversion != 0) {",
          "222:       log(\"fractal head unknown type %d\\n\", typeandversion);",
          "224:       return MYSOFA_OK;",
          "225:     }",
          "227:   } while (typeandversion != 0);",
          "229:   reader->recursive_counter--;",
          "230:   return MYSOFA_OK;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "234: static int indirectblockRead(struct READER *reader,",
          "335: }",
          "",
          "[Removed Lines]",
          "235:   struct DATAOBJECT *dataobject, struct FRACTALHEAP *fractalheap,",
          "236:   uint64_t iblock_size) {",
          "237:  int size, nrows, max_dblock_rows, k, n, err;",
          "238:  uint32_t filter_mask;",
          "239:  uint64_t heap_header_address, block_offset, child_direct_block = 0,",
          "240:    size_filtered, child_indirect_block;",
          "241:  long store;",
          "243:  char buf[4];",
          "245:  UNUSED(size_filtered);",
          "246:  UNUSED(heap_header_address);",
          "247:  UNUSED(filter_mask);",
          "250:  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHIB\", 4)) {",
          "251:   log(\"cannot read signature of fractal heap indirect block\\n\");",
          "252:   return MYSOFA_INVALID_FORMAT;",
          "253:  }",
          "254:  log(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);",
          "256:  if (fgetc(reader->fhd) != 0) {",
          "257:   log(\"object FHIB must have version 0\\n\");",
          "258:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "259:  }",
          "262:  heap_header_address = readValue(reader, reader->superblock.size_of_offsets);",
          "264:  size = (fractalheap->maximum_heap_size + 7) / 8;",
          "265:  block_offset = readValue(reader, size);",
          "267:  if (block_offset) {",
          "268:   log(\"FHIB block offset is not 0\\n\");",
          "269:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "270:  }",
          "273:  nrows = (log2i(iblock_size) - log2i(fractalheap->starting_block_size)) + 1;",
          "276:  max_dblock_rows = (log2i(fractalheap->maximum_direct_block_size)",
          "277:    - log2i(fractalheap->starting_block_size)) + 2;",
          "280:  if (nrows < max_dblock_rows)",
          "281:   k = nrows * fractalheap->table_width;",
          "282:  else",
          "283:   k = max_dblock_rows * fractalheap->table_width;",
          "286:  n = k - (max_dblock_rows * fractalheap->table_width);",
          "288:  while (k > 0) {",
          "289:   child_direct_block = readValue(reader,",
          "290:     reader->superblock.size_of_offsets);",
          "291:   if (fractalheap->encoded_length > 0) {",
          "292:    size_filtered = readValue(reader,",
          "293:      reader->superblock.size_of_lengths);",
          "294:    filter_mask = readValue(reader, 4);",
          "295:   }",
          "296:   log(\">> %d %\" PRIX64 \" %d\\n\",k,child_direct_block,size);",
          "297:   if (validAddress(reader, child_direct_block)) {",
          "298:    store = ftell(reader->fhd);",
          "299:    if (fseek(reader->fhd, child_direct_block, SEEK_SET) < 0)",
          "300:     return errno;",
          "301:    err = directblockRead(reader, dataobject, fractalheap);",
          "302:    if (err)",
          "303:     return err;",
          "304:    if (store < 0)",
          "305:     return MYSOFA_READ_ERROR;",
          "306:    if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "307:     return errno;",
          "308:   }",
          "310:   k--;",
          "311:  }",
          "313:  while (n > 0) {",
          "314:   child_indirect_block = readValue(reader,",
          "315:     reader->superblock.size_of_offsets);",
          "317:   if (validAddress(reader, child_direct_block)) {",
          "318:    store = ftell(reader->fhd);",
          "319:    if (fseek(reader->fhd, child_indirect_block, SEEK_SET) < 0)",
          "320:     return errno;",
          "321:    err = indirectblockRead(reader, dataobject, fractalheap,",
          "322:      iblock_size * 2);",
          "323:    if (err)",
          "324:     return err;",
          "325:    if (store < 0)",
          "326:     return MYSOFA_READ_ERROR;",
          "327:    if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "328:     return errno;",
          "329:   }",
          "331:   n--;",
          "332:  }",
          "334:  return MYSOFA_OK;",
          "",
          "[Added Lines]",
          "238:                              struct DATAOBJECT *dataobject,",
          "239:                              struct FRACTALHEAP *fractalheap,",
          "240:                              uint64_t iblock_size) {",
          "241:   int size, nrows, max_dblock_rows, k, n, err;",
          "242:   uint32_t filter_mask;",
          "243:   uint64_t heap_header_address, block_offset,",
          "244:       child_direct_block = 0, size_filtered, child_indirect_block;",
          "245:   long store;",
          "247:   char buf[4];",
          "249:   UNUSED(size_filtered);",
          "250:   UNUSED(heap_header_address);",
          "251:   UNUSED(filter_mask);",
          "254:   if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHIB\", 4)) {",
          "255:     log(\"cannot read signature of fractal heap indirect block\\n\");",
          "256:     return MYSOFA_INVALID_FORMAT;",
          "257:   }",
          "258:   log(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "260:   if (fgetc(reader->fhd) != 0) {",
          "261:     log(\"object FHIB must have version 0\\n\");",
          "262:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "263:   }",
          "266:   heap_header_address = readValue(reader, reader->superblock.size_of_offsets);",
          "268:   size = (fractalheap->maximum_heap_size + 7) / 8;",
          "269:   block_offset = readValue(reader, size);",
          "271:   if (block_offset) {",
          "272:     log(\"FHIB block offset is not 0\\n\");",
          "273:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "274:   }",
          "278:   nrows = (log2i(iblock_size) - log2i(fractalheap->starting_block_size)) + 1;",
          "282:   max_dblock_rows = (log2i(fractalheap->maximum_direct_block_size) -",
          "283:                      log2i(fractalheap->starting_block_size)) +",
          "284:                     2;",
          "290:   if (nrows < max_dblock_rows)",
          "291:     k = nrows * fractalheap->table_width;",
          "292:   else",
          "293:     k = max_dblock_rows * fractalheap->table_width;",
          "297:   n = k - (max_dblock_rows * fractalheap->table_width);",
          "299:   while (k > 0) {",
          "300:     child_direct_block = readValue(reader, reader->superblock.size_of_offsets);",
          "301:     if (fractalheap->encoded_length > 0) {",
          "302:       size_filtered = readValue(reader, reader->superblock.size_of_lengths);",
          "303:       filter_mask = readValue(reader, 4);",
          "304:     }",
          "305:     log(\">> %d %\" PRIX64 \" %d\\n\", k, child_direct_block, size);",
          "306:     if (validAddress(reader, child_direct_block)) {",
          "307:       store = ftell(reader->fhd);",
          "308:       if (fseek(reader->fhd, child_direct_block, SEEK_SET) < 0)",
          "309:         return errno;",
          "310:       err = directblockRead(reader, dataobject, fractalheap);",
          "311:       if (err)",
          "312:         return err;",
          "313:       if (store < 0)",
          "314:         return MYSOFA_READ_ERROR;",
          "315:       if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "316:         return errno;",
          "317:     }",
          "319:     k--;",
          "320:   }",
          "322:   while (n > 0) {",
          "323:     child_indirect_block =",
          "324:         readValue(reader, reader->superblock.size_of_offsets);",
          "326:     if (validAddress(reader, child_direct_block)) {",
          "327:       store = ftell(reader->fhd);",
          "328:       if (fseek(reader->fhd, child_indirect_block, SEEK_SET) < 0)",
          "329:         return errno;",
          "330:       err = indirectblockRead(reader, dataobject, fractalheap, iblock_size * 2);",
          "331:       if (err)",
          "332:         return err;",
          "333:       if (store < 0)",
          "334:         return MYSOFA_READ_ERROR;",
          "335:       if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "336:         return errno;",
          "337:     }",
          "339:     n--;",
          "340:   }",
          "342:   return MYSOFA_OK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "352: int fractalheapRead(struct READER *reader, struct DATAOBJECT *dataobject,",
          "465: }",
          "467: void fractalheapFree(struct FRACTALHEAP *fractalheap) {",
          "469: }",
          "",
          "[Removed Lines]",
          "353:   struct FRACTALHEAP *fractalheap) {",
          "354:  int err;",
          "355:  char buf[4];",
          "358:  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FRHP\", 4)) {",
          "359:   log(\"cannot read signature of fractal heap\\n\");",
          "360:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "361:  }",
          "362:  log(\"%\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);",
          "364:  if (fgetc(reader->fhd) != 0) {",
          "365:   log(\"object fractal heap must have version 0\\n\");",
          "366:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "367:  }",
          "369:  fractalheap->heap_id_length = (uint16_t) readValue(reader, 2);",
          "370:  fractalheap->encoded_length = (uint16_t) readValue(reader, 2);",
          "371:  if (fractalheap->encoded_length > 0x8000)",
          "372:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "373:  fractalheap->flags = (uint8_t) fgetc(reader->fhd);",
          "374:  fractalheap->maximum_size = (uint32_t) readValue(reader, 4);",
          "376:  fractalheap->next_huge_object_id = readValue(reader,",
          "377:    reader->superblock.size_of_lengths);",
          "378:  fractalheap->btree_address_of_huge_objects = readValue(reader,",
          "379:    reader->superblock.size_of_offsets);",
          "380:  fractalheap->free_space = readValue(reader,",
          "381:    reader->superblock.size_of_lengths);",
          "382:  fractalheap->address_free_space = readValue(reader,",
          "383:    reader->superblock.size_of_offsets);",
          "384:  fractalheap->amount_managed_space = readValue(reader,",
          "385:    reader->superblock.size_of_lengths);",
          "386:  fractalheap->amount_allocated_space = readValue(reader,",
          "387:    reader->superblock.size_of_lengths);",
          "388:  fractalheap->offset_managed_space = readValue(reader,",
          "389:    reader->superblock.size_of_lengths);",
          "390:  fractalheap->number_managed_objects = readValue(reader,",
          "391:    reader->superblock.size_of_lengths);",
          "392:  fractalheap->size_huge_objects = readValue(reader,",
          "393:    reader->superblock.size_of_lengths);",
          "394:  fractalheap->number_huge_objects = readValue(reader,",
          "395:    reader->superblock.size_of_lengths);",
          "396:  fractalheap->size_tiny_objects = readValue(reader,",
          "397:    reader->superblock.size_of_lengths);",
          "398:  fractalheap->number_tiny_objects = readValue(reader,",
          "399:    reader->superblock.size_of_lengths);",
          "401:  fractalheap->table_width = (uint16_t) readValue(reader, 2);",
          "403:  fractalheap->starting_block_size = readValue(reader,",
          "404:    reader->superblock.size_of_lengths);",
          "405:  fractalheap->maximum_direct_block_size = readValue(reader,",
          "406:    reader->superblock.size_of_lengths);",
          "408:  fractalheap->maximum_heap_size = (uint16_t) readValue(reader, 2);",
          "409:  fractalheap->starting_row = (uint16_t) readValue(reader, 2);",
          "411:  fractalheap->address_of_root_block = readValue(reader,",
          "412:    reader->superblock.size_of_offsets);",
          "414:  fractalheap->current_row = (uint16_t) readValue(reader, 2);",
          "416:  if (fractalheap->encoded_length > 0) {",
          "418:   fractalheap->size_of_filtered_block = readValue(reader,",
          "419:     reader->superblock.size_of_lengths);",
          "420:   fractalheap->fitler_mask = (uint32_t) readValue(reader, 4);",
          "422:   fractalheap->filter_information = malloc(fractalheap->encoded_length);",
          "423:   if (!fractalheap->filter_information)",
          "424:    return MYSOFA_NO_MEMORY;",
          "426:   if (fread(fractalheap->filter_information, 1,",
          "427:     fractalheap->encoded_length, reader->fhd)",
          "428:     != fractalheap->encoded_length) {",
          "429:    free(fractalheap->filter_information);",
          "430:    return MYSOFA_READ_ERROR;",
          "431:   }",
          "432:  }",
          "435:   return MYSOFA_READ_ERROR;",
          "436:  }",
          "438:  if (fractalheap->number_huge_objects) {",
          "439:   log(\"cannot handle huge objects\\n\");",
          "440:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "441:  }",
          "443:  if (fractalheap->number_tiny_objects) {",
          "444:   log(\"cannot handle tiny objects\\n\");",
          "445:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "446:  }",
          "448:  if (validAddress(reader, fractalheap->address_of_root_block)) {",
          "450:   if (fseek(reader->fhd, fractalheap->address_of_root_block, SEEK_SET)",
          "451:     < 0)",
          "452:    return errno;",
          "453:   if (fractalheap->current_row)",
          "454:    err = indirectblockRead(reader, dataobject, fractalheap,",
          "455:      fractalheap->starting_block_size);",
          "456:   else {",
          "457:    err = directblockRead(reader, dataobject, fractalheap);",
          "459:   }",
          "460:   if (err)",
          "461:    return err;",
          "462:  }",
          "464:  return MYSOFA_OK;",
          "468:  free(fractalheap->filter_information);",
          "",
          "[Added Lines]",
          "361:                     struct FRACTALHEAP *fractalheap) {",
          "362:   int err;",
          "363:   char buf[4];",
          "366:   if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FRHP\", 4)) {",
          "367:     log(\"cannot read signature of fractal heap\\n\");",
          "368:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "369:   }",
          "370:   log(\"%\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "372:   if (fgetc(reader->fhd) != 0) {",
          "373:     log(\"object fractal heap must have version 0\\n\");",
          "374:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "375:   }",
          "377:   fractalheap->heap_id_length = (uint16_t)readValue(reader, 2);",
          "378:   fractalheap->encoded_length = (uint16_t)readValue(reader, 2);",
          "379:   if (fractalheap->encoded_length > 0x8000)",
          "380:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "381:   fractalheap->flags = (uint8_t)fgetc(reader->fhd);",
          "382:   fractalheap->maximum_size = (uint32_t)readValue(reader, 4);",
          "384:   fractalheap->next_huge_object_id =",
          "385:       readValue(reader, reader->superblock.size_of_lengths);",
          "386:   fractalheap->btree_address_of_huge_objects =",
          "387:       readValue(reader, reader->superblock.size_of_offsets);",
          "388:   fractalheap->free_space =",
          "389:       readValue(reader, reader->superblock.size_of_lengths);",
          "390:   fractalheap->address_free_space =",
          "391:       readValue(reader, reader->superblock.size_of_offsets);",
          "392:   fractalheap->amount_managed_space =",
          "393:       readValue(reader, reader->superblock.size_of_lengths);",
          "394:   fractalheap->amount_allocated_space =",
          "395:       readValue(reader, reader->superblock.size_of_lengths);",
          "396:   fractalheap->offset_managed_space =",
          "397:       readValue(reader, reader->superblock.size_of_lengths);",
          "398:   fractalheap->number_managed_objects =",
          "399:       readValue(reader, reader->superblock.size_of_lengths);",
          "400:   fractalheap->size_huge_objects =",
          "401:       readValue(reader, reader->superblock.size_of_lengths);",
          "402:   fractalheap->number_huge_objects =",
          "403:       readValue(reader, reader->superblock.size_of_lengths);",
          "404:   fractalheap->size_tiny_objects =",
          "405:       readValue(reader, reader->superblock.size_of_lengths);",
          "406:   fractalheap->number_tiny_objects =",
          "407:       readValue(reader, reader->superblock.size_of_lengths);",
          "409:   fractalheap->table_width = (uint16_t)readValue(reader, 2);",
          "411:   fractalheap->starting_block_size =",
          "412:       readValue(reader, reader->superblock.size_of_lengths);",
          "413:   fractalheap->maximum_direct_block_size =",
          "414:       readValue(reader, reader->superblock.size_of_lengths);",
          "416:   fractalheap->maximum_heap_size = (uint16_t)readValue(reader, 2);",
          "417:   fractalheap->starting_row = (uint16_t)readValue(reader, 2);",
          "419:   fractalheap->address_of_root_block =",
          "420:       readValue(reader, reader->superblock.size_of_offsets);",
          "422:   fractalheap->current_row = (uint16_t)readValue(reader, 2);",
          "424:   if (fractalheap->encoded_length > 0) {",
          "426:     fractalheap->size_of_filtered_block =",
          "427:         readValue(reader, reader->superblock.size_of_lengths);",
          "428:     fractalheap->fitler_mask = (uint32_t)readValue(reader, 4);",
          "430:     fractalheap->filter_information = malloc(fractalheap->encoded_length);",
          "431:     if (!fractalheap->filter_information)",
          "432:       return MYSOFA_NO_MEMORY;",
          "434:     if (fread(fractalheap->filter_information, 1, fractalheap->encoded_length,",
          "435:               reader->fhd) != fractalheap->encoded_length) {",
          "436:       free(fractalheap->filter_information);",
          "437:       return MYSOFA_READ_ERROR;",
          "438:     }",
          "439:   }",
          "442:     return MYSOFA_READ_ERROR;",
          "443:   }",
          "445:   if (fractalheap->number_huge_objects) {",
          "446:     log(\"cannot handle huge objects\\n\");",
          "447:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "448:   }",
          "450:   if (fractalheap->number_tiny_objects) {",
          "451:     log(\"cannot handle tiny objects\\n\");",
          "452:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "453:   }",
          "455:   if (validAddress(reader, fractalheap->address_of_root_block)) {",
          "457:     if (fseek(reader->fhd, fractalheap->address_of_root_block, SEEK_SET) < 0)",
          "458:       return errno;",
          "459:     if (fractalheap->current_row)",
          "460:       err = indirectblockRead(reader, dataobject, fractalheap,",
          "461:                               fractalheap->starting_block_size);",
          "462:     else {",
          "463:       err = directblockRead(reader, dataobject, fractalheap);",
          "464:     }",
          "465:     if (err)",
          "466:       return err;",
          "467:   }",
          "469:   return MYSOFA_OK;",
          "473:   free(fractalheap->filter_information);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "69f349cb09c81af6dd735741509655396ce6cb2d",
      "candidate_info": {
        "commit_hash": "69f349cb09c81af6dd735741509655396ce6cb2d",
        "repo": "hoene/libmysofa",
        "commit_url": "https://github.com/hoene/libmysofa/commit/69f349cb09c81af6dd735741509655396ce6cb2d",
        "files": [
          "src/hdf/btree.c",
          "src/hdf/dataobject.c",
          "src/hdf/fractalhead.c",
          "src/hdf/gcol.c"
        ],
        "message": "Addressed some more coverity issues",
        "before_after_code_files": [
          "src/hdf/btree.c||src/hdf/btree.c",
          "src/hdf/dataobject.c||src/hdf/dataobject.c",
          "src/hdf/fractalhead.c||src/hdf/fractalhead.c",
          "src/hdf/gcol.c||src/hdf/gcol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ],
          "candidate": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hdf/btree.c||src/hdf/btree.c": [
          "File: src/hdf/btree.c -> src/hdf/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:   uint32_t creation_order, hash_of_name;",
          "72:   uint64_t heap_id;",
          "76:   UNUSED(heap_id);",
          "77:   UNUSED(hash_of_name);",
          "",
          "[Removed Lines]",
          "74:   char buf[4];",
          "",
          "[Added Lines]",
          "74:   char buf[5];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     mylog(\"cannot read signature of BTLF\\n\");",
          "84:     return MYSOFA_INVALID_FORMAT;",
          "85:   }",
          "86:   mylog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "88:   if (fgetc(reader->fhd) != 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86:   buf[4]=0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "155: int btreeRead(struct READER *reader, struct BTREE *btree) {",
          "159:   if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"BTHD\", 4)) {",
          "160:     mylog(\"cannot read signature of BTHD\\n\");",
          "161:     return MYSOFA_INVALID_FORMAT;",
          "162:   }",
          "163:   mylog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "165:   if (fgetc(reader->fhd) != 0) {",
          "",
          "[Removed Lines]",
          "156:   char buf[4];",
          "",
          "[Added Lines]",
          "157:   char buf[5];",
          "164:   buf[4]=0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "216:   uint64_t address_of_left_sibling, address_of_right_sibling, start[4],",
          "217:       child_pointer, key, store;",
          "221:   UNUSED(node_level);",
          "222:   UNUSED(address_of_right_sibling);",
          "",
          "[Removed Lines]",
          "219:   char buf[4];",
          "",
          "[Added Lines]",
          "221:   char buf[5];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "233:     mylog(\"cannot read signature of TREE\\n\");",
          "234:     return MYSOFA_INVALID_FORMAT;",
          "235:   }",
          "236:   mylog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "238:   node_type = (uint8_t)fgetc(reader->fhd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:   buf[4]=0;",
          "",
          "---------------"
        ],
        "src/hdf/dataobject.c||src/hdf/dataobject.c": [
          "File: src/hdf/dataobject.c -> src/hdf/dataobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "309:           return MYSOFA_READ_ERROR;",
          "311:         c = readValue(reader, 4);",
          "313:         if (dimension != 0) {",
          "314:           mylog(\"COMPOUND v1 with dimension not supported\");",
          "315:           return MYSOFA_INVALID_FORMAT;",
          "",
          "[Removed Lines]",
          "312:         uint8_t dimension = fgetc(reader->fhd);",
          "",
          "[Added Lines]",
          "312:         int dimension = fgetc(reader->fhd);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1028: static int readOCHK(struct READER *reader, struct DATAOBJECT *dataobject,",
          "1029:                     uint64_t end) {",
          "1030:   int err;",
          "1034:   if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"OCHK\", 4)) {",
          "1035:     mylog(\"cannot read signature of OCHK\\n\");",
          "1036:     return MYSOFA_INVALID_FORMAT;",
          "1037:   }",
          "1038:   mylog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "",
          "[Removed Lines]",
          "1031:   char buf[4];",
          "",
          "[Added Lines]",
          "1031:   char buf[5];",
          "1038:   buf[4]=0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1049:                    char *name) {",
          "1050:   uint64_t size_of_chunk, end_of_messages;",
          "1051:   int err;",
          "1054:   memset(dataobject, 0, sizeof(*dataobject));",
          "1055:   dataobject->address = ftell(reader->fhd);",
          "",
          "[Removed Lines]",
          "1052:   char buf[4];",
          "",
          "[Added Lines]",
          "1053:   char buf[5];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1060:     mylog(\"cannot read signature of data object\\n\");",
          "1061:     return MYSOFA_INVALID_FORMAT;",
          "1062:   }",
          "1063:   mylog(\"%08\" PRIX64 \" %.4s\\n\", dataobject->address, buf);",
          "1065:   if (fgetc(reader->fhd) != 2) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1064:   buf[4]=0;",
          "",
          "---------------"
        ],
        "src/hdf/fractalhead.c||src/hdf/fractalhead.c": [
          "File: src/hdf/fractalhead.c -> src/hdf/fractalhead.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: static int directblockRead(struct READER *reader, struct DATAOBJECT *dataobject,",
          "21:                            struct FRACTALHEAP *fractalheap) {",
          "24:   int size, offset_size, length_size, err, len;",
          "25:   uint8_t typeandversion;",
          "26:   uint64_t unknown, heap_header_address, block_offset, block_size, offset,",
          "",
          "[Removed Lines]",
          "23:   char buf[4], *name, *value;",
          "",
          "[Added Lines]",
          "23:   char buf[5], *name, *value;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:     mylog(\"cannot read signature of fractal heap indirect block\\n\");",
          "45:     return MYSOFA_INVALID_FORMAT;",
          "46:   }",
          "47:   mylog(\"%08\" PRIX64 \" %.4s stack %d\\n\", (uint64_t)ftell(reader->fhd) - 4, buf,",
          "48:         reader->recursive_counter);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:   buf[4]=0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "359:       child_direct_block = 0, size_filtered, child_indirect_block;",
          "360:   long store;",
          "364:   UNUSED(size_filtered);",
          "365:   UNUSED(heap_header_address);",
          "",
          "[Removed Lines]",
          "362:   char buf[4];",
          "",
          "[Added Lines]",
          "363:   char buf[5];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "370:     mylog(\"cannot read signature of fractal heap indirect block\\n\");",
          "371:     return MYSOFA_INVALID_FORMAT;",
          "372:   }",
          "373:   mylog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "375:   if (fgetc(reader->fhd) != 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "374:   buf[4]=0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "475: int fractalheapRead(struct READER *reader, struct DATAOBJECT *dataobject,",
          "476:                     struct FRACTALHEAP *fractalheap) {",
          "477:   int err;",
          "481:   if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FRHP\", 4)) {",
          "482:     mylog(\"cannot read signature of fractal heap\\n\");",
          "483:     return MYSOFA_UNSUPPORTED_FORMAT;",
          "484:   }",
          "485:   mylog(\"%\" PRIX64 \" %.4s\\n\", (uint64_t)ftell(reader->fhd) - 4, buf);",
          "487:   if (fgetc(reader->fhd) != 0) {",
          "",
          "[Removed Lines]",
          "478:   char buf[4];",
          "",
          "[Added Lines]",
          "480:   char buf[5];",
          "487:   buf[4]=0;",
          "",
          "---------------"
        ],
        "src/hdf/gcol.c||src/hdf/gcol.c": [
          "File: src/hdf/gcol.c -> src/hdf/gcol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:   uint16_t reference_count, address;",
          "19:   uint64_t collection_size, end;",
          "20:   struct GCOL *gcol;",
          "23:   UNUSED(reference_count);",
          "",
          "[Removed Lines]",
          "21:   char buf[4];",
          "",
          "[Added Lines]",
          "21:   char buf[5];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27:     mylog(\"cannot read signature of global heap collection\\n\");",
          "28:     return MYSOFA_INVALID_FORMAT;",
          "29:   }",
          "31:   if (fgetc(reader->fhd) != 1) {",
          "32:     mylog(\"object GCOL must have version 1\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30:   buf[4]=0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "46a7e0065c573c9341ad85c390958294217465d4",
      "candidate_info": {
        "commit_hash": "46a7e0065c573c9341ad85c390958294217465d4",
        "repo": "hoene/libmysofa",
        "commit_url": "https://github.com/hoene/libmysofa/commit/46a7e0065c573c9341ad85c390958294217465d4",
        "files": [
          "src/hdf/dataobject.c",
          "src/hdf/fractalhead.c"
        ],
        "message": "Fixed recursive issue",
        "before_after_code_files": [
          "src/hdf/dataobject.c||src/hdf/dataobject.c",
          "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ],
          "candidate": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hdf/dataobject.c||src/hdf/dataobject.c": [
          "File: src/hdf/dataobject.c -> src/hdf/dataobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "622:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "624:  log(\" continue %08\" PRIX64 \" %08\" PRIX64 \"\\n\", offset, length);",
          "626:   return MYSOFA_UNSUPPORTED_FORMAT;",
          "627:  else",
          "628:   reader->recursive_counter++;",
          "",
          "[Removed Lines]",
          "625:  if(reader->recursive_counter >= 10)",
          "",
          "[Added Lines]",
          "625:  if(reader->recursive_counter >= 20)",
          "",
          "---------------"
        ],
        "src/hdf/fractalhead.c||src/hdf/fractalhead.c": [
          "File: src/hdf/fractalhead.c -> src/hdf/fractalhead.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  UNUSED(block_size);",
          "34:  UNUSED(block_offset);",
          "37:   return MYSOFA_INVALID_FORMAT;",
          "38:  else",
          "39:   reader->recursive_counter++;",
          "",
          "[Removed Lines]",
          "36:  if(reader->recursive_counter >= 10)",
          "",
          "[Added Lines]",
          "36:  if(reader->recursive_counter >= 20)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9068491217ee2de3066907f876b45ba0b00f9bb3",
      "candidate_info": {
        "commit_hash": "9068491217ee2de3066907f876b45ba0b00f9bb3",
        "repo": "hoene/libmysofa",
        "commit_url": "https://github.com/hoene/libmysofa/commit/9068491217ee2de3066907f876b45ba0b00f9bb3",
        "files": [
          "src/hdf/fractalhead.c"
        ],
        "message": "Reading attributes via H5T_STRING",
        "before_after_code_files": [
          "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ],
          "candidate": [
            "src/hdf/fractalhead.c||src/hdf/fractalhead.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hdf/fractalhead.c||src/hdf/fractalhead.c": [
          "File: src/hdf/fractalhead.c -> src/hdf/fractalhead.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   if (reader->recursive_counter >= 20) {",
          "35:     mylog(\"recursive problem\");",
          "36:     return MYSOFA_INVALID_FORMAT;",
          "39:     reader->recursive_counter++;",
          "",
          "[Removed Lines]",
          "37:   }",
          "38:   else",
          "",
          "[Added Lines]",
          "37:   } else",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:     return MYSOFA_INVALID_FORMAT;",
          "45:   }",
          "46:   mylog(\"%08\" PRIX64 \" %.4s stack %d\\n\", (uint64_t)ftell(reader->fhd) - 4, buf,",
          "49:   if (fgetc(reader->fhd) != 0) {",
          "50:     mylog(\"object FHDB must have version 0\\n\");",
          "",
          "[Removed Lines]",
          "47:       reader->recursive_counter);",
          "",
          "[Added Lines]",
          "46:         reader->recursive_counter);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78:    00 08 00  |........SOFA....| 00003e40  08 00 04 00 00 56 65 72  73 69 6f 6e",
          "79:    00 13 00 00  |.....Version....| 00003e50  00 03 00 00 00 02 00 00  00 30 2e",
          "80:    36 03 00 10 00  |.........0.6....| 00003e60  08 00 04 00 00 53 4f 46  41 43",
          "",
          "[Removed Lines]",
          "75:    |.FHDB.@.........| 00003e10  00 00 00 83 8d ac f6 >03  00 0c 00 08 00 04 00",
          "76:    00  |................| 00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00 13 00",
          "77:    00 00  |Conventions.....| 00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03",
          "",
          "[Added Lines]",
          "74:    |.FHDB.@.........|",
          "76:    00003e10  00 00 00 83 8d ac f6",
          "78:    >03  00 0c 00 08 00 04 00 00  |................|",
          "80:    00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00",
          "82:    13 00 00 00  |Conventions.....|",
          "84:    00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "85:    6f 6e 73 56 65 72 73  |AConventionsVers| 00003eb0  69 6f 6e 00 13 00 00 00 03",
          "86:    00 00 00 02 00 00 00  |ion.............|",
          "89:   do {",
          "90:     typeandversion = (uint8_t)fgetc(reader->fhd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96: 00002730  00 00 00 00 00 00 00 46  48 44 42 00 97 02 00 00  |.......FHDB.....|",
          "97: 00002740  00 00 00 00 00 00 00 00  00 99 b9 5c d8",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "93:     if (offset > 0x10000000 || length > 0x10000000)",
          "94:       return MYSOFA_UNSUPPORTED_FORMAT;",
          "100:     if (typeandversion == 3) {",
          "",
          "[Removed Lines]",
          "96:     mylog(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\", typeandversion, offset, length,",
          "97:         ftell(reader->fhd));",
          "",
          "[Added Lines]",
          "108:     mylog(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\", typeandversion, offset,",
          "109:           length, ftell(reader->fhd) - 1 - offset_size - length_size);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "157:       mylog(\" %s = %s\\n\", name, value);",
          "159:       attr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));",
          "160:       attr->name = name;",
          "161:       attr->value = value;",
          "162:       attr->next = dataobject->attributes;",
          "163:       dataobject->attributes = attr;",
          "165:     } else if (typeandversion == 1) {",
          "218:       }",
          "222:     } else if (typeandversion != 0) {",
          "",
          "[Removed Lines]",
          "169:       unknown = readValue(reader, 6);",
          "170:       if (unknown) {",
          "171:         mylog(\"FHDB type 1 unsupported values\\n\");",
          "172:         return MYSOFA_UNSUPPORTED_FORMAT;",
          "173:       }",
          "175:       len = fgetc(reader->fhd);",
          "176:       if (len < 0)",
          "177:         return MYSOFA_READ_ERROR;",
          "178:       assert(len < 0x100);",
          "180:       if (!(name = malloc(len + 1)))",
          "181:         return MYSOFA_NO_MEMORY;",
          "182:       if (fread(name, 1, len, reader->fhd) != len) {",
          "183:         free(name);",
          "184:         return MYSOFA_READ_ERROR;",
          "185:       }",
          "186:       name[len] = 0;",
          "188:       heap_header_address =",
          "189:           readValue(reader, reader->superblock.size_of_offsets);",
          "191:       mylog(\"fractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64",
          "192:           \"\\n\",",
          "193:           length, name, heap_header_address);",
          "195:       dir = malloc(sizeof(struct DIR));",
          "196:       if (!dir) {",
          "197:         free(name);",
          "198:         return MYSOFA_NO_MEMORY;",
          "199:       }",
          "200:       memset(dir, 0, sizeof(*dir));",
          "202:       dir->next = dataobject->directory;",
          "203:       dataobject->directory = dir;",
          "205:       store = ftell(reader->fhd);",
          "206:       if (fseek(reader->fhd, heap_header_address, SEEK_SET)) {",
          "207:         free(name);",
          "208:         return errno;",
          "209:       }",
          "211:       err = dataobjectRead(reader, &dir->dataobject, name);",
          "212:       if (err) {",
          "213:         return err;",
          "214:       }",
          "216:       if (store < 0) {",
          "217:         return errno;",
          "219:       if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "220:         return errno;",
          "",
          "[Added Lines]",
          "172:       if (attr == NULL) {",
          "173:         free(value);",
          "174:         free(name);",
          "175:         return MYSOFA_NO_MEMORY;",
          "176:       }",
          "185:       unknown = readValue(reader, 4);",
          "186:       switch (unknown) {",
          "187:       case 0:",
          "189:         unknown = readValue(reader, 2);",
          "190:         assert(unknown == 0x0000);",
          "192:         len = fgetc(reader->fhd);",
          "193:         if (len < 0)",
          "194:           return MYSOFA_READ_ERROR;",
          "195:         assert(len < 0x100);",
          "197:         if (!(name = malloc(len + 1)))",
          "198:           return MYSOFA_NO_MEMORY;",
          "199:         if (fread(name, 1, len, reader->fhd) != len) {",
          "200:           free(name);",
          "201:           return MYSOFA_READ_ERROR;",
          "202:         }",
          "203:         name[len] = 0;",
          "205:         heap_header_address =",
          "206:             readValue(reader, reader->superblock.size_of_offsets);",
          "208:         mylog(\"fractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64",
          "209:               \"\\n\",",
          "210:               length, name, heap_header_address);",
          "212:         dir = malloc(sizeof(struct DIR));",
          "213:         if (!dir) {",
          "214:           free(name);",
          "215:           return MYSOFA_NO_MEMORY;",
          "216:         }",
          "217:         memset(dir, 0, sizeof(*dir));",
          "219:         dir->next = dataobject->directory;",
          "220:         dataobject->directory = dir;",
          "222:         store = ftell(reader->fhd);",
          "223:         if (fseek(reader->fhd, heap_header_address, SEEK_SET)) {",
          "224:           free(name);",
          "225:           return errno;",
          "226:         }",
          "228:         err = dataobjectRead(reader, &dir->dataobject, name);",
          "229:         if (err) {",
          "230:           return err;",
          "231:         }",
          "233:         if (store < 0) {",
          "234:           return errno;",
          "235:         }",
          "236:         if (fseek(reader->fhd, store, SEEK_SET) < 0)",
          "237:           return errno;",
          "238:         break;",
          "239:       case 0x00080008:",
          "242:             > 01 00 0e  |...........\\....|",
          "243:     00002750  00 08 00 08 00 5f 4e 43  50 72 6f 70 65 72 74 69",
          "244:     |....._NCProperti| 00002760  65 73 00 00 00 13 00 00  00 37 00 00 00 01 00",
          "245:     00  |es.......7......|",
          "247:     00002770  00 00 00 00 00 76 65 72  73 69 6f 6e 3d 31 7c 6e",
          "248:     |.....version=1|n| 00002780  65 74 63 64 66 6c 69 62  76 65 72 73 69 6f 6e",
          "249:     3d  |etcdflibversion=| 00002790  34 2e 36 2e 31 7c 68 64  66 35 6c 69 62 76",
          "250:     65 72  |4.6.1|hdf5libver| 000027a0  73 69 6f 6e 3d 31 2e 31  30 2e 34 00 01",
          "251:     00 0c 00  |sion=1.10.4.....| 000027b0  08 00 08 00 43 6f 6e 76  65 6e 74 69",
          "252:     6f 6e 73 00  |....Conventions.| 000027c0  00 00 00 00 13 00 00 00  04 00 00",
          "253:     00 01 00 00 00  |................| 000027d0  00 00 00 00 53 4f 46 41  01 00",
          "254:     08 00 08 00 08 00  |....SOFA........| 000027e0  56 65 72 73 69 6f 6e 00  13",
          "255:     00 00 00 03 00 00 00  |Version.........| 000027f0  01 00 00 00 00 00 00 00",
          "256:     31 2e 30 01 00 10 00 08  |........1.0.....| 00002800  00 08 00 53 4f 46 41",
          "257:     43  6f 6e 76 65 6e 74 69 6f  |...SOFAConventio| 00002810  6e 73 00 13 00 00",
          "258:     00 13  00 00 00 01 00 00 00 00  |ns..............| 00002820  00 00 00 53 69",
          "259:     6d 70 6c  65 46 72 65 65 46 69 65  |...SimpleFreeFie|",
          "261:         if (!(name = malloc(100)))",
          "262:           return MYSOFA_NO_MEMORY;",
          "263:         len = -1;",
          "264:         for (int i = 0; i < 100; i++) {",
          "265:           int c = fgetc(reader->fhd);",
          "266:           if (c < 0 || i == 100 - 1) {",
          "267:             free(name);",
          "268:             return MYSOFA_READ_ERROR;",
          "269:           }",
          "270:           name[i] = c;",
          "271:           if (len < 0 && c == 0)",
          "272:             len = i;",
          "273:           if (c == 0x13)",
          "274:             break;",
          "275:         }",
          "276:         name = realloc(name, len + 1);",
          "277:         mylog(\"name %d %s\\n\", len, name);",
          "279:         if (readValue(reader, 3) != 0x000000) {",
          "280:           mylog(\"FHDB type 3 unsupported values\");",
          "281:           free(name);",
          "282:           return MYSOFA_UNSUPPORTED_FORMAT;",
          "283:         }",
          "285:         len = (int)readValue(reader, 4);",
          "286:         if (len > 0x1000 || len < 0) {",
          "287:           mylog(\"FHDB type 3 unsupported values\");",
          "288:           free(name);",
          "289:           return MYSOFA_UNSUPPORTED_FORMAT;",
          "290:         }",
          "292:         unknown = (int)readValue(reader, 8);",
          "293:         if (unknown != 0x00000001) {",
          "294:           mylog(\"FHDB type 3 unsupported values\");",
          "295:           free(name);",
          "296:           return MYSOFA_UNSUPPORTED_FORMAT;",
          "297:         }",
          "298:         if (!(value = malloc(len + 1))) {",
          "299:           free(name);",
          "300:           return MYSOFA_NO_MEMORY;",
          "301:         }",
          "302:         if (fread(value, 1, len, reader->fhd) != len) {",
          "303:           free(value);",
          "304:           free(name);",
          "305:           return MYSOFA_READ_ERROR;",
          "306:         }",
          "307:         value[len] = 0;",
          "309:         mylog(\" %s = %s\\n\", name, value);",
          "311:         attr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));",
          "312:         if (attr == NULL) {",
          "313:           free(value);",
          "314:           free(name);",
          "315:           return MYSOFA_NO_MEMORY;",
          "316:         }",
          "318:         attr->name = name;",
          "319:         attr->value = value;",
          "320:         attr->next = dataobject->attributes;",
          "321:         dataobject->attributes = attr;",
          "322:         break;",
          "324:       default:",
          "325:         mylog(\"FHDB type 1 unsupported values %08X %lX\\n\", unknown,",
          "326:               ftell(reader->fhd) - 4);",
          "327:         return MYSOFA_UNSUPPORTED_FORMAT;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
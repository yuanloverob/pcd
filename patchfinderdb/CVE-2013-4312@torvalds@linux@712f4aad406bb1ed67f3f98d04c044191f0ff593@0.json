{
  "cve_id": "CVE-2013-4312",
  "cve_desc": "The Linux kernel before 4.4.1 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by sending each descriptor over a UNIX socket before closing it, related to net/unix/af_unix.c and net/unix/garbage.c.",
  "repo": "torvalds/linux",
  "patch_hash": "712f4aad406bb1ed67f3f98d04c044191f0ff593",
  "patch_info": {
    "commit_hash": "712f4aad406bb1ed67f3f98d04c044191f0ff593",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/712f4aad406bb1ed67f3f98d04c044191f0ff593",
    "files": [
      "include/linux/sched.h",
      "net/unix/af_unix.c",
      "net/unix/garbage.c"
    ],
    "message": "unix: properly account for FDs passed over unix sockets\n\nIt is possible for a process to allocate and accumulate far more FDs than\nthe process' limit by sending them over a unix socket then closing them\nto keep the process' fd count low.\n\nThis change addresses this problem by keeping track of the number of FDs\nin flight per user and preventing non-privileged processes from having\nmore FDs in flight than their configured FD limit.\n\nReported-by: socketpair@gmail.com\nReported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nMitigates: CVE-2013-4312 (Linux 2.0+)\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "include/linux/sched.h||include/linux/sched.h",
      "net/unix/af_unix.c||net/unix/af_unix.c",
      "net/unix/garbage.c||net/unix/garbage.c"
    ]
  },
  "patch_diff": {
    "include/linux/sched.h||include/linux/sched.h": [
      "File: include/linux/sched.h -> include/linux/sched.h"
    ],
    "net/unix/af_unix.c||net/unix/af_unix.c": [
      "File: net/unix/af_unix.c -> net/unix/af_unix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1513:  sock_wfree(skb);",
      "1514: }",
      "1516: #define MAX_RECURSION_LEVEL 4",
      "1518: static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1522: static inline bool too_many_unix_fds(struct task_struct *p)",
      "1523: {",
      "1524:  struct user_struct *user = current_user();",
      "1526:  if (unlikely(user->unix_inflight > task_rlimit(p, RLIMIT_NOFILE)))",
      "1527:   return !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);",
      "1528:  return false;",
      "1529: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1521:  unsigned char max_level = 0;",
      "1522:  int unix_sock_count = 0;",
      "1524:  for (i = scm->fp->count - 1; i >= 0; i--) {",
      "1525:   struct sock *sk = unix_get_socket(scm->fp->fp[i]);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1539:  if (too_many_unix_fds(current))",
      "1540:   return -ETOOMANYREFS;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1542:  if (!UNIXCB(skb).fp)",
      "1543:   return -ENOMEM;",
      "1549:  return max_level;",
      "1550: }",
      "",
      "[Removed Lines]",
      "1545:  if (unix_sock_count) {",
      "1546:   for (i = scm->fp->count - 1; i >= 0; i--)",
      "1547:    unix_inflight(scm->fp->fp[i]);",
      "1548:  }",
      "",
      "[Added Lines]",
      "1563:  for (i = scm->fp->count - 1; i >= 0; i--)",
      "1564:   unix_inflight(scm->fp->fp[i]);",
      "",
      "---------------"
    ],
    "net/unix/garbage.c||net/unix/garbage.c": [
      "File: net/unix/garbage.c -> net/unix/garbage.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "120: {",
      "121:  struct sock *s = unix_get_socket(fp);",
      "123:  if (s) {",
      "124:   struct unix_sock *u = unix_sk(s);",
      "128:   if (atomic_long_inc_return(&u->inflight) == 1) {",
      "129:    BUG_ON(!list_empty(&u->link));",
      "130:    list_add_tail(&u->link, &gc_inflight_list);",
      "",
      "[Removed Lines]",
      "126:   spin_lock(&unix_gc_lock);",
      "",
      "[Added Lines]",
      "123:  spin_lock(&unix_gc_lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "132:    BUG_ON(list_empty(&u->link));",
      "133:   }",
      "134:   unix_tot_inflight++;",
      "136:  }",
      "137: }",
      "139: void unix_notinflight(struct file *fp)",
      "140: {",
      "141:  struct sock *s = unix_get_socket(fp);",
      "143:  if (s) {",
      "144:   struct unix_sock *u = unix_sk(s);",
      "147:   BUG_ON(list_empty(&u->link));",
      "149:   if (atomic_long_dec_and_test(&u->inflight))",
      "150:    list_del_init(&u->link);",
      "151:   unix_tot_inflight--;",
      "153:  }",
      "154: }",
      "156: static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),",
      "",
      "[Removed Lines]",
      "135:   spin_unlock(&unix_gc_lock);",
      "146:   spin_lock(&unix_gc_lock);",
      "152:   spin_unlock(&unix_gc_lock);",
      "",
      "[Added Lines]",
      "136:  fp->f_cred->user->unix_inflight++;",
      "137:  spin_unlock(&unix_gc_lock);",
      "144:  spin_lock(&unix_gc_lock);",
      "155:  fp->f_cred->user->unix_inflight--;",
      "156:  spin_unlock(&unix_gc_lock);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "415e3d3e90ce9e18727e8843ae343eda5a58fad6",
      "candidate_info": {
        "commit_hash": "415e3d3e90ce9e18727e8843ae343eda5a58fad6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6",
        "files": [
          "include/net/af_unix.h",
          "include/net/scm.h",
          "net/core/scm.c",
          "net/unix/af_unix.c",
          "net/unix/garbage.c"
        ],
        "message": "unix: correctly track in-flight fds in sending process user_struct\n\nThe commit referenced in the Fixes tag incorrectly accounted the number\nof in-flight fds over a unix domain socket to the original opener\nof the file-descriptor. This allows another process to arbitrary\ndeplete the original file-openers resource limit for the maximum of\nopen files. Instead the sending processes and its struct cred should\nbe credited.\n\nTo do so, we add a reference counted struct user_struct pointer to the\nscm_fp_list and use it to account for the number of inflight unix fds.\n\nFixes: 712f4aad406bb1 (\"unix: properly account for FDs passed over unix sockets\")\nReported-by: David Herrmann <dh.herrmann@gmail.com>\nCc: David Herrmann <dh.herrmann@gmail.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/af_unix.h||include/net/af_unix.h",
          "include/net/scm.h||include/net/scm.h",
          "net/core/scm.c||net/core/scm.c",
          "net/unix/af_unix.c||net/unix/af_unix.c",
          "net/unix/garbage.c||net/unix/garbage.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/unix/af_unix.c||net/unix/af_unix.c",
            "net/unix/garbage.c||net/unix/garbage.c"
          ],
          "candidate": [
            "net/unix/af_unix.c||net/unix/af_unix.c",
            "net/unix/garbage.c||net/unix/garbage.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/af_unix.h||include/net/af_unix.h": [
          "File: include/net/af_unix.h -> include/net/af_unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include <linux/mutex.h>",
          "7: #include <net/sock.h>",
          "11: void unix_gc(void);",
          "12: void wait_for_unix_gc(void);",
          "13: struct sock *unix_get_socket(struct file *filp);",
          "",
          "[Removed Lines]",
          "9: void unix_inflight(struct file *fp);",
          "10: void unix_notinflight(struct file *fp);",
          "",
          "[Added Lines]",
          "9: void unix_inflight(struct user_struct *user, struct file *fp);",
          "10: void unix_notinflight(struct user_struct *user, struct file *fp);",
          "",
          "---------------"
        ],
        "include/net/scm.h||include/net/scm.h": [
          "File: include/net/scm.h -> include/net/scm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: struct scm_fp_list {",
          "22:  short   count;",
          "23:  short   max;",
          "24:  struct file  *fp[SCM_MAX_FD];",
          "25: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24:  struct user_struct *user;",
          "",
          "---------------"
        ],
        "net/core/scm.c||net/core/scm.c": [
          "File: net/core/scm.c -> net/core/scm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:   fpl->count = 0;",
          "89:   fpl->max = SCM_MAX_FD;",
          "90:  }",
          "91:  fpp = &fpl->fp[fpl->count];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90:   fpl->user = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:   fpl->count++;",
          "109:  }",
          "110:  return num;",
          "111: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112:  if (!fpl->user)",
          "113:   fpl->user = get_uid(current_user());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:   scm->fp = NULL;",
          "120:   for (i=fpl->count-1; i>=0; i--)",
          "121:    fput(fpl->fp[i]);",
          "122:   kfree(fpl);",
          "123:  }",
          "124: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "127:   free_uid(fpl->user);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "336:   for (i = 0; i < fpl->count; i++)",
          "337:    get_file(fpl->fp[i]);",
          "338:   new_fpl->max = new_fpl->count;",
          "339:  }",
          "340:  return new_fpl;",
          "341: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345:   new_fpl->user = get_uid(fpl->user);",
          "",
          "---------------"
        ],
        "net/unix/af_unix.c||net/unix/af_unix.c": [
          "File: net/unix/af_unix.c -> net/unix/af_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1496:  UNIXCB(skb).fp = NULL;",
          "1498:  for (i = scm->fp->count-1; i >= 0; i--)",
          "1500: }",
          "1502: static void unix_destruct_scm(struct sk_buff *skb)",
          "",
          "[Removed Lines]",
          "1499:   unix_notinflight(scm->fp->fp[i]);",
          "",
          "[Added Lines]",
          "1499:   unix_notinflight(scm->fp->user, scm->fp->fp[i]);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1561:   return -ENOMEM;",
          "1563:  for (i = scm->fp->count - 1; i >= 0; i--)",
          "1565:  return max_level;",
          "1566: }",
          "",
          "[Removed Lines]",
          "1564:   unix_inflight(scm->fp->fp[i]);",
          "",
          "[Added Lines]",
          "1564:   unix_inflight(scm->fp->user, scm->fp->fp[i]);",
          "",
          "---------------"
        ],
        "net/unix/garbage.c||net/unix/garbage.c": [
          "File: net/unix/garbage.c -> net/unix/garbage.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "120: {",
          "121:  struct sock *s = unix_get_socket(fp);",
          "",
          "[Removed Lines]",
          "119: void unix_inflight(struct file *fp)",
          "",
          "[Added Lines]",
          "119: void unix_inflight(struct user_struct *user, struct file *fp)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133:   }",
          "134:   unix_tot_inflight++;",
          "135:  }",
          "137:  spin_unlock(&unix_gc_lock);",
          "138: }",
          "141: {",
          "142:  struct sock *s = unix_get_socket(fp);",
          "",
          "[Removed Lines]",
          "136:  fp->f_cred->user->unix_inflight++;",
          "140: void unix_notinflight(struct file *fp)",
          "",
          "[Added Lines]",
          "136:  user->unix_inflight++;",
          "140: void unix_notinflight(struct user_struct *user, struct file *fp)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "152:    list_del_init(&u->link);",
          "153:   unix_tot_inflight--;",
          "154:  }",
          "156:  spin_unlock(&unix_gc_lock);",
          "157: }",
          "",
          "[Removed Lines]",
          "155:  fp->f_cred->user->unix_inflight--;",
          "",
          "[Added Lines]",
          "155:  user->unix_inflight--;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d1ab39f17f8653021620d0355ee1cd24d7442a4f",
      "candidate_info": {
        "commit_hash": "d1ab39f17f8653021620d0355ee1cd24d7442a4f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d1ab39f17f8653021620d0355ee1cd24d7442a4f",
        "files": [
          "net/unix/garbage.c"
        ],
        "message": "net: unix: garbage: fixed several comment and whitespace style issues\n\nfixed several comment and whitespace style issues\n\nSigned-off-by: Jason Eastman <eastman.jason.linux@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/unix/garbage.c||net/unix/garbage.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/unix/garbage.c||net/unix/garbage.c"
          ],
          "candidate": [
            "net/unix/garbage.c||net/unix/garbage.c"
          ]
        }
      },
      "candidate_diff": {
        "net/unix/garbage.c||net/unix/garbage.c": [
          "File: net/unix/garbage.c -> net/unix/garbage.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "203: static void scan_children(struct sock *x, void (*func)(struct unix_sock *),",
          "204:      struct sk_buff_head *hitlist)",
          "205: {",
          "207:   scan_inflight(x, func, hitlist);",
          "209:   struct sk_buff *skb;",
          "210:   struct sk_buff *next;",
          "211:   struct unix_sock *u;",
          "212:   LIST_HEAD(embryos);",
          "218:   spin_lock(&x->sk_receive_queue.lock);",
          "219:   skb_queue_walk_safe(&x->sk_receive_queue, skb, next) {",
          "220:    u = unix_sk(skb->sk);",
          "226:    BUG_ON(!list_empty(&u->link));",
          "",
          "[Removed Lines]",
          "206:  if (x->sk_state != TCP_LISTEN)",
          "208:  else {",
          "",
          "[Added Lines]",
          "201:  if (x->sk_state != TCP_LISTEN) {",
          "203:  } else {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-1573",
  "cve_desc": "The nft_flush_table function in net/netfilter/nf_tables_api.c in the Linux kernel before 3.18.5 mishandles the interaction between cross-chain jumps and ruleset flushes, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability.",
  "repo": "torvalds/linux",
  "patch_hash": "a2f18db0c68fec96631c10cad9384c196e9008ac",
  "patch_info": {
    "commit_hash": "a2f18db0c68fec96631c10cad9384c196e9008ac",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a2f18db0c68fec96631c10cad9384c196e9008ac",
    "files": [
      "net/netfilter/nf_tables_api.c"
    ],
    "message": "netfilter: nf_tables: fix flush ruleset chain dependencies\n\nJumping between chains doesn't mix well with flush ruleset. Rules\nfrom a different chain and set elements may still refer to us.\n\n[  353.373791] ------------[ cut here ]------------\n[  353.373845] kernel BUG at net/netfilter/nf_tables_api.c:1159!\n[  353.373896] invalid opcode: 0000 [#1] SMP\n[  353.373942] Modules linked in: intel_powerclamp uas iwldvm iwlwifi\n[  353.374017] CPU: 0 PID: 6445 Comm: 31c3.nft Not tainted 3.18.0 #98\n[  353.374069] Hardware name: LENOVO 5129CTO/5129CTO, BIOS 6QET47WW (1.17 ) 07/14/2010\n[...]\n[  353.375018] Call Trace:\n[  353.375046]  [<ffffffff81964c31>] ? nf_tables_commit+0x381/0x540\n[  353.375101]  [<ffffffff81949118>] nfnetlink_rcv+0x3d8/0x4b0\n[  353.375150]  [<ffffffff81943fc5>] netlink_unicast+0x105/0x1a0\n[  353.375200]  [<ffffffff8194438e>] netlink_sendmsg+0x32e/0x790\n[  353.375253]  [<ffffffff818f398e>] sock_sendmsg+0x8e/0xc0\n[  353.375300]  [<ffffffff818f36b9>] ? move_addr_to_kernel.part.20+0x19/0x70\n[  353.375357]  [<ffffffff818f44f9>] ? move_addr_to_kernel+0x19/0x30\n[  353.375410]  [<ffffffff819016d2>] ? verify_iovec+0x42/0xd0\n[  353.375459]  [<ffffffff818f3e10>] ___sys_sendmsg+0x3f0/0x400\n[  353.375510]  [<ffffffff810615fa>] ? native_sched_clock+0x2a/0x90\n[  353.375563]  [<ffffffff81176697>] ? acct_account_cputime+0x17/0x20\n[  353.375616]  [<ffffffff8110dc78>] ? account_user_time+0x88/0xa0\n[  353.375667]  [<ffffffff818f4bbd>] __sys_sendmsg+0x3d/0x80\n[  353.375719]  [<ffffffff81b184f4>] ? int_check_syscall_exit_work+0x34/0x3d\n[  353.375776]  [<ffffffff818f4c0d>] SyS_sendmsg+0xd/0x20\n[  353.375823]  [<ffffffff81b1826d>] system_call_fastpath+0x16/0x1b\n\nRelease objects in this order: rules -> sets -> chains -> tables, to\nmake sure no references to chains are held anymore.\n\nReported-by: Asbjoern Sloth Toennesen <asbjorn@asbjorn.biz>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "before_after_code_files": [
      "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c"
    ]
  },
  "patch_diff": {
    "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c": [
      "File: net/netfilter/nf_tables_api.c -> net/netfilter/nf_tables_api.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "713:  struct nft_chain *chain, *nc;",
      "714:  struct nft_set *set, *ns;",
      "717:   ctx->chain = chain;",
      "719:   err = nft_delrule_by_chain(ctx);",
      "720:   if (err < 0)",
      "721:    goto out;",
      "726:  }",
      "728:  list_for_each_entry_safe(set, ns, &ctx->table->sets, list) {",
      "",
      "[Removed Lines]",
      "716:  list_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {",
      "723:   err = nft_delchain(ctx);",
      "724:   if (err < 0)",
      "725:    goto out;",
      "",
      "[Added Lines]",
      "716:  list_for_each_entry(chain, &ctx->table->chains, list) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "735:    goto out;",
      "736:  }",
      "738:  err = nft_deltable(ctx);",
      "739: out:",
      "740:  return err;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "734:  list_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {",
      "735:   ctx->chain = chain;",
      "737:   err = nft_delchain(ctx);",
      "738:   if (err < 0)",
      "739:    goto out;",
      "740:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5fb694f96e7c19e66b1c55124b98812e32e3efa5",
      "candidate_info": {
        "commit_hash": "5fb694f96e7c19e66b1c55124b98812e32e3efa5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5fb694f96e7c19e66b1c55124b98812e32e3efa5",
        "files": [
          "drivers/usb/gadget/udc/atmel_usba_udc.c"
        ],
        "message": "usb: gadget: udc: atmel: fix possible oops when unloading module\n\nWhen unloading the module 'g_hid.ko', the urb request will be dequeued and the\ncompletion routine will be excuted. If there is no urb packet, the urb request\nwill not be added to the endpoint queue and the completion routine pointer in\nurb request is NULL.\n\nAccessing to this NULL function pointer will cause the Oops issue reported\nbelow.\n\nAdd the code to check if the urb request is in the endpoint queue\nor not. If the urb request is not in the endpoint queue, a negative\nerror code will be returned.\n\nHere is the Oops log:\n\nUnable to handle kernel NULL pointer dereference at virtual address 00000000\npgd = dedf0000\n[00000000] *pgd=3ede5831, *pte=00000000, *ppte=00000000\nInternal error: Oops: 80000007 [#1] ARM\nModules linked in: g_hid(-) usb_f_hid libcomposite\nCPU: 0 PID: 923 Comm: rmmod Not tainted 3.18.0+ #2\nHardware name: Atmel SAMA5 (Device Tree)\ntask: df6b1100 ti: dedf6000 task.ti: dedf6000\nPC is at 0x0\nLR is at usb_gadget_giveback_request+0xc/0x10\npc : [<00000000>]    lr : [<c02ace88>]    psr: 60000093\nsp : dedf7eb0  ip : df572634  fp : 00000000\nr10: 00000000  r9 : df52e210  r8 : 60000013\nr7 : df6a9858  r6 : df52e210  r5 : df6a9858  r4 : df572600\nr3 : 00000000  r2 : ffffff98  r1 : df572600  r0 : df6a9868\nFlags: nZCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user\nControl: 10c53c7d  Table: 3edf0059  DAC: 00000015\nProcess rmmod (pid: 923, stack limit = 0xdedf6230)\nStack: (0xdedf7eb0 to 0xdedf8000)\n7ea0:                                     00000000 c02adbbc df572580 deced608\n7ec0: df572600 df6a9868 df572634 c02aed3c df577c00 c01b8608 00000000 df6be27c\n7ee0: 00200200 00100100 bf0162f4 c000e544 dedf6000 00000000 00000000 bf010c00\n7f00: bf0162cc bf00159c 00000000 df572980 df52e218 00000001 df5729b8 bf0031d0\n[..]\n[<c02ace88>] (usb_gadget_giveback_request) from [<c02adbbc>] (request_complete+0x64/0x88)\n[<c02adbbc>] (request_complete) from [<c02aed3c>] (usba_ep_dequeue+0x70/0x128)\n[<c02aed3c>] (usba_ep_dequeue) from [<bf010c00>] (hidg_unbind+0x50/0x7c [usb_f_hid])\n[<bf010c00>] (hidg_unbind [usb_f_hid]) from [<bf00159c>] (remove_config.isra.6+0x98/0x9c [libcomposite])\n[<bf00159c>] (remove_config.isra.6 [libcomposite]) from [<bf0031d0>] (__composite_unbind+0x34/0x98 [libcomposite])\n[<bf0031d0>] (__composite_unbind [libcomposite]) from [<c02acee0>] (usb_gadget_remove_driver+0x50/0x78)\n[<c02acee0>] (usb_gadget_remove_driver) from [<c02ad570>] (usb_gadget_unregister_driver+0x64/0x94)\n[<c02ad570>] (usb_gadget_unregister_driver) from [<bf0160c0>] (hidg_cleanup+0x10/0x34 [g_hid])\n[<bf0160c0>] (hidg_cleanup [g_hid]) from [<c0056748>] (SyS_delete_module+0x118/0x19c)\n[<c0056748>] (SyS_delete_module) from [<c000e3c0>] (ret_fast_syscall+0x0/0x30)\nCode: bad PC value\n\nSigned-off-by: Songjun Wu <songjun.wu@atmel.com>\n[nicolas.ferre@atmel.com: reworked the commit message]\nSigned-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>\nFixes: 914a3f3b3754 (\"USB: add atmel_usba_udc driver\")\nCc: <stable@vger.kernel.org> # 2.6.x-ish\nSigned-off-by: Felipe Balbi <balbi@ti.com>",
        "before_after_code_files": [
          "drivers/usb/gadget/udc/atmel_usba_udc.c||drivers/usb/gadget/udc/atmel_usba_udc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/gadget/udc/atmel_usba_udc.c||drivers/usb/gadget/udc/atmel_usba_udc.c": [
          "File: drivers/usb/gadget/udc/atmel_usba_udc.c -> drivers/usb/gadget/udc/atmel_usba_udc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "828: {",
          "829:  struct usba_ep *ep = to_usba_ep(_ep);",
          "830:  struct usba_udc *udc = ep->udc;",
          "832:  unsigned long flags;",
          "833:  u32 status;",
          "",
          "[Removed Lines]",
          "831:  struct usba_request *req = to_usba_req(_req);",
          "",
          "[Added Lines]",
          "831:  struct usba_request *req;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "838:  spin_lock_irqsave(&udc->lock, flags);",
          "840:  if (req->using_dma) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "840:  list_for_each_entry(req, &ep->queue, queue) {",
          "841:   if (&req->req == _req)",
          "842:    break;",
          "843:  }",
          "845:  if (&req->req != _req) {",
          "846:   spin_unlock_irqrestore(&udc->lock, flags);",
          "847:   return -EINVAL;",
          "848:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c957e8f084e0d21febcd6b8a0ea9631eccc92f36",
      "candidate_info": {
        "commit_hash": "c957e8f084e0d21febcd6b8a0ea9631eccc92f36",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c957e8f084e0d21febcd6b8a0ea9631eccc92f36",
        "files": [
          "drivers/spi/spi-pxa2xx.c"
        ],
        "message": "spi/pxa2xx: Clear cur_chip pointer before starting next message\n\nOnce the current message is finished, the driver notifies SPI core about\nthis by calling spi_finalize_current_message(). This function queues next\nmessage to be transferred. If there are more messages in the queue, it is\npossible that the driver is asked to transfer the next message at this\npoint.\n\nWhen spi_finalize_current_message() returns the driver clears the\ndrv_data->cur_chip pointer to NULL. The problem is that if the driver\nalready started the next message clearing drv_data->cur_chip will cause\nNULL pointer dereference which crashes the kernel like:\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000048\n IP: [<ffffffffa0022bc8>] cs_deassert+0x18/0x70 [spi_pxa2xx_platform]\n PGD 78bb8067 PUD 37712067 PMD 0\n Oops: 0000 [#1] SMP\n Modules linked in:\n CPU: 1 PID: 11 Comm: ksoftirqd/1 Tainted: G           O   3.18.0-rc4-mjo #5\n Hardware name: Intel Corp. VALLEYVIEW B3 PLATFORM/NOTEBOOK, BIOS MNW2CRB1.X64.0071.R30.1408131301 08/13/2014\n task: ffff880077f9f290 ti: ffff88007a820000 task.ti: ffff88007a820000\n RIP: 0010:[<ffffffffa0022bc8>]  [<ffffffffa0022bc8>] cs_deassert+0x18/0x70 [spi_pxa2xx_platform]\n RSP: 0018:ffff88007a823d08  EFLAGS: 00010202\n RAX: 0000000000000008 RBX: ffff8800379a4430 RCX: 0000000000000026\n RDX: 0000000000000000 RSI: 0000000000000246 RDI: ffff8800379a4430\n RBP: ffff88007a823d18 R08: 00000000ffffffff R09: 000000007a9bc65a\n R10: 000000000000028f R11: 0000000000000005 R12: ffff880070123e98\n R13: ffff880070123de8 R14: 0000000000000100 R15: ffffc90004888000\n FS:  0000000000000000(0000) GS:ffff880079a80000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n CR2: 0000000000000048 CR3: 000000007029b000 CR4: 00000000001007e0\n Stack:\n  ffff88007a823d58 ffff8800379a4430 ffff88007a823d48 ffffffffa0022c89\n  0000000000000000 ffff8800379a4430 0000000000000000 0000000000000006\n  ffff88007a823da8 ffffffffa0023be0 ffff88007a823dd8 ffffffff81076204\n Call Trace:\n  [<ffffffffa0022c89>] giveback+0x69/0xa0 [spi_pxa2xx_platform]\n  [<ffffffffa0023be0>] pump_transfers+0x710/0x740 [spi_pxa2xx_platform]\n  [<ffffffff81076204>] ? pick_next_task_fair+0x744/0x830\n  [<ffffffff81049679>] tasklet_action+0xa9/0xe0\n  [<ffffffff81049a0e>] __do_softirq+0xee/0x280\n  [<ffffffff81049bc0>] run_ksoftirqd+0x20/0x40\n  [<ffffffff810646df>] smpboot_thread_fn+0xff/0x1b0\n  [<ffffffff810645e0>] ? SyS_setgroups+0x150/0x150\n  [<ffffffff81060f9d>] kthread+0xcd/0xf0\n  [<ffffffff81060ed0>] ? kthread_create_on_node+0x180/0x180\n  [<ffffffff8187a82c>] ret_from_fork+0x7c/0xb0\n\nFix this by clearing drv_data->cur_chip before we call spi_finalize_current_message().\n\nReported-by: Martin Oldfield <m@mjoldfield.com>\nSigned-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>\nAcked-by: Robert Jarzmik <robert.jarzmik@free.fr>\nSigned-off-by: Mark Brown <broonie@kernel.org>\nCc: stable@vger.kernel.org",
        "before_after_code_files": [
          "drivers/spi/spi-pxa2xx.c||drivers/spi/spi-pxa2xx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/spi/spi-pxa2xx.c||drivers/spi/spi-pxa2xx.c": [
          "File: drivers/spi/spi-pxa2xx.c -> drivers/spi/spi-pxa2xx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "546:    cs_deassert(drv_data);",
          "547:  }",
          "550:  drv_data->cur_chip = NULL;",
          "551: }",
          "553: static void reset_sccr1(struct driver_data *drv_data)",
          "",
          "[Removed Lines]",
          "549:  spi_finalize_current_message(drv_data->master);",
          "",
          "[Added Lines]",
          "550:  spi_finalize_current_message(drv_data->master);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4093325f829746b88eaf02a5ae3b88a325ea8b75",
      "candidate_info": {
        "commit_hash": "4093325f829746b88eaf02a5ae3b88a325ea8b75",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4093325f829746b88eaf02a5ae3b88a325ea8b75",
        "files": [
          "tools/perf/util/probe-finder.c"
        ],
        "message": "perf probe: Fix crash in dwarf_getcfi_elf\n\nDavid reported that perf can segfault when adding an uprobe event like\nthis:\n\n  $ perf probe -x /lib64/libc-2.14.90.so -a 'malloc  size=%di'\n\n  (gdb) bt\n  #0  parse_eh_frame_hdr (hdr=0x0, hdr_size=2596, hdr_vaddr=71788,\n      ehdr=0x7fffffffd390, eh_frame_vaddr=\n      0x7fffffffd378, table_entries=0x8808d8, table_encoding=0x8808e0 \"\") at\n      dwarf_getcfi_elf.c:79\n  #1  0x000000385f81615a in getcfi_scn_eh_frame (hdr_vaddr=71788,\n      hdr_scn=0x8839b0, shdr=0x7fffffffd2f0, scn=<optimized out>,\n      ehdr=0x7fffffffd390, elf=0x882b30) at dwarf_getcfi_elf.c:231\n  #2  getcfi_shdr (ehdr=0x7fffffffd390, elf=0x882b30) at dwarf_getcfi_elf.c:283\n  #3  dwarf_getcfi_elf (elf=0x882b30) at dwarf_getcfi_elf.c:309\n  #4  0x00000000004d5bac in debuginfo__find_probes (pf=0x7fffffffd4f0,\n      dbg=Unhandled dwarf expression opcode 0xfa) at util/probe-finder.c:993\n  #5  0x00000000004d634a in debuginfo__find_trace_events (dbg=0x880840,\n      pev=<optimized out>, tevs=0x880f88, max_tevs=<optimized out>) at\n      util/probe-finder.c:1200\n  #6  0x00000000004aed6b in try_to_find_probe_trace_events (target=0x881b20\n      \"/lib64/libpthread-2.14.90.so\",\n      max_tevs=128, tevs=0x880f88, pev=0x859b30) at util/probe-event.c:482\n  #7  convert_to_probe_trace_events (target=0x881b20\n      \"/lib64/libpthread-2.14.90.so\", max_tevs=128, tevs=0x880f88,\n      pev=0x859b30) at util/probe-event.c:2356\n  #8  add_perf_probe_events (pevs=<optimized out>, npevs=1, max_tevs=128,\n      target=0x881b20 \"/lib64/libpthread-2.14.90.so\", force_add=false) at\n      util/probe-event.c:2391\n  #9  0x000000000044014f in __cmd_probe (argc=<optimized out>,\n      argv=0x7fffffffe2f0, prefix=Unhandled dwarf expression opcode 0xfa) at\n      at builtin-probe.c:488\n  #10 0x0000000000440313 in cmd_probe (argc=5, argv=0x7fffffffe2f0,\n      prefix=<optimized out>) at builtin-probe.c:506\n  #11 0x000000000041d133 in run_builtin (p=0x805680, argc=5,\n      argv=0x7fffffffe2f0) at perf.c:341\n  #12 0x000000000041c8b2 in handle_internal_command (argv=<optimized out>,\n      argc=<optimized out>) at perf.c:400\n  #13 run_argv (argv=<optimized out>, argcp=<optimized out>) at perf.c:444\n  #14 main (argc=5, argv=0x7fffffffe2f0) at perf.c:559\n\nAnd I found a related commit (5704c8c4fa71 \"getcfi_scn_eh_frame: Don't\ncrash and burn when .eh_frame bits aren't there.\") in elfutils that can\nlead to a unexpected crash like this.  To safely use the function, it\nneeds to check the .eh_frame section is a PROGBITS type.\n\nReported-by: David Ahern <dsahern@gmail.com>\nTested-by: David Ahern <dsahern@gmail.com>\nSigned-off-by: Namhyung Kim <namhyung@kernel.org>\nAcked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>\nCc: David Ahern <dsahern@gmail.com>\nCc: Mark Wielaard <mjw@redhat.com>\nCc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>\nLink: http://lkml.kernel.org/r/20141230090533.GH6081@sejong\nSigned-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>",
        "before_after_code_files": [
          "tools/perf/util/probe-finder.c||tools/perf/util/probe-finder.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/perf/util/probe-finder.c||tools/perf/util/probe-finder.c": [
          "File: tools/perf/util/probe-finder.c -> tools/perf/util/probe-finder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "989:  int ret = 0;",
          "991: #if _ELFUTILS_PREREQ(0, 142)",
          "994: #endif",
          "996:  off = 0;",
          "",
          "[Removed Lines]",
          "993:  pf->cfi = dwarf_getcfi_elf(dwarf_getelf(dbg->dbg));",
          "",
          "[Added Lines]",
          "992:  Elf *elf;",
          "993:  GElf_Ehdr ehdr;",
          "994:  GElf_Shdr shdr;",
          "997:  elf = dwarf_getelf(dbg->dbg);",
          "998:  if (elf == NULL)",
          "999:   return -EINVAL;",
          "1001:  if (gelf_getehdr(elf, &ehdr) == NULL)",
          "1002:   return -EINVAL;",
          "1004:  if (elf_section_by_name(elf, &ehdr, &shdr, \".eh_frame\", NULL) &&",
          "1005:      shdr.sh_type == SHT_PROGBITS) {",
          "1006:   pf->cfi = dwarf_getcfi_elf(elf);",
          "1007:  } else {",
          "1008:   pf->cfi = dwarf_getcfi(dbg->dbg);",
          "1009:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dd802406e396c22dfb5aa0d16196f04d515be49e",
      "candidate_info": {
        "commit_hash": "dd802406e396c22dfb5aa0d16196f04d515be49e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/dd802406e396c22dfb5aa0d16196f04d515be49e",
        "files": [
          "fs/f2fs/acl.c"
        ],
        "message": "f2fs: avoid double lock for cp_rwsem\n\nThe __f2fs_add_link is covered by cp_rwsem all the time.\nThis calls init_inode_metadata, which conducts some acl operations including\nmemory allocation with GFP_KERNEL previously.\nBut, under memory pressure, f2fs_write_data_page can be called, which also\ngrabs cp_rwsem too.\n\nIn this case, this incurs a deadlock pointed by Chao.\nThread #1        Thread #2\n down_read\n                 down_write\n  down_read\n -> here down_read should wait forever.\n\nReviewed-by: Chao Yu <chao2.yu@samsung.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/acl.c||fs/f2fs/acl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/acl.c||fs/f2fs/acl.c": [
          "File: fs/f2fs/acl.c -> fs/f2fs/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:  if (count == 0)",
          "63:   return NULL;",
          "66:  if (!acl)",
          "67:   return ERR_PTR(-ENOMEM);",
          "",
          "[Removed Lines]",
          "65:  acl = posix_acl_alloc(count, GFP_KERNEL);",
          "",
          "[Added Lines]",
          "65:  acl = posix_acl_alloc(count, GFP_NOFS);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116:  int i;",
          "118:  f2fs_acl = kmalloc(sizeof(struct f2fs_acl_header) + acl->a_count *",
          "120:  if (!f2fs_acl)",
          "121:   return ERR_PTR(-ENOMEM);",
          "",
          "[Removed Lines]",
          "119:    sizeof(struct f2fs_acl_entry), GFP_KERNEL);",
          "",
          "[Added Lines]",
          "119:    sizeof(struct f2fs_acl_entry), GFP_NOFS);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b9ac12ef099707f405d7478009564302d7ed8393",
      "candidate_info": {
        "commit_hash": "b9ac12ef099707f405d7478009564302d7ed8393",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b9ac12ef099707f405d7478009564302d7ed8393",
        "files": [
          "net/netfilter/nf_tables_api.c"
        ],
        "message": "netfilter: nf_tables: extend NFT_MSG_DELTABLE to support flushing the ruleset\n\nThis patch extend the NFT_MSG_DELTABLE call to support flushing the entire\nruleset.\n\nThe options now are:\n * No family speficied, no table specified: flush all the ruleset.\n * Family specified, no table specified: flush all tables in the AF.\n * Family specified, table specified: flush the given table.\n\nSigned-off-by: Arturo Borrero Gonzalez <arturo.borrero.glez@gmail.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c"
          ],
          "candidate": [
            "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c"
          ]
        }
      },
      "candidate_diff": {
        "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c": [
          "File: net/netfilter/nf_tables_api.c -> net/netfilter/nf_tables_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "707:  return 0;",
          "708: }",
          "710: static int nf_tables_deltable(struct sock *nlsk, struct sk_buff *skb,",
          "711:          const struct nlmsghdr *nlh,",
          "712:          const struct nlattr * const nla[])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "710: static int nft_flush_table(struct nft_ctx *ctx)",
          "711: {",
          "712:  int err;",
          "713:  struct nft_chain *chain, *nc;",
          "714:  struct nft_set *set, *ns;",
          "716:  list_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {",
          "717:   ctx->chain = chain;",
          "719:   err = nft_delrule_by_chain(ctx);",
          "720:   if (err < 0)",
          "721:    goto out;",
          "723:   err = nft_delchain(ctx);",
          "724:   if (err < 0)",
          "725:    goto out;",
          "726:  }",
          "728:  list_for_each_entry_safe(set, ns, &ctx->table->sets, list) {",
          "729:   if (set->flags & NFT_SET_ANONYMOUS &&",
          "730:       !list_empty(&set->bindings))",
          "731:    continue;",
          "733:   err = nft_delset(ctx, set);",
          "734:   if (err < 0)",
          "735:    goto out;",
          "736:  }",
          "738:  err = nft_deltable(ctx);",
          "739: out:",
          "740:  return err;",
          "741: }",
          "743: static int nft_flush(struct nft_ctx *ctx, int family)",
          "744: {",
          "745:  struct nft_af_info *afi;",
          "746:  struct nft_table *table, *nt;",
          "747:  const struct nlattr * const *nla = ctx->nla;",
          "748:  int err = 0;",
          "750:  list_for_each_entry(afi, &ctx->net->nft.af_info, list) {",
          "751:   if (family != AF_UNSPEC && afi->family != family)",
          "752:    continue;",
          "754:   ctx->afi = afi;",
          "755:   list_for_each_entry_safe(table, nt, &afi->tables, list) {",
          "756:    if (nla[NFTA_TABLE_NAME] &&",
          "757:        nla_strcmp(nla[NFTA_TABLE_NAME], table->name) != 0)",
          "758:     continue;",
          "760:    ctx->table = table;",
          "762:    err = nft_flush_table(ctx);",
          "763:    if (err < 0)",
          "764:     goto out;",
          "765:   }",
          "766:  }",
          "767: out:",
          "768:  return err;",
          "769: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "718:  int family = nfmsg->nfgen_family;",
          "719:  struct nft_ctx ctx;",
          "721:  afi = nf_tables_afinfo_lookup(net, family, false);",
          "722:  if (IS_ERR(afi))",
          "723:   return PTR_ERR(afi);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "782:  nft_ctx_init(&ctx, skb, nlh, NULL, NULL, NULL, nla);",
          "783:  if (family == AF_UNSPEC || nla[NFTA_TABLE_NAME] == NULL)",
          "784:   return nft_flush(&ctx, family);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "727:   return PTR_ERR(table);",
          "728:  if (table->flags & NFT_TABLE_INACTIVE)",
          "729:   return -ENOENT;",
          "736: }",
          "738: static void nf_tables_table_destroy(struct nft_ctx *ctx)",
          "",
          "[Removed Lines]",
          "730:  if (table->use > 0)",
          "731:   return -EBUSY;",
          "733:  nft_ctx_init(&ctx, skb, nlh, afi, table, NULL, nla);",
          "735:  return nft_deltable(&ctx);",
          "",
          "[Added Lines]",
          "796:  ctx.afi = afi;",
          "797:  ctx.table = table;",
          "799:  return nft_flush_table(&ctx);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a3c0e48faa6018b1867f4897d1c74b78df6dd416",
      "candidate_info": {
        "commit_hash": "a3c0e48faa6018b1867f4897d1c74b78df6dd416",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/a3c0e48faa6018b1867f4897d1c74b78df6dd416",
        "files": [
          "include/uv.h"
        ],
        "message": "doc: describe signal send emulation on windows\n\nSignals don't exist on Windows, but libuv emulates the behaviour of\nseveral Unix signals. This wasn't documented, and the existing\ndocumentation for signal reception emulation on Windows was worded as if\nit applied to signal sending, which it does not.",
        "before_after_code_files": [
          "include/uv.h||include/uv.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h"
        ]
      }
    },
    {
      "candidate_hash": "cdc979dbe04bac58eb33ee2510f860c172a42d7e",
      "candidate_info": {
        "commit_hash": "cdc979dbe04bac58eb33ee2510f860c172a42d7e",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/cdc979dbe04bac58eb33ee2510f860c172a42d7e",
        "files": [
          "Makefile.am",
          "include/uv-aix.h",
          "include/uv-unix.h",
          "src/unix/aix.c",
          "src/unix/core.c",
          "src/unix/fs.c",
          "src/unix/internal.h",
          "src/unix/udp.c",
          "test/test-fs.c",
          "uv.gyp"
        ],
        "message": "aix: improve AIX compatibility",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "include/uv-aix.h||include/uv-aix.h",
          "include/uv-unix.h||include/uv-unix.h",
          "src/unix/aix.c||src/unix/aix.c",
          "src/unix/core.c||src/unix/core.c",
          "src/unix/fs.c||src/unix/fs.c",
          "src/unix/internal.h||src/unix/internal.h",
          "src/unix/udp.c||src/unix/udp.c",
          "test/test-fs.c||test/test-fs.c",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "230: endif",
          "232: if AIX",
          "234: endif",
          "236: if SUNOS",
          "",
          "[Removed Lines]",
          "233: test_run_tests_CFLAGS += -D_ALL_SOURCE -D_XOPEN_SOURCE=500",
          "",
          "[Added Lines]",
          "233: test_run_tests_CFLAGS += -D_ALL_SOURCE -D_XOPEN_SOURCE=500 -D_LINUX_SOURCE_COMPAT",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "241: if AIX",
          "243: libuv_la_SOURCES += src/unix/aix.c",
          "244: endif",
          "",
          "[Removed Lines]",
          "242: libuv_la_CFLAGS += -D_ALL_SOURCE -D_XOPEN_SOURCE=500",
          "",
          "[Added Lines]",
          "242: libuv_la_CFLAGS += -D_ALL_SOURCE -D_XOPEN_SOURCE=500 -D_LINUX_SOURCE_COMPAT",
          "",
          "---------------"
        ],
        "include/uv-aix.h||include/uv-aix.h": [
          "File: include/uv-aix.h -> include/uv-aix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #ifndef UV_AIX_H",
          "23: #define UV_AIX_H",
          "25: #define UV_PLATFORM_LOOP_FIELDS                                               \\",
          "26:   int fs_fd;                                                                  \\",
          "28: #define UV_PLATFORM_FS_EVENT_FIELDS                                           \\",
          "29:   uv__io_t event_watcher;                                                     \\",
          "30:   char *dir_filename;                                                         \\",
          "",
          "---------------"
        ],
        "include/uv-unix.h||include/uv-unix.h": [
          "File: include/uv-unix.h -> include/uv-unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #if defined(__linux__)",
          "48: # include \"uv-linux.h\"",
          "49: #elif defined(__sun)",
          "50: # include \"uv-sunos.h\"",
          "51: #elif defined(__APPLE__)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49: #elif defined(_AIX)",
          "50: # include \"uv-aix.h\"",
          "",
          "---------------"
        ],
        "src/unix/aix.c||src/unix/aix.c": [
          "File: src/unix/aix.c -> src/unix/aix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include <unistd.h>",
          "40: #include <fcntl.h>",
          "41: #include <utmp.h>",
          "43: #include <sys/protosw.h>",
          "44: #include <libperfstat.h>",
          "45: #include <sys/proc.h>",
          "46: #include <sys/procfs.h>",
          "48: uint64_t uv__hrtime(uv_clocktype_t type) {",
          "49:   uint64_t G = 1000000000;",
          "50:   timebasestruct_t t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: #include <libgen.h>",
          "49: #include <sys/poll.h>",
          "51: #include <sys/pollset.h>",
          "52: #include <ctype.h>",
          "53: #include <sys/ahafs_evProds.h>",
          "55: #include <sys/mntctl.h>",
          "56: #include <sys/vmount.h>",
          "57: #include <limits.h>",
          "58: #include <strings.h>",
          "59: #include <sys/vnode.h>",
          "61: #define RDWR_BUF_SIZE   4096",
          "62: #define EQ(a,b)         (strcmp(a,b) == 0)",
          "64: int uv__platform_loop_init(uv_loop_t* loop, int default_loop) {",
          "65:   loop->fs_fd = -1;",
          "69:   loop->backend_fd = pollset_create(-1);",
          "71:   if (loop->backend_fd == -1)",
          "72:     return -1;",
          "74:   return 0;",
          "75: }",
          "78: void uv__platform_loop_delete(uv_loop_t* loop) {",
          "79:   if (loop->fs_fd != -1) {",
          "80:     uv__close(loop->fs_fd);",
          "81:     loop->fs_fd = -1;",
          "82:   }",
          "84:   if (loop->backend_fd != -1) {",
          "85:     pollset_destroy(loop->backend_fd);",
          "86:     loop->backend_fd = -1;",
          "87:   }",
          "88: }",
          "91: void uv__io_poll(uv_loop_t* loop, int timeout) {",
          "92:   struct pollfd events[1024];",
          "93:   struct pollfd pqry;",
          "94:   struct pollfd* pe;",
          "95:   struct poll_ctl pc;",
          "96:   QUEUE* q;",
          "97:   uv__io_t* w;",
          "98:   uint64_t base;",
          "99:   uint64_t diff;",
          "100:   int nevents;",
          "101:   int count;",
          "102:   int nfds;",
          "103:   int i;",
          "104:   int rc;",
          "105:   int add_failed;",
          "107:   if (loop->nfds == 0) {",
          "108:     assert(QUEUE_EMPTY(&loop->watcher_queue));",
          "109:     return;",
          "110:   }",
          "112:   while (!QUEUE_EMPTY(&loop->watcher_queue)) {",
          "113:     q = QUEUE_HEAD(&loop->watcher_queue);",
          "114:     QUEUE_REMOVE(q);",
          "115:     QUEUE_INIT(q);",
          "117:     w = QUEUE_DATA(q, uv__io_t, watcher_queue);",
          "118:     assert(w->pevents != 0);",
          "119:     assert(w->fd >= 0);",
          "120:     assert(w->fd < (int) loop->nwatchers);",
          "122:     pc.events = w->pevents;",
          "123:     pc.fd = w->fd;",
          "125:     add_failed = 0;",
          "126:     if (w->events == 0) {",
          "127:       pc.cmd = PS_ADD;",
          "128:       if (pollset_ctl(loop->backend_fd, &pc, 1)) {",
          "129:         if (errno != EINVAL) {",
          "130:           assert(0 && \"Failed to add file descriptor (pc.fd) to pollset\");",
          "131:           abort();",
          "132:         }",
          "134:         pqry.fd = pc.fd;",
          "135:         rc = pollset_query(loop->backend_fd, &pqry);",
          "136:         switch (rc) {",
          "137:         case -1:",
          "138:           assert(0 && \"Failed to query pollset for file descriptor\");",
          "139:           abort();",
          "140:         case 0:",
          "141:           assert(0 && \"Pollset does not contain file descriptor\");",
          "142:           abort();",
          "143:         }",
          "146:         add_failed = 1;",
          "147:       }",
          "148:     }",
          "149:     if (w->events != 0 || add_failed) {",
          "156:       pc.cmd = PS_DELETE;",
          "157:       if (pollset_ctl(loop->backend_fd, &pc, 1)) {",
          "158:         assert(0 && \"Failed to delete file descriptor (pc.fd) from pollset\");",
          "159:         abort();",
          "160:       }",
          "161:       pc.cmd = PS_ADD;",
          "162:       if (pollset_ctl(loop->backend_fd, &pc, 1)) {",
          "163:         assert(0 && \"Failed to add file descriptor (pc.fd) to pollset\");",
          "164:         abort();",
          "165:       }",
          "166:     }",
          "168:     w->events = w->pevents;",
          "169:   }",
          "171:   assert(timeout >= -1);",
          "172:   base = loop->time;",
          "175:   for (;;) {",
          "176:     nfds = pollset_poll(loop->backend_fd,",
          "177:                         events,",
          "178:                         ARRAY_SIZE(events),",
          "179:                         timeout);",
          "185:     SAVE_ERRNO(uv__update_time(loop));",
          "187:     if (nfds == 0) {",
          "188:       assert(timeout != -1);",
          "189:       return;",
          "190:     }",
          "192:     if (nfds == -1) {",
          "193:       if (errno != EINTR) {",
          "194:         abort();",
          "195:       }",
          "197:       if (timeout == -1)",
          "198:         continue;",
          "200:       if (timeout == 0)",
          "201:         return;",
          "204:       goto update_timeout;",
          "205:     }",
          "207:     nevents = 0;",
          "209:     assert(loop->watchers != NULL);",
          "210:     loop->watchers[loop->nwatchers] = (void*) events;",
          "211:     loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;",
          "213:     for (i = 0; i < nfds; i++) {",
          "214:       pe = events + i;",
          "215:       pc.cmd = PS_DELETE;",
          "216:       pc.fd = pe->fd;",
          "219:       if (pc.fd == -1)",
          "220:         continue;",
          "222:       assert(pc.fd >= 0);",
          "223:       assert((unsigned) pc.fd < loop->nwatchers);",
          "225:       w = loop->watchers[pc.fd];",
          "227:       if (w == NULL) {",
          "233:         pollset_ctl(loop->backend_fd, &pc, 1);",
          "234:         continue;",
          "235:       }",
          "237:       w->cb(loop, w, pe->revents);",
          "238:       nevents++;",
          "239:     }",
          "241:     loop->watchers[loop->nwatchers] = NULL;",
          "242:     loop->watchers[loop->nwatchers + 1] = NULL;",
          "244:     if (nevents != 0) {",
          "245:       if (nfds == ARRAY_SIZE(events) && --count != 0) {",
          "247:         timeout = 0;",
          "248:         continue;",
          "249:       }",
          "250:       return;",
          "251:     }",
          "253:     if (timeout == 0)",
          "254:       return;",
          "256:     if (timeout == -1)",
          "257:       continue;",
          "259: update_timeout:",
          "260:     assert(timeout > 0);",
          "262:     diff = loop->time - base;",
          "263:     if (diff >= (uint64_t) timeout)",
          "264:       return;",
          "266:     timeout -= diff;",
          "267:   }",
          "268: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62: int uv_exepath(char* buffer, size_t* size) {",
          "63:   ssize_t res;",
          "65:   struct psinfo ps;",
          "66:   int fd;",
          "83:   fd = open(pp, O_RDONLY);",
          "84:   if (fd < 0)",
          "85:     return fd;",
          "",
          "[Removed Lines]",
          "64:   char pp[64], cwdl[PATH_MAX];",
          "68:   if (buffer == NULL)",
          "69:     return (-1);",
          "71:   if (size == NULL)",
          "72:     return (-1);",
          "74:   (void) snprintf(pp, sizeof(pp), \"/proc/%lu/cwd\", (unsigned long) getpid());",
          "76:   res = readlink(pp, cwdl, sizeof(cwdl) - 1);",
          "77:   if (res < 0)",
          "78:     return res;",
          "80:   cwdl[res] = '\\0';",
          "82:   (void) snprintf(pp, sizeof(pp), \"/proc/%lu/psinfo\", (unsigned long) getpid());",
          "",
          "[Added Lines]",
          "290:   char cwd[PATH_MAX], cwdl[PATH_MAX];",
          "291:   char symlink[PATH_MAX], temp_buffer[PATH_MAX];",
          "292:   char pp[64];",
          "295:   char **argv;",
          "297:   if ((buffer == NULL) || (size == NULL))",
          "298:     return -EINVAL;",
          "300:   snprintf(pp, sizeof(pp), \"/proc/%lu/psinfo\", (unsigned long) getpid());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:   if (res < 0)",
          "90:     return res;",
          "95: }",
          "",
          "[Removed Lines]",
          "92:   (void) snprintf(buffer, *size, \"%s%s\", cwdl, ps.pr_fname);",
          "94:   return 0;",
          "",
          "[Added Lines]",
          "311:   if (ps.pr_argv == 0)",
          "312:     return -EINVAL;",
          "314:   argv = (char **) *((char ***) (intptr_t) ps.pr_argv);",
          "316:   if ((argv == NULL) || (argv[0] == NULL))",
          "317:     return -EINVAL;",
          "328:   if (argv[0][0] == '/') {",
          "329:     snprintf(symlink, PATH_MAX-1, \"%s\", argv[0]);",
          "332:     res = readlink(symlink, temp_buffer, PATH_MAX-1);",
          "337:     if (res < 0) {",
          "338:       assert(*size > strlen(symlink));",
          "339:       strcpy(buffer, symlink);",
          "344:     } else {",
          "345:       assert(*size > (strlen(symlink) + 1 + strlen(temp_buffer)));",
          "346:       snprintf(buffer, *size-1, \"%s/%s\", dirname(symlink), temp_buffer);",
          "347:     }",
          "349:     return 0;",
          "352:   } else if (argv[0][0] == '.') {",
          "353:     char *relative = strchr(argv[0], '/');",
          "354:     if (relative == NULL)",
          "355:       return -EINVAL;",
          "358:     snprintf(cwd, PATH_MAX-1, \"/proc/%lu/cwd\", (unsigned long) getpid());",
          "361:     res = readlink(cwd, cwdl, sizeof(cwdl) - 1);",
          "362:     if (res < 0)",
          "363:       return -errno;",
          "365:     snprintf(symlink, PATH_MAX-1, \"%s%s\", cwdl, relative + 1);",
          "367:     res = readlink(symlink, temp_buffer, PATH_MAX-1);",
          "368:     if (res < 0) {",
          "369:       assert(*size > strlen(symlink));",
          "370:       strcpy(buffer, symlink);",
          "371:     } else {",
          "372:       assert(*size > (strlen(symlink) + 1 + strlen(temp_buffer)));",
          "373:       snprintf(buffer, *size-1, \"%s/%s\", dirname(symlink), temp_buffer);",
          "374:     }",
          "376:     return 0;",
          "379:   } else if (strchr(argv[0], '/') != NULL) {",
          "381:     snprintf(cwd, PATH_MAX-1, \"/proc/%lu/cwd\", (unsigned long) getpid());",
          "384:     res = readlink(cwd, cwdl, sizeof(cwdl) - 1);",
          "385:     if (res < 0)",
          "386:       return -errno;",
          "388:     snprintf(symlink, PATH_MAX-1, \"%s%s\", cwdl, argv[0]);",
          "390:     res = readlink(symlink, temp_buffer, PATH_MAX-1);",
          "391:     if (res < 0) {",
          "392:       assert(*size > strlen(symlink));",
          "393:       strcpy(buffer, symlink);",
          "394:     } else {",
          "395:       assert(*size > (strlen(symlink) + 1 + strlen(temp_buffer)));",
          "396:       snprintf(buffer, *size-1, \"%s/%s\", dirname(symlink), temp_buffer);",
          "397:     }",
          "399:     return 0;",
          "401:   } else {",
          "403:     char *token = NULL;",
          "404:     struct stat statstruct;",
          "407:     char *path = getenv(\"PATH\");",
          "408:     if(sizeof(clonedpath) <= strlen(path))",
          "409:       return -EINVAL;",
          "412:     strcpy(clonedpath, path);",
          "415:     token = strtok(clonedpath, \":\");",
          "418:     snprintf(cwd, PATH_MAX-1, \"/proc/%lu/cwd\", (unsigned long) getpid());",
          "419:     res = readlink(cwd, cwdl, sizeof(cwdl) - 1);",
          "420:     if (res < 0)",
          "421:       return -errno;",
          "424:     while(token != NULL) {",
          "425:       if (token[0] == '.') {",
          "427:         char *relative = strchr(token, '/');",
          "428:         if (relative != NULL)",
          "430:           snprintf(symlink, PATH_MAX-1, \"%s%s/%s\", cwdl, relative+1, ps.pr_fname);",
          "431:         else",
          "432:           snprintf(symlink, PATH_MAX-1, \"%s%s\", cwdl, ps.pr_fname);",
          "433:         if (stat(symlink, &statstruct) != -1) {",
          "435:           res = readlink(symlink, temp_buffer, PATH_MAX-1);",
          "436:           if (res < 0) {",
          "437:             assert(*size > strlen(symlink));",
          "438:             strcpy(buffer, symlink);",
          "439:           } else {",
          "440:             assert(*size > (strlen(symlink) + 1 + strlen(temp_buffer)));",
          "441:             snprintf(buffer, *size-1, \"%s/%s\", dirname(symlink), temp_buffer);",
          "442:           }",
          "444:           return 0;",
          "445:         }",
          "448:       } else {",
          "449:         snprintf(symlink, PATH_MAX-1, \"%s/%s\", token, ps.pr_fname);",
          "450:         if (stat(symlink, &statstruct) != -1) {",
          "451:           res = readlink(symlink, temp_buffer, PATH_MAX-1);",
          "452:           if (res < 0) {",
          "453:             assert(*size > strlen(symlink));",
          "454:             strcpy(buffer, symlink);",
          "455:           } else {",
          "456:             assert(*size > (strlen(symlink) + 1 + strlen(temp_buffer)));",
          "457:             snprintf(buffer, *size-1, \"%s/%s\", dirname(symlink), temp_buffer);",
          "458:           }",
          "460:           return 0;",
          "461:         }",
          "462:       }",
          "463:       token = strtok(NULL, \":\");",
          "464:     }",
          "466:     return -EINVAL;",
          "467:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "128: }",
          "131: int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle) {",
          "133: }",
          "",
          "[Removed Lines]",
          "132:   return -ENOSYS;",
          "",
          "[Added Lines]",
          "504: static char *uv__rawname(char *cp) {",
          "505:   static char rawbuf[FILENAME_MAX+1];",
          "506:   char *dp = rindex(cp, '/');",
          "508:   if (dp == 0)",
          "509:     return 0;",
          "512:   strcpy(rawbuf, cp);",
          "514:   strcat(rawbuf, \"/r\");",
          "515:   strcat(rawbuf, dp+1);",
          "516:   return rawbuf;",
          "517: }",
          "527: static int uv__path_is_a_directory(char* filename) {",
          "528:   struct stat statbuf;",
          "530:   if (stat(filename, &statbuf) < 0)",
          "533:   if (statbuf.st_type == VDIR)",
          "534:     return 0;",
          "536:   return -1;",
          "537: }",
          "544: static int uv__is_ahafs_mounted(void){",
          "545:   int rv, i = 2;",
          "546:   struct vmount *p;",
          "547:   int size_multiplier = 10;",
          "548:   size_t siz = sizeof(struct vmount)*size_multiplier;",
          "549:   struct vmount *vmt;",
          "550:   const char *dev = \"/aha\";",
          "551:   char *obj, *stub;",
          "553:   p = malloc(siz);",
          "554:   if (p == NULL)",
          "555:     return -errno;",
          "558:   rv = mntctl(MCTL_QUERY, siz, (char*)p);",
          "559:   if (rv < 0)",
          "560:     return -errno;",
          "561:   if (rv == 0) {",
          "563:     siz = *(int*)p;",
          "564:     free(p);",
          "565:     p = malloc(siz);",
          "566:     if (p == NULL)",
          "567:       return -errno;",
          "568:     rv = mntctl(MCTL_QUERY, siz, (char*)p);",
          "569:     if (rv < 0)",
          "570:       return -errno;",
          "571:   }",
          "574:   for(vmt = p, i = 0; i < rv; i++) {",
          "578:     if (EQ(obj, dev) || EQ(uv__rawname(obj), dev) || EQ(stub, dev)) {",
          "580:       return 0;",
          "581:     }",
          "582:     vmt = (struct vmount *) ((char *) vmt + vmt->vmt_length);",
          "583:   }",
          "586:   return -1;",
          "587: }",
          "593: static int uv__makedir_p(const char *dir) {",
          "594:   char tmp[256];",
          "595:   char *p = NULL;",
          "596:   size_t len;",
          "597:   int err;",
          "599:   snprintf(tmp, sizeof(tmp),\"%s\",dir);",
          "600:   len = strlen(tmp);",
          "601:   if (tmp[len - 1] == '/')",
          "602:     tmp[len - 1] = 0;",
          "603:   for (p = tmp + 1; *p; p++) {",
          "604:     if (*p == '/') {",
          "606:       err = mkdir(tmp, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);",
          "607:       if(err != 0)",
          "608:         return err;",
          "610:     }",
          "611:   }",
          "612:   return mkdir(tmp, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);",
          "613: }",
          "620: static int uv__make_subdirs_p(const char *filename) {",
          "621:   char cmd[2048];",
          "622:   char *p;",
          "623:   int rc = 0;",
          "626:   p = strrchr(filename, '/');",
          "628:   if (p == NULL)",
          "629:     return 0;",
          "631:   if (uv__path_is_a_directory((char*)filename) == 0) {",
          "632:     sprintf(cmd, \"/aha/fs/modDir.monFactory\");",
          "633:   } else {",
          "634:     sprintf(cmd, \"/aha/fs/modFile.monFactory\");",
          "635:   }",
          "637:   strncat(cmd, filename, (p - filename));",
          "638:   rc = uv__makedir_p(cmd);",
          "640:   if (rc == -1 && errno != EEXIST){",
          "641:     return -errno;",
          "642:   }",
          "644:   return rc;",
          "645: }",
          "653: static int uv__setup_ahafs(const char* filename, int *fd) {",
          "654:   int rc = 0;",
          "655:   char mon_file_write_string[RDWR_BUF_SIZE];",
          "656:   char mon_file[PATH_MAX];",
          "660:   file_is_directory = uv__path_is_a_directory((char*)filename);",
          "662:   if (file_is_directory == 0)",
          "663:     sprintf(mon_file, \"/aha/fs/modDir.monFactory\");",
          "664:   else",
          "665:     sprintf(mon_file, \"/aha/fs/modFile.monFactory\");",
          "667:   if ((strlen(mon_file) + strlen(filename) + 5) > PATH_MAX)",
          "668:     return -ENAMETOOLONG;",
          "671:   rc = uv__make_subdirs_p(filename);",
          "672:   if (rc == -1 && errno != EEXIST)",
          "673:     return rc;",
          "675:   strcat(mon_file, filename);",
          "676:   strcat(mon_file, \".mon\");",
          "682:   if (*fd < 0)",
          "683:     return -errno;",
          "697:   if (file_is_directory == 0)",
          "698:     sprintf(mon_file_write_string, \"CHANGED=YES;WAIT_TYPE=WAIT_IN_SELECT;INFO_LVL=2\");",
          "699:   else",
          "700:     sprintf(mon_file_write_string, \"CHANGED=YES;WAIT_TYPE=WAIT_IN_SELECT;INFO_LVL=1\");",
          "702:   rc = write(*fd, mon_file_write_string, strlen(mon_file_write_string)+1);",
          "703:   if (rc < 0)",
          "704:     return -errno;",
          "706:   return 0;",
          "707: }",
          "714: static int uv__skip_lines(char **p, int n) {",
          "715:   int lines = 0;",
          "717:   while(n > 0) {",
          "719:     if (!p)",
          "720:       return lines;",
          "722:     (*p)++;",
          "723:     n--;",
          "724:     lines++;",
          "725:   }",
          "726:   return lines;",
          "727: }",
          "738: static int uv__parse_data(char *buf, int *events, uv_fs_event_t* handle) {",
          "739:   int    evp_rc, i;",
          "740:   char   *p;",
          "743:   p = buf;",
          "747:   for(i = 0; i < PATH_MAX; i++) {",
          "748:     filename[i] = 0;",
          "749:   }",
          "750:   i = 0;",
          "753:   if (strncmp(buf, \"BUF_WRAP\", strlen(\"BUF_WRAP\")) == 0) {",
          "754:     assert(0 && \"Buffer wrap detected, Some event occurrences lost!\");",
          "755:     return 0;",
          "756:   }",
          "765:   if (uv__skip_lines(&p, 9) != 9)",
          "766:     return -1;",
          "768:   if (sscanf(p, \"RC_FROM_EVPROD=%d\\nEND_EVENT_DATA\", &evp_rc) == 1) {",
          "770:       if (evp_rc == AHAFS_MODDIR_UNMOUNT || evp_rc == AHAFS_MODDIR_REMOVE_SELF) {",
          "773:         handle->dir_filename = NULL;",
          "774:       } else {",
          "779:         if (uv__skip_lines(&p, 1) != 1)",
          "780:           return -1;",
          "783:         if (sscanf(p, \"BEGIN_EVPROD_INFO\\n%sEND_EVPROD_INFO\", filename) == 1) {",
          "784:           handle->dir_filename = strdup((const char*)&filename);",
          "785:         } else",
          "786:           return -1;",
          "787:         }",
          "789:       if (evp_rc == AHAFS_MODFILE_RENAME)",
          "791:       else",
          "793:     }",
          "794:   }",
          "795:   else",
          "796:     return -1;",
          "798:   return 0;",
          "799: }",
          "803: static void uv__ahafs_event(uv_loop_t* loop, uv__io_t* event_watch, unsigned int fflags) {",
          "804:   char   result_data[RDWR_BUF_SIZE];",
          "805:   int bytes, rc = 0;",
          "806:   uv_fs_event_t* handle;",
          "807:   int events = 0;",
          "808:   int  i = 0;",
          "809:   char fname[PATH_MAX];",
          "810:   char *p;",
          "812:   handle = container_of(event_watch, uv_fs_event_t, event_watcher);",
          "815:   for(i = 0; i < PATH_MAX; i++) {",
          "816:     fname[i] = 0;",
          "817:   }",
          "818:   i = 0;",
          "824:   bytes = pread(event_watch->fd, result_data, RDWR_BUF_SIZE, 0);",
          "826:   assert((bytes <= 0) && \"uv__ahafs_event - Error reading monitor file\");",
          "829:   if(bytes > 0)",
          "830:     rc = uv__parse_data(result_data, &events, handle);",
          "835:   if (uv__path_is_a_directory(handle->path) == 0) {",
          "836:     p = handle->dir_filename;",
          "837:     while(*p != NULL){",
          "838:       fname[i]= *p;",
          "839:       i++;",
          "840:       p++;",
          "841:     }",
          "842:   } else {",
          "844:     if (handle->path[0] == '/') {",
          "845:       p = strrchr(handle->path, '/');",
          "846:       p++;",
          "848:       while(*p != NULL) {",
          "849:         fname[i]= *p;",
          "850:         i++;",
          "851:         p++;",
          "852:       }",
          "853:     }",
          "854:   }",
          "857:   if (rc == -1)",
          "858:     return;",
          "860:     handle->cb(handle, (const char*)&fname, events, 0);",
          "861: }",
          "865:   uv__handle_init(loop, (uv_handle_t*)handle, UV_FS_EVENT);",
          "866:   return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "137:                       uv_fs_event_cb cb,",
          "138:                       const char* filename,",
          "139:                       unsigned int flags) {",
          "141: }",
          "144: int uv_fs_event_stop(uv_fs_event_t* handle) {",
          "146: }",
          "149: void uv__fs_event_close(uv_fs_event_t* handle) {",
          "151: }",
          "",
          "[Removed Lines]",
          "140:   return -ENOSYS;",
          "145:   return -ENOSYS;",
          "150:   UNREACHABLE();",
          "",
          "[Added Lines]",
          "874:   int  fd, rc, i = 0, res = 0;",
          "875:   char cwd[PATH_MAX];",
          "876:   char absolute_path[PATH_MAX];",
          "877:   char fname[PATH_MAX];",
          "878:   char *p;",
          "881:   for(i = 0; i < PATH_MAX; i++) {",
          "882:     cwd[i] = 0;",
          "883:     absolute_path[i] = 0;",
          "884:     fname[i] = 0;",
          "885:   }",
          "886:   i = 0;",
          "889:   if (filename[0] == '/') {",
          "891:     sprintf(absolute_path, filename);",
          "892:     p = strrchr(filename, '/');",
          "893:     p++;",
          "894:   } else {",
          "895:     if (filename[0] == '.' && filename[1] == '/') {",
          "897:       sprintf(fname, filename);",
          "898:       snprintf(cwd, PATH_MAX-1, \"/proc/%lu/cwd\", (unsigned long) getpid());",
          "899:       res = readlink(cwd, absolute_path, sizeof(absolute_path) - 1);",
          "900:       if (res < 0)",
          "901:         return res;",
          "902:       p = strrchr(absolute_path, '/');",
          "903:       p++;",
          "904:       p++;",
          "905:     } else {",
          "907:       sprintf(fname, filename);",
          "908:       snprintf(cwd, PATH_MAX-1, \"/proc/%lu/cwd\", (unsigned long) getpid());",
          "909:       res = readlink(cwd, absolute_path, sizeof(absolute_path) - 1);",
          "910:       if (res < 0)",
          "911:         return res;",
          "912:       p = strrchr(absolute_path, '/');",
          "913:       p++;",
          "914:     }",
          "916:     while(filename[i] != NULL) {",
          "918:       i++;",
          "919:       p++;",
          "920:     }",
          "921:   }",
          "924:     return UV_ENOSYS;",
          "927:   rc = uv__setup_ahafs((const char *)absolute_path, &fd);",
          "928:   if (rc != 0)",
          "929:     return rc;",
          "932:   uv__handle_start(handle);",
          "933:   uv__io_init(&handle->event_watcher, uv__ahafs_event, fd);",
          "934:   handle->path = strdup((const char*)&absolute_path);",
          "935:   handle->cb = cb;",
          "937:   uv__io_start(handle->loop, &handle->event_watcher, UV__POLLIN);",
          "939:   return 0;",
          "945:   if (!uv__is_active(handle))",
          "946:     return 0;",
          "948:   uv__io_close(handle->loop, &handle->event_watcher);",
          "949:   uv__handle_stop(handle);",
          "951:   if (uv__path_is_a_directory(handle->path) == 0) {",
          "952:     free(handle->dir_filename);",
          "953:     handle->dir_filename = NULL;",
          "954:   }",
          "956:   free(handle->path);",
          "957:   handle->path = NULL;",
          "958:   uv__close(handle->event_watcher.fd);",
          "959:   handle->event_watcher.fd = -1;",
          "961:   return 0;",
          "966:   uv_fs_event_stop(handle);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "175:   int err;",
          "176:   int fd;",
          "180:   fd = open(pp, O_RDONLY);",
          "181:   if (fd == -1)",
          "",
          "[Removed Lines]",
          "178:   (void) snprintf(pp, sizeof(pp), \"/proc/%lu/psinfo\", (unsigned long) getpid());",
          "",
          "[Added Lines]",
          "994:   snprintf(pp, sizeof(pp), \"/proc/%lu/psinfo\", (unsigned long) getpid());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "398:   free(addresses);",
          "399: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1217: void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {",
          "1218:   struct pollfd* events;",
          "1219:   uintptr_t i;",
          "1220:   uintptr_t nfds;",
          "1222:   assert(loop->watchers != NULL);",
          "1224:   events = (struct pollfd*) loop->watchers[loop->nwatchers];",
          "1225:   nfds = (uintptr_t) loop->watchers[loop->nwatchers + 1];",
          "1226:   if (events == NULL)",
          "1227:     return;",
          "1230:   for (i = 0; i < nfds; i++)",
          "1231:     if ((int) events[i].fd == fd)",
          "1232:       events[i].fd = -1;",
          "1233: }",
          "",
          "---------------"
        ],
        "src/unix/core.c||src/unix/core.c": [
          "File: src/unix/core.c -> src/unix/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: # endif",
          "71: #endif",
          "73: static void uv__run_pending(uv_loop_t* loop);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: #ifdef _AIX",
          "74: #include <sys/ioctl.h>",
          "75: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "444: }",
          "449: int uv__nonblock(int fd, int set) {",
          "450:   int r;",
          "",
          "[Removed Lines]",
          "447: #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)",
          "",
          "[Added Lines]",
          "451: #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) || \\",
          "452:     defined(_AIX)",
          "",
          "---------------"
        ],
        "src/unix/fs.c||src/unix/fs.c": [
          "File: src/unix/fs.c -> src/unix/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "217: static ssize_t uv__fs_read(uv_fs_t* req) {",
          "218:   ssize_t result;",
          "220:   if (req->off < 0) {",
          "221:     if (req->nbufs == 1)",
          "222:       result = read(req->file, req->bufs[0].base, req->bufs[0].len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220: #if defined(_AIX)",
          "221:   struct stat buf;",
          "222:   if(fstat(req->file, &buf))",
          "223:     return -1;",
          "224:   if(S_ISDIR(buf.st_mode)) {",
          "225:     errno = EISDIR;",
          "226:     return -1;",
          "227:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "683:   dst->st_birthtim.tv_nsec = src->st_birthtimespec.tv_nsec;",
          "684:   dst->st_flags = src->st_flags;",
          "685:   dst->st_gen = src->st_gen;",
          "687:   dst->st_atim.tv_sec = src->st_atim.tv_sec;",
          "688:   dst->st_atim.tv_nsec = src->st_atim.tv_nsec;",
          "689:   dst->st_mtim.tv_sec = src->st_mtim.tv_sec;",
          "",
          "[Removed Lines]",
          "686: #elif defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || defined(_XOPEN_SOURCE)",
          "",
          "[Added Lines]",
          "695: #elif !defined(_AIX) && \\",
          "696:   (defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || defined(_XOPEN_SOURCE))",
          "",
          "---------------"
        ],
        "src/unix/internal.h||src/unix/internal.h": [
          "File: src/unix/internal.h -> src/unix/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: # include <port.h>",
          "45: #if defined(__APPLE__) && !TARGET_OS_IPHONE",
          "46: # include <CoreServices/CoreServices.h>",
          "47: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45: #if defined(_AIX)",
          "46: #define reqevents events",
          "47: #define rtnevents revents",
          "48: #include <sys/poll.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89: # define UV__POLLHUP  UV__EPOLLHUP",
          "90: #endif",
          "93: # define UV__POLLIN   POLLIN",
          "94: # define UV__POLLOUT  POLLOUT",
          "95: # define UV__POLLERR  POLLERR",
          "",
          "[Removed Lines]",
          "92: #if defined(__sun)",
          "",
          "[Added Lines]",
          "98: #if defined(__sun) || defined(_AIX)",
          "",
          "---------------"
        ],
        "src/unix/udp.c||src/unix/udp.c": [
          "File: src/unix/udp.c -> src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "606: static int uv__setsockopt_maybe_char(uv_udp_t* handle, int option, int val) {",
          "608:   char arg = val;",
          "609: #else",
          "610:   int arg = val;",
          "",
          "[Removed Lines]",
          "607: #if defined(__sun)",
          "",
          "[Added Lines]",
          "607: #if defined(__sun) || defined(_AIX)",
          "",
          "---------------"
        ],
        "test/test-fs.c||test/test-fs.c": [
          "File: test/test-fs.c -> test/test-fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "985:   ASSERT(s->st_birthtim.tv_nsec == t.st_birthtimespec.tv_nsec);",
          "986:   ASSERT(s->st_flags == t.st_flags);",
          "987:   ASSERT(s->st_gen == t.st_gen);",
          "988: #elif defined(__sun) || \\",
          "989:       defined(_BSD_SOURCE) || \\",
          "990:       defined(_SVID_SOURCE) || \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "988: #elif defined(_AIX)",
          "989:   ASSERT(s->st_atim.tv_sec == t.st_atime);",
          "990:   ASSERT(s->st_atim.tv_nsec == 0);",
          "991:   ASSERT(s->st_mtim.tv_sec == t.st_mtime);",
          "992:   ASSERT(s->st_mtim.tv_nsec == 0);",
          "993:   ASSERT(s->st_ctim.tv_sec == t.st_ctime);",
          "994:   ASSERT(s->st_ctim.tv_nsec == 0);",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "137:             'include/uv-sunos.h',",
          "138:             'include/uv-darwin.h',",
          "139:             'include/uv-bsd.h',",
          "140:             'src/unix/async.c',",
          "141:             'src/unix/atomic-ops.h',",
          "142:             'src/unix/core.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "140:             'include/uv-aix.h',",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "245:           'defines': [",
          "246:             '_ALL_SOURCE',",
          "247:             '_XOPEN_SOURCE=500',",
          "248:           ],",
          "249:           'link_settings': {",
          "250:             'libraries': [",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "249:             '_LINUX_SOURCE_COMPAT',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1dc2709b999a84520ab1b3c56c0e082bf8617c1f",
      "candidate_info": {
        "commit_hash": "1dc2709b999a84520ab1b3c56c0e082bf8617c1f",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/1dc2709b999a84520ab1b3c56c0e082bf8617c1f",
        "files": [
          "ChangeLog",
          "configure.ac",
          "include/uv-version.h"
        ],
        "message": "Now working on v0.11.23",
        "before_after_code_files": [
          "configure.ac||configure.ac",
          "include/uv-version.h||include/uv-version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
          "15: AC_PREREQ(2.57)",
          "17: AC_CONFIG_MACRO_DIR([m4])",
          "18: m4_include([m4/libuv-extra-automake-flags.m4])",
          "19: AM_INIT_AUTOMAKE([-Wall -Werror foreign subdir-objects] UV_EXTRA_AUTOMAKE_FLAGS)",
          "",
          "[Removed Lines]",
          "16: AC_INIT([libuv], [0.11.22], [https://github.com/joyent/libuv/issues])",
          "",
          "[Added Lines]",
          "16: AC_INIT([libuv], [0.11.23], [https://github.com/joyent/libuv/issues])",
          "",
          "---------------"
        ],
        "include/uv-version.h||include/uv-version.h": [
          "File: include/uv-version.h -> include/uv-version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #define UV_VERSION_MAJOR 0",
          "34: #define UV_VERSION_MINOR 11",
          "",
          "[Removed Lines]",
          "35: #define UV_VERSION_PATCH 22",
          "36: #define UV_VERSION_IS_RELEASE 1",
          "",
          "[Added Lines]",
          "35: #define UV_VERSION_PATCH 23",
          "36: #define UV_VERSION_IS_RELEASE 0",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "76cd67686c36e535660b449fb3bd4042084f12ce",
      "candidate_info": {
        "commit_hash": "76cd67686c36e535660b449fb3bd4042084f12ce",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/76cd67686c36e535660b449fb3bd4042084f12ce",
        "files": [
          "src/unix/getaddrinfo.c",
          "src/uv-common.c"
        ],
        "message": "unix: fix exposing EAI_* glibc-isms",
        "before_after_code_files": [
          "src/unix/getaddrinfo.c||src/unix/getaddrinfo.c",
          "src/uv-common.c||src/uv-common.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/getaddrinfo.c||src/unix/getaddrinfo.c": [
          "File: src/unix/getaddrinfo.c -> src/unix/getaddrinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"uv.h\"",
          "22: #include \"internal.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #ifndef _GNU_SOURCE",
          "25: # define _GNU_SOURCE",
          "26: #endif",
          "",
          "---------------"
        ],
        "src/uv-common.c||src/uv-common.c": [
          "File: src/uv-common.c -> src/uv-common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"uv.h\"",
          "30: #include \"uv-common.h\"",
          "",
          "[Removed Lines]",
          "25: #ifndef _GNU_SOURCE",
          "26: # define _GNU_SOURCE",
          "27: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2b9c374c1c079989864ff632f93e431654f0321c",
      "candidate_info": {
        "commit_hash": "2b9c374c1c079989864ff632f93e431654f0321c",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/2b9c374c1c079989864ff632f93e431654f0321c",
        "files": [
          "Makefile.am",
          "src/win/core.c",
          "test/test-close-order.c",
          "test/test-list.h",
          "uv.gyp"
        ],
        "message": "windows: run close callbacks after polling for i/o\n\nMakes the uv-win behavior compatible with uv-unix.\n\nFixes #796.",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "src/win/core.c||src/win/core.c",
          "test/test-close-order.c||test/test-close-order.c",
          "test/test-list.h||test/test-list.h",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:                          test/test-barrier.c \\",
          "115:                          test/test-callback-order.c \\",
          "116:                          test/test-callback-stack.c \\",
          "117:                          test/test-condvar.c \\",
          "118:                          test/test-connection-fail.c \\",
          "119:                          test/test-cwd-and-chdir.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117:                          test/test-close-order.c \\",
          "",
          "---------------"
        ],
        "src/win/core.c||src/win/core.c": [
          "File: src/win/core.c -> src/win/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "281:     uv_process_timers(loop);",
          "283:     uv_process_reqs(loop);",
          "286:     uv_idle_invoke(loop);",
          "288:     uv_prepare_invoke(loop);",
          "290:     (*poll)(loop, loop->idle_handles == NULL &&",
          "",
          "[Removed Lines]",
          "284:     uv_process_endgames(loop);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "296:                   !(mode & UV_RUN_NOWAIT));",
          "298:     uv_check_invoke(loop);",
          "300:     if (mode == UV_RUN_ONCE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "296:     uv_process_endgames(loop);",
          "",
          "---------------"
        ],
        "test/test-close-order.c||test/test-close-order.c": [
          "File: test/test-close-order.c -> test/test-close-order.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"uv.h\"",
          "23: #include \"task.h\"",
          "25: static int check_cb_called;",
          "26: static int timer_cb_called;",
          "27: static int close_cb_called;",
          "29: static uv_check_t check_handle;",
          "30: static uv_timer_t timer_handle1;",
          "31: static uv_timer_t timer_handle2;",
          "34: static void close_cb(uv_handle_t* handle) {",
          "35:   ASSERT(handle != NULL);",
          "36:   close_cb_called++;",
          "37: }",
          "41: static void check_cb(uv_check_t* handle, int status) {",
          "42:   ASSERT(check_cb_called == 0);",
          "43:   ASSERT(timer_cb_called == 1);",
          "44:   ASSERT(close_cb_called == 0);",
          "45:   uv_close((uv_handle_t*) handle, close_cb);",
          "46:   uv_close((uv_handle_t*) &timer_handle2, close_cb);",
          "47:   check_cb_called++;",
          "48: }",
          "51: static void timer_cb(uv_timer_t* handle, int status) {",
          "52:   uv_close((uv_handle_t*) handle, close_cb);",
          "53:   timer_cb_called++;",
          "54: }",
          "57: TEST_IMPL(close_order) {",
          "58:   uv_loop_t* loop;",
          "59:   loop = uv_default_loop();",
          "61:   uv_check_init(loop, &check_handle);",
          "62:   uv_check_start(&check_handle, check_cb);",
          "63:   uv_timer_init(loop, &timer_handle1);",
          "64:   uv_timer_start(&timer_handle1, timer_cb, 0, 0);",
          "65:   uv_timer_init(loop, &timer_handle2);",
          "66:   uv_timer_start(&timer_handle2, timer_cb, 100000, 0);",
          "68:   ASSERT(check_cb_called == 0);",
          "69:   ASSERT(close_cb_called == 0);",
          "70:   ASSERT(timer_cb_called == 0);",
          "72:   uv_run(loop, UV_RUN_DEFAULT);",
          "74:   ASSERT(check_cb_called == 1);",
          "75:   ASSERT(close_cb_called == 3);",
          "76:   ASSERT(timer_cb_called == 1);",
          "78:   MAKE_VALGRIND_HAPPY();",
          "79:   return 0;",
          "80: }",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: TEST_DECLARE   (platform_output)",
          "23: TEST_DECLARE   (callback_order)",
          "24: TEST_DECLARE   (run_once)",
          "25: TEST_DECLARE   (run_nowait)",
          "26: TEST_DECLARE   (loop_stop)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: TEST_DECLARE   (close_order)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "242: #if 0",
          "243:   TEST_ENTRY  (callback_order)",
          "244: #endif",
          "245:   TEST_ENTRY  (run_once)",
          "246:   TEST_ENTRY  (run_nowait)",
          "247:   TEST_ENTRY  (loop_stop)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246:   TEST_ENTRY  (close_order)",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "297:         'test/test-async-null-cb.c',",
          "298:         'test/test-callback-stack.c',",
          "299:         'test/test-callback-order.c',",
          "300:         'test/test-connection-fail.c',",
          "301:         'test/test-cwd-and-chdir.c',",
          "302:         'test/test-delayed-accept.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "300:         'test/test-close-order.c',",
          "",
          "---------------"
        ]
      }
    }
  ]
}
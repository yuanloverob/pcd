{
  "cve_id": "CVE-2019-19924",
  "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
  "repo": "sqlite/sqlite",
  "patch_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
  "patch_info": {
    "commit_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/vdbeaux.c",
      "src/window.c"
    ],
    "message": "When an error occurs while rewriting the parser tree for window functions in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/vdbeaux.c||src/vdbeaux.c",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "376:   int addr;",
      "377:   CollSeq *p4;",
      "379:   if( isCommuted ){",
      "380:     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);",
      "381:   }else{",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:   if( pParse->nErr ) return 0;",
      "",
      "---------------"
    ],
    "src/vdbeaux.c||src/vdbeaux.c": [
      "File: src/vdbeaux.c -> src/vdbeaux.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1304: static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){",
      "1305:   assert( p->nOp>0 || p->aOp==0 );",
      "1307:   if( p->nOp ){",
      "1308:     assert( p->aOp );",
      "1309:     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
      "",
      "[Removed Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );",
      "",
      "[Added Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
      "1307:           || p->pParse->nErr>0 );",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "935:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
      "936:     if( pTab==0 ){",
      "938:     }",
      "940:     p->pSrc = 0;",
      "",
      "[Removed Lines]",
      "937:       return SQLITE_NOMEM;",
      "",
      "[Added Lines]",
      "937:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1039:     sqlite3DbFree(db, pTab);",
      "1040:   }",
      "1042:   return rc;",
      "1043: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1042:   if( rc && pParse->nErr==0 ){",
      "1043:     assert( pParse->db->mallocFailed );",
      "1044:     return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
      "1045:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "427b96aedf422b1a8e906e47e8852033c70939c4",
      "candidate_info": {
        "commit_hash": "427b96aedf422b1a8e906e47e8852033c70939c4",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/427b96aedf422b1a8e906e47e8852033c70939c4",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/insert.c",
          "src/sqliteInt.h",
          "src/update.c"
        ],
        "message": "New testcase() macros.  Fix a problem with INSERT when the IPK is to the right of generated columns.\n\nFossilOrigin-Name: 412799fc5527aaca987e4e04b8a4f774dcdb70fb80e3a126dc3a26d48a66935c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/insert.c||src/insert.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/update.c||src/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ba123b8c201053d8f9387de38f3513b06f7721b28d79fab8489f96d336105117",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2207:   }",
          "2209: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "2211:     int ii;",
          "2212:     for(ii=0; ii<p->nCol; ii++){",
          "2213:       u32 colFlags = p->aCol[ii].colFlags;",
          "2215:         sqlite3ResolveSelfReference(pParse, p, NC_GenCol,",
          "2216:                                     p->aCol[ii].pDflt, 0);",
          "2217:       }",
          "",
          "[Removed Lines]",
          "2210:   if( p->tabFlags & (TF_HasVirtual|TF_HasStored) ){",
          "2214:       if( (colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL))!=0 ){",
          "",
          "[Added Lines]",
          "2210:   if( p->tabFlags & TF_HasGenerated ){",
          "2212:     testcase( p->tabFlags & TF_HasVirtual );",
          "2213:     testcase( p->tabFlags & TF_HasStored );",
          "2216:       if( (colFlags & COLFLAG_GENERATED)!=0 ){",
          "2217:         testcase( colFlags & COLFLAG_VIRTUAL );",
          "2218:         testcase( colFlags & COLFLAG_STORED );",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:   for(i=0; i<pTab->nCol; i++){",
          "224:     if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "225:       pTab->aCol[i].colFlags |= COLFLAG_NOTAVAIL;",
          "226:     }",
          "227:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225:       testcase( pTab->aCol[i].colflags & COLFLAG_VIRTUAL );",
          "226:       testcase( pTab->aCol[i].colflags & COLFLAG_STORED );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "855:   if( pColumn==0 && nColumn>0 ){",
          "856:     ipkColumn = pTab->iPKey;",
          "857:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "859: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "860:     if( pTab->tabFlags & TF_HasGenerated ){",
          "861:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "862:       testcase( pTab->tabFlags & TF_HasGenerated );",
          "863:       for(i=ipkColumn-1; i>=0; i--){",
          "864:         if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "865:           testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "866:           testcase( pTab->aCol[i].colFlags & COLFLAG_GENERATED );",
          "867:           ipkColumn--;",
          "868:         }",
          "869:       }",
          "870:     }",
          "871: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1074:       sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab);",
          "1075:     }",
          "1076: #endif",
          "",
          "[Removed Lines]",
          "1073:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "1088:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1089:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1090:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1143:       sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab);",
          "1144:     }",
          "1145: #endif",
          "",
          "[Removed Lines]",
          "1142:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "1159:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1160:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1161:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1486:     testcase( i!=sqlite3TableColumnToStorage(pTab, i) );",
          "1487:     testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "1488:     testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "1490:     iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;",
          "1491:     switch( onError ){",
          "1492:       case OE_Replace: {",
          "",
          "[Removed Lines]",
          "1489:     testcase( pTab->aCol[i].colFlags & COLFLAG_GENERATED );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2423:     if( (pDestCol->colFlags & COLFLAG_GENERATED)!=0 ){",
          "2424:       if( sqlite3ExprCompare(0, pSrcCol->pDflt, pDestCol->pDflt, -1)!=0 ){",
          "2426:       }",
          "2427:     }",
          "2428:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2443:         testcase( pDestCol->colflags & COLFLAG_VIRTUAL );",
          "2444:         testcase( pDestCol->colflags & COLFLAG_STORED );",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:           chngPk = 1;",
          "314:         }",
          "315: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "317:           sqlite3ErrorMsg(pParse,",
          "318:              \"cannot UPDATE generated column \\\"%s\\\"\",",
          "319:              pTab->aCol[j].zName);",
          "",
          "[Removed Lines]",
          "316:         else if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){",
          "",
          "[Added Lines]",
          "316:         else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){",
          "317:           testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "318:           testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "693:     }",
          "694:   }",
          "695: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "697:     sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "698:   }",
          "699: #endif",
          "",
          "[Removed Lines]",
          "696:   if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "698:   if( pTab->tabFlags & TF_HasGenerated ){",
          "699:     testcase( pTab->tabFlags & TF_HasVirtual );",
          "700:     testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:       }",
          "738:     }",
          "739: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "741:       sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "742:     }",
          "743: #endif",
          "",
          "[Removed Lines]",
          "740:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "744:     if( pTab->tabFlags & TF_HasGenerated ){",
          "745:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "746:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
      "candidate_info": {
        "commit_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/85bcdce270575e78258148c00f2efff7e81e7bc1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/sqliteInt.h",
          "src/wherecode.c"
        ],
        "message": "Split the code generation for the RHS of IN operators and for SELECT and EXISTS expressions into two separate subroutines, because there is now little commonality between those to functions. This is intended to help make the code easier to read and maintain.\n\nFossilOrigin-Name: 2b6494b1509f0d0189f98aa34c990eee99c775ff57826e79b2c5b0a12b4c97ad",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/wherecode.c||src/wherecode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6231485114eb07b258cd0e6e163ca05f7e9cf5664e071808fcb1329b33e4c4f5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "481:   int reg = 0;",
          "482: #ifndef SQLITE_OMIT_SUBQUERY",
          "483:   if( pExpr->op==TK_SELECT ){",
          "485:   }",
          "486: #endif",
          "487:   return reg;",
          "",
          "[Removed Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "",
          "[Added Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2542:     }else if( prRhsHasNull ){",
          "2544:     }",
          "2546:     pParse->nQueryLoop = savedNQueryLoop;",
          "2547:   }else{",
          "2548:     pX->iTable = iTab;",
          "",
          "[Removed Lines]",
          "2545:     sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==IN_INDEX_ROWID);",
          "",
          "[Added Lines]",
          "2545:     assert( pX->op==TK_IN );",
          "2546:     sqlite3CodeRhsOfIN(pParse, pX, eType==IN_INDEX_ROWID);",
          "2547:     if( rMayHaveNull ){",
          "2548:       sqlite3SetHasNullFlag(v, pX->iTable, rMayHaveNull);",
          "2549:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2626:   }",
          "2627: }",
          "2664: ){",
          "",
          "[Removed Lines]",
          "2658: #ifndef SQLITE_OMIT_SUBQUERY",
          "2659: int sqlite3CodeSubselect(",
          "2667:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2668:   if( NEVER(v==0) ) return 0;",
          "",
          "[Added Lines]",
          "2633: #ifndef SQLITE_OMIT_SUBQUERY",
          "2658: void sqlite3CodeRhsOfIN(",
          "2670:   v = sqlite3GetVdbe(pParse);",
          "2671:   assert( v!=0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2681:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2682:   }",
          "2810:       }",
          "2813:       }",
          "2815:     }",
          "2859:       }",
          "2864:       }else{",
          "2870:       }",
          "2874:     }",
          "2875:   }",
          "2879:   }",
          "2881:   if( jmpIfDynamic>=0 ){",
          "2882:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "",
          "[Removed Lines]",
          "2684:   switch( pExpr->op ){",
          "2685:     case TK_IN: {",
          "2691:       nVal = sqlite3ExprVectorSize(pLeft);",
          "2692:       assert( !isRowid || nVal==1 );",
          "2707:       pExpr->iTable = pParse->nTab++;",
          "2708:       addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2709:           pExpr->iTable, (isRowid?0:nVal));",
          "2710:       pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2712:       if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2718:         Select *pSelect = pExpr->x.pSelect;",
          "2719:         ExprList *pEList = pSelect->pEList;",
          "2721:         ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2722:             jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2723:         ));",
          "2724:         assert( !isRowid );",
          "2727:         if( ALWAYS(pEList->nExpr==nVal) ){",
          "2728:           SelectDest dest;",
          "2729:           int i;",
          "2730:           sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2731:           dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2732:           pSelect->iLimit = 0;",
          "2733:           testcase( pSelect->selFlags & SF_Distinct );",
          "2735:           if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2736:             sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2737:             sqlite3KeyInfoUnref(pKeyInfo);",
          "2738:             return 0;",
          "2739:           }",
          "2740:           sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2742:           assert( pEList!=0 );",
          "2743:           assert( pEList->nExpr>0 );",
          "2744:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2745:           for(i=0; i<nVal; i++){",
          "2746:             Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2747:             pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2748:                 pParse, p, pEList->a[i].pExpr",
          "2749:             );",
          "2750:           }",
          "2751:         }",
          "2752:       }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2761:         int i;",
          "2762:         ExprList *pList = pExpr->x.pList;",
          "2763:         struct ExprList_item *pItem;",
          "2764:         int r1, r2, r3;",
          "2765:         affinity = sqlite3ExprAffinity(pLeft);",
          "2766:         if( !affinity ){",
          "2767:           affinity = SQLITE_AFF_BLOB;",
          "2768:         }",
          "2769:         if( pKeyInfo ){",
          "2770:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2771:           pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2772:         }",
          "2775:         r1 = sqlite3GetTempReg(pParse);",
          "2776:         r2 = sqlite3GetTempReg(pParse);",
          "2777:         if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2778:         for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2779:           Expr *pE2 = pItem->pExpr;",
          "2780:           int iValToIns;",
          "2787:           if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2788:             sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2789:             jmpIfDynamic = -1;",
          "2790:           }",
          "2793:           if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2794:             sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2795:           }else{",
          "2796:             r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2797:             if( isRowid ){",
          "2798:               sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2799:                                 sqlite3VdbeCurrentAddr(v)+2);",
          "2800:               VdbeCoverage(v);",
          "2801:               sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2802:             }else{",
          "2803:               sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2804:               sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2805:             }",
          "2806:           }",
          "2807:         }",
          "2808:         sqlite3ReleaseTempReg(pParse, r1);",
          "2809:         sqlite3ReleaseTempReg(pParse, r2);",
          "2811:       if( pKeyInfo ){",
          "2812:         sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2814:       break;",
          "2817:     case TK_EXISTS:",
          "2818:     case TK_SELECT:",
          "2819:     default: {",
          "2838:       testcase( pExpr->op==TK_EXISTS );",
          "2839:       testcase( pExpr->op==TK_SELECT );",
          "2840:       assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2841:       assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2843:       pSel = pExpr->x.pSelect;",
          "2844:       ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2845:             jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2846:       nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2847:       sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2848:       pParse->nMem += nReg;",
          "2849:       if( pExpr->op==TK_SELECT ){",
          "2850:         dest.eDest = SRT_Mem;",
          "2851:         dest.iSdst = dest.iSDParm;",
          "2852:         dest.nSdst = nReg;",
          "2853:         sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2854:         VdbeComment((v, \"Init subquery result\"));",
          "2855:       }else{",
          "2856:         dest.eDest = SRT_Exists;",
          "2857:         sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2858:         VdbeComment((v, \"Init EXISTS result\"));",
          "2860:       pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2861:       if( pSel->pLimit ){",
          "2862:         sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2863:         pSel->pLimit->pLeft = pLimit;",
          "2865:         pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2866:       }",
          "2867:       pSel->iLimit = 0;",
          "2868:       if( sqlite3Select(pParse, pSel, &dest) ){",
          "2869:         return 0;",
          "2871:       rReg = dest.iSDParm;",
          "2872:       ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "2873:       break;",
          "2877:   if( rHasNullFlag ){",
          "2878:     sqlite3SetHasNullFlag(v, pExpr->iTable, rHasNullFlag);",
          "",
          "[Added Lines]",
          "2688:   pLeft = pExpr->pLeft;",
          "2689:   nVal = sqlite3ExprVectorSize(pLeft);",
          "2690:   assert( !isRowid || nVal==1 );",
          "2695:   pExpr->iTable = pParse->nTab++;",
          "2696:   addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2697:       pExpr->iTable, (isRowid?0:nVal));",
          "2698:   pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2700:   if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2706:     Select *pSelect = pExpr->x.pSelect;",
          "2707:     ExprList *pEList = pSelect->pEList;",
          "2709:     ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2710:         jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2711:     ));",
          "2712:     assert( !isRowid );",
          "2715:     if( ALWAYS(pEList->nExpr==nVal) ){",
          "2716:       SelectDest dest;",
          "2717:       int i;",
          "2718:       sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2719:       dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2720:       pSelect->iLimit = 0;",
          "2721:       testcase( pSelect->selFlags & SF_Distinct );",
          "2723:       if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2724:         sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2725:         sqlite3KeyInfoUnref(pKeyInfo);",
          "2726:         return;",
          "2728:       sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2730:       assert( pEList!=0 );",
          "2731:       assert( pEList->nExpr>0 );",
          "2732:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2733:       for(i=0; i<nVal; i++){",
          "2734:         Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2735:         pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2736:             pParse, p, pEList->a[i].pExpr",
          "2737:         );",
          "2740:   }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2749:     int i;",
          "2750:     ExprList *pList = pExpr->x.pList;",
          "2751:     struct ExprList_item *pItem;",
          "2752:     int r1, r2, r3;",
          "2753:     affinity = sqlite3ExprAffinity(pLeft);",
          "2754:     if( !affinity ){",
          "2755:       affinity = SQLITE_AFF_BLOB;",
          "2756:     }",
          "2757:     if( pKeyInfo ){",
          "2758:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2759:       pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2760:     }",
          "2763:     r1 = sqlite3GetTempReg(pParse);",
          "2764:     r2 = sqlite3GetTempReg(pParse);",
          "2765:     if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2766:     for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2767:       Expr *pE2 = pItem->pExpr;",
          "2768:       int iValToIns;",
          "2775:       if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2776:         sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2777:         jmpIfDynamic = -1;",
          "2781:       if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2782:         sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2784:         r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2785:         if( isRowid ){",
          "2786:           sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2787:                             sqlite3VdbeCurrentAddr(v)+2);",
          "2788:           VdbeCoverage(v);",
          "2789:           sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2790:         }else{",
          "2791:           sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2792:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2793:         }",
          "2796:     sqlite3ReleaseTempReg(pParse, r1);",
          "2797:     sqlite3ReleaseTempReg(pParse, r2);",
          "2799:   if( pKeyInfo ){",
          "2800:     sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2801:   }",
          "2802:   if( jmpIfDynamic>=0 ){",
          "2803:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "2804:   }",
          "2805: }",
          "2822: #ifndef SQLITE_OMIT_SUBQUERY",
          "2823: int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){",
          "2830:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2831:   assert( v!=0 );",
          "2843:   if( !ExprHasProperty(pExpr, EP_VarSelect) ){",
          "2844:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2845:   }",
          "2857:   testcase( pExpr->op==TK_EXISTS );",
          "2858:   testcase( pExpr->op==TK_SELECT );",
          "2859:   assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2860:   assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2862:   pSel = pExpr->x.pSelect;",
          "2863:   ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2864:         jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2865:   nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2866:   sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2867:   pParse->nMem += nReg;",
          "2868:   if( pExpr->op==TK_SELECT ){",
          "2869:     dest.eDest = SRT_Mem;",
          "2870:     dest.iSdst = dest.iSDParm;",
          "2871:     dest.nSdst = nReg;",
          "2872:     sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2873:     VdbeComment((v, \"Init subquery result\"));",
          "2874:   }else{",
          "2875:     dest.eDest = SRT_Exists;",
          "2876:     sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2877:     VdbeComment((v, \"Init EXISTS result\"));",
          "2878:   }",
          "2879:   pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2880:   if( pSel->pLimit ){",
          "2881:     sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2882:     pSel->pLimit->pLeft = pLimit;",
          "2883:   }else{",
          "2884:     pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2885:   }",
          "2886:   pSel->iLimit = 0;",
          "2887:   if( sqlite3Select(pParse, pSel, &dest) ){",
          "2888:     return 0;",
          "2890:   rReg = dest.iSDParm;",
          "2891:   ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3343: #if SQLITE_OMIT_SUBQUERY",
          "3344:       iResult = 0;",
          "3345: #else",
          "3347: #endif",
          "3348:     }else{",
          "3349:       int i;",
          "",
          "[Removed Lines]",
          "3346:       iResult = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "3358:       iResult = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3817:       if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){",
          "3818:         sqlite3SubselectError(pParse, nCol, 1);",
          "3819:       }else{",
          "3821:       }",
          "3822:       break;",
          "3823:     }",
          "3824:     case TK_SELECT_COLUMN: {",
          "3825:       int n;",
          "3826:       if( pExpr->pLeft->iTable==0 ){",
          "3828:       }",
          "3829:       assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );",
          "3830:       if( pExpr->iTable",
          "",
          "[Removed Lines]",
          "3820:         return sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "3827:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft, 0, 0);",
          "",
          "[Added Lines]",
          "3832:         return sqlite3CodeSubselect(pParse, pExpr);",
          "3839:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4258: int sqlite3GetToken(const unsigned char *, int *);",
          "4259: void sqlite3NestedParse(Parse*, const char*, ...);",
          "4260: void sqlite3ExpirePreparedStatements(sqlite3*, int);",
          "4262: void sqlite3SelectPrep(Parse*, Select*, NameContext*);",
          "4263: void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);",
          "4264: int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);",
          "",
          "[Removed Lines]",
          "4261: int sqlite3CodeSubselect(Parse*, Expr *, int, int);",
          "",
          "[Added Lines]",
          "4261: void sqlite3CodeRhsOfIN(Parse*, Expr*, int);",
          "4262: int sqlite3CodeSubselect(Parse*, Expr*);",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1076: #ifndef SQLITE_OMIT_SUBQUERY",
          "1077:     if( (p->flags & EP_xIsSelect) ){",
          "1078:       Vdbe *v = pParse->pVdbe;",
          "1080:       sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);",
          "1081:     }else",
          "1082: #endif",
          "",
          "[Removed Lines]",
          "1079:       int iSelect = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "1079:       int iSelect;",
          "1080:       assert( p->op==TK_SELECT );",
          "1081:       iSelect = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a786e453a4c03c958feb30bfda4153a24bb393e6",
      "candidate_info": {
        "commit_hash": "a786e453a4c03c958feb30bfda4153a24bb393e6",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a786e453a4c03c958feb30bfda4153a24bb393e6",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/window.c"
        ],
        "message": "Simplify the windows frame code some. Add a comment explaining some of the VM code generated by sqlite3WindowCodeStep().\n\nFossilOrigin-Name: 6bd1a07949ff3d394056bfcc813444401ef00806e3f0e0423ff6962541e84bdb",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/window.c||src/window.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/window.c||src/window.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: e7bced731aa071c95bc398cdecd53c939841bf0c52fbcd06e47ba68f8c5cc35a",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1698:   return ret;",
          "1699: }",
          "1774: ){",
          "1775:   Window *pMWin = p->pWin;",
          "1776:   ExprList *pOrderBy = pMWin->pOrderBy;",
          "1777:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "1794:   int addrShortcut = 0;",
          "1810:   assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT",
          "1811:        || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED",
          "",
          "[Removed Lines]",
          "1768: static void windowCodeStep(",
          "1769:   Parse *pParse,",
          "1770:   Select *p,",
          "1771:   WhereInfo *pWInfo,",
          "1772:   int regGosub,",
          "1773:   int addrGosub",
          "1780:   int regArg;",
          "1781:   int csrWrite = pMWin->iEphCsr+1;",
          "1787:   int addrGoto;",
          "1788:   int addrIf;",
          "1789:   int addrGosubFlush;",
          "1790:   int addrInteger;",
          "1791:   int addrCacheRewind;",
          "1792:   int addrCacheNext;",
          "1795:   int addrEmpty = 0;",
          "1796:   int addrPeerJump = 0;",
          "1798:   int bCache = windowCachePartition(pMWin);",
          "1803:   int reg = pParse->nMem+1;",
          "1804:   int regRecord = reg+nSub;",
          "1805:   int regRowid = regRecord+1;",
          "1806:   int regPeer = 0;",
          "1807:   int regNewPeer = 0;",
          "1808:   WindowCodeArg s;",
          "",
          "[Added Lines]",
          "1707: Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){",
          "1708:   Window *pNew = 0;",
          "1709:   if( ALWAYS(p) ){",
          "1710:     pNew = sqlite3DbMallocZero(db, sizeof(Window));",
          "1711:     if( pNew ){",
          "1712:       pNew->zName = sqlite3DbStrDup(db, p->zName);",
          "1713:       pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);",
          "1714:       pNew->pFunc = p->pFunc;",
          "1715:       pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);",
          "1716:       pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);",
          "1717:       pNew->eType = p->eType;",
          "1718:       pNew->eEnd = p->eEnd;",
          "1719:       pNew->eStart = p->eStart;",
          "1720:       pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);",
          "1721:       pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);",
          "1722:       pNew->pOwner = pOwner;",
          "1723:     }",
          "1724:   }",
          "1725:   return pNew;",
          "1726: }",
          "1732: Window *sqlite3WindowListDup(sqlite3 *db, Window *p){",
          "1733:   Window *pWin;",
          "1734:   Window *pRet = 0;",
          "1735:   Window **pp = &pRet;",
          "1737:   for(pWin=p; pWin; pWin=pWin->pNextWin){",
          "1739:     if( *pp==0 ) break;",
          "1740:     pp = &((*pp)->pNextWin);",
          "1741:   }",
          "1743:   return pRet;",
          "1744: }",
          "1946: void sqlite3WindowCodeStep(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1814:        || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING",
          "1815:   );",
          "1817:   memset(&s, 0, sizeof(WindowCodeArg));",
          "1818:   s.pParse = pParse;",
          "1819:   s.pMWin = pMWin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1989:   bCache = windowCachePartition(pMWin);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1821:   s.regGosub = regGosub;",
          "1822:   s.addrGosub = addrGosub;",
          "1823:   s.current.csr = pMWin->iEphCsr;",
          "1824:   s.start.csr = s.current.csr+2;",
          "1825:   s.end.csr = s.current.csr+3;",
          "1829:   regFlushPart = ++pParse->nMem;",
          "1831:   if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING ){",
          "1832:     regStart = ++pParse->nMem;",
          "1833:   }",
          "",
          "[Removed Lines]",
          "1827:   pParse->nMem += 1 + nSub + 1;",
          "",
          "[Added Lines]",
          "1999:   csrWrite = s.current.csr+1;",
          "2003:   regNew = pParse->nMem+1;",
          "2004:   pParse->nMem += nInput;",
          "2005:   regRecord = ++pParse->nMem;",
          "2006:   regRowid = ++pParse->nMem;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1836:   }",
          "1841:   if( pMWin->eType!=TK_ROWS ){",
          "1842:     int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);",
          "1844:     if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;",
          "1846:     regPeer = pParse->nMem+1;       pParse->nMem += nPeer;",
          "1847:     s.start.reg = pParse->nMem+1;   pParse->nMem += nPeer;",
          "1848:     s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;",
          "",
          "[Removed Lines]",
          "1843:     regNewPeer = reg + pMWin->nBufferCol;",
          "",
          "[Added Lines]",
          "2024:     regNewPeer = regNew + pMWin->nBufferCol;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1850:   }",
          "1857:   }",
          "1866:   if( pMWin->pPartition ){",
          "1867:     int addr;",
          "1868:     ExprList *pPart = pMWin->pPartition;",
          "1869:     int nPart = pPart->nExpr;",
          "1871:     KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);",
          "1873:     addr = sqlite3VdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart, nPart);",
          "",
          "[Removed Lines]",
          "1855:   for(iCol=0; iCol<nSub; iCol++){",
          "1856:     sqlite3VdbeAddOp3(v, OP_Column, iSubCsr, iCol, reg+iCol);",
          "1858:   sqlite3VdbeAddOp3(v, OP_MakeRecord, reg, nSub, regRecord);",
          "1870:     int regNewPart = reg + pMWin->nBufferCol;",
          "",
          "[Added Lines]",
          "2035:   for(iInput=0; iInput<nInput; iInput++){",
          "2036:     sqlite3VdbeAddOp3(v, OP_Column, csrInput, iInput, regNew+iInput);",
          "2038:   sqlite3VdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);",
          "2049:     int regNewPart = regNew + pMWin->nBufferCol;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1893:     }",
          "1894:     addrCacheRewind = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);",
          "1895:   }else{",
          "1897:   }",
          "1902:   if( regStart ){",
          "1903:     sqlite3ExprCode(pParse, pMWin->pStart, regStart);",
          "",
          "[Removed Lines]",
          "1896:     addrIf = sqlite3VdbeAddOp1(v, OP_IfNot, pMWin->regFirst);",
          "1900:   s.regArg = regArg = windowInitAccum(pParse, pMWin);",
          "",
          "[Added Lines]",
          "2075:     addrIfNot = sqlite3VdbeAddOp1(v, OP_IfNot, pMWin->regFirst);",
          "2079:   s.regArg = windowInitAccum(pParse, pMWin);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1950:   addrGoto = sqlite3VdbeAddOp0(v, OP_Goto);",
          "1954:   if( bCache ){",
          "1955:     addrCacheNext = sqlite3VdbeCurrentAddr(v);",
          "1956:     if( pMWin->eType!=TK_ROWS ){",
          "1957:       windowReadPeerValues(&s, csrWrite, regNewPeer);",
          "1958:     }",
          "1959:   }else{",
          "1961:   }",
          "1962:   if( regPeer ){",
          "1963:     addrPeerJump = windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer);",
          "",
          "[Removed Lines]",
          "1953:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep.SECOND_ROW_CODE\"));",
          "1960:     sqlite3VdbeJumpHere(v, addrIf);",
          "",
          "[Added Lines]",
          "2132:   VdbeModuleComment((pParse->pVdbe, \"Begin WindowCodeStep.SECOND_ROW\"));",
          "2139:     sqlite3VdbeJumpHere(v, addrIfNot);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2011:   if( addrPeerJump ){",
          "2012:     sqlite3VdbeJumpHere(v, addrPeerJump);",
          "2013:   }",
          "2017:   sqlite3VdbeJumpHere(v, addrGoto);",
          "",
          "[Removed Lines]",
          "2014:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep.SECOND_ROW_CODE\"));",
          "",
          "[Added Lines]",
          "2193:   VdbeModuleComment((pParse->pVdbe, \"End WindowCodeStep.SECOND_ROW\"));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2029:     sqlite3VdbeJumpHere(v, addrGosubFlush);",
          "2030:   }",
          "2033:   addrEmpty = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);",
          "2034:   if( pMWin->eEnd==TK_PRECEDING ){",
          "2035:     windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);",
          "",
          "[Removed Lines]",
          "2032:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep.FLUSH_CODE\"));",
          "",
          "[Added Lines]",
          "2211:   VdbeModuleComment((pParse->pVdbe, \"Begin WindowCodeStep.FLUSH\"));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2079:   sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);",
          "2080:   sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regSize);",
          "2081:   if( bCache==0 ) sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regFirst);",
          "2083:   if( pMWin->pPartition ){",
          "2084:     sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));",
          "2085:     sqlite3VdbeAddOp1(v, OP_Return, regFlushPart);",
          "2086:   }",
          "2087: }",
          "",
          "[Removed Lines]",
          "2082:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep.FLUSH_CODE\"));",
          "2095: Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){",
          "2096:   Window *pNew = 0;",
          "2097:   if( ALWAYS(p) ){",
          "2098:     pNew = sqlite3DbMallocZero(db, sizeof(Window));",
          "2099:     if( pNew ){",
          "2100:       pNew->zName = sqlite3DbStrDup(db, p->zName);",
          "2101:       pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);",
          "2102:       pNew->pFunc = p->pFunc;",
          "2103:       pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);",
          "2104:       pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);",
          "2105:       pNew->eType = p->eType;",
          "2106:       pNew->eEnd = p->eEnd;",
          "2107:       pNew->eStart = p->eStart;",
          "2108:       pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);",
          "2109:       pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);",
          "2110:       pNew->pOwner = pOwner;",
          "2111:     }",
          "2112:   }",
          "2113:   return pNew;",
          "2114: }",
          "2120: Window *sqlite3WindowListDup(sqlite3 *db, Window *p){",
          "2121:   Window *pWin;",
          "2122:   Window *pRet = 0;",
          "2123:   Window **pp = &pRet;",
          "2125:   for(pWin=p; pWin; pWin=pWin->pNextWin){",
          "2127:     if( *pp==0 ) break;",
          "2128:     pp = &((*pp)->pNextWin);",
          "2129:   }",
          "2131:   return pRet;",
          "2132: }",
          "2141: void sqlite3WindowCodeStep(",
          "2147: ){",
          "2148:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep()\"));",
          "2149:   windowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);",
          "2150:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep()\"));",
          "2151: }",
          "",
          "[Added Lines]",
          "2261:   VdbeModuleComment((pParse->pVdbe, \"End WindowCodeStep.FLUSH\"));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b10a50e7f829f7038242db6f52b557e7624df412",
      "candidate_info": {
        "commit_hash": "b10a50e7f829f7038242db6f52b557e7624df412",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b10a50e7f829f7038242db6f52b557e7624df412",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/dbfuzz2.c"
        ],
        "message": "In dbfuzz2, avoid using a malloc in the LLVMFuzzerInitialize() initializer routine, so that no memory leaks are reported.  Also, show the version of SQLite being used when the -v option is on.\n\nFossilOrigin-Name: 824f93246988ffa213bbd41a7de08886999b1a8ae00fdf6b9767acb6e3ec6a1f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/dbfuzz2.c||test/dbfuzz2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 97e723d746eeb2159f5bf1701532271ac6a4620879c82d496f4499c178b64479",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/dbfuzz2.c||test/dbfuzz2.c": [
          "File: test/dbfuzz2.c -> test/dbfuzz2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: int LLVMFuzzerInitialize(int *pArgc, char ***pArgv){",
          "135:   int i, j, n;",
          "136:   int argc = *pArgc;",
          "138:   char **argv = *pArgv;",
          "142:   for(i=j=1; i<argc; i++){",
          "143:     char *z = argv[i];",
          "144:     if( z[0]=='-' ){",
          "",
          "[Removed Lines]",
          "137:   char **newArgv;",
          "139:   newArgv = malloc( sizeof(char*)*(argc+1) );",
          "140:   if( newArgv==0 ) return 0;",
          "141:   newArgv[0] = argv[0];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:         continue;",
          "154:       }",
          "155:     }",
          "157:   }",
          "161:   return 0;",
          "162: }",
          "",
          "[Removed Lines]",
          "156:     newArgv[j++] = argv[i];",
          "158:   newArgv[j] = 0;",
          "",
          "[Added Lines]",
          "152:     argv[j++] = argv[i];",
          "154:   argv[j] = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "202:       free(pIn);",
          "203:     }",
          "204:   }",
          "205:   return 0;",
          "206: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:   if( eVerbosity>0 ){",
          "201:     printf(\"SQLite %s\\n\", sqlite3_sourceid());",
          "202:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1417c2f77f4c63d3a18bff4c21a933cfe4b5daee",
      "candidate_info": {
        "commit_hash": "1417c2f77f4c63d3a18bff4c21a933cfe4b5daee",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1417c2f77f4c63d3a18bff4c21a933cfe4b5daee",
        "files": [
          "manifest",
          "manifest.uuid",
          "tool/lemon.c"
        ],
        "message": "Fix the parse.sql output file so that it is readable into a database where foreign keys are enforced.\n\nFossilOrigin-Name: 3a82c554c3bde4640df6865686f8f70e2c1e07c581fed4772b6b0a8ec1b10bb6",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "tool/lemon.c||tool/lemon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 0fab65c79f675c825ed7e85c82b65ce6f990c9d0796ebb3886942d241df7b268",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4189:       return;",
          "4190:     }",
          "4191:     fprintf(sql,",
          "4192:        \"CREATE TABLE symbol(\\n\"",
          "4193:        \"  id INTEGER PRIMARY KEY,\\n\"",
          "4194:        \"  name TEXT NOT NULL,\\n\"",
          "4195:        \"  isTerminal BOOLEAN NOT NULL,\\n\"",
          "4197:        \");\\n\"",
          "4198:     );",
          "4199:     for(i=0; i<lemp->nsymbol; i++){",
          "",
          "[Removed Lines]",
          "4196:        \"  fallback INTEGER REFERENCES symbol\\n\"",
          "",
          "[Added Lines]",
          "4192:        \"BEGIN;\\n\"",
          "4197:        \"  fallback INTEGER REFERENCES symbol\"",
          "4198:                \" DEFERRABLE INITIALLY DEFERRED\\n\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4244:         }",
          "4245:       }",
          "4246:     }",
          "4247:   }",
          "4248:   lineno = 1;",
          "4249:   tplt_xfer(lemp->name,in,out,&lineno);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4249:     fprintf(sql, \"COMMIT;\\n\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-20911",
  "cve_desc": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to denial of service in bit_calc_CRC in bits.c, related to a for loop.",
  "repo": "LibreDWG/libredwg",
  "patch_hash": "c6f6668b82bfe595899cc820279ac37bb9ef16f5",
  "patch_info": {
    "commit_hash": "c6f6668b82bfe595899cc820279ac37bb9ef16f5",
    "repo": "LibreDWG/libredwg",
    "commit_url": "https://github.com/LibreDWG/libredwg/commit/c6f6668b82bfe595899cc820279ac37bb9ef16f5",
    "files": [
      "include/dwg.h",
      "src/decode.c",
      "src/encode.c",
      "src/free.c"
    ],
    "message": "cleanup tio.unknown\n\nnot needed anymore, we only have UNKNOWN_OBJ or UNKNOWN_ENT with full common\nentity_data.\nFixes GH #178 heap_overflow2",
    "before_after_code_files": [
      "include/dwg.h||include/dwg.h",
      "src/decode.c||src/decode.c",
      "src/encode.c||src/encode.c",
      "src/free.c||src/free.c"
    ]
  },
  "patch_diff": {
    "include/dwg.h||include/dwg.h": [
      "File: include/dwg.h -> include/dwg.h"
    ],
    "src/decode.c||src/decode.c": [
      "File: src/decode.c -> src/decode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5013:           bit_set_position (dat, restartpos);",
      "5019:           if (i >= 0 && i < (int)dwg->num_classes)",
      "5020:             {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5014:           obj->supertype = DWG_SUPERTYPE_UNKNOWN;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5032:                   LOG_ERROR (\"Invalid class index %d >%d\", i,",
      "5033:                              (int)dwg->num_classes);",
      "5034:                 }",
      "5036:               obj->type = 0;",
      "5038:               return error | DWG_ERR_VALUEOUTOFBOUNDS;",
      "5039:             }",
      "5096:         }",
      "5097:     }",
      "",
      "[Removed Lines]",
      "5035:               obj->supertype = DWG_SUPERTYPE_UNKNOWN;",
      "5041:           if (klass && !is_entity)",
      "5042:             {",
      "5043:               int err = dwg_decode_UNKNOWN_OBJ (dat, obj);",
      "5044:               error |= err;",
      "5045:               obj->supertype = DWG_SUPERTYPE_UNKNOWN;",
      "5046:               if (!dat)",
      "5047:                 return error;",
      "5048:               if (err >= DWG_ERR_CRITICAL)",
      "5050:             }",
      "5051:           else if (klass) // is_entity",
      "5052:             {",
      "5053:               int err;",
      "5054: #if 0 && !defined(IS_RELEASE)",
      "5055:               if (strEQc(klass->dxfname, \"MULTILEADER\")) { //debug CED",
      "5056:                 char *mleader = bit_read_TF(dat, obj->size);",
      "5057:                 LOG_INSANE_TF(mleader, (int)obj->size)",
      "5058:                 bit_set_position(dat, restartpos);",
      "5059:                 free (mleader);",
      "5060:               }",
      "5061: #endif",
      "5062:               err = dwg_decode_UNKNOWN_ENT (dat, obj);",
      "5063:               error |= err;",
      "5064:               obj->supertype = DWG_SUPERTYPE_UNKNOWN;",
      "5065:               if (!dat)",
      "5066:                 return error;",
      "5067:               if (err >= DWG_ERR_CRITICAL)",
      "5069:             }",
      "5070:           else // not a class",
      "5071:             {",
      "5072:               LOG_WARN (\"Unknown object, skipping eed/reactors/xdic\");",
      "5073:               SINCE (R_2000)",
      "5074:               {",
      "5075:                 obj->bitsize = bit_read_RL (dat);",
      "5076:                 LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\",",
      "5077:                            obj->bitsize, dat->byte-2, dat->bit);",
      "5078:                 if (obj->bitsize > obj->size * 8)",
      "5079:                   {",
      "5080:                     LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL,",
      "5081:                                obj->bitsize, obj->size * 8);",
      "5082:                     obj->bitsize = obj->size * 8;",
      "5083:                     error |= DWG_ERR_VALUEOUTOFBOUNDS;",
      "5084:                   }",
      "5085:               }",
      "5086:               if (!bit_read_H (dat, &obj->handle))",
      "5087:                 {",
      "5088:                   LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\",",
      "5089:                              ARGS_H (obj->handle));",
      "5090:                 }",
      "5091:               restartpos = dat->byte;",
      "5092:               obj->supertype = DWG_SUPERTYPE_UNKNOWN;",
      "5093:               obj->tio.unknown = bit_read_TF (dat, obj->size);",
      "5094:               dat->byte = restartpos;",
      "5095:             }",
      "",
      "[Added Lines]",
      "5037:           if (is_entity)",
      "5038:               error |= dwg_decode_UNKNOWN_ENT (dat, obj);",
      "5039:           else",
      "5040:               error |= dwg_decode_UNKNOWN_OBJ (dat, obj);",
      "5042:           if (!dat)",
      "5043:             return error;",
      "5044:           if (error >= DWG_ERR_CRITICAL)",
      "",
      "---------------"
    ],
    "src/encode.c||src/encode.c": [
      "File: src/encode.c -> src/encode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1970:           else",
      "1971:             is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;",
      "1976:             error = dwg_encode_UNKNOWN_ENT (dat, obj);",
      "1993:         }",
      "1994:     }",
      "",
      "[Removed Lines]",
      "1973:           if (klass && !is_entity)",
      "1974:             error = dwg_encode_UNKNOWN_OBJ (dat, obj);",
      "1975:           else if (klass)",
      "1977:           else // not a class",
      "1978:             {",
      "1979:               LOG_WARN (\"Unknown object, skipping eed/reactors/xdic\");",
      "1980:               error = DWG_ERR_UNHANDLEDCLASS;",
      "1981:               SINCE (R_2000)",
      "1982:               {",
      "1983:                 bit_write_RL (dat, obj->bitsize);",
      "1984:                 LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,",
      "1985:                           dat->byte - 4, dat->bit);",
      "1986:               }",
      "1987:               bit_write_H (dat, &obj->handle);",
      "1988:               LOG_INFO (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));",
      "1991:               bit_write_TF (dat, obj->tio.unknown, obj->size);",
      "1992:             }",
      "",
      "[Added Lines]",
      "1973:           if (is_entity)",
      "1975:           else",
      "1976:             error = dwg_encode_UNKNOWN_OBJ (dat, obj);",
      "",
      "---------------"
    ],
    "src/free.c||src/free.c": [
      "File: src/free.c -> src/free.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "731:       else if ((error = dwg_free_variable_type (obj->parent, obj))",
      "732:                & DWG_ERR_UNHANDLEDCLASS)",
      "733:         {",
      "738:         unhandled:",
      "753:               dwg_free_UNKNOWN_ENT (dat, obj);",
      "761:               dwg_free_UNKNOWN_OBJ (dat, obj);",
      "771:         }",
      "772:     }",
      "",
      "[Removed Lines]",
      "734:           int is_entity;",
      "735:           int i;",
      "736:           Dwg_Class *klass;",
      "739:           is_entity = 0;",
      "740:           i = obj->type - 500;",
      "741:           klass = NULL;",
      "743:           dwg = obj->parent;",
      "744:           if (dwg->dwg_class && i >= 0 && i < (int)dwg->num_classes)",
      "745:             {",
      "746:               klass = &dwg->dwg_class[i];",
      "747:               is_entity = klass ? dwg_class_is_entity (klass) : 0;",
      "748:             }",
      "750:           if (obj->fixedtype == DWG_TYPE_TABLE)",
      "751:             {",
      "754:             }",
      "755:           else if (obj->fixedtype == DWG_TYPE_DATATABLE)",
      "756:             {",
      "757:               dwg_free_UNKNOWN_OBJ (dat, obj);",
      "758:             }",
      "759:           else if (klass && !is_entity)",
      "760:             {",
      "762:             }",
      "763:           else if (klass && is_entity)",
      "764:             {",
      "765:               dwg_free_UNKNOWN_ENT (dat, obj);",
      "766:             }",
      "767:           else // not a class",
      "768:             {",
      "769:               FREE_IF (obj->tio.unknown);",
      "770:             }",
      "",
      "[Added Lines]",
      "735:           if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)",
      "737:           else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f0ad00da16fd57a4c9fefdab85c3bb0725a9ac74",
      "candidate_info": {
        "commit_hash": "f0ad00da16fd57a4c9fefdab85c3bb0725a9ac74",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/f0ad00da16fd57a4c9fefdab85c3bb0725a9ac74",
        "files": [
          "src/in_json.c"
        ],
        "message": "in_json: ignore OBJECTS index field\n\nwe really need to use our own for an reliable objid.\nIt is treated just as a comment.\n\nAlso fixup TableCellContent_Attr.index subclass field.\nFixes GH #178 fuzzing crashes",
        "before_after_code_files": [
          "src/in_json.c||src/in_json.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/in_json.c||src/in_json.c": [
          "File: src/in_json.c -> src/in_json.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1678:               if (!obj->dxfname)",
          "1679:                 obj->dxfname = strdup (name);",
          "1680:             }",
          "1682:             {",
          "1683:               BITCODE_RL index = (BITCODE_RL)json_long (dat, tokens);",
          "1684:               if (obj->index != index)",
          "1686:                           obj->index)",
          "1692:               LOG_TRACE (\"index: %d\\n\", obj->index)",
          "1693:             }",
          "1694:           else if (strEQc (key, \"type\") && !obj->type)",
          "",
          "[Removed Lines]",
          "1681:           else if (strEQc (key, \"index\")) // TODO not TableCellContent_Attr",
          "1685:                 LOG_WARN (\"Unexpected %s.index %d, expected %d\", name, index,",
          "1687:               obj->index = index;",
          "1688:               if (is_entity)",
          "1689:                 obj->tio.entity->objid = obj->index;",
          "1690:               else",
          "1691:                 obj->tio.object->objid = obj->index;",
          "",
          "[Added Lines]",
          "1681:           else if (strEQc (key, \"index\") && strNE (name, \"TableCellContent_Attr\"))",
          "1685:                 LOG_WARN (\"Ignore wrong %s.index %d, expected %d\", name, index,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d931b61ac89337d1f3b6dbe220ce1da13d482b3d",
      "candidate_info": {
        "commit_hash": "d931b61ac89337d1f3b6dbe220ce1da13d482b3d",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/d931b61ac89337d1f3b6dbe220ce1da13d482b3d",
        "files": [
          "src/in_json.c"
        ],
        "message": "in_json: Fatal error on missing OBJECTS type\n\nthough theoretically we could search for the type, as\nwe do for our internal fixedtype.\nFixes GH #178 fuzzing crashes",
        "before_after_code_files": [
          "src/in_json.c||src/in_json.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/in_json.c||src/in_json.c": [
          "File: src/in_json.c -> src/in_json.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1751:                   obj->handle.size = hdl->handleref.size;",
          "1752:                   obj->handle.value = hdl->handleref.value;",
          "1753:                 }",
          "1754:             }",
          "1755:           else if (strEQc (key, \"num_unknown_bits\")",
          "1756:                    && memBEGINc (obj->name, \"UNKNOWN_\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1754:               if (!obj->type) // TODO: We could eventually relax this",
          "1755:                 {",
          "1756:                   LOG_ERROR (\"Required %s.type missing\", name)",
          "1757:                   return DWG_ERR_INVALIDDWG;",
          "1758:                 }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "95cc9300430d35feb05b06a9badf678419463dbe",
      "candidate_info": {
        "commit_hash": "95cc9300430d35feb05b06a9badf678419463dbe",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/95cc9300430d35feb05b06a9badf678419463dbe",
        "files": [
          "src/bits.c"
        ],
        "message": "encode: protect from stack under-flow\n\nFrom GH #178 fuzzing",
        "before_after_code_files": [
          "src/bits.c||src/bits.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/bits.c||src/bits.c": [
          "File: src/bits.c -> src/bits.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "883:     if (byte[i] & 0x7f)",
          "884:       break;",
          "887:     i--;",
          "888:   byte[i] &= 0x7f;",
          "889:   if (negative)",
          "",
          "[Removed Lines]",
          "886:   if (byte[i] & 0x40)",
          "",
          "[Added Lines]",
          "886:   if (byte[i] & 0x40 && i > 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "953:     if (byte[i] & 0x7f)",
          "954:       break;",
          "957:     i--;",
          "958:   byte[i] &= 0x7f;",
          "959:   for (j = 4; j >= i; j--)",
          "",
          "[Removed Lines]",
          "956:   if (byte[i] & 0x40)",
          "",
          "[Added Lines]",
          "956:   if (byte[i] & 0x40 && i > 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "784829b23deead8f62fe49cf7d8dd082698a33a9",
      "candidate_info": {
        "commit_hash": "784829b23deead8f62fe49cf7d8dd082698a33a9",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/784829b23deead8f62fe49cf7d8dd082698a33a9",
        "files": [
          "src/encode.c"
        ],
        "message": "encode: object.size overflow\n\ndecode fails when it overflows, but encode does not\nknow its final dat->size, so introduce a sensible limit.\nFixes the dos testcase of GH #178",
        "before_after_code_files": [
          "src/encode.c||src/encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "src/encode.c||src/encode.c"
          ],
          "candidate": [
            "src/encode.c||src/encode.c"
          ]
        }
      },
      "candidate_diff": {
        "src/encode.c||src/encode.c": [
          "File: src/encode.c -> src/encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1662:   dat->bit = 0;",
          "1664:   LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);",
          "1665:   while (dat->byte + obj->size >= dat->size)",
          "1666:     bit_chain_alloc (dat);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1665:   if (obj->size > 0x100000)",
          "1666:     {",
          "1667:       LOG_ERROR (\"Object size %u overflow\", obj->size);",
          "1668:       return DWG_ERR_VALUEOUTOFBOUNDS;",
          "1669:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "aeabdfc2f4899229ec29264f3055e2d9df026990",
      "candidate_info": {
        "commit_hash": "aeabdfc2f4899229ec29264f3055e2d9df026990",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/aeabdfc2f4899229ec29264f3055e2d9df026990",
        "files": [
          "src/encode.c"
        ],
        "message": "encode: convert UNKNOWN_ENT to POINT\n\nTo preserve the next_entity chain\non unhandled entities, like LIGHT, HELIX, MULTILEADER, TABLE,\nSURFACE, ARC_DIMENSION, GEOPOSITIONMAKRKER, MESH.",
        "before_after_code_files": [
          "src/encode.c||src/encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/encode.c||src/encode.c"
          ],
          "candidate": [
            "src/encode.c||src/encode.c"
          ]
        }
      },
      "candidate_diff": {
        "src/encode.c||src/encode.c": [
          "File: src/encode.c -> src/encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: bool is_dwg_object (const char *name);",
          "49: bool is_dwg_entity (const char *name);",
          "52: static unsigned int loglevel;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: int dwg_dynapi_entity_size (const char *restrict name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2273:           assert (address);",
          "2274:           dat->byte = address; // restart and write into the UNKNOWN_OBJ object",
          "2275:           dat->bit = 0;",
          "2277:           if (dwg->header.version != dwg->header.from_version)",
          "2278:             {",
          "2280:               obj->size = 0;",
          "2281:               obj->bitsize = 0;",
          "2283:               if (is_entity)",
          "2293:                 }",
          "2294:               else",
          "2295:                 {",
          "2298:                   LOG_INFO (\"fixup as DUMMY, Type %d\\n\", obj->type);",
          "2299:                 }",
          "2300:               obj->hdlpos = 0;",
          "2301:             }",
          "",
          "[Removed Lines]",
          "2279:               obj->type = DWG_TYPE_DUMMY; // TODO or PLACEHOLDER if available",
          "2284:                 { // isn't there a better way, like PROXY? to at least preserve",
          "2286:                   BITCODE_H owner = obj->tio.entity->ownerhandle;",
          "2287:                   LOG_WARN (\"fixup entity as DUMMY, Type %d\\n\", obj->type);",
          "2288:                   obj->tio.object->xdicobjhandle = NULL;",
          "2289:                   obj->tio.object->num_eed = 0;",
          "2290:                   obj->tio.object->num_reactors = 0;",
          "2291:                   obj->tio.object->ownerhandle = owner;",
          "2292:                   is_entity = 0;",
          "2296:                   obj->tio.object->num_eed = 0;",
          "2297:                   obj->tio.object->num_reactors = 0;",
          "",
          "[Added Lines]",
          "2286:                 { // better than DUMMY to preserve the next_entity chain.",
          "2288:                   Dwg_Entity_POINT *_obj = obj->tio.entity->tio.POINT;",
          "2289:                   LOG_WARN (\"fixup entity as POINT, Type %d\\n\", obj->type);",
          "2291:                   if (obj->tio.entity->num_reactors)",
          "2292:                     {",
          "2293:                       free (obj->tio.entity->reactors);",
          "2294:                       obj->tio.entity->num_reactors = 0;",
          "2295:                       obj->tio.entity->reactors = NULL;",
          "2296:                     }",
          "2297:                   free (obj->unknown_bits);",
          "2298:                   obj->tio.entity->tio.POINT = _obj",
          "2299:                     = realloc (_obj, sizeof (Dwg_Entity_POINT));",
          "2301:                   _obj->parent = obj->tio.entity;",
          "2302:                   _obj->x = 0.0;",
          "2303:                   _obj->y = 0.0;",
          "2304:                   _obj->z = 0.0;",
          "2305:                   _obj->thickness = 1e25; // let it stand out",
          "2306:                   _obj->extrusion.x = 0.0;",
          "2307:                   _obj->extrusion.y = 0.0;",
          "2308:                   _obj->extrusion.z = 1.0;",
          "2309:                   _obj->x_ang = 0.0;",
          "2310:                   obj->type = DWG_TYPE_POINT;",
          "2311:                   obj->fixedtype = DWG_TYPE_POINT;",
          "2312:                   if (dwg->opts & DWG_OPTS_INJSON)",
          "2313:                     {",
          "2314:                       free (obj->name);",
          "2315:                       obj->name = strdup (\"POINT\");",
          "2316:                     }",
          "2317:                   else",
          "2318:                     obj->name = (char*)\"POINT\";",
          "2319:                   if (dwg->opts & DWG_OPTS_IN)",
          "2320:                     {",
          "2321:                       free (obj->dxfname);",
          "2322:                       obj->dxfname = strdup (\"POINT\");",
          "2323:                     }",
          "2324:                   else",
          "2325:                     obj->dxfname = (char*)\"POINT\";",
          "2330:                   obj->type = DWG_TYPE_DUMMY; // TODO or PLACEHOLDER if available, or even PROXY_OBJECT",
          "2331:                   obj->fixedtype = DWG_TYPE_DUMMY;",
          "2332:                   if (obj->tio.object->num_reactors)",
          "2333:                     {",
          "2334:                       free (obj->tio.object->reactors);",
          "2335:                       obj->tio.object->num_reactors = 0;",
          "2336:                       obj->tio.object->reactors = NULL;",
          "2337:                     }",
          "2340:                   free (obj->unknown_bits);",
          "2341:                   if (dwg->opts & DWG_OPTS_INJSON)",
          "2342:                     {",
          "2343:                       free (obj->name);",
          "2344:                       obj->name = strdup (\"DUMMY\");",
          "2345:                     }",
          "2346:                   else",
          "2347:                     obj->name = (char*)\"DUMMY\";",
          "2348:                   if (dwg->opts & DWG_OPTS_IN)",
          "2349:                     {",
          "2350:                       free (obj->dxfname);",
          "2351:                       obj->dxfname = strdup (\"DUMMY\");",
          "2352:                     }",
          "2353:                   else",
          "2354:                     obj->dxfname = (char*)\"DUMMY\";",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2310:             bit_write_BS (dat, obj->type);",
          "2314:             error = dwg_encode_UNKNOWN_ENT (dat, obj);",
          "2315:           else",
          "2316:             error = dwg_encode_UNKNOWN_OBJ (dat, obj);",
          "",
          "[Removed Lines]",
          "2313:           if (is_entity)",
          "",
          "[Added Lines]",
          "2369:           if (obj->type == DWG_TYPE_POINT)",
          "2370:             error = dwg_encode_POINT (dat, obj);",
          "2371:           else if (obj->type == DWG_TYPE_DUMMY)",
          "2372:             error = dwg_encode_DUMMY (dat, obj);",
          "2373:           else if (is_entity)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
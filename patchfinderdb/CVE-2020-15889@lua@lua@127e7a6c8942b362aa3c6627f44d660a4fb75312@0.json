{
  "cve_id": "CVE-2020-15889",
  "cve_desc": "Lua 5.4.0 has a getobjname heap-based buffer over-read because youngcollection in lgc.c uses markold for an insufficient number of list members.",
  "repo": "lua/lua",
  "patch_hash": "127e7a6c8942b362aa3c6627f44d660a4fb75312",
  "patch_info": {
    "commit_hash": "127e7a6c8942b362aa3c6627f44d660a4fb75312",
    "repo": "lua/lua",
    "commit_url": "https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312",
    "files": [
      "lgc.c"
    ],
    "message": "Fixed bug of old finalized objects in the GC\n\nWhen an object aged OLD1 is finalized, it is moved from the list\n'finobj' to the *beginning* of the list 'allgc'. So, this part of the\nlist (and not only the survival list) must be visited by 'markold'.",
    "before_after_code_files": [
      "lgc.c||lgc.c"
    ]
  },
  "patch_diff": {
    "lgc.c||lgc.c": [
      "File: lgc.c -> lgc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1140: static void youngcollection (lua_State *L, global_State *g) {",
      "1142:   lua_assert(g->gcstate == GCSpropagate);",
      "1144:   markold(g, g->finobj, g->finobjrold);",
      "1145:   atomic(L);",
      "",
      "[Removed Lines]",
      "1143:   markold(g, g->survival, g->reallyold);",
      "",
      "[Added Lines]",
      "1141:   markold(g, g->allgc, g->reallyold);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0dc5deca1c0182a4a3db2fcfd7bc721f27fb352b",
      "candidate_info": {
        "commit_hash": "0dc5deca1c0182a4a3db2fcfd7bc721f27fb352b",
        "repo": "lua/lua",
        "commit_url": "https://github.com/lua/lua/commit/0dc5deca1c0182a4a3db2fcfd7bc721f27fb352b",
        "files": [
          "lgc.c",
          "lstate.c",
          "lstate.h",
          "testes/gengc.lua"
        ],
        "message": "Optimization in 'markold'\n\nOLD1 objects can be potentially anywhere in the 'allgc' list (up\nto 'reallyold'), but frequently they are all after 'old1' (natural\nevolution of survivals) or do not exist at all (when all objects die\nyoung). So, instead of 'markold' starts looking for them always\nfrom the start of 'allgc', the collector keeps an extra pointer,\n'firstold1', that points to the first OLD1 object in the 'allgc' list,\nor is NULL if there are no OLD1 objects in that list.",
        "before_after_code_files": [
          "lgc.c||lgc.c",
          "lstate.c||lstate.c",
          "lstate.h||lstate.h",
          "testes/gengc.lua||testes/gengc.lua"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lgc.c||lgc.c"
          ],
          "candidate": [
            "lgc.c||lgc.c"
          ]
        }
      },
      "candidate_diff": {
        "lgc.c||lgc.c": [
          "File: lgc.c -> lgc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "860:   if (issweepphase(g))",
          "862:   return o;",
          "863: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "862:   else if (getage(o) == G_OLD1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "956: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "964: static void checkpointer (GCObject **p, GCObject *o) {",
          "965:   if (o == *p)",
          "967: }",
          "974: static void correctpointers (global_State *g, GCObject *o) {",
          "975:   checkpointer(&g->survival, o);",
          "976:   checkpointer(&g->old1, o);",
          "977:   checkpointer(&g->reallyold, o);",
          "978:   checkpointer(&g->firstold1, o);",
          "979: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "974:     }",
          "984:     for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }",
          "",
          "[Removed Lines]",
          "976:       if (o == g->survival)",
          "977:         g->survival = o->next;",
          "978:       if (o == g->old1)",
          "979:         g->old1 = o->next;",
          "980:       if (o == g->reallyold)",
          "981:         g->reallyold = o->next;",
          "982:     }",
          "",
          "[Added Lines]",
          "998:     else",
          "999:       correctpointers(g, o);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1035: static GCObject **sweepgen (lua_State *L, global_State *g, GCObject **p,",
          "1037:   static const lu_byte nextage[] = {",
          "",
          "[Removed Lines]",
          "1036:                             GCObject *limit) {",
          "",
          "[Added Lines]",
          "1053:                             GCObject *limit, GCObject **pfirstold1) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1057:         curr->marked = cast_byte(marked | G_SURVIVAL | white);",
          "1058:       }",
          "1060:         setage(curr, nextage[getage(curr)]);",
          "1062:     }",
          "1063:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1078:         if (getage(curr) == G_OLD1 && *pfirstold1 == NULL)",
          "1080:       }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1170: static void youngcollection (lua_State *L, global_State *g) {",
          "1172:   lua_assert(g->gcstate == GCSpropagate);",
          "1174:   markold(g, g->finobj, g->finobjrold);",
          "1175:   atomic(L);",
          "1178:   g->gcstate = GCSswpallgc;",
          "1182:   g->reallyold = g->old1;",
          "1190:   g->finobjrold = g->finobjold1;",
          "1196:   finishgencycle(L, g);",
          "1197: }",
          "",
          "[Removed Lines]",
          "1173:   markold(g, g->allgc, g->reallyold);",
          "1179:   psurvival = sweepgen(L, g, &g->allgc, g->survival);",
          "1181:   sweepgen(L, g, psurvival, g->old1);",
          "1187:   psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);",
          "1189:   sweepgen(L, g, psurvival, g->finobjold1);",
          "1194:   sweepgen(L, g, &g->tobefnz, NULL);",
          "",
          "[Added Lines]",
          "1197:   }",
          "1203:   psurvival = sweepgen(L, g, &g->allgc, g->survival, &g->firstold1);",
          "1205:   sweepgen(L, g, psurvival, g->old1, &g->firstold1);",
          "1212:   psurvival = sweepgen(L, g, &g->finobj, g->finobjsur, &dummy);",
          "1214:   sweepgen(L, g, psurvival, g->finobjold1, &dummy);",
          "1219:   sweepgen(L, g, &g->tobefnz, NULL, &dummy);",
          "",
          "---------------"
        ],
        "lstate.c||lstate.c": [
          "File: lstate.c -> lstate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "413:   g->gckind = KGC_INC;",
          "414:   g->gcemergency = 0;",
          "415:   g->finobj = g->tobefnz = g->fixedgc = NULL;",
          "417:   g->finobjsur = g->finobjold1 = g->finobjrold = NULL;",
          "418:   g->sweepgc = NULL;",
          "419:   g->gray = g->grayagain = NULL;",
          "",
          "[Removed Lines]",
          "416:   g->survival = g->old1 = g->reallyold = NULL;",
          "",
          "[Added Lines]",
          "416:   g->firstold1 = g->survival = g->old1 = g->reallyold = NULL;",
          "",
          "---------------"
        ],
        "lstate.h||lstate.h": [
          "File: lstate.h -> lstate.h"
        ],
        "testes/gengc.lua||testes/gengc.lua": [
          "File: testes/gengc.lua -> testes/gengc.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: end",
          "40: do   -- bug in 5.4.0",
          "41: -- When an object aged OLD1 is finalized, it is moved from the list",
          "42: -- 'finobj' to the *beginning* of the list 'allgc', but that part of the",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: do",
          "41:   -- ensure that 'firstold1' is corrected when object is removed from",
          "42:   -- the 'allgc' list",
          "43:   local function foo () end",
          "44:   local old = {10}",
          "45:   collectgarbage()    -- make 'old' old",
          "46:   assert(not T or T.gcage(old) == \"old\")",
          "47:   setmetatable(old, {})    -- new table becomes OLD0 (barrier)",
          "48:   assert(not T or T.gcage(getmetatable(old)) == \"old0\")",
          "49:   collectgarbage(\"step\", 0)   -- new table becomes OLD1 and firstold1",
          "50:   assert(not T or T.gcage(getmetatable(old)) == \"old1\")",
          "51:   setmetatable(getmetatable(old), {__gc = foo})  -- get it out of allgc list",
          "52:   collectgarbage(\"step\", 0)   -- should not seg. fault",
          "53: end",
          "",
          "---------------"
        ]
      }
    }
  ]
}
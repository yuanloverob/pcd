{
  "cve_id": "CVE-2016-10029",
  "cve_desc": "The virtio_gpu_set_scanout function in QEMU (aka Quick Emulator) built with Virtio GPU Device emulator support allows local guest OS users to cause a denial of service (out-of-bounds read and process crash) via a scanout id in a VIRTIO_GPU_CMD_SET_SCANOUT command larger than num_scanouts.",
  "repo": "qemu/qemu",
  "patch_hash": "2fe760554eb3769d70f608a158474f728ba45ba6",
  "patch_info": {
    "commit_hash": "2fe760554eb3769d70f608a158474f728ba45ba6",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/2fe760554eb3769d70f608a158474f728ba45ba6",
    "files": [
      "hw/display/virtio-gpu-3d.c",
      "hw/display/virtio-gpu.c"
    ],
    "message": "virtio-gpu: check max_outputs only\n\nThe scanout id should not be above the configured num_scanouts.\n\nSigned-off-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 1463653560-26958-5-git-send-email-marcandre.lureau@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>",
    "before_after_code_files": [
      "hw/display/virtio-gpu-3d.c||hw/display/virtio-gpu-3d.c",
      "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
    ]
  },
  "patch_diff": {
    "hw/display/virtio-gpu-3d.c||hw/display/virtio-gpu-3d.c": [
      "File: hw/display/virtio-gpu-3d.c -> hw/display/virtio-gpu-3d.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "128:     trace_virtio_gpu_cmd_res_flush(rf.resource_id,",
      "129:                                    rf.r.width, rf.r.height, rf.r.x, rf.r.y);",
      "132:         if (g->scanout[i].resource_id != rf.resource_id) {",
      "133:             continue;",
      "134:         }",
      "",
      "[Removed Lines]",
      "131:     for (i = 0; i < VIRTIO_GPU_MAX_SCANOUT; i++) {",
      "",
      "[Added Lines]",
      "131:     for (i = 0; i < g->conf.max_outputs; i++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "147:     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,",
      "148:                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);",
      "151:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",",
      "152:                       __func__, ss.scanout_id);",
      "153:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;",
      "",
      "[Removed Lines]",
      "150:     if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT) {",
      "",
      "[Added Lines]",
      "150:     if (ss.scanout_id >= g->conf.max_outputs) {",
      "",
      "---------------"
    ],
    "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c": [
      "File: hw/display/virtio-gpu.c -> hw/display/virtio-gpu.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "467:     pixman_region_init_rect(&flush_region,",
      "468:                             rf.r.x, rf.r.y, rf.r.width, rf.r.height);",
      "470:         struct virtio_gpu_scanout *scanout;",
      "471:         pixman_region16_t region, finalregion;",
      "472:         pixman_box16_t *extents;",
      "",
      "[Removed Lines]",
      "469:     for (i = 0; i < VIRTIO_GPU_MAX_SCANOUT; i++) {",
      "",
      "[Added Lines]",
      "469:     for (i = 0; i < g->conf.max_outputs; i++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "509:     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,",
      "510:                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);",
      "514:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",",
      "515:                       __func__, ss.scanout_id);",
      "516:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;",
      "",
      "[Removed Lines]",
      "512:     if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT ||",
      "513:         ss.scanout_id >= g->conf.max_outputs) {",
      "",
      "[Added Lines]",
      "512:     if (ss.scanout_id >= g->conf.max_outputs) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9d9e152136bdaa75ea98e5c2105f2a7127e369eb",
      "candidate_info": {
        "commit_hash": "9d9e152136bdaa75ea98e5c2105f2a7127e369eb",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/9d9e152136bdaa75ea98e5c2105f2a7127e369eb",
        "files": [
          "configure",
          "hw/display/Makefile.objs",
          "hw/display/virtio-gpu-3d.c",
          "hw/display/virtio-gpu.c",
          "include/hw/virtio/virtio-gpu.h",
          "trace-events"
        ],
        "message": "virtio-gpu: add 3d mode and virgl rendering support.\n\nAdd virglrenderer library detection.  Add 3d mode to virtio-gpu,\nwire up virglrenderer library.  When in 3d mode render using the\nnew context management and texture scanout callbacks.\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>",
        "before_after_code_files": [
          "hw/display/Makefile.objs||hw/display/Makefile.objs",
          "hw/display/virtio-gpu-3d.c||hw/display/virtio-gpu-3d.c",
          "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c",
          "include/hw/virtio/virtio-gpu.h||include/hw/virtio/virtio-gpu.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/display/virtio-gpu-3d.c||hw/display/virtio-gpu-3d.c",
            "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
          ],
          "candidate": [
            "hw/display/virtio-gpu-3d.c||hw/display/virtio-gpu-3d.c",
            "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/display/Makefile.objs||hw/display/Makefile.objs": [
          "File: hw/display/Makefile.objs -> hw/display/Makefile.objs",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: common-obj-$(CONFIG_QXL) += qxl.o qxl-logger.o qxl-render.o",
          "39: obj-$(CONFIG_VIRTIO_PCI) += virtio-gpu-pci.o",
          "40: obj-$(CONFIG_VIRTIO_VGA) += virtio-vga.o",
          "",
          "[Removed Lines]",
          "38: obj-$(CONFIG_VIRTIO) += virtio-gpu.o",
          "",
          "[Added Lines]",
          "38: obj-$(CONFIG_VIRTIO) += virtio-gpu.o virtio-gpu-3d.o",
          "41: virtio-gpu.o-cflags := $(VIRGL_CFLAGS)",
          "42: virtio-gpu.o-libs += $(VIRGL_LIBS)",
          "43: virtio-gpu-3d.o-cflags := $(VIRGL_CFLAGS)",
          "44: virtio-gpu-3d.o-libs += $(VIRGL_LIBS)",
          "",
          "---------------"
        ],
        "hw/display/virtio-gpu-3d.c||hw/display/virtio-gpu-3d.c": [
          "File: hw/display/virtio-gpu-3d.c -> hw/display/virtio-gpu-3d.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include \"qemu-common.h\"",
          "15: #include \"qemu/iov.h\"",
          "16: #include \"trace.h\"",
          "17: #include \"hw/virtio/virtio.h\"",
          "18: #include \"hw/virtio/virtio-gpu.h\"",
          "20: #ifdef CONFIG_VIRGL",
          "22: #include \"virglrenderer.h\"",
          "24: static struct virgl_renderer_callbacks virtio_gpu_3d_cbs;",
          "26: static void virgl_cmd_create_resource_2d(VirtIOGPU *g,",
          "27:                                          struct virtio_gpu_ctrl_command *cmd)",
          "28: {",
          "29:     struct virtio_gpu_resource_create_2d c2d;",
          "30:     struct virgl_renderer_resource_create_args args;",
          "32:     VIRTIO_GPU_FILL_CMD(c2d);",
          "33:     trace_virtio_gpu_cmd_res_create_2d(c2d.resource_id, c2d.format,",
          "34:                                        c2d.width, c2d.height);",
          "36:     args.handle = c2d.resource_id;",
          "37:     args.target = 2;",
          "38:     args.format = c2d.format;",
          "39:     args.bind = (1 << 1);",
          "40:     args.width = c2d.width;",
          "41:     args.height = c2d.height;",
          "42:     args.depth = 1;",
          "43:     args.array_size = 1;",
          "44:     args.last_level = 0;",
          "45:     args.nr_samples = 0;",
          "46:     args.flags = VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP;",
          "47:     virgl_renderer_resource_create(&args, NULL, 0);",
          "48: }",
          "50: static void virgl_cmd_create_resource_3d(VirtIOGPU *g,",
          "51:                                          struct virtio_gpu_ctrl_command *cmd)",
          "52: {",
          "53:     struct virtio_gpu_resource_create_3d c3d;",
          "54:     struct virgl_renderer_resource_create_args args;",
          "56:     VIRTIO_GPU_FILL_CMD(c3d);",
          "57:     trace_virtio_gpu_cmd_res_create_3d(c3d.resource_id, c3d.format,",
          "58:                                        c3d.width, c3d.height, c3d.depth);",
          "60:     args.handle = c3d.resource_id;",
          "61:     args.target = c3d.target;",
          "62:     args.format = c3d.format;",
          "63:     args.bind = c3d.bind;",
          "64:     args.width = c3d.width;",
          "65:     args.height = c3d.height;",
          "66:     args.depth = c3d.depth;",
          "67:     args.array_size = c3d.array_size;",
          "68:     args.last_level = c3d.last_level;",
          "69:     args.nr_samples = c3d.nr_samples;",
          "70:     args.flags = c3d.flags;",
          "71:     virgl_renderer_resource_create(&args, NULL, 0);",
          "72: }",
          "74: static void virgl_cmd_resource_unref(VirtIOGPU *g,",
          "75:                                      struct virtio_gpu_ctrl_command *cmd)",
          "76: {",
          "77:     struct virtio_gpu_resource_unref unref;",
          "79:     VIRTIO_GPU_FILL_CMD(unref);",
          "80:     trace_virtio_gpu_cmd_res_unref(unref.resource_id);",
          "82:     virgl_renderer_resource_unref(unref.resource_id);",
          "83: }",
          "85: static void virgl_cmd_context_create(VirtIOGPU *g,",
          "86:                                      struct virtio_gpu_ctrl_command *cmd)",
          "87: {",
          "88:     struct virtio_gpu_ctx_create cc;",
          "90:     VIRTIO_GPU_FILL_CMD(cc);",
          "91:     trace_virtio_gpu_cmd_ctx_create(cc.hdr.ctx_id,",
          "92:                                     cc.debug_name);",
          "94:     virgl_renderer_context_create(cc.hdr.ctx_id, cc.nlen,",
          "95:                                   cc.debug_name);",
          "96: }",
          "98: static void virgl_cmd_context_destroy(VirtIOGPU *g,",
          "99:                                       struct virtio_gpu_ctrl_command *cmd)",
          "100: {",
          "101:     struct virtio_gpu_ctx_destroy cd;",
          "103:     VIRTIO_GPU_FILL_CMD(cd);",
          "104:     trace_virtio_gpu_cmd_ctx_destroy(cd.hdr.ctx_id);",
          "106:     virgl_renderer_context_destroy(cd.hdr.ctx_id);",
          "107: }",
          "109: static void virtio_gpu_rect_update(VirtIOGPU *g, int idx, int x, int y,",
          "110:                                 int width, int height)",
          "111: {",
          "112:     if (!g->scanout[idx].con) {",
          "113:         return;",
          "114:     }",
          "116:     dpy_gl_update(g->scanout[idx].con, x, y, width, height);",
          "117: }",
          "119: static void virgl_cmd_resource_flush(VirtIOGPU *g,",
          "120:                                      struct virtio_gpu_ctrl_command *cmd)",
          "121: {",
          "122:     struct virtio_gpu_resource_flush rf;",
          "123:     int i;",
          "125:     VIRTIO_GPU_FILL_CMD(rf);",
          "126:     trace_virtio_gpu_cmd_res_flush(rf.resource_id,",
          "127:                                    rf.r.width, rf.r.height, rf.r.x, rf.r.y);",
          "129:     for (i = 0; i < VIRTIO_GPU_MAX_SCANOUT; i++) {",
          "130:         if (g->scanout[i].resource_id != rf.resource_id) {",
          "131:             continue;",
          "132:         }",
          "133:         virtio_gpu_rect_update(g, i, rf.r.x, rf.r.y, rf.r.width, rf.r.height);",
          "134:     }",
          "135: }",
          "137: static void virgl_cmd_set_scanout(VirtIOGPU *g,",
          "138:                                   struct virtio_gpu_ctrl_command *cmd)",
          "139: {",
          "140:     struct virtio_gpu_set_scanout ss;",
          "141:     struct virgl_renderer_resource_info info;",
          "142:     int ret;",
          "144:     VIRTIO_GPU_FILL_CMD(ss);",
          "145:     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,",
          "146:                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);",
          "148:     if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT) {",
          "149:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",",
          "150:                       __func__, ss.scanout_id);",
          "151:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;",
          "152:         return;",
          "153:     }",
          "154:     g->enable = 1;",
          "156:     memset(&info, 0, sizeof(info));",
          "158:     if (ss.resource_id && ss.r.width && ss.r.height) {",
          "159:         ret = virgl_renderer_resource_get_info(ss.resource_id, &info);",
          "160:         if (ret == -1) {",
          "161:             qemu_log_mask(LOG_GUEST_ERROR,",
          "162:                           \"%s: illegal resource specified %d\\n\",",
          "163:                           __func__, ss.resource_id);",
          "164:             cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "165:             return;",
          "166:         }",
          "167:         qemu_console_resize(g->scanout[ss.scanout_id].con,",
          "168:                             ss.r.width, ss.r.height);",
          "169:         virgl_renderer_force_ctx_0();",
          "170:         dpy_gl_scanout(g->scanout[ss.scanout_id].con, info.tex_id,",
          "171:                        info.flags & 1 /* FIXME: Y_0_TOP */,",
          "172:                        ss.r.x, ss.r.y, ss.r.width, ss.r.height);",
          "173:     } else {",
          "174:         if (ss.scanout_id != 0) {",
          "175:             dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);",
          "176:         }",
          "177:         dpy_gl_scanout(g->scanout[ss.scanout_id].con, 0, false,",
          "178:                        0, 0, 0, 0);",
          "179:     }",
          "180:     g->scanout[ss.scanout_id].resource_id = ss.resource_id;",
          "181: }",
          "183: static void virgl_cmd_submit_3d(VirtIOGPU *g,",
          "184:                                 struct virtio_gpu_ctrl_command *cmd)",
          "185: {",
          "186:     struct virtio_gpu_cmd_submit cs;",
          "187:     void *buf;",
          "188:     size_t s;",
          "190:     VIRTIO_GPU_FILL_CMD(cs);",
          "191:     trace_virtio_gpu_cmd_ctx_submit(cs.hdr.ctx_id, cs.size);",
          "193:     buf = g_malloc(cs.size);",
          "194:     s = iov_to_buf(cmd->elem.out_sg, cmd->elem.out_num,",
          "195:                    sizeof(cs), buf, cs.size);",
          "196:     if (s != cs.size) {",
          "197:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: size mismatch (%zd/%d)\",",
          "198:                       __func__, s, cs.size);",
          "199:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;",
          "200:         return;",
          "201:     }",
          "203:     if (virtio_gpu_stats_enabled(g->conf)) {",
          "204:         g->stats.req_3d++;",
          "205:         g->stats.bytes_3d += cs.size;",
          "206:     }",
          "208:     virgl_renderer_submit_cmd(buf, cs.hdr.ctx_id, cs.size / 4);",
          "210:     g_free(buf);",
          "211: }",
          "213: static void virgl_cmd_transfer_to_host_2d(VirtIOGPU *g,",
          "214:                                           struct virtio_gpu_ctrl_command *cmd)",
          "215: {",
          "216:     struct virtio_gpu_transfer_to_host_2d t2d;",
          "217:     struct virtio_gpu_box box;",
          "219:     VIRTIO_GPU_FILL_CMD(t2d);",
          "220:     trace_virtio_gpu_cmd_res_xfer_toh_2d(t2d.resource_id);",
          "222:     box.x = t2d.r.x;",
          "223:     box.y = t2d.r.y;",
          "224:     box.z = 0;",
          "225:     box.w = t2d.r.width;",
          "226:     box.h = t2d.r.height;",
          "227:     box.d = 1;",
          "229:     virgl_renderer_transfer_write_iov(t2d.resource_id,",
          "230:                                       0,",
          "231:                                       0,",
          "232:                                       0,",
          "233:                                       0,",
          "234:                                       (struct virgl_box *)&box,",
          "235:                                       t2d.offset, NULL, 0);",
          "236: }",
          "238: static void virgl_cmd_transfer_to_host_3d(VirtIOGPU *g,",
          "239:                                           struct virtio_gpu_ctrl_command *cmd)",
          "240: {",
          "241:     struct virtio_gpu_transfer_host_3d t3d;",
          "243:     VIRTIO_GPU_FILL_CMD(t3d);",
          "244:     trace_virtio_gpu_cmd_res_xfer_toh_3d(t3d.resource_id);",
          "246:     virgl_renderer_transfer_write_iov(t3d.resource_id,",
          "247:                                       t3d.hdr.ctx_id,",
          "248:                                       t3d.level,",
          "249:                                       t3d.stride,",
          "250:                                       t3d.layer_stride,",
          "251:                                       (struct virgl_box *)&t3d.box,",
          "252:                                       t3d.offset, NULL, 0);",
          "253: }",
          "255: static void",
          "256: virgl_cmd_transfer_from_host_3d(VirtIOGPU *g,",
          "257:                                 struct virtio_gpu_ctrl_command *cmd)",
          "258: {",
          "259:     struct virtio_gpu_transfer_host_3d tf3d;",
          "261:     VIRTIO_GPU_FILL_CMD(tf3d);",
          "262:     trace_virtio_gpu_cmd_res_xfer_fromh_3d(tf3d.resource_id);",
          "264:     virgl_renderer_transfer_read_iov(tf3d.resource_id,",
          "265:                                      tf3d.hdr.ctx_id,",
          "266:                                      tf3d.level,",
          "267:                                      tf3d.stride,",
          "268:                                      tf3d.layer_stride,",
          "269:                                      (struct virgl_box *)&tf3d.box,",
          "270:                                      tf3d.offset, NULL, 0);",
          "271: }",
          "274: static void virgl_resource_attach_backing(VirtIOGPU *g,",
          "275:                                           struct virtio_gpu_ctrl_command *cmd)",
          "276: {",
          "277:     struct virtio_gpu_resource_attach_backing att_rb;",
          "278:     struct iovec *res_iovs;",
          "279:     int ret;",
          "281:     VIRTIO_GPU_FILL_CMD(att_rb);",
          "282:     trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);",
          "284:     ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, &res_iovs);",
          "285:     if (ret != 0) {",
          "286:         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;",
          "287:         return;",
          "288:     }",
          "290:     virgl_renderer_resource_attach_iov(att_rb.resource_id,",
          "291:                                        res_iovs, att_rb.nr_entries);",
          "292: }",
          "294: static void virgl_resource_detach_backing(VirtIOGPU *g,",
          "295:                                           struct virtio_gpu_ctrl_command *cmd)",
          "296: {",
          "297:     struct virtio_gpu_resource_detach_backing detach_rb;",
          "298:     struct iovec *res_iovs = NULL;",
          "299:     int num_iovs = 0;",
          "301:     VIRTIO_GPU_FILL_CMD(detach_rb);",
          "302:     trace_virtio_gpu_cmd_res_back_detach(detach_rb.resource_id);",
          "304:     virgl_renderer_resource_detach_iov(detach_rb.resource_id,",
          "305:                                        &res_iovs,",
          "306:                                        &num_iovs);",
          "307:     if (res_iovs == NULL || num_iovs == 0) {",
          "308:         return;",
          "309:     }",
          "310:     virtio_gpu_cleanup_mapping_iov(res_iovs, num_iovs);",
          "311: }",
          "314: static void virgl_cmd_ctx_attach_resource(VirtIOGPU *g,",
          "315:                                           struct virtio_gpu_ctrl_command *cmd)",
          "316: {",
          "317:     struct virtio_gpu_ctx_resource att_res;",
          "319:     VIRTIO_GPU_FILL_CMD(att_res);",
          "320:     trace_virtio_gpu_cmd_ctx_res_attach(att_res.hdr.ctx_id,",
          "321:                                         att_res.resource_id);",
          "323:     virgl_renderer_ctx_attach_resource(att_res.hdr.ctx_id, att_res.resource_id);",
          "324: }",
          "326: static void virgl_cmd_ctx_detach_resource(VirtIOGPU *g,",
          "327:                                           struct virtio_gpu_ctrl_command *cmd)",
          "328: {",
          "329:     struct virtio_gpu_ctx_resource det_res;",
          "331:     VIRTIO_GPU_FILL_CMD(det_res);",
          "332:     trace_virtio_gpu_cmd_ctx_res_detach(det_res.hdr.ctx_id,",
          "333:                                         det_res.resource_id);",
          "335:     virgl_renderer_ctx_detach_resource(det_res.hdr.ctx_id, det_res.resource_id);",
          "336: }",
          "338: static void virgl_cmd_get_capset_info(VirtIOGPU *g,",
          "339:                                       struct virtio_gpu_ctrl_command *cmd)",
          "340: {",
          "341:     struct virtio_gpu_get_capset_info info;",
          "342:     struct virtio_gpu_resp_capset_info resp;",
          "344:     VIRTIO_GPU_FILL_CMD(info);",
          "346:     if (info.capset_index == 0) {",
          "347:         resp.capset_id = VIRTIO_GPU_CAPSET_VIRGL;",
          "348:         virgl_renderer_get_cap_set(resp.capset_id,",
          "349:                                    &resp.capset_max_version,",
          "350:                                    &resp.capset_max_size);",
          "351:     } else {",
          "352:         resp.capset_max_version = 0;",
          "353:         resp.capset_max_size = 0;",
          "354:     }",
          "355:     resp.hdr.type = VIRTIO_GPU_RESP_OK_CAPSET_INFO;",
          "356:     virtio_gpu_ctrl_response(g, cmd, &resp.hdr, sizeof(resp));",
          "357: }",
          "359: static void virgl_cmd_get_capset(VirtIOGPU *g,",
          "360:                                  struct virtio_gpu_ctrl_command *cmd)",
          "361: {",
          "362:     struct virtio_gpu_get_capset gc;",
          "363:     struct virtio_gpu_resp_capset *resp;",
          "364:     uint32_t max_ver, max_size;",
          "365:     VIRTIO_GPU_FILL_CMD(gc);",
          "367:     virgl_renderer_get_cap_set(gc.capset_id, &max_ver,",
          "368:                                &max_size);",
          "369:     resp = g_malloc(sizeof(*resp) + max_size);",
          "371:     resp->hdr.type = VIRTIO_GPU_RESP_OK_CAPSET;",
          "372:     virgl_renderer_fill_caps(gc.capset_id,",
          "373:                              gc.capset_version,",
          "374:                              (void *)resp->capset_data);",
          "375:     virtio_gpu_ctrl_response(g, cmd, &resp->hdr, sizeof(*resp) + max_size);",
          "376:     g_free(resp);",
          "377: }",
          "379: void virtio_gpu_virgl_process_cmd(VirtIOGPU *g,",
          "380:                                       struct virtio_gpu_ctrl_command *cmd)",
          "381: {",
          "382:     VIRTIO_GPU_FILL_CMD(cmd->cmd_hdr);",
          "384:     virgl_renderer_force_ctx_0();",
          "385:     switch (cmd->cmd_hdr.type) {",
          "386:     case VIRTIO_GPU_CMD_CTX_CREATE:",
          "387:         virgl_cmd_context_create(g, cmd);",
          "388:         break;",
          "389:     case VIRTIO_GPU_CMD_CTX_DESTROY:",
          "390:         virgl_cmd_context_destroy(g, cmd);",
          "391:         break;",
          "392:     case VIRTIO_GPU_CMD_RESOURCE_CREATE_2D:",
          "393:         virgl_cmd_create_resource_2d(g, cmd);",
          "394:         break;",
          "395:     case VIRTIO_GPU_CMD_RESOURCE_CREATE_3D:",
          "396:         virgl_cmd_create_resource_3d(g, cmd);",
          "397:         break;",
          "398:     case VIRTIO_GPU_CMD_SUBMIT_3D:",
          "399:         virgl_cmd_submit_3d(g, cmd);",
          "400:         break;",
          "401:     case VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D:",
          "402:         virgl_cmd_transfer_to_host_2d(g, cmd);",
          "403:         break;",
          "404:     case VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D:",
          "405:         virgl_cmd_transfer_to_host_3d(g, cmd);",
          "406:         break;",
          "407:     case VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D:",
          "408:         virgl_cmd_transfer_from_host_3d(g, cmd);",
          "409:         break;",
          "410:     case VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING:",
          "411:         virgl_resource_attach_backing(g, cmd);",
          "412:         break;",
          "413:     case VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING:",
          "414:         virgl_resource_detach_backing(g, cmd);",
          "415:         break;",
          "416:     case VIRTIO_GPU_CMD_SET_SCANOUT:",
          "417:         virgl_cmd_set_scanout(g, cmd);",
          "418:         break;",
          "419:     case VIRTIO_GPU_CMD_RESOURCE_FLUSH:",
          "420:         virgl_cmd_resource_flush(g, cmd);",
          "421:        break;",
          "422:     case VIRTIO_GPU_CMD_RESOURCE_UNREF:",
          "423:         virgl_cmd_resource_unref(g, cmd);",
          "424:         break;",
          "425:     case VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE:",
          "427:         virgl_cmd_ctx_attach_resource(g, cmd);",
          "428:         break;",
          "429:     case VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE:",
          "431:         virgl_cmd_ctx_detach_resource(g, cmd);",
          "432:         break;",
          "433:     case VIRTIO_GPU_CMD_GET_CAPSET_INFO:",
          "434:         virgl_cmd_get_capset_info(g, cmd);",
          "435:         break;",
          "436:     case VIRTIO_GPU_CMD_GET_CAPSET:",
          "437:         virgl_cmd_get_capset(g, cmd);",
          "438:         break;",
          "440:     case VIRTIO_GPU_CMD_GET_DISPLAY_INFO:",
          "441:         virtio_gpu_get_display_info(g, cmd);",
          "442:         break;",
          "443:     default:",
          "444:         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;",
          "445:         break;",
          "446:     }",
          "448:     if (cmd->finished) {",
          "449:         return;",
          "450:     }",
          "451:     if (cmd->error) {",
          "452:         fprintf(stderr, \"%s: ctrl 0x%x, error 0x%x\\n\", __func__,",
          "453:                 cmd->cmd_hdr.type, cmd->error);",
          "454:         virtio_gpu_ctrl_response_nodata(g, cmd, cmd->error);",
          "455:         return;",
          "456:     }",
          "457:     if (!(cmd->cmd_hdr.flags & VIRTIO_GPU_FLAG_FENCE)) {",
          "458:         virtio_gpu_ctrl_response_nodata(g, cmd, VIRTIO_GPU_RESP_OK_NODATA);",
          "459:         return;",
          "460:     }",
          "462:     trace_virtio_gpu_fence_ctrl(cmd->cmd_hdr.fence_id, cmd->cmd_hdr.type);",
          "463:     virgl_renderer_create_fence(cmd->cmd_hdr.fence_id, cmd->cmd_hdr.type);",
          "464: }",
          "466: static void virgl_write_fence(void *opaque, uint32_t fence)",
          "467: {",
          "468:     VirtIOGPU *g = opaque;",
          "469:     struct virtio_gpu_ctrl_command *cmd, *tmp;",
          "471:     QTAILQ_FOREACH_SAFE(cmd, &g->fenceq, next, tmp) {",
          "476:         if (cmd->cmd_hdr.fence_id > fence) {",
          "477:             continue;",
          "478:         }",
          "479:         trace_virtio_gpu_fence_resp(cmd->cmd_hdr.fence_id);",
          "480:         virtio_gpu_ctrl_response_nodata(g, cmd, VIRTIO_GPU_RESP_OK_NODATA);",
          "481:         QTAILQ_REMOVE(&g->fenceq, cmd, next);",
          "482:         g_free(cmd);",
          "483:         g->inflight--;",
          "484:         if (virtio_gpu_stats_enabled(g->conf)) {",
          "485:             fprintf(stderr, \"inflight: %3d (-)\\r\", g->inflight);",
          "486:         }",
          "487:     }",
          "488: }",
          "490: static virgl_renderer_gl_context",
          "491: virgl_create_context(void *opaque, int scanout_idx,",
          "492:                      struct virgl_renderer_gl_ctx_param *params)",
          "493: {",
          "494:     VirtIOGPU *g = opaque;",
          "495:     QEMUGLContext ctx;",
          "496:     QEMUGLParams qparams;",
          "498:     qparams.major_ver = params->major_ver;",
          "499:     qparams.minor_ver = params->minor_ver;",
          "501:     ctx = dpy_gl_ctx_create(g->scanout[scanout_idx].con, &qparams);",
          "502:     return (virgl_renderer_gl_context)ctx;",
          "503: }",
          "505: static void virgl_destroy_context(void *opaque, virgl_renderer_gl_context ctx)",
          "506: {",
          "507:     VirtIOGPU *g = opaque;",
          "508:     QEMUGLContext qctx = (QEMUGLContext)ctx;",
          "510:     dpy_gl_ctx_destroy(g->scanout[0].con, qctx);",
          "511: }",
          "513: static int virgl_make_context_current(void *opaque, int scanout_idx,",
          "514:                                       virgl_renderer_gl_context ctx)",
          "515: {",
          "516:     VirtIOGPU *g = opaque;",
          "517:     QEMUGLContext qctx = (QEMUGLContext)ctx;",
          "519:     return dpy_gl_ctx_make_current(g->scanout[scanout_idx].con, qctx);",
          "520: }",
          "522: static struct virgl_renderer_callbacks virtio_gpu_3d_cbs = {",
          "523:     .version             = 1,",
          "524:     .write_fence         = virgl_write_fence,",
          "525:     .create_gl_context   = virgl_create_context,",
          "526:     .destroy_gl_context  = virgl_destroy_context,",
          "527:     .make_current        = virgl_make_context_current,",
          "528: };",
          "530: static void virtio_gpu_print_stats(void *opaque)",
          "531: {",
          "532:     VirtIOGPU *g = opaque;",
          "534:     if (g->stats.requests) {",
          "535:         fprintf(stderr, \"stats: vq req %4d, %3d -- 3D %4d (%5d)\\n\",",
          "536:                 g->stats.requests,",
          "537:                 g->stats.max_inflight,",
          "538:                 g->stats.req_3d,",
          "539:                 g->stats.bytes_3d);",
          "540:         g->stats.requests     = 0;",
          "541:         g->stats.max_inflight = 0;",
          "542:         g->stats.req_3d       = 0;",
          "543:         g->stats.bytes_3d     = 0;",
          "544:     } else {",
          "545:         fprintf(stderr, \"stats: idle\\r\");",
          "546:     }",
          "547:     timer_mod(g->print_stats, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 1000);",
          "548: }",
          "550: static void virtio_gpu_fence_poll(void *opaque)",
          "551: {",
          "552:     VirtIOGPU *g = opaque;",
          "554:     virgl_renderer_poll();",
          "555:     if (g->inflight) {",
          "556:         timer_mod(g->fence_poll, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 10);",
          "557:     }",
          "558: }",
          "560: void virtio_gpu_virgl_fence_poll(VirtIOGPU *g)",
          "561: {",
          "562:     virtio_gpu_fence_poll(g);",
          "563: }",
          "565: void virtio_gpu_virgl_reset(VirtIOGPU *g)",
          "566: {",
          "567:     int i;",
          "570:     for (i = 0; i < g->conf.max_outputs; i++) {",
          "571:         if (i != 0) {",
          "572:             dpy_gfx_replace_surface(g->scanout[i].con, NULL);",
          "573:         }",
          "574:         dpy_gl_scanout(g->scanout[i].con, 0, false, 0, 0, 0, 0);",
          "575:     }",
          "576: }",
          "578: int virtio_gpu_virgl_init(VirtIOGPU *g)",
          "579: {",
          "580:     int ret;",
          "582:     ret = virgl_renderer_init(g, 0, &virtio_gpu_3d_cbs);",
          "583:     if (ret != 0) {",
          "584:         return ret;",
          "585:     }",
          "587:     g->fence_poll = timer_new_ms(QEMU_CLOCK_VIRTUAL,",
          "588:                                  virtio_gpu_fence_poll, g);",
          "590:     if (virtio_gpu_stats_enabled(g->conf)) {",
          "591:         g->print_stats = timer_new_ms(QEMU_CLOCK_VIRTUAL,",
          "592:                                       virtio_gpu_print_stats, g);",
          "593:         timer_mod(g->print_stats, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 1000);",
          "594:     }",
          "595:     return 0;",
          "596: }",
          "",
          "---------------"
        ],
        "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c": [
          "File: hw/display/virtio-gpu.c -> hw/display/virtio-gpu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: static struct virtio_gpu_simple_resource*",
          "23: virtio_gpu_find_resource(VirtIOGPU *g, uint32_t resource_id);",
          "25: static void update_cursor_data_simple(VirtIOGPU *g,",
          "26:                                       struct virtio_gpu_scanout *s,",
          "27:                                       uint32_t resource_id)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #ifdef CONFIG_VIRGL",
          "26: #include \"virglrenderer.h\"",
          "27: #define VIRGL(_g, _virgl, _simple, ...)                     \\",
          "28:     do {                                                    \\",
          "29:         if (_g->use_virgl_renderer) {                       \\",
          "30:             _virgl(__VA_ARGS__);                            \\",
          "31:         } else {                                            \\",
          "32:             _simple(__VA_ARGS__);                           \\",
          "33:         }                                                   \\",
          "34:     } while (0)",
          "35: #else",
          "36: #define VIRGL(_g, _virgl, _simple, ...)                 \\",
          "37:     do {                                                \\",
          "38:         _simple(__VA_ARGS__);                           \\",
          "39:     } while (0)",
          "40: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:            pixels * sizeof(uint32_t));",
          "46: }",
          "48: static void update_cursor(VirtIOGPU *g, struct virtio_gpu_update_cursor *cursor)",
          "49: {",
          "50:     struct virtio_gpu_scanout *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "65: #ifdef CONFIG_VIRGL",
          "67: static void update_cursor_data_virgl(VirtIOGPU *g,",
          "68:                                      struct virtio_gpu_scanout *s,",
          "69:                                      uint32_t resource_id)",
          "70: {",
          "71:     uint32_t width, height;",
          "72:     uint32_t pixels, *data;",
          "74:     data = virgl_renderer_get_cursor_data(resource_id, &width, &height);",
          "75:     if (!data) {",
          "76:         return;",
          "77:     }",
          "79:     if (width != s->current_cursor->width ||",
          "80:         height != s->current_cursor->height) {",
          "81:         return;",
          "82:     }",
          "84:     pixels = s->current_cursor->width * s->current_cursor->height;",
          "85:     memcpy(s->current_cursor->data, data, pixels * sizeof(uint32_t));",
          "86:     free(data);",
          "87: }",
          "89: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:         s->current_cursor->hot_y = cursor->hot_y;",
          "65:         if (cursor->resource_id > 0) {",
          "67:         }",
          "68:         dpy_cursor_define(s->con, s->current_cursor);",
          "69:     }",
          "",
          "[Removed Lines]",
          "66:             update_cursor_data_simple(g, s, cursor->resource_id);",
          "",
          "[Added Lines]",
          "109:             VIRGL(g, update_cursor_data_virgl, update_cursor_data_simple,",
          "110:                   g, s, cursor->resource_id);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "92: static uint64_t virtio_gpu_get_features(VirtIODevice *vdev, uint64_t features,",
          "93:                                         Error **errp)",
          "94: {",
          "95:     return features;",
          "96: }",
          "98: static void virtio_gpu_notify_event(VirtIOGPU *g, uint32_t event_type)",
          "99: {",
          "100:     g->virtio_config.events_read |= event_type;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "141:     if (virtio_gpu_virgl_enabled(g->conf)) {",
          "142:         features |= (1 << VIRTIO_GPU_FEATURE_VIRGL);",
          "143:     }",
          "147: static void virtio_gpu_set_features(VirtIODevice *vdev, uint64_t features)",
          "148: {",
          "149:     static const uint32_t virgl = (1 << VIRTIO_GPU_FEATURE_VIRGL);",
          "150:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "152:     g->use_virgl_renderer = ((features & virgl) == virgl);",
          "153:     trace_virtio_gpu_features(g->use_virgl_renderer);",
          "154: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "698:         return;",
          "699:     }",
          "701:     cmd = g_new(struct virtio_gpu_ctrl_command, 1);",
          "702:     while (virtqueue_pop(vq, &cmd->elem)) {",
          "703:         cmd->vq = vq;",
          "704:         cmd->error = 0;",
          "705:         cmd->finished = false;",
          "709:         if (!cmd->finished) {",
          "710:             QTAILQ_INSERT_TAIL(&g->fenceq, cmd, next);",
          "714:             }",
          "716:             cmd = g_new(struct virtio_gpu_ctrl_command, 1);",
          "717:         }",
          "718:     }",
          "719:     g_free(cmd);",
          "720: }",
          "722: static void virtio_gpu_ctrl_bh(void *opaque)",
          "",
          "[Removed Lines]",
          "706:         g->stats.requests++;",
          "708:         virtio_gpu_simple_process_cmd(g, cmd);",
          "711:             g->stats.inflight++;",
          "712:             if (g->stats.max_inflight < g->stats.inflight) {",
          "713:                 g->stats.max_inflight = g->stats.inflight;",
          "715:             fprintf(stderr, \"inflight: %3d (+)\\r\", g->stats.inflight);",
          "",
          "[Added Lines]",
          "759: #ifdef CONFIG_VIRGL",
          "760:     if (!g->renderer_inited && g->use_virgl_renderer) {",
          "761:         virtio_gpu_virgl_init(g);",
          "762:         g->renderer_inited = true;",
          "763:     }",
          "764: #endif",
          "771:         if (virtio_gpu_stats_enabled(g->conf)) {",
          "772:             g->stats.requests++;",
          "773:         }",
          "775:         VIRGL(g, virtio_gpu_virgl_process_cmd, virtio_gpu_simple_process_cmd,",
          "776:               g, cmd);",
          "779:             g->inflight++;",
          "780:             if (virtio_gpu_stats_enabled(g->conf)) {",
          "781:                 if (g->stats.max_inflight < g->inflight) {",
          "782:                     g->stats.max_inflight = g->inflight;",
          "783:                 }",
          "784:                 fprintf(stderr, \"inflight: %3d (+)\\r\", g->inflight);",
          "791: #ifdef CONFIG_VIRGL",
          "792:     if (g->use_virgl_renderer) {",
          "793:         virtio_gpu_virgl_fence_poll(g);",
          "794:     }",
          "795: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "803: {",
          "804:     VirtIODevice *vdev = VIRTIO_DEVICE(qdev);",
          "805:     VirtIOGPU *g = VIRTIO_GPU(qdev);",
          "806:     int i;",
          "808:     g->config_size = sizeof(struct virtio_gpu_config);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "882:     bool have_virgl;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "813:     g->req_state[0].width = 1024;",
          "814:     g->req_state[0].height = 768;",
          "819:     g->ctrl_bh = qemu_bh_new(virtio_gpu_ctrl_bh, g);",
          "820:     g->cursor_bh = qemu_bh_new(virtio_gpu_cursor_bh, g);",
          "",
          "[Removed Lines]",
          "816:     g->ctrl_vq   = virtio_add_queue(vdev, 64, virtio_gpu_handle_ctrl_cb);",
          "817:     g->cursor_vq = virtio_add_queue(vdev, 16, virtio_gpu_handle_cursor_cb);",
          "",
          "[Added Lines]",
          "893:     g->use_virgl_renderer = false;",
          "894: #if !defined(CONFIG_VIRGL) || defined(HOST_WORDS_BIGENDIAN)",
          "895:     have_virgl = false;",
          "896: #else",
          "897:     have_virgl = display_opengl;",
          "898: #endif",
          "899:     if (!have_virgl) {",
          "900:         g->conf.flags &= ~(1 << VIRTIO_GPU_FLAG_VIRGL_ENABLED);",
          "901:     }",
          "903:     if (virtio_gpu_virgl_enabled(g->conf)) {",
          "905:         g->ctrl_vq   = virtio_add_queue(vdev, 256, virtio_gpu_handle_ctrl_cb);",
          "906:         g->cursor_vq = virtio_add_queue(vdev, 16, virtio_gpu_handle_cursor_cb);",
          "907:         g->virtio_config.num_capsets = 1;",
          "908:     } else {",
          "909:         g->ctrl_vq   = virtio_add_queue(vdev, 64, virtio_gpu_handle_ctrl_cb);",
          "910:         g->cursor_vq = virtio_add_queue(vdev, 16, virtio_gpu_handle_cursor_cb);",
          "911:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "868:         g->scanout[i].ds = NULL;",
          "869:     }",
          "870:     g->enabled_output_bitmask = 1;",
          "871: }",
          "873: static Property virtio_gpu_properties[] = {",
          "874:     DEFINE_PROP_UINT32(\"max_outputs\", VirtIOGPU, conf.max_outputs, 1),",
          "875:     DEFINE_PROP_END_OF_LIST(),",
          "876: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "966: #ifdef CONFIG_VIRGL",
          "967:     if (g->use_virgl_renderer) {",
          "968:         virtio_gpu_virgl_reset(g);",
          "969:         g->use_virgl_renderer = 0;",
          "970:     }",
          "971: #endif",
          "976: #ifdef CONFIG_VIRGL",
          "977:     DEFINE_PROP_BIT(\"virgl\", VirtIOGPU, conf.flags,",
          "978:                     VIRTIO_GPU_FLAG_VIRGL_ENABLED, true),",
          "979:     DEFINE_PROP_BIT(\"stats\", VirtIOGPU, conf.flags,",
          "980:                     VIRTIO_GPU_FLAG_STATS_ENABLED, false),",
          "981: #endif",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "884:     vdc->get_config = virtio_gpu_get_config;",
          "885:     vdc->set_config = virtio_gpu_set_config;",
          "886:     vdc->get_features = virtio_gpu_get_features;",
          "888:     vdc->reset = virtio_gpu_reset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "994:     vdc->set_features = virtio_gpu_set_features;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "916: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_attach_backing) != 32);",
          "917: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_detach_backing) != 32);",
          "918: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resp_display_info)       != 408);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1028: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_transfer_host_3d)        != 72);",
          "1029: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_create_3d)      != 72);",
          "1030: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_ctx_create)              != 96);",
          "1031: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_ctx_destroy)             != 24);",
          "1032: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_ctx_resource)            != 32);",
          "1033: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_cmd_submit)              != 32);",
          "1034: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_get_capset_info)         != 32);",
          "1035: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resp_capset_info)        != 40);",
          "1036: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_get_capset)              != 32);",
          "1037: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resp_capset)             != 24);",
          "",
          "---------------"
        ],
        "include/hw/virtio/virtio-gpu.h||include/hw/virtio/virtio-gpu.h": [
          "File: include/hw/virtio/virtio-gpu.h -> include/hw/virtio/virtio-gpu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:     int x, y;",
          "57: };",
          "59: struct virtio_gpu_conf {",
          "60:     uint32_t max_outputs;",
          "61: };",
          "63: struct virtio_gpu_ctrl_command {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: enum virtio_gpu_conf_flags {",
          "60:     VIRTIO_GPU_FLAG_VIRGL_ENABLED = 1,",
          "61:     VIRTIO_GPU_FLAG_STATS_ENABLED,",
          "62: };",
          "64: #define virtio_gpu_virgl_enabled(_cfg) \\",
          "65:     (_cfg.flags & (1 << VIRTIO_GPU_FLAG_VIRGL_ENABLED))",
          "66: #define virtio_gpu_stats_enabled(_cfg) \\",
          "67:     (_cfg.flags & (1 << VIRTIO_GPU_FLAG_STATS_ENABLED))",
          "71:     uint32_t flags;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92:     int enabled_output_bitmask;",
          "93:     struct virtio_gpu_config virtio_config;",
          "95:     QEMUTimer *fence_poll;",
          "96:     QEMUTimer *print_stats;",
          "98:     struct {",
          "100:         uint32_t max_inflight;",
          "101:         uint32_t requests;",
          "102:         uint32_t req_3d;",
          "",
          "[Removed Lines]",
          "99:         uint32_t inflight;",
          "",
          "[Added Lines]",
          "106:     bool use_virgl_renderer;",
          "107:     bool renderer_inited;",
          "111:     uint32_t inflight;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "139:                                   struct iovec **iov);",
          "140: void virtio_gpu_cleanup_mapping_iov(struct iovec *iov, uint32_t count);",
          "142: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156: void virtio_gpu_virgl_process_cmd(VirtIOGPU *g,",
          "157:                                   struct virtio_gpu_ctrl_command *cmd);",
          "158: void virtio_gpu_virgl_fence_poll(VirtIOGPU *g);",
          "159: void virtio_gpu_virgl_reset(VirtIOGPU *g);",
          "160: int virtio_gpu_virgl_init(VirtIOGPU *g);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe89fdebcaab696d525f2905b33d7b303111eade",
      "candidate_info": {
        "commit_hash": "fe89fdebcaab696d525f2905b33d7b303111eade",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/fe89fdebcaab696d525f2905b33d7b303111eade",
        "files": [
          "hw/display/virtio-gpu.c"
        ],
        "message": "virtio-gpu: check early scanout id\n\nBefore accessing the g->scanout array, in order to avoid potential\nout-of-bounds access.\n\nSigned-off-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 1463653560-26958-2-git-send-email-marcandre.lureau@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>",
        "before_after_code_files": [
          "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
          ],
          "candidate": [
            "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c": [
          "File: hw/display/virtio-gpu.c -> hw/display/virtio-gpu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "508:     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,",
          "509:                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);",
          "511:     g->enable = 1;",
          "512:     if (ss.resource_id == 0) {",
          "513:         scanout = &g->scanout[ss.scanout_id];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "511:     if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT ||",
          "512:         ss.scanout_id >= g->conf.max_outputs) {",
          "513:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",",
          "514:                       __func__, ss.scanout_id);",
          "515:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;",
          "516:         return;",
          "517:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "517:                 res->scanout_bitmask &= ~(1 << ss.scanout_id);",
          "518:             }",
          "519:         }",
          "522:             qemu_log_mask(LOG_GUEST_ERROR,",
          "523:                           \"%s: illegal scanout id specified %d\",",
          "524:                           __func__, ss.scanout_id);",
          "",
          "[Removed Lines]",
          "520:         if (ss.scanout_id == 0 ||",
          "521:             ss.scanout_id >= g->conf.max_outputs) {",
          "",
          "[Added Lines]",
          "528:         if (ss.scanout_id == 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "533:     }",
          "544:     res = virtio_gpu_find_resource(g, ss.resource_id);",
          "545:     if (!res) {",
          "546:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",",
          "",
          "[Removed Lines]",
          "536:     if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT ||",
          "537:         ss.scanout_id >= g->conf.max_outputs) {",
          "538:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",",
          "539:                       __func__, ss.scanout_id);",
          "540:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;",
          "541:         return;",
          "542:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "62232bf48456bda4058ceae05851bc58c1032338",
      "candidate_info": {
        "commit_hash": "62232bf48456bda4058ceae05851bc58c1032338",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/62232bf48456bda4058ceae05851bc58c1032338",
        "files": [
          "hw/display/Makefile.objs",
          "hw/display/virtio-gpu.c",
          "include/hw/virtio/virtio-gpu.h",
          "trace-events"
        ],
        "message": "virtio-gpu/2d: add virtio gpu core code\n\nThis patch adds the core code for virtio gpu emulation,\ncovering 2d support.\n\nWritten by Dave Airlie and Gerd Hoffmann.\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>",
        "before_after_code_files": [
          "hw/display/Makefile.objs||hw/display/Makefile.objs",
          "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c",
          "include/hw/virtio/virtio-gpu.h||include/hw/virtio/virtio-gpu.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
          ],
          "candidate": [
            "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/display/Makefile.objs||hw/display/Makefile.objs": [
          "File: hw/display/Makefile.objs -> hw/display/Makefile.objs",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: obj-$(CONFIG_VGA) += vga.o",
          "36: common-obj-$(CONFIG_QXL) += qxl.o qxl-logger.o qxl-render.o",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: obj-$(CONFIG_VIRTIO) += virtio-gpu.o",
          "",
          "---------------"
        ],
        "hw/display/virtio-gpu.c||hw/display/virtio-gpu.c": [
          "File: hw/display/virtio-gpu.c -> hw/display/virtio-gpu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include \"qemu-common.h\"",
          "15: #include \"qemu/iov.h\"",
          "16: #include \"ui/console.h\"",
          "17: #include \"trace.h\"",
          "18: #include \"hw/virtio/virtio.h\"",
          "19: #include \"hw/virtio/virtio-gpu.h\"",
          "20: #include \"hw/virtio/virtio-bus.h\"",
          "22: static struct virtio_gpu_simple_resource*",
          "23: virtio_gpu_find_resource(VirtIOGPU *g, uint32_t resource_id);",
          "25: static void update_cursor_data_simple(VirtIOGPU *g,",
          "26:                                       struct virtio_gpu_scanout *s,",
          "27:                                       uint32_t resource_id)",
          "28: {",
          "29:     struct virtio_gpu_simple_resource *res;",
          "30:     uint32_t pixels;",
          "32:     res = virtio_gpu_find_resource(g, resource_id);",
          "33:     if (!res) {",
          "34:         return;",
          "35:     }",
          "37:     if (pixman_image_get_width(res->image)  != s->current_cursor->width ||",
          "38:         pixman_image_get_height(res->image) != s->current_cursor->height) {",
          "39:         return;",
          "40:     }",
          "42:     pixels = s->current_cursor->width * s->current_cursor->height;",
          "43:     memcpy(s->current_cursor->data,",
          "44:            pixman_image_get_data(res->image),",
          "45:            pixels * sizeof(uint32_t));",
          "46: }",
          "48: static void update_cursor(VirtIOGPU *g, struct virtio_gpu_update_cursor *cursor)",
          "49: {",
          "50:     struct virtio_gpu_scanout *s;",
          "52:     if (cursor->pos.scanout_id >= g->conf.max_outputs) {",
          "53:         return;",
          "54:     }",
          "55:     s = &g->scanout[cursor->pos.scanout_id];",
          "57:     if (cursor->hdr.type != VIRTIO_GPU_CMD_MOVE_CURSOR) {",
          "58:         if (!s->current_cursor) {",
          "59:             s->current_cursor = cursor_alloc(64, 64);",
          "60:         }",
          "62:         s->current_cursor->hot_x = cursor->hot_x;",
          "63:         s->current_cursor->hot_y = cursor->hot_y;",
          "65:         if (cursor->resource_id > 0) {",
          "66:             update_cursor_data_simple(g, s, cursor->resource_id);",
          "67:         }",
          "68:         dpy_cursor_define(s->con, s->current_cursor);",
          "69:     }",
          "70:     dpy_mouse_set(s->con, cursor->pos.x, cursor->pos.y,",
          "71:                   cursor->resource_id ? 1 : 0);",
          "72: }",
          "74: static void virtio_gpu_get_config(VirtIODevice *vdev, uint8_t *config)",
          "75: {",
          "76:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "77:     memcpy(config, &g->virtio_config, sizeof(g->virtio_config));",
          "78: }",
          "80: static void virtio_gpu_set_config(VirtIODevice *vdev, const uint8_t *config)",
          "81: {",
          "82:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "83:     struct virtio_gpu_config vgconfig;",
          "85:     memcpy(&vgconfig, config, sizeof(g->virtio_config));",
          "87:     if (vgconfig.events_clear) {",
          "88:         g->virtio_config.events_read &= ~vgconfig.events_clear;",
          "89:     }",
          "90: }",
          "92: static uint64_t virtio_gpu_get_features(VirtIODevice *vdev, uint64_t features)",
          "93: {",
          "94:     return features;",
          "95: }",
          "97: static void virtio_gpu_notify_event(VirtIOGPU *g, uint32_t event_type)",
          "98: {",
          "99:     g->virtio_config.events_read |= event_type;",
          "100:     virtio_notify_config(&g->parent_obj);",
          "101: }",
          "103: static struct virtio_gpu_simple_resource *",
          "104: virtio_gpu_find_resource(VirtIOGPU *g, uint32_t resource_id)",
          "105: {",
          "106:     struct virtio_gpu_simple_resource *res;",
          "108:     QTAILQ_FOREACH(res, &g->reslist, next) {",
          "109:         if (res->resource_id == resource_id) {",
          "110:             return res;",
          "111:         }",
          "112:     }",
          "113:     return NULL;",
          "114: }",
          "116: void virtio_gpu_ctrl_response(VirtIOGPU *g,",
          "117:                               struct virtio_gpu_ctrl_command *cmd,",
          "118:                               struct virtio_gpu_ctrl_hdr *resp,",
          "119:                               size_t resp_len)",
          "120: {",
          "121:     size_t s;",
          "123:     if (cmd->cmd_hdr.flags & VIRTIO_GPU_FLAG_FENCE) {",
          "124:         resp->flags |= VIRTIO_GPU_FLAG_FENCE;",
          "125:         resp->fence_id = cmd->cmd_hdr.fence_id;",
          "126:         resp->ctx_id = cmd->cmd_hdr.ctx_id;",
          "127:     }",
          "128:     s = iov_from_buf(cmd->elem.in_sg, cmd->elem.in_num, 0, resp, resp_len);",
          "129:     if (s != resp_len) {",
          "130:         qemu_log_mask(LOG_GUEST_ERROR,",
          "131:                       \"%s: response size incorrect %zu vs %zu\\n\",",
          "132:                       __func__, s, resp_len);",
          "133:     }",
          "134:     virtqueue_push(cmd->vq, &cmd->elem, s);",
          "135:     virtio_notify(VIRTIO_DEVICE(g), cmd->vq);",
          "136:     cmd->finished = true;",
          "137: }",
          "139: void virtio_gpu_ctrl_response_nodata(VirtIOGPU *g,",
          "140:                                      struct virtio_gpu_ctrl_command *cmd,",
          "141:                                      enum virtio_gpu_ctrl_type type)",
          "142: {",
          "143:     struct virtio_gpu_ctrl_hdr resp;",
          "145:     memset(&resp, 0, sizeof(resp));",
          "146:     resp.type = type;",
          "147:     virtio_gpu_ctrl_response(g, cmd, &resp, sizeof(resp));",
          "148: }",
          "150: static void",
          "151: virtio_gpu_fill_display_info(VirtIOGPU *g,",
          "152:                              struct virtio_gpu_resp_display_info *dpy_info)",
          "153: {",
          "154:     int i;",
          "156:     for (i = 0; i < g->conf.max_outputs; i++) {",
          "157:         if (g->enabled_output_bitmask & (1 << i)) {",
          "158:             dpy_info->pmodes[i].enabled = 1;",
          "159:             dpy_info->pmodes[i].r.width = g->req_state[i].width;",
          "160:             dpy_info->pmodes[i].r.height = g->req_state[i].height;",
          "161:         }",
          "162:     }",
          "163: }",
          "165: void virtio_gpu_get_display_info(VirtIOGPU *g,",
          "166:                                  struct virtio_gpu_ctrl_command *cmd)",
          "167: {",
          "168:     struct virtio_gpu_resp_display_info display_info;",
          "170:     trace_virtio_gpu_cmd_get_display_info();",
          "171:     memset(&display_info, 0, sizeof(display_info));",
          "172:     display_info.hdr.type = VIRTIO_GPU_RESP_OK_DISPLAY_INFO;",
          "173:     virtio_gpu_fill_display_info(g, &display_info);",
          "174:     virtio_gpu_ctrl_response(g, cmd, &display_info.hdr,",
          "175:                              sizeof(display_info));",
          "176: }",
          "178: static pixman_format_code_t get_pixman_format(uint32_t virtio_gpu_format)",
          "179: {",
          "180:     switch (virtio_gpu_format) {",
          "181: #ifdef HOST_WORDS_BIGENDIAN",
          "182:     case VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM:",
          "183:         return PIXMAN_b8g8r8x8;",
          "184:     case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:",
          "185:         return PIXMAN_b8g8r8a8;",
          "186:     case VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM:",
          "187:         return PIXMAN_x8r8g8b8;",
          "188:     case VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM:",
          "189:         return PIXMAN_a8r8g8b8;",
          "190:     case VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM:",
          "191:         return PIXMAN_r8g8b8x8;",
          "192:     case VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM:",
          "193:         return PIXMAN_r8g8b8a8;",
          "194:     case VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM:",
          "195:         return PIXMAN_x8b8g8r8;",
          "196:     case VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM:",
          "197:         return PIXMAN_a8b8g8r8;",
          "198: #else",
          "199:     case VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM:",
          "200:         return PIXMAN_x8r8g8b8;",
          "201:     case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:",
          "202:         return PIXMAN_a8r8g8b8;",
          "203:     case VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM:",
          "204:         return PIXMAN_b8g8r8x8;",
          "205:     case VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM:",
          "206:         return PIXMAN_b8g8r8a8;",
          "207:     case VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM:",
          "208:         return PIXMAN_x8b8g8r8;",
          "209:     case VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM:",
          "210:         return PIXMAN_a8b8g8r8;",
          "211:     case VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM:",
          "212:         return PIXMAN_r8g8b8x8;",
          "213:     case VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM:",
          "214:         return PIXMAN_r8g8b8a8;",
          "215: #endif",
          "216:     default:",
          "217:         return 0;",
          "218:     }",
          "219: }",
          "221: static void virtio_gpu_resource_create_2d(VirtIOGPU *g,",
          "222:                                           struct virtio_gpu_ctrl_command *cmd)",
          "223: {",
          "224:     pixman_format_code_t pformat;",
          "225:     struct virtio_gpu_simple_resource *res;",
          "226:     struct virtio_gpu_resource_create_2d c2d;",
          "228:     VIRTIO_GPU_FILL_CMD(c2d);",
          "229:     trace_virtio_gpu_cmd_res_create_2d(c2d.resource_id, c2d.format,",
          "230:                                        c2d.width, c2d.height);",
          "232:     if (c2d.resource_id == 0) {",
          "233:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: resource id 0 is not allowed\\n\",",
          "234:                       __func__);",
          "235:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "236:         return;",
          "237:     }",
          "239:     res = virtio_gpu_find_resource(g, c2d.resource_id);",
          "240:     if (res) {",
          "241:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: resource already exists %d\\n\",",
          "242:                       __func__, c2d.resource_id);",
          "243:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "244:         return;",
          "245:     }",
          "247:     res = g_new0(struct virtio_gpu_simple_resource, 1);",
          "249:     res->width = c2d.width;",
          "250:     res->height = c2d.height;",
          "251:     res->format = c2d.format;",
          "252:     res->resource_id = c2d.resource_id;",
          "254:     pformat = get_pixman_format(c2d.format);",
          "255:     if (!pformat) {",
          "256:         qemu_log_mask(LOG_GUEST_ERROR,",
          "257:                       \"%s: host couldn't handle guest format %d\\n\",",
          "258:                       __func__, c2d.format);",
          "259:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;",
          "260:         return;",
          "261:     }",
          "262:     res->image = pixman_image_create_bits(pformat,",
          "263:                                           c2d.width,",
          "264:                                           c2d.height,",
          "265:                                           NULL, 0);",
          "267:     if (!res->image) {",
          "268:         qemu_log_mask(LOG_GUEST_ERROR,",
          "269:                       \"%s: resource creation failed %d %d %d\\n\",",
          "270:                       __func__, c2d.resource_id, c2d.width, c2d.height);",
          "271:         g_free(res);",
          "272:         cmd->error = VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY;",
          "273:         return;",
          "274:     }",
          "276:     QTAILQ_INSERT_HEAD(&g->reslist, res, next);",
          "277: }",
          "279: static void virtio_gpu_resource_destroy(VirtIOGPU *g,",
          "280:                                         struct virtio_gpu_simple_resource *res)",
          "281: {",
          "282:     pixman_image_unref(res->image);",
          "283:     QTAILQ_REMOVE(&g->reslist, res, next);",
          "284:     g_free(res);",
          "285: }",
          "287: static void virtio_gpu_resource_unref(VirtIOGPU *g,",
          "288:                                       struct virtio_gpu_ctrl_command *cmd)",
          "289: {",
          "290:     struct virtio_gpu_simple_resource *res;",
          "291:     struct virtio_gpu_resource_unref unref;",
          "293:     VIRTIO_GPU_FILL_CMD(unref);",
          "294:     trace_virtio_gpu_cmd_res_unref(unref.resource_id);",
          "296:     res = virtio_gpu_find_resource(g, unref.resource_id);",
          "297:     if (!res) {",
          "298:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",",
          "299:                       __func__, unref.resource_id);",
          "300:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "301:         return;",
          "302:     }",
          "303:     virtio_gpu_resource_destroy(g, res);",
          "304: }",
          "306: static void virtio_gpu_transfer_to_host_2d(VirtIOGPU *g,",
          "307:                                            struct virtio_gpu_ctrl_command *cmd)",
          "308: {",
          "309:     struct virtio_gpu_simple_resource *res;",
          "310:     int h;",
          "311:     uint32_t src_offset, dst_offset, stride;",
          "312:     int bpp;",
          "313:     pixman_format_code_t format;",
          "314:     struct virtio_gpu_transfer_to_host_2d t2d;",
          "316:     VIRTIO_GPU_FILL_CMD(t2d);",
          "317:     trace_virtio_gpu_cmd_res_xfer_toh_2d(t2d.resource_id);",
          "319:     res = virtio_gpu_find_resource(g, t2d.resource_id);",
          "320:     if (!res || !res->iov) {",
          "321:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",",
          "322:                       __func__, t2d.resource_id);",
          "323:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "324:         return;",
          "325:     }",
          "327:     if (t2d.r.x > res->width ||",
          "328:         t2d.r.y > res->height ||",
          "329:         t2d.r.width > res->width ||",
          "330:         t2d.r.height > res->height ||",
          "331:         t2d.r.x + t2d.r.width > res->width ||",
          "332:         t2d.r.y + t2d.r.height > res->height) {",
          "333:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: transfer bounds outside resource\"",
          "334:                       \" bounds for resource %d: %d %d %d %d vs %d %d\\n\",",
          "335:                       __func__, t2d.resource_id, t2d.r.x, t2d.r.y,",
          "336:                       t2d.r.width, t2d.r.height, res->width, res->height);",
          "337:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;",
          "338:         return;",
          "339:     }",
          "341:     format = pixman_image_get_format(res->image);",
          "342:     bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;",
          "343:     stride = pixman_image_get_stride(res->image);",
          "345:     if (t2d.offset || t2d.r.x || t2d.r.y ||",
          "346:         t2d.r.width != pixman_image_get_width(res->image)) {",
          "347:         void *img_data = pixman_image_get_data(res->image);",
          "348:         for (h = 0; h < t2d.r.height; h++) {",
          "349:             src_offset = t2d.offset + stride * h;",
          "350:             dst_offset = (t2d.r.y + h) * stride + (t2d.r.x * bpp);",
          "352:             iov_to_buf(res->iov, res->iov_cnt, src_offset,",
          "353:                        (uint8_t *)img_data",
          "354:                        + dst_offset, t2d.r.width * bpp);",
          "355:         }",
          "356:     } else {",
          "357:         iov_to_buf(res->iov, res->iov_cnt, 0,",
          "358:                    pixman_image_get_data(res->image),",
          "359:                    pixman_image_get_stride(res->image)",
          "361:     }",
          "362: }",
          "364: static void virtio_gpu_resource_flush(VirtIOGPU *g,",
          "365:                                       struct virtio_gpu_ctrl_command *cmd)",
          "366: {",
          "367:     struct virtio_gpu_simple_resource *res;",
          "368:     struct virtio_gpu_resource_flush rf;",
          "369:     pixman_region16_t flush_region;",
          "370:     int i;",
          "372:     VIRTIO_GPU_FILL_CMD(rf);",
          "373:     trace_virtio_gpu_cmd_res_flush(rf.resource_id,",
          "374:                                    rf.r.width, rf.r.height, rf.r.x, rf.r.y);",
          "376:     res = virtio_gpu_find_resource(g, rf.resource_id);",
          "377:     if (!res) {",
          "378:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",",
          "379:                       __func__, rf.resource_id);",
          "380:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "381:         return;",
          "382:     }",
          "384:     if (rf.r.x > res->width ||",
          "385:         rf.r.y > res->height ||",
          "386:         rf.r.width > res->width ||",
          "387:         rf.r.height > res->height ||",
          "388:         rf.r.x + rf.r.width > res->width ||",
          "389:         rf.r.y + rf.r.height > res->height) {",
          "390:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: flush bounds outside resource\"",
          "391:                       \" bounds for resource %d: %d %d %d %d vs %d %d\\n\",",
          "392:                       __func__, rf.resource_id, rf.r.x, rf.r.y,",
          "393:                       rf.r.width, rf.r.height, res->width, res->height);",
          "394:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;",
          "395:         return;",
          "396:     }",
          "398:     pixman_region_init_rect(&flush_region,",
          "399:                             rf.r.x, rf.r.y, rf.r.width, rf.r.height);",
          "400:     for (i = 0; i < VIRTIO_GPU_MAX_SCANOUT; i++) {",
          "401:         struct virtio_gpu_scanout *scanout;",
          "402:         pixman_region16_t region, finalregion;",
          "403:         pixman_box16_t *extents;",
          "405:         if (!(res->scanout_bitmask & (1 << i))) {",
          "406:             continue;",
          "407:         }",
          "408:         scanout = &g->scanout[i];",
          "410:         pixman_region_init(&finalregion);",
          "411:         pixman_region_init_rect(&region, scanout->x, scanout->y,",
          "412:                                 scanout->width, scanout->height);",
          "414:         pixman_region_intersect(&finalregion, &flush_region, &region);",
          "415:         pixman_region_translate(&finalregion, -scanout->x, -scanout->y);",
          "416:         extents = pixman_region_extents(&finalregion);",
          "418:         dpy_gfx_update(g->scanout[i].con,",
          "419:                        extents->x1, extents->y1,",
          "420:                        extents->x2 - extents->x1,",
          "421:                        extents->y2 - extents->y1);",
          "423:         pixman_region_fini(&region);",
          "424:         pixman_region_fini(&finalregion);",
          "425:     }",
          "426:     pixman_region_fini(&flush_region);",
          "427: }",
          "429: static void virtio_gpu_set_scanout(VirtIOGPU *g,",
          "430:                                    struct virtio_gpu_ctrl_command *cmd)",
          "431: {",
          "432:     struct virtio_gpu_simple_resource *res;",
          "433:     struct virtio_gpu_scanout *scanout;",
          "434:     pixman_format_code_t format;",
          "435:     uint32_t offset;",
          "436:     int bpp;",
          "437:     struct virtio_gpu_set_scanout ss;",
          "439:     VIRTIO_GPU_FILL_CMD(ss);",
          "440:     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,",
          "441:                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);",
          "443:     g->enable = 1;",
          "444:     if (ss.resource_id == 0) {",
          "445:         scanout = &g->scanout[ss.scanout_id];",
          "446:         if (scanout->resource_id) {",
          "447:             res = virtio_gpu_find_resource(g, scanout->resource_id);",
          "448:             if (res) {",
          "449:                 res->scanout_bitmask &= ~(1 << ss.scanout_id);",
          "450:             }",
          "451:         }",
          "452:         if (ss.scanout_id == 0 ||",
          "453:             ss.scanout_id >= g->conf.max_outputs) {",
          "454:             qemu_log_mask(LOG_GUEST_ERROR,",
          "455:                           \"%s: illegal scanout id specified %d\",",
          "456:                           __func__, ss.scanout_id);",
          "457:             cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;",
          "458:             return;",
          "459:         }",
          "460:         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);",
          "461:         scanout->ds = NULL;",
          "462:         scanout->width = 0;",
          "463:         scanout->height = 0;",
          "464:         return;",
          "465:     }",
          "468:     if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT ||",
          "469:         ss.scanout_id >= g->conf.max_outputs) {",
          "470:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",",
          "471:                       __func__, ss.scanout_id);",
          "472:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;",
          "473:         return;",
          "474:     }",
          "476:     res = virtio_gpu_find_resource(g, ss.resource_id);",
          "477:     if (!res) {",
          "478:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",",
          "479:                       __func__, ss.resource_id);",
          "480:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "481:         return;",
          "482:     }",
          "484:     if (ss.r.x > res->width ||",
          "485:         ss.r.y > res->height ||",
          "486:         ss.r.width > res->width ||",
          "487:         ss.r.height > res->height ||",
          "488:         ss.r.x + ss.r.width > res->width ||",
          "489:         ss.r.y + ss.r.height > res->height) {",
          "490:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout %d bounds for\"",
          "491:                       \" resource %d, (%d,%d)+%d,%d vs %d %d\\n\",",
          "492:                       __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,",
          "493:                       ss.r.width, ss.r.height, res->width, res->height);",
          "494:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;",
          "495:         return;",
          "496:     }",
          "498:     scanout = &g->scanout[ss.scanout_id];",
          "500:     format = pixman_image_get_format(res->image);",
          "501:     bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;",
          "502:     offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);",
          "503:     if (!scanout->ds || surface_data(scanout->ds)",
          "504:         != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||",
          "505:         scanout->width != ss.r.width ||",
          "506:         scanout->height != ss.r.height) {",
          "508:         scanout->ds = qemu_create_displaysurface_from",
          "509:             (ss.r.width, ss.r.height, format,",
          "510:              pixman_image_get_stride(res->image),",
          "511:              (uint8_t *)pixman_image_get_data(res->image) + offset);",
          "512:         if (!scanout->ds) {",
          "513:             cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;",
          "514:             return;",
          "515:         }",
          "516:         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);",
          "517:     }",
          "519:     res->scanout_bitmask |= (1 << ss.scanout_id);",
          "520:     scanout->resource_id = ss.resource_id;",
          "521:     scanout->x = ss.r.x;",
          "522:     scanout->y = ss.r.y;",
          "523:     scanout->width = ss.r.width;",
          "524:     scanout->height = ss.r.height;",
          "525: }",
          "527: int virtio_gpu_create_mapping_iov(struct virtio_gpu_resource_attach_backing *ab,",
          "528:                                   struct virtio_gpu_ctrl_command *cmd,",
          "529:                                   struct iovec **iov)",
          "530: {",
          "531:     struct virtio_gpu_mem_entry *ents;",
          "532:     size_t esize, s;",
          "533:     int i;",
          "535:     if (ab->nr_entries > 16384) {",
          "536:         qemu_log_mask(LOG_GUEST_ERROR,",
          "537:                       \"%s: nr_entries is too big (%d > 1024)\\n\",",
          "538:                       __func__, ab->nr_entries);",
          "539:         return -1;",
          "540:     }",
          "542:     esize = sizeof(*ents) * ab->nr_entries;",
          "543:     ents = g_malloc(esize);",
          "544:     s = iov_to_buf(cmd->elem.out_sg, cmd->elem.out_num,",
          "545:                    sizeof(*ab), ents, esize);",
          "546:     if (s != esize) {",
          "547:         qemu_log_mask(LOG_GUEST_ERROR,",
          "548:                       \"%s: command data size incorrect %zu vs %zu\\n\",",
          "549:                       __func__, s, esize);",
          "550:         g_free(ents);",
          "551:         return -1;",
          "552:     }",
          "555:     for (i = 0; i < ab->nr_entries; i++) {",
          "556:         hwaddr len = ents[i].length;",
          "557:         (*iov)[i].iov_len = ents[i].length;",
          "558:         (*iov)[i].iov_base = cpu_physical_memory_map(ents[i].addr, &len, 1);",
          "559:         if (!(*iov)[i].iov_base || len != ents[i].length) {",
          "560:             qemu_log_mask(LOG_GUEST_ERROR, \"%s: failed to map MMIO memory for\"",
          "561:                           \" resource %d element %d\\n\",",
          "562:                           __func__, ab->resource_id, i);",
          "563:             virtio_gpu_cleanup_mapping_iov(*iov, i);",
          "564:             g_free(ents);",
          "565:             g_free(*iov);",
          "567:             return -1;",
          "568:         }",
          "569:     }",
          "570:     g_free(ents);",
          "571:     return 0;",
          "572: }",
          "574: void virtio_gpu_cleanup_mapping_iov(struct iovec *iov, uint32_t count)",
          "575: {",
          "576:     int i;",
          "578:     for (i = 0; i < count; i++) {",
          "579:         cpu_physical_memory_unmap(iov[i].iov_base, iov[i].iov_len, 1,",
          "580:                                   iov[i].iov_len);",
          "581:     }",
          "582: }",
          "584: static void virtio_gpu_cleanup_mapping(struct virtio_gpu_simple_resource *res)",
          "585: {",
          "586:     virtio_gpu_cleanup_mapping_iov(res->iov, res->iov_cnt);",
          "587:     g_free(res->iov);",
          "588:     res->iov = NULL;",
          "589:     res->iov_cnt = 0;",
          "590: }",
          "592: static void",
          "593: virtio_gpu_resource_attach_backing(VirtIOGPU *g,",
          "594:                                    struct virtio_gpu_ctrl_command *cmd)",
          "595: {",
          "596:     struct virtio_gpu_simple_resource *res;",
          "597:     struct virtio_gpu_resource_attach_backing ab;",
          "598:     int ret;",
          "600:     VIRTIO_GPU_FILL_CMD(ab);",
          "601:     trace_virtio_gpu_cmd_res_back_attach(ab.resource_id);",
          "603:     res = virtio_gpu_find_resource(g, ab.resource_id);",
          "604:     if (!res) {",
          "605:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",",
          "606:                       __func__, ab.resource_id);",
          "607:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "608:         return;",
          "609:     }",
          "611:     ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->iov);",
          "612:     if (ret != 0) {",
          "613:         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;",
          "614:         return;",
          "615:     }",
          "617:     res->iov_cnt = ab.nr_entries;",
          "618: }",
          "620: static void",
          "621: virtio_gpu_resource_detach_backing(VirtIOGPU *g,",
          "622:                                    struct virtio_gpu_ctrl_command *cmd)",
          "623: {",
          "624:     struct virtio_gpu_simple_resource *res;",
          "625:     struct virtio_gpu_resource_detach_backing detach;",
          "627:     VIRTIO_GPU_FILL_CMD(detach);",
          "628:     trace_virtio_gpu_cmd_res_back_detach(detach.resource_id);",
          "630:     res = virtio_gpu_find_resource(g, detach.resource_id);",
          "631:     if (!res || !res->iov) {",
          "632:         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",",
          "633:                       __func__, detach.resource_id);",
          "634:         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;",
          "635:         return;",
          "636:     }",
          "637:     virtio_gpu_cleanup_mapping(res);",
          "638: }",
          "640: static void virtio_gpu_simple_process_cmd(VirtIOGPU *g,",
          "641:                                           struct virtio_gpu_ctrl_command *cmd)",
          "642: {",
          "643:     VIRTIO_GPU_FILL_CMD(cmd->cmd_hdr);",
          "645:     switch (cmd->cmd_hdr.type) {",
          "646:     case VIRTIO_GPU_CMD_GET_DISPLAY_INFO:",
          "647:         virtio_gpu_get_display_info(g, cmd);",
          "648:         break;",
          "649:     case VIRTIO_GPU_CMD_RESOURCE_CREATE_2D:",
          "650:         virtio_gpu_resource_create_2d(g, cmd);",
          "651:         break;",
          "652:     case VIRTIO_GPU_CMD_RESOURCE_UNREF:",
          "653:         virtio_gpu_resource_unref(g, cmd);",
          "654:         break;",
          "655:     case VIRTIO_GPU_CMD_RESOURCE_FLUSH:",
          "656:         virtio_gpu_resource_flush(g, cmd);",
          "657:         break;",
          "658:     case VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D:",
          "659:         virtio_gpu_transfer_to_host_2d(g, cmd);",
          "660:         break;",
          "661:     case VIRTIO_GPU_CMD_SET_SCANOUT:",
          "662:         virtio_gpu_set_scanout(g, cmd);",
          "663:         break;",
          "664:     case VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING:",
          "665:         virtio_gpu_resource_attach_backing(g, cmd);",
          "666:         break;",
          "667:     case VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING:",
          "668:         virtio_gpu_resource_detach_backing(g, cmd);",
          "669:         break;",
          "670:     default:",
          "671:         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;",
          "672:         break;",
          "673:     }",
          "674:     if (!cmd->finished) {",
          "675:         virtio_gpu_ctrl_response_nodata(g, cmd, cmd->error ? cmd->error :",
          "676:                                         VIRTIO_GPU_RESP_OK_NODATA);",
          "677:     }",
          "678: }",
          "680: static void virtio_gpu_handle_ctrl_cb(VirtIODevice *vdev, VirtQueue *vq)",
          "681: {",
          "682:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "683:     qemu_bh_schedule(g->ctrl_bh);",
          "684: }",
          "686: static void virtio_gpu_handle_cursor_cb(VirtIODevice *vdev, VirtQueue *vq)",
          "687: {",
          "688:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "689:     qemu_bh_schedule(g->cursor_bh);",
          "690: }",
          "692: static void virtio_gpu_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)",
          "693: {",
          "694:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "695:     struct virtio_gpu_ctrl_command *cmd;",
          "697:     if (!virtio_queue_ready(vq)) {",
          "698:         return;",
          "699:     }",
          "701:     cmd = g_new(struct virtio_gpu_ctrl_command, 1);",
          "702:     while (virtqueue_pop(vq, &cmd->elem)) {",
          "703:         cmd->vq = vq;",
          "704:         cmd->error = 0;",
          "705:         cmd->finished = false;",
          "706:         g->stats.requests++;",
          "708:         virtio_gpu_simple_process_cmd(g, cmd);",
          "709:         if (!cmd->finished) {",
          "710:             QTAILQ_INSERT_TAIL(&g->fenceq, cmd, next);",
          "711:             g->stats.inflight++;",
          "712:             if (g->stats.max_inflight < g->stats.inflight) {",
          "713:                 g->stats.max_inflight = g->stats.inflight;",
          "714:             }",
          "715:             fprintf(stderr, \"inflight: %3d (+)\\r\", g->stats.inflight);",
          "716:             cmd = g_new(struct virtio_gpu_ctrl_command, 1);",
          "717:         }",
          "718:     }",
          "719:     g_free(cmd);",
          "720: }",
          "722: static void virtio_gpu_ctrl_bh(void *opaque)",
          "723: {",
          "724:     VirtIOGPU *g = opaque;",
          "725:     virtio_gpu_handle_ctrl(&g->parent_obj, g->ctrl_vq);",
          "726: }",
          "728: static void virtio_gpu_handle_cursor(VirtIODevice *vdev, VirtQueue *vq)",
          "729: {",
          "730:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "731:     VirtQueueElement elem;",
          "732:     size_t s;",
          "733:     struct virtio_gpu_update_cursor cursor_info;",
          "735:     if (!virtio_queue_ready(vq)) {",
          "736:         return;",
          "737:     }",
          "738:     while (virtqueue_pop(vq, &elem)) {",
          "739:         s = iov_to_buf(elem.out_sg, elem.out_num, 0,",
          "740:                        &cursor_info, sizeof(cursor_info));",
          "741:         if (s != sizeof(cursor_info)) {",
          "742:             qemu_log_mask(LOG_GUEST_ERROR,",
          "743:                           \"%s: cursor size incorrect %zu vs %zu\\n\",",
          "744:                           __func__, s, sizeof(cursor_info));",
          "745:         } else {",
          "746:             update_cursor(g, &cursor_info);",
          "747:         }",
          "748:         virtqueue_push(vq, &elem, 0);",
          "749:         virtio_notify(vdev, vq);",
          "750:     }",
          "751: }",
          "753: static void virtio_gpu_cursor_bh(void *opaque)",
          "754: {",
          "755:     VirtIOGPU *g = opaque;",
          "756:     virtio_gpu_handle_cursor(&g->parent_obj, g->cursor_vq);",
          "757: }",
          "759: static void virtio_gpu_invalidate_display(void *opaque)",
          "760: {",
          "761: }",
          "763: static void virtio_gpu_update_display(void *opaque)",
          "764: {",
          "765: }",
          "767: static void virtio_gpu_text_update(void *opaque, console_ch_t *chardata)",
          "768: {",
          "769: }",
          "771: static int virtio_gpu_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)",
          "772: {",
          "773:     VirtIOGPU *g = opaque;",
          "775:     if (idx > g->conf.max_outputs) {",
          "776:         return -1;",
          "777:     }",
          "779:     g->req_state[idx].x = info->xoff;",
          "780:     g->req_state[idx].y = info->yoff;",
          "781:     g->req_state[idx].width = info->width;",
          "782:     g->req_state[idx].height = info->height;",
          "784:     if (info->width && info->height) {",
          "785:         g->enabled_output_bitmask |= (1 << idx);",
          "786:     } else {",
          "787:         g->enabled_output_bitmask &= ~(1 << idx);",
          "788:     }",
          "791:     virtio_gpu_notify_event(g, VIRTIO_GPU_EVENT_DISPLAY);",
          "792:     return 0;",
          "793: }",
          "795: const GraphicHwOps virtio_gpu_ops = {",
          "796:     .invalidate = virtio_gpu_invalidate_display,",
          "797:     .gfx_update = virtio_gpu_update_display,",
          "798:     .text_update = virtio_gpu_text_update,",
          "799:     .ui_info = virtio_gpu_ui_info,",
          "800: };",
          "802: static void virtio_gpu_device_realize(DeviceState *qdev, Error **errp)",
          "803: {",
          "804:     VirtIODevice *vdev = VIRTIO_DEVICE(qdev);",
          "805:     VirtIOGPU *g = VIRTIO_GPU(qdev);",
          "806:     int i;",
          "808:     g->config_size = sizeof(struct virtio_gpu_config);",
          "809:     g->virtio_config.num_scanouts = g->conf.max_outputs;",
          "810:     virtio_init(VIRTIO_DEVICE(g), \"virtio-gpu\", VIRTIO_ID_GPU,",
          "811:                 g->config_size);",
          "813:     g->req_state[0].width = 1024;",
          "814:     g->req_state[0].height = 768;",
          "816:     g->ctrl_vq   = virtio_add_queue(vdev, 64, virtio_gpu_handle_ctrl_cb);",
          "817:     g->cursor_vq = virtio_add_queue(vdev, 16, virtio_gpu_handle_cursor_cb);",
          "819:     g->ctrl_bh = qemu_bh_new(virtio_gpu_ctrl_bh, g);",
          "820:     g->cursor_bh = qemu_bh_new(virtio_gpu_cursor_bh, g);",
          "821:     QTAILQ_INIT(&g->reslist);",
          "822:     QTAILQ_INIT(&g->fenceq);",
          "824:     g->enabled_output_bitmask = 1;",
          "825:     g->qdev = qdev;",
          "827:     for (i = 0; i < g->conf.max_outputs; i++) {",
          "828:         g->scanout[i].con =",
          "829:             graphic_console_init(DEVICE(g), i, &virtio_gpu_ops, g);",
          "830:         if (i > 0) {",
          "831:             dpy_gfx_replace_surface(g->scanout[i].con, NULL);",
          "832:         }",
          "833:     }",
          "834: }",
          "836: static void virtio_gpu_instance_init(Object *obj)",
          "837: {",
          "838: }",
          "840: static void virtio_gpu_reset(VirtIODevice *vdev)",
          "841: {",
          "842:     VirtIOGPU *g = VIRTIO_GPU(vdev);",
          "843:     struct virtio_gpu_simple_resource *res, *tmp;",
          "844:     int i;",
          "846:     g->enable = 0;",
          "848:     QTAILQ_FOREACH_SAFE(res, &g->reslist, next, tmp) {",
          "849:         virtio_gpu_resource_destroy(g, res);",
          "850:     }",
          "851:     for (i = 0; i < g->conf.max_outputs; i++) {",
          "852: #if 0",
          "853:         g->req_state[i].x = 0;",
          "854:         g->req_state[i].y = 0;",
          "855:         if (i == 0) {",
          "856:             g->req_state[0].width = 1024;",
          "857:             g->req_state[0].height = 768;",
          "858:         } else {",
          "859:             g->req_state[i].width = 0;",
          "860:             g->req_state[i].height = 0;",
          "861:         }",
          "862: #endif",
          "863:         g->scanout[i].resource_id = 0;",
          "864:         g->scanout[i].width = 0;",
          "865:         g->scanout[i].height = 0;",
          "866:         g->scanout[i].x = 0;",
          "867:         g->scanout[i].y = 0;",
          "868:         g->scanout[i].ds = NULL;",
          "869:     }",
          "870:     g->enabled_output_bitmask = 1;",
          "871: }",
          "873: static Property virtio_gpu_properties[] = {",
          "874:     DEFINE_VIRTIO_GPU_PROPERTIES(VirtIOGPU, conf),",
          "875:     DEFINE_PROP_END_OF_LIST(),",
          "876: };",
          "878: static void virtio_gpu_class_init(ObjectClass *klass, void *data)",
          "879: {",
          "880:     DeviceClass *dc = DEVICE_CLASS(klass);",
          "881:     VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);",
          "883:     vdc->realize = virtio_gpu_device_realize;",
          "884:     vdc->get_config = virtio_gpu_get_config;",
          "885:     vdc->set_config = virtio_gpu_set_config;",
          "886:     vdc->get_features = virtio_gpu_get_features;",
          "888:     vdc->reset = virtio_gpu_reset;",
          "890:     dc->props = virtio_gpu_properties;",
          "891: }",
          "893: static const TypeInfo virtio_gpu_info = {",
          "894:     .name = TYPE_VIRTIO_GPU,",
          "895:     .parent = TYPE_VIRTIO_DEVICE,",
          "896:     .instance_size = sizeof(VirtIOGPU),",
          "897:     .instance_init = virtio_gpu_instance_init,",
          "898:     .class_init = virtio_gpu_class_init,",
          "899: };",
          "901: static void virtio_register_types(void)",
          "902: {",
          "903:     type_register_static(&virtio_gpu_info);",
          "904: }",
          "906: type_init(virtio_register_types)",
          "908: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_ctrl_hdr)                != 24);",
          "909: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_update_cursor)           != 56);",
          "910: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_unref)          != 32);",
          "911: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_create_2d)      != 40);",
          "912: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_set_scanout)             != 48);",
          "913: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_flush)          != 48);",
          "914: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_transfer_to_host_2d)     != 56);",
          "915: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_mem_entry)               != 16);",
          "916: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_attach_backing) != 32);",
          "917: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resource_detach_backing) != 32);",
          "918: QEMU_BUILD_BUG_ON(sizeof(struct virtio_gpu_resp_display_info)       != 408);",
          "",
          "---------------"
        ],
        "include/hw/virtio/virtio-gpu.h||include/hw/virtio/virtio-gpu.h": [
          "File: include/hw/virtio/virtio-gpu.h -> include/hw/virtio/virtio-gpu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #ifndef _QEMU_VIRTIO_VGA_H",
          "15: #define _QEMU_VIRTIO_VGA_H",
          "17: #include \"qemu/queue.h\"",
          "18: #include \"ui/qemu-pixman.h\"",
          "19: #include \"ui/console.h\"",
          "20: #include \"hw/virtio/virtio.h\"",
          "21: #include \"hw/pci/pci.h\"",
          "23: #include \"standard-headers/linux/virtio_gpu.h\"",
          "24: #define TYPE_VIRTIO_GPU \"virtio-gpu-device\"",
          "25: #define VIRTIO_GPU(obj)                                        \\",
          "26:         OBJECT_CHECK(VirtIOGPU, (obj), TYPE_VIRTIO_GPU)",
          "28: #define VIRTIO_ID_GPU 16",
          "30: #define VIRTIO_GPU_MAX_SCANOUT 4",
          "32: struct virtio_gpu_simple_resource {",
          "33:     uint32_t resource_id;",
          "34:     uint32_t width;",
          "35:     uint32_t height;",
          "36:     uint32_t format;",
          "37:     struct iovec *iov;",
          "38:     unsigned int iov_cnt;",
          "39:     uint32_t scanout_bitmask;",
          "40:     pixman_image_t *image;",
          "41:     QTAILQ_ENTRY(virtio_gpu_simple_resource) next;",
          "42: };",
          "44: struct virtio_gpu_scanout {",
          "45:     QemuConsole *con;",
          "46:     DisplaySurface *ds;",
          "47:     uint32_t width, height;",
          "48:     int x, y;",
          "49:     int invalidate;",
          "50:     uint32_t resource_id;",
          "51:     QEMUCursor *current_cursor;",
          "52: };",
          "54: struct virtio_gpu_requested_state {",
          "55:     uint32_t width, height;",
          "56:     int x, y;",
          "57: };",
          "59: struct virtio_gpu_conf {",
          "60:     uint32_t max_outputs;",
          "61: };",
          "63: struct virtio_gpu_ctrl_command {",
          "64:     VirtQueueElement elem;",
          "65:     VirtQueue *vq;",
          "66:     struct virtio_gpu_ctrl_hdr cmd_hdr;",
          "67:     uint32_t error;",
          "68:     bool finished;",
          "69:     QTAILQ_ENTRY(virtio_gpu_ctrl_command) next;",
          "70: };",
          "72: typedef struct VirtIOGPU {",
          "73:     VirtIODevice parent_obj;",
          "75:     QEMUBH *ctrl_bh;",
          "76:     QEMUBH *cursor_bh;",
          "77:     VirtQueue *ctrl_vq;",
          "78:     VirtQueue *cursor_vq;",
          "80:     int enable;",
          "82:     int config_size;",
          "83:     DeviceState *qdev;",
          "85:     QTAILQ_HEAD(, virtio_gpu_simple_resource) reslist;",
          "86:     QTAILQ_HEAD(, virtio_gpu_ctrl_command) fenceq;",
          "88:     struct virtio_gpu_scanout scanout[VIRTIO_GPU_MAX_SCANOUT];",
          "89:     struct virtio_gpu_requested_state req_state[VIRTIO_GPU_MAX_SCANOUT];",
          "91:     struct virtio_gpu_conf conf;",
          "92:     int enabled_output_bitmask;",
          "93:     struct virtio_gpu_config virtio_config;",
          "95:     QEMUTimer *fence_poll;",
          "96:     QEMUTimer *print_stats;",
          "98:     struct {",
          "99:         uint32_t inflight;",
          "100:         uint32_t max_inflight;",
          "101:         uint32_t requests;",
          "102:         uint32_t req_3d;",
          "103:         uint32_t bytes_3d;",
          "104:     } stats;",
          "105: } VirtIOGPU;",
          "107: extern const GraphicHwOps virtio_gpu_ops;",
          "110: #define DEFINE_VIRTIO_GPU_PCI_PROPERTIES(_state)               \\",
          "111:     DEFINE_PROP_BIT(\"ioeventfd\", _state, flags,                \\",
          "112:                     VIRTIO_PCI_FLAG_USE_IOEVENTFD_BIT, false), \\",
          "113:     DEFINE_PROP_UINT32(\"vectors\", _state, nvectors, 3)",
          "115: #define DEFINE_VIRTIO_GPU_PROPERTIES(_state, _conf_field)               \\",
          "116:     DEFINE_PROP_UINT32(\"max_outputs\", _state, _conf_field.max_outputs, 1)",
          "118: #define VIRTIO_GPU_FILL_CMD(out) do {                                   \\",
          "119:         size_t s;                                                       \\",
          "120:         s = iov_to_buf(cmd->elem.out_sg, cmd->elem.out_num, 0,          \\",
          "121:                        &out, sizeof(out));                              \\",
          "122:         if (s != sizeof(out)) {                                         \\",
          "123:             qemu_log_mask(LOG_GUEST_ERROR,                              \\",
          "124:                           \"%s: command size incorrect %zu vs %zu\\n\",    \\",
          "125:                           __func__, s, sizeof(out));                    \\",
          "126:             return;                                                     \\",
          "127:         }                                                               \\",
          "128:     } while (0)",
          "131: void virtio_gpu_ctrl_response(VirtIOGPU *g,",
          "132:                               struct virtio_gpu_ctrl_command *cmd,",
          "133:                               struct virtio_gpu_ctrl_hdr *resp,",
          "134:                               size_t resp_len);",
          "135: void virtio_gpu_ctrl_response_nodata(VirtIOGPU *g,",
          "136:                                      struct virtio_gpu_ctrl_command *cmd,",
          "137:                                      enum virtio_gpu_ctrl_type type);",
          "138: void virtio_gpu_get_display_info(VirtIOGPU *g,",
          "139:                                  struct virtio_gpu_ctrl_command *cmd);",
          "140: int virtio_gpu_create_mapping_iov(struct virtio_gpu_resource_attach_backing *ab,",
          "141:                                   struct virtio_gpu_ctrl_command *cmd,",
          "142:                                   struct iovec **iov);",
          "143: void virtio_gpu_cleanup_mapping_iov(struct iovec *iov, uint32_t count);",
          "145: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
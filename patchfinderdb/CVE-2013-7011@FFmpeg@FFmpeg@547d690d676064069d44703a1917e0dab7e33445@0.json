{
  "cve_id": "CVE-2013-7011",
  "cve_desc": "The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not prevent changes to global parameters, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "547d690d676064069d44703a1917e0dab7e33445",
  "patch_info": {
    "commit_hash": "547d690d676064069d44703a1917e0dab7e33445",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/547d690d676064069d44703a1917e0dab7e33445",
    "files": [
      "libavcodec/ffv1dec.c"
    ],
    "message": "ffv1dec: check that global parameters dont change in version 0/1\n\nSuch changes are not allowed nor supported\n\nFixes Ticket2906\n\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
      "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "580:     memset(state, 128, sizeof(state));",
      "582:     if (f->version < 2) {",
      "583:         unsigned v= get_symbol(c, state, 0);",
      "584:         if (v >= 2) {",
      "585:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "583:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "597:         if (f->version > 0)",
      "598:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
      "604:         f->plane_count    = 2 + f->transparency;",
      "605:     }",
      "",
      "[Removed Lines]",
      "600:         f->chroma_planes  = get_rac(c, state);",
      "601:         f->chroma_h_shift = get_symbol(c, state, 0);",
      "602:         f->chroma_v_shift = get_symbol(c, state, 0);",
      "603:         f->transparency   = get_rac(c, state);",
      "",
      "[Added Lines]",
      "601:         chroma_planes  = get_rac(c, state);",
      "602:         chroma_h_shift = get_symbol(c, state, 0);",
      "603:         chroma_v_shift = get_symbol(c, state, 0);",
      "604:         transparency   = get_rac(c, state);",
      "606:         if (f->plane_count) {",
      "607:             if (   chroma_planes != f->chroma_planes",
      "608:                 || chroma_h_shift!= f->chroma_h_shift",
      "609:                 || chroma_v_shift!= f->chroma_v_shift",
      "610:                 || transparency  != f->transparency) {",
      "611:                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");",
      "612:                 return AVERROR_INVALIDDATA;",
      "613:             }",
      "614:         }",
      "616:         f->chroma_planes  = chroma_planes;",
      "617:         f->chroma_h_shift = chroma_h_shift;",
      "618:         f->chroma_v_shift = chroma_v_shift;",
      "619:         f->transparency   = transparency;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "df2fc635439df6d5ab84d50ae96acb0da07f941e",
      "candidate_info": {
        "commit_hash": "df2fc635439df6d5ab84d50ae96acb0da07f941e",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/df2fc635439df6d5ab84d50ae96acb0da07f941e",
        "files": [
          "libavcodec/ffv1dec.c"
        ],
        "message": "ffv1dec: check that global parameters dont change in version 0/1\n\nSuch changes are not allowed nor supported\n\nFixes Ticket2906\n\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 547d690d676064069d44703a1917e0dab7e33445)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "528:     memset(state, 128, sizeof(state));",
          "530:     if (f->version < 2) {",
          "531:         unsigned v= get_symbol(c, state, 0);",
          "532:         if (v >= 2) {",
          "533:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "531:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "545:         if (f->version > 0)",
          "546:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "552:         f->plane_count    = 2 + f->transparency;",
          "553:     }",
          "",
          "[Removed Lines]",
          "548:         f->chroma_planes  = get_rac(c, state);",
          "549:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "550:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "551:         f->transparency   = get_rac(c, state);",
          "",
          "[Added Lines]",
          "549:         chroma_planes  = get_rac(c, state);",
          "550:         chroma_h_shift = get_symbol(c, state, 0);",
          "551:         chroma_v_shift = get_symbol(c, state, 0);",
          "552:         transparency   = get_rac(c, state);",
          "554:         if (f->plane_count) {",
          "555:             if (   chroma_planes != f->chroma_planes",
          "556:                 || chroma_h_shift!= f->chroma_h_shift",
          "557:                 || chroma_v_shift!= f->chroma_v_shift",
          "558:                 || transparency  != f->transparency) {",
          "559:                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");",
          "560:                 return AVERROR_INVALIDDATA;",
          "561:             }",
          "562:         }",
          "564:         f->chroma_planes  = chroma_planes;",
          "565:         f->chroma_h_shift = chroma_h_shift;",
          "566:         f->chroma_v_shift = chroma_v_shift;",
          "567:         f->transparency   = transparency;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c7ee4bc016e56abb69fa728e124294e786fb7c01",
      "candidate_info": {
        "commit_hash": "c7ee4bc016e56abb69fa728e124294e786fb7c01",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c7ee4bc016e56abb69fa728e124294e786fb7c01",
        "files": [
          "libavcodec/ffv1dec.c"
        ],
        "message": "ffv1dec: check that global parameters dont change in version 0/1\n\nSuch changes are not allowed nor supported\n\nFixes Ticket2906\n\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 547d690d676064069d44703a1917e0dab7e33445)",
        "before_after_code_files": [
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "562:     memset(state, 128, sizeof(state));",
          "564:     if (f->version < 2) {",
          "565:         unsigned v= get_symbol(c, state, 0);",
          "566:         if (v >= 2) {",
          "567:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "565:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "579:         if (f->version > 0)",
          "580:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "586:         f->plane_count    = 2 + f->transparency;",
          "587:     }",
          "",
          "[Removed Lines]",
          "582:         f->chroma_planes  = get_rac(c, state);",
          "583:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "584:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "585:         f->transparency   = get_rac(c, state);",
          "",
          "[Added Lines]",
          "583:         chroma_planes  = get_rac(c, state);",
          "584:         chroma_h_shift = get_symbol(c, state, 0);",
          "585:         chroma_v_shift = get_symbol(c, state, 0);",
          "586:         transparency   = get_rac(c, state);",
          "588:         if (f->plane_count) {",
          "589:             if (   chroma_planes != f->chroma_planes",
          "590:                 || chroma_h_shift!= f->chroma_h_shift",
          "591:                 || chroma_v_shift!= f->chroma_v_shift",
          "592:                 || transparency  != f->transparency) {",
          "593:                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");",
          "594:                 return AVERROR_INVALIDDATA;",
          "595:             }",
          "596:         }",
          "598:         f->chroma_planes  = chroma_planes;",
          "599:         f->chroma_h_shift = chroma_h_shift;",
          "600:         f->chroma_v_shift = chroma_v_shift;",
          "601:         f->transparency   = transparency;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bb4126e250e0a2d8505d135cd81d8c98b48dd4fc",
      "candidate_info": {
        "commit_hash": "bb4126e250e0a2d8505d135cd81d8c98b48dd4fc",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/bb4126e250e0a2d8505d135cd81d8c98b48dd4fc",
        "files": [
          "libavcodec/ffv1dec.c"
        ],
        "message": "ffv1dec: check that global parameters dont change in version 0/1\n\nSuch changes are not allowed nor supported\n\nFixes Ticket2906\n\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 547d690d676064069d44703a1917e0dab7e33445)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "527:     memset(state, 128, sizeof(state));",
          "529:     if (f->version < 2) {",
          "530:         unsigned v= get_symbol(c, state, 0);",
          "531:         if (v >= 2) {",
          "532:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "530:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "544:         if (f->version > 0)",
          "545:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "551:         f->plane_count    = 2 + f->transparency;",
          "552:     }",
          "",
          "[Removed Lines]",
          "547:         f->chroma_planes  = get_rac(c, state);",
          "548:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "549:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "550:         f->transparency   = get_rac(c, state);",
          "",
          "[Added Lines]",
          "548:         chroma_planes  = get_rac(c, state);",
          "549:         chroma_h_shift = get_symbol(c, state, 0);",
          "550:         chroma_v_shift = get_symbol(c, state, 0);",
          "551:         transparency   = get_rac(c, state);",
          "553:         if (f->plane_count) {",
          "554:             if (   chroma_planes != f->chroma_planes",
          "555:                 || chroma_h_shift!= f->chroma_h_shift",
          "556:                 || chroma_v_shift!= f->chroma_v_shift",
          "557:                 || transparency  != f->transparency) {",
          "558:                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");",
          "559:                 return AVERROR_INVALIDDATA;",
          "560:             }",
          "561:         }",
          "563:         f->chroma_planes  = chroma_planes;",
          "564:         f->chroma_h_shift = chroma_h_shift;",
          "565:         f->chroma_v_shift = chroma_v_shift;",
          "566:         f->transparency   = transparency;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0f13cd3187192ba0cc2b043430de6e279e7b97c3",
      "candidate_info": {
        "commit_hash": "0f13cd3187192ba0cc2b043430de6e279e7b97c3",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/0f13cd3187192ba0cc2b043430de6e279e7b97c3",
        "files": [
          "libavcodec/ffv1.c",
          "libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c"
        ],
        "message": "ffv1: update to ffv1 version 3\n\nBased on code from Carl Eugen Hoyos, Michael Niedermayer and Paul B Mahol.",
        "before_after_code_files": [
          "libavcodec/ffv1.c||libavcodec/ffv1.c",
          "libavcodec/ffv1.h||libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1.c||libavcodec/ffv1.c": [
          "File: libavcodec/ffv1.c -> libavcodec/ffv1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:     s->avctx = avctx;",
          "139:     s->flags = avctx->flags;",
          "141:     ff_dsputil_init(&s->dsp, avctx);",
          "143:     s->width  = avctx->width;",
          "144:     s->height = avctx->height;",
          "148:     s->num_h_slices = 1;",
          "149:     s->num_v_slices = 1;",
          "",
          "[Removed Lines]",
          "146:     assert(s->width && s->height);",
          "",
          "[Added Lines]",
          "141:     if (!avctx->width || !avctx->height)",
          "142:         return AVERROR_INVALIDDATA;",
          "144:     avcodec_get_frame_defaults(&s->picture);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:     return 0;",
          "152: }",
          "155: {",
          "175:         }",
          "183:         }",
          "184:     }",
          "",
          "[Removed Lines]",
          "154: int ffv1_init_slice_state(FFV1Context *f)",
          "156:     int i, j;",
          "158:     for (i = 0; i < f->slice_count; i++) {",
          "159:         FFV1Context *fs = f->slice_context[i];",
          "160:         for (j = 0; j < f->plane_count; j++) {",
          "161:             PlaneContext *const p = &fs->plane[j];",
          "163:             if (fs->ac) {",
          "164:                 if (!p->state)",
          "165:                     p->state = av_malloc(CONTEXT_SIZE * p->context_count *",
          "166:                                          sizeof(uint8_t));",
          "167:                 if (!p->state)",
          "168:                     return AVERROR(ENOMEM);",
          "169:             } else {",
          "170:                 if (!p->vlc_state)",
          "171:                     p->vlc_state = av_malloc(p->context_count * sizeof(VlcState));",
          "172:                 if (!p->vlc_state)",
          "173:                     return AVERROR(ENOMEM);",
          "174:             }",
          "177:         if (fs->ac > 1) {",
          "179:             for (j = 1; j < 256; j++) {",
          "180:                 fs->c.one_state[j]        = fs->state_transition[j];",
          "181:                 fs->c.zero_state[256 - j] = 256 - fs->c.one_state[j];",
          "182:             }",
          "",
          "[Added Lines]",
          "158: int ffv1_init_slice_state(FFV1Context *f, FFV1Context *fs)",
          "160:     int j;",
          "162:     fs->plane_count  = f->plane_count;",
          "163:     fs->transparency = f->transparency;",
          "164:     for (j = 0; j < f->plane_count; j++) {",
          "165:         PlaneContext *const p = &fs->plane[j];",
          "167:         if (fs->ac) {",
          "168:             if (!p->state)",
          "169:                 p->state = av_malloc(CONTEXT_SIZE * p->context_count *",
          "170:                                      sizeof(uint8_t));",
          "171:             if (!p->state)",
          "172:                 return AVERROR(ENOMEM);",
          "173:         } else {",
          "174:             if (!p->vlc_state)",
          "175:                 p->vlc_state = av_malloc(p->context_count * sizeof(VlcState));",
          "176:             if (!p->vlc_state)",
          "177:                 return AVERROR(ENOMEM);",
          "179:     }",
          "181:     if (fs->ac > 1) {",
          "183:         for (j = 1; j < 256; j++) {",
          "184:             fs->c.one_state[j]        = f->state_transition[j];",
          "185:             fs->c.zero_state[256 - j] = 256 - fs->c.one_state[j];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "209:         fs->slice_x      = sxs;",
          "210:         fs->slice_y      = sys;",
          "213:                                       sizeof(*fs->sample_buffer));",
          "214:         if (!fs->sample_buffer)",
          "215:             return AVERROR(ENOMEM);",
          "",
          "[Removed Lines]",
          "212:         fs->sample_buffer = av_malloc(9 * (fs->width + 6) *",
          "",
          "[Added Lines]",
          "215:         fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "232:     return 0;",
          "233: }",
          "236: {",
          "260:             }",
          "261:         }",
          "262:     }",
          "",
          "[Removed Lines]",
          "235: void ffv1_clear_state(FFV1Context *f)",
          "237:     int i, si, j;",
          "239:     for (si = 0; si < f->slice_count; si++) {",
          "240:         FFV1Context *fs = f->slice_context[si];",
          "241:         for (i = 0; i < f->plane_count; i++) {",
          "242:             PlaneContext *p = &fs->plane[i];",
          "244:             p->interlace_bit_state[0] = 128;",
          "245:             p->interlace_bit_state[1] = 128;",
          "247:             if (fs->ac) {",
          "248:                 if (f->initial_states[p->quant_table_index]) {",
          "249:                     memcpy(p->state, f->initial_states[p->quant_table_index],",
          "250:                            CONTEXT_SIZE * p->context_count);",
          "251:                 } else",
          "252:                     memset(p->state, 128, CONTEXT_SIZE * p->context_count);",
          "253:             } else {",
          "254:                 for (j = 0; j < p->context_count; j++) {",
          "255:                     p->vlc_state[j].drift     = 0;",
          "256:                     p->vlc_state[j].error_sum = 4; // FFMAX((RANGE + 32)/64, 2);",
          "257:                     p->vlc_state[j].bias      = 0;",
          "258:                     p->vlc_state[j].count     = 1;",
          "259:                 }",
          "",
          "[Added Lines]",
          "238: void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs)",
          "240:     int i, j;",
          "242:     for (i = 0; i < f->plane_count; i++) {",
          "243:         PlaneContext *p = &fs->plane[i];",
          "245:         p->interlace_bit_state[0] = 128;",
          "246:         p->interlace_bit_state[1] = 128;",
          "248:         if (fs->ac) {",
          "249:             if (f->initial_states[p->quant_table_index]) {",
          "250:                 memcpy(p->state, f->initial_states[p->quant_table_index],",
          "251:                        CONTEXT_SIZE * p->context_count);",
          "252:             } else",
          "253:                 memset(p->state, 128, CONTEXT_SIZE * p->context_count);",
          "254:         } else {",
          "255:             for (j = 0; j < p->context_count; j++) {",
          "256:                 p->vlc_state[j].drift     = 0;",
          "257:                 p->vlc_state[j].error_sum = 4;    //FFMAX((RANGE + 32)/64, 2);",
          "258:                 p->vlc_state[j].bias      = 0;",
          "259:                 p->vlc_state[j].count     = 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "270:     if (avctx->codec->decode && s->picture.data[0])",
          "271:         avctx->release_buffer(avctx, &s->picture);",
          "273:     for (j = 0; j < s->slice_count; j++) {",
          "274:         FFV1Context *fs = s->slice_context[j];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:     if (avctx->codec->decode && s->last_picture.data[0])",
          "273:         avctx->release_buffer(avctx, &s->last_picture);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1.h||libavcodec/ffv1.h": [
          "File: libavcodec/ffv1.h -> libavcodec/ffv1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #define MAX_SLICES 256",
          "59: typedef struct FFV1Context {",
          "60:     AVCodecContext *avctx;",
          "61:     RangeCoder c;",
          "62:     GetBitContext gb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60:     AVClass *class;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:     uint64_t rc_stat[256][2];",
          "65:     uint64_t (*rc_stat2[MAX_QUANT_TABLES])[32][2];",
          "66:     int version;",
          "67:     int width, height;",
          "68:     int chroma_h_shift, chroma_v_shift;",
          "69:     int flags;",
          "70:     int picture_number;",
          "72:     int plane_count;",
          "73:     int ac;     // 1 = range coder <-> 0 = golomb rice",
          "74:     PlaneContext plane[MAX_PLANES];",
          "75:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "76:     int16_t quant_tables[MAX_QUANT_TABLES][MAX_CONTEXT_INPUTS][256];",
          "",
          "[Removed Lines]",
          "71:     AVFrame picture;",
          "",
          "[Added Lines]",
          "68:     int minor_version;",
          "70:     int chroma_planes;",
          "72:     int transparency;",
          "75:     AVFrame picture, last_picture;",
          "78:     int ac_byte_count;      // number of bytes used for AC coding",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:     int run_index;",
          "81:     int colorspace;",
          "82:     int16_t *sample_buffer;",
          "85:     int quant_table_count;",
          "87:     DSPContext dsp;",
          "",
          "[Removed Lines]",
          "83:     int gob_count;",
          "",
          "[Added Lines]",
          "89:     int ec;",
          "90:     int slice_damaged;",
          "91:     int key_frame_ok;",
          "93:     int bits_per_raw_sample;",
          "94:     int packed_at_lsb;",
          "96:     int gob_count;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "175: }",
          "177: int ffv1_common_init(AVCodecContext *avctx);",
          "179: int ffv1_init_slice_contexts(FFV1Context *f);",
          "180: int ffv1_allocate_initial_states(FFV1Context *f);",
          "182: int ffv1_close(AVCodecContext *avctx);",
          "",
          "[Removed Lines]",
          "178: int ffv1_init_slice_state(FFV1Context *f);",
          "181: void ffv1_clear_state(FFV1Context *f);",
          "",
          "[Added Lines]",
          "190: int ffv1_init_slice_state(FFV1Context *f, FFV1Context *fs);",
          "193: void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"avcodec.h\"",
          "30: #include \"get_bits.h\"",
          "31: #include \"put_bits.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"libavutil/pixdesc.h\"",
          "30: #include \"libavutil/crc.h\"",
          "31: #include \"libavutil/opt.h\"",
          "32: #include \"libavutil/imgutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:         } else {",
          "193:             decode_line(s, w, sample, plane_index,",
          "194:                         s->avctx->bits_per_raw_sample);",
          "198:         }",
          "200:     }",
          "201: }",
          "205: {",
          "206:     int x, y, p;",
          "209:         sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;",
          "210:         sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;",
          "211:     }",
          "213:     s->run_index = 0;",
          "217:     for (y = 0; y < h; y++) {",
          "221:             sample[p][0] = sample[p][1];",
          "222:             sample[p][1] = temp;",
          "224:             sample[p][1][-1] = sample[p][0][0];",
          "225:             sample[p][0][w]  = sample[p][0][w - 1];",
          "227:         }",
          "228:         for (x = 0; x < w; x++) {",
          "229:             int g = sample[0][1][x];",
          "230:             int b = sample[1][1][x];",
          "231:             int r = sample[2][1][x];",
          "238:             g -= (b + r) >> 2;",
          "239:             b += g;",
          "240:             r += g;",
          "243:         }",
          "244:     }",
          "245: }",
          "247: static int decode_slice(AVCodecContext *c, void *arg)",
          "248: {",
          "255:     AVFrame *const p = &f->picture;",
          "257:     av_assert1(width && height);",
          "258:     if (f->colorspace == 0) {",
          "260:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "261:         const int cx            = x >> f->chroma_h_shift;",
          "262:         const int cy            = y >> f->chroma_v_shift;",
          "271:     } else {",
          "275:     }",
          "277:     emms_c();",
          "",
          "[Removed Lines]",
          "195:             for (x = 0; x < w; x++)",
          "196:                 ((uint16_t *)(src + stride * y))[x] =",
          "197:                     sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "203: static void decode_rgb_frame(FFV1Context *s, uint32_t *src,",
          "204:                              int w, int h, int stride)",
          "207:     int16_t *sample[3][2];",
          "208:     for (x = 0; x < 3; x++) {",
          "215:     memset(s->sample_buffer, 0, 6 * (w + 6) * sizeof(*s->sample_buffer));",
          "218:         for (p = 0; p < 3; p++) {",
          "219:             int16_t *temp = sample[p][0]; // FIXME: try a normal buffer",
          "226:             decode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "236:             b -= 0x100;",
          "237:             r -= 0x100;",
          "242:             src[x + stride * y] = b + (g << 8) + (r << 16) + (0xFF << 24);",
          "249:     FFV1Context *fs  = *(void **)arg;",
          "250:     FFV1Context *f   = fs->avctx->priv_data;",
          "251:     int width        = fs->slice_width;",
          "252:     int height       = fs->slice_height;",
          "253:     int x            = fs->slice_x;",
          "254:     int y            = fs->slice_y;",
          "259:         const int chroma_width  = -((-width)  >> f->chroma_h_shift);",
          "264:         decode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "265:                      width, height, p->linesize[0], 0);",
          "267:         decode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "268:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "269:         decode_plane(fs, p->data[2] + cx + cy * p->linesize[1],",
          "270:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "272:         decode_rgb_frame(fs,",
          "273:                          (uint32_t *)p->data[0] + x + y * (p->linesize[0] / 4),",
          "274:                          width, height, p->linesize[0] / 4);",
          "",
          "[Added Lines]",
          "199:             if (s->packed_at_lsb) {",
          "200:                 for (x = 0; x < w; x++)",
          "201:                     ((uint16_t *)(src + stride * y))[x] = sample[1][x];",
          "202:             } else {",
          "203:                 for (x = 0; x < w; x++)",
          "204:                     ((uint16_t *)(src + stride * y))[x] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "205:             }",
          "211: static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h,",
          "212:                              int stride[3])",
          "215:     int16_t *sample[4][2];",
          "216:     int lbd  = s->avctx->bits_per_raw_sample <= 8;",
          "217:     int bits = s->avctx->bits_per_raw_sample > 0",
          "218:                ? s->avctx->bits_per_raw_sample",
          "219:                : 8;",
          "220:     int offset = 1 << bits;",
          "222:     for (x = 0; x < 4; x++) {",
          "229:     memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));",
          "232:         for (p = 0; p < 3 + s->transparency; p++) {",
          "233:             int16_t *temp = sample[p][0]; //FIXME try a normal buffer",
          "240:             if (lbd)",
          "241:                 decode_line(s, w, sample[p], (p + 1) / 2, 9);",
          "242:             else",
          "243:                 decode_line(s, w, sample[p], (p + 1) / 2, bits + 1);",
          "249:             int a = sample[3][1][x];",
          "251:             b -= offset;",
          "252:             r -= offset;",
          "257:             if (lbd)",
          "259:                     (g << 8) + (r << 16) + (a << 24);",
          "260:             else {",
          "264:             }",
          "269: static int decode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "270: {",
          "271:     RangeCoder *c = &fs->c;",
          "272:     uint8_t state[CONTEXT_SIZE];",
          "273:     unsigned ps, i, context_count;",
          "274:     memset(state, 128, sizeof(state));",
          "276:     av_assert0(f->version > 2);",
          "278:     fs->slice_x      = get_symbol(c, state, 0) * f->width;",
          "279:     fs->slice_y      = get_symbol(c, state, 0) * f->height;",
          "280:     fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;",
          "281:     fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "283:     fs->slice_x     /= f->num_h_slices;",
          "284:     fs->slice_y     /= f->num_v_slices;",
          "285:     fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;",
          "286:     fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "287:     if ((unsigned)fs->slice_width  > f->width ||",
          "288:         (unsigned)fs->slice_height > f->height)",
          "289:         return AVERROR_INVALIDDATA;",
          "290:     if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "291:         (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "292:         return AVERROR_INVALIDDATA;",
          "294:     for (i = 0; i < f->plane_count; i++) {",
          "295:         PlaneContext *const p = &fs->plane[i];",
          "296:         int idx               = get_symbol(c, state, 0);",
          "297:         if (idx > (unsigned)f->quant_table_count) {",
          "298:             av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");",
          "299:             return AVERROR_INVALIDDATA;",
          "300:         }",
          "301:         p->quant_table_index = idx;",
          "302:         memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));",
          "303:         context_count = f->context_count[idx];",
          "305:         if (p->context_count < context_count) {",
          "306:             av_freep(&p->state);",
          "307:             av_freep(&p->vlc_state);",
          "308:         }",
          "309:         p->context_count = context_count;",
          "310:     }",
          "312:     ps = get_symbol(c, state, 0);",
          "313:     if (ps == 1) {",
          "314:         f->picture.interlaced_frame = 1;",
          "315:         f->picture.top_field_first  = 1;",
          "316:     } else if (ps == 2) {",
          "317:         f->picture.interlaced_frame = 1;",
          "318:         f->picture.top_field_first  = 0;",
          "319:     } else if (ps == 3) {",
          "320:         f->picture.interlaced_frame = 0;",
          "321:     }",
          "322:     f->picture.sample_aspect_ratio.num = get_symbol(c, state, 0);",
          "323:     f->picture.sample_aspect_ratio.den = get_symbol(c, state, 0);",
          "325:     return 0;",
          "326: }",
          "330:     FFV1Context *fs = *(void **)arg;",
          "331:     FFV1Context *f  = fs->avctx->priv_data;",
          "332:     int width, height, x, y, ret;",
          "333:     const int ps = (av_pix_fmt_desc_get(c->pix_fmt)->flags & PIX_FMT_PLANAR)",
          "334:                    ? (c->bits_per_raw_sample > 8) + 1",
          "335:                    : 4;",
          "338:     if (f->version > 2) {",
          "339:         if (decode_slice_header(f, fs) < 0) {",
          "340:             fs->slice_damaged = 1;",
          "341:             return AVERROR_INVALIDDATA;",
          "342:         }",
          "343:     }",
          "344:     if ((ret = ffv1_init_slice_state(f, fs)) < 0)",
          "345:         return ret;",
          "346:     if (f->picture.key_frame)",
          "347:         ffv1_clear_slice_state(f, fs);",
          "348:     width  = fs->slice_width;",
          "349:     height = fs->slice_height;",
          "350:     x      = fs->slice_x;",
          "351:     y      = fs->slice_y;",
          "353:     if (!fs->ac) {",
          "354:         if (f->version == 3 && f->minor_version > 1 || f->version > 3)",
          "355:             get_rac(&fs->c, (uint8_t[]) { 129 });",
          "356:         fs->ac_byte_count = f->version > 2 || (!x && !y) ? fs->c.bytestream - fs->c.bytestream_start - 1 : 0;",
          "357:         init_get_bits(&fs->gb, fs->c.bytestream_start + fs->ac_byte_count,",
          "358:                       (fs->c.bytestream_end - fs->c.bytestream_start -",
          "359:                        fs->ac_byte_count) * 8);",
          "360:     }",
          "364:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "368:         decode_plane(fs, p->data[0] + ps * x + y * p->linesize[0], width,",
          "369:                      height, p->linesize[0],",
          "370:                      0);",
          "372:         if (f->chroma_planes) {",
          "373:             decode_plane(fs, p->data[1] + ps * cx + cy * p->linesize[1],",
          "374:                          chroma_width, chroma_height, p->linesize[1],",
          "375:                          1);",
          "376:             decode_plane(fs, p->data[2] + ps * cx + cy * p->linesize[2],",
          "377:                          chroma_width, chroma_height, p->linesize[2],",
          "378:                          1);",
          "379:         }",
          "380:         if (fs->transparency)",
          "381:             decode_plane(fs, p->data[3] + ps * x + y * p->linesize[3], width,",
          "382:                          height, p->linesize[3],",
          "383:                          2);",
          "385:         uint8_t *planes[3] = { p->data[0] + ps * x + y * p->linesize[0],",
          "386:                                p->data[1] + ps * x + y * p->linesize[1],",
          "387:                                p->data[2] + ps * x + y * p->linesize[2] };",
          "388:         decode_rgb_frame(fs, planes, width, height, p->linesize);",
          "389:     }",
          "390:     if (fs->ac && f->version > 2) {",
          "391:         int v;",
          "392:         get_rac(&fs->c, (uint8_t[]) { 129 });",
          "393:         v = fs->c.bytestream_end - fs->c.bytestream - 2 - 5 * f->ec;",
          "394:         if (v) {",
          "395:             av_log(f->avctx, AV_LOG_ERROR, \"bytestream end mismatching by %d\\n\",",
          "396:                    v);",
          "397:             fs->slice_damaged = 1;",
          "398:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:     memset(state, 128, sizeof(state));",
          "290:     for (v = 0; i < 128; v++) {",
          "296:         while (len--) {",
          "297:             quant_table[i] = scale * v;",
          "",
          "[Removed Lines]",
          "291:         int len = get_symbol(c, state, 0) + 1;",
          "293:         if (len + i > 128)",
          "294:             return AVERROR_INVALIDDATA;",
          "",
          "[Added Lines]",
          "415:         unsigned len = get_symbol(c, state, 0) + 1;",
          "417:         if (len > 128 - i)",
          "418:             return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "315:     for (i = 0; i < 5; i++) {",
          "316:         context_count *= read_quant_table(c, quant_table[i], context_count);",
          "317:         if (context_count > 32768U) {",
          "319:         }",
          "320:     }",
          "321:     return (context_count + 1) / 2;",
          "",
          "[Removed Lines]",
          "318:             return AVERROR_INVALIDDATA;",
          "",
          "[Added Lines]",
          "442:             return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "325: {",
          "326:     RangeCoder *const c = &f->c;",
          "327:     uint8_t state[CONTEXT_SIZE];",
          "329:     uint8_t state2[32][CONTEXT_SIZE];",
          "331:     memset(state2, 128, sizeof(state2));",
          "",
          "[Removed Lines]",
          "328:     int i, j, k;",
          "",
          "[Added Lines]",
          "452:     int i, j, k, ret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "335:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "337:     f->version = get_symbol(c, state, 0);",
          "340:         for (i = 1; i < 256; i++)",
          "341:             f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "343:     f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "352:     if (f->num_h_slices > (unsigned)f->width ||",
          "353:         f->num_v_slices > (unsigned)f->height) {",
          "",
          "[Removed Lines]",
          "338:     f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "339:     if (f->ac > 1)",
          "342:     f->colorspace                 = get_symbol(c, state, 0); // YUV cs type",
          "344:     get_rac(c, state); // no chroma = false",
          "345:     f->chroma_h_shift = get_symbol(c, state, 0);",
          "346:     f->chroma_v_shift = get_symbol(c, state, 0);",
          "347:     get_rac(c, state); // transparency plane",
          "348:     f->plane_count  = 2;",
          "349:     f->num_h_slices = 1 + get_symbol(c, state, 0);",
          "350:     f->num_v_slices = 1 + get_symbol(c, state, 0);",
          "",
          "[Added Lines]",
          "462:     if (f->version > 2) {",
          "463:         c->bytestream_end -= 4;",
          "464:         f->minor_version   = get_symbol(c, state, 0);",
          "465:     }",
          "466:     f->ac = f->avctx->coder_type = get_symbol(c, state, 0);",
          "468:     if (f->ac > 1) {",
          "471:     }",
          "473:     f->colorspace                 = get_symbol(c, state, 0); //YUV cs type",
          "475:     f->chroma_planes              = get_rac(c, state);",
          "476:     f->chroma_h_shift             = get_symbol(c, state, 0);",
          "477:     f->chroma_v_shift             = get_symbol(c, state, 0);",
          "478:     f->transparency               = get_rac(c, state);",
          "479:     f->plane_count                = 2 + f->transparency;",
          "480:     f->num_h_slices               = 1 + get_symbol(c, state, 0);",
          "481:     f->num_v_slices               = 1 + get_symbol(c, state, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "356:     }",
          "358:     f->quant_table_count = get_symbol(c, state, 0);",
          "360:     if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)",
          "361:         return AVERROR_INVALIDDATA;",
          "363:     for (i = 0; i < f->quant_table_count; i++) {",
          "364:         f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);",
          "365:         if (f->context_count[i] < 0) {",
          "366:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "368:         }",
          "369:     }",
          "374:     for (i = 0; i < f->quant_table_count; i++)",
          "376:             for (j = 0; j < f->context_count[i]; j++)",
          "377:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "378:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "379:                     f->initial_states[i][j][k] =",
          "380:                         (pred + get_symbol(c, state2[k], 1)) & 0xFF;",
          "381:                 }",
          "382:     return 0;",
          "383: }",
          "385: static int read_header(FFV1Context *f)",
          "386: {",
          "387:     uint8_t state[CONTEXT_SIZE];",
          "389:     RangeCoder *const c = &f->slice_context[0]->c;",
          "391:     memset(state, 128, sizeof(state));",
          "393:     if (f->version < 2) {",
          "397:             for (i = 1; i < 256; i++)",
          "400:         if (f->version > 0)",
          "401:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "403:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "404:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "407:     }",
          "409:     if (f->colorspace == 0) {",
          "411:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "412:             case 0x00:",
          "413:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "414:                 break;",
          "415:             case 0x10:",
          "416:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "417:                 break;",
          "",
          "[Removed Lines]",
          "367:             return f->context_count[i];",
          "371:     if (ffv1_allocate_initial_states(f) < 0)",
          "372:         return AVERROR(ENOMEM);",
          "375:         if (get_rac(c, state))",
          "388:     int i, j, context_count;",
          "394:         f->version = get_symbol(c, state, 0);",
          "395:         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "396:         if (f->ac > 1)",
          "398:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "399:         f->colorspace = get_symbol(c, state, 0); // YUV cs type",
          "402:         get_rac(c, state); // no chroma = false",
          "405:         get_rac(c, state); // transparency plane",
          "406:         f->plane_count = 2;",
          "410:         if (f->avctx->bits_per_raw_sample <= 8) {",
          "",
          "[Added Lines]",
          "496:             return AVERROR_INVALIDDATA;",
          "499:     if ((ret = ffv1_allocate_initial_states(f)) < 0)",
          "500:         return ret;",
          "503:         if (get_rac(c, state)) {",
          "510:         }",
          "512:     if (f->version > 2) {",
          "513:         f->ec = get_symbol(c, state, 0);",
          "514:     }",
          "516:     if (f->version > 2) {",
          "517:         unsigned v;",
          "518:         v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0,",
          "519:                    f->avctx->extradata, f->avctx->extradata_size);",
          "520:         if (v) {",
          "521:             av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", v);",
          "522:             return AVERROR_INVALIDDATA;",
          "523:         }",
          "524:     }",
          "533:     int i, j, context_count = -1;",
          "539:         unsigned v = get_symbol(c, state, 0);",
          "540:         if (v > 1) {",
          "541:             av_log(f->avctx, AV_LOG_ERROR,",
          "542:                    \"invalid version %d in version 1 header\\n\", v);",
          "543:             return AVERROR_INVALIDDATA;",
          "544:         }",
          "545:         f->version = v;",
          "547:         f->ac = f->avctx->coder_type = get_symbol(c, state, 0);",
          "549:         if (f->ac > 1) {",
          "551:                 f->state_transition[i] =",
          "552:                     get_symbol(c, state, 1) + c->one_state[i];",
          "553:         }",
          "555:         f->colorspace = get_symbol(c, state, 0); //YUV cs type",
          "560:         f->chroma_planes  = get_rac(c, state);",
          "563:         f->transparency   = get_rac(c, state);",
          "564:         f->plane_count    = 2 + f->transparency;",
          "568:         if (!f->transparency && !f->chroma_planes) {",
          "569:             if (f->avctx->bits_per_raw_sample <= 8)",
          "570:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;",
          "571:             else",
          "572:                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;",
          "573:         } else if (f->avctx->bits_per_raw_sample <= 8 && !f->transparency) {",
          "578:             case 0x01:",
          "579:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV440P;",
          "580:                 break;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "428:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "429:                 return AVERROR(ENOSYS);",
          "430:             }",
          "431:         } else {",
          "432:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "433:             case 0x00:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {",
          "598:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "599:             case 0x00:",
          "600:                 f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P;",
          "601:                 break;",
          "602:             case 0x10:",
          "603:                 f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P;",
          "604:                 break;",
          "605:             case 0x11:",
          "606:                 f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;",
          "607:                 break;",
          "608:             default:",
          "609:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "610:                 return AVERROR(ENOSYS);",
          "611:             }",
          "612:         } else if (f->avctx->bits_per_raw_sample == 9) {",
          "613:             f->packed_at_lsb = 1;",
          "614:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "615:             case 0x00:",
          "616:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9;",
          "617:                 break;",
          "618:             case 0x10:",
          "619:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9;",
          "620:                 break;",
          "621:             case 0x11:",
          "622:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9;",
          "623:                 break;",
          "624:             default:",
          "625:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "626:                 return AVERROR(ENOSYS);",
          "627:             }",
          "628:         } else if (f->avctx->bits_per_raw_sample == 10) {",
          "629:             f->packed_at_lsb = 1;",
          "630:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "631:             case 0x00:",
          "632:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10;",
          "633:                 break;",
          "634:             case 0x10:",
          "635:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;",
          "636:                 break;",
          "637:             case 0x11:",
          "638:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10;",
          "639:                 break;",
          "640:             default:",
          "641:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "642:                 return AVERROR(ENOSYS);",
          "643:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "450:                    \"chroma subsampling not supported in this colorspace\\n\");",
          "451:             return AVERROR(ENOSYS);",
          "452:         }",
          "454:     } else {",
          "455:         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");",
          "456:         return AVERROR(ENOSYS);",
          "",
          "[Removed Lines]",
          "453:         f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "",
          "[Added Lines]",
          "666:         switch (f->avctx->bits_per_raw_sample) {",
          "667:         case 8:",
          "668:             f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "669:             break;",
          "670:         case 9:",
          "671:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;",
          "672:             break;",
          "673:         case 10:",
          "674:             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
          "675:             break;",
          "676:         default:",
          "677:             av_log(f->avctx, AV_LOG_ERROR,",
          "678:                    \"bit depth %d not supported\\n\",",
          "679:                    f->avctx->bits_per_raw_sample);",
          "680:             return AVERROR(ENOSYS);",
          "681:         }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "459:     av_dlog(f->avctx, \"%d %d %d\\n\",",
          "460:             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);",
          "462:     if (f->version < 2) {",
          "463:         context_count = read_quant_tables(c, f->quant_table);",
          "464:         if (context_count < 0) {",
          "465:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "467:         }",
          "469:         f->slice_count = get_symbol(c, state, 0);",
          "472:     }",
          "474:     for (j = 0; j < f->slice_count; j++) {",
          "475:         FFV1Context *fs = f->slice_context[j];",
          "489:                 (unsigned)fs->slice_height > f->height)",
          "490:                 return AVERROR_INVALIDDATA;",
          "493:                 return AVERROR_INVALIDDATA;",
          "494:         }",
          "496:         for (i = 0; i < f->plane_count; i++) {",
          "497:             PlaneContext *const p = &fs->plane[i];",
          "500:                 int idx = get_symbol(c, state, 0);",
          "501:                 if (idx > (unsigned)f->quant_table_count) {",
          "502:                     av_log(f->avctx, AV_LOG_ERROR,",
          "",
          "[Removed Lines]",
          "466:             return context_count;",
          "468:     } else {",
          "470:         if (f->slice_count > (unsigned)MAX_SLICES)",
          "471:             return AVERROR_INVALIDDATA;",
          "476:         fs->ac = f->ac;",
          "478:         if (f->version >= 2) {",
          "479:             fs->slice_x      = get_symbol(c, state, 0) * f->width;",
          "480:             fs->slice_y      = get_symbol(c, state, 0) * f->height;",
          "481:             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "482:             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "484:             fs->slice_x     /= f->num_h_slices;",
          "485:             fs->slice_y     /= f->num_v_slices;",
          "486:             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;",
          "487:             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "488:             if ((unsigned)fs->slice_width  > f->width ||",
          "491:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "492:                 (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "499:             if (f->version >= 2) {",
          "",
          "[Added Lines]",
          "693:             return AVERROR_INVALIDDATA;",
          "695:     } else if (f->version < 3) {",
          "697:     } else {",
          "698:         const uint8_t *p = c->bytestream_end;",
          "699:         for (f->slice_count = 0;",
          "700:              f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;",
          "701:              f->slice_count++) {",
          "702:             int trailer = 3 + 5 * !!f->ec;",
          "703:             int size    = AV_RB24(p - trailer);",
          "704:             if (size + trailer > p - c->bytestream_start)",
          "705:                 break;",
          "706:             p -= size + trailer;",
          "707:         }",
          "708:     }",
          "709:     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {",
          "710:         av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\",",
          "711:                f->slice_count);",
          "712:         return AVERROR_INVALIDDATA;",
          "717:         fs->ac            = f->ac;",
          "718:         fs->packed_at_lsb = f->packed_at_lsb;",
          "720:         fs->slice_damaged = 0;",
          "722:         if (f->version == 2) {",
          "723:             fs->slice_x     = get_symbol(c, state, 0) * f->width;",
          "724:             fs->slice_y     = get_symbol(c, state, 0) * f->height;",
          "725:             fs->slice_width =",
          "726:                 (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;",
          "727:             fs->slice_height =",
          "728:                 (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "730:             fs->slice_x      /= f->num_h_slices;",
          "731:             fs->slice_y      /= f->num_v_slices;",
          "732:             fs->slice_width  /= f->num_h_slices - fs->slice_x;",
          "733:             fs->slice_height /= f->num_v_slices - fs->slice_y;",
          "734:             if ((unsigned)fs->slice_width > f->width ||",
          "737:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width > f->width",
          "738:                 || (unsigned)fs->slice_y + (uint64_t)fs->slice_height >",
          "739:                 f->height)",
          "746:             if (f->version == 2) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "511:                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));",
          "512:             }",
          "517:             }",
          "519:         }",
          "520:     }",
          "522:     return 0;",
          "523: }",
          "",
          "[Removed Lines]",
          "514:             if (p->context_count < context_count) {",
          "515:                 av_freep(&p->state);",
          "516:                 av_freep(&p->vlc_state);",
          "518:             p->context_count = context_count;",
          "",
          "[Added Lines]",
          "761:             if (f->version <= 2) {",
          "762:                 av_assert0(context_count >= 0);",
          "763:                 if (p->context_count < context_count) {",
          "764:                     av_freep(&p->state);",
          "765:                     av_freep(&p->vlc_state);",
          "766:                 }",
          "767:                 p->context_count = context_count;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "546:     FFV1Context *f      = avctx->priv_data;",
          "547:     RangeCoder *const c = &f->slice_context[0]->c;",
          "548:     AVFrame *const p    = &f->picture;",
          "550:     uint8_t keystate = 128;",
          "551:     const uint8_t *buf_p;",
          "",
          "[Removed Lines]",
          "549:     int bytes_read, i, ret;",
          "",
          "[Added Lines]",
          "798:     int i, ret;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "559:     ff_init_range_decoder(c, buf, buf_size);",
          "560:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "563:     if (get_rac(c, &keystate)) {",
          "565:         if ((ret = read_header(f)) < 0)",
          "566:             return ret;",
          "571:     } else {",
          "579:         }",
          "580:     }",
          "583:     if ((ret = avctx->get_buffer(avctx, p)) < 0) {",
          "584:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "585:         return ret;",
          "586:     }",
          "588:     if (avctx->debug & FF_DEBUG_PICT_INFO)",
          "601:     buf_p = buf + buf_size;",
          "603:         FFV1Context *fs = f->slice_context[i];",
          "606:             av_log(avctx, AV_LOG_ERROR, \"Slice pointer chain broken\\n\");",
          "607:             return AVERROR_INVALIDDATA;",
          "608:         }",
          "609:         buf_p -= v;",
          "611:             ff_init_range_decoder(&fs->c, buf_p, v);",
          "614:     }",
          "618:     f->picture_number++;",
          "623:     return buf_size;",
          "624: }",
          "",
          "[Removed Lines]",
          "562:     p->pict_type = AV_PICTURE_TYPE_I; // FIXME: I vs. P",
          "564:         p->key_frame = 1;",
          "567:         if ((ret = ffv1_init_slice_state(f)) < 0)",
          "568:             return ret;",
          "570:         ffv1_clear_state(f);",
          "572:         p->key_frame = 0;",
          "573:     }",
          "574:     if (f->ac > 1) {",
          "575:         int i;",
          "576:         for (i = 1; i < 256; i++) {",
          "577:             c->one_state[i]        = f->state_transition[i];",
          "578:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "582:     p->reference = 0;",
          "589:         av_log(avctx, AV_LOG_ERROR, \"keyframe:%d coder:%d\\n\", p->key_frame, f->ac);",
          "591:     if (!f->ac) {",
          "592:         bytes_read = c->bytestream - c->bytestream_start - 1;",
          "593:         if (bytes_read == 0)",
          "594:             av_log(avctx, AV_LOG_ERROR, \"error at end of AC stream\\n\"); // FIXME",
          "595:         init_get_bits(&f->slice_context[0]->gb, buf + bytes_read,",
          "596:                       (buf_size - bytes_read) * 8);",
          "597:     } else {",
          "599:     }",
          "602:     for (i = f->slice_count - 1; i > 0; i--) {",
          "604:         int v           = AV_RB24(buf_p - 3) + 3;",
          "605:         if (buf_p - buf <= v) {",
          "610:         if (fs->ac)",
          "612:         else",
          "613:             init_get_bits(&fs->gb, buf_p, v * 8);",
          "616:     avctx->execute(avctx, decode_slice, &f->slice_context[0],",
          "617:                    NULL, f->slice_count, sizeof(void *));",
          "",
          "[Added Lines]",
          "811:     p->pict_type = AV_PICTURE_TYPE_I; //FIXME I vs. P",
          "813:         p->key_frame    = 1;",
          "814:         f->key_frame_ok = 0;",
          "817:         f->key_frame_ok = 1;",
          "819:         if (!f->key_frame_ok) {",
          "820:             av_log(avctx, AV_LOG_ERROR,",
          "821:                    \"Cant decode non keyframe without valid keyframe\\n\");",
          "822:             return AVERROR_INVALIDDATA;",
          "824:         p->key_frame = 0;",
          "827:     p->reference = 3; //for error concealment",
          "834:         av_log(avctx, AV_LOG_DEBUG,",
          "835:                \"ver:%d keyframe:%d coder:%d ec:%d slices:%d bps:%d\\n\",",
          "836:                f->version, p->key_frame, f->ac, f->ec, f->slice_count,",
          "837:                f->avctx->bits_per_raw_sample);",
          "840:     for (i = f->slice_count - 1; i >= 0; i--) {",
          "842:         int trailer     = 3 + 5 * !!f->ec;",
          "843:         int v;",
          "845:         if (i || f->version > 2)",
          "846:             v = AV_RB24(buf_p - trailer) + trailer;",
          "847:         else",
          "848:             v = buf_p - c->bytestream_start;",
          "849:         if (buf_p - c->bytestream_start < v) {",
          "855:         if (f->ec) {",
          "856:             unsigned crc = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, v);",
          "857:             if (crc) {",
          "858:                 av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", crc);",
          "859:                 fs->slice_damaged = 1;",
          "860:             }",
          "861:         }",
          "863:         if (i) {",
          "865:         } else",
          "866:             fs->c.bytestream_end = (uint8_t *)(buf_p + v);",
          "867:     }",
          "869:     avctx->execute(avctx, decode_slice, &f->slice_context[0], NULL,",
          "870:                    f->slice_count,",
          "871:                    sizeof(void *));",
          "873:     for (i = f->slice_count - 1; i >= 0; i--) {",
          "874:         FFV1Context *fs = f->slice_context[i];",
          "875:         int j;",
          "876:         if (fs->slice_damaged && f->last_picture.data[0]) {",
          "877:             const uint8_t *src[4];",
          "878:             uint8_t *dst[4];",
          "879:             for (j = 0; j < 4; j++) {",
          "880:                 int sh = (j == 1 || j == 2) ? f->chroma_h_shift : 0;",
          "881:                 int sv = (j == 1 || j == 2) ? f->chroma_v_shift : 0;",
          "882:                 dst[j] = f->picture.data[j] + f->picture.linesize[j] *",
          "883:                          (fs->slice_y >> sv) + (fs->slice_x >> sh);",
          "884:                 src[j] = f->last_picture.data[j] +",
          "885:                          f->last_picture.linesize[j] *",
          "886:                          (fs->slice_y >> sv) + (fs->slice_x >> sh);",
          "887:             }",
          "888:             av_image_copy(dst, f->picture.linesize, (const uint8_t **)src,",
          "889:                           f->last_picture.linesize,",
          "890:                           avctx->pix_fmt, fs->slice_width,",
          "891:                           fs->slice_height);",
          "892:         }",
          "900:     FFSWAP(AVFrame, f->picture, f->last_picture);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c": [
          "File: libavcodec/ffv1enc.c -> libavcodec/ffv1enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"avcodec.h\"",
          "30: #include \"get_bits.h\"",
          "31: #include \"put_bits.h\"",
          "32: #include \"dsputil.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"libavutil/pixdesc.h\"",
          "30: #include \"libavutil/crc.h\"",
          "31: #include \"libavutil/opt.h\"",
          "32: #include \"libavutil/imgutils.h\"",
          "34: #include \"internal.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:             occ[j] = 1.0;",
          "58:             for (k = 0; k < 256; k++) {",
          "59:                 double newocc[256] = { 0 };",
          "61:                     if (occ[m]) {",
          "62:                         len -= occ[m] *     (p  * l2tab[m] +",
          "63:                                         (1 - p) * l2tab[256 - m]);",
          "",
          "[Removed Lines]",
          "60:                 for (m = 0; m < 256; m++)",
          "",
          "[Added Lines]",
          "65:                 for (m = 1; m < 256; m++)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:         i += i;",
          "145:     }",
          "149: #if 0 // JPEG LS",
          "150:     if (k == 0 && 2 * state->drift <= -state->count)",
          "",
          "[Removed Lines]",
          "147:     assert(k <= 8);",
          "",
          "[Added Lines]",
          "152:     assert(k <= 13);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "269:         sample[0][-1] = sample[1][0];",
          "270:         sample[1][w]  = sample[1][w - 1];",
          "273:             for (x = 0; x < w; x++)",
          "274:                 sample[0][x] = src[x + stride * y];",
          "275:             encode_line(s, w, sample, plane_index, 8);",
          "276:         } else {",
          "281:         }",
          "283:     }",
          "284: }",
          "288: {",
          "289:     int x, y, p, i;",
          "290:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "292:     s->run_index = 0;",
          "296:     for (y = 0; y < h; y++) {",
          "297:         for (i = 0; i < ring_size; i++)",
          "300:                                ((h + i - y) % ring_size) * (w + 6) + 3;",
          "302:         for (x = 0; x < w; x++) {",
          "308:             b -= g;",
          "309:             r -= g;",
          "310:             g += (b + r) >> 2;",
          "314:             sample[0][0][x] = g;",
          "315:             sample[1][0][x] = b;",
          "316:             sample[2][0][x] = r;",
          "317:         }",
          "319:             sample[p][0][-1] = sample[p][1][0];",
          "320:             sample[p][1][w]  = sample[p][1][w - 1];",
          "322:         }",
          "323:     }",
          "324: }",
          "326: static void write_quant_table(RangeCoder *c, int16_t *quant_table)",
          "327: {",
          "328:     int last = 0;",
          "",
          "[Removed Lines]",
          "272:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "277:             for (x = 0; x < w; x++)",
          "278:                 sample[0][x] = ((uint16_t *)(src + stride * y))[x] >>",
          "279:                                (16 - s->avctx->bits_per_raw_sample);",
          "280:             encode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);",
          "286: static void encode_rgb_frame(FFV1Context *s, uint32_t *src, int w, int h,",
          "287:                              int stride)",
          "291:     int16_t *sample[3][3];",
          "294:     memset(s->sample_buffer, 0, ring_size * 3 * (w + 6) * sizeof(*s->sample_buffer));",
          "298:             for (p = 0; p < 3; p++)",
          "299:                 sample[p][i] = s->sample_buffer + p * ring_size * (w + 6) +",
          "303:             int v = src[x + stride * y];",
          "304:             int b =  v        & 0xFF;",
          "305:             int g = (v >>  8) & 0xFF;",
          "306:             int r = (v >> 16) & 0xFF;",
          "311:             b += 0x100;",
          "312:             r += 0x100;",
          "318:         for (p = 0; p < 3; p++) {",
          "321:             encode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "",
          "[Added Lines]",
          "277:         if (s->bits_per_raw_sample <= 8) {",
          "282:             if (s->packed_at_lsb) {",
          "283:                 for (x = 0; x < w; x++)",
          "284:                     sample[0][x] = ((uint16_t *)(src + stride * y))[x];",
          "285:             } else {",
          "286:                 for (x = 0; x < w; x++)",
          "287:                     sample[0][x] =",
          "288:                         ((uint16_t *)(src + stride * y))[x] >> (16 - s->bits_per_raw_sample);",
          "289:             }",
          "290:             encode_line(s, w, sample, plane_index, s->bits_per_raw_sample);",
          "296: static void encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h,",
          "297:                              int stride[3])",
          "301:     int16_t *sample[MAX_PLANES][3];",
          "302:     int lbd  = s->avctx->bits_per_raw_sample <= 8;",
          "303:     int bits = s->avctx->bits_per_raw_sample > 0",
          "304:                ? s->avctx->bits_per_raw_sample",
          "305:                : 8;",
          "306:     int offset = 1 << bits;",
          "310:     memset(s->sample_buffer, 0, ring_size * MAX_PLANES *",
          "311:                                 (w + 6) * sizeof(*s->sample_buffer));",
          "315:             for (p = 0; p < MAX_PLANES; p++)",
          "316:                 sample[p][i] = s->sample_buffer + p * ring_size *",
          "317:                                (w + 6) +",
          "321:             int b, g, r, av_uninit(a);",
          "322:             if (lbd) {",
          "323:                 unsigned v = *((uint32_t *)(src[0] + x * 4 + stride[0] * y));",
          "324:                 b = v & 0xFF;",
          "325:                 g = (v >> 8) & 0xFF;",
          "326:                 r = (v >> 16) & 0xFF;",
          "327:                 a = v >> 24;",
          "328:             } else {",
          "329:                 b = *((uint16_t *)(src[0] + x * 2 + stride[0] * y));",
          "330:                 g = *((uint16_t *)(src[1] + x * 2 + stride[1] * y));",
          "331:                 r = *((uint16_t *)(src[2] + x * 2 + stride[2] * y));",
          "332:             }",
          "337:             b += offset;",
          "338:             r += offset;",
          "343:             sample[3][0][x] = a;",
          "345:         for (p = 0; p < 3 + s->transparency; p++) {",
          "348:             if (lbd)",
          "349:                 encode_line(s, w, sample[p], (p + 1) / 2, 9);",
          "350:             else",
          "351:                 encode_line(s, w, sample[p], (p + 1) / 2, bits + 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "364:         }",
          "365:         put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "366:         if (f->version > 0)",
          "369:         put_symbol(c, state, f->chroma_h_shift, 0);",
          "370:         put_symbol(c, state, f->chroma_v_shift, 0);",
          "373:         write_quant_tables(c, f->quant_table);",
          "375:         put_symbol(c, state, f->slice_count, 0);",
          "376:         for (i = 0; i < f->slice_count; i++) {",
          "377:             FFV1Context *fs = f->slice_context[i];",
          "",
          "[Removed Lines]",
          "367:             put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "368:         put_rac(c, state, 1); // chroma planes",
          "371:         put_rac(c, state, 0); // no transparency plane",
          "374:     } else {",
          "",
          "[Added Lines]",
          "398:             put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "399:         put_rac(c, state, f->chroma_planes);",
          "402:         put_rac(c, state, f->transparency);",
          "405:     } else if (f->version < 3) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "393:     }",
          "394: }",
          "397: {",
          "398:     RangeCoder *const c = &f->c;",
          "399:     uint8_t state[CONTEXT_SIZE];",
          "400:     int i, j, k;",
          "401:     uint8_t state2[32][CONTEXT_SIZE];",
          "403:     memset(state2, 128, sizeof(state2));",
          "404:     memset(state, 128, sizeof(state));",
          "408:     ff_init_range_encoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "409:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "411:     put_symbol(c, state, f->version, 0);",
          "412:     put_symbol(c, state, f->ac, 0);",
          "413:     if (f->ac > 1)",
          "414:         for (i = 1; i < 256; i++)",
          "415:             put_symbol(c, state, f->state_transition[i] - c->one_state[i], 1);",
          "416:     put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "419:     put_symbol(c, state, f->chroma_h_shift, 0);",
          "420:     put_symbol(c, state, f->chroma_v_shift, 0);",
          "422:     put_symbol(c, state, f->num_h_slices - 1, 0);",
          "423:     put_symbol(c, state, f->num_v_slices - 1, 0);",
          "",
          "[Removed Lines]",
          "396: static int write_extra_header(FFV1Context *f)",
          "406:     f->avctx->extradata = av_malloc(f->avctx->extradata_size = 10000 +",
          "407:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32);",
          "417:     put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "418:     put_rac(c, state, 1); // chroma planes",
          "421:     put_rac(c, state, 0); // no transparency plane",
          "",
          "[Added Lines]",
          "427: static int write_extradata(FFV1Context *f)",
          "433:     unsigned v;",
          "438:     f->avctx->extradata_size = 10000 + 4 +",
          "439:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32;",
          "440:     f->avctx->extradata = av_malloc(f->avctx->extradata_size);",
          "445:     if (f->version > 2) {",
          "446:         if (f->version == 3)",
          "447:             f->minor_version = 2;",
          "448:         put_symbol(c, state, f->minor_version, 0);",
          "449:     }",
          "457:     put_symbol(c, state, f->bits_per_raw_sample, 0);",
          "458:     put_rac(c, state, f->chroma_planes);",
          "461:     put_rac(c, state, f->transparency);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "443:         }",
          "444:     }",
          "446:     f->avctx->extradata_size = ff_rac_terminate(c);",
          "448:     return 0;",
          "449: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "486:     if (f->version > 2) {",
          "487:         put_symbol(c, state, f->ec, 0);",
          "488:     }",
          "492:     v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0,",
          "493:                f->avctx->extradata, f->avctx->extradata_size);",
          "494:     AV_WL32(f->avctx->extradata + f->avctx->extradata_size, v);",
          "495:     f->avctx->extradata_size += 4;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "496:     return print;",
          "497: }",
          "499: static av_cold int ffv1_encode_init(AVCodecContext *avctx)",
          "500: {",
          "501:     FFV1Context *s = avctx->priv_data;",
          "502:     int i, j, k, m, ret;",
          "504:     ffv1_common_init(avctx);",
          "506:     s->version = 0;",
          "509:     if (s->ac > 1)",
          "510:         for (i = 1; i < 256; i++)",
          "511:             s->state_transition[i] = ffv1_ver2_state[i];",
          "514:     for (i = 0; i < 256; i++) {",
          "515:         s->quant_table_count = 2;",
          "517:             s->quant_tables[0][0][i] = ffv1_quant11[i];",
          "518:             s->quant_tables[0][1][i] = ffv1_quant11[i] * 11;",
          "519:             s->quant_tables[0][2][i] = ffv1_quant11[i] * 11 * 11;",
          "",
          "[Removed Lines]",
          "507:     s->ac      = avctx->coder_type ? 2 : 0;",
          "513:     s->plane_count = 2;",
          "516:         if (avctx->bits_per_raw_sample <= 8) {",
          "",
          "[Added Lines]",
          "548: static int init_slices_state(FFV1Context *f)",
          "549: {",
          "550:     int i, ret;",
          "551:     for (i = 0; i < f->slice_count; i++) {",
          "552:         FFV1Context *fs = f->slice_context[i];",
          "553:         if ((ret = ffv1_init_slice_state(f, fs)) < 0)",
          "554:             return AVERROR(ENOMEM);",
          "555:     }",
          "556:     return 0;",
          "557: }",
          "562:     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "569:     if ((avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) ||",
          "570:         avctx->slices > 1)",
          "571:         s->version = FFMAX(s->version, 2);",
          "573:     if (avctx->level == 3) {",
          "574:         s->version = 3;",
          "575:     }",
          "577:     if (s->ec < 0) {",
          "578:         s->ec = (s->version >= 3);",
          "579:     }",
          "581:     if (s->version >= 2 &&",
          "582:         avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {",
          "583:         av_log(avctx, AV_LOG_ERROR,",
          "584:                \"Version %d requested, please set -strict experimental in \"",
          "585:                \"order to enable it\\n\",",
          "586:                s->version);",
          "587:         return AVERROR(ENOSYS);",
          "588:     }",
          "590:     s->ac = avctx->coder_type > 0 ? 2 : 0;",
          "592:     s->plane_count = 3;",
          "593:     switch (avctx->pix_fmt) {",
          "594:     case AV_PIX_FMT_YUV444P9:",
          "595:     case AV_PIX_FMT_YUV422P9:",
          "596:     case AV_PIX_FMT_YUV420P9:",
          "597:         if (!avctx->bits_per_raw_sample)",
          "598:             s->bits_per_raw_sample = 9;",
          "599:     case AV_PIX_FMT_YUV444P10:",
          "600:     case AV_PIX_FMT_YUV420P10:",
          "601:     case AV_PIX_FMT_YUV422P10:",
          "602:         s->packed_at_lsb = 1;",
          "603:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "604:             s->bits_per_raw_sample = 10;",
          "605:     case AV_PIX_FMT_GRAY16:",
          "606:     case AV_PIX_FMT_YUV444P16:",
          "607:     case AV_PIX_FMT_YUV422P16:",
          "608:     case AV_PIX_FMT_YUV420P16:",
          "609:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {",
          "610:             s->bits_per_raw_sample = 16;",
          "611:         } else if (!s->bits_per_raw_sample) {",
          "612:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "613:         }",
          "614:         if (s->bits_per_raw_sample <= 8) {",
          "615:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "616:             return AVERROR_INVALIDDATA;",
          "617:         }",
          "618:         if (!s->ac && avctx->coder_type == -1) {",
          "619:             av_log(avctx, AV_LOG_INFO,",
          "620:                    \"bits_per_raw_sample > 8, forcing coder 1\\n\");",
          "621:             s->ac = 2;",
          "622:         }",
          "623:         if (!s->ac) {",
          "624:             av_log(",
          "625:                 avctx, AV_LOG_ERROR,",
          "626:                 \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "627:             return AVERROR_INVALIDDATA;",
          "628:         }",
          "629:         s->version = FFMAX(s->version, 1);",
          "630:     case AV_PIX_FMT_GRAY8:",
          "631:     case AV_PIX_FMT_YUV444P:",
          "632:     case AV_PIX_FMT_YUV440P:",
          "633:     case AV_PIX_FMT_YUV422P:",
          "634:     case AV_PIX_FMT_YUV420P:",
          "635:     case AV_PIX_FMT_YUV411P:",
          "636:     case AV_PIX_FMT_YUV410P:",
          "637:         s->chroma_planes = desc->nb_components < 3 ? 0 : 1;",
          "638:         s->colorspace    = 0;",
          "639:         break;",
          "640:     case AV_PIX_FMT_YUVA444P:",
          "641:     case AV_PIX_FMT_YUVA422P:",
          "642:     case AV_PIX_FMT_YUVA420P:",
          "643:         s->chroma_planes = 1;",
          "644:         s->colorspace    = 0;",
          "645:         s->transparency  = 1;",
          "646:         break;",
          "647:     case AV_PIX_FMT_RGB32:",
          "648:         s->colorspace   = 1;",
          "649:         s->transparency = 1;",
          "650:         break;",
          "651:     case AV_PIX_FMT_GBRP9:",
          "652:         if (!avctx->bits_per_raw_sample)",
          "653:             s->bits_per_raw_sample = 9;",
          "654:     case AV_PIX_FMT_GBRP10:",
          "655:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "656:             s->bits_per_raw_sample = 10;",
          "657:     case AV_PIX_FMT_GBRP16:",
          "658:         if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)",
          "659:             s->bits_per_raw_sample = 16;",
          "660:         else if (!s->bits_per_raw_sample)",
          "661:             s->bits_per_raw_sample = avctx->bits_per_raw_sample;",
          "662:         s->colorspace    = 1;",
          "663:         s->chroma_planes = 1;",
          "664:         s->version       = FFMAX(s->version, 1);",
          "665:         break;",
          "666:     default:",
          "667:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "668:         return AVERROR_INVALIDDATA;",
          "669:     }",
          "670:     if (s->transparency) {",
          "671:         av_log(",
          "672:             avctx, AV_LOG_WARNING,",
          "673:             \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");",
          "674:     }",
          "675:     if (avctx->context_model > 1U) {",
          "676:         av_log(avctx, AV_LOG_ERROR,",
          "677:                \"Invalid context model %d, valid values are 0 and 1\\n\",",
          "678:                avctx->context_model);",
          "679:         return AVERROR(EINVAL);",
          "680:     }",
          "688:         if (s->bits_per_raw_sample <= 8) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "546:         p->context_count     = s->context_count[p->quant_table_index];",
          "547:     }",
          "552:     avctx->coded_frame = &s->picture;",
          "581:     avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift,",
          "582:                                   &s->chroma_v_shift);",
          "",
          "[Removed Lines]",
          "549:     if (ffv1_allocate_initial_states(s) < 0)",
          "550:         return AVERROR(ENOMEM);",
          "553:     switch (avctx->pix_fmt) {",
          "554:     case AV_PIX_FMT_YUV444P16:",
          "555:     case AV_PIX_FMT_YUV422P16:",
          "556:     case AV_PIX_FMT_YUV420P16:",
          "557:         if (avctx->bits_per_raw_sample <= 8) {",
          "558:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "559:             return AVERROR_INVALIDDATA;",
          "560:         }",
          "561:         if (!s->ac) {",
          "562:             av_log(avctx, AV_LOG_ERROR,",
          "563:                    \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "564:             return AVERROR(ENOSYS);",
          "565:         }",
          "566:         s->version = FFMAX(s->version, 1);",
          "567:     case AV_PIX_FMT_YUV444P:",
          "568:     case AV_PIX_FMT_YUV422P:",
          "569:     case AV_PIX_FMT_YUV420P:",
          "570:     case AV_PIX_FMT_YUV411P:",
          "571:     case AV_PIX_FMT_YUV410P:",
          "572:         s->colorspace = 0;",
          "573:         break;",
          "574:     case AV_PIX_FMT_RGB32:",
          "575:         s->colorspace = 1;",
          "576:         break;",
          "577:     default:",
          "578:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "579:         return AVERROR(ENOSYS);",
          "580:     }",
          "",
          "[Added Lines]",
          "721:     if ((ret = ffv1_allocate_initial_states(s)) < 0)",
          "722:         return ret;",
          "725:     if (!s->transparency)",
          "726:         s->plane_count = 2;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "625:                         }",
          "626:                 }",
          "627:             gob_count = strtol(p, &next, 0);",
          "629:                 av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");",
          "630:                 return AVERROR_INVALIDDATA;",
          "631:             }",
          "",
          "[Removed Lines]",
          "628:             if (next == p || gob_count < 0) {",
          "",
          "[Added Lines]",
          "775:             if (next == p || gob_count <= 0) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "656:     }",
          "658:     if (s->version > 1) {",
          "662:     }",
          "664:     if ((ret = ffv1_init_slice_contexts(s)) < 0)",
          "665:         return ret;",
          "667:         return ret;",
          "669: #define STATS_OUT_SIZE 1024 * 1024 * 6",
          "",
          "[Removed Lines]",
          "659:         s->num_h_slices = 2;",
          "660:         s->num_v_slices = 2;",
          "661:         write_extra_header(s);",
          "666:     if ((ret = ffv1_init_slice_state(s)) < 0)",
          "",
          "[Added Lines]",
          "806:         for (s->num_v_slices = 2; s->num_v_slices < 9; s->num_v_slices++)",
          "807:             for (s->num_h_slices = s->num_v_slices;",
          "808:                  s->num_h_slices < 2 * s->num_v_slices; s->num_h_slices++)",
          "809:                 if (avctx->slices == s->num_h_slices * s->num_v_slices &&",
          "810:                     avctx->slices <= 64 || !avctx->slices)",
          "811:                     goto slices_ok;",
          "812:         av_log(avctx, AV_LOG_ERROR,",
          "813:                \"Unsupported number %d of slices requested, please specify a \"",
          "814:                \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",",
          "815:                avctx->slices);",
          "816:         return AVERROR(ENOSYS);",
          "817: slices_ok:",
          "818:         write_extradata(s);",
          "823:     if ((ret = init_slices_state(s)) < 0)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "683:     return 0;",
          "684: }",
          "686: static int encode_slice(AVCodecContext *c, void *arg)",
          "687: {",
          "688:     FFV1Context *fs  = *(void **)arg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "843: static void encode_slice_header(FFV1Context *f, FFV1Context *fs)",
          "844: {",
          "845:     RangeCoder *c = &fs->c;",
          "846:     uint8_t state[CONTEXT_SIZE];",
          "847:     int j;",
          "848:     memset(state, 128, sizeof(state));",
          "850:     put_symbol(c, state, (fs->slice_x + 1) * f->num_h_slices / f->width, 0);",
          "851:     put_symbol(c, state, (fs->slice_y + 1) * f->num_v_slices / f->height, 0);",
          "852:     put_symbol(c, state, (fs->slice_width + 1) * f->num_h_slices / f->width - 1,",
          "853:                0);",
          "854:     put_symbol(c, state,",
          "855:                (fs->slice_height + 1) * f->num_v_slices / f->height - 1,",
          "856:                0);",
          "857:     for (j = 0; j < f->plane_count; j++) {",
          "858:         put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "859:         av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "860:     }",
          "861:     if (!f->picture.interlaced_frame)",
          "862:         put_symbol(c, state, 3, 0);",
          "863:     else",
          "864:         put_symbol(c, state, 1 + !f->picture.top_field_first, 0);",
          "865:     put_symbol(c, state, f->picture.sample_aspect_ratio.num, 0);",
          "866:     put_symbol(c, state, f->picture.sample_aspect_ratio.den, 0);",
          "867: }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "692:     int x            = fs->slice_x;",
          "693:     int y            = fs->slice_y;",
          "694:     AVFrame *const p = &f->picture;",
          "696:     if (f->colorspace == 0) {",
          "697:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878:     const int ps     = (av_pix_fmt_desc_get(c->pix_fmt)->flags & PIX_FMT_PLANAR)",
          "879:                        ? (f->bits_per_raw_sample > 8) + 1",
          "880:                        : 4;",
          "882:     if (p->key_frame)",
          "883:         ffv1_clear_slice_state(f, fs);",
          "884:     if (f->version > 2) {",
          "885:         encode_slice_header(f, fs);",
          "886:     }",
          "887:     if (!fs->ac) {",
          "888:         if (f->version > 2)",
          "889:             put_rac(&fs->c, (uint8_t[]) { 129 }, 0);",
          "890:         fs->ac_byte_count = f->version > 2 || (!x && !y) ? ff_rac_terminate( &fs->c) : 0;",
          "891:         init_put_bits(&fs->pb, fs->c.bytestream_start + fs->ac_byte_count,",
          "892:                       fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count);",
          "893:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "699:         const int cx            = x >> f->chroma_h_shift;",
          "700:         const int cy            = y >> f->chroma_v_shift;",
          "703:                      width, height, p->linesize[0], 0);",
          "709:     } else {",
          "713:     }",
          "714:     emms_c();",
          "",
          "[Removed Lines]",
          "702:         encode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "705:         encode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "706:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "707:         encode_plane(fs, p->data[2] + cx + cy * p->linesize[2],",
          "708:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "710:         encode_rgb_frame(fs, (uint32_t *)(p->data[0]) +",
          "711:                          x + y * (p->linesize[0] / 4),",
          "712:                          width, height, p->linesize[0] / 4);",
          "",
          "[Added Lines]",
          "901:         encode_plane(fs, p->data[0] + ps * x + y * p->linesize[0],",
          "904:         if (f->chroma_planes) {",
          "905:             encode_plane(fs, p->data[1] + ps * cx + cy * p->linesize[1],",
          "906:                          chroma_width, chroma_height, p->linesize[1], 1);",
          "907:             encode_plane(fs, p->data[2] + ps * cx + cy * p->linesize[2],",
          "908:                          chroma_width, chroma_height, p->linesize[2], 1);",
          "909:         }",
          "910:         if (fs->transparency)",
          "911:             encode_plane(fs, p->data[3] + ps * x + y * p->linesize[3], width,",
          "912:                          height, p->linesize[3], 2);",
          "914:         uint8_t *planes[3] = { p->data[0] + ps * x + y * p->linesize[0],",
          "915:                                p->data[1] + ps * x + y * p->linesize[1],",
          "916:                                p->data[2] + ps * x + y * p->linesize[2] };",
          "917:         encode_rgb_frame(fs, planes, width, height, p->linesize);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "717: }",
          "719: static int ffv1_encode_frame(AVCodecContext *avctx, AVPacket *pkt,",
          "721: {",
          "722:     FFV1Context *f      = avctx->priv_data;",
          "723:     RangeCoder *const c = &f->slice_context[0]->c;",
          "",
          "[Removed Lines]",
          "720:                              const AVFrame *pict, int *got_packet)",
          "",
          "[Added Lines]",
          "925:                         const AVFrame *pict, int *got_packet)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "727:     uint8_t *buf_p;",
          "728:     int i, ret;",
          "733:         av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");",
          "734:         return ret;",
          "735:     }",
          "",
          "[Removed Lines]",
          "730:     if (!pkt->data &&",
          "731:         (ret = av_new_packet(pkt, avctx->width * avctx->height *",
          "732:                              ((8 * 2 + 1 + 1) * 4) / 8 + FF_MIN_BUFFER_SIZE)) < 0) {",
          "",
          "[Added Lines]",
          "935:     if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height *",
          "936:                              ((8 * 2 + 1 + 1) * 4) / 8 +",
          "937:                              FF_MIN_BUFFER_SIZE)) < 0) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "745:         p->key_frame = 1;",
          "746:         f->gob_count++;",
          "747:         write_header(f);",
          "749:     } else {",
          "750:         put_rac(c, &keystate, 0);",
          "751:         p->key_frame = 0;",
          "752:     }",
          "759:         int i;",
          "760:         for (i = 1; i < 256; i++) {",
          "761:             c->one_state[i]        = f->state_transition[i];",
          "",
          "[Removed Lines]",
          "748:         ffv1_clear_state(f);",
          "754:     if (!f->ac) {",
          "755:         used_count += ff_rac_terminate(c);",
          "756:         init_put_bits(&f->slice_context[0]->pb, pkt->data + used_count,",
          "757:                       pkt->size - used_count);",
          "758:     } else if (f->ac > 1) {",
          "",
          "[Added Lines]",
          "958:     if (f->ac > 1) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "766:     for (i = 1; i < f->slice_count; i++) {",
          "767:         FFV1Context *fs = f->slice_context[i];",
          "775:     }",
          "776:     avctx->execute(avctx, encode_slice, &f->slice_context[0], NULL,",
          "777:                    f->slice_count, sizeof(void *));",
          "",
          "[Removed Lines]",
          "768:         uint8_t *start  = pkt->data + (pkt->size - used_count) * i / f->slice_count;",
          "769:         int len         = pkt->size / f->slice_count;",
          "771:         if (fs->ac)",
          "772:             ff_init_range_encoder(&fs->c, start, len);",
          "773:         else",
          "774:             init_put_bits(&fs->pb, start, len);",
          "",
          "[Added Lines]",
          "968:         uint8_t *start  = pkt->data +",
          "969:                           (pkt->size - used_count) * (int64_t)i / f->slice_count;",
          "970:         int len = pkt->size / f->slice_count;",
          "971:         ff_init_range_encoder(&fs->c, start, len);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "782:         int bytes;",
          "784:         if (fs->ac) {",
          "786:             put_rac(&fs->c, &state, 0);",
          "787:             bytes = ff_rac_terminate(&fs->c);",
          "788:         } else {",
          "789:             flush_put_bits(&fs->pb); // FIXME: nicer padding",
          "792:         }",
          "794:             av_assert0(bytes < pkt->size / f->slice_count);",
          "796:             av_assert0(bytes < (1 << 24));",
          "797:             AV_WB24(buf_p + bytes, bytes);",
          "798:             bytes += 3;",
          "799:         }",
          "800:         buf_p += bytes;",
          "801:     }",
          "",
          "[Removed Lines]",
          "785:             uint8_t state = 128;",
          "790:             bytes      = used_count + (put_bits_count(&fs->pb) + 7) / 8;",
          "791:             used_count = 0;",
          "793:         if (i > 0) {",
          "795:             memmove(buf_p, fs->ac ? fs->c.bytestream_start : fs->pb.buf, bytes);",
          "",
          "[Added Lines]",
          "982:             uint8_t state = 129;",
          "987:             bytes = fs->ac_byte_count + (put_bits_count(&fs->pb) + 7) / 8;",
          "989:         if (i > 0 || f->version > 2) {",
          "991:             memmove(buf_p, fs->c.bytestream_start, bytes);",
          "996:         if (f->ec) {",
          "997:             unsigned v;",
          "998:             buf_p[bytes++] = 0;",
          "999:             v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, bytes);",
          "1000:             AV_WL32(buf_p + bytes, v);",
          "1001:             bytes += 4;",
          "1002:         }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "851:     return 0;",
          "852: }",
          "854: AVCodec ff_ffv1_encoder = {",
          "855:     .name           = \"ffv1\",",
          "856:     .type           = AVMEDIA_TYPE_VIDEO,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1057: #define OFFSET(x) offsetof(FFV1Context, x)",
          "1058: #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM",
          "1059: static const AVOption options[] = {",
          "1060:     { \"slicecrc\", \"Protect slices with CRCs\", OFFSET(ec), AV_OPT_TYPE_INT,",
          "1061:              { .i64 = -1 }, -1, 1, VE },",
          "1062:     { NULL }",
          "1063: };",
          "1065: static const AVClass class = {",
          "1066:     .class_name = \"ffv1 encoder\",",
          "1067:     .item_name  = av_default_item_name,",
          "1068:     .option     = options,",
          "1069:     .version    = LIBAVUTIL_VERSION_INT,",
          "1070: };",
          "1072: static const AVCodecDefault ffv1_defaults[] = {",
          "1073:     { \"coder\", \"-1\" },",
          "1074:     { NULL },",
          "1075: };",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "863:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "864:         AV_PIX_FMT_YUV420P,   AV_PIX_FMT_YUV422P,   AV_PIX_FMT_YUV444P,",
          "865:         AV_PIX_FMT_YUV411P,   AV_PIX_FMT_YUV410P,",
          "866:         AV_PIX_FMT_YUV420P16, AV_PIX_FMT_YUV422P16, AV_PIX_FMT_YUV444P16,",
          "867:         AV_PIX_FMT_RGB32,",
          "868:         AV_PIX_FMT_NONE",
          "869:     },",
          "870:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "871: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1089:         AV_PIX_FMT_YUV444P9,  AV_PIX_FMT_YUV422P9,  AV_PIX_FMT_YUV420P9,",
          "1090:         AV_PIX_FMT_YUV420P10, AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV444P10,",
          "1093:         AV_PIX_FMT_GBRP9,     AV_PIX_FMT_GBRP10,",
          "1094:         AV_PIX_FMT_YUVA420P,  AV_PIX_FMT_YUVA422P,  AV_PIX_FMT_YUVA444P,",
          "1095:         AV_PIX_FMT_GRAY16,    AV_PIX_FMT_GRAY8,",
          "1100:     .defaults       = ffv1_defaults,",
          "1101:     .priv_class     = &class,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f",
      "candidate_info": {
        "commit_hash": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b05cd1ea7e45a836f7f6071a716c38bb30326e0f",
        "files": [
          "libavcodec/ffv1dec.c"
        ],
        "message": "ffv1dec: Check bits_per_raw_sample and colorspace for equality in ver 0/1 headers\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "580:     memset(state, 128, sizeof(state));",
          "582:     if (f->version < 2) {",
          "584:         unsigned v= get_symbol(c, state, 0);",
          "585:         if (v >= 2) {",
          "586:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
          "",
          "[Removed Lines]",
          "583:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;",
          "",
          "[Added Lines]",
          "583:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "593:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "594:         }",
          "601:         chroma_planes  = get_rac(c, state);",
          "602:         chroma_h_shift = get_symbol(c, state, 0);",
          "603:         chroma_v_shift = get_symbol(c, state, 0);",
          "604:         transparency   = get_rac(c, state);",
          "606:         if (f->plane_count) {",
          "608:                 || chroma_h_shift!= f->chroma_h_shift",
          "609:                 || chroma_v_shift!= f->chroma_v_shift",
          "610:                 || transparency  != f->transparency) {",
          "",
          "[Removed Lines]",
          "596:         f->colorspace = get_symbol(c, state, 0); //YUV cs type",
          "598:         if (f->version > 0)",
          "599:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "607:             if (   chroma_planes != f->chroma_planes",
          "",
          "[Added Lines]",
          "596:         colorspace     = get_symbol(c, state, 0); //YUV cs type",
          "597:         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;",
          "604:             if (   colorspace    != f->colorspace",
          "605:                 || bits_per_raw_sample != f->avctx->bits_per_raw_sample",
          "606:                 || chroma_planes != f->chroma_planes",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "613:             }",
          "614:         }",
          "616:         f->chroma_planes  = chroma_planes;",
          "617:         f->chroma_h_shift = chroma_h_shift;",
          "618:         f->chroma_v_shift = chroma_v_shift;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "615:         f->colorspace     = colorspace;",
          "616:         f->avctx->bits_per_raw_sample = bits_per_raw_sample;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
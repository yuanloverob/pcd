{
  "cve_id": "CVE-2014-7841",
  "cve_desc": "The sctp_process_param function in net/sctp/sm_make_chunk.c in the SCTP implementation in the Linux kernel before 3.17.4, when ASCONF is used, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via a malformed INIT chunk.",
  "repo": "torvalds/linux",
  "patch_hash": "e40607cbe270a9e8360907cb1e62ddf0736e4864",
  "patch_info": {
    "commit_hash": "e40607cbe270a9e8360907cb1e62ddf0736e4864",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e40607cbe270a9e8360907cb1e62ddf0736e4864",
    "files": [
      "net/sctp/sm_make_chunk.c"
    ],
    "message": "net: sctp: fix NULL pointer dereference in af->from_addr_param on malformed packet\n\nAn SCTP server doing ASCONF will panic on malformed INIT ping-of-death\nin the form of:\n\n  ------------ INIT[PARAM: SET_PRIMARY_IP] ------------>\n\nWhile the INIT chunk parameter verification dissects through many things\nin order to detect malformed input, it misses to actually check parameters\ninside of parameters. E.g. RFC5061, section 4.2.4 proposes a 'set primary\nIP address' parameter in ASCONF, which has as a subparameter an address\nparameter.\n\nSo an attacker may send a parameter type other than SCTP_PARAM_IPV4_ADDRESS\nor SCTP_PARAM_IPV6_ADDRESS, param_type2af() will subsequently return 0\nand thus sctp_get_af_specific() returns NULL, too, which we then happily\ndereference unconditionally through af->from_addr_param().\n\nThe trace for the log:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000078\nIP: [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]\nPGD 0\nOops: 0000 [#1] SMP\n[...]\nPid: 0, comm: swapper Not tainted 2.6.32-504.el6.x86_64 #1 Bochs Bochs\nRIP: 0010:[<ffffffffa01e9c62>]  [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]\n[...]\nCall Trace:\n <IRQ>\n [<ffffffffa01f2add>] ? sctp_bind_addr_copy+0x5d/0xe0 [sctp]\n [<ffffffffa01e1fcb>] sctp_sf_do_5_1B_init+0x21b/0x340 [sctp]\n [<ffffffffa01e3751>] sctp_do_sm+0x71/0x1210 [sctp]\n [<ffffffffa01e5c09>] ? sctp_endpoint_lookup_assoc+0xc9/0xf0 [sctp]\n [<ffffffffa01e61f6>] sctp_endpoint_bh_rcv+0x116/0x230 [sctp]\n [<ffffffffa01ee986>] sctp_inq_push+0x56/0x80 [sctp]\n [<ffffffffa01fcc42>] sctp_rcv+0x982/0xa10 [sctp]\n [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23/0x28 [iptable_filter]\n [<ffffffff8148bdc9>] ? nf_iterate+0x69/0xb0\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0\n [<ffffffff8148bf86>] ? nf_hook_slow+0x76/0x120\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0\n[...]\n\nA minimal way to address this is to check for NULL as we do on all\nother such occasions where we know sctp_get_af_specific() could\npossibly return with NULL.\n\nFixes: d6de3097592b (\"[SCTP]: Add the handling of \"Set Primary IP Address\" parameter to INIT\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/sctp/sm_make_chunk.c||net/sctp/sm_make_chunk.c"
    ]
  },
  "patch_diff": {
    "net/sctp/sm_make_chunk.c||net/sctp/sm_make_chunk.c": [
      "File: net/sctp/sm_make_chunk.c -> net/sctp/sm_make_chunk.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2609:   addr_param = param.v + sizeof(sctp_addip_param_t);",
      "2611:   af = sctp_get_af_specific(param_type2af(param.p->type));",
      "2612:   af->from_addr_param(&addr, addr_param,",
      "2613:         htons(asoc->peer.port), 0);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2612:   if (af == NULL)",
      "2613:    break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "41fb96a4b619afd2272acb6e981a7581efa8e118",
      "candidate_info": {
        "commit_hash": "41fb96a4b619afd2272acb6e981a7581efa8e118",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/41fb96a4b619afd2272acb6e981a7581efa8e118",
        "files": [
          "lib/kobject.c"
        ],
        "message": "kobject: fix NULL pointer derefernce in kobj_child_ns_ops\n\nWe will hit NULL pointer dereference if we call\nplatform_device_register_simple or platform_device_add at very early\nstage. I have observed following crash when called platform_device_add\nfrom \"init_irq\" hook of machine_desc. This patch fixes this issue and\nlet system handle this case gracefully instead of kernel panic.\n\n[0.000000] Unable to handle kernel NULL pointer dereference at\nvirtual address 0000000c\n[0.000000] pgd = c0004000\n[0.000000] [0000000c] *pgd=00000000\n[0.000000] Internal error: Oops: 5 [#1] PREEMPT ARM\n[0.000000] Modules linked in:\n[0.000000] CPU: 0 PID: 0 Comm: swapper Tainted: G        W 3.17.0-rc6-00198-ga1603f1-dirty #319\n[0.000000] task: c05b23f0 ti: c05a8000 task.ti: c05a8000\n[0.000000] PC is at kobject_namespace+0x18/0x58\n[0.000000] LR is at kobject_add_internal+0x90/0x2ec\n[snip]\n[0.000000] [<c01b1df0>] (kobject_namespace) from [<c01b2338>] (kobject_add_internal+0x90/0x2ec)\n[0.000000] [<c01b2338>] (kobject_add_internal) from [<c01b2728>] (kobject_add+0x4c/0x98)\n[0.000000] [<c01b2728>] (kobject_add) from [<c0226274>] (device_add+0xe8/0x51c)\n[0.000000] [<c0226274>] (device_add) from [<c0229c70>] (platform_device_add+0xb4/0x214)\n[0.000000] [<c0229c70>] (platform_device_add) from [<c022a338>] (platform_device_register_full+0xb8/0xdc)\n[0.000000] [<c022a338>] (platform_device_register_full) from [<c0570214>] (exynos_init_irq+0x90/0x9c)\n[0.000000] [<c0570214>] (exynos_init_irq) from [<c056c18c>] (init_IRQ+0x2c/0x78)\n[0.000000] [<c056c18c>] (init_IRQ) from [<c0569a54>] (start_kernel+0x22c/0x378)\n[0.000000] [<c0569a54>] (start_kernel) from [<40008070>] (0x40008070)\n[0.000000] Code: e590000c e3500000 0a00000e e5903014 (e593300c)\n\nSigned-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "lib/kobject.c||lib/kobject.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/kobject.c||lib/kobject.c": [
          "File: lib/kobject.c -> lib/kobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "976: {",
          "977:  const struct kobj_ns_type_operations *ops = NULL;",
          "980:   ops = parent->ktype->child_ns_type(parent);",
          "982:  return ops;",
          "",
          "[Removed Lines]",
          "979:  if (parent && parent->ktype->child_ns_type)",
          "",
          "[Added Lines]",
          "979:  if (parent && parent->ktype && parent->ktype->child_ns_type)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f668f074ff58dea540d83bbed1b2c1171b0dd764",
      "candidate_info": {
        "commit_hash": "f668f074ff58dea540d83bbed1b2c1171b0dd764",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f668f074ff58dea540d83bbed1b2c1171b0dd764",
        "files": [
          "drivers/irqchip/irq-bcm7120-l2.c"
        ],
        "message": "irqchip: bcm7120-l2: Eliminate bad IRQ check\n\nThis check may be prone to race conditions, e.g.\n\n1) Some external event (e.g. GPIO level) causes an IRQ to become pending\n2) Peripheral asserts the L2 IRQ\n3) CPU takes an interrupt\n4) The event from #1 goes away\n5) bcm7120_l2_intc_irq_handle() reads back a 0 status\n\nUnlike the hardware supported by brcmstb-l2, the bcm7120-l2 controller\ndoes not latch the IRQ status.  Bits can change if the inputs to the\ncontroller change.  Also, do_bad_IRQ() is an ARM-specific macro.\n\nSo let's just nuke it.\n\nSigned-off-by: Kevin Cernekee <cernekee@gmail.com>\nAcked-by: Florian Fainelli <f.fainelli@gmail.com>\nAcked-by: Arnd Bergmann <arnd@arndb.de>\nLink: https://lkml.kernel.org/r/1415342669-30640-7-git-send-email-cernekee@gmail.com\nSigned-off-by: Jason Cooper <jason@lakedaemon.net>",
        "before_after_code_files": [
          "drivers/irqchip/irq-bcm7120-l2.c||drivers/irqchip/irq-bcm7120-l2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/irqchip/irq-bcm7120-l2.c||drivers/irqchip/irq-bcm7120-l2.c": [
          "File: drivers/irqchip/irq-bcm7120-l2.c -> drivers/irqchip/irq-bcm7120-l2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include \"irqchip.h\"",
          "33: #define IRQEN  0x00",
          "34: #define IRQSTAT  0x04",
          "",
          "[Removed Lines]",
          "30: #include <asm/mach/irq.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51:  chained_irq_enter(chip, desc);",
          "53:  status = __raw_readl(b->base + IRQSTAT);",
          "61:   irq = ffs(status) - 1;",
          "62:   status &= ~(1 << irq);",
          "63:   generic_handle_irq(irq_find_mapping(b->domain, irq));",
          "67:  chained_irq_exit(chip, desc);",
          "68: }",
          "",
          "[Removed Lines]",
          "55:  if (status == 0) {",
          "56:   do_bad_IRQ(irq, desc);",
          "57:   goto out;",
          "58:  }",
          "60:  do {",
          "64:  } while (status);",
          "66: out:",
          "",
          "[Added Lines]",
          "52:  while (status) {",
          "56:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "95069ac8da4975120ba76e968fc72948582c3509",
      "candidate_info": {
        "commit_hash": "95069ac8da4975120ba76e968fc72948582c3509",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/95069ac8da4975120ba76e968fc72948582c3509",
        "files": [
          "mm/slab_common.c"
        ],
        "message": "mm/slab: fix unalignment problem on Malta with EVA due to slab merge\n\nUnlike SLUB, sometimes, object isn't started at the beginning of the\nslab in SLAB.  This causes the unalignment problem after slab merging is\nsupported by commit 12220dea07f1 (\"mm/slab: support slab merge\").\n\nFollowing is the report from Markos that fail to boot on Malta with EVA.\n\n    Calibrating delay loop... 19.86 BogoMIPS (lpj=99328)\n    pid_max: default: 32768 minimum: 301\n    Mount-cache hash table entries: 4096 (order: 0, 16384 bytes)\n    Mountpoint-cache hash table entries: 4096 (order: 0, 16384 bytes)\n    Kernel bug detected[#1]:\n    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.17.0-05639-g12220dea07f1 #1631\n    task: 1f04f5d8 ti: 1f050000 task.ti: 1f050000\n    epc   : 80141190 alloc_unbound_pwq+0x234/0x304\n        Not tainted\n    ra    : 80141184 alloc_unbound_pwq+0x228/0x304\n    Process swapper/0 (pid: 1, threadinfo=1f050000, task=1f04f5d8, tls=00000000)\n    Call Trace:\n      alloc_unbound_pwq+0x234/0x304\n      apply_workqueue_attrs+0x11c/0x294\n      __alloc_workqueue_key+0x23c/0x470\n      init_workqueues+0x320/0x400\n      do_one_initcall+0xe8/0x23c\n      kernel_init_freeable+0x9c/0x224\n      kernel_init+0x10/0x100\n      ret_from_kernel_thread+0x14/0x1c\n    [ end trace cb88537fdc8fa200 ]\n    Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\n\nalloc_unbound_pwq() allocates slab object from pool_workqueue.  This\nkmem_cache requires 256 bytes alignment, but, current merging code\ndoesn't honor that, and merge it with kmalloc-256.  kmalloc-256 requires\nonly cacheline size alignment so that above failure occurs.  However, in\nx86, kmalloc-256 is luckily aligned in 256 bytes, so the problem didn't\nhappen on it.\n\nTo fix this problem, this patch introduces alignment mismatch check in\nfind_mergeable().  This will fix the problem.\n\nSigned-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nReported-by: Markos Chandras <Markos.Chandras@imgtec.com>\nTested-by: Markos Chandras <Markos.Chandras@imgtec.com>\nAcked-by: Christoph Lameter <cl@linux.com>\nCc: Pekka Enberg <penberg@kernel.org>\nCc: David Rientjes <rientjes@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/slab_common.c||mm/slab_common.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/slab_common.c||mm/slab_common.c": [
          "File: mm/slab_common.c -> mm/slab_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "259:   if (s->size - size >= sizeof(void *))",
          "260:    continue;",
          "262:   return s;",
          "263:  }",
          "264:  return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "262:   if (IS_ENABLED(CONFIG_SLAB) && align &&",
          "263:    (align > s->align || s->align % align))",
          "264:    continue;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b3ecba096729f521312d1863ad22530695527aed",
      "candidate_info": {
        "commit_hash": "b3ecba096729f521312d1863ad22530695527aed",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b3ecba096729f521312d1863ad22530695527aed",
        "files": [
          "net/sunrpc/auth_gss/auth_gss.c"
        ],
        "message": "sunrpc: fix sleeping under rcu_read_lock in gss_stringify_acceptor\n\nBruce reported that he was seeing the following BUG pop:\n\n    BUG: sleeping function called from invalid context at mm/slab.c:2846\n    in_atomic(): 0, irqs_disabled(): 0, pid: 4539, name: mount.nfs\n    2 locks held by mount.nfs/4539:\n    #0:  (nfs_clid_init_mutex){+.+.+.}, at: [<ffffffffa01c0a9a>] nfs4_discover_server_trunking+0x4a/0x2f0 [nfsv4]\n    #1:  (rcu_read_lock){......}, at: [<ffffffffa00e3185>] gss_stringify_acceptor+0x5/0xb0 [auth_rpcgss]\n    Preemption disabled at:[<ffffffff81a4f082>] printk+0x4d/0x4f\n\n    CPU: 3 PID: 4539 Comm: mount.nfs Not tainted 3.18.0-rc1-00013-g5b095e9 #3393\n    Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011\n    ffff880021499390 ffff8800381476a8 ffffffff81a534cf 0000000000000001\n    0000000000000000 ffff8800381476c8 ffffffff81097854 00000000000000d0\n    0000000000000018 ffff880038147718 ffffffff8118e4f3 0000000020479f00\n    Call Trace:\n    [<ffffffff81a534cf>] dump_stack+0x4f/0x7c\n    [<ffffffff81097854>] __might_sleep+0x114/0x180\n    [<ffffffff8118e4f3>] __kmalloc+0x1a3/0x280\n    [<ffffffffa00e31d8>] gss_stringify_acceptor+0x58/0xb0 [auth_rpcgss]\n    [<ffffffffa00e3185>] ? gss_stringify_acceptor+0x5/0xb0 [auth_rpcgss]\n    [<ffffffffa006b438>] rpcauth_stringify_acceptor+0x18/0x30 [sunrpc]\n    [<ffffffffa01b0469>] nfs4_proc_setclientid+0x199/0x380 [nfsv4]\n    [<ffffffffa01b04d0>] ? nfs4_proc_setclientid+0x200/0x380 [nfsv4]\n    [<ffffffffa01bdf1a>] nfs40_discover_server_trunking+0xda/0x150 [nfsv4]\n    [<ffffffffa01bde45>] ? nfs40_discover_server_trunking+0x5/0x150 [nfsv4]\n    [<ffffffffa01c0acf>] nfs4_discover_server_trunking+0x7f/0x2f0 [nfsv4]\n    [<ffffffffa01c8e24>] nfs4_init_client+0x104/0x2f0 [nfsv4]\n    [<ffffffffa01539b4>] nfs_get_client+0x314/0x3f0 [nfs]\n    [<ffffffffa0153780>] ? nfs_get_client+0xe0/0x3f0 [nfs]\n    [<ffffffffa01c83aa>] nfs4_set_client+0x8a/0x110 [nfsv4]\n    [<ffffffffa0069708>] ? __rpc_init_priority_wait_queue+0xa8/0xf0 [sunrpc]\n    [<ffffffffa01c9b2f>] nfs4_create_server+0x12f/0x390 [nfsv4]\n    [<ffffffffa01c1472>] nfs4_remote_mount+0x32/0x60 [nfsv4]\n    [<ffffffff81196489>] mount_fs+0x39/0x1b0\n    [<ffffffff81166145>] ? __alloc_percpu+0x15/0x20\n    [<ffffffff811b276b>] vfs_kern_mount+0x6b/0x150\n    [<ffffffffa01c1396>] nfs_do_root_mount+0x86/0xc0 [nfsv4]\n    [<ffffffffa01c1784>] nfs4_try_mount+0x44/0xc0 [nfsv4]\n    [<ffffffffa01549b7>] ? get_nfs_version+0x27/0x90 [nfs]\n    [<ffffffffa0161a2d>] nfs_fs_mount+0x47d/0xd60 [nfs]\n    [<ffffffff81a59c5e>] ? mutex_unlock+0xe/0x10\n    [<ffffffffa01606a0>] ? nfs_remount+0x430/0x430 [nfs]\n    [<ffffffffa01609c0>] ? nfs_clone_super+0x140/0x140 [nfs]\n    [<ffffffff81196489>] mount_fs+0x39/0x1b0\n    [<ffffffff81166145>] ? __alloc_percpu+0x15/0x20\n    [<ffffffff811b276b>] vfs_kern_mount+0x6b/0x150\n    [<ffffffff811b5830>] do_mount+0x210/0xbe0\n    [<ffffffff811b54ca>] ? copy_mount_options+0x3a/0x160\n    [<ffffffff811b651f>] SyS_mount+0x6f/0xb0\n    [<ffffffff81a5c852>] system_call_fastpath+0x12/0x17\n\nSleeping under the rcu_read_lock is bad. This patch fixes it by dropping\nthe rcu_read_lock before doing the allocation and then reacquiring it\nand redoing the dereference before doing the copy. If we find that the\nstring has somehow grown in the meantime, we'll reallocate and try again.\n\nCc: <stable@vger.kernel.org> # v3.17+\nReported-by: \"J. Bruce Fields\" <bfields@fieldses.org>\nSigned-off-by: Jeff Layton <jlayton@primarydata.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>",
        "before_after_code_files": [
          "net/sunrpc/auth_gss/auth_gss.c||net/sunrpc/auth_gss/auth_gss.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sunrpc/auth_gss/auth_gss.c||net/sunrpc/auth_gss/auth_gss.c": [
          "File: net/sunrpc/auth_gss/auth_gss.c -> net/sunrpc/auth_gss/auth_gss.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1353:  char *string = NULL;",
          "1354:  struct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);",
          "1355:  struct gss_cl_ctx *ctx;",
          "1356:  struct xdr_netobj *acceptor;",
          "1358:  rcu_read_lock();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1356:  unsigned int len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1360:  if (!ctx)",
          "1361:   goto out;",
          "1370:  if (!string)",
          "1371:   goto out;",
          "1373:  memcpy(string, acceptor->data, acceptor->len);",
          "1374:  string[acceptor->len] = '\\0';",
          "",
          "[Removed Lines]",
          "1363:  acceptor = &ctx->gc_acceptor;",
          "1366:  if (!acceptor->len)",
          "1367:   goto out;",
          "1369:  string = kmalloc(acceptor->len + 1, GFP_KERNEL);",
          "",
          "[Added Lines]",
          "1364:  len = ctx->gc_acceptor.len;",
          "1365:  rcu_read_unlock();",
          "1368:  if (!len)",
          "1369:   return NULL;",
          "1370: realloc:",
          "1371:  string = kmalloc(len + 1, GFP_KERNEL);",
          "1373:   return NULL;",
          "1375:  rcu_read_lock();",
          "1376:  ctx = rcu_dereference(gss_cred->gc_ctx);",
          "1379:  if (!ctx || !ctx->gc_acceptor.len) {",
          "1380:   kfree(string);",
          "1381:   string = NULL;",
          "1383:  }",
          "1385:  acceptor = &ctx->gc_acceptor;",
          "1391:  if (len < acceptor->len) {",
          "1392:   len = acceptor->len;",
          "1393:   rcu_read_unlock();",
          "1394:   kfree(string);",
          "1395:   goto realloc;",
          "1396:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e4a60d139060975eb956717e4f63ae348d4d8cc5",
      "candidate_info": {
        "commit_hash": "e4a60d139060975eb956717e4f63ae348d4d8cc5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e4a60d139060975eb956717e4f63ae348d4d8cc5",
        "files": [
          "drivers/base/core.c"
        ],
        "message": "sysfs: driver core: Fix glue dir race condition by gdp_mutex\n\nThere is a race condition when removing glue directory.\nIt can be reproduced in following test:\n\npath 1: Add first child device\ndevice_add()\n    get_device_parent()\n            /*find parent from glue_dirs.list*/\n            list_for_each_entry(k, &dev->class->p->glue_dirs.list, entry)\n                    if (k->parent == parent_kobj) {\n                            kobj = kobject_get(k);\n                            break;\n                    }\n            ....\n            class_dir_create_and_add()\n\npath2: Remove last child device under glue dir\ndevice_del()\n    cleanup_device_parent()\n            cleanup_glue_dir()\n                    kobject_put(glue_dir);\n\nIf path2 has been called cleanup_glue_dir(), but not\ncall kobject_put(glue_dir), the glue dir is still\nin parent's kset list. Meanwhile, path1 find the glue\ndir from the glue_dirs.list. Path2 may release glue dir\nbefore path1 call kobject_get(). So kernel will report\nthe warning and bug_on.\n\nThis is a \"classic\" problem we have of a kref in a list\nthat can be found while the last instance could be removed\nat the same time.\n\nThis patch reuse gdp_mutex to fix this race condition.\n\nThe following calltrace is captured in kernel 3.4, but\nthe latest kernel still has this bug.\n\n-----------------------------------------------------\n<4>[ 3965.441471] WARNING: at ...include/linux/kref.h:41 kobject_get+0x33/0x40()\n<4>[ 3965.441474] Hardware name: Romley\n<4>[ 3965.441475] Modules linked in: isd_iop(O) isd_xda(O)...\n...\n<4>[ 3965.441605] Call Trace:\n<4>[ 3965.441611]  [<ffffffff8103717a>] warn_slowpath_common+0x7a/0xb0\n<4>[ 3965.441615]  [<ffffffff810371c5>] warn_slowpath_null+0x15/0x20\n<4>[ 3965.441618]  [<ffffffff81215963>] kobject_get+0x33/0x40\n<4>[ 3965.441624]  [<ffffffff812d1e45>] get_device_parent.isra.11+0x135/0x1f0\n<4>[ 3965.441627]  [<ffffffff812d22d4>] device_add+0xd4/0x6d0\n<4>[ 3965.441631]  [<ffffffff812d0dbc>] ? dev_set_name+0x3c/0x40\n....\n<2>[ 3965.441912] kernel BUG at ..../fs/sysfs/group.c:65!\n<4>[ 3965.441915] invalid opcode: 0000 [#1] SMP\n...\n<4>[ 3965.686743]  [<ffffffff811a677e>] sysfs_create_group+0xe/0x10\n<4>[ 3965.686748]  [<ffffffff810cfb04>] blk_trace_init_sysfs+0x14/0x20\n<4>[ 3965.686753]  [<ffffffff811fcabb>] blk_register_queue+0x3b/0x120\n<4>[ 3965.686756]  [<ffffffff812030bc>] add_disk+0x1cc/0x490\n....\n-------------------------------------------------------\n\nSigned-off-by: Yijing Wang <wangyijing@huawei.com>\nSigned-off-by: Weng Meiling <wengmeiling.weng@huawei.com>\nCc: <stable@vger.kernel.org> #3.4+\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/base/core.c||drivers/base/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/base/core.c||drivers/base/core.c": [
          "File: drivers/base/core.c -> drivers/base/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "724:  return &dir->kobj;",
          "725: }",
          "728: static struct kobject *get_device_parent(struct device *dev,",
          "729:       struct device *parent)",
          "730: {",
          "731:  if (dev->class) {",
          "733:   struct kobject *kobj = NULL;",
          "734:   struct kobject *parent_kobj;",
          "735:   struct kobject *k;",
          "",
          "[Removed Lines]",
          "732:   static DEFINE_MUTEX(gdp_mutex);",
          "",
          "[Added Lines]",
          "727: static DEFINE_MUTEX(gdp_mutex);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "793:      glue_dir->kset != &dev->class->p->glue_dirs)",
          "794:   return;",
          "796:  kobject_put(glue_dir);",
          "797: }",
          "799: static void cleanup_device_parent(struct device *dev)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "796:  mutex_lock(&gdp_mutex);",
          "798:  mutex_unlock(&gdp_mutex);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
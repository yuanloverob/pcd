{
  "cve_id": "CVE-2013-1796",
  "cve_desc": "The kvm_set_msr_common function in arch/x86/kvm/x86.c in the Linux kernel through 3.8.4 does not ensure a required time_page alignment during an MSR_KVM_SYSTEM_TIME operation, which allows guest OS users to cause a denial of service (buffer overflow and host OS memory corruption) or possibly have unspecified other impact via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "c300aa64ddf57d9c5d9c898a64b36877345dd4a9",
  "patch_info": {
    "commit_hash": "c300aa64ddf57d9c5d9c898a64b36877345dd4a9",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c300aa64ddf57d9c5d9c898a64b36877345dd4a9",
    "files": [
      "arch/x86/kvm/x86.c"
    ],
    "message": "KVM: x86: fix for buffer overflow in handling of MSR_KVM_SYSTEM_TIME (CVE-2013-1796)\n\nIf the guest sets the GPA of the time_page so that the request to update the\ntime straddles a page then KVM will write onto an incorrect page.  The\nwrite is done byusing kmap atomic to get a pointer to the page for the time\nstructure and then performing a memcpy to that page starting at an offset\nthat the guest controls.  Well behaved guests always provide a 32-byte aligned\naddress, however a malicious guest could use this to corrupt host kernel\nmemory.\n\nTested: Tested against kvmclock unit test.\n\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c": [
      "File: arch/x86/kvm/x86.c -> arch/x86/kvm/x86.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1960:   vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);",
      "1962:   vcpu->arch.time_page =",
      "1963:     gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1963:   if (vcpu->arch.time_offset &",
      "1964:     (sizeof(struct pvclock_vcpu_time_info) - 1))",
      "1965:    break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0b79459b482e85cb7426aa7da683a9f2c97aeae1",
      "candidate_info": {
        "commit_hash": "0b79459b482e85cb7426aa7da683a9f2c97aeae1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1",
        "files": [
          "arch/x86/include/asm/kvm_host.h",
          "arch/x86/kvm/x86.c"
        ],
        "message": "KVM: x86: Convert MSR_KVM_SYSTEM_TIME to use gfn_to_hva_cache functions (CVE-2013-1797)\n\nThere is a potential use after free issue with the handling of\nMSR_KVM_SYSTEM_TIME.  If the guest specifies a GPA in a movable or removable\nmemory such as frame buffers then KVM might continue to write to that\naddress even after it's removed via KVM_SET_USER_MEMORY_REGION.  KVM pins\nthe page in memory so it's unlikely to cause an issue, but if the user\nspace component re-purposes the memory previously used for the guest, then\nthe guest will be able to corrupt that memory.\n\nTested: Tested against kvmclock unit test\n\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
        "before_after_code_files": [
          "arch/x86/include/asm/kvm_host.h||arch/x86/include/asm/kvm_host.h",
          "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
          ],
          "candidate": [
            "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/include/asm/kvm_host.h||arch/x86/include/asm/kvm_host.h": [
          "File: arch/x86/include/asm/kvm_host.h -> arch/x86/include/asm/kvm_host.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "414:  gpa_t time;",
          "415:  struct pvclock_vcpu_time_info hv_clock;",
          "416:  unsigned int hw_tsc_khz;",
          "420:  bool pvclock_set_guest_stopped_request;",
          "",
          "[Removed Lines]",
          "417:  unsigned int time_offset;",
          "418:  struct page *time_page;",
          "",
          "[Added Lines]",
          "417:  struct gfn_to_hva_cache pv_time;",
          "418:  bool pv_time_enabled;",
          "",
          "---------------"
        ],
        "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c": [
          "File: arch/x86/kvm/x86.c -> arch/x86/kvm/x86.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1406:  unsigned long flags, this_tsc_khz;",
          "1407:  struct kvm_vcpu_arch *vcpu = &v->arch;",
          "1408:  struct kvm_arch *ka = &v->kvm->arch;",
          "1410:  s64 kernel_ns, max_kernel_ns;",
          "1411:  u64 tsc_timestamp, host_tsc;",
          "1413:  u8 pvclock_flags;",
          "1414:  bool use_master_clock;",
          "",
          "[Removed Lines]",
          "1409:  void *shared_kaddr;",
          "1412:  struct pvclock_vcpu_time_info *guest_hv_clock;",
          "",
          "[Added Lines]",
          "1411:  struct pvclock_vcpu_time_info guest_hv_clock;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1464:  local_irq_restore(flags);",
          "1467:   return 0;",
          "",
          "[Removed Lines]",
          "1466:  if (!vcpu->time_page)",
          "",
          "[Added Lines]",
          "1465:  if (!vcpu->pv_time_enabled)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1526:  vcpu->hv_clock.version += 2;",
          "1535:  if (vcpu->pvclock_set_guest_stopped_request) {",
          "1536:   pvclock_flags |= PVCLOCK_GUEST_STOPPED;",
          "",
          "[Removed Lines]",
          "1528:  shared_kaddr = kmap_atomic(vcpu->time_page);",
          "1530:  guest_hv_clock = shared_kaddr + vcpu->time_offset;",
          "1533:  pvclock_flags = (guest_hv_clock->flags & PVCLOCK_GUEST_STOPPED);",
          "",
          "[Added Lines]",
          "1527:  if (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,",
          "1528:   &guest_hv_clock, sizeof(guest_hv_clock))))",
          "1529:   return 0;",
          "1532:  pvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1544:  vcpu->hv_clock.flags = pvclock_flags;",
          "1552:  return 0;",
          "1553: }",
          "",
          "[Removed Lines]",
          "1546:  memcpy(shared_kaddr + vcpu->time_offset, &vcpu->hv_clock,",
          "1547:         sizeof(vcpu->hv_clock));",
          "1549:  kunmap_atomic(shared_kaddr);",
          "1551:  mark_page_dirty(v->kvm, vcpu->time >> PAGE_SHIFT);",
          "",
          "[Added Lines]",
          "1545:  kvm_write_guest_cached(v->kvm, &vcpu->pv_time,",
          "1546:     &vcpu->hv_clock,",
          "1547:     sizeof(vcpu->hv_clock));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1838: static void kvmclock_reset(struct kvm_vcpu *vcpu)",
          "1839: {",
          "1844: }",
          "1846: static void accumulate_steal_time(struct kvm_vcpu *vcpu)",
          "",
          "[Removed Lines]",
          "1840:  if (vcpu->arch.time_page) {",
          "1841:   kvm_release_page_dirty(vcpu->arch.time_page);",
          "1842:   vcpu->arch.time_page = NULL;",
          "1843:  }",
          "",
          "[Added Lines]",
          "1836:  vcpu->arch.pv_time_enabled = false;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1947:   break;",
          "1948:  case MSR_KVM_SYSTEM_TIME_NEW:",
          "1949:  case MSR_KVM_SYSTEM_TIME: {",
          "1950:   kvmclock_reset(vcpu);",
          "1952:   vcpu->arch.time = data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1943:   u64 gpa_offset;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1956:   if (!(data & 1))",
          "1957:    break;",
          "1965:    break;",
          "1973:   break;",
          "1974:  }",
          "",
          "[Removed Lines]",
          "1960:   vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);",
          "1963:   if (vcpu->arch.time_offset &",
          "1964:     (sizeof(struct pvclock_vcpu_time_info) - 1))",
          "1967:   vcpu->arch.time_page =",
          "1968:     gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);",
          "1970:   if (is_error_page(vcpu->arch.time_page))",
          "1971:    vcpu->arch.time_page = NULL;",
          "",
          "[Added Lines]",
          "1953:   gpa_offset = data & ~(PAGE_MASK | 1);",
          "1956:   if (gpa_offset & (sizeof(struct pvclock_vcpu_time_info) - 1))",
          "1959:   if (kvm_gfn_to_hva_cache_init(vcpu->kvm,",
          "1960:        &vcpu->arch.pv_time, data & ~1ULL))",
          "1961:    vcpu->arch.pv_time_enabled = false;",
          "1962:   else",
          "1963:    vcpu->arch.pv_time_enabled = true;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2973: static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)",
          "2974: {",
          "2976:   return -EINVAL;",
          "2977:  vcpu->arch.pvclock_set_guest_stopped_request = true;",
          "2978:  kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);",
          "",
          "[Removed Lines]",
          "2975:  if (!vcpu->arch.time_page)",
          "",
          "[Added Lines]",
          "2967:  if (!vcpu->arch.pv_time_enabled)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6723:   goto fail_free_wbinvd_dirty_mask;",
          "6725:  vcpu->arch.ia32_tsc_adjust_msr = 0x0;",
          "6726:  kvm_async_pf_hash_reset(vcpu);",
          "6727:  kvm_pmu_init(vcpu);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6718:  vcpu->arch.pv_time_enabled = false;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
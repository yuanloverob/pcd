{
  "cve_id": "CVE-2017-13146",
  "cve_desc": "In ImageMagick before 6.9.8-5 and 7.x before 7.0.5-6, there is a memory leak in the ReadMATImage function in coders/mat.c.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20",
  "patch_info": {
    "commit_hash": "79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20",
    "files": [
      "coders/mat.c"
    ],
    "message": "...",
    "before_after_code_files": [
      "coders/mat.c||coders/mat.c"
    ]
  },
  "patch_diff": {
    "coders/mat.c||coders/mat.c": [
      "File: coders/mat.c -> coders/mat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "628:   unsigned int",
      "629:     depth;",
      "632:   (void) SeekBlob(image,0,SEEK_SET);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "772:         if (HDR.Type[1] == 0)",
      "773:           InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);",
      "774:         else",
      "776:       }",
      "777:     quantum_info=DestroyQuantumInfo(quantum_info);",
      "778:     rotate_image=RotateImage(image,90.0,exception);",
      "",
      "[Removed Lines]",
      "775:           InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);",
      "",
      "[Added Lines]",
      "776:           InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);",
      "777:       }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "890:       image=DestroyImageList(image);",
      "891:       return((Image *) NULL);",
      "892:     }",
      "894:      Read MATLAB image.",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1290:           }",
      "1291:         }",
      "1292:         }",
      "1295:   RelinquishMagickMemory(BImgBuff);",
      "1296:   quantum_info=DestroyQuantumInfo(quantum_info);",
      "",
      "[Removed Lines]",
      "1293:   }",
      "",
      "[Added Lines]",
      "1296:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a1936a74ca7cc5443337e51a5f5f3a963986b322",
      "candidate_info": {
        "commit_hash": "a1936a74ca7cc5443337e51a5f5f3a963986b322",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/a1936a74ca7cc5443337e51a5f5f3a963986b322",
        "files": [
          "coders/mat.c"
        ],
        "message": "...",
        "before_after_code_files": [
          "coders/mat.c||coders/mat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/mat.c||coders/mat.c"
          ],
          "candidate": [
            "coders/mat.c||coders/mat.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/mat.c||coders/mat.c": [
          "File: coders/mat.c -> coders/mat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "628:   unsigned int",
          "629:     depth;",
          "658:     return((Image *) NULL);",
          "662:       byte;",
          "696:       format_type=UnsignedQuantumFormat;",
          "707:       format_type=UnsignedQuantumFormat;",
          "724:     register Quantum",
          "742:           image->rows);",
          "743:         if (status == MagickFalse)",
          "746:   }",
          "747:   if (HDR.imagf == 1)",
          "748:     for (y=0; y < (ssize_t) image->rows; y++)",
          "751:         Read complex pixels.",
          "753:       count=ReadBlob(image,depth/8*image->columns,(char *) pixels);",
          "765:       image=DestroyImage(image);",
          "767:     }",
          "768:   return(image);",
          "769: }",
          "",
          "[Removed Lines]",
          "631:   (void) SeekBlob(image,0,SEEK_SET);",
          "632:   ldblk=ReadBlobLSBLong(image);",
          "633:   if ((ldblk > 9999) || (ldblk < 0))",
          "634:     return((Image *) NULL);",
          "641:   if (HDR.Type[0] == 0)",
          "642:     {",
          "643:       HDR.nRows=ReadBlobLSBLong(image);",
          "644:       HDR.nCols=ReadBlobLSBLong(image);",
          "645:       HDR.imagf=ReadBlobLSBLong(image);",
          "646:       HDR.nameLen=ReadBlobLSBLong(image);",
          "647:       endian=LSBEndian;",
          "648:     }",
          "649:   else",
          "650:     {",
          "651:       HDR.nRows=ReadBlobMSBLong(image);",
          "652:       HDR.nCols=ReadBlobMSBLong(image);",
          "653:       HDR.imagf=ReadBlobMSBLong(image);",
          "654:       HDR.nameLen=ReadBlobMSBLong(image);",
          "655:       endian=MSBEndian;",
          "656:     }",
          "657:   if (HDR.nameLen > 0xFFFF)",
          "659:   for (i=0; i < (ssize_t) HDR.nameLen; i++)",
          "660:   {",
          "661:     int",
          "665:       Skip matrix name.",
          "667:     byte=ReadBlobByte(image);",
          "668:     if (byte == EOF)",
          "669:       return((Image *) NULL);",
          "670:   }",
          "671:   image->columns=(size_t) HDR.nRows;",
          "672:   image->rows=(size_t) HDR.nCols;",
          "673:   SetImageColorspace(image,GRAYColorspace,exception);",
          "674:   if (image_info->ping != MagickFalse)",
          "675:     {",
          "676:       Swap(image->columns,image->rows);",
          "677:       return(image);",
          "678:     }",
          "679:   status=SetImageExtent(image,image->columns,image->rows,exception);",
          "680:   if (status == MagickFalse)",
          "681:     return((Image *) NULL);",
          "682:   quantum_info=AcquireQuantumInfo(image_info,image);",
          "683:   if (quantum_info == (QuantumInfo *) NULL)",
          "684:     return((Image *) NULL);",
          "685:   switch(HDR.Type[1])",
          "686:   {",
          "687:     case 0:",
          "688:       format_type=FloatingPointQuantumFormat;",
          "689:       depth=64;",
          "690:       break;",
          "691:     case 1:",
          "692:       format_type=FloatingPointQuantumFormat;",
          "693:       depth=32;",
          "694:       break;",
          "695:     case 2:",
          "697:       depth=16;",
          "698:       break;",
          "699:     case 3:",
          "700:       format_type=SignedQuantumFormat;",
          "701:       depth=16;",
          "702:     case 4:",
          "703:       format_type=UnsignedQuantumFormat;",
          "704:       depth=8;",
          "705:       break;",
          "706:     default:",
          "708:       depth=8;",
          "709:       break;",
          "710:   }",
          "711:   image->depth=depth;",
          "712:   if (HDR.Type[0] != 0)",
          "713:     SetQuantumEndian(image,quantum_info,MSBEndian);",
          "714:   status=SetQuantumFormat(image,quantum_info,format_type);",
          "715:   status=SetQuantumDepth(image,quantum_info,depth);",
          "716:   status=SetQuantumEndian(image,quantum_info,endian);",
          "717:   SetQuantumScale(quantum_info,1.0);",
          "718:   pixels=(unsigned char *) GetQuantumPixels(quantum_info);",
          "719:   for (y=0; y < (ssize_t) image->rows; y++)",
          "720:   {",
          "721:     int",
          "722:       status;",
          "727:     count=ReadBlob(image,depth/8*image->columns,(char *) pixels);",
          "728:     if (count == -1)",
          "729:       break;",
          "730:     q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,exception);",
          "731:     if (q == (Quantum *) NULL)",
          "732:       break;",
          "733:     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,",
          "734:       GrayQuantum,pixels,exception);",
          "735:     if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))",
          "736:       FixSignedValues(image,q,(int) image->columns);",
          "737:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "738:       break;",
          "739:     if (image->previous == (Image *) NULL)",
          "740:       {",
          "741:         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,",
          "744:           break;",
          "745:       }",
          "749:     {",
          "754:       if (count == -1)",
          "755:         break;",
          "756:       if (HDR.Type[1] == 0)",
          "757:         InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);",
          "758:       else",
          "759:         InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);",
          "760:     }",
          "761:   quantum_info=DestroyQuantumInfo(quantum_info);",
          "762:   rotate_image=RotateImage(image,90.0,exception);",
          "763:   if (rotate_image != (Image *) NULL)",
          "764:     {",
          "766:       image=rotate_image;",
          "",
          "[Added Lines]",
          "634:   {",
          "636:      Object parser loop.",
          "645:     if (HDR.Type[3] != 0)",
          "647:     if (HDR.Type[2] != 0)",
          "649:     if (HDR.Type[0] == 0)",
          "650:       {",
          "651:         HDR.nRows=ReadBlobLSBLong(image);",
          "652:         HDR.nCols=ReadBlobLSBLong(image);",
          "653:         HDR.imagf=ReadBlobLSBLong(image);",
          "654:         HDR.nameLen=ReadBlobLSBLong(image);",
          "655:         endian=LSBEndian;",
          "656:       }",
          "657:     else",
          "658:       {",
          "659:         HDR.nRows=ReadBlobMSBLong(image);",
          "660:         HDR.nCols=ReadBlobMSBLong(image);",
          "661:         HDR.imagf=ReadBlobMSBLong(image);",
          "662:         HDR.nameLen=ReadBlobMSBLong(image);",
          "663:         endian=MSBEndian;",
          "665:     if ((HDR.imagf != 0) && (HDR.imagf != 1))",
          "666:       break;",
          "667:     if (HDR.nameLen > 0xFFFF)",
          "668:       return((Image *) NULL);",
          "669:     for (i=0; i < (ssize_t) HDR.nameLen; i++)",
          "670:     {",
          "675:         Skip matrix name.",
          "677:       byte=ReadBlobByte(image);",
          "678:       if (byte == EOF)",
          "679:         {",
          "681:             image->filename);",
          "682:           break;",
          "683:         }",
          "684:     }",
          "685:     image->columns=(size_t) HDR.nRows;",
          "686:     image->rows=(size_t) HDR.nCols;",
          "687:     SetImageColorspace(image,GRAYColorspace,exception);",
          "688:     if (image_info->ping != MagickFalse)",
          "689:       {",
          "691:         return(image);",
          "692:       }",
          "693:     status=SetImageExtent(image,image->columns,image->rows,exception);",
          "694:     if (status == MagickFalse)",
          "695:       return((Image *) NULL);",
          "696:     quantum_info=AcquireQuantumInfo(image_info,image);",
          "697:     if (quantum_info == (QuantumInfo *) NULL)",
          "698:       return((Image *) NULL);",
          "699:     switch(HDR.Type[1])",
          "700:     {",
          "701:       case 0:",
          "702:         format_type=FloatingPointQuantumFormat;",
          "703:         depth=64;",
          "704:         break;",
          "705:       case 1:",
          "706:         format_type=FloatingPointQuantumFormat;",
          "707:         depth=32;",
          "708:         break;",
          "709:       case 2:",
          "710:         format_type=UnsignedQuantumFormat;",
          "711:         depth=16;",
          "712:         break;",
          "713:       case 3:",
          "714:         format_type=SignedQuantumFormat;",
          "715:         depth=16;",
          "716:       case 4:",
          "717:         format_type=UnsignedQuantumFormat;",
          "718:         depth=8;",
          "719:         break;",
          "720:       default:",
          "721:         format_type=UnsignedQuantumFormat;",
          "722:         depth=8;",
          "723:         break;",
          "724:     }",
          "725:     image->depth=depth;",
          "726:     if (HDR.Type[0] != 0)",
          "727:       SetQuantumEndian(image,quantum_info,MSBEndian);",
          "728:     status=SetQuantumFormat(image,quantum_info,format_type);",
          "729:     status=SetQuantumDepth(image,quantum_info,depth);",
          "730:     status=SetQuantumEndian(image,quantum_info,endian);",
          "733:     for (y=0; y < (ssize_t) image->rows; y++)",
          "734:     {",
          "735:       int",
          "736:         status;",
          "738:       register Quantum",
          "742:       if (count == -1)",
          "743:         break;",
          "744:       q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,",
          "745:         exception);",
          "746:       if (q == (Quantum *) NULL)",
          "747:         break;",
          "748:       (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,",
          "749:         GrayQuantum,pixels,exception);",
          "750:       if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))",
          "751:         FixSignedValues(image,q,(int) image->columns);",
          "752:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "753:         break;",
          "754:       if (image->previous == (Image *) NULL)",
          "755:         {",
          "756:           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,",
          "757:             image->rows);",
          "758:           if (status == MagickFalse)",
          "760:         }",
          "761:     }",
          "762:     if (HDR.imagf == 1)",
          "763:       for (y=0; y < (ssize_t) image->rows; y++)",
          "764:       {",
          "766:           Read complex pixels.",
          "768:         count=ReadBlob(image,depth/8*image->columns,(char *) pixels);",
          "769:         if (count == -1)",
          "770:           break;",
          "771:         if (HDR.Type[1] == 0)",
          "772:           InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);",
          "773:         else",
          "774:           InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);",
          "775:       }",
          "776:     quantum_info=DestroyQuantumInfo(quantum_info);",
          "777:     rotate_image=RotateImage(image,90.0,exception);",
          "778:     if (rotate_image != (Image *) NULL)",
          "779:       {",
          "780:         image=DestroyImage(image);",
          "781:         image=rotate_image;",
          "782:       }",
          "783:     if (EOFBlob(image) != MagickFalse)",
          "784:       {",
          "785:         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "786:           image->filename);",
          "787:         break;",
          "788:       }",
          "790:       Proceed to next image.",
          "792:     if (image_info->number_scenes != 0)",
          "793:       if (image->scene >= (image_info->scene+image_info->number_scenes-1))",
          "794:         break;",
          "796:       Allocate next image structure.",
          "798:     AcquireNextImage(image_info,image,exception);",
          "799:     if (GetNextImageInList(image) == (Image *) NULL)",
          "800:       {",
          "801:         image=DestroyImageList(image);",
          "802:         return((Image *) NULL);",
          "803:       }",
          "804:     image=SyncNextImageInList(image);",
          "805:     status=SetImageProgress(image,LoadImagesTag,TellBlob(image),",
          "806:       GetBlobSize(image));",
          "807:     if (status == MagickFalse)",
          "808:       break;",
          "809:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-32686",
  "cve_desc": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP before version 2.11.1, there are a couple of issues found in the SSL socket. First, a race condition between callback and destroy, due to the accepted socket having no group lock. Second, the SSL socket parent/listener may get destroyed during handshake. Both issues were reported to happen intermittently in heavy load TLS connections. They cause a crash, resulting in a denial of service. These are fixed in version 2.11.1.",
  "repo": "pjsip/pjproject",
  "patch_hash": "d5f95aa066f878b0aef6a64e60b61e8626e664cd",
  "patch_info": {
    "commit_hash": "d5f95aa066f878b0aef6a64e60b61e8626e664cd",
    "repo": "pjsip/pjproject",
    "commit_url": "https://github.com/pjsip/pjproject/commit/d5f95aa066f878b0aef6a64e60b61e8626e664cd",
    "files": [
      "pjlib/src/pj/ssl_sock_imp_common.c",
      "pjlib/src/pj/ssl_sock_ossl.c",
      "pjsip/src/pjsip/sip_transport_tls.c"
    ],
    "message": "Merge pull request from GHSA-cv8x-p47p-99wr\n\n* - Avoid SSL socket parent/listener getting destroyed during handshake by increasing parent's reference count.\n- Add missing SSL socket close when the newly accepted SSL socket is discarded in SIP TLS transport.\n\n* - Fix silly mistake: accepted active socket created without group lock in SSL socket.\n- Replace assertion with normal validation check of SSL socket instance in OpenSSL verification callback (verify_cb()) to avoid crash, e.g: if somehow race condition with SSL socket destroy happens or OpenSSL application data index somehow gets corrupted.",
    "before_after_code_files": [
      "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
      "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c",
      "pjsip/src/pjsip/sip_transport_tls.c||pjsip/src/pjsip/sip_transport_tls.c"
    ]
  },
  "patch_diff": {
    "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c": [
      "File: pjlib/src/pj/ssl_sock_imp_common.c -> pjlib/src/pj/ssl_sock_imp_common.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "257:     if (ssock->is_server) {",
      "258:  if (status != PJ_SUCCESS) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "258:  pj_bool_t ret = PJ_TRUE;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "272:         status);",
      "273:      }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "278:      if (ssock->parent->param.grp_lock) {",
      "279:   pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);",
      "280:   ssock->parent = NULL;",
      "281:      }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "316:      return PJ_FALSE;",
      "317:  }",
      "319:  if (ssock->param.cb.on_accept_complete2) {",
      "321:      ret = (*ssock->param.cb.on_accept_complete2)",
      "322:       (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr,",
      "323:       pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr),",
      "324:       status);",
      "327:  } else if (ssock->param.cb.on_accept_complete) {",
      "329:      ret = (*ssock->param.cb.on_accept_complete)",
      "330:         (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr,",
      "331:          pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr));",
      "334:  }",
      "335:     }",
      "",
      "[Removed Lines]",
      "320:      pj_bool_t ret;",
      "325:      if (ret == PJ_FALSE)",
      "326:   return PJ_FALSE;",
      "328:      pj_bool_t ret;",
      "332:      if (ret == PJ_FALSE)",
      "333:   return PJ_FALSE;",
      "",
      "[Added Lines]",
      "342:  if (ssock->parent->param.grp_lock) {",
      "343:      pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);",
      "344:      ssock->parent = NULL;",
      "345:  }",
      "347:  if (ret == PJ_FALSE)",
      "348:      return PJ_FALSE;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "930:     if (status != PJ_SUCCESS)",
      "931:  goto on_return;",
      "934:     ssock->sock = newsock;",
      "936:     ssock->is_server = PJ_TRUE;",
      "937:     if (ssock_parent->cert) {",
      "938:  status = pj_ssl_sock_set_certificate(ssock, ssock->pool,",
      "",
      "[Removed Lines]",
      "935:     ssock->parent = ssock_parent;",
      "",
      "[Added Lines]",
      "948:     ssock->parent = ssock_parent;",
      "949:     if (ssock->parent->param.grp_lock)",
      "950:  pj_grp_lock_add_ref(ssock->parent->param.grp_lock);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "957:     ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool,",
      "958:             ssock->param.async_cnt,",
      "959:             sizeof(void*));",
      "963:     for (i = 0; i<ssock->param.async_cnt; ++i) {",
      "964:  ssock->asock_rbuf[i] = (void*) pj_pool_alloc(",
      "965:          ssock->pool,",
      "966:          ssock->param.read_buffer_size +",
      "967:          sizeof(read_data_t*));",
      "970:     }",
      "",
      "[Removed Lines]",
      "960:     if (!ssock->asock_rbuf)",
      "961:         return PJ_ENOMEM;",
      "968:         if (!ssock->asock_rbuf[i])",
      "969:             return PJ_ENOMEM;",
      "",
      "[Added Lines]",
      "978:     if (!ssock->asock_rbuf) {",
      "979:  status = PJ_ENOMEM;",
      "980:  goto on_return;",
      "981:     }",
      "988:  if (!ssock->asock_rbuf[i]) {",
      "989:      status = PJ_ENOMEM;",
      "990:      goto on_return;",
      "991:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "980:      goto on_return;",
      "982:  pj_grp_lock_add_ref(glock);",
      "984:  pj_grp_lock_add_handler(ssock->param.grp_lock, ssock->pool, ssock,",
      "985:     ssl_on_destroy);",
      "986:     }",
      "",
      "[Removed Lines]",
      "983:  asock_cfg.grp_lock = ssock->param.grp_lock = glock;",
      "",
      "[Added Lines]",
      "1005:  ssock->param.grp_lock = glock;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1010:     pj_activesock_cfg_default(&asock_cfg);",
      "1011:     asock_cfg.async_cnt = ssock->param.async_cnt;",
      "1012:     asock_cfg.concurrency = ssock->param.concurrency;",
      "1013:     asock_cfg.whole_data = PJ_TRUE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1033:     asock_cfg.grp_lock = ssock->param.grp_lock;",
      "",
      "---------------"
    ],
    "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c": [
      "File: pjlib/src/pj/ssl_sock_ossl.c -> pjlib/src/pj/ssl_sock_ossl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "327:  ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);",
      "328:     }",
      "331:     return GET_STATUS_FROM_SSL_ERR(err);",
      "332: }",
      "",
      "[Removed Lines]",
      "330:     ssock->last_err = err;",
      "",
      "[Added Lines]",
      "330:     if (ssock)",
      "331:  ssock->last_err = err;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "345:     SSLLogErrors(action, ret, err, len, ssock);",
      "348:     return GET_STATUS_FROM_SSL_ERR(ssl_err);",
      "349: }",
      "",
      "[Removed Lines]",
      "347:     ssock->last_err = ssl_err;",
      "",
      "[Added Lines]",
      "348:     if (ssock)",
      "349:  ssock->last_err = ssl_err;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "788:     sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);",
      "790: #if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\",
      "791:     PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "791:     if (sslsock_idx == -1) {",
      "792:  status = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);",
      "793:  PJ_LOG(1,(THIS_FILE,",
      "794:         \"Fatal error: failed to get application data index for \"",
      "795:         \"SSL socket\"));",
      "796:  return status;",
      "797:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "819: }",
      "823: static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)",
      "824: {",
      "827:     int err;",
      "830:     ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx,",
      "831:         SSL_get_ex_data_X509_STORE_CTX_idx());",
      "835:     ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);",
      "839:     err = X509_STORE_CTX_get_error(x509_ctx);",
      "",
      "[Removed Lines]",
      "825:     pj_ssl_sock_t *ssock;",
      "826:     SSL *ossl_ssl;",
      "832:     pj_assert(ossl_ssl);",
      "836:     pj_assert(ssock);",
      "",
      "[Added Lines]",
      "839:     pj_ssl_sock_t *ssock = NULL;",
      "840:     SSL *ossl_ssl = NULL;",
      "846:     if (!ossl_ssl) {",
      "847:  PJ_LOG(1,(THIS_FILE,",
      "848:     \"SSL verification callback failed to get SSL instance\"));",
      "849:  goto on_return;",
      "850:     }",
      "854:     if (!ssock) {",
      "856:  PJ_LOG(1,(THIS_FILE,",
      "857:     \"SSL verification callback failed to get SSL socket \"",
      "858:     \"instance (sslsock_idx=%d).\", sslsock_idx));",
      "859:  goto on_return;",
      "860:     }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "911:     if (PJ_FALSE == ssock->param.verify_peer)",
      "912:  preverify_ok = 1;",
      "914:     return preverify_ok;",
      "915: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "938: on_return:",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1474: static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)",
      "1475: {",
      "1476:     ossl_sock_t *ossock = (ossl_sock_t *)ssock;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1504:     if (ossock->ossl_ssl) {",
      "1505:  SSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);",
      "1506:     }",
      "",
      "---------------"
    ],
    "pjsip/src/pjsip/sip_transport_tls.c||pjsip/src/pjsip/sip_transport_tls.c": [
      "File: pjsip/src/pjsip/sip_transport_tls.c -> pjsip/src/pjsip/sip_transport_tls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1333:     PJ_UNUSED_ARG(src_addr_len);",
      "1335:     listener = (struct tls_listener*) pj_ssl_sock_get_user_data(ssock);",
      "1337:     if (accept_status != PJ_SUCCESS) {",
      "1339:      pjsip_tls_on_accept_fail_param param;",
      "1340:      pj_ssl_sock_info ssi;",
      "",
      "[Removed Lines]",
      "1338:  if (listener && listener->tls_setting.on_accept_fail_cb) {",
      "",
      "[Added Lines]",
      "1336:     if (!listener) {",
      "1340:  if (new_ssock && accept_status == PJ_SUCCESS) {",
      "1342:      PJ_LOG(4,(THIS_FILE,",
      "1343:         \"Incoming TLS connection from %s (sock=%d) is discarded \"",
      "1344:         \"because listener is already destroyed\",",
      "1345:         pj_sockaddr_print(src_addr, addr, sizeof(addr), 3),",
      "1346:         new_ssock));",
      "1348:      pj_ssl_sock_close(new_ssock);",
      "1349:  }",
      "1351:  return PJ_FALSE;",
      "1352:     }",
      "1355:  if (listener->tls_setting.on_accept_fail_cb) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1358:     PJ_ASSERT_RETURN(new_ssock, PJ_TRUE);",
      "1360:     if (!listener->is_registered) {",
      "1361:  if (listener->tls_setting.on_accept_fail_cb) {",
      "1362:      pjsip_tls_on_accept_fail_param param;",
      "1363:      pj_bzero(&param, sizeof(param));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1378:  pj_ssl_sock_close(new_ssock);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1409:     ssl_info.grp_lock, &tls);",
      "1411:     if (status != PJ_SUCCESS) {",
      "1412:  if (listener->tls_setting.on_accept_fail_cb) {",
      "1413:      pjsip_tls_on_accept_fail_param param;",
      "1414:      pj_bzero(&param, sizeof(param));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1431:  pj_ssl_sock_close(new_ssock);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fb8a7772efb73c5ed8190764c29d99f4a35ae86c",
      "candidate_info": {
        "commit_hash": "fb8a7772efb73c5ed8190764c29d99f4a35ae86c",
        "repo": "pjsip/pjproject",
        "commit_url": "https://github.com/pjsip/pjproject/commit/fb8a7772efb73c5ed8190764c29d99f4a35ae86c",
        "files": [
          "aconfigure",
          "aconfigure.ac",
          "pjlib/include/pj/config.h",
          "pjlib/src/pj/ioqueue_select.c",
          "pjlib/src/pj/ssl_sock_apple.m",
          "pjlib/src/pj/ssl_sock_darwin.c",
          "pjlib/src/pj/ssl_sock_imp_common.c",
          "pjlib/src/pj/ssl_sock_imp_common.h",
          "pjlib/src/pjlib-test/ssl_sock.c"
        ],
        "message": "Apple SSL backend using Network framework (#2482)",
        "before_after_code_files": [
          "aconfigure.ac||aconfigure.ac",
          "pjlib/include/pj/config.h||pjlib/include/pj/config.h",
          "pjlib/src/pj/ioqueue_select.c||pjlib/src/pj/ioqueue_select.c",
          "pjlib/src/pj/ssl_sock_apple.m||pjlib/src/pj/ssl_sock_apple.m",
          "pjlib/src/pj/ssl_sock_darwin.c||pjlib/src/pj/ssl_sock_darwin.c",
          "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
          "pjlib/src/pj/ssl_sock_imp_common.h||pjlib/src/pj/ssl_sock_imp_common.h",
          "pjlib/src/pjlib-test/ssl_sock.c||pjlib/src/pjlib-test/ssl_sock.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c"
          ],
          "candidate": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c"
          ]
        }
      },
      "candidate_diff": {
        "aconfigure.ac||aconfigure.ac": [
          "File: aconfigure.ac -> aconfigure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "490:   ac_os_objs=\"$ac_os_objs sock_qos_bsd.o\"",
          "491:   ;;",
          "492:  esac",
          "493:  # UUID",
          "494:  case $target in",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "493:  # SSL",
          "494:  case $target in",
          "496:   ac_os_objs=\"$ac_os_objs ssl_sock_apple.o\"",
          "497:   ;;",
          "498:  esac",
          "",
          "---------------"
        ],
        "pjlib/include/pj/config.h||pjlib/include/pj/config.h": [
          "File: pjlib/include/pj/config.h -> pjlib/include/pj/config.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "989: #define PJ_SSL_SOCK_IMP_DARWIN      3 /**< Using Apple's Secure",
          "990:           Transport (deprecated in",
          "992: #define PJ_SSL_SOCK_IMP_APPLE       4 /**< Using Apple's Network",
          "",
          "---------------"
        ],
        "pjlib/src/pj/ioqueue_select.c||pjlib/src/pj/ioqueue_select.c": [
          "File: pjlib/src/pj/ioqueue_select.c -> pjlib/src/pj/ioqueue_select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "131: static pj_status_t replace_udp_sock(pj_ioqueue_key_t *h);",
          "132: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134: #if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\",
          "135:     (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_APPLE)",
          "137: pj_status_t ssl_network_event_poll();",
          "138: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "927:     PJ_ASSERT_RETURN(ioqueue, -PJ_EINVAL);",
          "930:     pj_lock_acquire(ioqueue->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "935: #if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\",
          "936:     (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_APPLE)",
          "938:     ssl_network_event_poll();",
          "939: #endif",
          "",
          "---------------"
        ],
        "pjlib/src/pj/ssl_sock_apple.m||pjlib/src/pj/ssl_sock_apple.m": [
          "File: pjlib/src/pj/ssl_sock_apple.m -> pjlib/src/pj/ssl_sock_apple.m",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <pj/ssl_sock.h>",
          "20: #include <pj/os.h>",
          "21: #include <pj/pool.h>",
          "22: #include <pj/rand.h>",
          "25: #if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\",
          "26:     (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_APPLE)",
          "28: #define THIS_FILE               \"ssl_sock_apple.m\"",
          "30: #define SSL_SOCK_IMP_USE_CIRC_BUF",
          "31: #define SSL_SOCK_IMP_USE_OWN_NETWORK",
          "33: #include \"ssl_sock_imp_common.h\"",
          "34: #include \"ssl_sock_imp_common.c\"",
          "36: #include \"TargetConditionals.h\"",
          "38: #include <err.h>",
          "39: #include <CoreFoundation/CoreFoundation.h>",
          "40: #include <CommonCrypto/CommonDigest.h>",
          "41: #include <Foundation/NSLock.h>",
          "42: #include <Network/Network.h>",
          "43: #include <Security/Security.h>",
          "57: typedef struct applessl_sock_t {",
          "58:     pj_ssl_sock_t   base;",
          "60:     nw_listener_t  listener;",
          "61:     nw_connection_t     connection;",
          "62:     dispatch_queue_t queue;",
          "63:     dispatch_semaphore_t ev_semaphore;",
          "65:     SecTrustRef  trust;",
          "66:     tls_ciphersuite_t cipher;",
          "67:     sec_identity_t identity;",
          "68: } applessl_sock_t;",
          "77:  typedef enum event_id",
          "78: {",
          "79:     EVENT_ACCEPT,",
          "80:     EVENT_CONNECT,",
          "81:     EVENT_VERIFY_CERT,",
          "82:     EVENT_HANDSHAKE_COMPLETE,",
          "83:     EVENT_DATA_READ,",
          "84:     EVENT_DATA_SENT",
          "85: } event_id;",
          "87: typedef struct event_t",
          "88: {",
          "89:     PJ_DECL_LIST_MEMBER(struct event_t);",
          "91:     event_id    type;",
          "92:     pj_ssl_sock_t  *ssock;",
          "93:     pj_bool_t   async;",
          "95:     union",
          "96:     {",
          "97:         struct",
          "98:         {",
          "99:             nw_connection_t  newconn;",
          "100:             pj_sockaddr   src_addr;",
          "101:             int    src_addr_len;",
          "102:             pj_status_t   status;",
          "103:         } accept_ev;",
          "105:         struct",
          "106:         {",
          "107:             pj_status_t   status;",
          "108:         } connect_ev;",
          "110:  struct",
          "111:         {",
          "112:             pj_status_t   status;",
          "113:         } handshake_ev;",
          "115:         struct",
          "116:         {",
          "117:             pj_ioqueue_op_key_t *send_key;",
          "118:      pj_ssize_t    sent;",
          "119:         } data_sent_ev;",
          "121:         struct",
          "122:         {",
          "123:      void   *data;",
          "124:      pj_size_t    size;",
          "125:      pj_status_t   status;",
          "126:      pj_size_t    remainder;",
          "127:         } data_read_ev;",
          "129:     } body;",
          "130: } event_t;",
          "132: typedef struct event_manager",
          "133: {",
          "134:     NSLock *lock;",
          "135:     event_t  event_list;",
          "136:     event_t  free_event_list;",
          "137: } event_manager;",
          "139: static event_manager *event_mgr = NULL;",
          "147: static pj_status_t verify_cert(applessl_sock_t *assock, pj_ssl_cert_t *cert);",
          "149: static void event_manager_destroy()",
          "150: {",
          "151:     event_manager *mgr = event_mgr;",
          "153:     event_mgr = NULL;",
          "155:     while (!pj_list_empty(&mgr->free_event_list)) {",
          "156:      event_t *event = mgr->free_event_list.next;",
          "157:         pj_list_erase(event);",
          "158:         free(event);",
          "159:     }",
          "161:     while (!pj_list_empty(&mgr->event_list)) {",
          "162:      event_t *event = mgr->event_list.next;",
          "163:         pj_list_erase(event);",
          "164:         free(event);",
          "165:     }",
          "167:     [mgr->lock release];",
          "169:     free(mgr);",
          "170: }",
          "172: static pj_status_t event_manager_create()",
          "173: {",
          "174:     event_manager *mgr;",
          "176:     if (event_mgr)",
          "177:      return PJ_SUCCESS;",
          "179:     mgr = malloc(sizeof(event_manager));",
          "180:     if (!mgr) return PJ_ENOMEM;",
          "182:     mgr->lock = [[NSLock alloc]init];",
          "183:     pj_list_init(&mgr->event_list);",
          "184:     pj_list_init(&mgr->free_event_list);",
          "186:     event_mgr = mgr;",
          "187:     pj_atexit(&event_manager_destroy);",
          "189:     return PJ_SUCCESS;",
          "190: }",
          "195: static pj_status_t event_manager_post_event(pj_ssl_sock_t *ssock,",
          "196:          event_t *event_item,",
          "197:          pj_bool_t async)",
          "198: {",
          "199:     event_manager *mgr = event_mgr;",
          "200:     event_t *event;",
          "202:     [mgr->lock lock];",
          "204:     if (pj_list_empty(&mgr->free_event_list)) {",
          "205:         event = malloc(sizeof(event_t));",
          "206:     } else {",
          "207:         event = mgr->free_event_list.next;",
          "208:         pj_list_erase(event);",
          "209:     }",
          "211:     pj_memcpy(event, event_item, sizeof(event_t));",
          "212:     event->ssock = ssock;",
          "213:     event->async = async;",
          "214:     pj_list_push_back(&mgr->event_list, event);",
          "216:     [mgr->lock unlock];",
          "218:     if (!async) {",
          "219:  dispatch_semaphore_wait(((applessl_sock_t *)ssock)->ev_semaphore,",
          "220:            DISPATCH_TIME_FOREVER);",
          "221:     }",
          "223:     return PJ_SUCCESS;",
          "224: }",
          "227: static void event_manager_remove_events(pj_ssl_sock_t *ssock)",
          "228: {",
          "229:     event_t *event;",
          "231:     [event_mgr->lock lock];",
          "232:     event = event_mgr->event_list.next;",
          "233:     while (event != &event_mgr->event_list) {",
          "234:      event_t *event_ = event;",
          "236:      event = event->next;",
          "237:      if (event_->ssock == ssock) {",
          "238:          pj_list_erase(event_);",
          "240:      if (!event_->async) {",
          "241:          applessl_sock_t * assock;",
          "242:          assock = (applessl_sock_t *)event_->ssock;",
          "243:       dispatch_semaphore_signal(assock->ev_semaphore);",
          "244:      }",
          "245:      }",
          "246:     }",
          "247:     [event_mgr->lock unlock];",
          "248: }",
          "250: pj_status_t ssl_network_event_poll()",
          "251: {",
          "252:     if (!event_mgr)",
          "253:      return PJ_SUCCESS;",
          "255:     while (!pj_list_empty(&event_mgr->event_list)) {",
          "256:      applessl_sock_t * assock;",
          "257:      event_t *event;",
          "258:      pj_bool_t ret = PJ_TRUE;",
          "260:      [event_mgr->lock lock];",
          "262:      if (pj_list_empty(&event_mgr->event_list)) {",
          "263:          [event_mgr->lock unlock];",
          "264:          break;",
          "265:      }",
          "266:      event = event_mgr->event_list.next;",
          "267:      pj_list_erase(event);",
          "268:      [event_mgr->lock unlock];",
          "270:  assock = (applessl_sock_t *)event->ssock;",
          "271:  switch (event->type) {",
          "272:      case EVENT_ACCEPT:",
          "273:   ret = ssock_on_accept_complete(event->ssock,",
          "274:       PJ_INVALID_SOCKET,",
          "275:       event->body.accept_ev.newconn,",
          "276:           &event->body.accept_ev.src_addr,",
          "277:           event->body.accept_ev.src_addr_len,",
          "278:           event->body.accept_ev.status);",
          "279:       break;",
          "280:      case EVENT_CONNECT:",
          "281:       ret = ssock_on_connect_complete(event->ssock,",
          "282:           event->body.connect_ev.status);",
          "283:       break;",
          "284:      case EVENT_VERIFY_CERT:",
          "285:       verify_cert(assock, event->ssock->cert);",
          "286:       break;",
          "287:      case EVENT_HANDSHAKE_COMPLETE:",
          "288:          event->ssock->ssl_state = SSL_STATE_ESTABLISHED;",
          "289:       ret = on_handshake_complete(event->ssock,",
          "290:           event->body.handshake_ev.status);",
          "291:       break;",
          "292:      case EVENT_DATA_SENT:",
          "293:       ret = ssock_on_data_sent(event->ssock,",
          "294:           event->body.data_sent_ev.send_key,",
          "295:           event->body.data_sent_ev.sent);",
          "296:       break;",
          "297:      case EVENT_DATA_READ:",
          "298:       ret = ssock_on_data_read(event->ssock,",
          "299:           event->body.data_read_ev.data,",
          "300:           event->body.data_read_ev.size,",
          "301:           event->body.data_read_ev.status,",
          "302:           &event->body.data_read_ev.remainder);",
          "303:       break;",
          "304:      default:",
          "305:       break;",
          "306:  }",
          "309:  if (ret && !event->async && ret) {",
          "310:      dispatch_semaphore_signal(assock->ev_semaphore);",
          "311:  }",
          "314:      [event_mgr->lock lock];",
          "315:      pj_list_push_back(&event_mgr->free_event_list, event);",
          "316:      [event_mgr->lock unlock];",
          "317:     }",
          "319:     return 0;",
          "320: }",
          "328: #define PJ_SSL_ERRNO_START  (PJ_ERRNO_START_USER + \\",
          "329:       PJ_ERRNO_SPACE_SIZE*6)",
          "331: #define PJ_SSL_ERRNO_SPACE_SIZE  PJ_ERRNO_SPACE_SIZE",
          "334: static pj_status_t pj_status_from_err(applessl_sock_t *assock,",
          "335:           const char *msg,",
          "336:           OSStatus err)",
          "337: {",
          "338:     pj_status_t status = (pj_status_t)-err;",
          "339:     CFStringRef errmsg;",
          "341:     errmsg = SecCopyErrorMessageString(err, NULL);",
          "342:     PJ_LOG(3, (THIS_FILE, \"Apple SSL error %s [%d]: %s\",",
          "343:             (msg? msg: \"\"), err,",
          "344:             CFStringGetCStringPtr(errmsg, kCFStringEncodingUTF8)));",
          "345:     CFRelease(errmsg);",
          "347:     if (status > PJ_SSL_ERRNO_SPACE_SIZE)",
          "348:  status = PJ_SSL_ERRNO_SPACE_SIZE;",
          "349:     status += PJ_SSL_ERRNO_START;",
          "351:     if (assock)",
          "352:         assock->base.last_err = err;",
          "354:     return status;",
          "355: }",
          "358: static pj_status_t create_data_from_file(CFDataRef *data,",
          "359:       pj_str_t *fname, pj_str_t *path)",
          "360: {",
          "361:     CFURLRef file;",
          "362:     CFReadStreamRef read_stream;",
          "363:     UInt8 data_buf[8192];",
          "364:     CFIndex nbytes = 0;",
          "366:     if (path) {",
          "367:         CFURLRef filepath;",
          "368:         CFStringRef path_str;",
          "370:         path_str = CFStringCreateWithBytes(NULL, (const UInt8 *)path->ptr,",
          "371:                path->slen,",
          "372:                kCFStringEncodingUTF8, false);",
          "373:         if (!path_str) return PJ_ENOMEM;",
          "375:         filepath = CFURLCreateWithFileSystemPath(NULL, path_str,",
          "376:               kCFURLPOSIXPathStyle, true);",
          "377:         CFRelease(path_str);",
          "378:         if (!filepath) return PJ_ENOMEM;",
          "380:         path_str = CFStringCreateWithBytes(NULL, (const UInt8 *)fname->ptr,",
          "381:                fname->slen,",
          "382:                kCFStringEncodingUTF8, false);",
          "383:         if (!path_str) {",
          "384:          CFRelease(filepath);",
          "385:          return PJ_ENOMEM;",
          "386:         }",
          "388:         file = CFURLCreateCopyAppendingPathComponent(NULL, filepath,",
          "389:                   path_str, false);",
          "390:         CFRelease(path_str);",
          "391:         CFRelease(filepath);",
          "392:     } else {",
          "393:         file = CFURLCreateFromFileSystemRepresentation(NULL,",
          "394:             (const UInt8 *)fname->ptr, fname->slen, false);",
          "395:     }",
          "397:     if (!file)",
          "398:         return PJ_ENOMEM;",
          "400:     read_stream = CFReadStreamCreateWithFile(NULL, file);",
          "401:     CFRelease(file);",
          "403:     if (!read_stream)",
          "404:         return PJ_ENOTFOUND;",
          "406:     if (!CFReadStreamOpen(read_stream)) {",
          "407:         PJ_LOG(2, (THIS_FILE, \"Failed opening file\"));",
          "408:         CFRelease(read_stream);",
          "409:         return PJ_EINVAL;",
          "410:     }",
          "412:     nbytes = CFReadStreamRead(read_stream, data_buf,",
          "413:              sizeof(data_buf));",
          "414:     if (nbytes > 0)",
          "416:     else",
          "419:     CFReadStreamClose(read_stream);",
          "420:     CFRelease(read_stream);",
          "422:     return (*data? PJ_SUCCESS: PJ_EINVAL);",
          "423: }",
          "425: static pj_status_t create_identity_from_cert(applessl_sock_t *assock,",
          "426:               pj_ssl_cert_t *cert,",
          "427:               sec_identity_t *p_identity)",
          "428: {",
          "429:     CFStringRef password = NULL;",
          "430:     CFDataRef cert_data = NULL;",
          "431:     void *keys[1] = {NULL};",
          "432:     void *values[1] = {NULL};",
          "433:     CFDictionaryRef options;",
          "434:     CFArrayRef items;",
          "435:     CFIndex i, count;",
          "436:     SecIdentityRef identity = NULL;",
          "437:     OSStatus err;",
          "438:     pj_status_t status;",
          "443:     if (cert->privkey_file.slen || cert->privkey_buf.slen ||",
          "444:      cert->privkey_pass.slen)",
          "445:     {",
          "446:      PJ_LOG(5, (THIS_FILE, \"Ignoring supplied private key. Private key \"",
          "447:              \"must be placed in the keychain instead.\"));",
          "448:     }",
          "450:     if (cert->cert_file.slen) {",
          "451:      status = create_data_from_file(&cert_data, &cert->cert_file, NULL);",
          "452:      if (status != PJ_SUCCESS) {",
          "453:          PJ_PERROR(2, (THIS_FILE, status, \"Failed reading cert file\"));",
          "454:          return status;",
          "455:      }",
          "456:     } else if (cert->cert_buf.slen) {",
          "457:      cert_data = CFDataCreate(NULL, (const UInt8 *)cert->cert_buf.ptr,",
          "458:          cert->cert_buf.slen);",
          "459:      if (!cert_data)",
          "460:          return PJ_ENOMEM;",
          "461:     }",
          "463:     if (cert_data) {",
          "464:         if (cert->privkey_pass.slen) {",
          "465:      password = CFStringCreateWithBytes(NULL,",
          "466:              (const UInt8 *)cert->privkey_pass.ptr,",
          "467:              cert->privkey_pass.slen,",
          "468:              kCFStringEncodingUTF8,",
          "469:              false);",
          "470:      keys[0] = (void *)kSecImportExportPassphrase;",
          "471:      values[0] = (void *)password;",
          "472:         }",
          "474:         options = CFDictionaryCreate(NULL, (const void **)keys,",
          "475:              (const void **)values,",
          "476:              (password? 1: 0), NULL, NULL);",
          "477:         if (!options)",
          "478:          return PJ_ENOMEM;",
          "480: #if TARGET_OS_IPHONE",
          "481:         err = SecPKCS12Import(cert_data, options, &items);",
          "482: #else",
          "483:         {",
          "484:          SecExternalFormat ext_format[3] = {kSecFormatPKCS12,",
          "485:                     kSecFormatPEMSequence,",
          "486:                     kSecFormatX509Cert/* DER */};",
          "487:          SecExternalItemType ext_type = kSecItemTypeCertificate;",
          "488:          SecItemImportExportKeyParameters key_params;",
          "490:          pj_bzero(&key_params, sizeof(key_params));",
          "491:          key_params.version = SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION;",
          "492:          key_params.passphrase = password;",
          "494:          for (i = 0; i < PJ_ARRAY_SIZE(ext_format); i++) {",
          "495:           items = NULL;",
          "496:       err = SecItemImport(cert_data, NULL, &ext_format[i],",
          "497:             &ext_type, 0, &key_params, NULL, &items);",
          "498:       if (err == noErr && items) {",
          "499:           break;",
          "500:       }",
          "501:          }",
          "502:         }",
          "503: #endif",
          "505:         CFRelease(options);",
          "506:         if (password)",
          "507:          CFRelease(password);",
          "508:         CFRelease(cert_data);",
          "509:         if (err != noErr || !items) {",
          "510:          return pj_status_from_err(assock, \"SecItemImport\", err);",
          "511:         }",
          "513:         count = CFArrayGetCount(items);",
          "515:         for (i = 0; i < count; i++) {",
          "516:          CFTypeRef item;",
          "517:          CFTypeID item_id;",
          "519:          item = (CFTypeRef) CFArrayGetValueAtIndex(items, i);",
          "520:          item_id = CFGetTypeID(item);",
          "522:          if (item_id == CFDictionaryGetTypeID()) {",
          "523:           identity = (SecIdentityRef)",
          "524:                  CFDictionaryGetValue((CFDictionaryRef) item,",
          "525:                  kSecImportItemIdentity);",
          "526:              break;",
          "527:          }",
          "528: #if !TARGET_OS_IPHONE",
          "529:          else if (item_id == SecCertificateGetTypeID()) {",
          "530:           err = SecIdentityCreateWithCertificate(NULL,",
          "531:                 (SecCertificateRef) item, &identity);",
          "532:           if (err != noErr) {",
          "533:           pj_status_from_err(assock, \"SecIdentityCreate\", err);",
          "534:               if (err == errSecItemNotFound) {",
          "535:                PJ_LOG(2, (THIS_FILE, \"Private key must be placed in \"",
          "536:                        \"the keychain\"));",
          "537:               }",
          "538:           } else {",
          "539:               break;",
          "540:           }",
          "541:          }",
          "542: #endif",
          "543:         }",
          "545:         CFRelease(items);",
          "547:         if (!identity) {",
          "548:          PJ_LOG(2, (THIS_FILE, \"Failed extracting identity from \"",
          "549:                 \"the cert file\"));",
          "550:          return PJ_EINVAL;",
          "551:         }",
          "555:         CFRelease(identity);",
          "556:     }",
          "558:     return PJ_SUCCESS;",
          "559: }",
          "561: static pj_status_t verify_cert(applessl_sock_t *assock, pj_ssl_cert_t *cert)",
          "562: {",
          "563:     CFDataRef ca_data = NULL;",
          "564:     SecTrustRef trust = assock->trust;",
          "565:     bool result;",
          "566:     CFErrorRef error;",
          "567:     pj_status_t status = PJ_SUCCESS;",
          "568:     OSStatus err = noErr;",
          "570:     if (trust && cert && cert->CA_file.slen) {",
          "571:      status = create_data_from_file(&ca_data, &cert->CA_file,",
          "572:                (cert->CA_path.slen? &cert->CA_path:",
          "573:                 NULL));",
          "574:      if (status != PJ_SUCCESS)",
          "575:          PJ_LOG(2, (THIS_FILE, \"Failed reading CA file\"));",
          "576:     } else if (trust && cert && cert->CA_buf.slen) {",
          "577:      ca_data = CFDataCreate(NULL, (const UInt8 *)cert->CA_buf.ptr,",
          "578:               cert->CA_buf.slen);",
          "579:      if (!ca_data)",
          "580:          PJ_LOG(2, (THIS_FILE, \"Not enough memory for CA buffer\"));",
          "581:     }",
          "583:     if (ca_data) {",
          "584:         SecCertificateRef ca_cert;",
          "585:         CFMutableArrayRef ca_array;",
          "587:      ca_cert = SecCertificateCreateWithData(NULL, ca_data);",
          "588:      CFRelease(ca_data);",
          "589:      if (!ca_cert) {",
          "590:          PJ_LOG(2, (THIS_FILE, \"Failed creating certificate from \"",
          "591:                     \"CA file/buffer. It has to be \"",
          "592:                     \"in DER format.\"));",
          "593:          status = PJ_EINVAL;",
          "594:          goto on_return;",
          "595:      }",
          "597:      ca_array = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);",
          "598:     if (!ca_array) {",
          "599:          PJ_LOG(2, (THIS_FILE, \"Not enough memory for CA array\"));",
          "600:          CFRelease(ca_cert);",
          "601:          status = PJ_ENOMEM;",
          "602:          goto on_return;",
          "603:      }",
          "605:      CFArrayAppendValue(ca_array, ca_cert);",
          "606:      CFRelease(ca_cert);",
          "608:      err = SecTrustSetAnchorCertificates(trust, ca_array);",
          "609:      CFRelease(ca_array);",
          "610:      if (err != noErr)",
          "611:        pj_status_from_err(assock, \"SetAnchorCerts\", err);",
          "613:      err = SecTrustSetAnchorCertificatesOnly(trust, true);",
          "614:      if (err != noErr)",
          "615:        pj_status_from_err(assock, \"SetAnchorCertsOnly\", err);",
          "616:     }",
          "618:     result = SecTrustEvaluateWithError(trust, &error);",
          "619:     if (!result) {",
          "620:         pj_ssl_sock_t *ssock = &assock->base;",
          "621:  SecTrustResultType trust_result;",
          "623:         err = SecTrustGetTrustResult(trust, &trust_result);",
          "624:         if (err == noErr) {",
          "625:          switch (trust_result) {",
          "626:       case kSecTrustResultInvalid:",
          "627:       ssock->verify_status |= PJ_SSL_CERT_EINVALID_FORMAT;",
          "628:       break;",
          "630:       case kSecTrustResultDeny:",
          "631:       case kSecTrustResultFatalTrustFailure:",
          "632:           ssock->verify_status |= PJ_SSL_CERT_EUNTRUSTED;",
          "633:           break;",
          "635:       case kSecTrustResultRecoverableTrustFailure:",
          "642:           ssock->verify_status |= PJ_SSL_CERT_EVALIDITY_PERIOD;",
          "643:           break;",
          "645:       case kSecTrustResultOtherError:",
          "646:       ssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;",
          "647:       break;",
          "649:   default:",
          "650:       break;",
          "651:      }",
          "652:  }",
          "654:         if (error)",
          "655:             CFRelease(error);",
          "658:         status = PJ_EEOF;",
          "659:     }",
          "661: on_return:",
          "662:     if (status != PJ_SUCCESS && assock->base.verify_status == 0)",
          "663:      assock->base.verify_status |= PJ_SSL_CERT_EUNKNOWN;",
          "665:     return status;",
          "666: }",
          "676: static pj_status_t network_send(pj_ssl_sock_t *ssock,",
          "677:     pj_ioqueue_op_key_t *send_key,",
          "678:     const void *data,",
          "679:     pj_ssize_t *size,",
          "680:     unsigned flags)",
          "681: {",
          "682:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "683:     dispatch_data_t content;",
          "685:     content = dispatch_data_create(data, *size, assock->queue,",
          "686:            DISPATCH_DATA_DESTRUCTOR_DEFAULT);",
          "687:     if (!content)",
          "688:      return PJ_ENOMEM;",
          "690:     nw_connection_send(assock->connection, content,",
          "691:              NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT, true,",
          "692:              ^(nw_error_t error)",
          "693:     {",
          "694:      event_t event;",
          "696:  if (error != NULL) {",
          "697:          errno = nw_error_get_error_code(error);",
          "698:          if (errno == 89) {",
          "700:           return;",
          "701:          } else {",
          "702:           warn(\"Send error\");",
          "703:          }",
          "704:         }",
          "706:  event.type = EVENT_DATA_SENT;",
          "707:  event.body.data_sent_ev.send_key = send_key;",
          "708:  if (error != NULL) {",
          "709:      event.body.data_sent_ev.sent = (errno > 0)? -errno: errno;",
          "710:  } else {",
          "711:      event.body.data_sent_ev.sent = dispatch_data_get_size(content);",
          "712:  }",
          "714:  event_manager_post_event(ssock, &event, PJ_TRUE);",
          "715:     });",
          "716:     dispatch_release(content);",
          "718:     return PJ_EPENDING;",
          "719: }",
          "721: static pj_status_t network_start_read(pj_ssl_sock_t *ssock,",
          "722:           unsigned async_count,",
          "723:           unsigned buff_size,",
          "724:           void *readbuf[],",
          "725:           pj_uint32_t flags)",
          "726: {",
          "727:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "728:     unsigned i;",
          "730:     for (i = 0; i < async_count; i++) {",
          "731:  nw_connection_receive(assock->connection, 1, buff_size,",
          "732:      ^(dispatch_data_t content, nw_content_context_t context,",
          "733:        bool is_complete, nw_error_t error)",
          "734:  {",
          "735:      pj_status_t status = PJ_SUCCESS;",
          "737:      if (error != NULL) {",
          "738:           errno = nw_error_get_error_code(error);",
          "739:           if (errno == 89) {",
          "743:               return;",
          "744:           } else {",
          "745:               warn(\"Read error, stopping further receives\");",
          "746:               status = PJ_EEOF;",
          "747:           }",
          "748:             }",
          "753:      if (is_complete)",
          "754:       status = PJ_EEOF;",
          "756:      dispatch_block_t schedule_next_receive =",
          "757:      ^{",
          "759:       if (!error && !is_complete && assock->connection) {",
          "760:       network_start_read(ssock, async_count, buff_size,",
          "761:            readbuf, flags);",
          "762:       }",
          "763:      };",
          "765:             if (content) {",
          "766:                 schedule_next_receive = Block_copy(schedule_next_receive);",
          "768:              dispatch_data_apply(content,",
          "769:                     ^(dispatch_data_t region, size_t offset,",
          "770:                       const void *buffer, size_t inSize)",
          "771:              {",
          "772:                  event_t event;",
          "774:       memcpy(ssock->asock_rbuf[i], buffer, inSize);",
          "776:       event.type = EVENT_DATA_READ;",
          "777:       event.body.data_read_ev.data = ssock->asock_rbuf[i];",
          "778:       event.body.data_read_ev.size = inSize;",
          "779:       event.body.data_read_ev.status = status;",
          "780:       event.body.data_read_ev.remainder = 0;",
          "782:       event_manager_post_event(ssock, &event, PJ_FALSE);",
          "784:       schedule_next_receive();",
          "785:       Block_release(schedule_next_receive);",
          "787:                     return (bool)true;",
          "788:                 });",
          "789:             } else {",
          "790:              if (status != PJ_SUCCESS) {",
          "791:                  event_t event;",
          "794:       event.type = EVENT_DATA_READ;",
          "795:       event.body.data_read_ev.data = NULL;",
          "796:       event.body.data_read_ev.size = 0;",
          "797:       event.body.data_read_ev.status = status;",
          "798:       event.body.data_read_ev.remainder = 0;",
          "800:       event_manager_post_event(ssock, &event, PJ_TRUE);",
          "801:              }",
          "803:       schedule_next_receive();",
          "804:      }",
          "805:         });",
          "806:     }",
          "808:     return PJ_SUCCESS;",
          "809: }",
          "812: static pj_status_t network_get_localaddr(pj_ssl_sock_t *ssock,",
          "813:       pj_sockaddr_t *addr,",
          "814:       int *namelen)",
          "815: {",
          "816:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "817:     nw_path_t path;",
          "818:     nw_endpoint_t endpoint;",
          "819:     const struct sockaddr *address;",
          "821:     path = nw_connection_copy_current_path(assock->connection);",
          "822:     if (!path)",
          "823:      return PJ_EINVALIDOP;",
          "825:     endpoint = nw_path_copy_effective_local_endpoint(path);",
          "826:     nw_release(path);",
          "827:     if (!endpoint)",
          "828:      return PJ_EINVALIDOP;",
          "830:     address = nw_endpoint_get_address(endpoint);",
          "831:     if (address) {",
          "832:      pj_sockaddr_cp(addr, address);",
          "834:     }",
          "835:     nw_release(endpoint);",
          "837:     return PJ_SUCCESS;",
          "838: }",
          "840: static pj_status_t network_create_params(pj_ssl_sock_t * ssock,",
          "841:            const pj_sockaddr_t *localaddr,",
          "842:            pj_uint16_t port_range,",
          "843:            nw_parameters_t *p_params)",
          "844: {",
          "845:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "846:     char ip_addr[PJ_INET6_ADDRSTRLEN];",
          "847:     unsigned port;",
          "848:     char port_str[PJ_INET6_ADDRSTRLEN];",
          "849:     nw_endpoint_t local_endpoint;",
          "850:     nw_parameters_t parameters;",
          "851:     nw_parameters_configure_protocol_block_t configure_tls;",
          "852:     nw_protocol_stack_t protocol_stack;",
          "853:     nw_protocol_options_t ip_options;",
          "854:     tls_protocol_version_t min_proto = tls_protocol_version_TLSv10;",
          "855:     tls_protocol_version_t max_proto = tls_protocol_version_TLSv13;",
          "858:     if (ssock->param.proto == PJ_SSL_SOCK_PROTO_DEFAULT) {",
          "859:  ssock->param.proto = PJ_SSL_SOCK_PROTO_TLS1 |",
          "860:             PJ_SSL_SOCK_PROTO_TLS1_1 |",
          "861:             PJ_SSL_SOCK_PROTO_TLS1_2 |",
          "862:             PJ_SSL_SOCK_PROTO_TLS1_3;",
          "863:     }",
          "865:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_3) {",
          "866:  max_proto = tls_protocol_version_TLSv13;",
          "867:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_2) {",
          "868:  max_proto = tls_protocol_version_TLSv12;",
          "869:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_1) {",
          "870:  max_proto = tls_protocol_version_TLSv11;",
          "871:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1) {",
          "872:  max_proto = tls_protocol_version_TLSv10;",
          "873:     } else {",
          "874:  PJ_LOG(3, (THIS_FILE, \"Unsupported TLS protocol\"));",
          "875:  return PJ_EINVAL;",
          "876:     }",
          "878:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1) {",
          "879:  min_proto = tls_protocol_version_TLSv10;",
          "880:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_1) {",
          "881:  min_proto = tls_protocol_version_TLSv11;",
          "882:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_2) {",
          "883:  min_proto = tls_protocol_version_TLSv12;",
          "884:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_3) {",
          "885:  min_proto = tls_protocol_version_TLSv13;",
          "886:     }",
          "889:     if (ssock->cert)  {",
          "890:  pj_status_t status = create_identity_from_cert(assock, ssock->cert,",
          "891:              &assock->identity);",
          "892:  if (status != PJ_SUCCESS)",
          "893:          return status;",
          "894:     }",
          "896:     configure_tls = ^(nw_protocol_options_t tls_options)",
          "897:     {",
          "898:  sec_protocol_options_t sec_options;",
          "900:  sec_options = nw_tls_copy_sec_protocol_options(tls_options);",
          "903:      if (ssock->cert && assock->identity) {",
          "904:      sec_protocol_options_set_local_identity(sec_options,",
          "905:               assock->identity);",
          "906:  }",
          "908:  sec_protocol_options_set_min_tls_protocol_version(sec_options,",
          "909:              min_proto);",
          "910:  sec_protocol_options_set_max_tls_protocol_version(sec_options,",
          "911:          max_proto);",
          "914:      if (ssock->param.ciphers_num > 0) {",
          "915:          unsigned i;",
          "916:          for (i = 0; i < ssock->param.ciphers_num; i++) {",
          "917:           sec_protocol_options_append_tls_ciphersuite(sec_options,",
          "918:           (tls_ciphersuite_t)ssock->param.ciphers[i]);",
          "919:      }",
          "920:  }",
          "922:  if (!ssock->is_server && ssock->param.server_name.slen) {",
          "923:      sec_protocol_options_set_tls_server_name(sec_options,",
          "924:       ssock->param.server_name.ptr);",
          "925:  }",
          "927:  sec_protocol_options_set_tls_renegotiation_enabled(sec_options,",
          "928:           true);",
          "931:      sec_protocol_options_set_peer_authentication_required(sec_options,",
          "932:          true);",
          "941:         sec_protocol_options_set_challenge_block(sec_options,",
          "942:      ^(sec_protocol_metadata_t metadata,",
          "943:        sec_protocol_challenge_complete_t complete)",
          "944:  {",
          "945:      complete(assock->identity);",
          "946:  }, assock->queue);",
          "948:  sec_protocol_options_set_verify_block(sec_options,",
          "949:      ^(sec_protocol_metadata_t metadata, sec_trust_t trust_ref,",
          "950:        sec_protocol_verify_complete_t complete)",
          "951:  {",
          "952:      event_t event;",
          "953:      bool result = true;",
          "955:          assock->trust = trust_ref? sec_trust_copy_ref(trust_ref): nil;",
          "957:      assock->cipher =",
          "958:        sec_protocol_metadata_get_negotiated_tls_ciphersuite(metadata);",
          "961:      if (!ssock->is_server) {",
          "962:       event.type = EVENT_CONNECT;",
          "963:       event.body.connect_ev.status = PJ_SUCCESS;",
          "964:       event_manager_post_event(ssock, &event, PJ_FALSE);",
          "965:      }",
          "967:      event.type = EVENT_VERIFY_CERT;",
          "968:      event_manager_post_event(ssock, &event, PJ_FALSE);",
          "971:      if (ssock->verify_status != PJ_SSL_CERT_ESUCCESS) {",
          "972:   if (ssock->param.verify_peer) {",
          "974:              result = false;",
          "975:       } else {",
          "979:               result = true;",
          "980:           }",
          "981:          }",
          "983:      complete(result);",
          "984:         }, assock->queue);",
          "986:  nw_release(sec_options);",
          "987:     };",
          "989:     parameters = nw_parameters_create_secure_tcp(configure_tls,",
          "990:            NW_PARAMETERS_DEFAULT_CONFIGURATION);",
          "992:     protocol_stack = nw_parameters_copy_default_protocol_stack(parameters);",
          "993:     ip_options = nw_protocol_stack_copy_internet_protocol(protocol_stack);",
          "994:     if (ssock->param.sock_af == pj_AF_INET()) {",
          "995:  nw_ip_options_set_version(ip_options, nw_ip_version_4);",
          "996:     } else if (ssock->param.sock_af == pj_AF_INET6()) {",
          "997:  nw_ip_options_set_version(ip_options, nw_ip_version_6);",
          "998:     }",
          "999:     nw_release(ip_options);",
          "1000:     nw_release(protocol_stack);",
          "1002:     if (ssock->is_server && ssock->param.reuse_addr) {",
          "1003:      nw_parameters_set_reuse_local_address(parameters, true);",
          "1004:     }",
          "1009:     pj_sockaddr_print(localaddr, ip_addr,sizeof(ip_addr),0);",
          "1011:     if (port_range) {",
          "1012:  pj_uint16_t max_try = MAX_BIND_RETRY;",
          "1014:  if (port_range && port_range < max_try) {",
          "1015:      max_try = port_range;",
          "1016:  }",
          "1017:  for (; max_try; --max_try) {",
          "1018:      pj_uint16_t base_port;",
          "1020:      base_port = pj_sockaddr_get_port(localaddr);",
          "1021:      port = (pj_uint16_t)(base_port + pj_rand() % (port_range + 1));",
          "1022:      pj_utoa(port, port_str);",
          "1024:      local_endpoint = nw_endpoint_create_host(ip_addr, port_str);",
          "1025:      if (local_endpoint)",
          "1026:       break;",
          "1027:  }",
          "1028:     } else {",
          "1029:      port = pj_sockaddr_get_port(localaddr);",
          "1030:      pj_utoa(port, port_str);",
          "1032:      local_endpoint = nw_endpoint_create_host(ip_addr, port_str);",
          "1033:     }",
          "1035:     if (!local_endpoint) {",
          "1036:         PJ_LOG(2, (THIS_FILE, \"Failed creating local endpoint\"));",
          "1037:      return PJ_EINVALIDOP;",
          "1038:     }",
          "1040:     nw_parameters_set_local_endpoint(parameters, local_endpoint);",
          "1041:     nw_release(local_endpoint);",
          "1044:     return PJ_SUCCESS;",
          "1045: }",
          "1048: static pj_status_t network_setup_connection(pj_ssl_sock_t *ssock,",
          "1049:          void *connection)",
          "1050: {",
          "1051:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "1052:     assock->connection = (nw_connection_t)connection;",
          "1053:     pj_status_t status;",
          "1056:     status = circ_init(ssock->pool->factory, &ssock->circ_buf_input, 8192);",
          "1057:     if (status != PJ_SUCCESS)",
          "1058:         return status;",
          "1061:     status = circ_init(ssock->pool->factory, &ssock->circ_buf_output, 8192);",
          "1062:     if (status != PJ_SUCCESS)",
          "1063:         return status;",
          "1065:     nw_connection_set_queue(assock->connection, assock->queue);",
          "1067:     nw_connection_set_state_changed_handler(assock->connection,",
          "1068:      ^(nw_connection_state_t state, nw_error_t error)",
          "1069:     {",
          "1070:      pj_status_t status = PJ_SUCCESS;",
          "1071:      pj_bool_t call_cb = PJ_FALSE;",
          "1073:  if (error && state != nw_connection_state_cancelled) {",
          "1074:          errno = nw_error_get_error_code(error);",
          "1075:             warn(\"Connection failed %p\", assock);",
          "1076:             status = PJ_STATUS_FROM_OS(errno);",
          "1077:             call_cb = PJ_TRUE;",
          "1078:  }",
          "1080:  if (state == nw_connection_state_ready) {",
          "1081:      if (ssock->is_server) {",
          "1082:       nw_protocol_definition_t tls_def;",
          "1083:       nw_protocol_metadata_t prot_meta;",
          "1084:       sec_protocol_metadata_t meta;",
          "1086:       tls_def = nw_protocol_copy_tls_definition();",
          "1087:       prot_meta = nw_connection_copy_protocol_metadata(connection,",
          "1088:              tls_def);",
          "1089:   meta = nw_tls_copy_sec_protocol_metadata(prot_meta);",
          "1090:   assock->cipher =",
          "1091:             sec_protocol_metadata_get_negotiated_tls_ciphersuite(meta);",
          "1093:   if (ssock->param.require_client_cert &&",
          "1094:       !sec_protocol_metadata_access_peer_certificate_chain(",
          "1095:        meta, ^(sec_certificate_t certificate) {} ))",
          "1096:   {",
          "1097:       status = PJ_EEOF;",
          "1098:   }",
          "1099:   nw_release(tls_def);",
          "1100:   nw_release(prot_meta);",
          "1101:   nw_release(meta);",
          "1102:      }",
          "1103:      call_cb = PJ_TRUE;",
          "1104:  } else if (state == nw_connection_state_cancelled) {",
          "1108:  }",
          "1110:  if (call_cb) {",
          "1111:      event_t event;",
          "1113:      event.type = EVENT_HANDSHAKE_COMPLETE;",
          "1114:      event.body.handshake_ev.status = status;",
          "1115:      event_manager_post_event(ssock, &event, PJ_TRUE);",
          "1117:      if (ssock->is_server && status == PJ_SUCCESS) {",
          "1118:              status = network_start_read(ssock, ssock->param.async_cnt,",
          "1119:                    (unsigned)ssock->param.read_buffer_size,",
          "1120:         ssock->asock_rbuf, 0);",
          "1121:      }",
          "1122:  }",
          "1123:     });",
          "1125:     nw_connection_start(assock->connection);",
          "1127:     return PJ_SUCCESS;",
          "1128: }",
          "1130: static pj_status_t network_start_accept(pj_ssl_sock_t *ssock,",
          "1131:       pj_pool_t *pool,",
          "1132:        const pj_sockaddr_t *localaddr,",
          "1133:        int addr_len,",
          "1134:        const pj_ssl_sock_param *newsock_param)",
          "1135: {",
          "1136:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "1137:     unsigned port;",
          "1138:     char port_str[PJ_INET6_ADDRSTRLEN];",
          "1139:     pj_status_t status;",
          "1140:     nw_parameters_t parameters = NULL;",
          "1142:     status = network_create_params(ssock, localaddr, 0, &parameters);",
          "1143:     if (status != PJ_SUCCESS)",
          "1144:      return status;",
          "1147:     port = pj_sockaddr_get_port(localaddr);",
          "1148:     if (port != 0) {",
          "1149:      pj_utoa(port, port_str);",
          "1150:      assock->listener = nw_listener_create_with_port(port_str, parameters);",
          "1151:     } else {",
          "1152:         assock->listener = nw_listener_create(parameters);",
          "1153:     }",
          "1154:     nw_release(parameters);",
          "1155:     if (!assock->listener) {",
          "1156:         PJ_LOG(2, (THIS_FILE, \"Failed creating listener\"));",
          "1157:      return PJ_EINVALIDOP;",
          "1158:     }",
          "1160:     nw_listener_set_queue(assock->listener, assock->queue);",
          "1162:     nw_retain(assock->listener);",
          "1164:     nw_listener_set_state_changed_handler(assock->listener,",
          "1165:         ^(nw_listener_state_t state, nw_error_t error)",
          "1166:     {",
          "1167:  errno = error ? nw_error_get_error_code(error) : 0;",
          "1168:  if (state == nw_listener_state_failed) {",
          "1169:      warn(\"listener failed\\n\");",
          "1170:      pj_sockaddr_set_port(&ssock->local_addr, 0);",
          "1171:      dispatch_semaphore_signal(assock->ev_semaphore);",
          "1172:  } else if (state == nw_listener_state_ready) {",
          "1174:          pj_sockaddr_set_port(&ssock->local_addr,",
          "1175:                 nw_listener_get_port(assock->listener));",
          "1176:      dispatch_semaphore_signal(assock->ev_semaphore);",
          "1177:  } else if (state == nw_listener_state_cancelled) {",
          "1181:  }",
          "1182:     });",
          "1184:     nw_listener_set_new_connection_handler(assock->listener,",
          "1185:      ^(nw_connection_t connection)",
          "1186:     {",
          "1187:  nw_endpoint_t endpoint = nw_connection_copy_endpoint(connection);",
          "1188:  const struct sockaddr *address;",
          "1189:  event_t event;",
          "1191:  address = nw_endpoint_get_address(endpoint);",
          "1193:  event.type = EVENT_ACCEPT;",
          "1194:  event.body.accept_ev.newconn = connection;",
          "1195:  pj_sockaddr_cp(&event.body.accept_ev.src_addr, address);",
          "1196:  event.body.accept_ev.src_addr_len = pj_sockaddr_get_addr_len(address);",
          "1197:  event.body.accept_ev.status = PJ_SUCCESS;",
          "1199:  nw_retain(connection);",
          "1200:  event_manager_post_event(ssock, &event, PJ_TRUE);",
          "1202:  nw_release(endpoint);",
          "1203:     });",
          "1206:     ssock->addr_len = addr_len;",
          "1207:     pj_sockaddr_cp(&ssock->local_addr, localaddr);",
          "1210:     pj_ssl_sock_param_copy(pool, &ssock->newsock_param, newsock_param);",
          "1211:     ssock->newsock_param.grp_lock = NULL;",
          "1214:     nw_listener_start(assock->listener);",
          "1216:     dispatch_semaphore_wait(assock->ev_semaphore, DISPATCH_TIME_FOREVER);",
          "1218:     if (pj_sockaddr_get_port(&ssock->local_addr) == 0) {",
          "1220:      status = PJ_EEOF;",
          "1221:      goto on_error;",
          "1222:     }",
          "1224:     return PJ_SUCCESS;",
          "1226: on_error:",
          "1227:     ssl_reset_sock_state(ssock);",
          "1228:     return status;",
          "1229: }",
          "1232: static pj_status_t network_start_connect(pj_ssl_sock_t *ssock,",
          "1233:          pj_ssl_start_connect_param *connect_param)",
          "1234: {",
          "1235:     char ip_addr[PJ_INET6_ADDRSTRLEN];",
          "1236:     unsigned port;",
          "1237:     char port_str[PJ_INET6_ADDRSTRLEN];",
          "1238:     nw_endpoint_t endpoint;",
          "1239:     nw_parameters_t parameters;",
          "1240:     nw_connection_t connection;",
          "1241:     pj_status_t status;",
          "1243:     pj_pool_t *pool = connect_param->pool;",
          "1244:     const pj_sockaddr_t *localaddr = connect_param->localaddr;",
          "1245:     pj_uint16_t port_range = connect_param->local_port_range;",
          "1246:     const pj_sockaddr_t *remaddr = connect_param->remaddr;",
          "1247:     int addr_len = connect_param->addr_len;",
          "1249:     PJ_ASSERT_RETURN(ssock && pool && localaddr && remaddr && addr_len,",
          "1250:        PJ_EINVAL);",
          "1252:     status = network_create_params(ssock, localaddr, port_range,",
          "1253:            &parameters);",
          "1254:     if (status != PJ_SUCCESS)",
          "1255:      return status;",
          "1258:     pj_sockaddr_print(remaddr, ip_addr,sizeof(ip_addr),0);",
          "1259:     port = pj_sockaddr_get_port(remaddr);",
          "1260:     pj_utoa(port, port_str);",
          "1262:     endpoint = nw_endpoint_create_host(ip_addr, port_str);",
          "1263:     if (!endpoint) {",
          "1264:         PJ_LOG(2, (THIS_FILE, \"Failed creating remote endpoint\"));",
          "1265:      nw_release(parameters);",
          "1266:      return PJ_EINVALIDOP;",
          "1267:     }",
          "1269:     connection = nw_connection_create(endpoint, parameters);",
          "1270:     nw_release(endpoint);",
          "1271:     nw_release(parameters);",
          "1272:     if (!connection) {",
          "1273:         PJ_LOG(2, (THIS_FILE, \"Failed creating connection\"));",
          "1274:      return PJ_EINVALIDOP;",
          "1275:     }",
          "1278:     nw_retain(connection);",
          "1280:     status = network_setup_connection(ssock, connection);",
          "1281:     if (status != PJ_SUCCESS)",
          "1282:      return status;",
          "1285:     pj_sockaddr_cp(&ssock->rem_addr, remaddr);",
          "1288:     ssock->addr_len = addr_len;",
          "1289:     pj_sockaddr_cp(&ssock->local_addr, localaddr);",
          "1291:     return PJ_EPENDING;",
          "1292: }",
          "1301: static pj_ssl_sock_t *ssl_alloc(pj_pool_t *pool)",
          "1302: {",
          "1303:     applessl_sock_t *assock;",
          "1306:     if (event_manager_create() != PJ_SUCCESS)",
          "1307:      return NULL;",
          "1309:     assock = PJ_POOL_ZALLOC_T(pool, applessl_sock_t);",
          "1311:     assock->queue = dispatch_queue_create(\"ssl_queue\", DISPATCH_QUEUE_SERIAL);",
          "1312:     assock->ev_semaphore = dispatch_semaphore_create(0);",
          "1313:     if (!assock->queue || !assock->ev_semaphore) {",
          "1314:      ssl_destroy(&assock->base);",
          "1315:      return NULL;",
          "1316:     }",
          "1318:     return (pj_ssl_sock_t *)assock;",
          "1319: }",
          "1321: static pj_status_t ssl_create(pj_ssl_sock_t *ssock)",
          "1322: {",
          "1326:     return PJ_SUCCESS;",
          "1327: }",
          "1330: static void ssl_close_sockets(pj_ssl_sock_t *ssock)",
          "1331: {",
          "1332:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "1334:     if (assock->identity) {",
          "1335:     nw_release(assock->identity);",
          "1336:     assock->identity = nil;",
          "1337:     }",
          "1340:     if (!ssock->write_mutex)",
          "1341:      return;",
          "1343:     pj_lock_acquire(ssock->write_mutex);",
          "1344:     if (assock->connection) {",
          "1345:      nw_connection_cancel(assock->connection);",
          "1346:      nw_release(assock->connection);",
          "1347:      assock->connection = nil;",
          "1348:     }",
          "1349:     pj_lock_release(ssock->write_mutex);",
          "1350: }",
          "1353: static void ssl_destroy(pj_ssl_sock_t *ssock)",
          "1354: {",
          "1355:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "1358:     if (assock->connection) {",
          "1359:      nw_connection_force_cancel(assock->connection);",
          "1360:      nw_release(assock->connection);",
          "1361:      assock->connection = nil;",
          "1362:     }",
          "1364:     if (assock->listener) {",
          "1365:      nw_listener_cancel(assock->listener);",
          "1366:  nw_release(assock->listener);",
          "1367:    assock->listener = nil;",
          "1368:     }",
          "1370:     event_manager_remove_events(ssock);",
          "1375:     if (assock->ev_semaphore) {",
          "1376:      dispatch_semaphore_signal(assock->ev_semaphore);",
          "1377:     }",
          "1379:     if (assock->queue) {",
          "1380:      dispatch_release(assock->queue);",
          "1381:      assock->queue = NULL;",
          "1382:     }",
          "1384:     if (assock->ev_semaphore) {",
          "1385:      dispatch_release(assock->ev_semaphore);",
          "1386:      assock->ev_semaphore = nil;",
          "1387:     }",
          "1390:     circ_deinit(&ssock->circ_buf_input);",
          "1391:     circ_deinit(&ssock->circ_buf_output);",
          "1392: }",
          "1396: static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)",
          "1397: {",
          "1398:     pj_lock_acquire(ssock->circ_buf_output_mutex);",
          "1399:     ssock->ssl_state = SSL_STATE_NULL;",
          "1400:     pj_lock_release(ssock->circ_buf_output_mutex);",
          "1402:     ssl_close_sockets(ssock);",
          "1403: }",
          "1409: const char *sslGetCipherSuiteString(SSLCipherSuite cs)",
          "1410: {",
          "1411:     switch (cs) {",
          "1413:         case TLS_RSA_WITH_AES_128_CBC_SHA:",
          "1414:             return \"TLS_RSA_WITH_AES_128_CBC_SHA\";",
          "1415:         case TLS_DH_DSS_WITH_AES_128_CBC_SHA:",
          "1416:             return \"TLS_DH_DSS_WITH_AES_128_CBC_SHA\";",
          "1417:         case TLS_DH_RSA_WITH_AES_128_CBC_SHA:",
          "1418:             return \"TLS_DH_RSA_WITH_AES_128_CBC_SHA\";",
          "1419:         case TLS_DHE_DSS_WITH_AES_128_CBC_SHA:",
          "1420:             return \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\";",
          "1421:         case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:",
          "1422:             return \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\";",
          "1423:         case TLS_DH_anon_WITH_AES_128_CBC_SHA:",
          "1424:             return \"TLS_DH_anon_WITH_AES_128_CBC_SHA\";",
          "1425:         case TLS_RSA_WITH_AES_256_CBC_SHA:",
          "1426:             return \"TLS_RSA_WITH_AES_256_CBC_SHA\";",
          "1427:         case TLS_DH_DSS_WITH_AES_256_CBC_SHA:",
          "1428:             return \"TLS_DH_DSS_WITH_AES_256_CBC_SHA\";",
          "1429:         case TLS_DH_RSA_WITH_AES_256_CBC_SHA:",
          "1430:             return \"TLS_DH_RSA_WITH_AES_256_CBC_SHA\";",
          "1431:         case TLS_DHE_DSS_WITH_AES_256_CBC_SHA:",
          "1432:             return \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\";",
          "1433:         case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:",
          "1434:             return \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\";",
          "1435:         case TLS_DH_anon_WITH_AES_256_CBC_SHA:",
          "1436:             return \"TLS_DH_anon_WITH_AES_256_CBC_SHA\";",
          "1439:         case TLS_ECDH_ECDSA_WITH_NULL_SHA:",
          "1440:             return \"TLS_ECDH_ECDSA_WITH_NULL_SHA\";",
          "1441:         case TLS_ECDH_ECDSA_WITH_RC4_128_SHA:",
          "1442:             return \"TLS_ECDH_ECDSA_WITH_RC4_128_SHA\";",
          "1443:         case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:",
          "1444:             return \"TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\";",
          "1445:         case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:",
          "1446:             return \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\";",
          "1447:         case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:",
          "1448:             return \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\";",
          "1449:         case TLS_ECDHE_ECDSA_WITH_NULL_SHA:",
          "1450:             return \"TLS_ECDHE_ECDSA_WITH_NULL_SHA\";",
          "1451:         case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:",
          "1452:             return \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\";",
          "1453:         case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:",
          "1454:             return \"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\";",
          "1455:         case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:",
          "1456:             return \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\";",
          "1457:         case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:",
          "1458:             return \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\";",
          "1459:         case TLS_ECDH_RSA_WITH_NULL_SHA:",
          "1460:             return \"TLS_ECDH_RSA_WITH_NULL_SHA\";",
          "1461:         case TLS_ECDH_RSA_WITH_RC4_128_SHA:",
          "1462:             return \"TLS_ECDH_RSA_WITH_RC4_128_SHA\";",
          "1463:         case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:",
          "1464:             return \"TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\";",
          "1465:         case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:",
          "1466:             return \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\";",
          "1467:         case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:",
          "1468:             return \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\";",
          "1469:         case TLS_ECDHE_RSA_WITH_NULL_SHA:",
          "1470:             return \"TLS_ECDHE_RSA_WITH_NULL_SHA\";",
          "1471:         case TLS_ECDHE_RSA_WITH_RC4_128_SHA:",
          "1472:             return \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\";",
          "1473:         case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:",
          "1474:             return \"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\";",
          "1475:         case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:",
          "1476:             return \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\";",
          "1477:         case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:",
          "1478:             return \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\";",
          "1479:         case TLS_ECDH_anon_WITH_NULL_SHA:",
          "1480:             return \"TLS_ECDH_anon_WITH_NULL_SHA\";",
          "1481:         case TLS_ECDH_anon_WITH_RC4_128_SHA:",
          "1482:             return \"TLS_ECDH_anon_WITH_RC4_128_SHA\";",
          "1483:         case TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA:",
          "1484:             return \"TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\";",
          "1485:         case TLS_ECDH_anon_WITH_AES_128_CBC_SHA:",
          "1486:             return \"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\";",
          "1487:         case TLS_ECDH_anon_WITH_AES_256_CBC_SHA:",
          "1488:             return \"TLS_ECDH_anon_WITH_AES_256_CBC_SHA\";",
          "1491:         case TLS_RSA_WITH_AES_128_CBC_SHA256:",
          "1492:             return \"TLS_RSA_WITH_AES_128_CBC_SHA256\";",
          "1493:         case TLS_RSA_WITH_AES_256_CBC_SHA256:",
          "1494:             return \"TLS_RSA_WITH_AES_256_CBC_SHA256\";",
          "1495:         case TLS_DH_DSS_WITH_AES_128_CBC_SHA256:",
          "1496:             return \"TLS_DH_DSS_WITH_AES_128_CBC_SHA256\";",
          "1497:         case TLS_DH_RSA_WITH_AES_128_CBC_SHA256:",
          "1498:             return \"TLS_DH_RSA_WITH_AES_128_CBC_SHA256\";",
          "1499:         case TLS_DHE_DSS_WITH_AES_128_CBC_SHA256:",
          "1500:             return \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\";",
          "1501:         case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:",
          "1502:             return \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\";",
          "1503:         case TLS_DH_DSS_WITH_AES_256_CBC_SHA256:",
          "1504:             return \"TLS_DH_DSS_WITH_AES_256_CBC_SHA256\";",
          "1505:         case TLS_DH_RSA_WITH_AES_256_CBC_SHA256:",
          "1506:             return \"TLS_DH_RSA_WITH_AES_256_CBC_SHA256\";",
          "1507:         case TLS_DHE_DSS_WITH_AES_256_CBC_SHA256:",
          "1508:             return \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\";",
          "1509:         case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:",
          "1510:             return \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\";",
          "1511:         case TLS_DH_anon_WITH_AES_128_CBC_SHA256:",
          "1512:             return \"TLS_DH_anon_WITH_AES_128_CBC_SHA256\";",
          "1513:         case TLS_DH_anon_WITH_AES_256_CBC_SHA256:",
          "1514:             return \"TLS_DH_anon_WITH_AES_256_CBC_SHA256\";",
          "1517:         case TLS_RSA_WITH_AES_128_GCM_SHA256:",
          "1518:             return \"TLS_RSA_WITH_AES_128_GCM_SHA256\";",
          "1519:         case TLS_RSA_WITH_AES_256_GCM_SHA384:",
          "1520:             return \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\";",
          "1521:         case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:",
          "1522:             return \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\";",
          "1523:         case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:",
          "1524:             return \"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\";",
          "1525:         case TLS_DH_RSA_WITH_AES_128_GCM_SHA256:",
          "1526:             return \"TLS_DH_RSA_WITH_AES_128_GCM_SHA256\";",
          "1527:         case TLS_DH_RSA_WITH_AES_256_GCM_SHA384:",
          "1528:             return \"TLS_DH_RSA_WITH_AES_256_GCM_SHA384\";",
          "1529:         case TLS_DHE_DSS_WITH_AES_128_GCM_SHA256:",
          "1530:             return \"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\";",
          "1531:         case TLS_DHE_DSS_WITH_AES_256_GCM_SHA384:",
          "1532:             return \"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\";",
          "1533:         case TLS_DH_DSS_WITH_AES_128_GCM_SHA256:",
          "1534:             return \"TLS_DH_DSS_WITH_AES_128_GCM_SHA256\";",
          "1535:         case TLS_DH_DSS_WITH_AES_256_GCM_SHA384:",
          "1536:             return \"TLS_DH_DSS_WITH_AES_256_GCM_SHA384\";",
          "1537:         case TLS_DH_anon_WITH_AES_128_GCM_SHA256:",
          "1538:             return \"TLS_DH_anon_WITH_AES_128_GCM_SHA256\";",
          "1539:         case TLS_DH_anon_WITH_AES_256_GCM_SHA384:",
          "1540:             return \"TLS_DH_anon_WITH_AES_256_GCM_SHA384\";",
          "1543:         case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:",
          "1544:             return \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\";",
          "1545:         case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:",
          "1546:             return \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\";",
          "1547:         case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:",
          "1548:             return \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\";",
          "1549:         case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:",
          "1550:             return \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\";",
          "1551:         case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:",
          "1552:             return \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\";",
          "1553:         case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:",
          "1554:             return \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\";",
          "1555:         case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:",
          "1556:             return \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\";",
          "1557:         case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:",
          "1558:             return \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\";",
          "1559:         case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:",
          "1560:             return \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\";",
          "1561:         case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:",
          "1562:             return \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\";",
          "1563:         case TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:",
          "1564:             return \"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\";",
          "1565:         case TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:",
          "1566:             return \"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\";",
          "1567:         case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:",
          "1568:             return \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\";",
          "1569:         case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:",
          "1570:             return \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";",
          "1571:         case TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:",
          "1572:             return \"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\";",
          "1573:         case TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:",
          "1574:             return \"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\";",
          "1576:  case TLS_AES_128_GCM_SHA256:",
          "1577:      return \"TLS_AES_128_GCM_SHA256\";",
          "1578:  case TLS_AES_256_GCM_SHA384:",
          "1579:      return \"TLS_AES_256_GCM_SHA384\";",
          "1580:  case TLS_CHACHA20_POLY1305_SHA256:",
          "1581:      return \"TLS_CHACHA20_POLY1305_SHA256\";",
          "1582:  case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:",
          "1583:      return \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\";",
          "1584:  case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:",
          "1585:      return \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\";",
          "1586:  case TLS_RSA_WITH_3DES_EDE_CBC_SHA:",
          "1587:      return \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\";",
          "1589:         default:",
          "1590:             return \"TLS_CIPHER_STRING_UNKNOWN\";",
          "1591:     }",
          "1592: }",
          "1594: static void ssl_ciphers_populate(void)",
          "1595: {",
          "1600:     tls_ciphersuite_t ciphers[] = {",
          "1601:      tls_ciphersuite_AES_128_GCM_SHA256,",
          "1602:  tls_ciphersuite_AES_256_GCM_SHA384,",
          "1603:  tls_ciphersuite_CHACHA20_POLY1305_SHA256,",
          "1604:      tls_ciphersuite_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,",
          "1605:  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,",
          "1606:  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,",
          "1607:  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,",
          "1608:  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,",
          "1609:  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,",
          "1610:  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,",
          "1611:  tls_ciphersuite_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,",
          "1612:  tls_ciphersuite_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,",
          "1613:  tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA,",
          "1614:  tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA256,",
          "1615:  tls_ciphersuite_ECDHE_RSA_WITH_AES_128_GCM_SHA256,",
          "1616:  tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA,",
          "1617:  tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA384,",
          "1618:  tls_ciphersuite_ECDHE_RSA_WITH_AES_256_GCM_SHA384,",
          "1619:  tls_ciphersuite_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,",
          "1620:  tls_ciphersuite_RSA_WITH_3DES_EDE_CBC_SHA,",
          "1621:  tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA,",
          "1622:  tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA256,",
          "1623:  tls_ciphersuite_RSA_WITH_AES_128_GCM_SHA256,",
          "1624:  tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA,",
          "1625:  tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA256,",
          "1626:  tls_ciphersuite_RSA_WITH_AES_256_GCM_SHA384",
          "1627:     };",
          "1628:     if (!ssl_cipher_num) {",
          "1629:      unsigned i;",
          "1631:      ssl_cipher_num = sizeof(ciphers)/sizeof(ciphers[0]);",
          "1632:  for (i = 0; i < ssl_cipher_num; i++) {",
          "1633:      ssl_ciphers[i].id = (pj_ssl_cipher)ciphers[i];",
          "1634:      ssl_ciphers[i].name = sslGetCipherSuiteString(ciphers[i]);",
          "1635:  }",
          "1636:     }",
          "1637: }",
          "1640: static pj_ssl_cipher ssl_get_cipher(pj_ssl_sock_t *ssock)",
          "1641: {",
          "1642:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "1644:     return (pj_ssl_cipher) assock->cipher;",
          "1645: }",
          "1648: #if !TARGET_OS_IPHONE",
          "1649: static void get_info_and_cn(CFArrayRef array, CFMutableStringRef info,",
          "1650:        CFStringRef *cn)",
          "1651: {",
          "1652:     const void *keys[] = {kSecOIDOrganizationalUnitName, kSecOIDCountryName,",
          "1653:          kSecOIDStateProvinceName, kSecOIDLocalityName,",
          "1654:          kSecOIDOrganizationName, kSecOIDCommonName};",
          "1655:     const char *labels[] = { \"OU=\", \"C=\", \"ST=\", \"L=\", \"O=\", \"CN=\"};",
          "1656:     pj_bool_t add_separator = PJ_FALSE;",
          "1657:     int i, n;",
          "1660:     for(i = 0; i < sizeof(keys)/sizeof(keys[0]);  i++) {",
          "1661:         for (n = 0 ; n < CFArrayGetCount(array); n++) {",
          "1662:             CFDictionaryRef dict;",
          "1663:             CFTypeRef dictkey;",
          "1664:             CFStringRef str;",
          "1666:             dict = CFArrayGetValueAtIndex(array, n);",
          "1667:             if (CFGetTypeID(dict) != CFDictionaryGetTypeID())",
          "1668:                 continue;",
          "1669:             dictkey = CFDictionaryGetValue(dict, kSecPropertyKeyLabel);",
          "1670:             if (!CFEqual(dictkey, keys[i]))",
          "1671:                 continue;",
          "1672:             str = (CFStringRef) CFDictionaryGetValue(dict,",
          "1673:                       kSecPropertyKeyValue);",
          "1675:             if (CFStringGetLength(str) > 0) {",
          "1676:              if (add_separator) {",
          "1677:                     CFStringAppendCString(info, \"/\", kCFStringEncodingUTF8);",
          "1678:                 }",
          "1679:                 CFStringAppendCString(info, labels[i], kCFStringEncodingUTF8);",
          "1680:                 CFStringAppend(info, str);",
          "1681:   add_separator = PJ_TRUE;",
          "1683:   if (CFEqual(keys[i], kSecOIDCommonName))",
          "1685:             }",
          "1686:         }",
          "1687:     }",
          "1688: }",
          "1690: static CFDictionaryRef get_cert_oid(SecCertificateRef cert, CFStringRef oid,",
          "1691:         CFTypeRef *value)",
          "1692: {",
          "1693:     void *key[1];",
          "1694:     CFArrayRef key_arr;",
          "1695:     CFDictionaryRef vals, dict;",
          "1697:     key[0] = (void *)oid;",
          "1698:     key_arr = CFArrayCreate(NULL, (const void **)key, 1,",
          "1699:            &kCFTypeArrayCallBacks);",
          "1701:     vals = SecCertificateCopyValues(cert, key_arr, NULL);",
          "1702:     dict = CFDictionaryGetValue(vals, key[0]);",
          "1705:     CFRelease(key_arr);",
          "1707:     return vals;",
          "1708: }",
          "1710: #endif",
          "1716: static void get_cert_info(pj_pool_t *pool, pj_ssl_cert_info *ci,",
          "1717:      SecCertificateRef cert)",
          "1718: {",
          "1719:     pj_bool_t update_needed;",
          "1720:     char buf[512];",
          "1721:     size_t bufsize = sizeof(buf);",
          "1722:     const pj_uint8_t *serial_no = NULL;",
          "1723:     size_t serialsize = 0;",
          "1724:     CFMutableStringRef issuer_info;",
          "1725:     CFStringRef str;",
          "1726:     CFDataRef serial = NULL;",
          "1727: #if !TARGET_OS_IPHONE",
          "1728:     CFStringRef issuer_cn = NULL;",
          "1729:     CFDictionaryRef dict;",
          "1730: #endif",
          "1732:     pj_assert(pool && ci && cert);",
          "1735:     issuer_info = CFStringCreateMutable(NULL, 0);",
          "1736: #if !TARGET_OS_IPHONE",
          "1737: {",
          "1742:     CFArrayRef issuer_vals;",
          "1744:     dict = get_cert_oid(cert, kSecOIDX509V1IssuerName,",
          "1745:        (CFTypeRef *)&issuer_vals);",
          "1746:     if (dict) {",
          "1747:      get_info_and_cn(issuer_vals, issuer_info, &issuer_cn);",
          "1748:      if (issuer_cn)",
          "1749:          issuer_cn = CFStringCreateCopy(NULL, issuer_cn);",
          "1750:      CFRelease(dict);",
          "1751:     }",
          "1752: }",
          "1753: #endif",
          "1754:     CFStringGetCString(issuer_info, buf, bufsize, kCFStringEncodingUTF8);",
          "1757:     if (__builtin_available(macOS 10.13, iOS 11.0, *)) {",
          "1758:  serial = SecCertificateCopySerialNumberData(cert, NULL);",
          "1759:      if (serial) {",
          "1760:          serial_no = CFDataGetBytePtr(serial);",
          "1761:          serialsize = CFDataGetLength(serial);",
          "1762:      }",
          "1763:     }",
          "1766:     update_needed = pj_strcmp2(&ci->issuer.info, buf) ||",
          "1767:                     pj_memcmp(ci->serial_no, serial_no, serialsize);",
          "1768:     if (!update_needed) {",
          "1769:         CFRelease(issuer_info);",
          "1770:         return;",
          "1771:     }",
          "1775:     pj_bzero(ci, sizeof(pj_ssl_cert_info));",
          "1778: #if !TARGET_OS_IPHONE",
          "1779: {",
          "1780:     CFStringRef version;",
          "1782:     dict = get_cert_oid(cert, kSecOIDX509V1Version,",
          "1783:        (CFTypeRef *)&version);",
          "1784:     if (dict) {",
          "1785:      ci->version = CFStringGetIntValue(version);",
          "1786:      CFRelease(dict);",
          "1787:     }",
          "1788: }",
          "1789: #endif",
          "1792:     pj_strdup2(pool, &ci->issuer.info, buf);",
          "1793: #if !TARGET_OS_IPHONE",
          "1794:     if (issuer_cn) {",
          "1795:      CFStringGetCString(issuer_cn, buf, bufsize, kCFStringEncodingUTF8);",
          "1796:      pj_strdup2(pool, &ci->issuer.cn, buf);",
          "1797:      CFRelease(issuer_cn);",
          "1798:     }",
          "1799: #endif",
          "1800:     CFRelease(issuer_info);",
          "1803:     if (serial) {",
          "1804:      if (serialsize > sizeof(ci->serial_no))",
          "1805:          serialsize = sizeof(ci->serial_no);",
          "1806:      pj_memcpy(ci->serial_no, serial_no, serialsize);",
          "1807:      CFRelease(serial);",
          "1808:     }",
          "1811:     str = SecCertificateCopySubjectSummary(cert);",
          "1812:     CFStringGetCString(str, buf, bufsize, kCFStringEncodingUTF8);",
          "1813:     pj_strdup2(pool, &ci->subject.cn, buf);",
          "1814:     CFRelease(str);",
          "1815: #if !TARGET_OS_IPHONE",
          "1816: {",
          "1817:     CFArrayRef subject;",
          "1818:     CFMutableStringRef subject_info;",
          "1820:     dict = get_cert_oid(cert, kSecOIDX509V1SubjectName,",
          "1821:        (CFTypeRef *)&subject);",
          "1822:     if (dict) {",
          "1823:       subject_info = CFStringCreateMutable(NULL, 0);",
          "1825:      get_info_and_cn(subject, subject_info, &str);",
          "1827:      CFStringGetCString(subject_info, buf, bufsize, kCFStringEncodingUTF8);",
          "1828:      pj_strdup2(pool, &ci->subject.info, buf);",
          "1830:      CFRelease(dict);",
          "1831:      CFRelease(subject_info);",
          "1832:     }",
          "1833: }",
          "1834: #endif",
          "1837: #if !TARGET_OS_IPHONE",
          "1838: {",
          "1839:     CFNumberRef validity;",
          "1840:     double interval;",
          "1842:     dict = get_cert_oid(cert, kSecOIDX509V1ValidityNotBefore,",
          "1843:        (CFTypeRef *)&validity);",
          "1844:     if (dict) {",
          "1845:         if (CFNumberGetValue(validity, CFNumberGetType(validity),",
          "1846:                &interval))",
          "1847:         {",
          "1849:          ci->validity.start.sec = (unsigned long)interval + 978278400L;",
          "1850:      }",
          "1851:      CFRelease(dict);",
          "1852:     }",
          "1854:     dict = get_cert_oid(cert, kSecOIDX509V1ValidityNotAfter,",
          "1855:        (CFTypeRef *)&validity);",
          "1856:     if (dict) {",
          "1857:      if (CFNumberGetValue(validity, CFNumberGetType(validity),",
          "1858:             &interval))",
          "1859:      {",
          "1860:          ci->validity.end.sec = (unsigned long)interval + 978278400L;",
          "1861:      }",
          "1862:      CFRelease(dict);",
          "1863:     }",
          "1864: }",
          "1865: #endif",
          "1868: #if !TARGET_OS_IPHONE",
          "1869: {",
          "1870:     CFArrayRef altname;",
          "1871:     CFIndex i;",
          "1873:     dict = get_cert_oid(cert, kSecOIDSubjectAltName, (CFTypeRef *)&altname);",
          "1874:     if (!dict || !CFArrayGetCount(altname))",
          "1875:      return;",
          "1877:     ci->subj_alt_name.entry = pj_pool_calloc(pool, CFArrayGetCount(altname),",
          "1878:           sizeof(*ci->subj_alt_name.entry));",
          "1880:     for (i = 0; i < CFArrayGetCount(altname); ++i) {",
          "1881:      CFDictionaryRef item;",
          "1882:      CFStringRef label, value;",
          "1883:  pj_ssl_cert_name_type type = PJ_SSL_CERT_NAME_UNKNOWN;",
          "1885:         item = CFArrayGetValueAtIndex(altname, i);",
          "1886:         if (CFGetTypeID(item) != CFDictionaryGetTypeID())",
          "1887:             continue;",
          "1889:         label = (CFStringRef)CFDictionaryGetValue(item, kSecPropertyKeyLabel);",
          "1890:  if (CFGetTypeID(label) != CFStringGetTypeID())",
          "1891:      continue;",
          "1893:         value = (CFStringRef)CFDictionaryGetValue(item, kSecPropertyKeyValue);",
          "1895:  if (!CFStringCompare(label, CFSTR(\"DNS Name\"),",
          "1896:         kCFCompareCaseInsensitive))",
          "1897:  {",
          "1898:      if (CFGetTypeID(value) != CFStringGetTypeID())",
          "1899:       continue;",
          "1900:      CFStringGetCString(value, buf, bufsize, kCFStringEncodingUTF8);",
          "1901:      type = PJ_SSL_CERT_NAME_DNS;",
          "1902:  } else if (!CFStringCompare(label, CFSTR(\"IP Address\"),",
          "1903:              kCFCompareCaseInsensitive))",
          "1904:  {",
          "1905:      if (CFGetTypeID(value) != CFStringGetTypeID())",
          "1906:       continue;",
          "1907:      CFStringGetCString(value, buf, bufsize, kCFStringEncodingUTF8);",
          "1908:      type = PJ_SSL_CERT_NAME_IP;",
          "1909:  } else if (!CFStringCompare(label, CFSTR(\"Email Address\"),",
          "1910:              kCFCompareCaseInsensitive))",
          "1911:  {",
          "1912:      if (CFGetTypeID(value) != CFStringGetTypeID())",
          "1913:       continue;",
          "1914:      CFStringGetCString(value, buf, bufsize, kCFStringEncodingUTF8);",
          "1915:      type = PJ_SSL_CERT_NAME_RFC822;",
          "1916:  } else if (!CFStringCompare(label, CFSTR(\"URI\"),",
          "1917:              kCFCompareCaseInsensitive))",
          "1918:  {",
          "1919:      CFStringRef uri;",
          "1921:      if (CFGetTypeID(value) != CFURLGetTypeID())",
          "1922:       continue;",
          "1923:      uri = CFURLGetString((CFURLRef)value);",
          "1924:      CFStringGetCString(uri, buf, bufsize, kCFStringEncodingUTF8);",
          "1925:      type = PJ_SSL_CERT_NAME_URI;",
          "1926:  }",
          "1928:  if (type != PJ_SSL_CERT_NAME_UNKNOWN) {",
          "1929:      ci->subj_alt_name.entry[ci->subj_alt_name.cnt].type = type;",
          "1930:      if (type == PJ_SSL_CERT_NAME_IP) {",
          "1931:       char ip_buf[PJ_INET6_ADDRSTRLEN+10];",
          "1932:       int len = CFStringGetLength(value);",
          "1933:   int af = pj_AF_INET();",
          "1935:   if (len == sizeof(pj_in6_addr)) af = pj_AF_INET6();",
          "1936:   pj_inet_ntop2(af, buf, ip_buf, sizeof(ip_buf));",
          "1937:   pj_strdup2(pool,",
          "1938:       &ci->subj_alt_name.entry[ci->subj_alt_name.cnt].name,",
          "1939:       ip_buf);",
          "1940:      } else {",
          "1941:   pj_strdup2(pool,",
          "1942:        &ci->subj_alt_name.entry[ci->subj_alt_name.cnt].name,",
          "1943:       buf);",
          "1944:      }",
          "1945:      ci->subj_alt_name.cnt++;",
          "1946:  }",
          "1947:     }",
          "1949:     CFRelease(dict);",
          "1950: }",
          "1951: #endif",
          "1952: }",
          "1957: static void ssl_update_certs_info(pj_ssl_sock_t *ssock)",
          "1958: {",
          "1959:     applessl_sock_t *assock = (applessl_sock_t *)ssock;",
          "1960:     SecTrustRef trust = assock->trust;",
          "1961:     CFIndex count;",
          "1962:     SecCertificateRef cert;",
          "1964:     pj_assert(ssock->ssl_state == SSL_STATE_ESTABLISHED);",
          "1967:     if (assock->identity) {",
          "1968:         CFArrayRef cert_arr;",
          "1970:      cert_arr = sec_identity_copy_certificates_ref(assock->identity);",
          "1971:      if (cert_arr) {",
          "1972:          count = CFArrayGetCount(cert_arr);",
          "1973:          if (count > 0) {",
          "1974:   CFTypeRef elmt;",
          "1976:           elmt = (CFTypeRef) CFArrayGetValueAtIndex(cert_arr, 0);",
          "1977:           if (CFGetTypeID(elmt) == SecCertificateGetTypeID()) {",
          "1978:               cert = (SecCertificateRef)elmt;",
          "1979:                 get_cert_info(ssock->pool, &ssock->local_cert_info, cert);",
          "1980:             }",
          "1981:          }",
          "1982:          CFRelease(cert_arr);",
          "1983:      }",
          "1984:     }",
          "1987:     if (trust) {",
          "1988:      count = SecTrustGetCertificateCount(trust);",
          "1989:      if (count > 0) {",
          "1990:      cert = SecTrustGetCertificateAtIndex(trust, 0);",
          "1991:            get_cert_info(ssock->pool, &ssock->remote_cert_info, cert);",
          "1992:      }",
          "1993:     }",
          "1994: }",
          "1996: static void ssl_set_state(pj_ssl_sock_t *ssock, pj_bool_t is_server)",
          "1997: {",
          "1998:     PJ_UNUSED_ARG(ssock);",
          "1999:     PJ_UNUSED_ARG(is_server);",
          "2000: }",
          "2002: static void ssl_set_peer_name(pj_ssl_sock_t *ssock)",
          "2003: {",
          "2007:     PJ_UNUSED_ARG(ssock);",
          "2008: }",
          "2010: static pj_status_t ssl_do_handshake(pj_ssl_sock_t *ssock)",
          "2011: {",
          "2016:     return PJ_EPENDING;",
          "2017: }",
          "2019: static pj_status_t ssl_read(pj_ssl_sock_t *ssock, void *data, int *size)",
          "2020: {",
          "2021:     pj_size_t circ_buf_size, read_size;",
          "2023:     pj_lock_acquire(ssock->circ_buf_input_mutex);",
          "2025:     if (circ_empty(&ssock->circ_buf_input)) {",
          "2026:         pj_lock_release(ssock->circ_buf_input_mutex);",
          "2028:  return PJ_SUCCESS;",
          "2029:     }",
          "2031:     circ_buf_size = circ_size(&ssock->circ_buf_input);",
          "2032:     read_size = PJ_MIN(circ_buf_size, *size);",
          "2034:     circ_read(&ssock->circ_buf_input, data, read_size);",
          "2036:     pj_lock_release(ssock->circ_buf_input_mutex);",
          "2040:     return PJ_SUCCESS;",
          "2041: }",
          "2047: static pj_status_t ssl_write(pj_ssl_sock_t *ssock, const void *data,",
          "2048:         pj_ssize_t size, int *nwritten)",
          "2049: {",
          "2050:     pj_status_t status;",
          "2052:     status = circ_write(&ssock->circ_buf_output, data, size);",
          "2055:     return status;",
          "2056: }",
          "2058: static pj_status_t ssl_renegotiate(pj_ssl_sock_t *ssock)",
          "2059: {",
          "2060:     PJ_UNUSED_ARG(ssock);",
          "2067:     return PJ_ENOTSUP;",
          "2068: }",
          "",
          "---------------"
        ],
        "pjlib/src/pj/ssl_sock_darwin.c||pjlib/src/pj/ssl_sock_darwin.c": [
          "File: pjlib/src/pj/ssl_sock_darwin.c -> pjlib/src/pj/ssl_sock_darwin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "409:         ~PJ_SSL_SOCK_PROTO_SSL2;",
          "410:     }",
          "426:  max_proto = kTLSProtocol11;",
          "427:     }",
          "431:     }",
          "433:         err = SSLSetProtocolVersionMin(ssl_ctx, min_proto);",
          "434:         if (err != noErr) pj_status_from_err(dssock, \"SetVersionMin\", err);",
          "435:     }",
          "438:         err = SSLSetProtocolVersionMax(ssl_ctx, max_proto);",
          "439:         if (err != noErr) pj_status_from_err(dssock, \"SetVersionMax\", err);",
          "440:     }",
          "",
          "[Removed Lines]",
          "412:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL2) {",
          "413:      if (!min_proto) min_proto = kSSLProtocol2;",
          "414:  max_proto = kSSLProtocol2;",
          "415:     }",
          "416:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL3) {",
          "417:      if (!min_proto) min_proto = kSSLProtocol3;",
          "418:  max_proto = kSSLProtocol3;",
          "419:     }",
          "420:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1) {",
          "421:      if (!min_proto) min_proto = kTLSProtocol1;",
          "422:  max_proto = kTLSProtocol1;",
          "423:     }",
          "424:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_1) {",
          "425:      if (!min_proto) min_proto = kTLSProtocol11;",
          "428:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_2) {",
          "429:      if (!min_proto) min_proto = kTLSProtocol12;",
          "430:  max_proto = kTLSProtocol12;",
          "432:     if (min_proto != kSSLProtocolUnknown) {",
          "437:     if (max_proto != kSSLProtocolUnknown) {",
          "",
          "[Added Lines]",
          "411:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_3) {",
          "412:  max_proto = kTLSProtocol13;",
          "413:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_2) {",
          "414:  max_proto = kTLSProtocol12;",
          "415:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_1) {",
          "417:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1) {",
          "418:  max_proto = kTLSProtocol1;",
          "419:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL3) {",
          "420:  max_proto = kSSLProtocol3;",
          "421:     } else {",
          "422:  PJ_LOG(3, (THIS_FILE, \"Unsupported TLS/SSL protocol\"));",
          "423:  return PJ_EINVAL;",
          "426:     if (ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL3) {",
          "427:  min_proto = kSSLProtocol3;",
          "428:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1) {",
          "429:  min_proto = kTLSProtocol1;",
          "430:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_1) {",
          "431:  min_proto = kTLSProtocol11;",
          "432:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_2) {",
          "433:  min_proto = kTLSProtocol12;",
          "434:     } else if (ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_3) {",
          "435:  min_proto = kTLSProtocol13;",
          "441:     if (min_proto != kSSLProtocolUnknown && min_proto <= kTLSProtocol1) {",
          "446:     if (max_proto != kSSLProtocolUnknown && max_proto <= kTLSProtocol1) {",
          "",
          "---------------"
        ],
        "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c": [
          "File: pjlib/src/pj/ssl_sock_imp_common.c -> pjlib/src/pj/ssl_sock_imp_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: enum { MAX_BIND_RETRY = 100 };",
          "36: #ifdef SSL_SOCK_IMP_USE_CIRC_BUF",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #ifndef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "36: static pj_bool_t asock_on_data_read (pj_activesock_t *asock,",
          "37:          void *data,",
          "38:          pj_size_t size,",
          "39:          pj_status_t status,",
          "40:          pj_size_t *remainder);",
          "42: static pj_bool_t asock_on_data_sent (pj_activesock_t *asock,",
          "43:          pj_ioqueue_op_key_t *send_key,",
          "44:          pj_ssize_t sent);",
          "45: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "177: static void ssl_close_sockets(pj_ssl_sock_t *ssock)",
          "178: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: #ifndef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "203:     if (sock != PJ_INVALID_SOCKET)",
          "204:         pj_sock_close(sock);",
          "205: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "494:     pj_lock_release(ssock->write_mutex);",
          "497:     if (ssock->param.sock_type == pj_SOCK_STREAM()) {",
          "498:  status = pj_activesock_send(ssock->asock, &wdata->key,",
          "499:         wdata->data.content, &len,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "509: #ifdef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "510:     status = network_send(ssock, &wdata->key, wdata->data.content, &len,",
          "511:      flags);",
          "512: #else",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "505:           (pj_sockaddr_t*)&ssock->rem_addr,",
          "506:           ssock->addr_len);",
          "507:     }",
          "509:     if (status != PJ_EPENDING) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "524: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "644:      ((pj_int8_t*)(asock_rbuf) + \\",
          "645:      ssock->param.read_buffer_size)",
          "648:          void *data,",
          "649:          pj_size_t size,",
          "650:          pj_status_t status,",
          "651:          pj_size_t *remainder)",
          "652: {",
          "657:     if (data && size > 0) {",
          "658:      pj_status_t status_;",
          "",
          "[Removed Lines]",
          "647: static pj_bool_t asock_on_data_read (pj_activesock_t *asock,",
          "653:     pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "654:       pj_activesock_get_user_data(asock);",
          "",
          "[Added Lines]",
          "664: static pj_bool_t ssock_on_data_read (pj_ssl_sock_t *ssock,",
          "670:     if (status != PJ_SUCCESS)",
          "671:      goto on_error;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "789:     return PJ_FALSE;",
          "790: }",
          "793:          pj_ioqueue_op_key_t *send_key,",
          "794:          pj_ssize_t sent)",
          "795: {",
          "798:     write_data_t *wdata = (write_data_t*)send_key->user_data;",
          "799:     pj_ioqueue_op_key_t *app_key = wdata->app_key;",
          "800:     pj_ssize_t sent_len;",
          "",
          "[Removed Lines]",
          "792: static pj_bool_t asock_on_data_sent (pj_activesock_t *asock,",
          "796:     pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "797:       pj_activesock_get_user_data(asock);",
          "",
          "[Added Lines]",
          "808: static pj_bool_t ssock_on_data_sent (pj_ssl_sock_t *ssock,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "845:     return PJ_TRUE;",
          "846: }",
          "849:         pj_sock_t newsock,",
          "850:         const pj_sockaddr_t *src_addr,",
          "852: {",
          "855:     pj_ssl_sock_t *ssock;",
          "856:     pj_activesock_cb asock_cb;",
          "857:     pj_activesock_cfg asock_cfg;",
          "858:     unsigned i;",
          "859:     pj_status_t status;",
          "862:     status = pj_ssl_sock_create(ssock_parent->pool,",
          "863:     &ssock_parent->newsock_param, &ssock);",
          "",
          "[Removed Lines]",
          "848: static pj_bool_t asock_on_accept_complete (pj_activesock_t *asock,",
          "851:         int src_addr_len)",
          "853:     pj_ssl_sock_t *ssock_parent = (pj_ssl_sock_t*)",
          "854:       pj_activesock_get_user_data(asock);",
          "",
          "[Added Lines]",
          "862: static pj_status_t get_localaddr(pj_ssl_sock_t *ssock,",
          "863:      pj_sockaddr_t *addr,",
          "864:      int *namelen)",
          "865: {",
          "866: #ifdef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "867:     return network_get_localaddr(ssock, &ssock->local_addr,",
          "868:      &ssock->addr_len);",
          "869: #else",
          "870:     return pj_sock_getsockname(ssock->sock, &ssock->local_addr,",
          "871:           &ssock->addr_len);",
          "872: #endif",
          "873: }",
          "876: static pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,",
          "878:         void *newconn,",
          "880:         int src_addr_len,",
          "881:         pj_status_t accept_status)",
          "884: #ifndef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "886: #endif",
          "891:     if (accept_status != PJ_SUCCESS) {",
          "892:  if (ssock_parent->param.cb.on_accept_complete2) {",
          "893:      (*ssock_parent->param.cb.on_accept_complete2)(ssock_parent, NULL,",
          "894:              src_addr,",
          "895:              src_addr_len,",
          "896:              accept_status);",
          "897:  }",
          "898:  return PJ_TRUE;",
          "899:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "875:      goto on_return;",
          "876:     }",
          "894:     ssock->addr_len = src_addr_len;",
          "905:     pj_sockaddr_cp(&ssock->rem_addr, src_addr);",
          "",
          "[Removed Lines]",
          "879:     status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,",
          "880:     &ssock->param.qos_params, 1,",
          "881:     ssock->pool->obj_name, NULL);",
          "882:     if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)",
          "883:  goto on_return;",
          "886:     if (ssock->param.sockopt_params.cnt) {",
          "887:  status = pj_sock_setsockopt_params(ssock->sock,",
          "888:         &ssock->param.sockopt_params);",
          "889:  if (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)",
          "890:      goto on_return;",
          "891:     }",
          "895:     status = pj_sock_getsockname(ssock->sock, &ssock->local_addr,",
          "896:      &ssock->addr_len);",
          "897:     if (status != PJ_SUCCESS) {",
          "901:  pj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);",
          "902:     }",
          "",
          "[Added Lines]",
          "920:     pj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "925:             return PJ_ENOMEM;",
          "926:     }",
          "",
          "[Removed Lines]",
          "929:     pj_activesock_cfg_default(&asock_cfg);",
          "930:     asock_cfg.async_cnt = ssock->param.async_cnt;",
          "931:     asock_cfg.concurrency = ssock->param.concurrency;",
          "932:     asock_cfg.whole_data = PJ_TRUE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "947:     ssl_on_destroy);",
          "948:     }",
          "950:     pj_bzero(&asock_cb, sizeof(asock_cb));",
          "951:     asock_cb.on_data_read = asock_on_data_read;",
          "952:     asock_cb.on_data_sent = asock_on_data_sent;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "962: #ifdef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "963:     status = network_setup_connection(ssock, newconn);",
          "964:     if (status != PJ_SUCCESS)",
          "965:  goto on_return;",
          "967: #else",
          "969:     status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,",
          "970:     &ssock->param.qos_params, 1,",
          "971:     ssock->pool->obj_name, NULL);",
          "972:     if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)",
          "973:  goto on_return;",
          "976:     if (ssock->param.sockopt_params.cnt) {",
          "977:  status = pj_sock_setsockopt_params(ssock->sock,",
          "978:         &ssock->param.sockopt_params);",
          "979:  if (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)",
          "980:      goto on_return;",
          "981:     }",
          "984:     pj_activesock_cfg_default(&asock_cfg);",
          "985:     asock_cfg.async_cnt = ssock->param.async_cnt;",
          "986:     asock_cfg.concurrency = ssock->param.concurrency;",
          "987:     asock_cfg.whole_data = PJ_TRUE;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "970:            PJ_IOQUEUE_ALWAYS_ASYNC);",
          "971:     if (status != PJ_SUCCESS)",
          "972:  goto on_return;",
          "975:     pj_assert(ssock->send_buf.max_len == 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1012: #endif",
          "1015:     status = get_localaddr(ssock, &ssock->local_addr, &ssock->addr_len);",
          "1016:     if (status != PJ_SUCCESS) {",
          "1020:  pj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);",
          "1021:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1009:  on_handshake_complete(ssock, status);",
          "1010:     }",
          "1015:     return PJ_TRUE;",
          "1016: }",
          "1041:          pj_status_t status)",
          "1042: {",
          "1045:     unsigned i;",
          "1047:     if (status != PJ_SUCCESS)",
          "",
          "[Removed Lines]",
          "1018: static pj_bool_t asock_on_accept_complete2(pj_activesock_t *asock,",
          "1019:         pj_sock_t newsock,",
          "1020:         const pj_sockaddr_t *src_addr,",
          "1021:         int src_addr_len,",
          "1022:         pj_status_t status)",
          "1023: {",
          "1024:     pj_bool_t ret = PJ_TRUE;",
          "1025:     if (status != PJ_SUCCESS) {",
          "1026:  pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "1027:    pj_activesock_get_user_data(asock);",
          "1029:  if (ssock->param.cb.on_accept_complete2) {",
          "1030:      (*ssock->param.cb.on_accept_complete2) (ssock, NULL,",
          "1031:           src_addr, src_addr_len,",
          "1032:           status);",
          "1033:  }",
          "1034:     } else {",
          "1035:  ret = asock_on_accept_complete(asock, newsock, src_addr, src_addr_len);",
          "1036:     }",
          "1037:     return ret;",
          "1038: }",
          "1040: static pj_bool_t asock_on_connect_complete (pj_activesock_t *asock,",
          "1043:     pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "1044:       pj_activesock_get_user_data(asock);",
          "",
          "[Added Lines]",
          "1065: static pj_bool_t ssock_on_connect_complete (pj_ssl_sock_t *ssock,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1051:     ssock->addr_len = sizeof(pj_sockaddr);",
          "1054:     if (status != PJ_SUCCESS)",
          "1055:  goto on_return;",
          "",
          "[Removed Lines]",
          "1052:     status = pj_sock_getsockname(ssock->sock, &ssock->local_addr,",
          "1053:      &ssock->addr_len);",
          "",
          "[Added Lines]",
          "1075:     status = get_localaddr(ssock, &ssock->local_addr, &ssock->addr_len);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1076:     }",
          "1079:     status = pj_activesock_start_read2(ssock->asock, ssock->pool,",
          "1080:            (unsigned)ssock->param.read_buffer_size,",
          "1081:            ssock->asock_rbuf,",
          "1082:            PJ_IOQUEUE_ALWAYS_ASYNC);",
          "1083:     if (status != PJ_SUCCESS)",
          "1084:  goto on_return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1101: #ifdef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "1102:     status = network_start_read(ssock, ssock->param.async_cnt,",
          "1103:         (unsigned)ssock->param.read_buffer_size,",
          "1104:     ssock->asock_rbuf, 0);",
          "1105: #else",
          "1110: #endif",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1112:     return on_handshake_complete(ssock, status);",
          "1113: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1143: #ifndef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "1144: static pj_bool_t asock_on_data_read (pj_activesock_t *asock,",
          "1145:          void *data,",
          "1146:          pj_size_t size,",
          "1147:          pj_status_t status,",
          "1148:          pj_size_t *remainder)",
          "1149: {",
          "1150:     pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "1151:       pj_activesock_get_user_data(asock);",
          "1153:     return ssock_on_data_read(ssock, data, size, status, remainder);",
          "1154: }",
          "1156: static pj_bool_t asock_on_data_sent (pj_activesock_t *asock,",
          "1157:          pj_ioqueue_op_key_t *send_key,",
          "1158:          pj_ssize_t sent)",
          "1159: {",
          "1160:     pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "1161:       pj_activesock_get_user_data(asock);",
          "1163:     return ssock_on_data_sent(ssock, send_key, sent);",
          "1164: }",
          "1166: static pj_bool_t asock_on_accept_complete2(pj_activesock_t *asock,",
          "1167:         pj_sock_t newsock,",
          "1168:         const pj_sockaddr_t *src_addr,",
          "1169:         int src_addr_len,",
          "1170:         pj_status_t status)",
          "1171: {",
          "1172:     pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "1173:       pj_activesock_get_user_data(asock);",
          "1175:     return ssock_on_accept_complete(ssock, newsock, NULL,",
          "1176:             src_addr, src_addr_len, status);",
          "1177: }",
          "1179: static pj_bool_t asock_on_connect_complete (pj_activesock_t *asock,",
          "1180:          pj_status_t status)",
          "1181: {",
          "1182:     pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)",
          "1183:       pj_activesock_get_user_data(asock);",
          "1185:     return ssock_on_connect_complete(ssock, status);",
          "1186: }",
          "1187: #endif",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1279:     ssock = ssl_alloc(pool);",
          "1280:     ssock->pool = pool;",
          "1281:     ssock->info_pool = info_pool;",
          "1282:     ssock->sock = PJ_INVALID_SOCKET;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1353:     if (!ssock)",
          "1354:      return PJ_ENOMEM;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1503:     for (i=0; i<ssock->param.async_cnt; ++i) {",
          "1504:  if (ssock->asock_rbuf[i]) {",
          "1505:      pj_size_t remainder = 0;",
          "1507:           PJ_SUCCESS, &remainder);",
          "1508:  }",
          "1509:     }",
          "",
          "[Removed Lines]",
          "1506:      asock_on_data_read(ssock->asock, ssock->asock_rbuf[i], 0,",
          "",
          "[Added Lines]",
          "1581:      ssock_on_data_read(ssock, ssock->asock_rbuf[i], 0,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1765:      int addr_len,",
          "1766:      const pj_ssl_sock_param *newsock_param)",
          "1767: {",
          "1768:     pj_activesock_cb asock_cb;",
          "1769:     pj_activesock_cfg asock_cfg;",
          "1772:     PJ_ASSERT_RETURN(ssock && pool && localaddr && addr_len, PJ_EINVAL);",
          "",
          "[Removed Lines]",
          "1770:     pj_status_t status;",
          "",
          "[Added Lines]",
          "1843:     pj_status_t status;",
          "1844: #ifndef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "1847: #endif",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1779:         return PJ_EINVAL;",
          "1780:     }",
          "1783:     status = pj_sock_socket(ssock->param.sock_af, ssock->param.sock_type, 0,",
          "1784:        &ssock->sock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1859:     ssock->is_server = PJ_TRUE;",
          "1861: #ifdef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "1862:     status = network_start_accept(ssock, pool, localaddr, addr_len,",
          "1863:           newsock_param);",
          "1864:     if (status != PJ_SUCCESS)",
          "1865:  goto on_error;",
          "1866: #else",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1859:      &ssock->addr_len);",
          "1860:     if (status != PJ_SUCCESS)",
          "1861:  pj_sockaddr_cp(&ssock->local_addr, localaddr);",
          "1865:     return PJ_SUCCESS;",
          "",
          "[Removed Lines]",
          "1863:     ssock->is_server = PJ_TRUE;",
          "",
          "[Added Lines]",
          "1947: #endif",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1893:           pj_ssl_sock_t *ssock,",
          "1894:           pj_ssl_start_connect_param *connect_param)",
          "1895: {",
          "1896:     pj_activesock_cb asock_cb;",
          "1897:     pj_activesock_cfg asock_cfg;",
          "1900:     pj_pool_t *pool = connect_param->pool;",
          "1901:     const pj_sockaddr_t *localaddr = connect_param->localaddr;",
          "",
          "[Removed Lines]",
          "1898:     pj_status_t status;",
          "",
          "[Added Lines]",
          "1980:     pj_status_t status;",
          "1981: #ifdef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "1982:     status = network_start_connect(ssock, connect_param);",
          "1983:     if (status != PJ_EPENDING)",
          "1984:  goto on_error;",
          "1985: #else",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1972:     pj_sockaddr_cp(&ssock->rem_addr, remaddr);",
          "1990:     status = pj_activesock_start_connect(ssock->asock, pool, remaddr,",
          "1991:       addr_len);",
          "",
          "[Removed Lines]",
          "1975:     if (ssock->param.timer_heap &&",
          "1976:         (ssock->param.timeout.sec != 0 || ssock->param.timeout.msec != 0))",
          "1977:     {",
          "1978:  pj_assert(ssock->timer.id == TIMER_NONE);",
          "1979:  status = pj_timer_heap_schedule_w_grp_lock(ssock->param.timer_heap,",
          "1980:          &ssock->timer,",
          "1981:          &ssock->param.timeout,",
          "1982:          TIMER_HANDSHAKE_TIMEOUT,",
          "1983:          ssock->param.grp_lock);",
          "1984:  if (status != PJ_SUCCESS) {",
          "1985:      ssock->timer.id = TIMER_NONE;",
          "1986:      status = PJ_SUCCESS;",
          "1987:  }",
          "1988:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2011:     ssock->is_server = PJ_FALSE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2083: #endif",
          "2086:     if (ssock->param.timer_heap &&",
          "2087:         (ssock->param.timeout.sec != 0 || ssock->param.timeout.msec != 0))",
          "2088:     {",
          "2089:  pj_assert(ssock->timer.id == TIMER_NONE);",
          "2090:  status = pj_timer_heap_schedule_w_grp_lock(ssock->param.timer_heap,",
          "2091:          &ssock->timer,",
          "2092:          &ssock->param.timeout,",
          "2093:          TIMER_HANDSHAKE_TIMEOUT,",
          "2094:          ssock->param.grp_lock);",
          "2095:  if (status != PJ_SUCCESS) {",
          "2096:      ssock->timer.id = TIMER_NONE;",
          "2097:      status = PJ_SUCCESS;",
          "2098:  }",
          "2099:     }",
          "",
          "---------------"
        ],
        "pjlib/src/pj/ssl_sock_imp_common.h||pjlib/src/pj/ssl_sock_imp_common.h": [
          "File: pjlib/src/pj/ssl_sock_imp_common.h -> pjlib/src/pj/ssl_sock_imp_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "263: static pj_status_t ssl_write(pj_ssl_sock_t *ssock, const void *data,",
          "264:         pj_ssize_t size, int *nwritten);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265: #ifdef SSL_SOCK_IMP_USE_OWN_NETWORK",
          "267: static void ssl_close_sockets(pj_ssl_sock_t *ssock);",
          "269: static pj_status_t network_send(pj_ssl_sock_t *ssock,",
          "270:     pj_ioqueue_op_key_t *send_key,",
          "271:     const void *data,",
          "272:     pj_ssize_t *size,",
          "273:     unsigned flags);",
          "274: static pj_status_t network_start_read(pj_ssl_sock_t *ssock,",
          "275:           unsigned async_count,",
          "276:           unsigned buff_size,",
          "277:           void *readbuf[],",
          "278:           pj_uint32_t flags);",
          "279: static pj_status_t network_start_accept(pj_ssl_sock_t *ssock,",
          "280:       pj_pool_t *pool,",
          "281:        const pj_sockaddr_t *localaddr,",
          "282:        int addr_len,",
          "283:        const pj_ssl_sock_param *newsock_param);",
          "284: static pj_status_t network_start_connect(pj_ssl_sock_t *ssock,",
          "285:          pj_ssl_start_connect_param *connect_param);",
          "286: static pj_status_t network_setup_connection(pj_ssl_sock_t *ssock,",
          "287:          void *connection);",
          "288: static pj_status_t network_get_localaddr(pj_ssl_sock_t *ssock,",
          "289:       pj_sockaddr_t *addr,",
          "290:       int *namelen);",
          "292: #endif",
          "",
          "---------------"
        ],
        "pjlib/src/pjlib-test/ssl_sock.c||pjlib/src/pjlib-test/ssl_sock.c": [
          "File: pjlib/src/pjlib-test/ssl_sock.c -> pjlib/src/pjlib-test/ssl_sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #define CERT_DIR      \"../build/\"",
          "27: #   define CERT_CA_FILE      CERT_DIR \"cacert.der\"",
          "28: #else",
          "",
          "[Removed Lines]",
          "25: #if (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_DARWIN)",
          "",
          "[Added Lines]",
          "25: #if (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_DARWIN) || \\",
          "26:     (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_APPLE)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "174:      goto on_return;",
          "175:  }",
          "178:      st->sent += size;",
          "180:      break;",
          "181:     }",
          "183: on_return:",
          "",
          "[Removed Lines]",
          "177:  if (status == PJ_SUCCESS)",
          "179:  else",
          "",
          "[Added Lines]",
          "178:  if (status == PJ_SUCCESS) {",
          "180:  } else {",
          "181:      if (status == PJ_EPENDING)",
          "182:       status = PJ_SUCCESS;",
          "184:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "196: static pj_bool_t ssl_on_accept_complete(pj_ssl_sock_t *ssock,",
          "197:      pj_ssl_sock_t *newsock,",
          "198:      const pj_sockaddr_t *src_addr,",
          "200: {",
          "201:     struct test_state *parent_st = (struct test_state*)",
          "202:        pj_ssl_sock_get_user_data(ssock);",
          "",
          "[Removed Lines]",
          "199:      int src_addr_len)",
          "",
          "[Added Lines]",
          "203:      int src_addr_len,",
          "204:      pj_status_t accept_status)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "207:     pj_status_t status;",
          "209:     PJ_UNUSED_ARG(src_addr_len);",
          "212:     st = (struct test_state*)pj_pool_zalloc(parent_st->pool, sizeof(struct test_state));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216:     if (accept_status != PJ_SUCCESS) {",
          "217:      if (newsock) {",
          "218:          st = (struct test_state*) pj_ssl_sock_get_user_data(newsock);",
          "219:          st->err = accept_status;",
          "220:      }",
          "221:      return PJ_FALSE;",
          "222:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "245:      goto on_return;",
          "246:  }",
          "249:      st->sent += size;",
          "251:      break;",
          "252:     }",
          "254: on_return:",
          "",
          "[Removed Lines]",
          "248:  if (status == PJ_SUCCESS)",
          "250:  else",
          "",
          "[Added Lines]",
          "261:  if (status == PJ_SUCCESS) {",
          "263:  } else {",
          "264:      if (status == PJ_EPENDING)",
          "265:       status = PJ_SUCCESS;",
          "267:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "304:   goto on_return;",
          "305:      }",
          "308:   st->sent += size_;",
          "309:  }",
          "",
          "[Removed Lines]",
          "307:      if (status == PJ_SUCCESS)",
          "",
          "[Added Lines]",
          "323:      if (status == PJ_SUCCESS) {",
          "325:      } else if (status == PJ_EPENDING) {",
          "326:       status = PJ_SUCCESS;",
          "327:      }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "526: {",
          "527:     pj_pool_t *pool = NULL;",
          "528:     pj_ioqueue_t *ioqueue = NULL;",
          "529:     pj_ssl_sock_t *ssock_serv = NULL;",
          "530:     pj_ssl_sock_t *ssock_cli = NULL;",
          "531:     pj_ssl_sock_param param;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "548:     pj_timer_heap_t *timer = NULL;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "543:  goto on_return;",
          "544:     }",
          "546:     pj_ssl_sock_param_default(&param);",
          "548:     param.cb.on_connect_complete = &ssl_on_connect_complete;",
          "549:     param.cb.on_data_read = &ssl_on_data_read;",
          "550:     param.cb.on_data_sent = &ssl_on_data_sent;",
          "551:     param.ioqueue = ioqueue;",
          "552:     param.ciphers = ciphers;",
          "",
          "[Removed Lines]",
          "547:     param.cb.on_accept_complete = &ssl_on_accept_complete;",
          "",
          "[Added Lines]",
          "566:     status = pj_timer_heap_create(pool, 4, &timer);",
          "567:     if (status != PJ_SUCCESS) {",
          "568:  goto on_return;",
          "569:     }",
          "572:     param.cb.on_accept_complete2 = &ssl_on_accept_complete;",
          "577:     param.timer_heap = timer;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "733:     PJ_LOG(3, (\"\", \".....Sent/recv: %d/%d bytes\", state_cli.sent, state_cli.recv));",
          "735: on_return:",
          "736:     if (ssock_serv)",
          "737:  pj_ssl_sock_close(ssock_serv);",
          "738:     if (ssock_cli && !state_cli.err && !state_cli.done)",
          "739:  pj_ssl_sock_close(ssock_cli);",
          "740:     if (ioqueue)",
          "741:  pj_ioqueue_destroy(ioqueue);",
          "742:     if (pool)",
          "743:  pj_pool_release(pool);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "762: #if (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_DARWIN) || \\",
          "763:     (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_APPLE)",
          "764:     if (status != PJ_SUCCESS) {",
          "765:  PJ_LOG(3, (\"\", \"Apple SSL requires the private key to be \"",
          "766:          \"inside the Keychain. So double click on \"",
          "767:          \"the file pjlib/build/privkey.p12 to \"",
          "768:          \"place it in the Keychain. \"",
          "769:          \"The password is \\\"pjsip\\\".\"));",
          "770:     }",
          "771: #endif",
          "779:     if (timer)",
          "780:  pj_timer_heap_destroy(timer);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "892:  pj_str_t privkey_file = pj_str(CERT_PRIVKEY_FILE);",
          "893:  pj_str_t privkey_pass = pj_str(CERT_PRIVKEY_PASS);",
          "903: #if (defined(TEST_LOAD_FROM_FILES) && TEST_LOAD_FROM_FILES==1)",
          "904:  status = pj_ssl_cert_load_from_files(pool, &ca_file, &cert_file,",
          "905:           &privkey_file, &privkey_pass,",
          "",
          "[Removed Lines]",
          "895: #if (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_DARWIN)",
          "896:  PJ_LOG(3, (\"\", \"Darwin SSL requires the private key to be \"",
          "897:          \"inside the Keychain. So double click on \"",
          "898:          \"the file pjlib/build/privkey.p12 to \"",
          "899:          \"place it in the Keychain. \"",
          "900:          \"The password is \\\"pjsip\\\".\"));",
          "901: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "932:     }",
          "934:     pj_ssl_sock_param_default(&param);",
          "936:     param.cb.on_data_read = &ssl_on_data_read;",
          "937:     param.cb.on_data_sent = &ssl_on_data_sent;",
          "938:     param.ioqueue = ioqueue;",
          "",
          "[Removed Lines]",
          "935:     param.cb.on_accept_complete = &ssl_on_accept_complete;",
          "",
          "[Added Lines]",
          "966:     param.cb.on_accept_complete2 = &ssl_on_accept_complete;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1263:     }",
          "1265:     pj_ssl_sock_param_default(&param);",
          "1267:     param.cb.on_connect_complete = &ssl_on_connect_complete;",
          "1268:     param.cb.on_data_read = &ssl_on_data_read;",
          "1269:     param.cb.on_data_sent = &ssl_on_data_sent;",
          "",
          "[Removed Lines]",
          "1266:     param.cb.on_accept_complete = &ssl_on_accept_complete;",
          "",
          "[Added Lines]",
          "1297:     param.cb.on_accept_complete2 = &ssl_on_accept_complete;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1531:     if (ret == 0)",
          "1532:  return PJ_EBUG;",
          "1534:     PJ_LOG(3,(\"\", \"..echo test w/ incompatible proto: server TLSv1.2 vs client TLSv1.3\"));",
          "1535:     ret = echo_test(PJ_SSL_SOCK_PROTO_TLS1_2, PJ_SSL_SOCK_PROTO_TLS1_3,",
          "1536:       -1, -1,",
          "1537:       PJ_FALSE, PJ_FALSE);",
          "1538:     if (ret == 0)",
          "1539:  return PJ_EBUG;",
          "1541:     PJ_LOG(3,(\"\", \"..echo test w/ incompatible ciphers\"));",
          "1542:     ret = echo_test(PJ_SSL_SOCK_PROTO_DEFAULT, PJ_SSL_SOCK_PROTO_DEFAULT,",
          "1543:       PJ_TLS_RSA_WITH_DES_CBC_SHA, PJ_TLS_RSA_WITH_AES_256_CBC_SHA,",
          "1544:       PJ_FALSE, PJ_FALSE);",
          "1545:     if (ret == 0)",
          "1546:  return PJ_EBUG;",
          "1548:     PJ_LOG(3,(\"\", \"..echo test w/ client cert required but not provided\"));",
          "1549:     ret = echo_test(PJ_SSL_SOCK_PROTO_DEFAULT, PJ_SSL_SOCK_PROTO_DEFAULT,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1566: #if (PJ_SSL_SOCK_IMP != PJ_SSL_SOCK_IMP_DARWIN)",
          "1573: #endif",
          "1579: #if (PJ_SSL_SOCK_IMP != PJ_SSL_SOCK_IMP_APPLE)",
          "1586: #endif",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1569:     PJ_LOG(3,(\"\", \"..client non-SSL (handshake timeout 5 secs)\"));",
          "1570:     ret = client_non_ssl(5000);",
          "1573:  return ret;",
          "1575: #endif",
          "",
          "[Removed Lines]",
          "1572:     if (ret != 0)",
          "",
          "[Added Lines]",
          "1611:     if (ret != PJ_ETIMEDOUT)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "26a4d41b834f0f1037d170f841af70c35f86ec10",
      "candidate_info": {
        "commit_hash": "26a4d41b834f0f1037d170f841af70c35f86ec10",
        "repo": "pjsip/pjproject",
        "commit_url": "https://github.com/pjsip/pjproject/commit/26a4d41b834f0f1037d170f841af70c35f86ec10",
        "files": [
          "pjlib/src/pj/ssl_sock_imp_common.c"
        ],
        "message": "Handle multiple handshake fail on TLS connection",
        "before_after_code_files": [
          "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c"
          ],
          "candidate": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c"
          ]
        }
      },
      "candidate_diff": {
        "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c": [
          "File: pjlib/src/pj/ssl_sock_imp_common.c -> pjlib/src/pj/ssl_sock_imp_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "263:      char buf[PJ_INET6_ADDRSTRLEN+10];",
          "265:      PJ_PERROR(3,(ssock->pool->obj_name, status,",
          "266:     \"Handshake failed in accepting %s\",",
          "267:     pj_sockaddr_print(&ssock->rem_addr, buf,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265:      if (!ssock->parent) {",
          "266:   return PJ_FALSE;",
          "267:      }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "275:      }",
          "279:   pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);",
          "280:   ssock->parent = NULL;",
          "281:      }",
          "",
          "[Removed Lines]",
          "278:      if (ssock->parent->param.grp_lock) {",
          "",
          "[Added Lines]",
          "282:      if (ssock->parent && ssock->parent->param.grp_lock) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "343:      pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);",
          "344:      ssock->parent = NULL;",
          "345:  }",
          "",
          "[Removed Lines]",
          "342:  if (ssock->parent->param.grp_lock) {",
          "",
          "[Added Lines]",
          "346:  if (ssock->parent && ssock->parent->param.grp_lock) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b8e440327a20a291abf953112469385b8b498682",
      "candidate_info": {
        "commit_hash": "b8e440327a20a291abf953112469385b8b498682",
        "repo": "pjsip/pjproject",
        "commit_url": "https://github.com/pjsip/pjproject/commit/b8e440327a20a291abf953112469385b8b498682",
        "files": [
          "pjlib/src/pj/ssl_sock_imp_common.c",
          "pjlib/src/pj/ssl_sock_ossl.c",
          "pjsip/src/pjsip/sip_transport_tls.c"
        ],
        "message": "Merge pull request from GHSA-cv8x-p47p-99wr\n\n* - Avoid SSL socket parent/listener getting destroyed during handshake by increasing parent's reference count.\n- Add missing SSL socket close when the newly accepted SSL socket is discarded in SIP TLS transport.\n\n* - Fix silly mistake: accepted active socket created without group lock in SSL socket.\n- Replace assertion with normal validation check of SSL socket instance in OpenSSL verification callback (verify_cb()) to avoid crash, e.g: if somehow race condition with SSL socket destroy happens or OpenSSL application data index somehow gets corrupted.",
        "before_after_code_files": [
          "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
          "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c",
          "pjsip/src/pjsip/sip_transport_tls.c||pjsip/src/pjsip/sip_transport_tls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
            "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c",
            "pjsip/src/pjsip/sip_transport_tls.c||pjsip/src/pjsip/sip_transport_tls.c"
          ],
          "candidate": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
            "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c",
            "pjsip/src/pjsip/sip_transport_tls.c||pjsip/src/pjsip/sip_transport_tls.c"
          ]
        }
      },
      "candidate_diff": {
        "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c": [
          "File: pjlib/src/pj/ssl_sock_imp_common.c -> pjlib/src/pj/ssl_sock_imp_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:     if (ssock->is_server) {",
          "258:  if (status != PJ_SUCCESS) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "258:  pj_bool_t ret = PJ_TRUE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "272:         status);",
          "273:      }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "278:      if (ssock->parent->param.grp_lock) {",
          "279:   pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);",
          "280:   ssock->parent = NULL;",
          "281:      }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "316:      return PJ_FALSE;",
          "317:  }",
          "319:  if (ssock->param.cb.on_accept_complete2) {",
          "321:      ret = (*ssock->param.cb.on_accept_complete2)",
          "322:       (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr,",
          "323:       pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr),",
          "324:       status);",
          "327:  } else if (ssock->param.cb.on_accept_complete) {",
          "329:      ret = (*ssock->param.cb.on_accept_complete)",
          "330:         (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr,",
          "331:          pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr));",
          "334:  }",
          "335:     }",
          "",
          "[Removed Lines]",
          "320:      pj_bool_t ret;",
          "325:      if (ret == PJ_FALSE)",
          "326:   return PJ_FALSE;",
          "328:      pj_bool_t ret;",
          "332:      if (ret == PJ_FALSE)",
          "333:   return PJ_FALSE;",
          "",
          "[Added Lines]",
          "342:  if (ssock->parent->param.grp_lock) {",
          "343:      pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);",
          "344:      ssock->parent = NULL;",
          "345:  }",
          "347:  if (ret == PJ_FALSE)",
          "348:      return PJ_FALSE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "930:     if (status != PJ_SUCCESS)",
          "931:  goto on_return;",
          "934:     ssock->sock = newsock;",
          "936:     ssock->is_server = PJ_TRUE;",
          "937:     if (ssock_parent->cert) {",
          "938:  status = pj_ssl_sock_set_certificate(ssock, ssock->pool,",
          "",
          "[Removed Lines]",
          "935:     ssock->parent = ssock_parent;",
          "",
          "[Added Lines]",
          "948:     ssock->parent = ssock_parent;",
          "949:     if (ssock->parent->param.grp_lock)",
          "950:  pj_grp_lock_add_ref(ssock->parent->param.grp_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "957:     ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool,",
          "958:             ssock->param.async_cnt,",
          "959:             sizeof(void*));",
          "963:     for (i = 0; i<ssock->param.async_cnt; ++i) {",
          "964:  ssock->asock_rbuf[i] = (void*) pj_pool_alloc(",
          "965:          ssock->pool,",
          "966:          ssock->param.read_buffer_size +",
          "967:          sizeof(read_data_t*));",
          "970:     }",
          "",
          "[Removed Lines]",
          "960:     if (!ssock->asock_rbuf)",
          "961:         return PJ_ENOMEM;",
          "968:         if (!ssock->asock_rbuf[i])",
          "969:             return PJ_ENOMEM;",
          "",
          "[Added Lines]",
          "978:     if (!ssock->asock_rbuf) {",
          "979:  status = PJ_ENOMEM;",
          "980:  goto on_return;",
          "981:     }",
          "988:  if (!ssock->asock_rbuf[i]) {",
          "989:      status = PJ_ENOMEM;",
          "990:      goto on_return;",
          "991:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "980:      goto on_return;",
          "982:  pj_grp_lock_add_ref(glock);",
          "984:  pj_grp_lock_add_handler(ssock->param.grp_lock, ssock->pool, ssock,",
          "985:     ssl_on_destroy);",
          "986:     }",
          "",
          "[Removed Lines]",
          "983:  asock_cfg.grp_lock = ssock->param.grp_lock = glock;",
          "",
          "[Added Lines]",
          "1005:  ssock->param.grp_lock = glock;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1010:     pj_activesock_cfg_default(&asock_cfg);",
          "1011:     asock_cfg.async_cnt = ssock->param.async_cnt;",
          "1012:     asock_cfg.concurrency = ssock->param.concurrency;",
          "1013:     asock_cfg.whole_data = PJ_TRUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1033:     asock_cfg.grp_lock = ssock->param.grp_lock;",
          "",
          "---------------"
        ],
        "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c": [
          "File: pjlib/src/pj/ssl_sock_ossl.c -> pjlib/src/pj/ssl_sock_ossl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "327:  ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);",
          "328:     }",
          "331:     return GET_STATUS_FROM_SSL_ERR(err);",
          "332: }",
          "",
          "[Removed Lines]",
          "330:     ssock->last_err = err;",
          "",
          "[Added Lines]",
          "330:     if (ssock)",
          "331:  ssock->last_err = err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "345:     SSLLogErrors(action, ret, err, len, ssock);",
          "348:     return GET_STATUS_FROM_SSL_ERR(ssl_err);",
          "349: }",
          "",
          "[Removed Lines]",
          "347:     ssock->last_err = ssl_err;",
          "",
          "[Added Lines]",
          "348:     if (ssock)",
          "349:  ssock->last_err = ssl_err;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "788:     sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);",
          "790: #if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\",
          "791:     PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "791:     if (sslsock_idx == -1) {",
          "792:  status = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);",
          "793:  PJ_LOG(1,(THIS_FILE,",
          "794:         \"Fatal error: failed to get application data index for \"",
          "795:         \"SSL socket\"));",
          "796:  return status;",
          "797:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "819: }",
          "823: static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)",
          "824: {",
          "827:     int err;",
          "830:     ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx,",
          "831:         SSL_get_ex_data_X509_STORE_CTX_idx());",
          "835:     ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);",
          "839:     err = X509_STORE_CTX_get_error(x509_ctx);",
          "",
          "[Removed Lines]",
          "825:     pj_ssl_sock_t *ssock;",
          "826:     SSL *ossl_ssl;",
          "832:     pj_assert(ossl_ssl);",
          "836:     pj_assert(ssock);",
          "",
          "[Added Lines]",
          "839:     pj_ssl_sock_t *ssock = NULL;",
          "840:     SSL *ossl_ssl = NULL;",
          "846:     if (!ossl_ssl) {",
          "847:  PJ_LOG(1,(THIS_FILE,",
          "848:     \"SSL verification callback failed to get SSL instance\"));",
          "849:  goto on_return;",
          "850:     }",
          "854:     if (!ssock) {",
          "856:  PJ_LOG(1,(THIS_FILE,",
          "857:     \"SSL verification callback failed to get SSL socket \"",
          "858:     \"instance (sslsock_idx=%d).\", sslsock_idx));",
          "859:  goto on_return;",
          "860:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "911:     if (PJ_FALSE == ssock->param.verify_peer)",
          "912:  preverify_ok = 1;",
          "914:     return preverify_ok;",
          "915: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "938: on_return:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1474: static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)",
          "1475: {",
          "1476:     ossl_sock_t *ossock = (ossl_sock_t *)ssock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1504:     if (ossock->ossl_ssl) {",
          "1505:  SSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);",
          "1506:     }",
          "",
          "---------------"
        ],
        "pjsip/src/pjsip/sip_transport_tls.c||pjsip/src/pjsip/sip_transport_tls.c": [
          "File: pjsip/src/pjsip/sip_transport_tls.c -> pjsip/src/pjsip/sip_transport_tls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1333:     PJ_UNUSED_ARG(src_addr_len);",
          "1335:     listener = (struct tls_listener*) pj_ssl_sock_get_user_data(ssock);",
          "1337:     if (accept_status != PJ_SUCCESS) {",
          "1339:      pjsip_tls_on_accept_fail_param param;",
          "1340:      pj_ssl_sock_info ssi;",
          "",
          "[Removed Lines]",
          "1338:  if (listener && listener->tls_setting.on_accept_fail_cb) {",
          "",
          "[Added Lines]",
          "1336:     if (!listener) {",
          "1340:  if (new_ssock && accept_status == PJ_SUCCESS) {",
          "1342:      PJ_LOG(4,(THIS_FILE,",
          "1343:         \"Incoming TLS connection from %s (sock=%d) is discarded \"",
          "1344:         \"because listener is already destroyed\",",
          "1345:         pj_sockaddr_print(src_addr, addr, sizeof(addr), 3),",
          "1346:         new_ssock));",
          "1348:      pj_ssl_sock_close(new_ssock);",
          "1349:  }",
          "1351:  return PJ_FALSE;",
          "1352:     }",
          "1355:  if (listener->tls_setting.on_accept_fail_cb) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1358:     PJ_ASSERT_RETURN(new_ssock, PJ_TRUE);",
          "1360:     if (!listener->is_registered) {",
          "1361:  if (listener->tls_setting.on_accept_fail_cb) {",
          "1362:      pjsip_tls_on_accept_fail_param param;",
          "1363:      pj_bzero(&param, sizeof(param));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1378:  pj_ssl_sock_close(new_ssock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1409:     ssl_info.grp_lock, &tls);",
          "1411:     if (status != PJ_SUCCESS) {",
          "1412:  if (listener->tls_setting.on_accept_fail_cb) {",
          "1413:      pjsip_tls_on_accept_fail_param param;",
          "1414:      pj_bzero(&param, sizeof(param));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1431:  pj_ssl_sock_close(new_ssock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d2689d33f2eedc8e1b4713ae068a5aafa3457988",
      "candidate_info": {
        "commit_hash": "d2689d33f2eedc8e1b4713ae068a5aafa3457988",
        "repo": "pjsip/pjproject",
        "commit_url": "https://github.com/pjsip/pjproject/commit/d2689d33f2eedc8e1b4713ae068a5aafa3457988",
        "files": [
          "pjlib/src/pj/ssl_sock_imp_common.c",
          "pjlib/src/pj/ssl_sock_ossl.c"
        ],
        "message": "- Fix silly mistake: active socket created without group lock in SSL socket server. - Replace assertion with normal validation check of SSL socket instance in OpenSSL verification callback (verify_cb()) to avoid crash, e.g: if somehow race condition with SSL socket destroy happens or OpenSSL application data index somehow gets corrupted.",
        "before_after_code_files": [
          "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
          "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
            "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c"
          ],
          "candidate": [
            "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c",
            "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c"
          ]
        }
      },
      "candidate_diff": {
        "pjlib/src/pj/ssl_sock_imp_common.c||pjlib/src/pj/ssl_sock_imp_common.c": [
          "File: pjlib/src/pj/ssl_sock_imp_common.c -> pjlib/src/pj/ssl_sock_imp_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "980:      goto on_return;",
          "982:  pj_grp_lock_add_ref(glock);",
          "984:  pj_grp_lock_add_handler(ssock->param.grp_lock, ssock->pool, ssock,",
          "985:     ssl_on_destroy);",
          "986:     }",
          "",
          "[Removed Lines]",
          "983:  asock_cfg.grp_lock = ssock->param.grp_lock = glock;",
          "",
          "[Added Lines]",
          "983:  ssock->param.grp_lock = glock;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1010:     pj_activesock_cfg_default(&asock_cfg);",
          "1011:     asock_cfg.async_cnt = ssock->param.async_cnt;",
          "1012:     asock_cfg.concurrency = ssock->param.concurrency;",
          "1013:     asock_cfg.whole_data = PJ_TRUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1011:     asock_cfg.grp_lock = ssock->param.grp_lock;",
          "",
          "---------------"
        ],
        "pjlib/src/pj/ssl_sock_ossl.c||pjlib/src/pj/ssl_sock_ossl.c": [
          "File: pjlib/src/pj/ssl_sock_ossl.c -> pjlib/src/pj/ssl_sock_ossl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "327:  ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);",
          "328:     }",
          "331:     return GET_STATUS_FROM_SSL_ERR(err);",
          "332: }",
          "",
          "[Removed Lines]",
          "330:     ssock->last_err = err;",
          "",
          "[Added Lines]",
          "330:     if (ssock)",
          "331:  ssock->last_err = err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "345:     SSLLogErrors(action, ret, err, len, ssock);",
          "348:     return GET_STATUS_FROM_SSL_ERR(ssl_err);",
          "349: }",
          "",
          "[Removed Lines]",
          "347:     ssock->last_err = ssl_err;",
          "",
          "[Added Lines]",
          "348:     if (ssock)",
          "349:  ssock->last_err = ssl_err;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "788:     sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);",
          "790: #if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\",
          "791:     PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "791:     if (sslsock_idx == -1) {",
          "792:  status = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);",
          "793:  PJ_LOG(1,(THIS_FILE,",
          "794:         \"Fatal error: failed to get application data index for \"",
          "795:         \"SSL socket\"));",
          "796:  return status;",
          "797:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "819: }",
          "823: static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)",
          "824: {",
          "827:     int err;",
          "830:     ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx,",
          "831:         SSL_get_ex_data_X509_STORE_CTX_idx());",
          "835:     ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);",
          "839:     err = X509_STORE_CTX_get_error(x509_ctx);",
          "",
          "[Removed Lines]",
          "825:     pj_ssl_sock_t *ssock;",
          "826:     SSL *ossl_ssl;",
          "832:     pj_assert(ossl_ssl);",
          "836:     pj_assert(ssock);",
          "",
          "[Added Lines]",
          "839:     pj_ssl_sock_t *ssock = NULL;",
          "840:     SSL *ossl_ssl = NULL;",
          "846:     if (!ossl_ssl) {",
          "847:  PJ_LOG(1,(THIS_FILE,",
          "848:     \"SSL verification callback failed to get SSL instance\"));",
          "849:  goto on_return;",
          "850:     }",
          "854:     if (!ssock) {",
          "856:  PJ_LOG(1,(THIS_FILE,",
          "857:     \"SSL verification callback failed to get SSL socket \"",
          "858:     \"instance (sslsock_idx=%d).\", sslsock_idx));",
          "859:  goto on_return;",
          "860:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "911:     if (PJ_FALSE == ssock->param.verify_peer)",
          "912:  preverify_ok = 1;",
          "914:     return preverify_ok;",
          "915: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "938: on_return:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1474: static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)",
          "1475: {",
          "1476:     ossl_sock_t *ossock = (ossl_sock_t *)ssock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1504:     if (ossock->ossl_ssl) {",
          "1505:  SSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);",
          "1506:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
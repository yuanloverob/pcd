{
  "cve_id": "CVE-2015-7513",
  "cve_desc": "arch/x86/kvm/x86.c in the Linux kernel before 4.4 does not reset the PIT counter values during state restoration, which allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via a zero value, related to the kvm_vm_ioctl_set_pit and kvm_vm_ioctl_set_pit2 functions.",
  "repo": "torvalds/linux",
  "patch_hash": "0185604c2d82c560dab2f2933a18f797e74ab5a8",
  "patch_info": {
    "commit_hash": "0185604c2d82c560dab2f2933a18f797e74ab5a8",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0185604c2d82c560dab2f2933a18f797e74ab5a8",
    "files": [
      "arch/x86/kvm/x86.c"
    ],
    "message": "KVM: x86: Reload pit counters for all channels when restoring state\n\nCurrently if userspace restores the pit counters with a count of 0\non channels 1 or 2 and the guest attempts to read the count on those\nchannels, then KVM will perform a mod of 0 and crash.  This will ensure\nthat 0 values are converted to 65536 as per the spec.\n\nThis is CVE-2015-7513.\n\nSigned-off-by: Andy Honig <ahonig@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c": [
      "File: arch/x86/kvm/x86.c -> arch/x86/kvm/x86.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3573: static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)",
      "3574: {",
      "3575:  mutex_lock(&kvm->arch.vpit->pit_state.lock);",
      "3576:  memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));",
      "3578:  mutex_unlock(&kvm->arch.vpit->pit_state.lock);",
      "3579:  return 0;",
      "3580: }",
      "",
      "[Removed Lines]",
      "3577:  kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);",
      "",
      "[Added Lines]",
      "3575:  int i;",
      "3578:  for (i = 0; i < 3; i++)",
      "3579:   kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3593: static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)",
      "3594: {",
      "3595:  int start = 0;",
      "3596:  u32 prev_legacy, cur_legacy;",
      "3597:  mutex_lock(&kvm->arch.vpit->pit_state.lock);",
      "3598:  prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3598:  int i;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3602:  memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,",
      "3603:         sizeof(kvm->arch.vpit->pit_state.channels));",
      "3604:  kvm->arch.vpit->pit_state.flags = ps->flags;",
      "3606:  mutex_unlock(&kvm->arch.vpit->pit_state.lock);",
      "3607:  return 0;",
      "3608: }",
      "",
      "[Removed Lines]",
      "3605:  kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);",
      "",
      "[Added Lines]",
      "3608:  for (i = 0; i < 3; i++)",
      "3609:   kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "09edea72b7f9fd8a8d26c1f7504d989b9773ee5e",
      "candidate_info": {
        "commit_hash": "09edea72b7f9fd8a8d26c1f7504d989b9773ee5e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/09edea72b7f9fd8a8d26c1f7504d989b9773ee5e",
        "files": [
          "arch/x86/kvm/i8254.c",
          "arch/x86/kvm/i8254.h",
          "arch/x86/kvm/x86.c"
        ],
        "message": "KVM: i8254: pass struct kvm_pit instead of kvm in PIT\n\nThis patch passes struct kvm_pit into internal PIT functions.\nThose functions used to get PIT through kvm->arch.vpit, even though most\nof them never used *kvm for other purposes.  Another benefit is that we\ndon't need to set kvm->arch.vpit during initialization.\n\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/i8254.c||arch/x86/kvm/i8254.c",
          "arch/x86/kvm/i8254.h||arch/x86/kvm/i8254.h",
          "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
          ],
          "candidate": [
            "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/i8254.c||arch/x86/kvm/i8254.c": [
          "File: arch/x86/kvm/i8254.c -> arch/x86/kvm/i8254.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:  return res.ll;",
          "72: }",
          "75: {",
          "79:  switch (c->mode) {",
          "80:  default:",
          "",
          "[Removed Lines]",
          "74: static void pit_set_gate(struct kvm *kvm, int channel, u32 val)",
          "76:  struct kvm_kpit_channel_state *c =",
          "77:   &kvm->arch.vpit->pit_state.channels[channel];",
          "",
          "[Added Lines]",
          "74: static void pit_set_gate(struct kvm_pit *pit, int channel, u32 val)",
          "76:  struct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95:  c->gate = val;",
          "96: }",
          "99: {",
          "101: }",
          "104: {",
          "105:  s64 elapsed;",
          "106:  ktime_t remaining;",
          "109:  if (!ps->period)",
          "110:   return 0;",
          "",
          "[Removed Lines]",
          "98: static int pit_get_gate(struct kvm *kvm, int channel)",
          "100:  return kvm->arch.vpit->pit_state.channels[channel].gate;",
          "103: static s64 __kpit_elapsed(struct kvm *kvm)",
          "107:  struct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;",
          "",
          "[Added Lines]",
          "97: static int pit_get_gate(struct kvm_pit *pit, int channel)",
          "99:  return pit->pit_state.channels[channel].gate;",
          "102: static s64 __kpit_elapsed(struct kvm_pit *pit)",
          "106:  struct kvm_kpit_state *ps = &pit->pit_state;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "124:  return elapsed;",
          "125: }",
          "128:    int channel)",
          "129: {",
          "130:  if (channel == 0)",
          "133:  return ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));",
          "134: }",
          "137: {",
          "140:  s64 d, t;",
          "141:  int counter;",
          "144:  d = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);",
          "146:  switch (c->mode) {",
          "",
          "[Removed Lines]",
          "127: static s64 kpit_elapsed(struct kvm *kvm, struct kvm_kpit_channel_state *c,",
          "131:   return __kpit_elapsed(kvm);",
          "136: static int pit_get_count(struct kvm *kvm, int channel)",
          "138:  struct kvm_kpit_channel_state *c =",
          "139:   &kvm->arch.vpit->pit_state.channels[channel];",
          "143:  t = kpit_elapsed(kvm, c, channel);",
          "",
          "[Added Lines]",
          "126: static s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,",
          "130:   return __kpit_elapsed(pit);",
          "135: static int pit_get_count(struct kvm_pit *pit, int channel)",
          "137:  struct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];",
          "141:  t = kpit_elapsed(pit, c, channel);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "161:  return counter;",
          "162: }",
          "165: {",
          "168:  s64 d, t;",
          "169:  int out;",
          "172:  d = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);",
          "174:  switch (c->mode) {",
          "",
          "[Removed Lines]",
          "164: static int pit_get_out(struct kvm *kvm, int channel)",
          "166:  struct kvm_kpit_channel_state *c =",
          "167:   &kvm->arch.vpit->pit_state.channels[channel];",
          "171:  t = kpit_elapsed(kvm, c, channel);",
          "",
          "[Added Lines]",
          "162: static int pit_get_out(struct kvm_pit *pit, int channel)",
          "164:  struct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];",
          "168:  t = kpit_elapsed(pit, c, channel);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "194:  return out;",
          "195: }",
          "198: {",
          "202:  if (!c->count_latched) {",
          "204:   c->count_latched = c->rw_mode;",
          "205:  }",
          "206: }",
          "209: {",
          "213:  if (!c->status_latched) {",
          "216:     (c->rw_mode << 4) |",
          "217:     (c->mode << 1) |",
          "218:     c->bcd);",
          "",
          "[Removed Lines]",
          "197: static void pit_latch_count(struct kvm *kvm, int channel)",
          "199:  struct kvm_kpit_channel_state *c =",
          "200:   &kvm->arch.vpit->pit_state.channels[channel];",
          "203:   c->latched_count = pit_get_count(kvm, channel);",
          "208: static void pit_latch_status(struct kvm *kvm, int channel)",
          "210:  struct kvm_kpit_channel_state *c =",
          "211:   &kvm->arch.vpit->pit_state.channels[channel];",
          "215:   c->status = ((pit_get_out(kvm, channel) << 7) |",
          "",
          "[Added Lines]",
          "194: static void pit_latch_count(struct kvm_pit *pit, int channel)",
          "196:  struct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];",
          "199:   c->latched_count = pit_get_count(pit, channel);",
          "204: static void pit_latch_status(struct kvm_pit *pit, int channel)",
          "206:  struct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];",
          "210:   c->status = ((pit_get_out(pit, channel) << 7) |",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "306:  atomic_set(&pit->pit_state.irq_ack, 1);",
          "307: }",
          "310: {",
          "312:  s64 interval;",
          "314:  if (!ioapic_in_kernel(kvm) ||",
          "",
          "[Removed Lines]",
          "309: static void create_pit_timer(struct kvm *kvm, u32 val, int is_period)",
          "311:  struct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;",
          "",
          "[Added Lines]",
          "304: static void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)",
          "306:  struct kvm_kpit_state *ps = &pit->pit_state;",
          "307:  struct kvm *kvm = pit->kvm;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "326:  ps->is_periodic = is_period;",
          "328:  ps->timer.function = pit_timer_fn;",
          "",
          "[Removed Lines]",
          "329:  ps->kvm = ps->pit->kvm;",
          "331:  kvm_pit_reset_reinject(ps->pit);",
          "",
          "[Added Lines]",
          "325:  ps->kvm = pit->kvm;",
          "327:  kvm_pit_reset_reinject(pit);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "351:         HRTIMER_MODE_ABS);",
          "352: }",
          "355: {",
          "358:  pr_debug(\"load_count val is %d, channel is %d\\n\", val, channel);",
          "",
          "[Removed Lines]",
          "354: static void pit_load_count(struct kvm *kvm, int channel, u32 val)",
          "356:  struct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;",
          "",
          "[Added Lines]",
          "350: static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)",
          "352:  struct kvm_kpit_state *ps = &pit->pit_state;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "378:  case 1:",
          "380:  case 4:",
          "382:   break;",
          "383:  case 2:",
          "384:  case 3:",
          "386:   break;",
          "387:  default:",
          "389:  }",
          "390: }",
          "393: {",
          "394:  u8 saved_mode;",
          "398:  if (hpet_legacy_start) {",
          "400:   WARN_ON(channel != 0);",
          "405:  } else {",
          "407:  }",
          "408: }",
          "",
          "[Removed Lines]",
          "381:   create_pit_timer(kvm, val, 0);",
          "385:   create_pit_timer(kvm, val, 1);",
          "388:   destroy_pit_timer(kvm->arch.vpit);",
          "392: void kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_start)",
          "396:  WARN_ON_ONCE(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));",
          "401:   saved_mode = kvm->arch.vpit->pit_state.channels[0].mode;",
          "403:   pit_load_count(kvm, channel, val);",
          "404:   kvm->arch.vpit->pit_state.channels[0].mode = saved_mode;",
          "406:   pit_load_count(kvm, channel, val);",
          "",
          "[Added Lines]",
          "377:   create_pit_timer(pit, val, 0);",
          "381:   create_pit_timer(pit, val, 1);",
          "384:   destroy_pit_timer(pit);",
          "388: void kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,",
          "389:   int hpet_legacy_start)",
          "393:  WARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));",
          "398:   saved_mode = pit->pit_state.channels[0].mode;",
          "400:   pit_load_count(pit, channel, val);",
          "401:   pit->pit_state.channels[0].mode = saved_mode;",
          "403:   pit_load_count(pit, channel, val);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "429: {",
          "430:  struct kvm_pit *pit = dev_to_pit(this);",
          "431:  struct kvm_kpit_state *pit_state = &pit->pit_state;",
          "433:  int channel, access;",
          "434:  struct kvm_kpit_channel_state *s;",
          "435:  u32 val = *(u32 *) data;",
          "",
          "[Removed Lines]",
          "432:  struct kvm *kvm = pit->kvm;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "453:     s = &pit_state->channels[channel];",
          "454:     if (val & (2 << channel)) {",
          "455:      if (!(val & 0x20))",
          "457:      if (!(val & 0x10))",
          "459:     }",
          "460:    }",
          "461:   } else {",
          "",
          "[Removed Lines]",
          "456:       pit_latch_count(kvm, channel);",
          "458:       pit_latch_status(kvm, channel);",
          "",
          "[Added Lines]",
          "452:       pit_latch_count(pit, channel);",
          "454:       pit_latch_status(pit, channel);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "463:    s = &pit_state->channels[channel];",
          "464:    access = (val >> 4) & KVM_PIT_CHANNEL_MASK;",
          "465:    if (access == 0) {",
          "467:    } else {",
          "468:     s->rw_mode = access;",
          "469:     s->read_state = access;",
          "",
          "[Removed Lines]",
          "466:     pit_latch_count(kvm, channel);",
          "",
          "[Added Lines]",
          "462:     pit_latch_count(pit, channel);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "480:   switch (s->write_state) {",
          "481:   default:",
          "482:   case RW_STATE_LSB:",
          "484:    break;",
          "485:   case RW_STATE_MSB:",
          "487:    break;",
          "488:   case RW_STATE_WORD0:",
          "489:    s->write_latch = val;",
          "490:    s->write_state = RW_STATE_WORD1;",
          "491:    break;",
          "492:   case RW_STATE_WORD1:",
          "494:    s->write_state = RW_STATE_WORD0;",
          "495:    break;",
          "496:   }",
          "",
          "[Removed Lines]",
          "483:    pit_load_count(kvm, addr, val);",
          "486:    pit_load_count(kvm, addr, val << 8);",
          "493:    pit_load_count(kvm, addr, s->write_latch | (val << 8));",
          "",
          "[Added Lines]",
          "479:    pit_load_count(pit, addr, val);",
          "482:    pit_load_count(pit, addr, val << 8);",
          "489:    pit_load_count(pit, addr, s->write_latch | (val << 8));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "506: {",
          "507:  struct kvm_pit *pit = dev_to_pit(this);",
          "508:  struct kvm_kpit_state *pit_state = &pit->pit_state;",
          "510:  int ret, count;",
          "511:  struct kvm_kpit_channel_state *s;",
          "512:  if (!pit_in_range(addr))",
          "",
          "[Removed Lines]",
          "509:  struct kvm *kvm = pit->kvm;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "543:   switch (s->read_state) {",
          "544:   default:",
          "545:   case RW_STATE_LSB:",
          "547:    ret = count & 0xff;",
          "548:    break;",
          "549:   case RW_STATE_MSB:",
          "551:    ret = (count >> 8) & 0xff;",
          "552:    break;",
          "553:   case RW_STATE_WORD0:",
          "555:    ret = count & 0xff;",
          "556:    s->read_state = RW_STATE_WORD1;",
          "557:    break;",
          "558:   case RW_STATE_WORD1:",
          "560:    ret = (count >> 8) & 0xff;",
          "561:    s->read_state = RW_STATE_WORD0;",
          "562:    break;",
          "",
          "[Removed Lines]",
          "546:    count = pit_get_count(kvm, addr);",
          "550:    count = pit_get_count(kvm, addr);",
          "554:    count = pit_get_count(kvm, addr);",
          "559:    count = pit_get_count(kvm, addr);",
          "",
          "[Added Lines]",
          "541:    count = pit_get_count(pit, addr);",
          "545:    count = pit_get_count(pit, addr);",
          "549:    count = pit_get_count(pit, addr);",
          "554:    count = pit_get_count(pit, addr);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "577: {",
          "578:  struct kvm_pit *pit = speaker_to_pit(this);",
          "579:  struct kvm_kpit_state *pit_state = &pit->pit_state;",
          "581:  u32 val = *(u32 *) data;",
          "582:  if (addr != KVM_SPEAKER_BASE_ADDRESS)",
          "583:   return -EOPNOTSUPP;",
          "585:  mutex_lock(&pit_state->lock);",
          "586:  pit_state->speaker_data_on = (val >> 1) & 1;",
          "588:  mutex_unlock(&pit_state->lock);",
          "589:  return 0;",
          "590: }",
          "",
          "[Removed Lines]",
          "580:  struct kvm *kvm = pit->kvm;",
          "587:  pit_set_gate(kvm, 2, val & 1);",
          "",
          "[Added Lines]",
          "581:  pit_set_gate(pit, 2, val & 1);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "595: {",
          "596:  struct kvm_pit *pit = speaker_to_pit(this);",
          "597:  struct kvm_kpit_state *pit_state = &pit->pit_state;",
          "599:  unsigned int refresh_clock;",
          "600:  int ret;",
          "601:  if (addr != KVM_SPEAKER_BASE_ADDRESS)",
          "",
          "[Removed Lines]",
          "598:  struct kvm *kvm = pit->kvm;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "605:  refresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;",
          "607:  mutex_lock(&pit_state->lock);",
          "610:  if (len > sizeof(ret))",
          "611:   len = sizeof(ret);",
          "612:  memcpy(data, (char *)&ret, len);",
          "",
          "[Removed Lines]",
          "608:  ret = ((pit_state->speaker_data_on << 1) | pit_get_gate(kvm, 2) |",
          "609:   (pit_get_out(kvm, 2) << 5) | (refresh_clock << 4));",
          "",
          "[Added Lines]",
          "601:  ret = ((pit_state->speaker_data_on << 1) | pit_get_gate(pit, 2) |",
          "602:   (pit_get_out(pit, 2) << 5) | (refresh_clock << 4));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "625:   c = &pit->pit_state.channels[i];",
          "626:   c->mode = 0xff;",
          "627:   c->gate = (i != 2);",
          "629:  }",
          "630:  mutex_unlock(&pit->pit_state.lock);",
          "",
          "[Removed Lines]",
          "628:   pit_load_count(pit->kvm, i, 0);",
          "",
          "[Added Lines]",
          "621:   pit_load_count(pit, i, 0);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "687:  }",
          "688:  init_kthread_work(&pit->expired, pit_do_work);",
          "691:  pit->kvm = kvm;",
          "693:  pit_state = &pit->pit_state;",
          "",
          "[Removed Lines]",
          "690:  kvm->arch.vpit = pit;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "arch/x86/kvm/i8254.h||arch/x86/kvm/i8254.h": [
          "File: arch/x86/kvm/i8254.h -> arch/x86/kvm/i8254.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: #define KVM_MAX_PIT_INTR_INTERVAL   HZ / 100",
          "57: #define KVM_PIT_CHANNEL_MASK     0x3",
          "60: struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags);",
          "61: void kvm_free_pit(struct kvm *kvm);",
          "62: void kvm_pit_reset(struct kvm_pit *pit);",
          "64: #endif",
          "",
          "[Removed Lines]",
          "59: void kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_start);",
          "",
          "[Added Lines]",
          "63: void kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,",
          "64:   int hpet_legacy_start);",
          "",
          "---------------"
        ],
        "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c": [
          "File: arch/x86/kvm/x86.c -> arch/x86/kvm/x86.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3613: static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)",
          "3614: {",
          "3615:  int i;",
          "3618:  for (i = 0; i < 3; i++)",
          "3621:  return 0;",
          "3622: }",
          "",
          "[Removed Lines]",
          "3616:  mutex_lock(&kvm->arch.vpit->pit_state.lock);",
          "3617:  memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));",
          "3619:   kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);",
          "3620:  mutex_unlock(&kvm->arch.vpit->pit_state.lock);",
          "",
          "[Added Lines]",
          "3616:  struct kvm_pit *pit = kvm->arch.vpit;",
          "3618:  mutex_lock(&pit->pit_state.lock);",
          "3619:  memcpy(&pit->pit_state, ps, sizeof(struct kvm_pit_state));",
          "3621:   kvm_pit_load_count(pit, i, ps->channels[i].count, 0);",
          "3622:  mutex_unlock(&pit->pit_state.lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3637:  int start = 0;",
          "3638:  int i;",
          "3639:  u32 prev_legacy, cur_legacy;",
          "3642:  cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;",
          "3643:  if (!prev_legacy && cur_legacy)",
          "3644:   start = 1;",
          "3648:  for (i = 0; i < 3; i++)",
          "3650:        start && i == 0);",
          "3652:  return 0;",
          "3653: }",
          "",
          "[Removed Lines]",
          "3640:  mutex_lock(&kvm->arch.vpit->pit_state.lock);",
          "3641:  prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;",
          "3645:  memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,",
          "3646:         sizeof(kvm->arch.vpit->pit_state.channels));",
          "3647:  kvm->arch.vpit->pit_state.flags = ps->flags;",
          "3649:   kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count,",
          "3651:  mutex_unlock(&kvm->arch.vpit->pit_state.lock);",
          "",
          "[Added Lines]",
          "3642:  struct kvm_pit *pit = kvm->arch.vpit;",
          "3644:  mutex_lock(&pit->pit_state.lock);",
          "3645:  prev_legacy = pit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;",
          "3649:  memcpy(&pit->pit_state.channels, &ps->channels,",
          "3650:         sizeof(pit->pit_state.channels));",
          "3651:  pit->pit_state.flags = ps->flags;",
          "3653:   kvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,",
          "3655:  mutex_unlock(&pit->pit_state.lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5e57e7a03b1cdcb98e4aed135def2a08cbf3257",
      "candidate_info": {
        "commit_hash": "e5e57e7a03b1cdcb98e4aed135def2a08cbf3257",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e5e57e7a03b1cdcb98e4aed135def2a08cbf3257",
        "files": [
          "arch/x86/kvm/i8254.c",
          "arch/x86/kvm/x86.c"
        ],
        "message": "kvm: x86: only channel 0 of the i8254 is linked to the HPET\n\nWhile setting the KVM PIT counters in 'kvm_pit_load_count', if\n'hpet_legacy_start' is set, the function disables the timer on\nchannel[0], instead of the respective index 'channel'. This is\nbecause channels 1-3 are not linked to the HPET.  Fix the caller\nto only activate the special HPET processing for channel 0.\n\nReported-by: P J P <pjp@fedoraproject.org>\nFixes: 0185604c2d82c560dab2f2933a18f797e74ab5a8\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/i8254.c||arch/x86/kvm/i8254.c",
          "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
          ],
          "candidate": [
            "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/i8254.c||arch/x86/kvm/i8254.c": [
          "File: arch/x86/kvm/i8254.c -> arch/x86/kvm/i8254.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "420:  u8 saved_mode;",
          "421:  if (hpet_legacy_start) {",
          "423:   saved_mode = kvm->arch.vpit->pit_state.channels[0].mode;",
          "425:   pit_load_count(kvm, channel, val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "423:   WARN_ON(channel != 0);",
          "",
          "---------------"
        ],
        "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c": [
          "File: arch/x86/kvm/x86.c -> arch/x86/kvm/x86.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3606:         sizeof(kvm->arch.vpit->pit_state.channels));",
          "3607:  kvm->arch.vpit->pit_state.flags = ps->flags;",
          "3608:  for (i = 0; i < 3; i++)",
          "3610:  mutex_unlock(&kvm->arch.vpit->pit_state.lock);",
          "3611:  return 0;",
          "3612: }",
          "",
          "[Removed Lines]",
          "3609:   kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);",
          "",
          "[Added Lines]",
          "3609:   kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count,",
          "3610:        start && i == 0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
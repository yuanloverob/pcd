{
  "cve_id": "CVE-2016-4581",
  "cve_desc": "fs/pnode.c in the Linux kernel before 4.5.4 does not properly traverse a mount propagation tree in a certain case involving a slave mount, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted series of mount system calls.",
  "repo": "torvalds/linux",
  "patch_hash": "5ec0811d30378ae104f250bfc9b3640242d81e3f",
  "patch_info": {
    "commit_hash": "5ec0811d30378ae104f250bfc9b3640242d81e3f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5ec0811d30378ae104f250bfc9b3640242d81e3f",
    "files": [
      "fs/pnode.c"
    ],
    "message": "propogate_mnt: Handle the first propogated copy being a slave\n\nWhen the first propgated copy was a slave the following oops would result:\n> BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n> IP: [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> PGD bacd4067 PUD bac66067 PMD 0\n> Oops: 0000 [#1] SMP\n> Modules linked in:\n> CPU: 1 PID: 824 Comm: mount Not tainted 4.6.0-rc5userns+ #1523\n> Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007\n> task: ffff8800bb0a8000 ti: ffff8800bac3c000 task.ti: ffff8800bac3c000\n> RIP: 0010:[<ffffffff811fba4e>]  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> RSP: 0018:ffff8800bac3fd38  EFLAGS: 00010283\n> RAX: 0000000000000000 RBX: ffff8800bb77ec00 RCX: 0000000000000010\n> RDX: 0000000000000000 RSI: ffff8800bb58c000 RDI: ffff8800bb58c480\n> RBP: ffff8800bac3fd48 R08: 0000000000000001 R09: 0000000000000000\n> R10: 0000000000001ca1 R11: 0000000000001c9d R12: 0000000000000000\n> R13: ffff8800ba713800 R14: ffff8800bac3fda0 R15: ffff8800bb77ec00\n> FS:  00007f3c0cd9b7e0(0000) GS:ffff8800bfb00000(0000) knlGS:0000000000000000\n> CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n> CR2: 0000000000000010 CR3: 00000000bb79d000 CR4: 00000000000006e0\n> Stack:\n>  ffff8800bb77ec00 0000000000000000 ffff8800bac3fd88 ffffffff811fbf85\n>  ffff8800bac3fd98 ffff8800bb77f080 ffff8800ba713800 ffff8800bb262b40\n>  0000000000000000 0000000000000000 ffff8800bac3fdd8 ffffffff811f1da0\n> Call Trace:\n>  [<ffffffff811fbf85>] propagate_mnt+0x105/0x140\n>  [<ffffffff811f1da0>] attach_recursive_mnt+0x120/0x1e0\n>  [<ffffffff811f1ec3>] graft_tree+0x63/0x70\n>  [<ffffffff811f1f6b>] do_add_mount+0x9b/0x100\n>  [<ffffffff811f2c1a>] do_mount+0x2aa/0xdf0\n>  [<ffffffff8117efbe>] ? strndup_user+0x4e/0x70\n>  [<ffffffff811f3a45>] SyS_mount+0x75/0xc0\n>  [<ffffffff8100242b>] do_syscall_64+0x4b/0xa0\n>  [<ffffffff81988f3c>] entry_SYSCALL64_slow_path+0x25/0x25\n> Code: 00 00 75 ec 48 89 0d 02 22 22 01 8b 89 10 01 00 00 48 89 05 fd 21 22 01 39 8e 10 01 00 00 0f 84 e0 00 00 00 48 8b 80 d8 00 00 00 <48> 8b 50 10 48 89 05 df 21 22 01 48 89 15 d0 21 22 01 8b 53 30\n> RIP  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n>  RSP <ffff8800bac3fd38>\n> CR2: 0000000000000010\n> ---[ end trace 2725ecd95164f217 ]---\n\nThis oops happens with the namespace_sem held and can be triggered by\nnon-root users.  An all around not pleasant experience.\n\nTo avoid this scenario when finding the appropriate source mount to\ncopy stop the walk up the mnt_master chain when the first source mount\nis encountered.\n\nFurther rewrite the walk up the last_source mnt_master chain so that\nit is clear what is going on.\n\nThe reason why the first source mount is special is that it it's\nmnt_parent is not a mount in the dest_mnt propagation tree, and as\nsuch termination conditions based up on the dest_mnt mount propgation\ntree do not make sense.\n\nTo avoid other kinds of confusion last_dest is not changed when\ncomputing last_source.  last_dest is only used once in propagate_one\nand that is above the point of the code being modified, so changing\nthe global variable is meaningless and confusing.\n\nCc: stable@vger.kernel.org\nfixes: f2ebb3a921c1ca1e2ddd9242e95a1989a50c4c68 (\"smarter propagate_mnt()\")\nReported-by: Tycho Andersen <tycho.andersen@canonical.com>\nReviewed-by: Seth Forshee <seth.forshee@canonical.com>\nTested-by: Seth Forshee <seth.forshee@canonical.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "fs/pnode.c||fs/pnode.c"
    ]
  },
  "patch_diff": {
    "fs/pnode.c||fs/pnode.c": [
      "File: fs/pnode.c -> fs/pnode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "200: static struct user_namespace *user_ns;",
      "202: static struct mountpoint *mp;",
      "203: static struct hlist_head *list;",
      "",
      "[Removed Lines]",
      "201: static struct mount *last_dest, *last_source, *dest_master;",
      "",
      "[Added Lines]",
      "201: static struct mount *last_dest, *first_source, *last_source, *dest_master;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "221:   type = CL_MAKE_SHARED;",
      "222:  } else {",
      "223:   struct mount *n, *p;",
      "224:   for (n = m; ; n = p) {",
      "225:    p = n->mnt_master;",
      "235:     break;",
      "237:   }",
      "238:   type = CL_SLAVE;",
      "240:   if (IS_MNT_SHARED(m))",
      "",
      "[Removed Lines]",
      "226:    if (p == dest_master || IS_MNT_MARKED(p)) {",
      "227:     while (last_dest->mnt_master != p) {",
      "228:      last_source = last_source->mnt_master;",
      "229:      last_dest = last_source->mnt_parent;",
      "230:     }",
      "231:     if (!peers(n, last_dest)) {",
      "232:      last_source = last_source->mnt_master;",
      "233:      last_dest = last_source->mnt_parent;",
      "234:     }",
      "236:    }",
      "",
      "[Added Lines]",
      "224:   bool done;",
      "227:    if (p == dest_master || IS_MNT_MARKED(p))",
      "230:   do {",
      "231:    struct mount *parent = last_source->mnt_parent;",
      "232:    if (last_source == first_source)",
      "233:     break;",
      "234:    done = parent->mnt_master == p;",
      "235:    if (done && peers(n, parent))",
      "236:     break;",
      "237:    last_source = last_source->mnt_master;",
      "238:   } while (!done);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "287:  user_ns = current->nsproxy->mnt_ns->user_ns;",
      "288:  last_dest = dest_mnt;",
      "289:  last_source = source_mnt;",
      "290:  mp = dest_mp;",
      "291:  list = tree_list;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291:  first_source = source_mnt;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b49b927f16acee626c56a1af4ab4cb062f75b5df",
      "candidate_info": {
        "commit_hash": "b49b927f16acee626c56a1af4ab4cb062f75b5df",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b49b927f16acee626c56a1af4ab4cb062f75b5df",
        "files": [
          "drivers/mfd/omap-usb-tll.c"
        ],
        "message": "mfd: omap-usb-tll: Fix scheduling while atomic BUG\n\nWe shouldn't be calling clk_prepare_enable()/clk_prepare_disable()\nin an atomic context.\n\nFixes the following issue:\n\n[    5.830970] ehci-omap: OMAP-EHCI Host Controller driver\n[    5.830974] driver_register 'ehci-omap'\n[    5.895849] driver_register 'wl1271_sdio'\n[    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002\n[    5.896876] 4 locks held by udevd/994:\n[    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac\n[    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac\n[    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0\n[    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0\n[    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine\n[    5.897048] Preemption disabled at:[<  (null)>]   (null)\n[    5.897051]\n[    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233\n[    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)\n[    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)\n[    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)\n[    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)\n[    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)\n[    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)\n[    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)\n[    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)\n[    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)\n[    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)\n[    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)\n[    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)\n[    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)\n[    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)\n[    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)\n[    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)\n[    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)\n[    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)\n[    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)\n[    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)\n[    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)\n[    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)\n[    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)\n[    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)\n[    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)\n[    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)\n[    5.912697] ------------[ cut here ]------------\n[    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58\n[    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())\n\nCc: <stable@vger.kernel.org>\nReported-by: H. Nikolaus Schaller <hns@goldelico.com>\nTested-by: H. Nikolaus Schaller <hns@goldelico.com>\nSigned-off-by: Roger Quadros <rogerq@ti.com>\nSigned-off-by: Lee Jones <lee.jones@linaro.org>",
        "before_after_code_files": [
          "drivers/mfd/omap-usb-tll.c||drivers/mfd/omap-usb-tll.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mfd/omap-usb-tll.c||drivers/mfd/omap-usb-tll.c": [
          "File: drivers/mfd/omap-usb-tll.c -> drivers/mfd/omap-usb-tll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "270:   if (IS_ERR(tll->ch_clk[i]))",
          "271:    dev_dbg(dev, \"can't get clock : %s\\n\", clkname);",
          "272:  }",
          "274:  pm_runtime_put_sync(dev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:   else",
          "273:    clk_prepare(tll->ch_clk[i]);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "301:  tll_dev = NULL;",
          "302:  spin_unlock(&tll_lock);",
          "306:    clk_put(tll->ch_clk[i]);",
          "308:  pm_runtime_disable(&pdev->dev);",
          "309:  return 0;",
          "",
          "[Removed Lines]",
          "304:  for (i = 0; i < tll->nch; i++)",
          "305:   if (!IS_ERR(tll->ch_clk[i]))",
          "",
          "[Added Lines]",
          "306:  for (i = 0; i < tll->nch; i++) {",
          "307:   if (!IS_ERR(tll->ch_clk[i])) {",
          "308:    clk_unprepare(tll->ch_clk[i]);",
          "310:   }",
          "311:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:    if (IS_ERR(tll->ch_clk[i]))",
          "421:     continue;",
          "424:    if (r) {",
          "425:     dev_err(tll_dev,",
          "426:      \"Error enabling ch %d clock: %d\\n\", i, r);",
          "",
          "[Removed Lines]",
          "423:    r = clk_prepare_enable(tll->ch_clk[i]);",
          "",
          "[Added Lines]",
          "428:    r = clk_enable(tll->ch_clk[i]);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "448:  for (i = 0; i < tll->nch; i++) {",
          "449:   if (omap_usb_mode_needs_tll(pdata->port_mode[i])) {",
          "450:    if (!IS_ERR(tll->ch_clk[i]))",
          "452:   }",
          "453:  }",
          "",
          "[Removed Lines]",
          "451:     clk_disable_unprepare(tll->ch_clk[i]);",
          "",
          "[Added Lines]",
          "456:     clk_disable(tll->ch_clk[i]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "deb22e5c84c884a129d801cf3bfde7411536998d",
      "candidate_info": {
        "commit_hash": "deb22e5c84c884a129d801cf3bfde7411536998d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/deb22e5c84c884a129d801cf3bfde7411536998d",
        "files": [
          "drivers/pci/host/pci-hyperv.c"
        ],
        "message": "PCI: hv: Report resources release after stopping the bus\n\nKernel hang is observed when pci-hyperv module is release with device\ndrivers still attached.  E.g., when I do 'rmmod pci_hyperv' with BCM5720\ndevice pass-through-ed (tg3 module) I see the following:\n\n NMI watchdog: BUG: soft lockup - CPU#1 stuck for 22s! [rmmod:2104]\n ...\n Call Trace:\n  [<ffffffffa0641487>] tg3_read_mem+0x87/0x100 [tg3]\n  [<ffffffffa063f000>] ? 0xffffffffa063f000\n  [<ffffffffa0644375>] tg3_poll_fw+0x85/0x150 [tg3]\n  [<ffffffffa0649877>] tg3_chip_reset+0x357/0x8c0 [tg3]\n  [<ffffffffa064ca8b>] tg3_halt+0x3b/0x190 [tg3]\n  [<ffffffffa0657611>] tg3_stop+0x171/0x230 [tg3]\n  ...\n  [<ffffffffa064c550>] tg3_remove_one+0x90/0x140 [tg3]\n  [<ffffffff813bee59>] pci_device_remove+0x39/0xc0\n  [<ffffffff814a3201>] __device_release_driver+0xa1/0x160\n  [<ffffffff814a32e3>] device_release_driver+0x23/0x30\n  [<ffffffff813b794a>] pci_stop_bus_device+0x8a/0xa0\n  [<ffffffff813b7ab6>] pci_stop_root_bus+0x36/0x60\n  [<ffffffffa02c3f38>] hv_pci_remove+0x238/0x260 [pci_hyperv]\n\nThe problem seems to be that we report local resources release before\nstopping the bus and removing devices from it and device drivers may try to\nperform some operations with these resources on shutdown.  Move resources\nrelease report after we do pci_stop_root_bus().\n\nSigned-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>\nSigned-off-by: Bjorn Helgaas <bhelgaas@google.com>\nAcked-by: Jake Oshins <jakeo@microsoft.com>",
        "before_after_code_files": [
          "drivers/pci/host/pci-hyperv.c||drivers/pci/host/pci-hyperv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/pci/host/pci-hyperv.c||drivers/pci/host/pci-hyperv.c": [
          "File: drivers/pci/host/pci-hyperv.c -> drivers/pci/host/pci-hyperv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2269:  hbus = hv_get_drvdata(hdev);",
          "2276:  memset(&pkt.teardown_packet, 0, sizeof(pkt.teardown_packet));",
          "2277:  init_completion(&comp_pkt.host_event);",
          "2278:  pkt.teardown_packet.completion_func = hv_pci_generic_compl;",
          "",
          "[Removed Lines]",
          "2271:  ret = hv_send_resources_released(hdev);",
          "2272:  if (ret)",
          "2273:   dev_err(&hdev->device,",
          "2274:    \"Couldn't send resources released packet(s)\\n\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2295:   pci_unlock_rescan_remove();",
          "2296:  }",
          "2298:  vmbus_close(hdev->channel);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2293:  ret = hv_send_resources_released(hdev);",
          "2294:  if (ret)",
          "2295:   dev_err(&hdev->device,",
          "2296:    \"Couldn't send resources released packet(s)\\n\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "48b3b9d401ec86899a52003b37331190a35a81a6",
      "candidate_info": {
        "commit_hash": "48b3b9d401ec86899a52003b37331190a35a81a6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/48b3b9d401ec86899a52003b37331190a35a81a6",
        "files": [
          "fs/btrfs/volumes.c"
        ],
        "message": "btrfs: fix lock dep warning move scratch super outside of chunk_mutex\n\nMove scratch super outside of the chunk lock to avoid below\nlockdep warning. The better place to scratch super is in\nthe function btrfs_rm_dev_replace_free_srcdev() just before\nfree_device, which is outside of the chunk lock as well.\n\nTo reproduce:\n  (fresh boot)\n  mkfs.btrfs -f -draid5 -mraid5 /dev/sdc /dev/sdd /dev/sde\n  mount /dev/sdc /btrfs\n  dd if=/dev/zero of=/btrfs/tf1 bs=4096 count=100\n  (get devmgt from https://github.com/asj/devmgt.git)\n  devmgt detach /dev/sde\n  dd if=/dev/zero of=/btrfs/tf1 bs=4096 count=100\n  sync\n  btrfs replace start -Brf 3 /dev/sdf /btrfs <--\n  devmgt attach host7\n\n======================================================\n[ INFO: possible circular locking dependency detected ]\n4.6.0-rc2asj+ #1 Not tainted\n---------------------------------------------------\n\nbtrfs/2174 is trying to acquire lock:\n(sb_writers){.+.+.+}, at:\n[<ffffffff812449b4>] __sb_start_write+0xb4/0xf0\n\nbut task is already holding lock:\n(&fs_info->chunk_mutex){+.+.+.}, at:\n[<ffffffffa05c5f55>] btrfs_dev_replace_finishing+0x145/0x980 [btrfs]\n\nwhich lock already depends on the new lock.\n\nChain exists of:\nsb_writers --> &fs_devs->device_list_mutex --> &fs_info->chunk_mutex\nPossible unsafe locking scenario:\nCPU0\t\t\t\tCPU1\n----\t\t\t\t----\nlock(&fs_info->chunk_mutex);\n\t\t\t\tlock(&fs_devs->device_list_mutex);\n\t\t\t\tlock(&fs_info->chunk_mutex);\nlock(sb_writers);\n\n*** DEADLOCK ***\n\n-> #0 (sb_writers){.+.+.+}:\n[<ffffffff810e6415>] __lock_acquire+0x1bc5/0x1ee0\n[<ffffffff810e707e>] lock_acquire+0xbe/0x210\n[<ffffffff810df49a>] percpu_down_read+0x4a/0xa0\n[<ffffffff812449b4>] __sb_start_write+0xb4/0xf0\n[<ffffffff81265534>] mnt_want_write+0x24/0x50\n[<ffffffff812508a2>] path_openat+0x952/0x1190\n[<ffffffff81252451>] do_filp_open+0x91/0x100\n[<ffffffff8123f5cc>] file_open_name+0xfc/0x140\n[<ffffffff8123f643>] filp_open+0x33/0x60\n[<ffffffffa0572bb6>] update_dev_time+0x16/0x40 [btrfs]\n[<ffffffffa057f60d>] btrfs_scratch_superblocks+0x5d/0xb0 [btrfs]\n[<ffffffffa057f70e>] btrfs_rm_dev_replace_remove_srcdev+0xae/0xd0 [btrfs]\n[<ffffffffa05c62c5>] btrfs_dev_replace_finishing+0x4b5/0x980 [btrfs]\n[<ffffffffa05c6ae8>] btrfs_dev_replace_start+0x358/0x530 [btrfs]\n\nSigned-off-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1972:  if (srcdev->missing)",
          "1973:   fs_devices->missing_devices--;",
          "1976:   fs_devices->rw_devices--;",
          "1981:  if (srcdev->bdev)",
          "1982:   fs_devices->open_devices--;",
          "",
          "[Removed Lines]",
          "1975:  if (srcdev->writeable) {",
          "1978:   btrfs_scratch_superblocks(srcdev->bdev, srcdev->name->str);",
          "1979:  }",
          "",
          "[Added Lines]",
          "1975:  if (srcdev->writeable)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1987: {",
          "1988:  struct btrfs_fs_devices *fs_devices = srcdev->fs_devices;",
          "1990:  call_rcu(&srcdev->rcu, free_device);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1987:  if (srcdev->writeable) {",
          "1989:   btrfs_scratch_superblocks(srcdev->bdev, srcdev->name->str);",
          "1990:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "779bf3fefa835cb52a07457c8acac6f2f66f2493",
      "candidate_info": {
        "commit_hash": "779bf3fefa835cb52a07457c8acac6f2f66f2493",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/779bf3fefa835cb52a07457c8acac6f2f66f2493",
        "files": [
          "fs/btrfs/volumes.c"
        ],
        "message": "btrfs: fix lock dep warning, move scratch dev out of device_list_mutex and uuid_mutex\n\nWhen the replace target fails, the target device will be taken\nout of fs device list, scratch + update_dev_time and freed. However\nwe could do the scratch  + update_dev_time and free part after the\ndevice has been taken out of device list, so that we don't have to\nhold the device_list_mutex and uuid_mutex locks.\n\nReported issue:\n\n[ 5375.718845] ======================================================\n[ 5375.718846] [ INFO: possible circular locking dependency detected ]\n[ 5375.718849] 4.4.5-scst31x-debug-11+ #40 Not tainted\n[ 5375.718849] -------------------------------------------------------\n[ 5375.718851] btrfs-health/4662 is trying to acquire lock:\n[ 5375.718861]  (sb_writers){.+.+.+}, at: [<ffffffff812214f7>] __sb_start_write+0xb7/0xf0\n[ 5375.718862]\n[ 5375.718862] but task is already holding lock:\n[ 5375.718907]  (&fs_devs->device_list_mutex){+.+.+.}, at: [<ffffffffa028263c>] btrfs_destroy_dev_replace_tgtdev+0x3c/0x150 [btrfs]\n[ 5375.718907]\n[ 5375.718907] which lock already depends on the new lock.\n[ 5375.718907]\n[ 5375.718908]\n[ 5375.718908] the existing dependency chain (in reverse order) is:\n[ 5375.718911]\n[ 5375.718911] -> #3 (&fs_devs->device_list_mutex){+.+.+.}:\n[ 5375.718917]        [<ffffffff810da4be>] lock_acquire+0xce/0x1e0\n[ 5375.718921]        [<ffffffff81633949>] mutex_lock_nested+0x69/0x3c0\n[ 5375.718940]        [<ffffffffa0219bf6>] btrfs_show_devname+0x36/0x210 [btrfs]\n[ 5375.718945]        [<ffffffff81267079>] show_vfsmnt+0x49/0x150\n[ 5375.718948]        [<ffffffff81240b07>] m_show+0x17/0x20\n[ 5375.718951]        [<ffffffff81246868>] seq_read+0x2d8/0x3b0\n[ 5375.718955]        [<ffffffff8121df28>] __vfs_read+0x28/0xd0\n[ 5375.718959]        [<ffffffff8121e806>] vfs_read+0x86/0x130\n[ 5375.718962]        [<ffffffff8121f4c9>] SyS_read+0x49/0xa0\n[ 5375.718966]        [<ffffffff81637976>] entry_SYSCALL_64_fastpath+0x16/0x7a\n[ 5375.718968]\n[ 5375.718968] -> #2 (namespace_sem){+++++.}:\n[ 5375.718971]        [<ffffffff810da4be>] lock_acquire+0xce/0x1e0\n[ 5375.718974]        [<ffffffff81635199>] down_write+0x49/0x80\n[ 5375.718977]        [<ffffffff81243593>] lock_mount+0x43/0x1c0\n[ 5375.718979]        [<ffffffff81243c13>] do_add_mount+0x23/0xd0\n[ 5375.718982]        [<ffffffff81244afb>] do_mount+0x27b/0xe30\n[ 5375.718985]        [<ffffffff812459dc>] SyS_mount+0x8c/0xd0\n[ 5375.718988]        [<ffffffff81637976>] entry_SYSCALL_64_fastpath+0x16/0x7a\n[ 5375.718991]\n[ 5375.718991] -> #1 (&sb->s_type->i_mutex_key#5){+.+.+.}:\n[ 5375.718994]        [<ffffffff810da4be>] lock_acquire+0xce/0x1e0\n[ 5375.718996]        [<ffffffff81633949>] mutex_lock_nested+0x69/0x3c0\n[ 5375.719001]        [<ffffffff8122d608>] path_openat+0x468/0x1360\n[ 5375.719004]        [<ffffffff8122f86e>] do_filp_open+0x7e/0xe0\n[ 5375.719007]        [<ffffffff8121da7b>] do_sys_open+0x12b/0x210\n[ 5375.719010]        [<ffffffff8121db7e>] SyS_open+0x1e/0x20\n[ 5375.719013]        [<ffffffff81637976>] entry_SYSCALL_64_fastpath+0x16/0x7a\n[ 5375.719015]\n[ 5375.719015] -> #0 (sb_writers){.+.+.+}:\n[ 5375.719018]        [<ffffffff810d97ca>] __lock_acquire+0x17ba/0x1ae0\n[ 5375.719021]        [<ffffffff810da4be>] lock_acquire+0xce/0x1e0\n[ 5375.719026]        [<ffffffff810d3bef>] percpu_down_read+0x4f/0xa0\n[ 5375.719028]        [<ffffffff812214f7>] __sb_start_write+0xb7/0xf0\n[ 5375.719031]        [<ffffffff81242eb4>] mnt_want_write+0x24/0x50\n[ 5375.719035]        [<ffffffff8122ded2>] path_openat+0xd32/0x1360\n[ 5375.719037]        [<ffffffff8122f86e>] do_filp_open+0x7e/0xe0\n[ 5375.719040]        [<ffffffff8121d8a4>] file_open_name+0xe4/0x130\n[ 5375.719043]        [<ffffffff8121d923>] filp_open+0x33/0x60\n[ 5375.719073]        [<ffffffffa02776a6>] update_dev_time+0x16/0x40 [btrfs]\n[ 5375.719099]        [<ffffffffa02825be>] btrfs_scratch_superblocks+0x4e/0x90 [btrfs]\n[ 5375.719123]        [<ffffffffa0282665>] btrfs_destroy_dev_replace_tgtdev+0x65/0x150 [btrfs]\n[ 5375.719150]        [<ffffffffa02c6c80>] btrfs_dev_replace_finishing+0x6b0/0x990 [btrfs]\n[ 5375.719175]        [<ffffffffa02c729e>] btrfs_dev_replace_start+0x33e/0x540 [btrfs]\n[ 5375.719199]        [<ffffffffa02c7f58>] btrfs_auto_replace_start+0xf8/0x140 [btrfs]\n[ 5375.719222]        [<ffffffffa02464e6>] health_kthread+0x246/0x490 [btrfs]\n[ 5375.719225]        [<ffffffff810a70df>] kthread+0xef/0x110\n[ 5375.719229]        [<ffffffff81637d2f>] ret_from_fork+0x3f/0x70\n[ 5375.719230]\n[ 5375.719230] other info that might help us debug this:\n[ 5375.719230]\n[ 5375.719233] Chain exists of:\n[ 5375.719233]   sb_writers --> namespace_sem --> &fs_devs->device_list_mutex\n[ 5375.719233]\n[ 5375.719234]  Possible unsafe locking scenario:\n[ 5375.719234]\n[ 5375.719234]        CPU0                    CPU1\n[ 5375.719235]        ----                    ----\n[ 5375.719236]   lock(&fs_devs->device_list_mutex);\n[ 5375.719238]                                lock(namespace_sem);\n[ 5375.719239]                                lock(&fs_devs->device_list_mutex);\n[ 5375.719241]   lock(sb_writers);\n[ 5375.719241]\n[ 5375.719241]  *** DEADLOCK ***\n[ 5375.719241]\n[ 5375.719243] 4 locks held by btrfs-health/4662:\n[ 5375.719266]  #0:  (&fs_info->health_mutex){+.+.+.}, at: [<ffffffffa0246303>] health_kthread+0x63/0x490 [btrfs]\n[ 5375.719293]  #1:  (&fs_info->dev_replace.lock_finishing_cancel_unmount){+.+.+.}, at: [<ffffffffa02c6611>] btrfs_dev_replace_finishing+0x41/0x990 [btrfs]\n[ 5375.719319]  #2:  (uuid_mutex){+.+.+.}, at: [<ffffffffa0282620>] btrfs_destroy_dev_replace_tgtdev+0x20/0x150 [btrfs]\n[ 5375.719343]  #3:  (&fs_devs->device_list_mutex){+.+.+.}, at: [<ffffffffa028263c>] btrfs_destroy_dev_replace_tgtdev+0x3c/0x150 [btrfs]\n[ 5375.719343]\n[ 5375.719343] stack backtrace:\n[ 5375.719347] CPU: 2 PID: 4662 Comm: btrfs-health Not tainted 4.4.5-scst31x-debug-11+ #40\n[ 5375.719348] Hardware name: Supermicro SYS-6018R-WTRT/X10DRW-iT, BIOS 1.0c 01/07/2015\n[ 5375.719352]  0000000000000000 ffff880856f73880 ffffffff813529e3 ffffffff826182a0\n[ 5375.719354]  ffffffff8260c090 ffff880856f738c0 ffffffff810d667c ffff880856f73930\n[ 5375.719357]  ffff880861f32b40 ffff880861f32b68 0000000000000003 0000000000000004\n[ 5375.719357] Call Trace:\n[ 5375.719363]  [<ffffffff813529e3>] dump_stack+0x85/0xc2\n[ 5375.719366]  [<ffffffff810d667c>] print_circular_bug+0x1ec/0x260\n[ 5375.719369]  [<ffffffff810d97ca>] __lock_acquire+0x17ba/0x1ae0\n[ 5375.719373]  [<ffffffff810f606d>] ? debug_lockdep_rcu_enabled+0x1d/0x20\n[ 5375.719376]  [<ffffffff810da4be>] lock_acquire+0xce/0x1e0\n[ 5375.719378]  [<ffffffff812214f7>] ? __sb_start_write+0xb7/0xf0\n[ 5375.719383]  [<ffffffff810d3bef>] percpu_down_read+0x4f/0xa0\n[ 5375.719385]  [<ffffffff812214f7>] ? __sb_start_write+0xb7/0xf0\n[ 5375.719387]  [<ffffffff812214f7>] __sb_start_write+0xb7/0xf0\n[ 5375.719389]  [<ffffffff81242eb4>] mnt_want_write+0x24/0x50\n[ 5375.719393]  [<ffffffff8122ded2>] path_openat+0xd32/0x1360\n[ 5375.719415]  [<ffffffffa02462a0>] ? btrfs_congested_fn+0x180/0x180 [btrfs]\n[ 5375.719418]  [<ffffffff810f606d>] ? debug_lockdep_rcu_enabled+0x1d/0x20\n[ 5375.719420]  [<ffffffff8122f86e>] do_filp_open+0x7e/0xe0\n[ 5375.719423]  [<ffffffff810f615d>] ? rcu_read_lock_sched_held+0x6d/0x80\n[ 5375.719426]  [<ffffffff81201a9b>] ? kmem_cache_alloc+0x26b/0x5d0\n[ 5375.719430]  [<ffffffff8122e7d4>] ? getname_kernel+0x34/0x120\n[ 5375.719433]  [<ffffffff8121d8a4>] file_open_name+0xe4/0x130\n[ 5375.719436]  [<ffffffff8121d923>] filp_open+0x33/0x60\n[ 5375.719462]  [<ffffffffa02776a6>] update_dev_time+0x16/0x40 [btrfs]\n[ 5375.719485]  [<ffffffffa02825be>] btrfs_scratch_superblocks+0x4e/0x90 [btrfs]\n[ 5375.719506]  [<ffffffffa0282665>] btrfs_destroy_dev_replace_tgtdev+0x65/0x150 [btrfs]\n[ 5375.719530]  [<ffffffffa02c6c80>] btrfs_dev_replace_finishing+0x6b0/0x990 [btrfs]\n[ 5375.719554]  [<ffffffffa02c6b23>] ? btrfs_dev_replace_finishing+0x553/0x990 [btrfs]\n[ 5375.719576]  [<ffffffffa02c729e>] btrfs_dev_replace_start+0x33e/0x540 [btrfs]\n[ 5375.719598]  [<ffffffffa02c7f58>] btrfs_auto_replace_start+0xf8/0x140 [btrfs]\n[ 5375.719621]  [<ffffffffa02464e6>] health_kthread+0x246/0x490 [btrfs]\n[ 5375.719641]  [<ffffffffa02463d8>] ? health_kthread+0x138/0x490 [btrfs]\n[ 5375.719661]  [<ffffffffa02462a0>] ? btrfs_congested_fn+0x180/0x180 [btrfs]\n[ 5375.719663]  [<ffffffff810a70df>] kthread+0xef/0x110\n[ 5375.719666]  [<ffffffff810a6ff0>] ? kthread_create_on_node+0x200/0x200\n[ 5375.719669]  [<ffffffff81637d2f>] ret_from_fork+0x3f/0x70\n[ 5375.719672]  [<ffffffff810a6ff0>] ? kthread_create_on_node+0x200/0x200\n[ 5375.719697] ------------[ cut here ]------------\n\nSigned-off-by: Anand Jain <anand.jain@oracle.com>\nReported-by: Yauhen Kharuzhy <yauhen.kharuzhy@zavadatar.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2025:  btrfs_sysfs_rm_device_link(fs_info->fs_devices, tgtdev);",
          "2029:   fs_info->fs_devices->open_devices--;",
          "2031:  fs_info->fs_devices->num_devices--;",
          "2033:  next_device = list_entry(fs_info->fs_devices->devices.next,",
          "",
          "[Removed Lines]",
          "2027:  if (tgtdev->bdev) {",
          "2028:   btrfs_scratch_superblocks(tgtdev->bdev, tgtdev->name->str);",
          "2030:  }",
          "",
          "[Added Lines]",
          "2027:  if (tgtdev->bdev)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2038:   fs_info->fs_devices->latest_bdev = next_device->bdev;",
          "2039:  list_del_rcu(&tgtdev->dev_list);",
          "2043:  mutex_unlock(&fs_info->fs_devices->device_list_mutex);",
          "2044:  mutex_unlock(&uuid_mutex);",
          "2045: }",
          "2047: static int btrfs_find_device_by_path(struct btrfs_root *root, char *device_path,",
          "",
          "[Removed Lines]",
          "2041:  call_rcu(&tgtdev->rcu, free_device);",
          "",
          "[Added Lines]",
          "2050:  btrfs_scratch_superblocks(tgtdev->bdev, tgtdev->name->str);",
          "2051:  call_rcu(&tgtdev->rcu, free_device);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5e3c61f981756361e7dc74e2c673121028449e35",
      "candidate_info": {
        "commit_hash": "5e3c61f981756361e7dc74e2c673121028449e35",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5e3c61f981756361e7dc74e2c673121028449e35",
        "files": [
          "net/netfilter/nf_conntrack_core.c"
        ],
        "message": "netfilter: conntrack: fix lookup race during hash resize\n\nWhen resizing the conntrack hash table at runtime via\necho 42 > /sys/module/nf_conntrack/parameters/hashsize, we are racing with\nthe conntrack lookup path -- reads can happen in parallel and nothing\nprevents readers from observing a the newly allocated hash but the old\nsize (or vice versa).\n\nSo access to hash[bucket] can trigger OOB read access in case the table got\nexpanded and we saw the new size but the old hash pointer (or it got shrunk\nand we got new hash ptr but the size of the old and larger table):\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN\nCPU: 0 PID: 3 Comm: ksoftirqd/0 Not tainted 4.6.0-rc2+ #107\n[..]\nCall Trace:\n[<ffffffff822c3d6a>] ? nf_conntrack_tuple_taken+0x12a/0xe90\n[<ffffffff822c3ac1>] ? nf_ct_invert_tuplepr+0x221/0x3a0\n[<ffffffff8230e703>] get_unique_tuple+0xfb3/0x2760\n\nUse generation counter to obtain the address/length of the same table.\n\nAlso add a synchronize_net before freeing the old hash.\nAFAICS, without it we might access ct_hash[bucket] after ct_hash has been\nfreed, provided that lockless reader got delayed by another event:\n\nCPU1\t\t\tCPU2\nseq_begin\nseq_retry\n<delay>\t\t\tresize occurs\n\t\t\tfree oldhash\nfor_each(oldhash[size])\n\nNote that resize is only supported in init_netns, it took over 2 minutes\nof constant resizing+flooding to produce the warning, so this isn't a\nbig problem in practice.\n\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/netfilter/nf_conntrack_core.c||net/netfilter/nf_conntrack_core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/netfilter/nf_conntrack_core.c||net/netfilter/nf_conntrack_core.c": [
          "File: net/netfilter/nf_conntrack_core.c -> net/netfilter/nf_conntrack_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "469:         const struct nf_conntrack_tuple *tuple, u32 hash)",
          "470: {",
          "471:  struct nf_conntrack_tuple_hash *h;",
          "472:  struct hlist_nulls_node *n;",
          "475: begin:",
          "477:   if (nf_ct_key_equal(h, tuple, zone)) {",
          "478:    NF_CT_STAT_INC_ATOMIC(net, found);",
          "479:    return h;",
          "",
          "[Removed Lines]",
          "473:  unsigned int bucket = hash_bucket(hash, net);",
          "476:  hlist_nulls_for_each_entry_rcu(h, n, &net->ct.hash[bucket], hnnode) {",
          "",
          "[Added Lines]",
          "472:  struct hlist_nulls_head *ct_hash;",
          "474:  unsigned int bucket, sequence;",
          "477:  do {",
          "478:   sequence = read_seqcount_begin(&nf_conntrack_generation);",
          "479:   bucket = hash_bucket(hash, net);",
          "480:   ct_hash = net->ct.hash;",
          "481:  } while (read_seqcount_retry(&nf_conntrack_generation, sequence));",
          "483:  hlist_nulls_for_each_entry_rcu(h, n, &ct_hash[bucket], hnnode) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "722:  struct net *net = nf_ct_net(ignored_conntrack);",
          "723:  const struct nf_conntrack_zone *zone;",
          "724:  struct nf_conntrack_tuple_hash *h;",
          "725:  struct hlist_nulls_node *n;",
          "726:  struct nf_conn *ct;",
          "729:  zone = nf_ct_zone(ignored_conntrack);",
          "732:  rcu_read_lock();",
          "734:   ct = nf_ct_tuplehash_to_ctrack(h);",
          "735:   if (ct != ignored_conntrack &&",
          "736:       nf_ct_tuple_equal(tuple, &h->tuple) &&",
          "",
          "[Removed Lines]",
          "727:  unsigned int hash;",
          "730:  hash = hash_conntrack(net, tuple);",
          "733:  hlist_nulls_for_each_entry_rcu(h, n, &net->ct.hash[hash], hnnode) {",
          "",
          "[Added Lines]",
          "732:  struct hlist_nulls_head *ct_hash;",
          "733:  unsigned int hash, sequence;",
          "740:  do {",
          "741:   sequence = read_seqcount_begin(&nf_conntrack_generation);",
          "742:   hash = hash_conntrack(net, tuple);",
          "743:   ct_hash = net->ct.hash;",
          "744:  } while (read_seqcount_retry(&nf_conntrack_generation, sequence));",
          "746:  hlist_nulls_for_each_entry_rcu(h, n, &ct_hash[hash], hnnode) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1607:  nf_conntrack_all_unlock();",
          "1608:  local_bh_enable();",
          "1610:  nf_ct_free_hashtable(old_hash, old_size);",
          "1611:  return 0;",
          "1612: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1623:  synchronize_net();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
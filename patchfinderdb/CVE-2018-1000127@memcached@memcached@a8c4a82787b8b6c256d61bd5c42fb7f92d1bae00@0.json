{
  "cve_id": "CVE-2018-1000127",
  "cve_desc": "memcached version prior to 1.4.37 contains an Integer Overflow vulnerability in items.c:item_free() that can result in data corruption and deadlocks due to items existing in hash table being reused from free list. This attack appear to be exploitable via network connectivity to the memcached service. This vulnerability appears to have been fixed in 1.4.37 and later.",
  "repo": "memcached/memcached",
  "patch_hash": "a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00",
  "patch_info": {
    "commit_hash": "a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00",
    "repo": "memcached/memcached",
    "commit_url": "https://github.com/memcached/memcached/commit/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00",
    "files": [
      "memcached.c"
    ],
    "message": "Don't overflow item refcount on get\n\nCounts as a miss if the refcount is too high. ASCII multigets are the only\ntime refcounts can be held for so long.\n\ndoing a dirty read of refcount. is aligned.\n\ntrying to avoid adding an extra refcount branch for all calls of item_get due\nto performance. might be able to move it in there after logging refactoring\nsimplifies some of the branches.",
    "before_after_code_files": [
      "memcached.c||memcached.c"
    ]
  },
  "patch_diff": {
    "memcached.c||memcached.c": [
      "File: memcached.c -> memcached.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3249:     return (p - suffix) + 2;",
      "3250: }",
      "3253: static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {",
      "3254:     char *key;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3252: #define IT_REFCOUNT_LIMIT 60000",
      "3253: static inline item* limited_get(char *key, size_t nkey, conn *c) {",
      "3254:     item *it = item_get(key, nkey, c, DO_UPDATE);",
      "3255:     if (it && it->refcount > IT_REFCOUNT_LIMIT) {",
      "3256:         item_remove(it);",
      "3257:         it = NULL;",
      "3258:     }",
      "3259:     return it;",
      "3260: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3273:                 return;",
      "3274:             }",
      "3277:             if (settings.detail_enabled) {",
      "3278:                 stats_prefix_record_get(key, nkey, NULL != it);",
      "3279:             }",
      "",
      "[Removed Lines]",
      "3276:             it = item_get(key, nkey, c, DO_UPDATE);",
      "",
      "[Added Lines]",
      "3286:             it = limited_get(key, nkey, c);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7f4e0246e5c27baa9a7a690e5905f5ee56b80ece",
      "candidate_info": {
        "commit_hash": "7f4e0246e5c27baa9a7a690e5905f5ee56b80ece",
        "repo": "memcached/memcached",
        "commit_url": "https://github.com/memcached/memcached/commit/7f4e0246e5c27baa9a7a690e5905f5ee56b80ece",
        "files": [
          "doc/protocol.txt",
          "memcached.c",
          "t/getandtouch.t"
        ],
        "message": "adds get and touch command for ascii protocol",
        "before_after_code_files": [
          "memcached.c||memcached.c",
          "t/getandtouch.t||t/getandtouch.t"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "memcached.c||memcached.c"
          ],
          "candidate": [
            "memcached.c||memcached.c"
          ]
        }
      },
      "candidate_diff": {
        "memcached.c||memcached.c": [
          "File: memcached.c -> memcached.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3278: }",
          "3280: #define IT_REFCOUNT_LIMIT 60000",
          "3283:     if (it && it->refcount > IT_REFCOUNT_LIMIT) {",
          "3284:         item_remove(it);",
          "3285:         it = NULL;",
          "",
          "[Removed Lines]",
          "3281: static inline item* limited_get(char *key, size_t nkey, conn *c) {",
          "3282:     item *it = item_get(key, nkey, c, DO_UPDATE);",
          "",
          "[Added Lines]",
          "3281: static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {",
          "3282:     item *it;",
          "3283:     if (should_touch) {",
          "3284:         it = item_touch(key, nkey, exptime, c);",
          "3285:     } else {",
          "3286:         it = item_get(key, nkey, c, DO_UPDATE);",
          "3287:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3338:     char *key;",
          "3339:     size_t nkey;",
          "3340:     int i = 0;",
          "",
          "[Removed Lines]",
          "3337: static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {",
          "",
          "[Added Lines]",
          "3342: static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3342:     item *it;",
          "3343:     token_t *key_token = &tokens[KEY_TOKEN];",
          "3344:     char *suffix;",
          "3345:     assert(c != NULL);",
          "3347:     do {",
          "3348:         while(key_token->length != 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3350:     int32_t exptime_int = 0;",
          "3351:     rel_time_t exptime = 0;",
          "3354:     if (should_touch) {",
          "3356:         if (!safe_strtol(tokens[1].value, &exptime_int)) {",
          "3357:             out_string(c, \"CLIENT_ERROR invalid exptime argument\");",
          "3358:             return;",
          "3359:         }",
          "3360:         key_token++;",
          "3361:         exptime = realtime(exptime_int);",
          "3362:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3361:                 return;",
          "3362:             }",
          "3365:             if (settings.detail_enabled) {",
          "3366:                 stats_prefix_record_get(key, nkey, NULL != it);",
          "3367:             }",
          "",
          "[Removed Lines]",
          "3364:             it = limited_get(key, nkey, c);",
          "",
          "[Added Lines]",
          "3381:             it = limited_get(key, nkey, c, exptime, should_touch);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3445:                 pthread_mutex_lock(&c->thread->stats.mutex);",
          "3448:                 pthread_mutex_unlock(&c->thread->stats.mutex);",
          "3450:                 i++;",
          "3452:             } else {",
          "3453:                 pthread_mutex_lock(&c->thread->stats.mutex);",
          "3457:                 MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);",
          "3458:             }",
          "3460:             key_token++;",
          "",
          "[Removed Lines]",
          "3446:                 c->thread->stats.lru_hits[it->slabs_clsid]++;",
          "3447:                 c->thread->stats.get_cmds++;",
          "3454:                 c->thread->stats.get_misses++;",
          "3455:                 c->thread->stats.get_cmds++;",
          "3456:                 pthread_mutex_unlock(&c->thread->stats.mutex);",
          "",
          "[Added Lines]",
          "3463:                 if (should_touch) {",
          "3464:                     c->thread->stats.touch_cmds++;",
          "3465:                     c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;",
          "3466:                 } else {",
          "3467:                     c->thread->stats.lru_hits[it->slabs_clsid]++;",
          "3468:                     c->thread->stats.get_cmds++;",
          "3469:                 }",
          "3476:                 if (should_touch) {",
          "3477:                     c->thread->stats.touch_cmds++;",
          "3478:                     c->thread->stats.touch_misses++;",
          "3479:                 } else {",
          "3480:                     c->thread->stats.get_misses++;",
          "3481:                     c->thread->stats.get_cmds++;",
          "3482:                 }",
          "3484:                 pthread_mutex_unlock(&c->thread->stats.mutex);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4077:         ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||",
          "4078:          (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {",
          "4082:     } else if ((ntokens == 6 || ntokens == 7) &&",
          "4083:                ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = NREAD_ADD)) ||",
          "",
          "[Removed Lines]",
          "4080:         process_get_command(c, tokens, ntokens, false);",
          "",
          "[Added Lines]",
          "4107:         process_get_command(c, tokens, ntokens, false, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4099:     } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {",
          "4103:     } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {",
          "",
          "[Removed Lines]",
          "4101:         process_get_command(c, tokens, ntokens, true);",
          "",
          "[Added Lines]",
          "4128:         process_get_command(c, tokens, ntokens, true, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4113:         process_touch_command(c, tokens, ntokens);",
          "4115:     } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {",
          "4117:         process_stat(c, tokens, ntokens);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4142:     } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"gat\") == 0)) {",
          "4144:         process_get_command(c, tokens, ntokens, false, true);",
          "4146:     } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"gats\") == 0)) {",
          "4148:         process_get_command(c, tokens, ntokens, true, true);",
          "",
          "---------------"
        ],
        "t/getandtouch.t||t/getandtouch.t": [
          "File: t/getandtouch.t -> t/getandtouch.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/perl",
          "3: use strict;",
          "4: use warnings;",
          "5: use Test::More tests => 15;",
          "6: use FindBin qw($Bin);",
          "7: use lib \"$Bin/lib\";",
          "8: use MemcachedTest;",
          "11: my $server = new_memcached();",
          "12: my $sock = $server->sock;",
          "14: # cache miss",
          "15: print $sock \"gat 10 foo1\\r\\n\";",
          "16: is(scalar <$sock>, \"END\\r\\n\", \"cache miss\");",
          "18: # set foo1 and foo2 (and should get it)",
          "19: print $sock \"set foo1 0 2 7\\r\\nfooval1\\r\\n\";",
          "20: is(scalar <$sock>, \"STORED\\r\\n\", \"stored foo\");",
          "22: print $sock \"set foo2 0 2 7\\r\\nfooval2\\r\\n\";",
          "23: is(scalar <$sock>, \"STORED\\r\\n\", \"stored foo2\");",
          "25: # get and touch it with cas",
          "26: print $sock \"gats 10 foo1 foo2\\r\\n\";",
          "27: ok(scalar <$sock> =~ /VALUE foo1 0 7 (\\d+)\\r\\n/, \"get and touch foo1 with cas regexp success\");",
          "28: is(scalar <$sock>, \"fooval1\\r\\n\",\"value\");",
          "29: ok(scalar <$sock> =~ /VALUE foo2 0 7 (\\d+)\\r\\n/, \"get and touch foo2 with cas regexp success\");",
          "30: is(scalar <$sock>, \"fooval2\\r\\n\",\"value\");",
          "31: is(scalar <$sock>, \"END\\r\\n\", \"end\");",
          "33: # get and touch it without cas",
          "34: print $sock \"gat 10 foo1 foo2\\r\\n\";",
          "35: ok(scalar <$sock> =~ /VALUE foo1 0 7\\r\\n/, \"get and touch foo1 without cas regexp success\");",
          "36: is(scalar <$sock>, \"fooval1\\r\\n\",\"value\");",
          "37: ok(scalar <$sock> =~ /VALUE foo2 0 7\\r\\n/, \"get and touch foo2 without cas regexp success\");",
          "38: is(scalar <$sock>, \"fooval2\\r\\n\",\"value\");",
          "39: is(scalar <$sock>, \"END\\r\\n\", \"end\");",
          "41: sleep 2;",
          "42: mem_get_is($sock, \"foo1\", \"fooval1\");",
          "43: mem_get_is($sock, \"foo2\", \"fooval2\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
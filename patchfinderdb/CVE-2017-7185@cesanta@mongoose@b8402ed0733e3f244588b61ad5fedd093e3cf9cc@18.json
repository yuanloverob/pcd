{
  "cve_id": "CVE-2017-7185",
  "cve_desc": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.",
  "repo": "cesanta/mongoose",
  "patch_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
  "patch_info": {
    "commit_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "files": [
      "mongoose.c"
    ],
    "message": "Fix crash in multipart handling\n\nClose cesanta/dev#6974\n\nPUBLISHED_FROM=4d4e4a46eceba10aec8dacb7f8f58bd078c92307",
    "before_after_code_files": [
      "mongoose.c||mongoose.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5961:   struct mbuf *io = &c->recv_mbuf;",
      "5962:   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);",
      "5964:   if ((int) io->len < pd->mp_stream.boundary_len + 2) {",
      "5965:     return 0;",
      "5966:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5964:   if (pd->mp_stream.boundary == NULL) {",
      "5965:     pd->mp_stream.state = MPS_FINALIZE;",
      "5966:     DBG((\"Invalid request: boundary not initilaized\"));",
      "5967:     return 0;",
      "5968:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d3a8862bd8ba87c7a48819a93ff14524fbb9fe06",
      "candidate_info": {
        "commit_hash": "d3a8862bd8ba87c7a48819a93ff14524fbb9fe06",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/d3a8862bd8ba87c7a48819a93ff14524fbb9fe06",
        "files": [
          "docs/c-api/net.h/struct_mg_mgr_init_opts.md",
          "mongoose.c",
          "mongoose.h"
        ],
        "message": "Make interface vtables const\n\nFrees up a bit of ram on ESP\n\nPUBLISHED_FROM=0ea046cc63704481bca138b3096937669b94733d",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2975: #define MG_ENABLE_NET_IF_SOCKET MG_NET_IF == MG_NET_IF_SOCKET",
          "2976: #endif",
          "2980: #ifdef __cplusplus",
          "2981: }",
          "",
          "[Removed Lines]",
          "2978: extern struct mg_iface_vtable mg_socket_iface_vtable;",
          "",
          "[Added Lines]",
          "2978: extern const struct mg_iface_vtable mg_socket_iface_vtable;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3003: extern \"C\" {",
          "3008: struct mg_connection *mg_tun_if_find_conn(struct mg_tun_client *client,",
          "3009:                                           uint32_t stream_id);",
          "",
          "[Removed Lines]",
          "3006: extern struct mg_iface_vtable mg_tun_iface_vtable;",
          "",
          "[Added Lines]",
          "3006: extern const struct mg_iface_vtable mg_tun_iface_vtable;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3028: #if MG_ENABLE_TUN",
          "3031: #else",
          "3033: #endif",
          "3035: int mg_num_ifaces = (int) (sizeof(mg_ifaces) / sizeof(mg_ifaces[0]));",
          "3038:                                     struct mg_mgr *mgr) {",
          "3039:   struct mg_iface *iface = (struct mg_iface *) MG_CALLOC(1, sizeof(*iface));",
          "3040:   iface->mgr = mgr;",
          "",
          "[Removed Lines]",
          "3026: extern struct mg_iface_vtable mg_default_iface_vtable;",
          "3029: struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable,",
          "3030:                                        &mg_tun_iface_vtable};",
          "3032: struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable};",
          "3037: struct mg_iface *mg_if_create_iface(struct mg_iface_vtable *vtable,",
          "",
          "[Added Lines]",
          "3026: extern const struct mg_iface_vtable mg_default_iface_vtable;",
          "3029: const struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable,",
          "3030:                                              &mg_tun_iface_vtable};",
          "3032: const struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable};",
          "3037: struct mg_iface *mg_if_create_iface(const struct mg_iface_vtable *vtable,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3044: }",
          "3046: struct mg_iface *mg_find_iface(struct mg_mgr *mgr,",
          "3048:                                struct mg_iface *from) {",
          "3049:   int i = 0;",
          "3050:   if (from != NULL) {",
          "",
          "[Removed Lines]",
          "3047:                                struct mg_iface_vtable *vtable,",
          "",
          "[Added Lines]",
          "3047:                                const struct mg_iface_vtable *vtable,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3790:   }",
          "3794: #if MG_NET_IF == MG_NET_IF_SOCKET",
          "3796: #endif",
          "",
          "[Removed Lines]",
          "3793: struct mg_iface_vtable mg_socket_iface_vtable = MG_SOCKET_IFACE_VTABLE;",
          "3795: struct mg_iface_vtable mg_default_iface_vtable = MG_SOCKET_IFACE_VTABLE;",
          "",
          "[Added Lines]",
          "3793: const struct mg_iface_vtable mg_socket_iface_vtable = MG_SOCKET_IFACE_VTABLE;",
          "3795: const struct mg_iface_vtable mg_default_iface_vtable = MG_SOCKET_IFACE_VTABLE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3966:   }",
          "3972: #ifdef MG_MODULE_LINES",
          "",
          "[Removed Lines]",
          "3969: struct mg_iface_vtable mg_tun_iface_vtable = MG_TUN_IFACE_VTABLE;",
          "",
          "[Added Lines]",
          "3969: const struct mg_iface_vtable mg_tun_iface_vtable = MG_TUN_IFACE_VTABLE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "13012: #define MG_ENABLE_NET_IF_SIMPLELINK MG_NET_IF == MG_NET_IF_SIMPLELINK",
          "13013: #endif",
          "13017: #ifdef __cplusplus",
          "13018: }",
          "",
          "[Removed Lines]",
          "13015: extern struct mg_iface_vtable mg_simplelink_iface_vtable;",
          "",
          "[Added Lines]",
          "13015: extern const struct mg_iface_vtable mg_simplelink_iface_vtable;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "13484:   }",
          "13488: #if MG_NET_IF == MG_NET_IF_SIMPLELINK",
          "13490: #endif",
          "",
          "[Removed Lines]",
          "13487: struct mg_iface_vtable mg_simplelink_iface_vtable = MG_SL_IFACE_VTABLE;",
          "13489: struct mg_iface_vtable mg_default_iface_vtable = MG_SL_IFACE_VTABLE;",
          "",
          "[Added Lines]",
          "13487: const struct mg_iface_vtable mg_simplelink_iface_vtable = MG_SL_IFACE_VTABLE;",
          "13489: const struct mg_iface_vtable mg_default_iface_vtable = MG_SL_IFACE_VTABLE;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "13707: #include <stdint.h>",
          "13711: struct mg_lwip_conn_state {",
          "13712:   struct mg_connection *nc;",
          "",
          "[Removed Lines]",
          "13709: extern struct mg_iface_vtable mg_lwip_iface_vtable;",
          "",
          "[Added Lines]",
          "13709: extern const struct mg_iface_vtable mg_lwip_iface_vtable;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "14355:   }",
          "14359: #if MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL",
          "14361: #endif",
          "",
          "[Removed Lines]",
          "14358: struct mg_iface_vtable mg_lwip_iface_vtable = MG_LWIP_IFACE_VTABLE;",
          "14360: struct mg_iface_vtable mg_default_iface_vtable = MG_LWIP_IFACE_VTABLE;",
          "",
          "[Added Lines]",
          "14358: const struct mg_iface_vtable mg_lwip_iface_vtable = MG_LWIP_IFACE_VTABLE;",
          "14360: const struct mg_iface_vtable mg_default_iface_vtable = MG_LWIP_IFACE_VTABLE;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "14902: #define MG_ENABLE_NET_IF_PIC32 MG_NET_IF == MG_NET_IF_PIC32",
          "14903: #endif",
          "14907: #ifdef __cplusplus",
          "14908: }",
          "",
          "[Removed Lines]",
          "14905: extern struct mg_iface_vtable mg_pic32_iface_vtable;",
          "",
          "[Added Lines]",
          "14905: extern const struct mg_iface_vtable mg_pic32_iface_vtable;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "15201:   }",
          "15205: #if MG_NET_IF == MG_NET_IF_PIC32",
          "15207: #endif",
          "",
          "[Removed Lines]",
          "15204: struct mg_iface_vtable mg_pic32_iface_vtable = MG_PIC32_IFACE_VTABLE;",
          "15206: struct mg_iface_vtable mg_default_iface_vtable = MG_PIC32_IFACE_VTABLE;",
          "",
          "[Added Lines]",
          "15204: const struct mg_iface_vtable mg_pic32_iface_vtable = MG_PIC32_IFACE_VTABLE;",
          "15206: const struct mg_iface_vtable mg_default_iface_vtable = MG_PIC32_IFACE_VTABLE;",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3002: struct mg_iface {",
          "3003:   struct mg_mgr *mgr;",
          "3006: };",
          "3008: struct mg_iface_vtable {",
          "",
          "[Removed Lines]",
          "3005:   struct mg_iface_vtable *vtable;",
          "",
          "[Added Lines]",
          "3005:   const struct mg_iface_vtable *vtable;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3041:                         union socket_address *sa);",
          "3042: };",
          "3045: extern int mg_num_ifaces;",
          "3049:                                     struct mg_mgr *mgr);",
          "",
          "[Removed Lines]",
          "3044: extern struct mg_iface_vtable *mg_ifaces[];",
          "3048: struct mg_iface *mg_if_create_iface(struct mg_iface_vtable *vtable,",
          "",
          "[Added Lines]",
          "3044: extern const struct mg_iface_vtable *mg_ifaces[];",
          "3048: struct mg_iface *mg_if_create_iface(const struct mg_iface_vtable *vtable,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3055: struct mg_iface *mg_find_iface(struct mg_mgr *mgr,",
          "3057:                                struct mg_iface *from);",
          "",
          "[Removed Lines]",
          "3056:                                struct mg_iface_vtable *vtable,",
          "",
          "[Added Lines]",
          "3056:                                const struct mg_iface_vtable *vtable,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3350: struct mg_mgr_init_opts {",
          "3352:   int num_ifaces;",
          "3354: };",
          "",
          "[Removed Lines]",
          "3351:   struct mg_iface_vtable *main_iface;",
          "3353:   struct mg_iface_vtable **ifaces;",
          "",
          "[Added Lines]",
          "3351:   const struct mg_iface_vtable *main_iface;",
          "3353:   const struct mg_iface_vtable **ifaces;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4c37e4927480fdf8f0ff024a98314387711d5203",
      "candidate_info": {
        "commit_hash": "4c37e4927480fdf8f0ff024a98314387711d5203",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/4c37e4927480fdf8f0ff024a98314387711d5203",
        "files": [
          "mongoose.c"
        ],
        "message": "Disable insecure and deprectaed SSL protocols\n\nAlso allow disabling conmpression and forcing server cipher list.\n\nPUBLISHED_FROM=5539deec9c2382ba34597872dd7f3a5abc0cc311",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4198:     return MG_SSL_ERROR;",
          "4199:   }",
          "4201:   if (params->cert != NULL &&",
          "4202:       mg_use_cert(ctx->ssl_ctx, params->cert, params->key, err_msg) !=",
          "4203:           MG_SSL_OK) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4201: #ifndef KR_VERSION",
          "4203:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_SSLv2);",
          "4204:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_SSLv3);",
          "4205:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1);",
          "4206: #ifdef MG_SSL_OPENSSL_NO_COMPRESSION",
          "4207:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);",
          "4208: #endif",
          "4209: #ifdef MG_SSL_OPENSSL_CIPHER_SERVER_PREFERENCE",
          "4210:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);",
          "4211: #endif",
          "4212: #else",
          "4214: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6f140202ade8a3735f8bdc15f45f7af0aa0caf76",
      "candidate_info": {
        "commit_hash": "6f140202ade8a3735f8bdc15f45f7af0aa0caf76",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/6f140202ade8a3735f8bdc15f45f7af0aa0caf76",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix LWIP net_if when RTOS is used; use for ESP32\n\nAll calls to core LWIP APIs should go through the tcpip thread.\n\nPUBLISHED_FROM=ebe8c7f043394a75a46810f2b6626582c63b9e68",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14054: #include <lwip/pbuf.h>",
          "14055: #include <lwip/tcp.h>",
          "14057: #include <lwip/tcp_impl.h>",
          "14058: #endif",
          "14059: #include <lwip/udp.h>",
          "",
          "[Removed Lines]",
          "14056: #if CS_PLATFORM != CS_P_STM32",
          "",
          "[Added Lines]",
          "14054: #include <lwip/init.h>",
          "14057: #include <lwip/tcpip.h>",
          "14058: #if LWIP_VERSION >= 0x01050000",
          "14060: #else",
          "14071: #ifndef ip_2_ip4",
          "14072: #ifdef ipX_2_ip",
          "14073: #define ip_2_ip4(addr) ipX_2_ip(addr)",
          "14074: #else",
          "14075: #define ip_2_ip4(addr) (addr)",
          "14076: #endif",
          "14077: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14077: #define TCP_BIND tcp_bind",
          "14078: #define UDP_BIND udp_bind",
          "14079: #define IPADDR_NTOA ipaddr_ntoa",
          "14081: #endif",
          "14090: #endif",
          "14092: void mg_lwip_ssl_do_hs(struct mg_connection *nc);",
          "",
          "[Removed Lines]",
          "14080: #define SET_ADDR(dst, src) (dst)->sin.sin_addr.s_addr = GET_IPV4(src)",
          "14086: #if !defined(LWIP_IPV6) || !LWIP_IPV6",
          "14087: #define GET_IPV4(ipX_addr) ((ipX_addr)->addr)",
          "14088: #else",
          "14089: #define GET_IPV4(ipX_addr) ((ipX_addr)->ip4.addr)",
          "",
          "[Added Lines]",
          "14096: #define SET_ADDR(dst, src) (dst)->sin.sin_addr.s_addr = ip_2_ip4(src)->addr",
          "14099: #if NO_SYS",
          "14100: #define tcpip_callback(fn, arg) (fn)(arg)",
          "14101: typedef void (*tcpip_callback_fn)(void *arg);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "14256:   return ERR_OK;",
          "14257: }",
          "14261:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14262:   struct tcp_pcb *tpcb = TCP_NEW();",
          "14263:   cs->pcb.tcp = tpcb;",
          "",
          "[Removed Lines]",
          "14259: void mg_lwip_if_connect_tcp(struct mg_connection *nc,",
          "14260:                             const union socket_address *sa) {",
          "",
          "[Added Lines]",
          "14271: struct mg_lwip_if_connect_tcp_ctx {",
          "14272:   struct mg_connection *nc;",
          "14273:   const union socket_address *sa;",
          "14274: };",
          "14276: static void mg_lwip_if_connect_tcp_tcpip(void *arg) {",
          "14277:   struct mg_lwip_if_connect_tcp_ctx *ctx =",
          "14278:       (struct mg_lwip_if_connect_tcp_ctx *) arg;",
          "14279:   struct mg_connection *nc = ctx->nc;",
          "14280:   const union socket_address *sa = ctx->sa;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "14281:   }",
          "14282: }",
          "14290: static void mg_lwip_udp_recv_cb(void *arg, struct udp_pcb *pcb, struct pbuf *p,",
          "14291:                                 const ip_addr_t *addr, u16_t port)",
          "14292: #else",
          "",
          "[Removed Lines]",
          "14288: #if CS_PLATFORM == CS_P_NRF51 || CS_PLATFORM == CS_P_NRF52 || \\",
          "14289:     CS_PLATFORM == CS_P_STM32",
          "",
          "[Added Lines]",
          "14305: void mg_lwip_if_connect_tcp(struct mg_connection *nc,",
          "14306:                             const union socket_address *sa) {",
          "14307:   struct mg_lwip_if_connect_tcp_ctx ctx = {.nc = nc, .sa = sa};",
          "14308:   tcpip_callback(mg_lwip_if_connect_tcp_tcpip, &ctx);",
          "14309: }",
          "14315: #if LWIP_VERSION >= 0x01050000",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "14304:     return;",
          "14305:   }",
          "14306:   union socket_address *sa = (union socket_address *) sap->payload;",
          "14307:   sa->sin.sin_addr.s_addr = addr->addr;",
          "14308:   sa->sin.sin_port = htons(port);",
          "14310:   p = pbuf_coalesce(p, PBUF_RAW);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14333: #if LWIP_VERSION >= 0x01050000",
          "14334:   sa->sin.sin_addr.s_addr = ip_2_ip4(addr)->addr;",
          "14335: #else",
          "14337: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "14353:   }",
          "14354: }",
          "14357:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14358:   struct udp_pcb *upcb = udp_new();",
          "14359:   cs->err = UDP_BIND(upcb, IP_ADDR_ANY, 0 /* any port */);",
          "",
          "[Removed Lines]",
          "14356: void mg_lwip_if_connect_udp(struct mg_connection *nc) {",
          "",
          "[Added Lines]",
          "14386: static void mg_lwip_if_connect_udp_tcpip(void *arg) {",
          "14387:   struct mg_connection *nc = (struct mg_connection *) arg;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "14367:   mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);",
          "14368: }",
          "14370: void mg_lwip_accept_conn(struct mg_connection *nc, struct tcp_pcb *tpcb) {",
          "14371:   union socket_address sa;",
          "14372:   SET_ADDR(&sa, &tpcb->remote_ip);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14401: void mg_lwip_if_connect_udp(struct mg_connection *nc) {",
          "14402:   tcpip_callback(mg_lwip_if_connect_udp_tcpip, nc);",
          "14403: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "14374:   mg_if_accept_tcp_cb(nc, &sa, sizeof(sa.sin));",
          "14375: }",
          "14377: void mg_lwip_handle_accept(struct mg_connection *nc) {",
          "14378:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14379: #if MG_ENABLE_SSL",
          "14380:   if (cs->lc->flags & MG_F_SSL) {",
          "14381:     if (mg_ssl_if_conn_accept(nc, cs->lc) != MG_SSL_OK) {",
          "14382:       LOG(LL_ERROR, (\"SSL error\"));",
          "14384:     }",
          "14385:   } else",
          "14386: #endif",
          "",
          "[Removed Lines]",
          "14383:       tcp_close(cs->pcb.tcp);",
          "",
          "[Added Lines]",
          "14412: static void tcp_close_tcpip(void *arg) {",
          "14413:   tcp_close((struct tcp_pcb *) arg);",
          "14414: }",
          "14422:       tcpip_callback(tcp_close_tcpip, cs->pcb.tcp);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "14415:   return ERR_OK;",
          "14416: }",
          "14419:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14420:   struct tcp_pcb *tpcb = TCP_NEW();",
          "14421:   ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;",
          "",
          "[Removed Lines]",
          "14418: int mg_lwip_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {",
          "",
          "[Added Lines]",
          "14457: struct mg_lwip_if_listen_ctx {",
          "14458:   struct mg_connection *nc;",
          "14459:   union socket_address *sa;",
          "14460:   int ret;",
          "14461: };",
          "14463: static void mg_lwip_if_listen_tcp_tcpip(void *arg) {",
          "14464:   struct mg_lwip_if_listen_ctx *ctx = (struct mg_lwip_if_listen_ctx *) arg;",
          "14465:   struct mg_connection *nc = ctx->nc;",
          "14466:   union socket_address *sa = ctx->sa;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "14424:   DBG((\"%p tcp_bind(%s:%u) = %d\", nc, IPADDR_NTOA(ip), port, cs->err));",
          "14425:   if (cs->err != ERR_OK) {",
          "14426:     tcp_close(tpcb);",
          "14428:   }",
          "14429:   tcp_arg(tpcb, nc);",
          "14430:   tpcb = tcp_listen(tpcb);",
          "14431:   cs->pcb.tcp = tpcb;",
          "14432:   tcp_accept(tpcb, mg_lwip_accept_cb);",
          "14434: }",
          "14437:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14438:   struct udp_pcb *upcb = udp_new();",
          "14439:   ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;",
          "",
          "[Removed Lines]",
          "14427:     return -1;",
          "14433:   return 0;",
          "14436: int mg_lwip_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {",
          "",
          "[Added Lines]",
          "14475:     ctx->ret = -1;",
          "14476:     return;",
          "14482:   ctx->ret = 0;",
          "14485: int mg_lwip_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {",
          "14486:   struct mg_lwip_if_listen_ctx ctx = {.nc = nc, .sa = sa};",
          "14487:   tcpip_callback(mg_lwip_if_listen_tcp_tcpip, &ctx);",
          "14488:   return ctx.ret;",
          "14489: }",
          "14491: static void mg_lwip_if_listen_udp_tcpip(void *arg) {",
          "14492:   struct mg_lwip_if_listen_ctx *ctx = (struct mg_lwip_if_listen_ctx *) arg;",
          "14493:   struct mg_connection *nc = ctx->nc;",
          "14494:   union socket_address *sa = ctx->sa;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "14442:   DBG((\"%p udb_bind(%s:%u) = %d\", nc, IPADDR_NTOA(ip), port, cs->err));",
          "14443:   if (cs->err != ERR_OK) {",
          "14444:     udp_remove(upcb);",
          "14446:   }",
          "14450: }",
          "14454:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14455:   struct tcp_pcb *tpcb = cs->pcb.tcp;",
          "14458:   if (len == 0) {",
          "14459:     DBG((\"%p no buf avail %u %u %u %p %p\", tpcb, tpcb->acked, tpcb->snd_buf,",
          "14460:          tpcb->snd_queuelen, tpcb->unsent, tpcb->unacked));",
          "14463:   }",
          "",
          "[Removed Lines]",
          "14445:     return -1;",
          "14447:   udp_recv(upcb, mg_lwip_udp_recv_cb, nc);",
          "14448:   cs->pcb.udp = upcb;",
          "14449:   return 0;",
          "14452: int mg_lwip_tcp_write(struct mg_connection *nc, const void *data,",
          "14453:                       uint16_t len) {",
          "14456:   if (tpcb == NULL) return -1;",
          "14457:   len = MIN(tpcb->mss, MIN(len, tpcb->snd_buf));",
          "14461:     tcp_output(tpcb);",
          "14462:     return 0;",
          "",
          "[Added Lines]",
          "14503:     ctx->ret = -1;",
          "14504:   } else {",
          "14505:     udp_recv(upcb, mg_lwip_udp_recv_cb, nc);",
          "14506:     cs->pcb.udp = upcb;",
          "14507:     ctx->ret = 0;",
          "14511: int mg_lwip_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {",
          "14512:   struct mg_lwip_if_listen_ctx ctx = {.nc = nc, .sa = sa};",
          "14513:   tcpip_callback(mg_lwip_if_listen_udp_tcpip, &ctx);",
          "14514:   return ctx.ret;",
          "14515: }",
          "14517: struct mg_lwip_tcp_write_ctx {",
          "14518:   struct mg_connection *nc;",
          "14519:   const void *data;",
          "14520:   uint16_t len;",
          "14521:   int ret;",
          "14522: };",
          "14524: static void tcp_output_tcpip(void *arg) {",
          "14525:   tcp_output((struct tcp_pcb *) arg);",
          "14526: }",
          "14528: static void mg_lwip_tcp_write_tcpip(void *arg) {",
          "14529:   struct mg_lwip_tcp_write_ctx *ctx = (struct mg_lwip_tcp_write_ctx *) arg;",
          "14530:   struct mg_connection *nc = ctx->nc;",
          "14533:   uint16_t len = MIN(tpcb->mss, MIN(ctx->len, tpcb->snd_buf));",
          "14537:     tcpip_callback(tcp_output_tcpip, tpcb);",
          "14538:     ctx->ret = 0;",
          "14539:     return;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "14470: #if CS_PLATFORM == CS_P_ESP8266",
          "14471:   if (tpcb->unacked != NULL) {",
          "14473:   }",
          "14474:   if (tpcb->unsent != NULL) {",
          "14475:     len = MIN(len, (TCP_MSS - tpcb->unsent->len));",
          "14476:   }",
          "14477: #endif",
          "14479:   DBG((\"%p tcp_write %u = %d\", tpcb, len, cs->err));",
          "14480:   if (cs->err != ERR_OK) {",
          "14486:   }",
          "14488: }",
          "14490: static int mg_lwip_udp_send(struct mg_connection *nc, const void *data,",
          "",
          "[Removed Lines]",
          "14472:     return 0;",
          "14478:   cs->err = tcp_write(tpcb, data, len, TCP_WRITE_FLAG_COPY);",
          "14485:     return (cs->err == ERR_MEM ? 0 : -1);",
          "14487:   return len;",
          "",
          "[Added Lines]",
          "14549:     ctx->ret = 0;",
          "14550:     return;",
          "14556:   cs->err = tcp_write(tpcb, ctx->data, len, TCP_WRITE_FLAG_COPY);",
          "14563:     ctx->ret = (cs->err == ERR_MEM ? 0 : -1);",
          "14564:     return;",
          "14566:   ctx->ret = len;",
          "14567: }",
          "14569: static int mg_lwip_tcp_write(struct mg_connection *nc, const void *data,",
          "14570:                              uint16_t len) {",
          "14571:   struct mg_lwip_tcp_write_ctx ctx = {.nc = nc, .data = data, .len = len};",
          "14572:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14573:   struct tcp_pcb *tpcb = cs->pcb.tcp;",
          "14574:   if (tpcb == NULL) {",
          "14575:     return -1;",
          "14576:   }",
          "14577:   tcpip_callback(mg_lwip_tcp_write_tcpip, &ctx);",
          "14578:   return ctx.ret;",
          "14579: }",
          "14581: struct udp_sendto_ctx {",
          "14582:   struct udp_pcb *upcb;",
          "14583:   struct pbuf *p;",
          "14584:   ip_addr_t *ip;",
          "14585:   uint16_t port;",
          "14586:   int ret;",
          "14587: };",
          "14589: static void udp_sendto_tcpip(void *arg) {",
          "14590:   struct udp_sendto_ctx *ctx = (struct udp_sendto_ctx *) arg;",
          "14591:   ctx->ret = udp_sendto(ctx->upcb, ctx->p, ctx->ip, ctx->port);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "14508:     return 0;",
          "14509:   }",
          "14510:   memcpy(p->payload, data, len);",
          "14512:   DBG((\"%p udp_sendto = %d\", nc, cs->err));",
          "14513:   pbuf_free(p);",
          "14514:   return (cs->err == ERR_OK ? len : -1);",
          "",
          "[Removed Lines]",
          "14511:   cs->err = udp_sendto(upcb, p, (ip_addr_t *) ip, port);",
          "",
          "[Added Lines]",
          "14615:   struct udp_sendto_ctx ctx = {.upcb = upcb, .p = p, .ip = ip, .port = port};",
          "14616:   tcpip_callback(udp_sendto_tcpip, &ctx);",
          "14617:   cs->err = ctx.ret;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "14544:   mg_lwip_mgr_schedule_poll(nc->mgr);",
          "14545: }",
          "14547: void mg_lwip_if_recved(struct mg_connection *nc, size_t len) {",
          "14548:   if (nc->flags & MG_F_UDP) return;",
          "14549:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14653: struct tcp_recved_ctx {",
          "14654:   struct tcp_pcb *tpcb;",
          "14655:   size_t len;",
          "14656: };",
          "14658: void tcp_recved_tcpip(void *arg) {",
          "14659:   struct tcp_recved_ctx *ctx = (struct tcp_recved_ctx *) arg;",
          "14660:   tcp_recved(ctx->tpcb, ctx->len);",
          "14661: }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "14552:     return;",
          "14553:   }",
          "14554:   DBG((\"%p %p %u\", nc, cs->pcb.tcp, len));",
          "14557: #if MG_ENABLE_SSL",
          "14558:   if (!(nc->flags & MG_F_SSL)) {",
          "14560:   }",
          "14561: #else",
          "14563: #endif",
          "14564:   mbuf_trim(&nc->recv_mbuf);",
          "14565: }",
          "",
          "[Removed Lines]",
          "14559:     tcp_recved(cs->pcb.tcp, len);",
          "14562:   tcp_recved(cs->pcb.tcp, len);",
          "",
          "[Added Lines]",
          "14671:   struct tcp_recved_ctx ctx = {.tpcb = cs->pcb.tcp, .len = len};",
          "14674:     tcpip_callback(tcp_recved_tcpip, &ctx);",
          "14675:   } else {",
          "14680:   tcpip_callback(tcp_recved_tcpip, &ctx);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "14573:   return 1;",
          "14574: }",
          "14576: void mg_lwip_if_destroy_conn(struct mg_connection *nc) {",
          "14577:   if (nc->sock == INVALID_SOCKET) return;",
          "14578:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14694: static void udp_remove_tcpip(void *arg) {",
          "14695:   udp_remove((struct udp_pcb *) arg);",
          "14696: }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "14582:       tcp_arg(tpcb, NULL);",
          "14583:       DBG((\"%p tcp_close %p\", nc, tpcb));",
          "14584:       tcp_arg(tpcb, NULL);",
          "14586:     }",
          "14587:     while (cs->rx_chain != NULL) {",
          "14588:       struct pbuf *seg = cs->rx_chain;",
          "",
          "[Removed Lines]",
          "14585:       tcp_close(tpcb);",
          "",
          "[Added Lines]",
          "14707:       tcpip_callback(tcp_close_tcpip, tpcb);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "14596:     struct udp_pcb *upcb = cs->pcb.udp;",
          "14597:     if (upcb != NULL) {",
          "14598:       DBG((\"%p udp_remove %p\", nc, upcb));",
          "14600:     }",
          "14601:     memset(cs, 0, sizeof(*cs));",
          "14602:     MG_FREE(cs);",
          "",
          "[Removed Lines]",
          "14599:       udp_remove(upcb);",
          "",
          "[Added Lines]",
          "14721:       tcpip_callback(udp_remove_tcpip, upcb);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "14830:     if (nc->sock != INVALID_SOCKET &&",
          "14831:         !(nc->flags & (MG_F_UDP | MG_F_LISTENING)) && cs->pcb.tcp != NULL &&",
          "14832:         cs->pcb.tcp->unsent != NULL) {",
          "14834:     }",
          "14835:     if (nc->ev_timer_time > 0) {",
          "14836:       if (num_timers == 0 || nc->ev_timer_time < min_timer) {",
          "",
          "[Removed Lines]",
          "14833:       tcp_output(cs->pcb.tcp);",
          "",
          "[Added Lines]",
          "14955:       tcpip_callback(tcp_output_tcpip, cs->pcb.tcp);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9d30e892e944bc665725faad34d8a18f2e9bf674",
      "candidate_info": {
        "commit_hash": "9d30e892e944bc665725faad34d8a18f2e9bf674",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/9d30e892e944bc665725faad34d8a18f2e9bf674",
        "files": [
          "mongoose.h"
        ],
        "message": "Mongoose 6.8\n\nPUBLISHED_FROM=082d0bf5e9b06b850382ce502c7f5b4d68a6a328",
        "before_after_code_files": [
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #ifndef CS_MONGOOSE_SRC_COMMON_H_",
          "24: #define CS_MONGOOSE_SRC_COMMON_H_",
          "29: #ifdef MG_LOCALS",
          "",
          "[Removed Lines]",
          "26: #define MG_VERSION \"6.7\"",
          "",
          "[Added Lines]",
          "26: #define MG_VERSION \"6.8\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e4309d472b0679405e2da8ef3600c1b8d69ea95b",
      "candidate_info": {
        "commit_hash": "e4309d472b0679405e2da8ef3600c1b8d69ea95b",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/e4309d472b0679405e2da8ef3600c1b8d69ea95b",
        "files": [
          "examples/CC3200/Makefile.build",
          "mongoose.c"
        ],
        "message": "Annotate cs_log_printf with format attribute\n\nThis adds compile-time checks for format strings.\n\nFix issues exposed by this.\n\nPUBLISHED_FROM=b9f820d8ad44fce9186dfdad4fe109fafa5371ce",
        "before_after_code_files": [
          "examples/CC3200/Makefile.build||examples/CC3200/Makefile.build",
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "examples/CC3200/Makefile.build||examples/CC3200/Makefile.build": [
          "File: examples/CC3200/Makefile.build -> examples/CC3200/Makefile.build",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: VPATH = ../..",
          "27: SDK_FLAGS = -DUSE_FREERTOS -DSL_PLATFORM_MULTI_THREADED",
          "28: # -DTARGET_IS_CC3200 would reduce code size by using functions in ROM",
          "",
          "[Removed Lines]",
          "25: MONGOOSE_FEATURES = -DMG_ENABLE_SSL -DMG_ENABLE_HTTP_STREAMING_MULTIPART",
          "",
          "[Added Lines]",
          "25: MONGOOSE_FEATURES = -DMG_ENABLE_SSL -DMG_ENABLE_HTTP_STREAMING_MULTIPART -DMG_MODULE_LINES",
          "",
          "---------------"
        ],
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "230: void cs_log_set_file(FILE *file);",
          "231: extern enum cs_log_level cs_log_threshold;",
          "232: void cs_log_print_prefix(enum cs_log_level level, const char *func);",
          "235: #define LOG(l, x)                       \\",
          "236:   do {                                  \\",
          "",
          "[Removed Lines]",
          "233: void cs_log_printf(const char *fmt, ...);",
          "",
          "[Added Lines]",
          "233: void cs_log_printf(const char *fmt, ...)",
          "234: #ifdef __GNUC__",
          "235:     __attribute__((format(printf, 1, 2)))",
          "236: #endif",
          "237:     ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2918:     }",
          "2919:   }",
          "2922:   return allowed == '+';",
          "2923: }",
          "",
          "[Removed Lines]",
          "2921:   DBG((\"%08x %c\", remote_ip, allowed));",
          "",
          "[Added Lines]",
          "2925:   DBG((\"%08x %c\", (unsigned int) remote_ip, allowed));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2940:        (unsigned long) timestamp));",
          "2941:   if ((c->flags & MG_F_RESOLVING) && c->priv_2 != NULL) {",
          "2942:     ((struct mg_connection *) c->priv_2)->ev_timer_time = timestamp;",
          "",
          "[Removed Lines]",
          "2939:   DBG((\"%p %p %d -> %lu\", c, c->priv_2, c->flags & MG_F_RESOLVING,",
          "",
          "[Added Lines]",
          "2943:   DBG((\"%p %p %d -> %lu\", c, c->priv_2, (c->flags & MG_F_RESOLVING ? 1 : 0),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3883: #if MG_ENABLE_HEXDUMP",
          "3884:   char hex[512];",
          "3885:   mg_hexdump(buf, len, hex, sizeof(hex));",
          "3887: #endif",
          "3889:   mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME, 0, msg);",
          "",
          "[Removed Lines]",
          "3886:   LOG(LL_DEBUG, (\"sending to stream %zu:\\n%s\", stream_id, hex));",
          "",
          "[Added Lines]",
          "3890:   LOG(LL_DEBUG, (\"sending to stream 0x%x:\\n%s\", (unsigned int) stream_id, hex));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3914:     uint32_t stream_id = (uint32_t)(uintptr_t) nc->mgr_data;",
          "3915:     struct mg_str msg = {NULL, 0};",
          "3918:     mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME,",
          "3919:                       MG_TUN_F_END_STREAM, msg);",
          "3920:   }",
          "",
          "[Removed Lines]",
          "3917:     LOG(LL_DEBUG, (\"closing %zu:\", stream_id));",
          "",
          "[Added Lines]",
          "3921:     LOG(LL_DEBUG, (\"closing 0x%x:\", (unsigned int) stream_id));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3971:   if (stream_id > client->last_stream_id) {",
          "3974:     nc = mg_if_accept_new_conn(client->listener);",
          "3975:     nc->mgr_data = (void *) (uintptr_t) stream_id;",
          "3976:     client->last_stream_id = stream_id;",
          "3977:   } else {",
          "3980:   }",
          "3982:   return nc;",
          "",
          "[Removed Lines]",
          "3973:     LOG(LL_DEBUG, (\"new stream 0x%lx, accepting\", stream_id));",
          "3978:     LOG(LL_DEBUG, (\"Ignoring stream 0x%lx (last_stream_id 0x%lx)\", stream_id,",
          "3979:                    client->last_stream_id));",
          "",
          "[Added Lines]",
          "3977:     LOG(LL_DEBUG, (\"new stream 0x%x, accepting\", (unsigned int) stream_id));",
          "3982:     LOG(LL_DEBUG,",
          "3983:         (\"Ignoring stream 0x%x (last_stream_id 0x%x)\", (unsigned int) stream_id,",
          "3984:          (unsigned int) client->last_stream_id));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "9897:       LOG(LL_DEBUG,",
          "9898:           (\"%d %2x %d proto [%.*s] client_id [%.*s] will_topic [%.*s] \"",
          "9899:            \"will_msg [%.*s] user_name [%.*s] password [%.*s]\",",
          "9901:            (int) mm->protocol_name.len, mm->protocol_name.p,",
          "9902:            (int) mm->client_id.len, mm->client_id.p, (int) mm->will_topic.len,",
          "9903:            mm->will_topic.p, (int) mm->will_message.len, mm->will_message.p,",
          "",
          "[Removed Lines]",
          "9900:            len, (int) mm->connect_flags, (int) mm->keep_alive_timer,",
          "",
          "[Added Lines]",
          "9905:            (int) len, (int) mm->connect_flags, (int) mm->keep_alive_timer,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "11771: }",
          "11773: void mg_tun_log_frame(struct mg_tun_frame *frame) {",
          "11777: #if MG_ENABLE_HEXDUMP",
          "11778:   {",
          "11779:     char hex[512];",
          "",
          "[Removed Lines]",
          "11774:   LOG(LL_DEBUG, (\"Got TUN frame: type=0x%x, flags=0x%x stream_id=0x%lx, \"",
          "11775:                  \"len=%zu\",",
          "11776:                  frame->type, frame->flags, frame->stream_id, frame->body.len));",
          "",
          "[Added Lines]",
          "11779:   LOG(LL_DEBUG, (\"Got TUN frame: type=0x%x, flags=0x%x stream_id=0x%x, \"",
          "11780:                  \"len=%d\",",
          "11781:                  frame->type, frame->flags, (unsigned int) frame->stream_id,",
          "11782:                  (int) frame->body.len));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "11836:       struct mg_tun_frame frame;",
          "11838:       if (mg_tun_parse_frame(wm->data, wm->size, &frame) == -1) {",
          "11840:         break;",
          "11841:       }",
          "",
          "[Removed Lines]",
          "11839:         LOG(LL_ERROR, (\"Got invalid tun frame dropping\", wm->size));",
          "",
          "[Added Lines]",
          "11845:         LOG(LL_ERROR, (\"Got invalid tun frame dropping\"));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "14279: static err_t mg_lwip_tcp_sent_cb(void *arg, struct tcp_pcb *tpcb,",
          "14280:                                  u16_t num_sent) {",
          "14281:   struct mg_connection *nc = (struct mg_connection *) arg;",
          "14283:   if (nc == NULL) return ERR_OK;",
          "14284:   if ((nc->flags & MG_F_SEND_AND_CLOSE) && !(nc->flags & MG_F_WANT_WRITE) &&",
          "14286:     mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);",
          "14287:   }",
          "14288:   return ERR_OK;",
          "",
          "[Removed Lines]",
          "14282:   DBG((\"%p %p %u %u %u\", nc, tpcb, num_sent, tpcb->unsent, tpcb->unacked));",
          "14285:       nc->send_mbuf.len == 0 && tpcb->unsent == 0 && tpcb->unacked == 0) {",
          "",
          "[Added Lines]",
          "14288:   DBG((\"%p %p %u %p %p\", nc, tpcb, num_sent, tpcb->unsent, tpcb->unacked));",
          "14291:       nc->send_mbuf.len == 0 && tpcb->unsent == NULL && tpcb->unacked == NULL) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "14897: }",
          "14899: void mg_lwip_if_init(struct mg_iface *iface) {",
          "14901:   iface->data = MG_CALLOC(1, sizeof(struct mg_ev_mgr_lwip_data));",
          "14902: }",
          "",
          "[Removed Lines]",
          "14900:   LOG(LL_INFO, (\"%p Mongoose init\"));",
          "",
          "[Added Lines]",
          "14906:   LOG(LL_INFO, (\"%p Mongoose init\", iface));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "15076:   enum mg_ssl_if_result res;",
          "15077:   if (nc->flags & MG_F_CLOSE_IMMEDIATELY) return;",
          "15078:   res = mg_ssl_if_handshake(nc);",
          "15080:   if (res != MG_SSL_OK) {",
          "15081:     if (res == MG_SSL_WANT_WRITE) {",
          "15082:       nc->flags |= MG_F_WANT_WRITE;",
          "",
          "[Removed Lines]",
          "15079:   DBG((\"%p %d %d %d\", nc, nc->flags, server_side, res));",
          "",
          "[Added Lines]",
          "15085:   DBG((\"%p %lu %d %d\", nc, nc->flags, server_side, res));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8026",
  "cve_desc": "Heap-based buffer overflow in the verify_vbr_checksum function in exfatfsck in exfat-utils before 1.2.1 allows remote attackers to cause a denial of service (infinite loop) or possibly execute arbitrary code via a crafted filesystem.",
  "repo": "relan/exfat",
  "patch_hash": "2e86ae5f81da11f11673d0546efb525af02b7786",
  "patch_info": {
    "commit_hash": "2e86ae5f81da11f11673d0546efb525af02b7786",
    "repo": "relan/exfat",
    "commit_url": "https://github.com/relan/exfat/commit/2e86ae5f81da11f11673d0546efb525af02b7786",
    "files": [
      "libexfat/mount.c"
    ],
    "message": "Check sector and cluster size before use.\n\nOtherwise malformed FS can cause heap corruption.",
    "before_after_code_files": [
      "libexfat/mount.c||libexfat/mount.c"
    ]
  },
  "patch_diff": {
    "libexfat/mount.c||libexfat/mount.c": [
      "File: libexfat/mount.c -> libexfat/mount.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "206:   exfat_error(\"exFAT file system is not found\");",
      "207:   return -EIO;",
      "208:  }",
      "209:  ef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));",
      "210:  if (ef->zero_cluster == NULL)",
      "211:  {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "210:  if (ef->sb->sector_bits < 9)",
      "211:  {",
      "212:   exfat_close(ef->dev);",
      "213:   exfat_error(\"too small sector size: 2^%hhd\", ef->sb->sector_bits);",
      "214:   free(ef->sb);",
      "215:   return -EIO;",
      "216:  }",
      "218:  if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)",
      "219:  {",
      "220:   exfat_close(ef->dev);",
      "221:   exfat_error(\"too big cluster size: 2^(%hhd+%hhd)\",",
      "222:     ef->sb->sector_bits, ef->sb->spc_bits);",
      "223:   free(ef->sb);",
      "224:   return -EIO;",
      "225:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "240:   free(ef->sb);",
      "241:   return -EIO;",
      "242:  }",
      "253:  if (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >",
      "254:    exfat_get_size(ef->dev))",
      "255:  {",
      "",
      "[Removed Lines]",
      "244:  if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)",
      "245:  {",
      "246:   free(ef->zero_cluster);",
      "247:   exfat_close(ef->dev);",
      "248:   exfat_error(\"too big cluster size: 2^%d\",",
      "249:     (int) ef->sb->sector_bits + (int) ef->sb->spc_bits);",
      "250:   free(ef->sb);",
      "251:   return -EIO;",
      "252:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "38d5c3a929124fd123675ac576401b7de3570b2f",
      "candidate_info": {
        "commit_hash": "38d5c3a929124fd123675ac576401b7de3570b2f",
        "repo": "relan/exfat",
        "commit_url": "https://github.com/relan/exfat/commit/38d5c3a929124fd123675ac576401b7de3570b2f",
        "files": [
          "libexfat/mount.c"
        ],
        "message": "Check sector and cluster size before use.\n\nOtherwise malformed FS can cause heap corruption.",
        "before_after_code_files": [
          "libexfat/mount.c||libexfat/mount.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libexfat/mount.c||libexfat/mount.c"
          ],
          "candidate": [
            "libexfat/mount.c||libexfat/mount.c"
          ]
        }
      },
      "candidate_diff": {
        "libexfat/mount.c||libexfat/mount.c": [
          "File: libexfat/mount.c -> libexfat/mount.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "206:   exfat_error(\"exFAT file system is not found\");",
          "207:   return -EIO;",
          "208:  }",
          "209:  ef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));",
          "210:  if (ef->zero_cluster == NULL)",
          "211:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "210:  if (ef->sb->sector_bits < 9)",
          "211:  {",
          "212:   exfat_close(ef->dev);",
          "213:   exfat_error(\"too small sector size: 2^%hhd\", ef->sb->sector_bits);",
          "214:   free(ef->sb);",
          "215:   return -EIO;",
          "216:  }",
          "218:  if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)",
          "219:  {",
          "220:   exfat_close(ef->dev);",
          "221:   exfat_error(\"too big cluster size: 2^(%hhd+%hhd)\",",
          "222:     ef->sb->sector_bits, ef->sb->spc_bits);",
          "223:   free(ef->sb);",
          "224:   return -EIO;",
          "225:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "240:   free(ef->sb);",
          "241:   return -EIO;",
          "242:  }",
          "253:  if (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >",
          "254:    exfat_get_size(ef->dev))",
          "255:  {",
          "",
          "[Removed Lines]",
          "244:  if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)",
          "245:  {",
          "246:   free(ef->zero_cluster);",
          "247:   exfat_close(ef->dev);",
          "248:   exfat_error(\"too big cluster size: 2^%d\",",
          "249:     (int) ef->sb->sector_bits + (int) ef->sb->spc_bits);",
          "250:   free(ef->sb);",
          "251:   return -EIO;",
          "252:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
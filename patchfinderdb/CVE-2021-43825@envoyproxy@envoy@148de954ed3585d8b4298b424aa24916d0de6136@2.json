{
  "cve_id": "CVE-2021-43825",
  "cve_desc": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Sending a locally generated response must stop further processing of request or response data. Envoy tracks the amount of buffered request and response data and aborts the request if the amount of buffered data is over the limit by sending 413 or 500 responses. However when the buffer overflows while response is processed by the filter chain the operation may not be aborted correctly and result in accessing a freed memory block. If this happens Envoy will crash resulting in a denial of service.",
  "repo": "envoyproxy/envoy",
  "patch_hash": "148de954ed3585d8b4298b424aa24916d0de6136",
  "patch_info": {
    "commit_hash": "148de954ed3585d8b4298b424aa24916d0de6136",
    "repo": "envoyproxy/envoy",
    "commit_url": "https://github.com/envoyproxy/envoy/commit/148de954ed3585d8b4298b424aa24916d0de6136",
    "files": [
      "source/common/http/conn_manager_impl.cc",
      "source/common/http/filter_manager.cc",
      "source/common/http/filter_manager.h",
      "test/integration/BUILD",
      "test/integration/filters/BUILD",
      "test/integration/filters/buffer_continue_filter.cc",
      "test/integration/protocol_integration_test.cc"
    ],
    "message": "CVE-2021-43825\n\nResponse filter manager crash\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>",
    "before_after_code_files": [
      "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc",
      "source/common/http/filter_manager.cc||source/common/http/filter_manager.cc",
      "source/common/http/filter_manager.h||source/common/http/filter_manager.h",
      "test/integration/filters/buffer_continue_filter.cc||test/integration/filters/buffer_continue_filter.cc",
      "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
    ]
  },
  "patch_diff": {
    "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc": [
      "File: source/common/http/conn_manager_impl.cc -> source/common/http/conn_manager_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "212:     ENVOY_STREAM_LOG(debug, \"doEndStream() resetting stream\", stream);",
      "",
      "[Removed Lines]",
      "208:   if (stream.response_encoder_ != nullptr &&",
      "209:       (!stream.filter_manager_.remoteComplete() || !stream.state_.codec_saw_local_complete_)) {",
      "",
      "[Added Lines]",
      "208:   if (stream.response_encoder_ != nullptr && (!stream.filter_manager_.remoteDecodeComplete() ||",
      "209:                                               !stream.state_.codec_saw_local_complete_)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "251:   bool connection_close = stream.state_.saw_connection_close_;",
      "254:   checkForDeferredClose(connection_close && (request_complete || http_10_sans_cl));",
      "255: }",
      "",
      "[Removed Lines]",
      "252:   bool request_complete = stream.filter_manager_.remoteComplete();",
      "",
      "[Added Lines]",
      "252:   bool request_complete = stream.filter_manager_.remoteDecodeComplete();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1436:     if (connection_manager_.codec_->protocol() < Protocol::Http2) {",
      "1437:       connection_manager_.drain_state_ = DrainState::Closing;",
      "1438:     }",
      "",
      "[Removed Lines]",
      "1435:   if (!filter_manager_.remoteComplete()) {",
      "",
      "[Added Lines]",
      "1435:   if (!filter_manager_.remoteDecodeComplete()) {",
      "",
      "---------------"
    ],
    "source/common/http/filter_manager.cc||source/common/http/filter_manager.cc": [
      "File: source/common/http/filter_manager.cc -> source/common/http/filter_manager.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "303:   return !parent_.state_.local_complete_;",
      "304: }",
      "306: Buffer::InstancePtr ActiveStreamDecoderFilter::createBuffer() {",
      "307:   auto buffer = dispatcher().getWatermarkFactory().createBuffer(",
      "308:       [this]() -> void { this->requestDataDrained(); },",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "306: bool ActiveStreamEncoderFilter::canContinue() {",
      "309:   return !parent_.state_.remote_encode_complete_;",
      "310: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "316:   return parent_.buffered_request_data_;",
      "317: }",
      "321: void ActiveStreamDecoderFilter::doHeaders(bool end_stream) {",
      "322:   parent_.decodeHeaders(this, *parent_.filter_manager_callbacks_.requestHeaders(), end_stream);",
      "",
      "[Removed Lines]",
      "319: bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_complete_; }",
      "",
      "[Added Lines]",
      "325: bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "832: }",
      "834: void FilterManager::maybeEndDecode(bool end_stream) {",
      "837:   if (end_stream) {",
      "838:     stream_info_.downstreamTiming().onLastDownstreamRxByteReceived(dispatcher().timeSource());",
      "839:     ENVOY_STREAM_LOG(debug, \"request end stream\", *this);",
      "",
      "[Removed Lines]",
      "835:   ASSERT(!state_.remote_complete_);",
      "836:   state_.remote_complete_ = end_stream;",
      "",
      "[Added Lines]",
      "841:   ASSERT(!state_.remote_decode_complete_);",
      "842:   state_.remote_decode_complete_ = end_stream;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1357: void FilterManager::maybeEndEncode(bool end_stream) {",
      "1358:   if (end_stream) {",
      "1359:     filter_manager_callbacks_.endStream();",
      "1360:   }",
      "1361: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1365:     ASSERT(!state_.remote_encode_complete_);",
      "1366:     state_.remote_encode_complete_ = true;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1646: }",
      "1648: void ActiveStreamEncoderFilter::responseDataTooLarge() {",
      "1649:   if (parent_.state_.encoder_filters_streaming_) {",
      "1650:     onEncoderFilterAboveWriteBufferHighWatermark();",
      "1651:   } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1657:   ENVOY_STREAM_LOG(debug, \"response data too large watermark exceeded\", parent_);",
      "",
      "---------------"
    ],
    "source/common/http/filter_manager.h||source/common/http/filter_manager.h": [
      "File: source/common/http/filter_manager.h -> source/common/http/filter_manager.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "317:       : ActiveStreamFilterBase(parent, dual_filter, std::move(match_state)), handle_(filter) {}",
      "321:   Buffer::InstancePtr createBuffer() override;",
      "322:   Buffer::InstancePtr& bufferedData() override;",
      "323:   bool complete() override;",
      "",
      "[Removed Lines]",
      "320:   bool canContinue() override { return true; }",
      "",
      "[Added Lines]",
      "320:   bool canContinue() override;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "910:   bool remoteComplete() const { return state_.remote_complete_; }",
      "",
      "[Added Lines]",
      "910:   bool remoteDecodeComplete() const { return state_.remote_decode_complete_; }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1059:   struct State {",
      "1060:     State()",
      "1067:     uint32_t filter_call_state_{0};",
      "1070:     bool local_complete_ : 1; // This indicates that local is complete prior to filter processing.",
      "",
      "[Removed Lines]",
      "1061:         : remote_complete_(false), local_complete_(false), has_1xx_headers_(false),",
      "1062:           created_filter_chain_(false), is_head_request_(false), is_grpc_request_(false),",
      "1063:           non_100_response_headers_encoded_(false), under_on_local_reply_(false),",
      "1064:           decoder_filter_chain_aborted_(false), encoder_filter_chain_aborted_(false),",
      "1065:           saw_downstream_reset_(false) {}",
      "1069:     bool remote_complete_ : 1;",
      "",
      "[Added Lines]",
      "1061:         : remote_encode_complete_(false), remote_decode_complete_(false), local_complete_(false),",
      "1062:           has_1xx_headers_(false), created_filter_chain_(false), is_head_request_(false),",
      "1063:           is_grpc_request_(false), non_100_response_headers_encoded_(false),",
      "1064:           under_on_local_reply_(false), decoder_filter_chain_aborted_(false),",
      "1065:           encoder_filter_chain_aborted_(false), saw_downstream_reset_(false) {}",
      "1068:     bool remote_encode_complete_ : 1;",
      "1069:     bool remote_decode_complete_ : 1;",
      "",
      "---------------"
    ],
    "test/integration/filters/buffer_continue_filter.cc||test/integration/filters/buffer_continue_filter.cc": [
      "File: test/integration/filters/buffer_continue_filter.cc -> test/integration/filters/buffer_continue_filter.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #include <string>",
      "3: #include \"envoy/http/filter.h\"",
      "4: #include \"envoy/registry/registry.h\"",
      "5: #include \"envoy/server/filter_config.h\"",
      "7: #include \"source/extensions/filters/http/common/pass_through_filter.h\"",
      "9: #include \"test/extensions/filters/http/common/empty_http_filter_config.h\"",
      "11: namespace Envoy {",
      "14: class BufferContinueStreamFilter : public Http::PassThroughFilter {",
      "15: public:",
      "16:   Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap&, bool end_stream) override {",
      "17:     return end_stream ? Http::FilterHeadersStatus::Continue",
      "18:                       : Http::FilterHeadersStatus::StopIteration;",
      "19:   }",
      "21:   Http::FilterDataStatus decodeData(Buffer::Instance&, bool end_stream) override {",
      "22:     return end_stream ? Http::FilterDataStatus::Continue",
      "23:                       : Http::FilterDataStatus::StopIterationAndBuffer;",
      "24:   }",
      "26:   Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap& headers, bool) override {",
      "27:     response_headers_ = &headers;",
      "28:     return Http::FilterHeadersStatus::StopIteration;",
      "29:   }",
      "31:   Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override {",
      "32:     data_total_ += data.length();",
      "34:     const auto limit = encoder_callbacks_->encoderBufferLimit();",
      "35:     const auto header_size = response_headers_->byteSize();",
      "37:     if (limit && header_size + data_total_ > limit) {",
      "40:       return Http::FilterDataStatus::Continue;",
      "41:     }",
      "43:     encoder_callbacks_->addEncodedData(data, false);",
      "45:     if (!end_stream) {",
      "46:       return Http::FilterDataStatus::StopIterationAndBuffer;",
      "47:     }",
      "49:     return Http::FilterDataStatus::Continue;",
      "50:   }",
      "52: private:",
      "53:   Http::ResponseHeaderMap* response_headers_;",
      "54:   uint64_t data_total_{0};",
      "55: };",
      "57: class BufferContinueFilterConfig : public Extensions::HttpFilters::Common::EmptyHttpFilterConfig {",
      "58: public:",
      "59:   BufferContinueFilterConfig() : EmptyHttpFilterConfig(\"buffer-continue-filter\") {}",
      "61:   Http::FilterFactoryCb createFilter(const std::string&,",
      "62:                                      Server::Configuration::FactoryContext&) override {",
      "63:     return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {",
      "64:       callbacks.addStreamFilter(std::make_shared<::Envoy::BufferContinueStreamFilter>());",
      "65:     };",
      "66:   }",
      "67: };",
      "70: static Registry::RegisterFactory<BufferContinueFilterConfig,",
      "71:                                  Server::Configuration::NamedHttpFilterConfigFactory>",
      "72:     register_;",
      "74: } // namespace Envoy",
      "",
      "---------------"
    ],
    "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc": [
      "File: test/integration/protocol_integration_test.cc -> test/integration/protocol_integration_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "3450:   EXPECT_EQ(\"200\", response->headers().getStatusValue());",
      "3451: }",
      "3453: TEST_P(DownstreamProtocolIntegrationTest, ContentLengthSmallerThanPayload) {",
      "3454:   initialize();",
      "3455:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3454: TEST_P(ProtocolIntegrationTest, BufferContinue) {",
      "3456:   if (upstreamProtocol() != Http::CodecType::HTTP2) {",
      "3457:     return;",
      "3458:   }",
      "3459:   config_helper_.addConfigModifier(",
      "3460:       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&",
      "3461:               hcm) -> void {",
      "3462:         auto* route_config = hcm.mutable_route_config();",
      "3463:         auto* virtual_host = route_config->mutable_virtual_hosts(0);",
      "3464:         auto* header = virtual_host->mutable_response_headers_to_add()->Add()->mutable_header();",
      "3465:         header->set_key(\"foo\");",
      "3466:         header->set_value(\"bar\");",
      "3467:       });",
      "3469:   useAccessLog();",
      "3470:   config_helper_.addFilter(\"{ name: buffer-continue-filter, typed_config: { \\\"@type\\\": \"",
      "3471:                            \"type.googleapis.com/google.protobuf.Empty } }\");",
      "3472:   config_helper_.setBufferLimits(1024, 1024);",
      "3473:   initialize();",
      "3476:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "3477:   auto encoder_decoder = codec_client_->startRequest(default_request_headers_);",
      "3478:   auto downstream_request = &encoder_decoder.first;",
      "3479:   auto response = std::move(encoder_decoder.second);",
      "3480:   Buffer::OwnedImpl data(\"HTTP body content goes here\");",
      "3481:   codec_client_->sendData(*downstream_request, data, true);",
      "3482:   waitForNextUpstreamRequest();",
      "3485:   upstream_request_->encodeHeaders(default_response_headers_, false);",
      "3489:   upstream_request_->encodeData(512, false);",
      "3490:   upstream_request_->encodeData(1024 * 100, false);",
      "3492:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
      "3493:     ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());",
      "3494:   } else {",
      "3495:     ASSERT_TRUE(upstream_request_->waitForReset());",
      "3496:     ASSERT_TRUE(fake_upstream_connection_->close());",
      "3497:     ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());",
      "3498:   }",
      "3500:   ASSERT_TRUE(response->waitForEndStream());",
      "3501:   EXPECT_TRUE(response->complete());",
      "3502:   EXPECT_EQ(\"500\", response->headers().getStatusValue());",
      "3503: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "45f459dd8d2020e32c9877d05508627f34decd25",
      "candidate_info": {
        "commit_hash": "45f459dd8d2020e32c9877d05508627f34decd25",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/45f459dd8d2020e32c9877d05508627f34decd25",
        "files": [
          "source/common/http/conn_manager_impl.cc",
          "source/common/http/filter_manager.cc",
          "source/common/http/filter_manager.h",
          "test/integration/BUILD",
          "test/integration/filters/BUILD",
          "test/integration/filters/buffer_continue_filter.cc",
          "test/integration/protocol_integration_test.cc"
        ],
        "message": "[1.18] CVE-2021-43825\n\nResponse filter manager crash\n\nSigned-off-by: Otto van der Schaaf <ovanders@redhat.com>",
        "before_after_code_files": [
          "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc",
          "source/common/http/filter_manager.cc||source/common/http/filter_manager.cc",
          "source/common/http/filter_manager.h||source/common/http/filter_manager.h",
          "test/integration/filters/buffer_continue_filter.cc||test/integration/filters/buffer_continue_filter.cc",
          "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc",
            "source/common/http/filter_manager.cc||source/common/http/filter_manager.cc",
            "source/common/http/filter_manager.h||source/common/http/filter_manager.h",
            "test/integration/filters/buffer_continue_filter.cc||test/integration/filters/buffer_continue_filter.cc",
            "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
          ],
          "candidate": [
            "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc",
            "source/common/http/filter_manager.cc||source/common/http/filter_manager.cc",
            "source/common/http/filter_manager.h||source/common/http/filter_manager.h",
            "test/integration/filters/buffer_continue_filter.cc||test/integration/filters/buffer_continue_filter.cc",
            "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc": [
          "File: source/common/http/conn_manager_impl.cc -> source/common/http/conn_manager_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:     ENVOY_STREAM_LOG(debug, \"doEndStream() resetting stream\", stream);",
          "",
          "[Removed Lines]",
          "187:   if (stream.response_encoder_ != nullptr &&",
          "188:       (!stream.filter_manager_.remoteComplete() || !stream.state_.codec_saw_local_complete_)) {",
          "",
          "[Added Lines]",
          "187:   if (stream.response_encoder_ != nullptr && (!stream.filter_manager_.remoteDecodeComplete() ||",
          "188:                                               !stream.state_.codec_saw_local_complete_)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1422:     if (connection_manager_.codec_->protocol() < Protocol::Http2) {",
          "1423:       connection_manager_.drain_state_ = DrainState::Closing;",
          "1424:     }",
          "",
          "[Removed Lines]",
          "1421:   if (!filter_manager_.remoteComplete()) {",
          "",
          "[Added Lines]",
          "1421:   if (!filter_manager_.remoteDecodeComplete()) {",
          "",
          "---------------"
        ],
        "source/common/http/filter_manager.cc||source/common/http/filter_manager.cc": [
          "File: source/common/http/filter_manager.cc -> source/common/http/filter_manager.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "279:   return !parent_.state_.local_complete_;",
          "280: }",
          "282: Buffer::InstancePtr ActiveStreamDecoderFilter::createBuffer() {",
          "283:   auto buffer = dispatcher().getWatermarkFactory().create(",
          "284:       [this]() -> void { this->requestDataDrained(); },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282: bool ActiveStreamEncoderFilter::canContinue() {",
          "285:   return !parent_.state_.remote_encode_complete_;",
          "286: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "292:   return parent_.buffered_request_data_;",
          "293: }",
          "297: void ActiveStreamDecoderFilter::doHeaders(bool end_stream) {",
          "298:   parent_.decodeHeaders(this, *parent_.filter_manager_callbacks_.requestHeaders(), end_stream);",
          "",
          "[Removed Lines]",
          "295: bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_complete_; }",
          "",
          "[Added Lines]",
          "301: bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "789: }",
          "791: void FilterManager::maybeEndDecode(bool end_stream) {",
          "794:   if (end_stream) {",
          "795:     stream_info_.onLastDownstreamRxByteReceived();",
          "796:     ENVOY_STREAM_LOG(debug, \"request end stream\", *this);",
          "",
          "[Removed Lines]",
          "792:   ASSERT(!state_.remote_complete_);",
          "793:   state_.remote_complete_ = end_stream;",
          "",
          "[Added Lines]",
          "798:   ASSERT(!state_.remote_decode_complete_);",
          "799:   state_.remote_decode_complete_ = end_stream;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1292: void FilterManager::maybeEndEncode(bool end_stream) {",
          "1293:   if (end_stream) {",
          "1294:     filter_manager_callbacks_.endStream();",
          "1295:   }",
          "1296: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1300:     ASSERT(!state_.remote_encode_complete_);",
          "1301:     state_.remote_encode_complete_ = true;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1576: }",
          "1578: void ActiveStreamEncoderFilter::responseDataTooLarge() {",
          "1579:   if (parent_.state_.encoder_filters_streaming_) {",
          "1580:     onEncoderFilterAboveWriteBufferHighWatermark();",
          "1581:   } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1587:   ENVOY_STREAM_LOG(debug, \"response data too large watermark exceeded\", parent_);",
          "",
          "---------------"
        ],
        "source/common/http/filter_manager.h||source/common/http/filter_manager.h": [
          "File: source/common/http/filter_manager.h -> source/common/http/filter_manager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "309:       : ActiveStreamFilterBase(parent, dual_filter, std::move(match_state)), handle_(filter) {}",
          "313:   Buffer::InstancePtr createBuffer() override;",
          "314:   Buffer::InstancePtr& bufferedData() override;",
          "315:   bool complete() override;",
          "",
          "[Removed Lines]",
          "312:   bool canContinue() override { return true; }",
          "",
          "[Added Lines]",
          "312:   bool canContinue() override;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "889:   bool remoteComplete() const { return state_.remote_complete_; }",
          "",
          "[Added Lines]",
          "889:   bool remoteDecodeComplete() const { return state_.remote_decode_complete_; }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1035:   struct State {",
          "1036:     State()",
          "1042:     uint32_t filter_call_state_{0};",
          "1045:     bool local_complete_ : 1; // This indicates that local is complete prior to filter processing.",
          "",
          "[Removed Lines]",
          "1037:         : remote_complete_(false), local_complete_(false), has_continue_headers_(false),",
          "1038:           created_filter_chain_(false), is_head_request_(false), is_grpc_request_(false),",
          "1039:           non_100_response_headers_encoded_(false), under_on_local_reply_(false),",
          "1040:           decoder_filter_chain_aborted_(false), encoder_filter_chain_aborted_(false) {}",
          "1044:     bool remote_complete_ : 1;",
          "",
          "[Added Lines]",
          "1037:         : remote_encode_complete_(false), remote_decode_complete_(false), local_complete_(false),",
          "1038:           has_continue_headers_(false), created_filter_chain_(false), is_head_request_(false),",
          "1039:           is_grpc_request_(false), non_100_response_headers_encoded_(false),",
          "1040:           under_on_local_reply_(false), decoder_filter_chain_aborted_(false),",
          "1041:           encoder_filter_chain_aborted_(false) {}",
          "1045:     bool remote_encode_complete_ : 1;",
          "1046:     bool remote_decode_complete_ : 1;",
          "",
          "---------------"
        ],
        "test/integration/filters/buffer_continue_filter.cc||test/integration/filters/buffer_continue_filter.cc": [
          "File: test/integration/filters/buffer_continue_filter.cc -> test/integration/filters/buffer_continue_filter.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <string>",
          "3: #include \"envoy/http/filter.h\"",
          "4: #include \"envoy/registry/registry.h\"",
          "5: #include \"envoy/server/filter_config.h\"",
          "7: #include \"extensions/filters/http/common/pass_through_filter.h\"",
          "9: #include \"test/extensions/filters/http/common/empty_http_filter_config.h\"",
          "11: namespace Envoy {",
          "14: class BufferContinueStreamFilter : public Http::PassThroughFilter {",
          "15: public:",
          "16:   Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap&, bool end_stream) override {",
          "17:     return end_stream ? Http::FilterHeadersStatus::Continue",
          "18:                       : Http::FilterHeadersStatus::StopIteration;",
          "19:   }",
          "21:   Http::FilterDataStatus decodeData(Buffer::Instance&, bool end_stream) override {",
          "22:     return end_stream ? Http::FilterDataStatus::Continue",
          "23:                       : Http::FilterDataStatus::StopIterationAndBuffer;",
          "24:   }",
          "26:   Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap& headers, bool) override {",
          "27:     response_headers_ = &headers;",
          "28:     return Http::FilterHeadersStatus::StopIteration;",
          "29:   }",
          "31:   Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override {",
          "32:     data_total_ += data.length();",
          "34:     const auto limit = encoder_callbacks_->encoderBufferLimit();",
          "35:     const auto header_size = response_headers_->byteSize();",
          "37:     if (limit && header_size + data_total_ > limit) {",
          "40:       return Http::FilterDataStatus::Continue;",
          "41:     }",
          "43:     encoder_callbacks_->addEncodedData(data, false);",
          "45:     if (!end_stream) {",
          "46:       return Http::FilterDataStatus::StopIterationAndBuffer;",
          "47:     }",
          "49:     return Http::FilterDataStatus::Continue;",
          "50:   }",
          "52: private:",
          "53:   Http::ResponseHeaderMap* response_headers_;",
          "54:   uint64_t data_total_{0};",
          "55: };",
          "57: class BufferContinueFilterConfig : public Extensions::HttpFilters::Common::EmptyHttpFilterConfig {",
          "58: public:",
          "59:   BufferContinueFilterConfig() : EmptyHttpFilterConfig(\"buffer-continue-filter\") {}",
          "61:   Http::FilterFactoryCb createFilter(const std::string&,",
          "62:                                      Server::Configuration::FactoryContext&) override {",
          "63:     return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {",
          "64:       callbacks.addStreamFilter(std::make_shared<::Envoy::BufferContinueStreamFilter>());",
          "65:     };",
          "66:   }",
          "67: };",
          "70: static Registry::RegisterFactory<BufferContinueFilterConfig,",
          "71:                                  Server::Configuration::NamedHttpFilterConfigFactory>",
          "72:     register_;",
          "74: } // namespace Envoy",
          "",
          "---------------"
        ],
        "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc": [
          "File: test/integration/protocol_integration_test.cc -> test/integration/protocol_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2656:   EXPECT_EQ(\"413\", response->headers().getStatusValue());",
          "2657: }",
          "2659: } // namespace Envoy",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2660: TEST_P(ProtocolIntegrationTest, BufferContinue) {",
          "2662:   if (upstreamProtocol() != FakeHttpConnection::Type::HTTP2) {",
          "2663:     return;",
          "2664:   }",
          "2665:   config_helper_.addConfigModifier(",
          "2666:       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&",
          "2667:               hcm) -> void {",
          "2668:         auto* route_config = hcm.mutable_route_config();",
          "2669:         auto* virtual_host = route_config->mutable_virtual_hosts(0);",
          "2670:         auto* header = virtual_host->mutable_response_headers_to_add()->Add()->mutable_header();",
          "2671:         header->set_key(\"foo\");",
          "2672:         header->set_value(\"bar\");",
          "2673:       });",
          "2675:   useAccessLog();",
          "2676:   config_helper_.addFilter(\"{ name: buffer-continue-filter, typed_config: { \\\"@type\\\": \"",
          "2677:                            \"type.googleapis.com/google.protobuf.Empty } }\");",
          "2678:   config_helper_.setBufferLimits(1024, 1024);",
          "2679:   initialize();",
          "2682:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "2683:   auto encoder_decoder = codec_client_->startRequest(default_request_headers_);",
          "2684:   auto downstream_request = &encoder_decoder.first;",
          "2685:   auto response = std::move(encoder_decoder.second);",
          "2686:   Buffer::OwnedImpl data(\"HTTP body content goes here\");",
          "2687:   codec_client_->sendData(*downstream_request, data, true);",
          "2688:   waitForNextUpstreamRequest();",
          "2691:   upstream_request_->encodeHeaders(default_response_headers_, false);",
          "2695:   upstream_request_->encodeData(512, false);",
          "2696:   upstream_request_->encodeData(1024 * 100, false);",
          "2698:   if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {",
          "2699:     ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());",
          "2700:   } else {",
          "2701:     ASSERT_TRUE(upstream_request_->waitForReset());",
          "2702:     ASSERT_TRUE(fake_upstream_connection_->close());",
          "2703:     ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());",
          "2704:   }",
          "2706:   ASSERT_TRUE(response->waitForEndStream());",
          "2707:   EXPECT_TRUE(response->complete());",
          "2708:   EXPECT_EQ(\"500\", response->headers().getStatusValue());",
          "2709: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-7035",
  "cve_desc": "An authorization flaw was found in Pacemaker before 1.1.16, where it did not properly guard its IPC interface. An attacker with an unprivileged account on a Pacemaker node could use this flaw to, for example, force the Local Resource Manager daemon to execute a script as root and thereby gain root access on the machine.",
  "repo": "ClusterLabs/pacemaker",
  "patch_hash": "5d71e65049d143435b03d6b3709d82900f32276f",
  "patch_info": {
    "commit_hash": "5d71e65049d143435b03d6b3709d82900f32276f",
    "repo": "ClusterLabs/pacemaker",
    "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/5d71e65049",
    "files": [
      "lib/common/ipc.c"
    ],
    "message": "High: libcrmcommon: fix CVE-2016-7035 (improper IPC guarding)\n\nIt was discovered that at some not so uncommon circumstances, some\npacemaker daemons could be talked to, via libqb-facilitated IPC, by\nunprivileged clients due to flawed authorization decision.  Depending\non the capabilities of affected daemons, this might equip unauthorized\nuser with local privilege escalation or up to cluster-wide remote\nexecution of possibly arbitrary commands when such user happens to\nreside at standard or remote/guest cluster node, respectively.\n\nThe original vulnerability was introduced in an attempt to allow\nunprivileged IPC clients to clean up the file system materialized\nleftovers in case the server (otherwise responsible for the lifecycle\nof these files) crashes.  While the intended part of such behavior is\nnow effectively voided (along with the unintended one), a best-effort\nfix to address this corner case systemically at libqb is coming along\n(https://github.com/ClusterLabs/libqb/pull/231).\n\nAffected versions:  1.1.10-rc1 (2013-04-17) - 1.1.15 (2016-06-21)\nImpact:             Important\nCVSSv3 ranking:     8.8 : AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H\n\nCredits for independent findings, in chronological order:\n  Jan \"poki\" Pokorn\u00fd, of Red Hat\n  Alain Moulle, of ATOS/BULL",
    "before_after_code_files": [
      "lib/common/ipc.c||lib/common/ipc.c"
    ]
  },
  "patch_diff": {
    "lib/common/ipc.c||lib/common/ipc.c": [
      "File: lib/common/ipc.c -> lib/common/ipc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "293: crm_client_t *",
      "294: crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)",
      "295: {",
      "297:     static gid_t gid_cluster = 0;",
      "299:     crm_client_t *client = NULL;",
      "",
      "[Removed Lines]",
      "296:     static uid_t uid_server = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "304:     }",
      "306:     if (gid_cluster == 0) {",
      "308:         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {",
      "309:             static bool have_error = FALSE;",
      "310:             if(have_error == FALSE) {",
      "",
      "[Removed Lines]",
      "307:         uid_server = getuid();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "314:         }",
      "315:     }",
      "325:         crm_trace(\"Giving access to group %u\", gid_cluster);",
      "327:     }",
      "329:     crm_client_init();",
      "",
      "[Removed Lines]",
      "317:     if(gid_cluster != 0 && gid_client != 0) {",
      "321:             best_uid = QB_MAX(uid_client, uid_server);",
      "322:             crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);",
      "323:         }",
      "326:         qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);",
      "",
      "[Added Lines]",
      "315:     if (uid_client != 0) {",
      "318:         qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ae780515cd4db1e6f23db9f75a628ce9c39bdd49",
      "candidate_info": {
        "commit_hash": "ae780515cd4db1e6f23db9f75a628ce9c39bdd49",
        "repo": "ClusterLabs/pacemaker",
        "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/ae780515cd4db1e6f23db9f75a628ce9c39bdd49",
        "files": [
          "include/crm/common/ipcs.h",
          "lib/common/ipc.c"
        ],
        "message": "Refactor: libcrmcommon: remember when IPC client is root or cluster user\n\nwill allow using a different eviction threshold",
        "before_after_code_files": [
          "include/crm/common/ipcs.h||include/crm/common/ipcs.h",
          "lib/common/ipc.c||lib/common/ipc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/common/ipc.c||lib/common/ipc.c"
          ],
          "candidate": [
            "lib/common/ipc.c||lib/common/ipc.c"
          ]
        }
      },
      "candidate_diff": {
        "include/crm/common/ipcs.h||include/crm/common/ipcs.h": [
          "File: include/crm/common/ipcs.h -> include/crm/common/ipcs.h"
        ],
        "lib/common/ipc.c||lib/common/ipc.c": [
          "File: lib/common/ipc.c -> lib/common/ipc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "314: crm_client_t *",
          "315: crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)",
          "316: {",
          "317:     static gid_t gid_cluster = 0;",
          "319:     crm_client_t *client = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "317:     static gid_t uid_cluster = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "323:         return NULL;",
          "324:     }",
          "328:             static bool have_error = FALSE;",
          "329:             if(have_error == FALSE) {",
          "331:                 have_error = TRUE;",
          "332:             }",
          "333:         }",
          "",
          "[Removed Lines]",
          "326:     if (gid_cluster == 0) {",
          "327:         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {",
          "330:                 crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);",
          "",
          "[Added Lines]",
          "327:     if (uid_cluster == 0) {",
          "328:         if (crm_user_lookup(CRM_DAEMON_USER, &uid_cluster, &gid_cluster) < 0) {",
          "331:                 crm_warn(\"Could not find user and group IDs for user %s\",",
          "332:                          CRM_DAEMON_USER);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "347:     client->kind = CRM_CLIENT_IPC;",
          "348:     client->pid = crm_ipcs_client_pid(c);",
          "350:     crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);",
          "352: #if ENABLE_ACL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "352:     if ((uid_client == 0) || (uid_client == uid_cluster)) {",
          "354:         set_bit(client->flags, crm_client_flag_ipc_privileged);",
          "355:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
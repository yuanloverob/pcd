{
  "cve_id": "CVE-2017-17855",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging improper use of pointers in place of scalars.",
  "repo": "torvalds/linux",
  "patch_hash": "179d1c5602997fef5a940c6ddcf31212cbfebd14",
  "patch_info": {
    "commit_hash": "179d1c5602997fef5a940c6ddcf31212cbfebd14",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/179d1c5602997fef5a940c6ddcf31212cbfebd14",
    "files": [
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: don't prune branches when a scalar is replaced with a pointer\n\nThis could be made safe by passing through a reference to env and checking\nfor env->allow_ptr_leaks, but it would only work one way and is probably\nnot worth the hassle - not doing it will not directly lead to program\nrejection.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "before_after_code_files": [
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3467:    return range_within(rold, rcur) &&",
      "3468:           tnum_in(rold->var_off, rcur->var_off);",
      "3469:   } else {",
      "3479:   }",
      "3480:  case PTR_TO_MAP_VALUE:",
      "",
      "[Removed Lines]",
      "3474:    return rold->umin_value == 0 &&",
      "3475:           rold->umax_value == U64_MAX &&",
      "3476:           rold->smin_value == S64_MIN &&",
      "3477:           rold->smax_value == S64_MAX &&",
      "3478:           tnum_is_unknown(rold->var_off);",
      "",
      "[Added Lines]",
      "3477:    return false;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
      "candidate_info": {
        "commit_hash": "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
        "files": [
          "include/linux/bpf_verifier.h",
          "include/linux/tnum.h",
          "kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf/verifier: track signed and unsigned min/max values\n\nAllows us to, sometimes, combine information from a signed check of one\n bound and an unsigned check of the other.\nWe now track the full range of possible values, rather than restricting\n ourselves to [0, 1<<30) and considering anything beyond that as\n unknown.  While this is probably not necessary, it makes the code more\n straightforward and symmetrical between signed and unsigned bounds.\n\nSigned-off-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "include/linux/tnum.h||include/linux/tnum.h",
          "kernel/bpf/tnum.c||kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <linux/tnum.h>",
          "20: struct bpf_reg_state {",
          "21:  enum bpf_reg_type type;",
          "",
          "[Removed Lines]",
          "17: #define BPF_REGISTER_MAX_RANGE (1024 * 1024 * 1024)",
          "18: #define BPF_REGISTER_MIN_RANGE -1",
          "",
          "[Added Lines]",
          "18: #define BPF_MAX_VAR_OFF (1ULL << 31)",
          "22: #define BPF_MAX_VAR_SIZ INT_MAX",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55: };",
          "57: enum bpf_stack_slot_type {",
          "",
          "[Removed Lines]",
          "52:  s64 min_value;",
          "53:  u64 max_value;",
          "54:  bool value_from_signed;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/tnum.h||include/linux/tnum.h": [
          "File: include/linux/tnum.h -> include/linux/tnum.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: struct tnum tnum_const(u64 value);",
          "19: extern const struct tnum tnum_unknown;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: struct tnum tnum_range(u64 min, u64 max);",
          "",
          "---------------"
        ],
        "kernel/bpf/tnum.c||kernel/bpf/tnum.c": [
          "File: kernel/bpf/tnum.c -> kernel/bpf/tnum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:  return TNUM(value, 0);",
          "18: }",
          "20: struct tnum tnum_lshift(struct tnum a, u8 shift)",
          "21: {",
          "22:  return TNUM(a.value << shift, a.mask << shift);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: struct tnum tnum_range(u64 min, u64 max)",
          "21: {",
          "22:  u64 chi = min ^ max, delta;",
          "23:  u8 bits = fls64(chi);",
          "26:  if (bits > 63)",
          "27:   return tnum_unknown;",
          "32:  delta = (1ULL << bits) - 1;",
          "33:  return TNUM(min & ~delta, delta);",
          "34: }",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:     verbose(\",ks=%d,vs=%d\",",
          "235:      reg->map_ptr->key_size,",
          "236:      reg->map_ptr->value_size);",
          "243:    if (!tnum_is_unknown(reg->var_off)) {",
          "244:     char tn_buf[48];",
          "",
          "[Removed Lines]",
          "237:    if (reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "238:     verbose(\",min_value=%lld\",",
          "239:      (long long)reg->min_value);",
          "240:    if (reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "241:     verbose(\",max_value=%llu\",",
          "242:      (unsigned long long)reg->max_value);",
          "",
          "[Added Lines]",
          "237:    if (reg->smin_value != reg->umin_value &&",
          "238:        reg->smin_value != S64_MIN)",
          "239:     verbose(\",smin_value=%lld\",",
          "240:      (long long)reg->smin_value);",
          "241:    if (reg->smax_value != reg->umax_value &&",
          "242:        reg->smax_value != S64_MAX)",
          "243:     verbose(\",smax_value=%lld\",",
          "244:      (long long)reg->smax_value);",
          "245:    if (reg->umin_value != 0)",
          "246:     verbose(\",umin_value=%llu\",",
          "247:      (unsigned long long)reg->umin_value);",
          "248:    if (reg->umax_value != U64_MAX)",
          "249:     verbose(\",umax_value=%llu\",",
          "250:      (unsigned long long)reg->umax_value);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "467: static void __mark_reg_not_init(struct bpf_reg_state *reg);",
          "472: static void __mark_reg_known_zero(struct bpf_reg_state *reg)",
          "473: {",
          "477: }",
          "479: static void mark_reg_known_zero(struct bpf_reg_state *regs, u32 regno)",
          "",
          "[Removed Lines]",
          "474:  reg->var_off = tnum_const(0);",
          "475:  reg->min_value = 0;",
          "476:  reg->max_value = 0;",
          "",
          "[Added Lines]",
          "480: static void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)",
          "481: {",
          "482:  reg->id = 0;",
          "483:  reg->var_off = tnum_const(imm);",
          "484:  reg->smin_value = (s64)imm;",
          "485:  reg->smax_value = (s64)imm;",
          "486:  reg->umin_value = imm;",
          "487:  reg->umax_value = imm;",
          "488: }",
          "495:  __mark_reg_known(reg, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "488:  __mark_reg_known_zero(regs + regno);",
          "489: }",
          "492: static void __mark_reg_unknown(struct bpf_reg_state *reg)",
          "493: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "511: static void __update_reg_bounds(struct bpf_reg_state *reg)",
          "512: {",
          "514:  reg->smin_value = max_t(s64, reg->smin_value,",
          "515:     reg->var_off.value | (reg->var_off.mask & S64_MIN));",
          "517:  reg->smax_value = min_t(s64, reg->smax_value,",
          "518:     reg->var_off.value | (reg->var_off.mask & S64_MAX));",
          "519:  reg->umin_value = max(reg->umin_value, reg->var_off.value);",
          "520:  reg->umax_value = min(reg->umax_value,",
          "521:          reg->var_off.value | reg->var_off.mask);",
          "522: }",
          "525: static void __reg_deduce_bounds(struct bpf_reg_state *reg)",
          "526: {",
          "532:  if (reg->smin_value >= 0 || reg->smax_value < 0) {",
          "533:   reg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,",
          "534:          reg->umin_value);",
          "535:   reg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,",
          "536:          reg->umax_value);",
          "537:   return;",
          "538:  }",
          "542:  if ((s64)reg->umax_value >= 0) {",
          "546:   reg->smin_value = reg->umin_value;",
          "547:   reg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,",
          "548:          reg->umax_value);",
          "549:  } else if ((s64)reg->umin_value < 0) {",
          "553:   reg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,",
          "554:          reg->umin_value);",
          "555:   reg->smax_value = reg->umax_value;",
          "556:  }",
          "557: }",
          "560: static void __reg_bound_offset(struct bpf_reg_state *reg)",
          "561: {",
          "562:  reg->var_off = tnum_intersect(reg->var_off,",
          "563:           tnum_range(reg->umin_value,",
          "564:        reg->umax_value));",
          "565: }",
          "568: static void __mark_reg_unbounded(struct bpf_reg_state *reg)",
          "569: {",
          "570:  reg->smin_value = S64_MIN;",
          "571:  reg->smax_value = S64_MAX;",
          "572:  reg->umin_value = 0;",
          "573:  reg->umax_value = U64_MAX;",
          "574: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "495:  reg->id = 0;",
          "496:  reg->off = 0;",
          "497:  reg->var_off = tnum_unknown;",
          "500: }",
          "502: static void mark_reg_unknown(struct bpf_reg_state *regs, u32 regno)",
          "",
          "[Removed Lines]",
          "498:  reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "499:  reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "",
          "[Added Lines]",
          "583:  __mark_reg_unbounded(reg);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "545:  mark_reg_known_zero(regs, BPF_REG_1);",
          "546: }",
          "555: enum reg_arg_type {",
          "",
          "[Removed Lines]",
          "548: static void reset_reg_range_values(struct bpf_reg_state *regs, u32 regno)",
          "549: {",
          "550:  regs[regno].min_value = BPF_REGISTER_MIN_RANGE;",
          "551:  regs[regno].max_value = BPF_REGISTER_MAX_RANGE;",
          "552:  regs[regno].value_from_signed = false;",
          "553: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "720:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "721:    regno);",
          "722:   return -EACCES;",
          "723:  }",
          "725:  if (err) {",
          "726:   verbose(\"R%d min value is outside of the array range\\n\", regno);",
          "727:   return err;",
          "728:  }",
          "734:   verbose(\"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",",
          "735:    regno);",
          "736:   return -EACCES;",
          "737:  }",
          "739:  if (err)",
          "740:   verbose(\"R%d max value is outside of the array range\\n\", regno);",
          "741:  return err;",
          "",
          "[Removed Lines]",
          "719:  if (reg->min_value < 0) {",
          "724:  err = __check_map_access(env, regno, reg->min_value + off, size);",
          "733:  if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "738:  err = __check_map_access(env, regno, reg->max_value + off, size);",
          "",
          "[Added Lines]",
          "796:  if (reg->smin_value < 0) {",
          "801:  err = __check_map_access(env, regno, reg->smin_value + off, size);",
          "811:  if (reg->umax_value >= BPF_MAX_VAR_OFF) {",
          "816:  err = __check_map_access(env, regno, reg->umax_value + off, size);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "801:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "802:    regno);",
          "803:   return -EACCES;",
          "",
          "[Removed Lines]",
          "800:  if (reg->min_value < 0) {",
          "",
          "[Added Lines]",
          "878:  if (reg->smin_value < 0) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1071:   state->regs[value_regno].var_off = tnum_cast(",
          "1072:      state->regs[value_regno].var_off, size);",
          "1079:  }",
          "1080:  return err;",
          "1081: }",
          "",
          "[Removed Lines]",
          "1074:   state->regs[value_regno].min_value = 0;",
          "1075:   state->regs[value_regno].max_value = min_t(u64,",
          "1076:      state->regs[value_regno].var_off.value |",
          "1077:      state->regs[value_regno].var_off.mask,",
          "1078:      BPF_REGISTER_MAX_RANGE);",
          "",
          "[Added Lines]",
          "1151:   __update_reg_bounds(&state->regs[value_regno]);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1334:    meta = NULL;",
          "1337:    verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "1338:     regno);",
          "1339:    return -EACCES;",
          "1340:   }",
          "1343:    err = check_helper_mem_access(env, regno - 1, 0,",
          "1344:             zero_size_allowed,",
          "1345:             meta);",
          "",
          "[Removed Lines]",
          "1336:   if (reg->min_value < 0) {",
          "1342:   if (reg->min_value == 0) {",
          "",
          "[Added Lines]",
          "1409:   if (reg->smin_value < 0) {",
          "1415:   if (reg->umin_value == 0) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1347:     return err;",
          "1348:   }",
          "1351:    verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "1352:     regno);",
          "1353:    return -EACCES;",
          "1354:   }",
          "1355:   err = check_helper_mem_access(env, regno - 1,",
          "1357:            zero_size_allowed, meta);",
          "1358:  }",
          "",
          "[Removed Lines]",
          "1350:   if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "1356:            reg->max_value,",
          "",
          "[Added Lines]",
          "1423:   if (reg->umax_value >= BPF_MAX_VAR_SIZ) {",
          "1429:            reg->umax_value,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1600:  return 0;",
          "1601: }",
          "1612: static void coerce_reg_to_32(struct bpf_reg_state *reg)",
          "1613: {",
          "1618:  reg->var_off = tnum_cast(reg->var_off, 4);",
          "1626: }",
          "",
          "[Removed Lines]",
          "1603: static void check_reg_overflow(struct bpf_reg_state *reg)",
          "1604: {",
          "1605:  if (reg->max_value > BPF_REGISTER_MAX_RANGE)",
          "1606:   reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1607:  if (reg->min_value < BPF_REGISTER_MIN_RANGE ||",
          "1608:      reg->min_value > BPF_REGISTER_MAX_RANGE)",
          "1609:   reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1610: }",
          "1615:  if (reg->min_value < 0)",
          "1616:   reg->min_value = 0;",
          "1620:  if (tnum_is_const(reg->var_off)) {",
          "1621:   if ((s64)reg->var_off.value > BPF_REGISTER_MIN_RANGE)",
          "1622:    reg->min_value = reg->var_off.value;",
          "1623:   if (reg->var_off.value < BPF_REGISTER_MAX_RANGE)",
          "1624:    reg->max_value = reg->var_off.value;",
          "1625:  }",
          "",
          "[Added Lines]",
          "1681:  __update_reg_bounds(reg);",
          "1682: }",
          "1684: static bool signed_add_overflows(s64 a, s64 b)",
          "1685: {",
          "1687:  s64 res = (s64)((u64)a + (u64)b);",
          "1689:  if (b < 0)",
          "1690:   return res > a;",
          "1691:  return res < a;",
          "1692: }",
          "1694: static bool signed_sub_overflows(s64 a, s64 b)",
          "1695: {",
          "1697:  s64 res = (s64)((u64)a - (u64)b);",
          "1699:  if (b < 0)",
          "1700:   return res < a;",
          "1701:  return res > a;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1638: {",
          "1639:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "1640:  bool known = tnum_is_const(off_reg->var_off);",
          "1643:  u8 opcode = BPF_OP(insn->code);",
          "1644:  u32 dst = insn->dst_reg;",
          "1646:  dst_reg = &regs[dst];",
          "1649:   print_verifier_state(&env->cur_state);",
          "1651:   return -EINVAL;",
          "1652:  }",
          "",
          "[Removed Lines]",
          "1641:  s64 min_val = off_reg->min_value;",
          "1642:  u64 max_val = off_reg->max_value;",
          "1648:  if (WARN_ON_ONCE(known && (min_val != max_val))) {",
          "1650:   verbose(\"verifier internal error\\n\");",
          "",
          "[Added Lines]",
          "1716:  s64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,",
          "1717:      smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;",
          "1718:  u64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,",
          "1719:      umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;",
          "1725:  if (WARN_ON_ONCE(known && (smin_val != smax_val))) {",
          "1727:   verbose(\"verifier internal error: known but bad sbounds\\n\");",
          "1728:   return -EINVAL;",
          "1729:  }",
          "1730:  if (WARN_ON_ONCE(known && (umin_val != umax_val))) {",
          "1731:   print_verifier_state(&env->cur_state);",
          "1732:   verbose(\"verifier internal error: known but bad ubounds\\n\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1697:    dst_reg->var_off = ptr_reg->var_off;",
          "1699:    dst_reg->range = ptr_reg->range;",
          "1700:    break;",
          "1701:   }",
          "",
          "[Removed Lines]",
          "1692:   if (known && (ptr_reg->off + min_val ==",
          "1693:          (s64)(s32)(ptr_reg->off + min_val))) {",
          "1695:    dst_reg->min_value = ptr_reg->min_value;",
          "1696:    dst_reg->max_value = ptr_reg->max_value;",
          "1698:    dst_reg->off = ptr_reg->off + min_val;",
          "1702:   if (max_val == BPF_REGISTER_MAX_RANGE) {",
          "1703:    if (!env->allow_ptr_leaks)",
          "1704:     verbose(\"R%d tried to add unbounded value to pointer\\n\",",
          "1705:      dst);",
          "1706:    return -EACCES;",
          "1707:   }",
          "",
          "[Added Lines]",
          "1774:   if (known && (ptr_reg->off + smin_val ==",
          "1775:          (s64)(s32)(ptr_reg->off + smin_val))) {",
          "1777:    dst_reg->smin_value = smin_ptr;",
          "1778:    dst_reg->smax_value = smax_ptr;",
          "1779:    dst_reg->umin_value = umin_ptr;",
          "1780:    dst_reg->umax_value = umax_ptr;",
          "1782:    dst_reg->off = ptr_reg->off + smin_val;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1723:   dst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);",
          "1724:   dst_reg->off = ptr_reg->off;",
          "1725:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "",
          "[Removed Lines]",
          "1717:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1718:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1719:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1720:    dst_reg->min_value += min_val;",
          "1721:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1722:    dst_reg->max_value += max_val;",
          "",
          "[Added Lines]",
          "1795:   if (signed_add_overflows(smin_ptr, smin_val) ||",
          "1796:       signed_add_overflows(smax_ptr, smax_val)) {",
          "1797:    dst_reg->smin_value = S64_MIN;",
          "1798:    dst_reg->smax_value = S64_MAX;",
          "1799:   } else {",
          "1800:    dst_reg->smin_value = smin_ptr + smin_val;",
          "1801:    dst_reg->smax_value = smax_ptr + smax_val;",
          "1802:   }",
          "1803:   if (umin_ptr + umin_val < umin_ptr ||",
          "1804:       umax_ptr + umax_val < umax_ptr) {",
          "1805:    dst_reg->umin_value = 0;",
          "1806:    dst_reg->umax_value = U64_MAX;",
          "1807:   } else {",
          "1808:    dst_reg->umin_value = umin_ptr + umin_val;",
          "1809:    dst_reg->umax_value = umax_ptr + umax_val;",
          "1810:   }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1746:      dst);",
          "1747:    return -EACCES;",
          "1748:   }",
          "1754:    dst_reg->var_off = ptr_reg->var_off;",
          "1755:    dst_reg->id = ptr_reg->id;",
          "1757:    dst_reg->range = ptr_reg->range;",
          "1758:    break;",
          "1759:   }",
          "1780:   dst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);",
          "1781:   dst_reg->off = ptr_reg->off;",
          "1782:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "1783:    dst_reg->id = ++env->id_gen;",
          "1786:     dst_reg->range = 0;",
          "1787:   }",
          "1788:   break;",
          "",
          "[Removed Lines]",
          "1749:   if (known && (ptr_reg->off - min_val ==",
          "1750:          (s64)(s32)(ptr_reg->off - min_val))) {",
          "1752:    dst_reg->min_value = ptr_reg->min_value;",
          "1753:    dst_reg->max_value = ptr_reg->max_value;",
          "1756:    dst_reg->off = ptr_reg->off - min_val;",
          "1763:   if ((s64)max_val < 0) {",
          "1764:    if (!env->allow_ptr_leaks)",
          "1765:     verbose(\"R%d tried to subtract negative max_val %lld from pointer\\n\",",
          "1766:      dst, (s64)max_val);",
          "1767:    return -EACCES;",
          "1768:   }",
          "1772:   if (max_val >= BPF_REGISTER_MAX_RANGE)",
          "1773:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1774:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1775:    dst_reg->min_value -= max_val;",
          "1776:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1777:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1778:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1779:    dst_reg->max_value -= min_val;",
          "1785:    if (min_val < 0)",
          "",
          "[Added Lines]",
          "1837:   if (known && (ptr_reg->off - smin_val ==",
          "1838:          (s64)(s32)(ptr_reg->off - smin_val))) {",
          "1840:    dst_reg->smin_value = smin_ptr;",
          "1841:    dst_reg->smax_value = smax_ptr;",
          "1842:    dst_reg->umin_value = umin_ptr;",
          "1843:    dst_reg->umax_value = umax_ptr;",
          "1846:    dst_reg->off = ptr_reg->off - smin_val;",
          "1853:   if (signed_sub_overflows(smin_ptr, smax_val) ||",
          "1854:       signed_sub_overflows(smax_ptr, smin_val)) {",
          "1856:    dst_reg->smin_value = S64_MIN;",
          "1857:    dst_reg->smax_value = S64_MAX;",
          "1858:   } else {",
          "1859:    dst_reg->smin_value = smin_ptr - smax_val;",
          "1860:    dst_reg->smax_value = smax_ptr - smin_val;",
          "1861:   }",
          "1862:   if (umin_ptr < umax_val) {",
          "1864:    dst_reg->umin_value = 0;",
          "1865:    dst_reg->umax_value = U64_MAX;",
          "1866:   } else {",
          "1868:    dst_reg->umin_value = umin_ptr - umax_val;",
          "1869:    dst_reg->umax_value = umax_ptr - umin_val;",
          "1870:   }",
          "1876:    if (smin_val < 0)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1805:   return -EACCES;",
          "1806:  }",
          "1809:  return 0;",
          "1810: }",
          "",
          "[Removed Lines]",
          "1808:  check_reg_overflow(dst_reg);",
          "",
          "[Added Lines]",
          "1899:  __update_reg_bounds(dst_reg);",
          "1900:  __reg_deduce_bounds(dst_reg);",
          "1901:  __reg_bound_offset(dst_reg);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1815:           struct bpf_reg_state src_reg)",
          "1816: {",
          "1817:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1820:  u8 opcode = BPF_OP(insn->code);",
          "1821:  bool src_known, dst_known;",
          "1823:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1825:   coerce_reg_to_32(dst_reg);",
          "1826:   coerce_reg_to_32(&src_reg);",
          "1827:  }",
          "1830:  src_known = tnum_is_const(src_reg.var_off);",
          "1831:  dst_known = tnum_is_const(dst_reg->var_off);",
          "1833:  switch (opcode) {",
          "1834:  case BPF_ADD:",
          "1842:   dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);",
          "1843:   break;",
          "1844:  case BPF_SUB:",
          "1853:   dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);",
          "1854:   break;",
          "1855:  case BPF_MUL:",
          "1859:    break;",
          "1860:   }",
          "1870:   break;",
          "1871:  case BPF_AND:",
          "1872:   if (src_known && dst_known) {",
          "1878:    break;",
          "1879:   }",
          "1885:   dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);",
          "1891:   break;",
          "1892:  case BPF_OR:",
          "1893:   if (src_known && dst_known) {",
          "1899:    break;",
          "1900:   }",
          "1905:   dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);",
          "1909:   } else {",
          "1912:   }",
          "1913:   break;",
          "1914:  case BPF_LSH:",
          "1917:    mark_reg_unknown(regs, insn->dst_reg);",
          "1918:    break;",
          "1919:   }",
          "1927:   } else {",
          "1934:   }",
          "1939:   break;",
          "1940:  case BPF_RSH:",
          "1943:    mark_reg_unknown(regs, insn->dst_reg);",
          "1944:    break;",
          "1945:   }",
          "1951:   } else {",
          "1954:   }",
          "1955:   if (src_known)",
          "1957:   else",
          "1962:   break;",
          "1963:  default:",
          "1964:   mark_reg_unknown(regs, insn->dst_reg);",
          "1965:   break;",
          "1966:  }",
          "1969:  return 0;",
          "1970: }",
          "",
          "[Removed Lines]",
          "1818:  s64 min_val = BPF_REGISTER_MIN_RANGE;",
          "1819:  u64 max_val = BPF_REGISTER_MAX_RANGE;",
          "1828:  min_val = src_reg.min_value;",
          "1829:  max_val = src_reg.max_value;",
          "1835:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1836:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1837:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1838:    dst_reg->min_value += min_val;",
          "1840:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1841:    dst_reg->max_value += max_val;",
          "1845:   if (max_val == BPF_REGISTER_MAX_RANGE)",
          "1846:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1847:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1848:    dst_reg->min_value -= max_val;",
          "1849:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1850:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1851:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1852:    dst_reg->max_value -= min_val;",
          "1856:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1858:    __mark_reg_unknown(dst_reg);",
          "1861:   dst_reg->min_value *= min_val;",
          "1866:   BUILD_BUG_ON(BPF_REGISTER_MAX_RANGE > (u32)-1);",
          "1867:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1868:    dst_reg->max_value *= max_val;",
          "1869:   dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);",
          "1873:    u64 value = dst_reg->var_off.value & src_reg.var_off.value;",
          "1875:    dst_reg->var_off = tnum_const(value);",
          "1876:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1877:      value, BPF_REGISTER_MAX_RANGE);",
          "1886:   if (min_val < 0 && dst_reg->min_value < 0)",
          "1887:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1888:   else",
          "1889:    dst_reg->min_value = dst_reg->var_off.value;",
          "1890:   dst_reg->max_value = min(dst_reg->max_value, max_val);",
          "1894:    u64 value = dst_reg->var_off.value | src_reg.var_off.value;",
          "1896:    dst_reg->var_off = tnum_const(value);",
          "1897:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1898:      value, BPF_REGISTER_MAX_RANGE);",
          "1906:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1907:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1908:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1910:    dst_reg->min_value = max(dst_reg->min_value, min_val);",
          "1911:    dst_reg->max_value = dst_reg->var_off.value | dst_reg->var_off.mask;",
          "1915:   if (min_val < 0) {",
          "1924:   if (min_val > ilog2(BPF_REGISTER_MAX_RANGE)) {",
          "1925:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1926:    dst_reg->var_off = tnum_unknown;",
          "1928:    if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1929:     dst_reg->min_value <<= min_val;",
          "1930:    if (src_known)",
          "1931:     dst_reg->var_off = tnum_lshift(dst_reg->var_off, min_val);",
          "1932:    else",
          "1933:     dst_reg->var_off = tnum_lshift(tnum_unknown, min_val);",
          "1935:   if (max_val > ilog2(BPF_REGISTER_MAX_RANGE))",
          "1936:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1937:   else if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1938:    dst_reg->max_value <<= max_val;",
          "1941:   if (min_val < 0) {",
          "1947:   if (dst_reg->min_value < 0) {",
          "1948:    if (min_val)",
          "1950:     dst_reg->min_value = 0;",
          "1952:    dst_reg->min_value =",
          "1953:     (u64)(dst_reg->min_value) >> min_val;",
          "1956:    dst_reg->var_off = tnum_rshift(dst_reg->var_off, min_val);",
          "1958:    dst_reg->var_off = tnum_rshift(tnum_unknown, min_val);",
          "1959:   if (dst_reg->max_value == BPF_REGISTER_MAX_RANGE)",
          "1960:    dst_reg->max_value = ~0;",
          "1961:   dst_reg->max_value >>= max_val;",
          "1968:  check_reg_overflow(dst_reg);",
          "",
          "[Added Lines]",
          "1913:  s64 smin_val, smax_val;",
          "1914:  u64 umin_val, umax_val;",
          "1921:  smin_val = src_reg.smin_value;",
          "1922:  smax_val = src_reg.smax_value;",
          "1923:  umin_val = src_reg.umin_value;",
          "1924:  umax_val = src_reg.umax_value;",
          "1930:   if (signed_add_overflows(dst_reg->smin_value, smin_val) ||",
          "1931:       signed_add_overflows(dst_reg->smax_value, smax_val)) {",
          "1932:    dst_reg->smin_value = S64_MIN;",
          "1933:    dst_reg->smax_value = S64_MAX;",
          "1934:   } else {",
          "1935:    dst_reg->smin_value += smin_val;",
          "1936:    dst_reg->smax_value += smax_val;",
          "1937:   }",
          "1938:   if (dst_reg->umin_value + umin_val < umin_val ||",
          "1939:       dst_reg->umax_value + umax_val < umax_val) {",
          "1940:    dst_reg->umin_value = 0;",
          "1941:    dst_reg->umax_value = U64_MAX;",
          "1942:   } else {",
          "1943:    dst_reg->umin_value += umin_val;",
          "1944:    dst_reg->umax_value += umax_val;",
          "1945:   }",
          "1949:   if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||",
          "1950:       signed_sub_overflows(dst_reg->smax_value, smin_val)) {",
          "1952:    dst_reg->smin_value = S64_MIN;",
          "1953:    dst_reg->smax_value = S64_MAX;",
          "1954:   } else {",
          "1955:    dst_reg->smin_value -= smax_val;",
          "1956:    dst_reg->smax_value -= smin_val;",
          "1957:   }",
          "1958:   if (dst_reg->umin_value < umax_val) {",
          "1960:    dst_reg->umin_value = 0;",
          "1961:    dst_reg->umax_value = U64_MAX;",
          "1962:   } else {",
          "1964:    dst_reg->umin_value -= umax_val;",
          "1965:    dst_reg->umax_value -= umin_val;",
          "1966:   }",
          "1970:   dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);",
          "1971:   if (smin_val < 0 || dst_reg->smin_value < 0) {",
          "1973:    __mark_reg_unbounded(dst_reg);",
          "1974:    __update_reg_bounds(dst_reg);",
          "1980:   if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {",
          "1982:    __mark_reg_unbounded(dst_reg);",
          "1984:    __update_reg_bounds(dst_reg);",
          "1985:    break;",
          "1986:   }",
          "1987:   dst_reg->umin_value *= umin_val;",
          "1988:   dst_reg->umax_value *= umax_val;",
          "1989:   if (dst_reg->umax_value > S64_MAX) {",
          "1991:    dst_reg->smin_value = S64_MIN;",
          "1992:    dst_reg->smax_value = S64_MAX;",
          "1993:   } else {",
          "1994:    dst_reg->smin_value = dst_reg->umin_value;",
          "1995:    dst_reg->smax_value = dst_reg->umax_value;",
          "1996:   }",
          "2000:    __mark_reg_known(dst_reg, dst_reg->var_off.value &",
          "2001:         src_reg.var_off.value);",
          "2008:   dst_reg->umin_value = dst_reg->var_off.value;",
          "2009:   dst_reg->umax_value = min(dst_reg->umax_value, umax_val);",
          "2010:   if (dst_reg->smin_value < 0 || smin_val < 0) {",
          "2014:    dst_reg->smin_value = S64_MIN;",
          "2015:    dst_reg->smax_value = S64_MAX;",
          "2016:   } else {",
          "2020:    dst_reg->smin_value = dst_reg->umin_value;",
          "2021:    dst_reg->smax_value = dst_reg->umax_value;",
          "2022:   }",
          "2024:   __update_reg_bounds(dst_reg);",
          "2028:    __mark_reg_known(dst_reg, dst_reg->var_off.value |",
          "2029:         src_reg.var_off.value);",
          "2036:   dst_reg->umin_value = max(dst_reg->umin_value, umin_val);",
          "2037:   dst_reg->umax_value = dst_reg->var_off.value |",
          "2038:           dst_reg->var_off.mask;",
          "2039:   if (dst_reg->smin_value < 0 || smin_val < 0) {",
          "2043:    dst_reg->smin_value = S64_MIN;",
          "2044:    dst_reg->smax_value = S64_MAX;",
          "2049:    dst_reg->smin_value = dst_reg->umin_value;",
          "2050:    dst_reg->smax_value = dst_reg->umax_value;",
          "2053:   __update_reg_bounds(dst_reg);",
          "2056:   if (umax_val > 63) {",
          "2066:   dst_reg->smin_value = S64_MIN;",
          "2067:   dst_reg->smax_value = S64_MAX;",
          "2069:   if (dst_reg->umax_value > 1ULL << (63 - umax_val)) {",
          "2070:    dst_reg->umin_value = 0;",
          "2071:    dst_reg->umax_value = U64_MAX;",
          "2073:    dst_reg->umin_value <<= umin_val;",
          "2074:    dst_reg->umax_value <<= umax_val;",
          "2076:   if (src_known)",
          "2077:    dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);",
          "2078:   else",
          "2079:    dst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);",
          "2081:   __update_reg_bounds(dst_reg);",
          "2084:   if (umax_val > 63) {",
          "2092:   if (dst_reg->smin_value < 0) {",
          "2093:    if (umin_val) {",
          "2095:     dst_reg->smin_value = 0;",
          "2096:    } else {",
          "2098:     dst_reg->smin_value = S64_MIN;",
          "2099:     dst_reg->smax_value = S64_MAX;",
          "2100:    }",
          "2102:    dst_reg->smin_value =",
          "2103:     (u64)(dst_reg->smin_value) >> umax_val;",
          "2106:    dst_reg->var_off = tnum_rshift(dst_reg->var_off,",
          "2107:              umin_val);",
          "2109:    dst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);",
          "2110:   dst_reg->umin_value >>= umax_val;",
          "2111:   dst_reg->umax_value >>= umin_val;",
          "2113:   __update_reg_bounds(dst_reg);",
          "2120:  __reg_deduce_bounds(dst_reg);",
          "2121:  __reg_bound_offset(dst_reg);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1981:  int rc;",
          "1983:  dst_reg = &regs[insn->dst_reg];",
          "1985:  src_reg = NULL;",
          "1986:  if (dst_reg->type != SCALAR_VALUE)",
          "1987:   ptr_reg = dst_reg;",
          "1988:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1989:   src_reg = &regs[insn->src_reg];",
          "1992:   if (src_reg->type != SCALAR_VALUE) {",
          "1993:    if (dst_reg->type != SCALAR_VALUE) {",
          "",
          "[Removed Lines]",
          "1984:  check_reg_overflow(dst_reg);",
          "1990:   check_reg_overflow(src_reg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2037:   off_reg.type = SCALAR_VALUE;",
          "2041:   src_reg = &off_reg;",
          "2044:    rc = adjust_ptr_min_max_vals(env, insn,",
          "2045:            ptr_reg, src_reg);",
          "",
          "[Removed Lines]",
          "2038:   off_reg.var_off = tnum_const(insn->imm);",
          "2039:   off_reg.min_value = insn->imm;",
          "2040:   off_reg.max_value = insn->imm;",
          "2042:   check_reg_overflow(src_reg);",
          "",
          "[Added Lines]",
          "2188:   __mark_reg_known(&off_reg, insn->imm);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2144:      return -EACCES;",
          "2145:     }",
          "2146:     mark_reg_unknown(regs, insn->dst_reg);",
          "2151:     regs[insn->dst_reg].var_off = tnum_cast(",
          "2152:       regs[insn->dst_reg].var_off, 4);",
          "2153:    }",
          "2154:   } else {",
          "2158:    regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2163:   }",
          "2165:  } else if (opcode > BPF_END) {",
          "",
          "[Removed Lines]",
          "2159:    regs[insn->dst_reg].var_off = tnum_const(insn->imm);",
          "2160:    regs[insn->dst_reg].max_value = insn->imm;",
          "2161:    regs[insn->dst_reg].min_value = insn->imm;",
          "2162:    regs[insn->dst_reg].id = 0;",
          "",
          "[Added Lines]",
          "2297:     __update_reg_bounds(&regs[insn->dst_reg]);",
          "2304:    __mark_reg_known(regs + insn->dst_reg, insn->imm);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2227:   return;",
          "",
          "[Removed Lines]",
          "2229:  if (dst_reg->max_value > MAX_PACKET_OFF ||",
          "2230:      dst_reg->max_value + dst_reg->off > MAX_PACKET_OFF)",
          "",
          "[Added Lines]",
          "2371:  if (dst_reg->umax_value > MAX_PACKET_OFF ||",
          "2372:      dst_reg->umax_value + dst_reg->off > MAX_PACKET_OFF)",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2291:        struct bpf_reg_state *false_reg, u64 val,",
          "2292:        u8 opcode)",
          "2293: {",
          "",
          "[Removed Lines]",
          "2294:  bool value_from_signed = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2312:   break;",
          "2313:  case BPF_JNE:",
          "2319:   break;",
          "2320:  case BPF_JGT:",
          "2323:  case BPF_JSGT:",
          "2339:   break;",
          "2340:  case BPF_JGE:",
          "2343:  case BPF_JSGE:",
          "2359:   break;",
          "2360:  default:",
          "2361:   break;",
          "2362:  }",
          "2366: }",
          "",
          "[Removed Lines]",
          "2310:   true_reg->max_value = true_reg->min_value = val;",
          "2311:   true_reg->var_off = tnum_const(val);",
          "2317:   false_reg->max_value = false_reg->min_value = val;",
          "2318:   false_reg->var_off = tnum_const(val);",
          "2321:   value_from_signed = false;",
          "2324:   if (true_reg->value_from_signed != value_from_signed)",
          "2325:    reset_reg_range_values(true_reg, 0);",
          "2326:   if (false_reg->value_from_signed != value_from_signed)",
          "2327:    reset_reg_range_values(false_reg, 0);",
          "2328:   if (opcode == BPF_JGT) {",
          "2330:    false_reg->min_value = 0;",
          "2331:   }",
          "2335:   false_reg->max_value = val;",
          "2336:   false_reg->value_from_signed = value_from_signed;",
          "2337:   true_reg->min_value = val + 1;",
          "2338:   true_reg->value_from_signed = value_from_signed;",
          "2341:   value_from_signed = false;",
          "2344:   if (true_reg->value_from_signed != value_from_signed)",
          "2345:    reset_reg_range_values(true_reg, 0);",
          "2346:   if (false_reg->value_from_signed != value_from_signed)",
          "2347:    reset_reg_range_values(false_reg, 0);",
          "2348:   if (opcode == BPF_JGE) {",
          "2350:    false_reg->min_value = 0;",
          "2351:   }",
          "2355:   false_reg->max_value = val - 1;",
          "2356:   false_reg->value_from_signed = value_from_signed;",
          "2357:   true_reg->min_value = val;",
          "2358:   true_reg->value_from_signed = value_from_signed;",
          "2364:  check_reg_overflow(false_reg);",
          "2365:  check_reg_overflow(true_reg);",
          "",
          "[Added Lines]",
          "2450:   __mark_reg_known(true_reg, val);",
          "2456:   __mark_reg_known(false_reg, val);",
          "2459:   false_reg->umax_value = min(false_reg->umax_value, val);",
          "2460:   true_reg->umin_value = max(true_reg->umin_value, val + 1);",
          "2461:   break;",
          "2463:   false_reg->smax_value = min_t(s64, false_reg->smax_value, val);",
          "2464:   true_reg->smin_value = max_t(s64, true_reg->smin_value, val + 1);",
          "2467:   false_reg->umax_value = min(false_reg->umax_value, val - 1);",
          "2468:   true_reg->umin_value = max(true_reg->umin_value, val);",
          "2469:   break;",
          "2471:   false_reg->smax_value = min_t(s64, false_reg->smax_value, val - 1);",
          "2472:   true_reg->smin_value = max_t(s64, true_reg->smin_value, val);",
          "2478:  __reg_deduce_bounds(false_reg);",
          "2479:  __reg_deduce_bounds(true_reg);",
          "2481:  __reg_bound_offset(false_reg);",
          "2482:  __reg_bound_offset(true_reg);",
          "2487:  __update_reg_bounds(false_reg);",
          "2488:  __update_reg_bounds(true_reg);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2372:     struct bpf_reg_state *false_reg, u64 val,",
          "2373:     u8 opcode)",
          "2374: {",
          "2377:  if (__is_pointer_value(false, false_reg))",
          "2378:   return;",
          "",
          "[Removed Lines]",
          "2375:  bool value_from_signed = true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2387:   break;",
          "2388:  case BPF_JNE:",
          "2394:   break;",
          "2395:  case BPF_JGT:",
          "2398:  case BPF_JSGT:",
          "2415:   break;",
          "2416:  case BPF_JGE:",
          "2419:  case BPF_JSGE:",
          "2435:   break;",
          "2436:  default:",
          "2437:   break;",
          "2438:  }",
          "2442: }",
          "2445: static void __reg_combine_min_max(struct bpf_reg_state *src_reg,",
          "2446:       struct bpf_reg_state *dst_reg)",
          "2447: {",
          "2452:  src_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,",
          "2453:             dst_reg->var_off);",
          "2456: }",
          "2458: static void reg_combine_min_max(struct bpf_reg_state *true_src,",
          "",
          "[Removed Lines]",
          "2385:   true_reg->max_value = true_reg->min_value = val;",
          "2386:   true_reg->var_off = tnum_const(val);",
          "2392:   false_reg->max_value = false_reg->min_value = val;",
          "2393:   false_reg->var_off = tnum_const(val);",
          "2396:   value_from_signed = false;",
          "2399:   if (true_reg->value_from_signed != value_from_signed)",
          "2400:    reset_reg_range_values(true_reg, 0);",
          "2401:   if (false_reg->value_from_signed != value_from_signed)",
          "2402:    reset_reg_range_values(false_reg, 0);",
          "2403:   if (opcode == BPF_JGT) {",
          "2405:    true_reg->min_value = 0;",
          "2406:   }",
          "2411:   false_reg->min_value = val;",
          "2412:   false_reg->value_from_signed = value_from_signed;",
          "2413:   true_reg->max_value = val - 1;",
          "2414:   true_reg->value_from_signed = value_from_signed;",
          "2417:   value_from_signed = false;",
          "2420:   if (true_reg->value_from_signed != value_from_signed)",
          "2421:    reset_reg_range_values(true_reg, 0);",
          "2422:   if (false_reg->value_from_signed != value_from_signed)",
          "2423:    reset_reg_range_values(false_reg, 0);",
          "2424:   if (opcode == BPF_JGE) {",
          "2426:    true_reg->min_value = 0;",
          "2427:   }",
          "2431:   false_reg->min_value = val + 1;",
          "2432:   false_reg->value_from_signed = value_from_signed;",
          "2433:   true_reg->max_value = val;",
          "2434:   true_reg->value_from_signed = value_from_signed;",
          "2440:  check_reg_overflow(false_reg);",
          "2441:  check_reg_overflow(true_reg);",
          "2448:  src_reg->min_value = dst_reg->min_value = max(src_reg->min_value,",
          "2449:             dst_reg->min_value);",
          "2450:  src_reg->max_value = dst_reg->max_value = min(src_reg->max_value,",
          "2451:             dst_reg->max_value);",
          "2454:  check_reg_overflow(src_reg);",
          "2455:  check_reg_overflow(dst_reg);",
          "",
          "[Added Lines]",
          "2506:   __mark_reg_known(true_reg, val);",
          "2512:   __mark_reg_known(false_reg, val);",
          "2515:   true_reg->umax_value = min(true_reg->umax_value, val - 1);",
          "2516:   false_reg->umin_value = max(false_reg->umin_value, val);",
          "2517:   break;",
          "2519:   true_reg->smax_value = min_t(s64, true_reg->smax_value, val - 1);",
          "2520:   false_reg->smin_value = max_t(s64, false_reg->smin_value, val);",
          "2523:   true_reg->umax_value = min(true_reg->umax_value, val);",
          "2524:   false_reg->umin_value = max(false_reg->umin_value, val + 1);",
          "2525:   break;",
          "2527:   true_reg->smax_value = min_t(s64, true_reg->smax_value, val);",
          "2528:   false_reg->smin_value = max_t(s64, false_reg->smin_value, val + 1);",
          "2534:  __reg_deduce_bounds(false_reg);",
          "2535:  __reg_deduce_bounds(true_reg);",
          "2537:  __reg_bound_offset(false_reg);",
          "2538:  __reg_bound_offset(true_reg);",
          "2543:  __update_reg_bounds(false_reg);",
          "2544:  __update_reg_bounds(true_reg);",
          "2551:  src_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,",
          "2552:        dst_reg->umin_value);",
          "2553:  src_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,",
          "2554:        dst_reg->umax_value);",
          "2555:  src_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,",
          "2556:        dst_reg->smin_value);",
          "2557:  src_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,",
          "2558:        dst_reg->smax_value);",
          "2562:  __update_reg_bounds(src_reg);",
          "2563:  __update_reg_bounds(dst_reg);",
          "2565:  __reg_deduce_bounds(src_reg);",
          "2566:  __reg_deduce_bounds(dst_reg);",
          "2568:  __reg_bound_offset(src_reg);",
          "2569:  __reg_bound_offset(dst_reg);",
          "2574:  __update_reg_bounds(src_reg);",
          "2575:  __update_reg_bounds(dst_reg);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2467:   break;",
          "2468:  case BPF_JNE:",
          "2469:   __reg_combine_min_max(false_src, false_dst);",
          "2470:  }",
          "2471: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2590:   break;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2485:      reg->off)) {",
          "2488:   }",
          "2489:   if (is_null) {",
          "2490:    reg->type = SCALAR_VALUE;",
          "",
          "[Removed Lines]",
          "2483:   if (WARN_ON_ONCE(reg->min_value || reg->max_value ||",
          "2484:      reg->var_off.value || reg->var_off.mask ||",
          "2486:    reg->min_value = reg->max_value = reg->off = 0;",
          "2487:    reg->var_off = tnum_const(0);",
          "",
          "[Added Lines]",
          "2604:   if (WARN_ON_ONCE(reg->smin_value || reg->smax_value ||",
          "2605:      !tnum_equals_const(reg->var_off, 0) ||",
          "2607:    __mark_reg_known_zero(reg);",
          "2608:    reg->off = 0;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2676:   u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
          "2678:   regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2684:   return 0;",
          "2685:  }",
          "",
          "[Removed Lines]",
          "2679:   regs[insn->dst_reg].min_value = imm;",
          "2680:   regs[insn->dst_reg].max_value = imm;",
          "2681:   check_reg_overflow(&regs[insn->dst_reg]);",
          "2682:   regs[insn->dst_reg].var_off = tnum_const(imm);",
          "2683:   regs[insn->dst_reg].id = 0;",
          "",
          "[Added Lines]",
          "2800:   __mark_reg_known(&regs[insn->dst_reg], imm);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2968: static bool range_within(struct bpf_reg_state *old,",
          "2969:     struct bpf_reg_state *cur)",
          "2970: {",
          "2973: }",
          "",
          "[Removed Lines]",
          "2971:  return old->min_value <= cur->min_value &&",
          "2972:         old->max_value >= cur->max_value;",
          "",
          "[Added Lines]",
          "3088:  return old->umin_value <= cur->umin_value &&",
          "3089:         old->umax_value >= cur->umax_value &&",
          "3090:         old->smin_value <= cur->smin_value &&",
          "3091:         old->smax_value >= cur->smax_value;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3037:           tnum_is_unknown(rold->var_off);",
          "3038:   }",
          "3039:  case PTR_TO_MAP_VALUE:",
          "",
          "[Removed Lines]",
          "3035:    return rold->min_value == BPF_REGISTER_MIN_RANGE &&",
          "3036:           rold->max_value == BPF_REGISTER_MAX_RANGE &&",
          "",
          "[Added Lines]",
          "3154:    return rold->umin_value == 0 &&",
          "3155:           rold->umax_value == U64_MAX &&",
          "3156:           rold->smin_value == S64_MIN &&",
          "3157:           rold->smax_value == S64_MAX &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f1174f77b50c94eecaa658fdc56fa69b421de4b8",
      "candidate_info": {
        "commit_hash": "f1174f77b50c94eecaa658fdc56fa69b421de4b8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f1174f77b50c94eecaa658fdc56fa69b421de4b8",
        "files": [
          "drivers/net/ethernet/netronome/nfp/bpf/verifier.c",
          "include/linux/bpf.h",
          "include/linux/bpf_verifier.h",
          "include/linux/tnum.h",
          "kernel/bpf/Makefile",
          "kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf/verifier: rework value tracking\n\nUnifies adjusted and unadjusted register value types (e.g. FRAME_POINTER is\n now just a PTR_TO_STACK with zero offset).\nTracks value alignment by means of tracking known & unknown bits.  This\n also replaces the 'reg->imm' (leading zero bits) calculations for (what\n were) UNKNOWN_VALUEs.\nIf pointer leaks are allowed, and adjust_ptr_min_max_vals returns -EACCES,\n treat the pointer as an unknown scalar and try again, because we might be\n able to conclude something about the result (e.g. pointer & 0x40 is either\n 0 or 0x40).\nVerifier hooks in the netronome/nfp driver were changed to match the new\n data structures.\n\nSigned-off-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/netronome/nfp/bpf/verifier.c||drivers/net/ethernet/netronome/nfp/bpf/verifier.c",
          "include/linux/bpf.h||include/linux/bpf.h",
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "include/linux/tnum.h||include/linux/tnum.h",
          "kernel/bpf/tnum.c||kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/netronome/nfp/bpf/verifier.c||drivers/net/ethernet/netronome/nfp/bpf/verifier.c": [
          "File: drivers/net/ethernet/netronome/nfp/bpf/verifier.c -> drivers/net/ethernet/netronome/nfp/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:      const struct bpf_verifier_env *env)",
          "80: {",
          "81:  const struct bpf_reg_state *reg0 = &env->cur_state.regs[0];",
          "83:  if (nfp_prog->act == NN_ACT_XDP)",
          "84:   return 0;",
          "89:   return -EINVAL;",
          "90:  }",
          "94:   pr_info(\"unsupported exit state: %d, imm: %llx\\n\",",
          "96:   return -EINVAL;",
          "97:  }",
          "102:   pr_info(\"unsupported exit state: %d, imm: %llx\\n\",",
          "104:   return -EINVAL;",
          "105:  }",
          "",
          "[Removed Lines]",
          "86:  if (reg0->type != CONST_IMM) {",
          "87:   pr_info(\"unsupported exit state: %d, imm: %llx\\n\",",
          "88:    reg0->type, reg0->imm);",
          "92:  if (nfp_prog->act != NN_ACT_DIRECT &&",
          "93:      reg0->imm != 0 && (reg0->imm & ~0U) != ~0U) {",
          "95:    reg0->type, reg0->imm);",
          "99:  if (nfp_prog->act == NN_ACT_DIRECT && reg0->imm <= TC_ACT_REDIRECT &&",
          "100:      reg0->imm != TC_ACT_SHOT && reg0->imm != TC_ACT_STOLEN &&",
          "101:      reg0->imm != TC_ACT_QUEUED) {",
          "103:    reg0->type, reg0->imm);",
          "",
          "[Added Lines]",
          "82:  u64 imm;",
          "87:  if (!(reg0->type == SCALAR_VALUE && tnum_is_const(reg0->var_off))) {",
          "88:   char tn_buf[48];",
          "90:   tnum_strn(tn_buf, sizeof(tn_buf), reg0->var_off);",
          "91:   pr_info(\"unsupported exit state: %d, var_off: %s\\n\",",
          "92:    reg0->type, tn_buf);",
          "96:  imm = reg0->var_off.value;",
          "97:  if (nfp_prog->act != NN_ACT_DIRECT && imm != 0 && (imm & ~0U) != ~0U) {",
          "99:    reg0->type, imm);",
          "103:  if (nfp_prog->act == NN_ACT_DIRECT && imm <= TC_ACT_REDIRECT &&",
          "104:      imm != TC_ACT_SHOT && imm != TC_ACT_STOLEN &&",
          "105:      imm != TC_ACT_QUEUED) {",
          "107:    reg0->type, imm);",
          "",
          "---------------"
        ],
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "117: };",
          "120: enum bpf_reg_type {",
          "149: };",
          "151: struct bpf_prog;",
          "",
          "[Removed Lines]",
          "140:  PTR_TO_PACKET,",
          "148:  PTR_TO_MAP_VALUE_ADJ,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include <linux/tnum.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19: struct bpf_reg_state {",
          "20:  enum bpf_reg_type type;",
          "21:  union {",
          "34:   struct bpf_map *map_ptr;",
          "35:  };",
          "36:  u32 id;",
          "41:  s64 min_value;",
          "42:  u64 max_value;",
          "46:  bool value_from_signed;",
          "47: };",
          "",
          "[Removed Lines]",
          "23:   s64 imm;",
          "26:   struct {",
          "27:    u16 off;",
          "28:    u16 range;",
          "29:   };",
          "43:  u32 min_align;",
          "44:  u32 aux_off;",
          "45:  u32 aux_off_align;",
          "",
          "[Added Lines]",
          "24:   u16 range;",
          "32:  s32 off;",
          "46:  struct tnum var_off;",
          "",
          "---------------"
        ],
        "include/linux/tnum.h||include/linux/tnum.h": [
          "File: include/linux/tnum.h -> include/linux/tnum.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include <linux/types.h>",
          "10: struct tnum {",
          "11:  u64 value;",
          "12:  u64 mask;",
          "13: };",
          "17: struct tnum tnum_const(u64 value);",
          "19: extern const struct tnum tnum_unknown;",
          "23: struct tnum tnum_lshift(struct tnum a, u8 shift);",
          "25: struct tnum tnum_rshift(struct tnum a, u8 shift);",
          "27: struct tnum tnum_add(struct tnum a, struct tnum b);",
          "29: struct tnum tnum_sub(struct tnum a, struct tnum b);",
          "31: struct tnum tnum_and(struct tnum a, struct tnum b);",
          "33: struct tnum tnum_or(struct tnum a, struct tnum b);",
          "35: struct tnum tnum_xor(struct tnum a, struct tnum b);",
          "37: struct tnum tnum_mul(struct tnum a, struct tnum b);",
          "40: struct tnum tnum_intersect(struct tnum a, struct tnum b);",
          "43: struct tnum tnum_cast(struct tnum a, u8 size);",
          "46: static inline bool tnum_is_const(struct tnum a)",
          "47: {",
          "48:  return !a.mask;",
          "49: }",
          "52: static inline bool tnum_equals_const(struct tnum a, u64 b)",
          "53: {",
          "54:  return tnum_is_const(a) && a.value == b;",
          "55: }",
          "58: static inline bool tnum_is_unknown(struct tnum a)",
          "59: {",
          "60:  return !~a.mask;",
          "61: }",
          "66: bool tnum_is_aligned(struct tnum a, u64 size);",
          "69: bool tnum_in(struct tnum a, struct tnum b);",
          "77: int tnum_strn(char *str, size_t size, struct tnum a);",
          "79: int tnum_sbin(char *str, size_t size, struct tnum a);",
          "",
          "---------------"
        ],
        "kernel/bpf/tnum.c||kernel/bpf/tnum.c": [
          "File: kernel/bpf/tnum.c -> kernel/bpf/tnum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include <linux/kernel.h>",
          "9: #include <linux/tnum.h>",
          "11: #define TNUM(_v, _m) (struct tnum){.value = _v, .mask = _m}",
          "13: const struct tnum tnum_unknown = { .value = 0, .mask = -1 };",
          "15: struct tnum tnum_const(u64 value)",
          "16: {",
          "17:  return TNUM(value, 0);",
          "18: }",
          "20: struct tnum tnum_lshift(struct tnum a, u8 shift)",
          "21: {",
          "22:  return TNUM(a.value << shift, a.mask << shift);",
          "23: }",
          "25: struct tnum tnum_rshift(struct tnum a, u8 shift)",
          "26: {",
          "27:  return TNUM(a.value >> shift, a.mask >> shift);",
          "28: }",
          "30: struct tnum tnum_add(struct tnum a, struct tnum b)",
          "31: {",
          "32:  u64 sm, sv, sigma, chi, mu;",
          "34:  sm = a.mask + b.mask;",
          "35:  sv = a.value + b.value;",
          "36:  sigma = sm + sv;",
          "37:  chi = sigma ^ sv;",
          "38:  mu = chi | a.mask | b.mask;",
          "39:  return TNUM(sv & ~mu, mu);",
          "40: }",
          "42: struct tnum tnum_sub(struct tnum a, struct tnum b)",
          "43: {",
          "44:  u64 dv, alpha, beta, chi, mu;",
          "46:  dv = a.value - b.value;",
          "47:  alpha = dv + a.mask;",
          "48:  beta = dv - b.mask;",
          "49:  chi = alpha ^ beta;",
          "50:  mu = chi | a.mask | b.mask;",
          "51:  return TNUM(dv & ~mu, mu);",
          "52: }",
          "54: struct tnum tnum_and(struct tnum a, struct tnum b)",
          "55: {",
          "56:  u64 alpha, beta, v;",
          "58:  alpha = a.value | a.mask;",
          "59:  beta = b.value | b.mask;",
          "60:  v = a.value & b.value;",
          "61:  return TNUM(v, alpha & beta & ~v);",
          "62: }",
          "64: struct tnum tnum_or(struct tnum a, struct tnum b)",
          "65: {",
          "66:  u64 v, mu;",
          "68:  v = a.value | b.value;",
          "69:  mu = a.mask | b.mask;",
          "70:  return TNUM(v, mu & ~v);",
          "71: }",
          "73: struct tnum tnum_xor(struct tnum a, struct tnum b)",
          "74: {",
          "75:  u64 v, mu;",
          "77:  v = a.value ^ b.value;",
          "78:  mu = a.mask | b.mask;",
          "79:  return TNUM(v & ~mu, mu);",
          "80: }",
          "85: static struct tnum hma(struct tnum acc, u64 value, u64 mask)",
          "86: {",
          "87:  while (mask) {",
          "88:   if (mask & 1)",
          "89:    acc = tnum_add(acc, TNUM(0, value));",
          "90:   mask >>= 1;",
          "91:   value <<= 1;",
          "92:  }",
          "93:  return acc;",
          "94: }",
          "96: struct tnum tnum_mul(struct tnum a, struct tnum b)",
          "97: {",
          "98:  struct tnum acc;",
          "99:  u64 pi;",
          "101:  pi = a.value * b.value;",
          "102:  acc = hma(TNUM(pi, 0), a.mask, b.mask | b.value);",
          "103:  return hma(acc, b.mask, a.value);",
          "104: }",
          "109: struct tnum tnum_intersect(struct tnum a, struct tnum b)",
          "110: {",
          "111:  u64 v, mu;",
          "113:  v = a.value | b.value;",
          "114:  mu = a.mask & b.mask;",
          "115:  return TNUM(v & ~mu, mu);",
          "116: }",
          "118: struct tnum tnum_cast(struct tnum a, u8 size)",
          "119: {",
          "120:  a.value &= (1ULL << (size * 8)) - 1;",
          "121:  a.mask &= (1ULL << (size * 8)) - 1;",
          "122:  return a;",
          "123: }",
          "125: bool tnum_is_aligned(struct tnum a, u64 size)",
          "126: {",
          "127:  if (!size)",
          "128:   return true;",
          "129:  return !((a.value | a.mask) & (size - 1));",
          "130: }",
          "132: bool tnum_in(struct tnum a, struct tnum b)",
          "133: {",
          "134:  if (b.mask & ~a.mask)",
          "135:   return false;",
          "136:  b.value &= ~a.mask;",
          "137:  return a.value == b.value;",
          "138: }",
          "140: int tnum_strn(char *str, size_t size, struct tnum a)",
          "141: {",
          "142:  return snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);",
          "143: }",
          "144: EXPORT_SYMBOL_GPL(tnum_strn);",
          "146: int tnum_sbin(char *str, size_t size, struct tnum a)",
          "147: {",
          "148:  size_t n;",
          "150:  for (n = 64; n; n--) {",
          "151:   if (n < size) {",
          "152:    if (a.mask & 1)",
          "153:     str[n - 1] = 'x';",
          "154:    else if (a.value & 1)",
          "155:     str[n - 1] = '1';",
          "156:    else",
          "157:     str[n - 1] = '0';",
          "158:   }",
          "159:   a.mask >>= 1;",
          "160:   a.value >>= 1;",
          "161:  }",
          "162:  str[min(size - 1, (size_t)64)] = 0;",
          "163:  return 64;",
          "164: }",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "181: static const char * const reg_type_str[] = {",
          "182:  [NOT_INIT]  = \"?\",",
          "184:  [PTR_TO_CTX]  = \"ctx\",",
          "185:  [CONST_PTR_TO_MAP] = \"map_ptr\",",
          "186:  [PTR_TO_MAP_VALUE] = \"map_value\",",
          "187:  [PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",",
          "190:  [PTR_TO_STACK]  = \"fp\",",
          "192:  [PTR_TO_PACKET]  = \"pkt\",",
          "193:  [PTR_TO_PACKET_END] = \"pkt_end\",",
          "194: };",
          "",
          "[Removed Lines]",
          "183:  [UNKNOWN_VALUE]  = \"inv\",",
          "188:  [PTR_TO_MAP_VALUE_ADJ] = \"map_value_adj\",",
          "189:  [FRAME_PTR]  = \"fp\",",
          "191:  [CONST_IMM]  = \"imm\",",
          "",
          "[Added Lines]",
          "183:  [SCALAR_VALUE]  = \"inv\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "221:   if (t == NOT_INIT)",
          "222:    continue;",
          "223:   verbose(\" R%d=%s\", i, reg_type_str[t]);",
          "250:  }",
          "251:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "252:   if (state->stack_slot_type[i] == STACK_SPILL)",
          "",
          "[Removed Lines]",
          "224:   if (t == CONST_IMM || t == PTR_TO_STACK)",
          "225:    verbose(\"%lld\", reg->imm);",
          "226:   else if (t == PTR_TO_PACKET)",
          "227:    verbose(\"(id=%d,off=%d,r=%d)\",",
          "228:     reg->id, reg->off, reg->range);",
          "229:   else if (t == UNKNOWN_VALUE && reg->imm)",
          "230:    verbose(\"%lld\", reg->imm);",
          "231:   else if (t == CONST_PTR_TO_MAP || t == PTR_TO_MAP_VALUE ||",
          "232:     t == PTR_TO_MAP_VALUE_OR_NULL ||",
          "233:     t == PTR_TO_MAP_VALUE_ADJ)",
          "234:    verbose(\"(ks=%d,vs=%d,id=%u)\",",
          "235:     reg->map_ptr->key_size,",
          "236:     reg->map_ptr->value_size,",
          "237:     reg->id);",
          "238:   if (reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "239:    verbose(\",min_value=%lld\",",
          "240:     (long long)reg->min_value);",
          "241:   if (reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "242:    verbose(\",max_value=%llu\",",
          "243:     (unsigned long long)reg->max_value);",
          "244:   if (reg->min_align)",
          "245:    verbose(\",min_align=%u\", reg->min_align);",
          "246:   if (reg->aux_off)",
          "247:    verbose(\",aux_off=%u\", reg->aux_off);",
          "248:   if (reg->aux_off_align)",
          "249:    verbose(\",aux_off_align=%u\", reg->aux_off_align);",
          "",
          "[Added Lines]",
          "221:   if ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&",
          "222:       tnum_is_const(reg->var_off)) {",
          "224:    verbose(\"%lld\", reg->var_off.value + reg->off);",
          "225:   } else {",
          "226:    verbose(\"(id=%d\", reg->id);",
          "227:    if (t != SCALAR_VALUE)",
          "228:     verbose(\",off=%d\", reg->off);",
          "229:    if (t == PTR_TO_PACKET)",
          "230:     verbose(\",r=%d\", reg->range);",
          "231:    else if (t == CONST_PTR_TO_MAP ||",
          "232:      t == PTR_TO_MAP_VALUE ||",
          "233:      t == PTR_TO_MAP_VALUE_OR_NULL)",
          "234:     verbose(\",ks=%d,vs=%d\",",
          "235:      reg->map_ptr->key_size,",
          "236:      reg->map_ptr->value_size);",
          "237:    if (reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "238:     verbose(\",min_value=%lld\",",
          "239:      (long long)reg->min_value);",
          "240:    if (reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "241:     verbose(\",max_value=%llu\",",
          "242:      (unsigned long long)reg->max_value);",
          "243:    if (!tnum_is_unknown(reg->var_off)) {",
          "244:     char tn_buf[48];",
          "246:     tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "247:     verbose(\",var_off=%s\", tn_buf);",
          "248:    }",
          "249:    verbose(\")\");",
          "250:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "463:  BPF_REG_0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5",
          "464: };",
          "467: {",
          "474: }",
          "476: static void init_reg_state(struct bpf_reg_state *regs)",
          "",
          "[Removed Lines]",
          "466: static void mark_reg_not_init(struct bpf_reg_state *regs, u32 regno)",
          "468:  BUG_ON(regno >= MAX_BPF_REG);",
          "470:  memset(&regs[regno], 0, sizeof(regs[regno]));",
          "471:  regs[regno].type = NOT_INIT;",
          "472:  regs[regno].min_value = BPF_REGISTER_MIN_RANGE;",
          "473:  regs[regno].max_value = BPF_REGISTER_MAX_RANGE;",
          "",
          "[Added Lines]",
          "467: static void __mark_reg_not_init(struct bpf_reg_state *reg);",
          "472: static void __mark_reg_known_zero(struct bpf_reg_state *reg)",
          "474:  reg->var_off = tnum_const(0);",
          "475:  reg->min_value = 0;",
          "476:  reg->max_value = 0;",
          "477: }",
          "479: static void mark_reg_known_zero(struct bpf_reg_state *regs, u32 regno)",
          "480: {",
          "481:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "482:   verbose(\"mark_reg_known_zero(regs, %u)\\n\", regno);",
          "484:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "485:    __mark_reg_not_init(regs + regno);",
          "486:   return;",
          "487:  }",
          "488:  __mark_reg_known_zero(regs + regno);",
          "489: }",
          "492: static void __mark_reg_unknown(struct bpf_reg_state *reg)",
          "493: {",
          "494:  reg->type = SCALAR_VALUE;",
          "495:  reg->id = 0;",
          "496:  reg->off = 0;",
          "497:  reg->var_off = tnum_unknown;",
          "498:  reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "499:  reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "500: }",
          "502: static void mark_reg_unknown(struct bpf_reg_state *regs, u32 regno)",
          "503: {",
          "504:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "505:   verbose(\"mark_reg_unknown(regs, %u)\\n\", regno);",
          "507:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "508:    __mark_reg_not_init(regs + regno);",
          "509:   return;",
          "510:  }",
          "511:  __mark_reg_unknown(regs + regno);",
          "512: }",
          "514: static void __mark_reg_not_init(struct bpf_reg_state *reg)",
          "515: {",
          "516:  __mark_reg_unknown(reg);",
          "517:  reg->type = NOT_INIT;",
          "518: }",
          "520: static void mark_reg_not_init(struct bpf_reg_state *regs, u32 regno)",
          "521: {",
          "522:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "523:   verbose(\"mark_reg_not_init(regs, %u)\\n\", regno);",
          "525:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "526:    __mark_reg_not_init(regs + regno);",
          "527:   return;",
          "528:  }",
          "529:  __mark_reg_not_init(regs + regno);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "481:   mark_reg_not_init(regs, i);",
          "487:  regs[BPF_REG_1].type = PTR_TO_CTX;",
          "501: }",
          "503: static void reset_reg_range_values(struct bpf_reg_state *regs, u32 regno)",
          "",
          "[Removed Lines]",
          "484:  regs[BPF_REG_FP].type = FRAME_PTR;",
          "488: }",
          "490: static void __mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)",
          "491: {",
          "492:  regs[regno].type = UNKNOWN_VALUE;",
          "493:  regs[regno].id = 0;",
          "494:  regs[regno].imm = 0;",
          "495: }",
          "497: static void mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)",
          "498: {",
          "499:  BUG_ON(regno >= MAX_BPF_REG);",
          "500:  __mark_reg_unknown_value(regs, regno);",
          "",
          "[Added Lines]",
          "540:  regs[BPF_REG_FP].type = PTR_TO_STACK;",
          "541:  mark_reg_known_zero(regs, BPF_REG_FP);",
          "545:  mark_reg_known_zero(regs, BPF_REG_1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "505:  regs[regno].min_value = BPF_REGISTER_MIN_RANGE;",
          "506:  regs[regno].max_value = BPF_REGISTER_MAX_RANGE;",
          "507:  regs[regno].value_from_signed = false;",
          "516: }",
          "518: enum reg_arg_type {",
          "",
          "[Removed Lines]",
          "508:  regs[regno].min_align = 0;",
          "509: }",
          "511: static void mark_reg_unknown_value_and_range(struct bpf_reg_state *regs,",
          "512:           u32 regno)",
          "513: {",
          "514:  mark_reg_unknown_value(regs, regno);",
          "515:  reset_reg_range_values(regs, regno);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "542:    return -EACCES;",
          "543:   }",
          "544:   if (t == DST_OP)",
          "546:  }",
          "547:  return 0;",
          "548: }",
          "",
          "[Removed Lines]",
          "545:    mark_reg_unknown_value(regs, regno);",
          "",
          "[Added Lines]",
          "582:    mark_reg_unknown(regs, regno);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "552:  switch (type) {",
          "553:  case PTR_TO_MAP_VALUE:",
          "554:  case PTR_TO_MAP_VALUE_OR_NULL:",
          "556:  case PTR_TO_STACK:",
          "557:  case PTR_TO_CTX:",
          "558:  case PTR_TO_PACKET:",
          "559:  case PTR_TO_PACKET_END:",
          "561:  case CONST_PTR_TO_MAP:",
          "562:   return true;",
          "563:  default:",
          "",
          "[Removed Lines]",
          "555:  case PTR_TO_MAP_VALUE_ADJ:",
          "560:  case FRAME_PTR:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "637:   }",
          "638:   if (value_regno >= 0)",
          "642:   return 0;",
          "643:  }",
          "644: }",
          "648:        int size)",
          "649: {",
          "650:  struct bpf_map *map = env->cur_state.regs[regno].map_ptr;",
          "",
          "[Removed Lines]",
          "640:    mark_reg_unknown_value_and_range(state->regs,",
          "641:         value_regno);",
          "647: static int check_map_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "",
          "[Added Lines]",
          "675:    mark_reg_unknown(state->regs, value_regno);",
          "681: static int __check_map_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "657:  return 0;",
          "658: }",
          "662:     int off, int size)",
          "663: {",
          "664:  struct bpf_verifier_state *state = &env->cur_state;",
          "665:  struct bpf_reg_state *reg = &state->regs[regno];",
          "666:  int err;",
          "673:  if (log_level)",
          "674:   print_verifier_state(state);",
          "",
          "[Removed Lines]",
          "661: static int check_map_access_adj(struct bpf_verifier_env *env, u32 regno,",
          "675:  env->varlen_map_value_access = true;",
          "",
          "[Added Lines]",
          "695: static int check_map_access(struct bpf_verifier_env *env, u32 regno,",
          "711:  if (!tnum_is_const(reg->var_off))",
          "712:   env->varlen_map_value_access = true;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "684:    regno);",
          "685:   return -EACCES;",
          "686:  }",
          "688:  if (err) {",
          "691:   return err;",
          "692:  }",
          "",
          "[Removed Lines]",
          "687:  err = check_map_access(env, regno, reg->min_value + off, size);",
          "689:   verbose(\"R%d min value is outside of the array range\\n\",",
          "690:    regno);",
          "",
          "[Added Lines]",
          "724:  err = __check_map_access(env, regno, reg->min_value + off, size);",
          "726:   verbose(\"R%d min value is outside of the array range\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "699:    regno);",
          "700:   return -EACCES;",
          "701:  }",
          "703: }",
          "705: #define MAX_PACKET_OFF 0xffff",
          "",
          "[Removed Lines]",
          "702:  return check_map_access(env, regno, reg->max_value + off, size);",
          "",
          "[Added Lines]",
          "738:  err = __check_map_access(env, regno, reg->max_value + off, size);",
          "739:  if (err)",
          "740:   verbose(\"R%d max value is outside of the array range\\n\", regno);",
          "741:  return err;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "729:  }",
          "730: }",
          "734: {",
          "735:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "736:  struct bpf_reg_state *reg = &regs[regno];",
          "740:   verbose(\"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",",
          "741:    off, size, regno, reg->id, reg->off, reg->range);",
          "742:   return -EACCES;",
          "",
          "[Removed Lines]",
          "732: static int check_packet_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "733:           int size)",
          "738:  off += reg->off;",
          "739:  if (off < 0 || size <= 0 || off + size > reg->range) {",
          "",
          "[Added Lines]",
          "771: static int __check_packet_access(struct bpf_verifier_env *env, u32 regno,",
          "772:      int off, int size)",
          "777:  if (off < 0 || size <= 0 || (u64)off + size > reg->range) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "744:  return 0;",
          "745: }",
          "748: static int check_ctx_access(struct bpf_verifier_env *env, int insn_idx, int off, int size,",
          "749:        enum bpf_access_type t, enum bpf_reg_type *reg_type)",
          "750: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "785: static int check_packet_access(struct bpf_verifier_env *env, u32 regno, int off,",
          "786:           int size)",
          "787: {",
          "788:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "789:  struct bpf_reg_state *reg = &regs[regno];",
          "790:  int err;",
          "800:  if (reg->min_value < 0) {",
          "801:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "802:    regno);",
          "803:   return -EACCES;",
          "804:  }",
          "805:  err = __check_packet_access(env, regno, off, size);",
          "806:  if (err) {",
          "807:   verbose(\"R%d offset is outside of the packet\\n\", regno);",
          "808:   return err;",
          "809:  }",
          "810:  return err;",
          "811: }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "784:  if (allow_ptr_leaks)",
          "785:   return false;",
          "794: }",
          "796: static bool is_pointer_value(struct bpf_verifier_env *env, int regno)",
          "",
          "[Removed Lines]",
          "787:  switch (reg->type) {",
          "788:  case UNKNOWN_VALUE:",
          "789:  case CONST_IMM:",
          "790:   return false;",
          "791:  default:",
          "792:   return true;",
          "793:  }",
          "",
          "[Added Lines]",
          "853:  return reg->type != SCALAR_VALUE;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "801: static int check_pkt_ptr_alignment(const struct bpf_reg_state *reg,",
          "802:        int off, int size, bool strict)",
          "803: {",
          "804:  int ip_align;",
          "808:  if (!strict || size == 1)",
          "809:   return 0;",
          "",
          "[Removed Lines]",
          "805:  int reg_off;",
          "811:  reg_off = reg->off;",
          "812:  if (reg->id) {",
          "813:   if (reg->aux_off_align % size) {",
          "814:    verbose(\"Packet access is only %u byte aligned, %d byte access not allowed\\n\",",
          "815:     reg->aux_off_align, size);",
          "816:    return -EACCES;",
          "817:   }",
          "818:   reg_off += reg->aux_off;",
          "819:  }",
          "",
          "[Added Lines]",
          "864:  struct tnum reg_off;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "829:  ip_align = 2;",
          "833:   return -EACCES;",
          "834:  }",
          "836:  return 0;",
          "837: }",
          "841: {",
          "844:   return -EACCES;",
          "845:  }",
          "",
          "[Removed Lines]",
          "830:  if ((ip_align + reg_off + off) % size != 0) {",
          "831:   verbose(\"misaligned packet access off %d+%d+%d size %d\\n\",",
          "832:    ip_align, reg_off, off, size);",
          "839: static int check_val_ptr_alignment(const struct bpf_reg_state *reg,",
          "840:        int size, bool strict)",
          "842:  if (strict && size != 1) {",
          "843:   verbose(\"Unknown alignment. Only byte-sized access allowed in value access.\\n\");",
          "",
          "[Added Lines]",
          "881:  reg_off = tnum_add(reg->var_off, tnum_const(ip_align + reg->off + off));",
          "882:  if (!tnum_is_aligned(reg_off, size)) {",
          "883:   char tn_buf[48];",
          "885:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "886:   verbose(\"misaligned packet access off %d+%s+%d+%d size %d\\n\",",
          "887:    ip_align, tn_buf, reg->off, off, size);",
          "894: static int check_generic_ptr_alignment(const struct bpf_reg_state *reg,",
          "895:            const char *pointer_desc,",
          "896:            int off, int size, bool strict)",
          "898:  struct tnum reg_off;",
          "901:  if (!strict || size == 1)",
          "902:   return 0;",
          "904:  reg_off = tnum_add(reg->var_off, tnum_const(reg->off + off));",
          "905:  if (!tnum_is_aligned(reg_off, size)) {",
          "906:   char tn_buf[48];",
          "908:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "909:   verbose(\"misaligned %saccess off %s+%d+%d size %d\\n\",",
          "910:    pointer_desc, tn_buf, reg->off, off, size);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "852:           int off, int size)",
          "853: {",
          "854:  bool strict = env->strict_alignment;",
          "856:  switch (reg->type) {",
          "857:  case PTR_TO_PACKET:",
          "858:   return check_pkt_ptr_alignment(reg, off, size, strict);",
          "861:  default:",
          "869:  }",
          "870: }",
          "",
          "[Removed Lines]",
          "859:  case PTR_TO_MAP_VALUE_ADJ:",
          "860:   return check_val_ptr_alignment(reg, size, strict);",
          "862:   if (off % size != 0) {",
          "863:    verbose(\"misaligned access off %d size %d\\n\",",
          "864:     off, size);",
          "865:    return -EACCES;",
          "866:   }",
          "868:   return 0;",
          "",
          "[Added Lines]",
          "922:  const char *pointer_desc = \"\";",
          "928:  case PTR_TO_MAP_VALUE:",
          "929:   pointer_desc = \"value \";",
          "930:   break;",
          "931:  case PTR_TO_CTX:",
          "932:   pointer_desc = \"context \";",
          "933:   break;",
          "934:  case PTR_TO_STACK:",
          "935:   pointer_desc = \"stack \";",
          "936:   break;",
          "938:   break;",
          "940:  return check_generic_ptr_alignment(reg, pointer_desc, off, size, strict);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "883:  struct bpf_reg_state *reg = &state->regs[regno];",
          "884:  int size, err = 0;",
          "889:  size = bpf_size_to_bytes(bpf_size);",
          "890:  if (size < 0)",
          "891:   return size;",
          "893:  err = check_ptr_alignment(env, reg, off, size);",
          "894:  if (err)",
          "895:   return err;",
          "899:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "900:       is_pointer_value(env, value_regno)) {",
          "901:    verbose(\"R%d leaks addr into map\\n\", value_regno);",
          "902:    return -EACCES;",
          "903:   }",
          "909:   if (!err && t == BPF_READ && value_regno >= 0)",
          "913:  } else if (reg->type == PTR_TO_CTX) {",
          "916:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "917:       is_pointer_value(env, value_regno)) {",
          "918:    verbose(\"R%d leaks addr into ctx\\n\", value_regno);",
          "919:    return -EACCES;",
          "920:   }",
          "921:   err = check_ctx_access(env, insn_idx, off, size, t, &reg_type);",
          "922:   if (!err && t == BPF_READ && value_regno >= 0) {",
          "926:    state->regs[value_regno].type = reg_type;",
          "929:   }",
          "932:   if (off >= 0 || off < -MAX_BPF_STACK) {",
          "933:    verbose(\"invalid stack off=%d size=%d\\n\", off, size);",
          "934:    return -EACCES;",
          "",
          "[Removed Lines]",
          "886:  if (reg->type == PTR_TO_STACK)",
          "887:   off += reg->imm;",
          "897:  if (reg->type == PTR_TO_MAP_VALUE ||",
          "898:      reg->type == PTR_TO_MAP_VALUE_ADJ) {",
          "905:   if (reg->type == PTR_TO_MAP_VALUE_ADJ)",
          "906:    err = check_map_access_adj(env, regno, off, size);",
          "907:   else",
          "908:    err = check_map_access(env, regno, off, size);",
          "910:    mark_reg_unknown_value_and_range(state->regs,",
          "911:         value_regno);",
          "914:   enum bpf_reg_type reg_type = UNKNOWN_VALUE;",
          "923:    mark_reg_unknown_value_and_range(state->regs,",
          "924:         value_regno);",
          "927:    state->regs[value_regno].aux_off = 0;",
          "928:    state->regs[value_regno].aux_off_align = 0;",
          "931:  } else if (reg->type == FRAME_PTR || reg->type == PTR_TO_STACK) {",
          "",
          "[Added Lines]",
          "967:  off += reg->off;",
          "969:  if (reg->type == PTR_TO_MAP_VALUE) {",
          "976:   err = check_map_access(env, regno, off, size);",
          "978:    mark_reg_unknown(state->regs, value_regno);",
          "981:   enum bpf_reg_type reg_type = SCALAR_VALUE;",
          "991:   if (!tnum_is_const(reg->var_off)) {",
          "992:    char tn_buf[48];",
          "994:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "995:    verbose(\"variable ctx access var_off=%s off=%d size=%d\",",
          "996:     tn_buf, off, size);",
          "997:    return -EACCES;",
          "998:   }",
          "999:   off += reg->var_off.value;",
          "1006:    if (reg_type == SCALAR_VALUE)",
          "1007:     mark_reg_unknown(state->regs, value_regno);",
          "1008:    else",
          "1009:     mark_reg_known_zero(state->regs, value_regno);",
          "1010:    state->regs[value_regno].id = 0;",
          "1011:    state->regs[value_regno].off = 0;",
          "1012:    state->regs[value_regno].range = 0;",
          "1016:  } else if (reg->type == PTR_TO_STACK) {",
          "1021:   if (!tnum_is_const(reg->var_off)) {",
          "1022:    char tn_buf[48];",
          "1024:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1025:    verbose(\"variable stack access var_off=%s off=%d size=%d\",",
          "1026:     tn_buf, off, size);",
          "1027:    return -EACCES;",
          "1028:   }",
          "1029:   off += reg->var_off.value;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "948:   } else {",
          "949:    err = check_stack_read(state, off, size, value_regno);",
          "950:   }",
          "952:   if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {",
          "953:    verbose(\"cannot write into packet\\n\");",
          "954:    return -EACCES;",
          "",
          "[Removed Lines]",
          "951:  } else if (state->regs[regno].type == PTR_TO_PACKET) {",
          "",
          "[Added Lines]",
          "1049:  } else if (reg->type == PTR_TO_PACKET) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "960:   }",
          "961:   err = check_packet_access(env, regno, off, size);",
          "962:   if (!err && t == BPF_READ && value_regno >= 0)",
          "965:  } else {",
          "966:   verbose(\"R%d invalid mem access '%s'\\n\",",
          "967:    regno, reg_type_str[reg->type]);",
          "968:   return -EACCES;",
          "969:  }",
          "978:  }",
          "979:  return err;",
          "980: }",
          "",
          "[Removed Lines]",
          "963:    mark_reg_unknown_value_and_range(state->regs,",
          "964:         value_regno);",
          "971:  if (!err && size <= 2 && value_regno >= 0 && env->allow_ptr_leaks &&",
          "972:      state->regs[value_regno].type == UNKNOWN_VALUE) {",
          "977:   state->regs[value_regno].imm = 64 - size * 8;",
          "",
          "[Added Lines]",
          "1061:    mark_reg_unknown(state->regs, value_regno);",
          "1068:  if (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&",
          "1069:      state->regs[value_regno].type == SCALAR_VALUE) {",
          "1071:   state->regs[value_regno].var_off = tnum_cast(",
          "1072:      state->regs[value_regno].var_off, size);",
          "1074:   state->regs[value_regno].min_value = 0;",
          "1075:   state->regs[value_regno].max_value = min_t(u64,",
          "1076:      state->regs[value_regno].var_off.value |",
          "1077:      state->regs[value_regno].var_off.mask,",
          "1078:      BPF_REGISTER_MAX_RANGE);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1016:     BPF_SIZE(insn->code), BPF_WRITE, -1);",
          "1017: }",
          "1023: static int check_stack_boundary(struct bpf_verifier_env *env, int regno,",
          "1024:     int access_size, bool zero_size_allowed,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1121: static bool register_is_null(struct bpf_reg_state reg)",
          "1122: {",
          "1123:  return reg.type == SCALAR_VALUE && tnum_equals_const(reg.var_off, 0);",
          "1124: }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1029:  int off, i;",
          "1031:  if (regs[regno].type != PTR_TO_STACK) {",
          "1032:   if (zero_size_allowed && access_size == 0 &&",
          "1035:    return 0;",
          "1037:   verbose(\"R%d type=%s expected=%s\\n\", regno,",
          "",
          "[Removed Lines]",
          "1033:       regs[regno].type == CONST_IMM &&",
          "1034:       regs[regno].imm  == 0)",
          "",
          "[Added Lines]",
          "1143:       register_is_null(regs[regno]))",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1040:   return -EACCES;",
          "1041:  }",
          "1044:  if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",
          "1045:      access_size <= 0) {",
          "1046:   verbose(\"invalid stack type R%d off=%d access_size=%d\\n\",",
          "",
          "[Removed Lines]",
          "1043:  off = regs[regno].imm;",
          "",
          "[Added Lines]",
          "1153:  if (!tnum_is_const(regs[regno].var_off)) {",
          "1154:   char tn_buf[48];",
          "1156:   tnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);",
          "1157:   verbose(\"invalid variable stack read R%d var_off=%s\\n\",",
          "1158:    regno, tn_buf);",
          "1159:  }",
          "1160:  off = regs[regno].off + regs[regno].var_off.value;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1071:        int access_size, bool zero_size_allowed,",
          "1072:        struct bpf_call_arg_meta *meta)",
          "1073: {",
          "1077:  case PTR_TO_PACKET:",
          "1079:  case PTR_TO_MAP_VALUE:",
          "1084:   return check_stack_boundary(env, regno, access_size,",
          "1085:          zero_size_allowed, meta);",
          "1086:  }",
          "",
          "[Removed Lines]",
          "1074:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1076:  switch (regs[regno].type) {",
          "1078:   return check_packet_access(env, regno, 0, access_size);",
          "1080:   return check_map_access(env, regno, 0, access_size);",
          "1081:  case PTR_TO_MAP_VALUE_ADJ:",
          "1082:   return check_map_access_adj(env, regno, 0, access_size);",
          "",
          "[Added Lines]",
          "1191:  struct bpf_reg_state *regs = env->cur_state.regs, *reg = &regs[regno];",
          "1193:  switch (reg->type) {",
          "1195:   return check_packet_access(env, regno, reg->off, access_size);",
          "1197:   return check_map_access(env, regno, reg->off, access_size);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1123:    goto err_type;",
          "1124:  } else if (arg_type == ARG_CONST_SIZE ||",
          "1125:      arg_type == ARG_CONST_SIZE_OR_ZERO) {",
          "1131:    goto err_type;",
          "1132:  } else if (arg_type == ARG_CONST_MAP_PTR) {",
          "1133:   expected_type = CONST_PTR_TO_MAP;",
          "",
          "[Removed Lines]",
          "1126:   expected_type = CONST_IMM;",
          "1130:   if (type != UNKNOWN_VALUE && type != expected_type)",
          "",
          "[Added Lines]",
          "1241:   expected_type = SCALAR_VALUE;",
          "1242:   if (type != expected_type)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1141:      arg_type == ARG_PTR_TO_UNINIT_MEM) {",
          "1142:   expected_type = PTR_TO_STACK;",
          "1149:   else if (type != PTR_TO_PACKET && type != PTR_TO_MAP_VALUE &&",
          "1151:    goto err_type;",
          "1152:   meta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;",
          "1153:  } else {",
          "",
          "[Removed Lines]",
          "1147:   if (type == CONST_IMM && reg->imm == 0)",
          "1150:     type != PTR_TO_MAP_VALUE_ADJ && type != expected_type)",
          "",
          "[Added Lines]",
          "1259:   if (register_is_null(*reg))",
          "1262:     type != expected_type)",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1173:    return -EACCES;",
          "1174:   }",
          "1175:   if (type == PTR_TO_PACKET)",
          "1177:         meta->map_ptr->key_size);",
          "1178:   else",
          "1179:    err = check_stack_boundary(env, regno,",
          "",
          "[Removed Lines]",
          "1176:    err = check_packet_access(env, regno, 0,",
          "",
          "[Added Lines]",
          "1288:    err = check_packet_access(env, regno, reg->off,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1189:    return -EACCES;",
          "1190:   }",
          "1191:   if (type == PTR_TO_PACKET)",
          "1193:         meta->map_ptr->value_size);",
          "1194:   else",
          "1195:    err = check_stack_boundary(env, regno,",
          "",
          "[Removed Lines]",
          "1192:    err = check_packet_access(env, regno, 0,",
          "",
          "[Added Lines]",
          "1304:    err = check_packet_access(env, regno, reg->off,",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1209:    return -EACCES;",
          "1210:   }",
          "",
          "[Removed Lines]",
          "1215:   if (type == UNKNOWN_VALUE) {",
          "",
          "[Added Lines]",
          "1328:   if (!tnum_is_const(reg->var_off))",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1221:    meta = NULL;",
          "1245:    if (err)",
          "1246:     return err;",
          "1251:   }",
          "1252:  }",
          "1254:  return err;",
          "",
          "[Removed Lines]",
          "1223:    if (reg->min_value < 0) {",
          "1224:     verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "1225:      regno);",
          "1226:     return -EACCES;",
          "1227:    }",
          "1229:    if (reg->min_value == 0) {",
          "1230:     err = check_helper_mem_access(env, regno - 1, 0,",
          "1231:              zero_size_allowed,",
          "1232:              meta);",
          "1233:     if (err)",
          "1234:      return err;",
          "1235:    }",
          "1237:    if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "1238:     verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "1239:      regno);",
          "1240:     return -EACCES;",
          "1241:    }",
          "1242:    err = check_helper_mem_access(env, regno - 1,",
          "1243:             reg->max_value,",
          "1244:             zero_size_allowed, meta);",
          "1247:   } else {",
          "1249:    err = check_helper_mem_access(env, regno - 1, reg->imm,",
          "1250:             zero_size_allowed, meta);",
          "",
          "[Added Lines]",
          "1336:   if (reg->min_value < 0) {",
          "1337:    verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "1338:     regno);",
          "1339:    return -EACCES;",
          "1340:   }",
          "1342:   if (reg->min_value == 0) {",
          "1343:    err = check_helper_mem_access(env, regno - 1, 0,",
          "1344:             zero_size_allowed,",
          "1345:             meta);",
          "1350:   if (reg->max_value == BPF_REGISTER_MAX_RANGE) {",
          "1351:    verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "1352:     regno);",
          "1353:    return -EACCES;",
          "1354:   }",
          "1355:   err = check_helper_mem_access(env, regno - 1,",
          "1356:            reg->max_value,",
          "1357:            zero_size_allowed, meta);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1361:  for (i = 0; i < MAX_BPF_REG; i++)",
          "1362:   if (regs[i].type == PTR_TO_PACKET ||",
          "1363:       regs[i].type == PTR_TO_PACKET_END)",
          "1366:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "1367:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "",
          "[Removed Lines]",
          "1364:    mark_reg_unknown_value(regs, i);",
          "",
          "[Added Lines]",
          "1473:    mark_reg_unknown(regs, i);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1370:   if (reg->type != PTR_TO_PACKET &&",
          "1371:       reg->type != PTR_TO_PACKET_END)",
          "1372:    continue;",
          "1375:  }",
          "1376: }",
          "",
          "[Removed Lines]",
          "1373:   __mark_reg_unknown_value(state->spilled_regs,",
          "1374:       i / BPF_REG_SIZE);",
          "",
          "[Added Lines]",
          "1482:   __mark_reg_unknown(reg);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1453:  if (fn->ret_type == RET_INTEGER) {",
          "1455:  } else if (fn->ret_type == RET_VOID) {",
          "1456:   regs[BPF_REG_0].type = NOT_INIT;",
          "1457:  } else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {",
          "1458:   struct bpf_insn_aux_data *insn_aux;",
          "1460:   regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;",
          "",
          "[Removed Lines]",
          "1454:   regs[BPF_REG_0].type = UNKNOWN_VALUE;",
          "1461:   regs[BPF_REG_0].max_value = regs[BPF_REG_0].min_value = 0;",
          "",
          "[Added Lines]",
          "1563:   mark_reg_unknown(regs, BPF_REG_0);",
          "1571:   mark_reg_known_zero(regs, BPF_REG_0);",
          "1572:   regs[BPF_REG_0].off = 0;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1489:  return 0;",
          "1490: }",
          "1494: {",
          "1573:  }",
          "1575: }",
          "1578: {",
          "1581:  u8 opcode = BPF_OP(insn->code);",
          "1620:  }",
          "1729:   }",
          "1732:  }",
          "1735:  return 0;",
          "1736: }",
          "1740: {",
          "1741:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1819:  s64 min_val = BPF_REGISTER_MIN_RANGE;",
          "1820:  u64 max_val = BPF_REGISTER_MAX_RANGE;",
          "1821:  u8 opcode = BPF_OP(insn->code);",
          "1885:  }",
          "1887:  switch (opcode) {",
          "1888:  case BPF_ADD:",
          "1889:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1890:    dst_reg->min_value += min_val;",
          "1891:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1892:    dst_reg->max_value += max_val;",
          "1894:   break;",
          "1895:  case BPF_SUB:",
          "1901:   if (max_val == BPF_REGISTER_MAX_RANGE)",
          "1902:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1903:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1904:    dst_reg->min_value -= max_val;",
          "1905:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1906:    dst_reg->max_value -= min_val;",
          "1908:   break;",
          "1909:  case BPF_MUL:",
          "1912:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1913:    dst_reg->max_value *= max_val;",
          "1915:   break;",
          "1916:  case BPF_AND:",
          "1922:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1923:   else",
          "1927:   break;",
          "1928:  case BPF_LSH:",
          "1933:   if (min_val > ilog2(BPF_REGISTER_MAX_RANGE)) {",
          "1934:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1936:   } else {",
          "1937:    if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1938:     dst_reg->min_value <<= min_val;",
          "1942:   }",
          "1943:   if (max_val > ilog2(BPF_REGISTER_MAX_RANGE))",
          "1944:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "",
          "[Removed Lines]",
          "1492: static int check_packet_ptr_add(struct bpf_verifier_env *env,",
          "1493:     struct bpf_insn *insn)",
          "1495:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1496:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1497:  struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1498:  struct bpf_reg_state tmp_reg;",
          "1499:  s32 imm;",
          "1501:  if (BPF_SRC(insn->code) == BPF_K) {",
          "1503:   imm = insn->imm;",
          "1505: add_imm:",
          "1506:   if (imm < 0) {",
          "1507:    verbose(\"addition of negative constant to packet pointer is not allowed\\n\");",
          "1508:    return -EACCES;",
          "1509:   }",
          "1510:   if (imm >= MAX_PACKET_OFF ||",
          "1511:       imm + dst_reg->off >= MAX_PACKET_OFF) {",
          "1512:    verbose(\"constant %d is too large to add to packet pointer\\n\",",
          "1513:     imm);",
          "1514:    return -EACCES;",
          "1515:   }",
          "1519:   dst_reg->off += imm;",
          "1520:  } else {",
          "1521:   bool had_id;",
          "1523:   if (src_reg->type == PTR_TO_PACKET) {",
          "1534:   }",
          "1536:   if (src_reg->type == CONST_IMM) {",
          "1538:    imm = src_reg->imm;",
          "1539:    goto add_imm;",
          "1540:   }",
          "1546:   if (src_reg->type != UNKNOWN_VALUE) {",
          "1547:    verbose(\"cannot add '%s' to ptr_to_packet\\n\",",
          "1548:     reg_type_str[src_reg->type]);",
          "1549:    return -EACCES;",
          "1550:   }",
          "1551:   if (src_reg->imm < 48) {",
          "1552:    verbose(\"cannot add integer value with %lld upper zero bits to ptr_to_packet\\n\",",
          "1553:     src_reg->imm);",
          "1554:    return -EACCES;",
          "1555:   }",
          "1557:   had_id = (dst_reg->id != 0);",
          "1562:   dst_reg->id = ++env->id_gen;",
          "1565:   dst_reg->aux_off += dst_reg->off;",
          "1566:   dst_reg->off = 0;",
          "1567:   dst_reg->range = 0;",
          "1568:   if (had_id)",
          "1569:    dst_reg->aux_off_align = min(dst_reg->aux_off_align,",
          "1570:            src_reg->min_align);",
          "1571:   else",
          "1572:    dst_reg->aux_off_align = src_reg->min_align;",
          "1574:  return 0;",
          "1577: static int evaluate_reg_alu(struct bpf_verifier_env *env, struct bpf_insn *insn)",
          "1579:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1580:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1582:  s64 imm_log2;",
          "1589:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1590:   struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1592:   if (src_reg->type == UNKNOWN_VALUE && src_reg->imm > 0 &&",
          "1593:       dst_reg->imm && opcode == BPF_ADD) {",
          "1601:    dst_reg->imm = min(dst_reg->imm, src_reg->imm);",
          "1602:    dst_reg->imm--;",
          "1603:    return 0;",
          "1604:   }",
          "1605:   if (src_reg->type == CONST_IMM && src_reg->imm > 0 &&",
          "1606:       dst_reg->imm && opcode == BPF_ADD) {",
          "1612:    imm_log2 = __ilog2_u64((long long)src_reg->imm);",
          "1613:    dst_reg->imm = min(dst_reg->imm, 63 - imm_log2);",
          "1614:    dst_reg->imm--;",
          "1615:    return 0;",
          "1616:   }",
          "1618:   dst_reg->imm = 0;",
          "1619:   return 0;",
          "1626:  imm_log2 = __ilog2_u64((long long)insn->imm);",
          "1628:  if (dst_reg->imm && opcode == BPF_LSH) {",
          "1634:   dst_reg->imm -= insn->imm;",
          "1635:  } else if (dst_reg->imm && opcode == BPF_MUL) {",
          "1641:   dst_reg->imm -= imm_log2 + 1;",
          "1642:  } else if (opcode == BPF_AND) {",
          "1644:   dst_reg->imm = 63 - imm_log2;",
          "1645:  } else if (dst_reg->imm && opcode == BPF_ADD) {",
          "1647:   dst_reg->imm = min(dst_reg->imm, 63 - imm_log2);",
          "1648:   dst_reg->imm--;",
          "1649:  } else if (opcode == BPF_RSH) {",
          "1655:   dst_reg->imm += insn->imm;",
          "1656:   if (unlikely(dst_reg->imm > 64))",
          "1661:    dst_reg->imm = 64;",
          "1662:  } else {",
          "1666:   dst_reg->imm = 0;",
          "1667:  }",
          "1669:  if (dst_reg->imm < 0) {",
          "1674:   dst_reg->imm = 0;",
          "1675:  }",
          "1676:  return 0;",
          "1677: }",
          "1679: static int evaluate_reg_imm_alu_unknown(struct bpf_verifier_env *env,",
          "1680:      struct bpf_insn *insn)",
          "1681: {",
          "1682:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "1683:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1684:  struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1685:  u8 opcode = BPF_OP(insn->code);",
          "1686:  s64 imm_log2 = __ilog2_u64((long long)dst_reg->imm);",
          "1689:  if (src_reg->imm > 0 && dst_reg->imm) {",
          "1690:   switch (opcode) {",
          "1691:   case BPF_ADD:",
          "1699:    dst_reg->imm = min(src_reg->imm, 63 - imm_log2);",
          "1700:    dst_reg->imm--;",
          "1701:    break;",
          "1702:   case BPF_AND:",
          "1710:    dst_reg->imm = max(src_reg->imm, 63 - imm_log2);",
          "1711:    break;",
          "1712:   case BPF_OR:",
          "1720:    dst_reg->imm = min(src_reg->imm, 63 - imm_log2);",
          "1721:    break;",
          "1722:   case BPF_SUB:",
          "1723:   case BPF_MUL:",
          "1724:   case BPF_RSH:",
          "1725:   case BPF_LSH:",
          "1727:   default:",
          "1728:    mark_reg_unknown_value(regs, insn->dst_reg);",
          "1730:  } else {",
          "1731:   mark_reg_unknown_value(regs, insn->dst_reg);",
          "1734:  dst_reg->type = UNKNOWN_VALUE;",
          "1738: static int evaluate_reg_imm_alu(struct bpf_verifier_env *env,",
          "1739:     struct bpf_insn *insn)",
          "1742:  struct bpf_reg_state *dst_reg = &regs[insn->dst_reg];",
          "1743:  struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "1744:  u8 opcode = BPF_OP(insn->code);",
          "1745:  u64 dst_imm = dst_reg->imm;",
          "1747:  if (BPF_SRC(insn->code) == BPF_X && src_reg->type == UNKNOWN_VALUE)",
          "1748:   return evaluate_reg_imm_alu_unknown(env, insn);",
          "1754:  if (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_K) {",
          "1755:   dst_imm += insn->imm;",
          "1756:  } else if (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_X &&",
          "1757:      src_reg->type == CONST_IMM) {",
          "1758:   dst_imm += src_reg->imm;",
          "1759:  } else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_K) {",
          "1760:   dst_imm -= insn->imm;",
          "1761:  } else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_X &&",
          "1762:      src_reg->type == CONST_IMM) {",
          "1763:   dst_imm -= src_reg->imm;",
          "1764:  } else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_K) {",
          "1765:   dst_imm *= insn->imm;",
          "1766:  } else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_X &&",
          "1767:      src_reg->type == CONST_IMM) {",
          "1768:   dst_imm *= src_reg->imm;",
          "1769:  } else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_K) {",
          "1770:   dst_imm |= insn->imm;",
          "1771:  } else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_X &&",
          "1772:      src_reg->type == CONST_IMM) {",
          "1773:   dst_imm |= src_reg->imm;",
          "1774:  } else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_K) {",
          "1775:   dst_imm &= insn->imm;",
          "1776:  } else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_X &&",
          "1777:      src_reg->type == CONST_IMM) {",
          "1778:   dst_imm &= src_reg->imm;",
          "1779:  } else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_K) {",
          "1780:   dst_imm >>= insn->imm;",
          "1781:  } else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_X &&",
          "1782:      src_reg->type == CONST_IMM) {",
          "1783:   dst_imm >>= src_reg->imm;",
          "1784:  } else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_K) {",
          "1785:   dst_imm <<= insn->imm;",
          "1786:  } else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_X &&",
          "1787:      src_reg->type == CONST_IMM) {",
          "1788:   dst_imm <<= src_reg->imm;",
          "1789:  } else {",
          "1790:   mark_reg_unknown_value(regs, insn->dst_reg);",
          "1791:   goto out;",
          "1792:  }",
          "1794:  dst_reg->imm = dst_imm;",
          "1795: out:",
          "1796:  return 0;",
          "1797: }",
          "1799: static void check_reg_overflow(struct bpf_reg_state *reg)",
          "1800: {",
          "1801:  if (reg->max_value > BPF_REGISTER_MAX_RANGE)",
          "1802:   reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1803:  if (reg->min_value < BPF_REGISTER_MIN_RANGE ||",
          "1804:      reg->min_value > BPF_REGISTER_MAX_RANGE)",
          "1805:   reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1806: }",
          "1808: static u32 calc_align(u32 imm)",
          "1809: {",
          "1810:  if (!imm)",
          "1811:   return 1U << 31;",
          "1812:  return imm - ((imm - 1) & imm);",
          "1813: }",
          "1815: static void adjust_reg_min_max_vals(struct bpf_verifier_env *env,",
          "1816:         struct bpf_insn *insn)",
          "1817: {",
          "1818:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "1822:  u32 dst_align, src_align;",
          "1824:  dst_reg = &regs[insn->dst_reg];",
          "1825:  src_align = 0;",
          "1826:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1827:   check_reg_overflow(&regs[insn->src_reg]);",
          "1828:   min_val = regs[insn->src_reg].min_value;",
          "1829:   max_val = regs[insn->src_reg].max_value;",
          "1837:   if (regs[insn->src_reg].type != CONST_IMM &&",
          "1838:       regs[insn->src_reg].type != UNKNOWN_VALUE) {",
          "1839:    min_val = BPF_REGISTER_MIN_RANGE;",
          "1840:    max_val = BPF_REGISTER_MAX_RANGE;",
          "1841:    src_align = 0;",
          "1842:   } else {",
          "1843:    src_align = regs[insn->src_reg].min_align;",
          "1844:   }",
          "1845:  } else if (insn->imm < BPF_REGISTER_MAX_RANGE &&",
          "1846:      (s64)insn->imm > BPF_REGISTER_MIN_RANGE) {",
          "1847:   min_val = max_val = insn->imm;",
          "1848:   src_align = calc_align(insn->imm);",
          "1849:  }",
          "1851:  dst_align = dst_reg->min_align;",
          "1859:  if ((min_val == BPF_REGISTER_MIN_RANGE &&",
          "1860:       max_val == BPF_REGISTER_MAX_RANGE) ||",
          "1861:      (BPF_SRC(insn->code) == BPF_X &&",
          "1862:       ((min_val != BPF_REGISTER_MIN_RANGE &&",
          "1863:         max_val == BPF_REGISTER_MAX_RANGE) ||",
          "1864:        (min_val == BPF_REGISTER_MIN_RANGE &&",
          "1865:         max_val != BPF_REGISTER_MAX_RANGE) ||",
          "1866:        (dst_reg->min_value != BPF_REGISTER_MIN_RANGE &&",
          "1867:         dst_reg->max_value == BPF_REGISTER_MAX_RANGE) ||",
          "1868:        (dst_reg->min_value == BPF_REGISTER_MIN_RANGE &&",
          "1869:         dst_reg->max_value != BPF_REGISTER_MAX_RANGE)) &&",
          "1870:       regs[insn->dst_reg].value_from_signed !=",
          "1871:       regs[insn->src_reg].value_from_signed)) {",
          "1872:   reset_reg_range_values(regs, insn->dst_reg);",
          "1873:   return;",
          "1874:  }",
          "1880:  if (opcode != BPF_SUB) {",
          "1881:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1882:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1883:   if (max_val == BPF_REGISTER_MAX_RANGE)",
          "1884:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1893:   dst_reg->min_align = min(src_align, dst_align);",
          "1899:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1900:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1907:   dst_reg->min_align = min(src_align, dst_align);",
          "1910:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1911:    dst_reg->min_value *= min_val;",
          "1914:   dst_reg->min_align = max(src_align, dst_align);",
          "1921:   if (min_val < 0)",
          "1924:    dst_reg->min_value = 0;",
          "1925:   dst_reg->max_value = max_val;",
          "1926:   dst_reg->min_align = max(src_align, dst_align);",
          "1935:    dst_reg->min_align = 1;",
          "1939:    if (!dst_reg->min_align)",
          "1940:     dst_reg->min_align = 1;",
          "1941:    dst_reg->min_align <<= min_val;",
          "",
          "[Added Lines]",
          "1603: static void check_reg_overflow(struct bpf_reg_state *reg)",
          "1605:  if (reg->max_value > BPF_REGISTER_MAX_RANGE)",
          "1606:   reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1607:  if (reg->min_value < BPF_REGISTER_MIN_RANGE ||",
          "1608:      reg->min_value > BPF_REGISTER_MAX_RANGE)",
          "1609:   reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1610: }",
          "1612: static void coerce_reg_to_32(struct bpf_reg_state *reg)",
          "1613: {",
          "1615:  if (reg->min_value < 0)",
          "1616:   reg->min_value = 0;",
          "1618:  reg->var_off = tnum_cast(reg->var_off, 4);",
          "1620:  if (tnum_is_const(reg->var_off)) {",
          "1621:   if ((s64)reg->var_off.value > BPF_REGISTER_MIN_RANGE)",
          "1622:    reg->min_value = reg->var_off.value;",
          "1623:   if (reg->var_off.value < BPF_REGISTER_MAX_RANGE)",
          "1624:    reg->max_value = reg->var_off.value;",
          "1634: static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,",
          "1635:        struct bpf_insn *insn,",
          "1636:        const struct bpf_reg_state *ptr_reg,",
          "1637:        const struct bpf_reg_state *off_reg)",
          "1639:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "1640:  bool known = tnum_is_const(off_reg->var_off);",
          "1641:  s64 min_val = off_reg->min_value;",
          "1642:  u64 max_val = off_reg->max_value;",
          "1644:  u32 dst = insn->dst_reg;",
          "1646:  dst_reg = &regs[dst];",
          "1648:  if (WARN_ON_ONCE(known && (min_val != max_val))) {",
          "1649:   print_verifier_state(&env->cur_state);",
          "1650:   verbose(\"verifier internal error\\n\");",
          "1651:   return -EINVAL;",
          "1652:  }",
          "1654:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1656:   if (!env->allow_ptr_leaks)",
          "1657:    verbose(\"R%d 32-bit pointer arithmetic prohibited\\n\",",
          "1658:     dst);",
          "1659:   return -EACCES;",
          "1662:  if (ptr_reg->type == PTR_TO_MAP_VALUE_OR_NULL) {",
          "1663:   if (!env->allow_ptr_leaks)",
          "1664:    verbose(\"R%d pointer arithmetic on PTR_TO_MAP_VALUE_OR_NULL prohibited, null-check it first\\n\",",
          "1665:     dst);",
          "1666:   return -EACCES;",
          "1667:  }",
          "1668:  if (ptr_reg->type == CONST_PTR_TO_MAP) {",
          "1669:   if (!env->allow_ptr_leaks)",
          "1670:    verbose(\"R%d pointer arithmetic on CONST_PTR_TO_MAP prohibited\\n\",",
          "1671:     dst);",
          "1672:   return -EACCES;",
          "1673:  }",
          "1674:  if (ptr_reg->type == PTR_TO_PACKET_END) {",
          "1675:   if (!env->allow_ptr_leaks)",
          "1676:    verbose(\"R%d pointer arithmetic on PTR_TO_PACKET_END prohibited\\n\",",
          "1677:     dst);",
          "1678:   return -EACCES;",
          "1679:  }",
          "1684:  dst_reg->type = ptr_reg->type;",
          "1685:  dst_reg->id = ptr_reg->id;",
          "1687:  switch (opcode) {",
          "1688:  case BPF_ADD:",
          "1692:   if (known && (ptr_reg->off + min_val ==",
          "1693:          (s64)(s32)(ptr_reg->off + min_val))) {",
          "1695:    dst_reg->min_value = ptr_reg->min_value;",
          "1696:    dst_reg->max_value = ptr_reg->max_value;",
          "1697:    dst_reg->var_off = ptr_reg->var_off;",
          "1698:    dst_reg->off = ptr_reg->off + min_val;",
          "1699:    dst_reg->range = ptr_reg->range;",
          "1700:    break;",
          "1701:   }",
          "1702:   if (max_val == BPF_REGISTER_MAX_RANGE) {",
          "1703:    if (!env->allow_ptr_leaks)",
          "1704:     verbose(\"R%d tried to add unbounded value to pointer\\n\",",
          "1705:      dst);",
          "1706:    return -EACCES;",
          "1707:   }",
          "1717:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1718:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1719:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1720:    dst_reg->min_value += min_val;",
          "1721:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1722:    dst_reg->max_value += max_val;",
          "1723:   dst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);",
          "1724:   dst_reg->off = ptr_reg->off;",
          "1725:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "1726:    dst_reg->id = ++env->id_gen;",
          "1728:    dst_reg->range = 0;",
          "1729:   }",
          "1730:   break;",
          "1731:  case BPF_SUB:",
          "1732:   if (dst_reg == off_reg) {",
          "1734:    if (!env->allow_ptr_leaks)",
          "1735:     verbose(\"R%d tried to subtract pointer from scalar\\n\",",
          "1736:      dst);",
          "1737:    return -EACCES;",
          "1738:   }",
          "1743:   if (ptr_reg->type == PTR_TO_STACK) {",
          "1744:    if (!env->allow_ptr_leaks)",
          "1745:     verbose(\"R%d subtraction from stack pointer prohibited\\n\",",
          "1746:      dst);",
          "1747:    return -EACCES;",
          "1748:   }",
          "1749:   if (known && (ptr_reg->off - min_val ==",
          "1750:          (s64)(s32)(ptr_reg->off - min_val))) {",
          "1752:    dst_reg->min_value = ptr_reg->min_value;",
          "1753:    dst_reg->max_value = ptr_reg->max_value;",
          "1754:    dst_reg->var_off = ptr_reg->var_off;",
          "1755:    dst_reg->id = ptr_reg->id;",
          "1756:    dst_reg->off = ptr_reg->off - min_val;",
          "1757:    dst_reg->range = ptr_reg->range;",
          "1758:    break;",
          "1759:   }",
          "1763:   if ((s64)max_val < 0) {",
          "1764:    if (!env->allow_ptr_leaks)",
          "1765:     verbose(\"R%d tried to subtract negative max_val %lld from pointer\\n\",",
          "1766:      dst, (s64)max_val);",
          "1767:    return -EACCES;",
          "1768:   }",
          "1772:   if (max_val >= BPF_REGISTER_MAX_RANGE)",
          "1773:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1774:   if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)",
          "1775:    dst_reg->min_value -= max_val;",
          "1776:   if (min_val <= BPF_REGISTER_MIN_RANGE)",
          "1777:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1778:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1779:    dst_reg->max_value -= min_val;",
          "1780:   dst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);",
          "1781:   dst_reg->off = ptr_reg->off;",
          "1782:   if (ptr_reg->type == PTR_TO_PACKET) {",
          "1783:    dst_reg->id = ++env->id_gen;",
          "1785:    if (min_val < 0)",
          "1786:     dst_reg->range = 0;",
          "1788:   break;",
          "1789:  case BPF_AND:",
          "1790:  case BPF_OR:",
          "1791:  case BPF_XOR:",
          "1796:   if (!env->allow_ptr_leaks)",
          "1797:    verbose(\"R%d bitwise operator %s on pointer prohibited\\n\",",
          "1798:     dst, bpf_alu_string[opcode >> 4]);",
          "1799:   return -EACCES;",
          "1800:  default:",
          "1802:   if (!env->allow_ptr_leaks)",
          "1803:    verbose(\"R%d pointer arithmetic with %s operator prohibited\\n\",",
          "1804:     dst, bpf_alu_string[opcode >> 4]);",
          "1805:   return -EACCES;",
          "1808:  check_reg_overflow(dst_reg);",
          "1812: static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,",
          "1813:           struct bpf_insn *insn,",
          "1814:           struct bpf_reg_state *dst_reg,",
          "1815:           struct bpf_reg_state src_reg)",
          "1821:  bool src_known, dst_known;",
          "1823:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1825:   coerce_reg_to_32(dst_reg);",
          "1826:   coerce_reg_to_32(&src_reg);",
          "1828:  min_val = src_reg.min_value;",
          "1829:  max_val = src_reg.max_value;",
          "1830:  src_known = tnum_is_const(src_reg.var_off);",
          "1831:  dst_known = tnum_is_const(dst_reg->var_off);",
          "1835:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1836:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1842:   dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);",
          "1849:   if (min_val == BPF_REGISTER_MIN_RANGE)",
          "1850:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1853:   dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);",
          "1856:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1858:    __mark_reg_unknown(dst_reg);",
          "1859:    break;",
          "1860:   }",
          "1861:   dst_reg->min_value *= min_val;",
          "1866:   BUILD_BUG_ON(BPF_REGISTER_MAX_RANGE > (u32)-1);",
          "1869:   dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);",
          "1872:   if (src_known && dst_known) {",
          "1873:    u64 value = dst_reg->var_off.value & src_reg.var_off.value;",
          "1875:    dst_reg->var_off = tnum_const(value);",
          "1876:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1877:      value, BPF_REGISTER_MAX_RANGE);",
          "1878:    break;",
          "1879:   }",
          "1885:   dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);",
          "1886:   if (min_val < 0 && dst_reg->min_value < 0)",
          "1889:    dst_reg->min_value = dst_reg->var_off.value;",
          "1890:   dst_reg->max_value = min(dst_reg->max_value, max_val);",
          "1891:   break;",
          "1892:  case BPF_OR:",
          "1893:   if (src_known && dst_known) {",
          "1894:    u64 value = dst_reg->var_off.value | src_reg.var_off.value;",
          "1896:    dst_reg->var_off = tnum_const(value);",
          "1897:    dst_reg->min_value = dst_reg->max_value = min_t(u64,",
          "1898:      value, BPF_REGISTER_MAX_RANGE);",
          "1899:    break;",
          "1900:   }",
          "1905:   dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);",
          "1906:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1907:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1908:    dst_reg->max_value = BPF_REGISTER_MAX_RANGE;",
          "1909:   } else {",
          "1910:    dst_reg->min_value = max(dst_reg->min_value, min_val);",
          "1911:    dst_reg->max_value = dst_reg->var_off.value | dst_reg->var_off.mask;",
          "1912:   }",
          "1915:   if (min_val < 0) {",
          "1917:    mark_reg_unknown(regs, insn->dst_reg);",
          "1918:    break;",
          "1919:   }",
          "1926:    dst_reg->var_off = tnum_unknown;",
          "1930:    if (src_known)",
          "1931:     dst_reg->var_off = tnum_lshift(dst_reg->var_off, min_val);",
          "1932:    else",
          "1933:     dst_reg->var_off = tnum_lshift(tnum_unknown, min_val);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1946:    dst_reg->max_value <<= max_val;",
          "1947:   break;",
          "1948:  case BPF_RSH:",
          "1954:   } else {",
          "1955:    dst_reg->min_value =",
          "1956:     (u64)(dst_reg->min_value) >> min_val;",
          "1957:   }",
          "1967:   break;",
          "1968:  default:",
          "1970:   break;",
          "1971:  }",
          "1973:  check_reg_overflow(dst_reg);",
          "1974: }",
          "1977: static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)",
          "1978: {",
          "1980:  u8 opcode = BPF_OP(insn->code);",
          "1981:  int err;",
          "",
          "[Removed Lines]",
          "1952:   if (min_val < 0 || dst_reg->min_value < 0) {",
          "1953:    dst_reg->min_value = BPF_REGISTER_MIN_RANGE;",
          "1958:   if (min_val < 0) {",
          "1959:    dst_reg->min_align = 1;",
          "1960:   } else {",
          "1961:    dst_reg->min_align >>= (u64) min_val;",
          "1962:    if (!dst_reg->min_align)",
          "1963:     dst_reg->min_align = 1;",
          "1964:   }",
          "1965:   if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)",
          "1966:    dst_reg->max_value >>= max_val;",
          "1969:   reset_reg_range_values(regs, insn->dst_reg);",
          "1979:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;",
          "",
          "[Added Lines]",
          "1941:   if (min_val < 0) {",
          "1943:    mark_reg_unknown(regs, insn->dst_reg);",
          "1944:    break;",
          "1945:   }",
          "1947:   if (dst_reg->min_value < 0) {",
          "1948:    if (min_val)",
          "1950:     dst_reg->min_value = 0;",
          "1955:   if (src_known)",
          "1956:    dst_reg->var_off = tnum_rshift(dst_reg->var_off, min_val);",
          "1957:   else",
          "1958:    dst_reg->var_off = tnum_rshift(tnum_unknown, min_val);",
          "1959:   if (dst_reg->max_value == BPF_REGISTER_MAX_RANGE)",
          "1960:    dst_reg->max_value = ~0;",
          "1961:   dst_reg->max_value >>= max_val;",
          "1964:   mark_reg_unknown(regs, insn->dst_reg);",
          "1969:  return 0;",
          "1970: }",
          "1975: static int adjust_reg_min_max_vals(struct bpf_verifier_env *env,",
          "1976:        struct bpf_insn *insn)",
          "1977: {",
          "1978:  struct bpf_reg_state *regs = env->cur_state.regs, *dst_reg, *src_reg;",
          "1979:  struct bpf_reg_state *ptr_reg = NULL, off_reg = {0};",
          "1980:  u8 opcode = BPF_OP(insn->code);",
          "1981:  int rc;",
          "1983:  dst_reg = &regs[insn->dst_reg];",
          "1984:  check_reg_overflow(dst_reg);",
          "1985:  src_reg = NULL;",
          "1986:  if (dst_reg->type != SCALAR_VALUE)",
          "1987:   ptr_reg = dst_reg;",
          "1988:  if (BPF_SRC(insn->code) == BPF_X) {",
          "1989:   src_reg = &regs[insn->src_reg];",
          "1990:   check_reg_overflow(src_reg);",
          "1992:   if (src_reg->type != SCALAR_VALUE) {",
          "1993:    if (dst_reg->type != SCALAR_VALUE) {",
          "1997:     if (!env->allow_ptr_leaks) {",
          "1998:      verbose(\"R%d pointer %s pointer prohibited\\n\",",
          "1999:       insn->dst_reg,",
          "2000:       bpf_alu_string[opcode >> 4]);",
          "2001:      return -EACCES;",
          "2002:     }",
          "2003:     mark_reg_unknown(regs, insn->dst_reg);",
          "2004:     return 0;",
          "2005:    } else {",
          "2010:     rc = adjust_ptr_min_max_vals(env, insn,",
          "2011:             src_reg, dst_reg);",
          "2012:     if (rc == -EACCES && env->allow_ptr_leaks) {",
          "2014:      __mark_reg_unknown(&off_reg);",
          "2015:      return adjust_scalar_min_max_vals(",
          "2016:        env, insn,",
          "2017:        dst_reg, off_reg);",
          "2018:     }",
          "2019:     return rc;",
          "2020:    }",
          "2021:   } else if (ptr_reg) {",
          "2023:    rc = adjust_ptr_min_max_vals(env, insn,",
          "2024:            dst_reg, src_reg);",
          "2025:    if (rc == -EACCES && env->allow_ptr_leaks) {",
          "2027:     __mark_reg_unknown(dst_reg);",
          "2028:     return adjust_scalar_min_max_vals(",
          "2029:       env, insn, dst_reg, *src_reg);",
          "2030:    }",
          "2031:    return rc;",
          "2032:   }",
          "2033:  } else {",
          "2037:   off_reg.type = SCALAR_VALUE;",
          "2038:   off_reg.var_off = tnum_const(insn->imm);",
          "2039:   off_reg.min_value = insn->imm;",
          "2040:   off_reg.max_value = insn->imm;",
          "2041:   src_reg = &off_reg;",
          "2042:   check_reg_overflow(src_reg);",
          "2044:    rc = adjust_ptr_min_max_vals(env, insn,",
          "2045:            ptr_reg, src_reg);",
          "2046:    if (rc == -EACCES && env->allow_ptr_leaks) {",
          "2048:     __mark_reg_unknown(dst_reg);",
          "2049:     return adjust_scalar_min_max_vals(",
          "2050:       env, insn, dst_reg, off_reg);",
          "2051:    }",
          "2052:    return rc;",
          "2053:   }",
          "2054:  }",
          "2057:  if (WARN_ON_ONCE(ptr_reg)) {",
          "2058:   print_verifier_state(&env->cur_state);",
          "2059:   verbose(\"verifier internal error: unexpected ptr_reg\\n\");",
          "2060:   return -EINVAL;",
          "2061:  }",
          "2062:  if (WARN_ON(!src_reg)) {",
          "2063:   print_verifier_state(&env->cur_state);",
          "2064:   verbose(\"verifier internal error: no src_reg\\n\");",
          "2065:   return -EINVAL;",
          "2066:  }",
          "2067:  return adjust_scalar_min_max_vals(env, insn, dst_reg, *src_reg);",
          "2073:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2036:   if (err)",
          "2037:    return err;",
          "2044:   if (BPF_SRC(insn->code) == BPF_X) {",
          "2045:    if (BPF_CLASS(insn->code) == BPF_ALU64) {",
          "",
          "[Removed Lines]",
          "2042:   reset_reg_range_values(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2049:     regs[insn->dst_reg] = regs[insn->src_reg];",
          "2050:    } else {",
          "2051:     if (is_pointer_value(env, insn->src_reg)) {",
          "2052:      verbose(\"R%d partial copy of pointer\\n\",",
          "2053:       insn->src_reg);",
          "2054:      return -EACCES;",
          "2055:     }",
          "2057:    }",
          "2058:   } else {",
          "2065:    regs[insn->dst_reg].max_value = insn->imm;",
          "2066:    regs[insn->dst_reg].min_value = insn->imm;",
          "2069:   }",
          "2071:  } else if (opcode > BPF_END) {",
          "",
          "[Removed Lines]",
          "2056:     mark_reg_unknown_value(regs, insn->dst_reg);",
          "2062:    regs[insn->dst_reg].type = CONST_IMM;",
          "2063:    regs[insn->dst_reg].imm = insn->imm;",
          "2064:    regs[insn->dst_reg].id = 0;",
          "2067:    regs[insn->dst_reg].min_align = calc_align(insn->imm);",
          "2068:    regs[insn->dst_reg].value_from_signed = false;",
          "",
          "[Added Lines]",
          "2146:     mark_reg_unknown(regs, insn->dst_reg);",
          "2151:     regs[insn->dst_reg].var_off = tnum_cast(",
          "2152:       regs[insn->dst_reg].var_off, 4);",
          "2158:    regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2159:    regs[insn->dst_reg].var_off = tnum_const(insn->imm);",
          "2162:    regs[insn->dst_reg].id = 0;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2116:   if (err)",
          "2117:    return err;",
          "2181:  }",
          "2183:  return 0;",
          "",
          "[Removed Lines]",
          "2119:   dst_reg = &regs[insn->dst_reg];",
          "2122:   adjust_reg_min_max_vals(env, insn);",
          "2125:   if (opcode == BPF_ADD && BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2126:       dst_reg->type == FRAME_PTR && BPF_SRC(insn->code) == BPF_K) {",
          "2127:    dst_reg->type = PTR_TO_STACK;",
          "2128:    dst_reg->imm = insn->imm;",
          "2129:    return 0;",
          "2130:   } else if (opcode == BPF_ADD &&",
          "2131:       BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2132:       dst_reg->type == PTR_TO_STACK &&",
          "2133:       ((BPF_SRC(insn->code) == BPF_X &&",
          "2134:         regs[insn->src_reg].type == CONST_IMM) ||",
          "2135:        BPF_SRC(insn->code) == BPF_K)) {",
          "2136:    if (BPF_SRC(insn->code) == BPF_X)",
          "2137:     dst_reg->imm += regs[insn->src_reg].imm;",
          "2138:    else",
          "2139:     dst_reg->imm += insn->imm;",
          "2140:    return 0;",
          "2141:   } else if (opcode == BPF_ADD &&",
          "2142:       BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2143:       (dst_reg->type == PTR_TO_PACKET ||",
          "2144:        (BPF_SRC(insn->code) == BPF_X &&",
          "2145:         regs[insn->src_reg].type == PTR_TO_PACKET))) {",
          "2147:    return check_packet_ptr_add(env, insn);",
          "2148:   } else if (BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2149:       dst_reg->type == UNKNOWN_VALUE &&",
          "2150:       env->allow_ptr_leaks) {",
          "2152:    return evaluate_reg_alu(env, insn);",
          "2153:   } else if (BPF_CLASS(insn->code) == BPF_ALU64 &&",
          "2154:       dst_reg->type == CONST_IMM &&",
          "2155:       env->allow_ptr_leaks) {",
          "2157:    return evaluate_reg_imm_alu(env, insn);",
          "2158:   } else if (is_pointer_value(env, insn->dst_reg)) {",
          "2159:    verbose(\"R%d pointer arithmetic prohibited\\n\",",
          "2160:     insn->dst_reg);",
          "2161:    return -EACCES;",
          "2162:   } else if (BPF_SRC(insn->code) == BPF_X &&",
          "2163:       is_pointer_value(env, insn->src_reg)) {",
          "2164:    verbose(\"R%d pointer arithmetic prohibited\\n\",",
          "2165:     insn->src_reg);",
          "2166:    return -EACCES;",
          "2167:   }",
          "2174:   if (env->allow_ptr_leaks &&",
          "2175:       BPF_CLASS(insn->code) == BPF_ALU64 && opcode == BPF_ADD &&",
          "2176:       (dst_reg->type == PTR_TO_MAP_VALUE ||",
          "2177:        dst_reg->type == PTR_TO_MAP_VALUE_ADJ))",
          "2178:    dst_reg->type = PTR_TO_MAP_VALUE_ADJ;",
          "2179:   else",
          "2180:    mark_reg_unknown_value(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2213:   return adjust_reg_min_max_vals(env, insn);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2189:  struct bpf_reg_state *regs = state->regs, *reg;",
          "2190:  int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2225:  if (dst_reg->off < 0)",
          "2227:   return;",
          "2229:  if (dst_reg->max_value > MAX_PACKET_OFF ||",
          "2230:      dst_reg->max_value + dst_reg->off > MAX_PACKET_OFF)",
          "2234:   return;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "2222:  for (i = 0; i < MAX_BPF_REG; i++)",
          "2223:   if (regs[i].type == PTR_TO_PACKET && regs[i].id == dst_reg->id)",
          "2227:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "2228:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "2229:    continue;",
          "2230:   reg = &state->spilled_regs[i / BPF_REG_SIZE];",
          "2231:   if (reg->type == PTR_TO_PACKET && reg->id == dst_reg->id)",
          "2233:  }",
          "2234: }",
          "2240: static void reg_set_min_max(struct bpf_reg_state *true_reg,",
          "2241:        struct bpf_reg_state *false_reg, u64 val,",
          "2242:        u8 opcode)",
          "2243: {",
          "2244:  bool value_from_signed = true;",
          "2247:  switch (opcode) {",
          "2248:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "2225:    regs[i].range = max(regs[i].range, dst_reg->off);",
          "2232:    reg->range = max(reg->range, dst_reg->off);",
          "2245:  bool is_range = true;",
          "",
          "[Added Lines]",
          "2274:    regs[i].range = max_t(u16, regs[i].range, dst_reg->off);",
          "2281:    reg->range = max_t(u16, reg->range, dst_reg->off);",
          "2302:  if (__is_pointer_value(false, false_reg))",
          "2303:   return;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2252:   true_reg->max_value = true_reg->min_value = val;",
          "2254:   break;",
          "2255:  case BPF_JNE:",
          "2259:   false_reg->max_value = false_reg->min_value = val;",
          "2261:   break;",
          "2262:  case BPF_JGT:",
          "2263:   value_from_signed = false;",
          "",
          "[Removed Lines]",
          "2253:   is_range = false;",
          "2260:   is_range = false;",
          "",
          "[Added Lines]",
          "2311:   true_reg->var_off = tnum_const(val);",
          "2318:   false_reg->var_off = tnum_const(val);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2306:  check_reg_overflow(false_reg);",
          "2307:  check_reg_overflow(true_reg);",
          "2314: }",
          "2319: static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,",
          "2320:     struct bpf_reg_state *false_reg, u64 val,",
          "2321:     u8 opcode)",
          "2322: {",
          "2323:  bool value_from_signed = true;",
          "2326:  switch (opcode) {",
          "2327:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "2308:  if (is_range) {",
          "2309:   if (__is_pointer_value(false, false_reg))",
          "2310:    reset_reg_range_values(false_reg, 0);",
          "2311:   if (__is_pointer_value(false, true_reg))",
          "2312:    reset_reg_range_values(true_reg, 0);",
          "2313:  }",
          "2324:  bool is_range = true;",
          "",
          "[Added Lines]",
          "2377:  if (__is_pointer_value(false, false_reg))",
          "2378:   return;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2331:   true_reg->max_value = true_reg->min_value = val;",
          "2333:   break;",
          "2334:  case BPF_JNE:",
          "2338:   false_reg->max_value = false_reg->min_value = val;",
          "2340:   break;",
          "2341:  case BPF_JGT:",
          "2342:   value_from_signed = false;",
          "",
          "[Removed Lines]",
          "2332:   is_range = false;",
          "2339:   is_range = false;",
          "",
          "[Added Lines]",
          "2386:   true_reg->var_off = tnum_const(val);",
          "2393:   false_reg->var_off = tnum_const(val);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2386:  check_reg_overflow(false_reg);",
          "2387:  check_reg_overflow(true_reg);",
          "2393:  }",
          "2394: }",
          "2396: static void mark_map_reg(struct bpf_reg_state *regs, u32 regno, u32 id,",
          "2398: {",
          "2399:  struct bpf_reg_state *reg = &regs[regno];",
          "2401:  if (reg->type == PTR_TO_MAP_VALUE_OR_NULL && reg->id == id) {",
          "2404:   } else if (reg->map_ptr->inner_map_meta) {",
          "2405:    reg->type = CONST_PTR_TO_MAP;",
          "2406:    reg->map_ptr = reg->map_ptr->inner_map_meta;",
          "2407:   } else {",
          "2409:   }",
          "",
          "[Removed Lines]",
          "2388:  if (is_range) {",
          "2389:   if (__is_pointer_value(false, false_reg))",
          "2390:    reset_reg_range_values(false_reg, 0);",
          "2391:   if (__is_pointer_value(false, true_reg))",
          "2392:    reset_reg_range_values(true_reg, 0);",
          "2397:     enum bpf_reg_type type)",
          "2402:   if (type == UNKNOWN_VALUE) {",
          "2403:    __mark_reg_unknown_value(regs, regno);",
          "2408:    reg->type = type;",
          "",
          "[Added Lines]",
          "2442: }",
          "2445: static void __reg_combine_min_max(struct bpf_reg_state *src_reg,",
          "2446:       struct bpf_reg_state *dst_reg)",
          "2447: {",
          "2448:  src_reg->min_value = dst_reg->min_value = max(src_reg->min_value,",
          "2449:             dst_reg->min_value);",
          "2450:  src_reg->max_value = dst_reg->max_value = min(src_reg->max_value,",
          "2451:             dst_reg->max_value);",
          "2452:  src_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,",
          "2453:             dst_reg->var_off);",
          "2454:  check_reg_overflow(src_reg);",
          "2455:  check_reg_overflow(dst_reg);",
          "2456: }",
          "2458: static void reg_combine_min_max(struct bpf_reg_state *true_src,",
          "2459:     struct bpf_reg_state *true_dst,",
          "2460:     struct bpf_reg_state *false_src,",
          "2461:     struct bpf_reg_state *false_dst,",
          "2462:     u8 opcode)",
          "2463: {",
          "2464:  switch (opcode) {",
          "2465:  case BPF_JEQ:",
          "2466:   __reg_combine_min_max(true_src, true_dst);",
          "2467:   break;",
          "2468:  case BPF_JNE:",
          "2469:   __reg_combine_min_max(false_src, false_dst);",
          "2474:     bool is_null)",
          "2483:   if (WARN_ON_ONCE(reg->min_value || reg->max_value ||",
          "2484:      reg->var_off.value || reg->var_off.mask ||",
          "2485:      reg->off)) {",
          "2486:    reg->min_value = reg->max_value = reg->off = 0;",
          "2487:    reg->var_off = tnum_const(0);",
          "2488:   }",
          "2489:   if (is_null) {",
          "2490:    reg->type = SCALAR_VALUE;",
          "2495:    reg->type = PTR_TO_MAP_VALUE;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2421: static void mark_map_regs(struct bpf_verifier_state *state, u32 regno,",
          "2423: {",
          "2424:  struct bpf_reg_state *regs = state->regs;",
          "2425:  u32 id = regs[regno].id;",
          "2426:  int i;",
          "2428:  for (i = 0; i < MAX_BPF_REG; i++)",
          "2431:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "2432:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "2433:    continue;",
          "2435:  }",
          "2436: }",
          "",
          "[Removed Lines]",
          "2422:      enum bpf_reg_type type)",
          "2429:   mark_map_reg(regs, i, id, type);",
          "2434:   mark_map_reg(state->spilled_regs, i / BPF_REG_SIZE, id, type);",
          "",
          "[Added Lines]",
          "2509:      bool is_null)",
          "2516:   mark_map_reg(regs, i, id, is_null);",
          "2521:   mark_map_reg(state->spilled_regs, i / BPF_REG_SIZE, id, is_null);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2482:  if (BPF_SRC(insn->code) == BPF_K &&",
          "2483:      (opcode == BPF_JEQ || opcode == BPF_JNE) &&",
          "2485:   if (opcode == BPF_JEQ) {",
          "",
          "[Removed Lines]",
          "2484:      dst_reg->type == CONST_IMM && dst_reg->imm == insn->imm) {",
          "",
          "[Added Lines]",
          "2571:      dst_reg->type == SCALAR_VALUE &&",
          "2572:      tnum_equals_const(dst_reg->var_off, insn->imm)) {",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2507:  if (BPF_SRC(insn->code) == BPF_X) {",
          "2517:   reg_set_min_max(&other_branch->regs[insn->dst_reg],",
          "2518:      dst_reg, insn->imm, opcode);",
          "2519:  }",
          "",
          "[Removed Lines]",
          "2508:   if (regs[insn->src_reg].type == CONST_IMM)",
          "2509:    reg_set_min_max(&other_branch->regs[insn->dst_reg],",
          "2510:      dst_reg, regs[insn->src_reg].imm,",
          "2511:      opcode);",
          "2512:   else if (dst_reg->type == CONST_IMM)",
          "2513:    reg_set_min_max_inv(&other_branch->regs[insn->src_reg],",
          "2514:          &regs[insn->src_reg], dst_reg->imm,",
          "2515:          opcode);",
          "2516:  } else {",
          "",
          "[Added Lines]",
          "2600:   if (dst_reg->type == SCALAR_VALUE &&",
          "2601:       regs[insn->src_reg].type == SCALAR_VALUE) {",
          "2602:    if (tnum_is_const(regs[insn->src_reg].var_off))",
          "2603:     reg_set_min_max(&other_branch->regs[insn->dst_reg],",
          "2604:       dst_reg, regs[insn->src_reg].var_off.value,",
          "2605:       opcode);",
          "2606:    else if (tnum_is_const(dst_reg->var_off))",
          "2607:     reg_set_min_max_inv(&other_branch->regs[insn->src_reg],",
          "2608:           &regs[insn->src_reg],",
          "2609:           dst_reg->var_off.value, opcode);",
          "2610:    else if (opcode == BPF_JEQ || opcode == BPF_JNE)",
          "2612:     reg_combine_min_max(&other_branch->regs[insn->src_reg],",
          "2613:           &other_branch->regs[insn->dst_reg],",
          "2614:           &regs[insn->src_reg],",
          "2615:           &regs[insn->dst_reg], opcode);",
          "2616:   }",
          "2617:  } else if (dst_reg->type == SCALAR_VALUE) {",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2532:  } else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGT &&",
          "2533:      dst_reg->type == PTR_TO_PACKET &&",
          "2534:      regs[insn->src_reg].type == PTR_TO_PACKET_END) {",
          "",
          "[Removed Lines]",
          "2528:   mark_map_regs(this_branch, insn->dst_reg,",
          "2529:          opcode == BPF_JEQ ? PTR_TO_MAP_VALUE : UNKNOWN_VALUE);",
          "2530:   mark_map_regs(other_branch, insn->dst_reg,",
          "2531:          opcode == BPF_JEQ ? UNKNOWN_VALUE : PTR_TO_MAP_VALUE);",
          "",
          "[Added Lines]",
          "2629:   mark_map_regs(this_branch, insn->dst_reg, opcode == BPF_JNE);",
          "2630:   mark_map_regs(other_branch, insn->dst_reg, opcode == BPF_JEQ);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2576:  if (insn->src_reg == 0) {",
          "2577:   u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
          "2581:   regs[insn->dst_reg].id = 0;",
          "2582:   return 0;",
          "2583:  }",
          "",
          "[Removed Lines]",
          "2579:   regs[insn->dst_reg].type = CONST_IMM;",
          "2580:   regs[insn->dst_reg].imm = imm;",
          "",
          "[Added Lines]",
          "2678:   regs[insn->dst_reg].type = SCALAR_VALUE;",
          "2679:   regs[insn->dst_reg].min_value = imm;",
          "2680:   regs[insn->dst_reg].max_value = imm;",
          "2681:   check_reg_overflow(&regs[insn->dst_reg]);",
          "2682:   regs[insn->dst_reg].var_off = tnum_const(imm);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2663:  return 0;",
          "2664: }",
          "",
          "[Removed Lines]",
          "2662:  regs[BPF_REG_0].type = UNKNOWN_VALUE;",
          "",
          "[Added Lines]",
          "2764:  mark_reg_unknown(regs, BPF_REG_0);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2862:  return ret;",
          "2863: }",
          "2871: {",
          "2884:   return true;",
          "2914:   return true;",
          "2916:  return false;",
          "2917: }",
          "",
          "[Removed Lines]",
          "2868: static bool compare_ptrs_to_packet(struct bpf_verifier_env *env,",
          "2869:        struct bpf_reg_state *old,",
          "2870:        struct bpf_reg_state *cur)",
          "2872:  if (old->id != cur->id)",
          "2873:   return false;",
          "2883:  if (old->off == cur->off && old->range < cur->range)",
          "2912:  if (!env->strict_alignment && old->off <= cur->off &&",
          "2913:      old->off >= old->range && cur->off >= cur->range)",
          "",
          "[Added Lines]",
          "2968: static bool range_within(struct bpf_reg_state *old,",
          "2969:     struct bpf_reg_state *cur)",
          "2970: {",
          "2971:  return old->min_value <= cur->min_value &&",
          "2972:         old->max_value >= cur->max_value;",
          "2973: }",
          "2976: #define ID_MAP_SIZE (MAX_BPF_REG + MAX_BPF_STACK / BPF_REG_SIZE)",
          "2977: struct idpair {",
          "2978:  u32 old;",
          "2979:  u32 cur;",
          "2980: };",
          "2992: static bool check_ids(u32 old_id, u32 cur_id, struct idpair *idmap)",
          "2994:  unsigned int i;",
          "2996:  for (i = 0; i < ID_MAP_SIZE; i++) {",
          "2997:   if (!idmap[i].old) {",
          "2999:    idmap[i].old = old_id;",
          "3000:    idmap[i].cur = cur_id;",
          "3001:    return true;",
          "3002:   }",
          "3003:   if (idmap[i].old == old_id)",
          "3004:    return idmap[i].cur == cur_id;",
          "3005:  }",
          "3007:  WARN_ON_ONCE(1);",
          "3008:  return false;",
          "3009: }",
          "3012: static bool regsafe(struct bpf_reg_state *rold,",
          "3013:       struct bpf_reg_state *rcur,",
          "3014:       bool varlen_map_access, struct idpair *idmap)",
          "3015: {",
          "3016:  if (memcmp(rold, rcur, sizeof(*rold)) == 0)",
          "3019:  if (rold->type == NOT_INIT)",
          "3022:  if (rcur->type == NOT_INIT)",
          "3023:   return false;",
          "3024:  switch (rold->type) {",
          "3025:  case SCALAR_VALUE:",
          "3026:   if (rcur->type == SCALAR_VALUE) {",
          "3028:    return range_within(rold, rcur) &&",
          "3029:           tnum_in(rold->var_off, rcur->var_off);",
          "3030:   } else {",
          "3035:    return rold->min_value == BPF_REGISTER_MIN_RANGE &&",
          "3036:           rold->max_value == BPF_REGISTER_MAX_RANGE &&",
          "3037:           tnum_is_unknown(rold->var_off);",
          "3038:   }",
          "3039:  case PTR_TO_MAP_VALUE:",
          "3040:   if (varlen_map_access) {",
          "3046:    return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&",
          "3047:           range_within(rold, rcur) &&",
          "3048:           tnum_in(rold->var_off, rcur->var_off);",
          "3049:   } else {",
          "3054:    return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0;",
          "3055:   }",
          "3056:  case PTR_TO_MAP_VALUE_OR_NULL:",
          "3064:   if (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)",
          "3065:    return false;",
          "3066:   if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))",
          "3067:    return false;",
          "3069:   return check_ids(rold->id, rcur->id, idmap);",
          "3070:  case PTR_TO_PACKET:",
          "3071:   if (rcur->type != PTR_TO_PACKET)",
          "3072:    return false;",
          "3079:   if (rold->range > rcur->range)",
          "3080:    return false;",
          "3084:   if (rold->off != rcur->off)",
          "3085:    return false;",
          "3087:   if (rold->id && !check_ids(rold->id, rcur->id, idmap))",
          "3088:    return false;",
          "3090:   return range_within(rold, rcur) &&",
          "3091:          tnum_in(rold->var_off, rcur->var_off);",
          "3092:  case PTR_TO_CTX:",
          "3093:  case CONST_PTR_TO_MAP:",
          "3094:  case PTR_TO_STACK:",
          "3095:  case PTR_TO_PACKET_END:",
          "3099:  default:",
          "3101:   return false;",
          "3102:  }",
          "3105:  WARN_ON_ONCE(1);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2947:     struct bpf_verifier_state *cur)",
          "2948: {",
          "2949:  bool varlen_map_access = env->varlen_map_value_access;",
          "2951:  int i;",
          "2986:   return false;",
          "2987:  }",
          "2989:  for (i = 0; i < MAX_BPF_STACK; i++) {",
          "",
          "[Removed Lines]",
          "2950:  struct bpf_reg_state *rold, *rcur;",
          "2953:  for (i = 0; i < MAX_BPF_REG; i++) {",
          "2954:   rold = &old->regs[i];",
          "2955:   rcur = &cur->regs[i];",
          "2957:   if (memcmp(rold, rcur, sizeof(*rold)) == 0)",
          "2958:    continue;",
          "2963:   if (!varlen_map_access &&",
          "2964:       memcmp(rold, rcur, offsetofend(struct bpf_reg_state, id)) == 0)",
          "2965:    continue;",
          "2971:   if (rold->type == NOT_INIT ||",
          "2972:       (!varlen_map_access && rold->type == UNKNOWN_VALUE &&",
          "2973:        rcur->type != NOT_INIT))",
          "2974:    continue;",
          "2977:   if (rold->type == PTR_TO_MAP_VALUE_OR_NULL &&",
          "2978:       rcur->type == PTR_TO_MAP_VALUE_OR_NULL &&",
          "2979:       rold->map_ptr == rcur->map_ptr)",
          "2980:    continue;",
          "2982:   if (rold->type == PTR_TO_PACKET && rcur->type == PTR_TO_PACKET &&",
          "2983:       compare_ptrs_to_packet(env, rold, rcur))",
          "2984:    continue;",
          "",
          "[Added Lines]",
          "3140:  struct idpair *idmap;",
          "3141:  bool ret = false;",
          "3144:  idmap = kcalloc(ID_MAP_SIZE, sizeof(struct idpair), GFP_KERNEL);",
          "3146:  if (!idmap)",
          "3149:  for (i = 0; i < MAX_BPF_REG; i++) {",
          "3150:   if (!regsafe(&old->regs[i], &cur->regs[i], varlen_map_access,",
          "3151:         idmap))",
          "3152:    goto out_free;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2999:   if (i % BPF_REG_SIZE)",
          "3000:    continue;",
          "3001:   if (old->stack_slot_type[i] != STACK_SPILL)",
          "3002:    continue;",
          "3017:   else",
          "3018:    continue;",
          "3019:  }",
          "3021: }",
          "3023: static int is_state_visited(struct bpf_verifier_env *env, int insn_idx)",
          "",
          "[Removed Lines]",
          "2998:    return false;",
          "3003:   if (memcmp(&old->spilled_regs[i / BPF_REG_SIZE],",
          "3004:       &cur->spilled_regs[i / BPF_REG_SIZE],",
          "3005:       sizeof(old->spilled_regs[0])))",
          "3016:    return false;",
          "3020:  return true;",
          "",
          "[Added Lines]",
          "3164:    goto out_free;",
          "3169:   if (!regsafe(&old->spilled_regs[i / BPF_REG_SIZE],",
          "3170:         &cur->spilled_regs[i / BPF_REG_SIZE],",
          "3171:         varlen_map_access, idmap))",
          "3182:    goto out_free;",
          "3186:  ret = true;",
          "3187: out_free:",
          "3188:  kfree(idmap);",
          "3189:  return ret;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3331:     verbose(\"invalid BPF_LD mode\\n\");",
          "3332:     return -EINVAL;",
          "3333:    }",
          "3335:   } else {",
          "3336:    verbose(\"unknown insn class %d\\n\", class);",
          "3337:    return -EINVAL;",
          "",
          "[Removed Lines]",
          "3334:    reset_reg_range_values(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
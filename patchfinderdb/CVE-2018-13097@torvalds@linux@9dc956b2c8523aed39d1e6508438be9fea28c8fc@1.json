{
  "cve_id": "CVE-2018-13097",
  "cve_desc": "An issue was discovered in fs/f2fs/super.c in the Linux kernel through 4.17.3. There is an out-of-bounds read or a divide-by-zero error for an incorrect user_block_count in a corrupted f2fs image, leading to a denial of service (BUG).",
  "repo": "torvalds/linux",
  "patch_hash": "9dc956b2c8523aed39d1e6508438be9fea28c8fc",
  "patch_info": {
    "commit_hash": "9dc956b2c8523aed39d1e6508438be9fea28c8fc",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/9dc956b2c8523aed39d1e6508438be9fea28c8fc",
    "files": [
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix to do sanity check with user_block_count\n\nThis patch fixs to do sanity check with user_block_count.\n\n- Overview\nDivide zero in utilization when mount() a corrupted f2fs image\n\n- Reproduce (4.18 upstream kernel)\n\n- Kernel message\n[  564.099503] F2FS-fs (loop0): invalid crc value\n[  564.101991] divide error: 0000 [#1] SMP KASAN PTI\n[  564.103103] CPU: 1 PID: 1298 Comm: f2fs_discard-7: Not tainted 4.18.0-rc1+ #4\n[  564.104584] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  564.106624] RIP: 0010:issue_discard_thread+0x248/0x5c0\n[  564.107692] Code: ff ff 48 8b bd e8 fe ff ff 41 8b 9d 4c 04 00 00 e8 cd b8 ad ff 41 8b 85 50 04 00 00 31 d2 48 8d 04 80 48 8d 04 80 48 c1 e0 02 <48> f7 f3 83 f8 50 7e 16 41 c7 86 7c ff ff ff 01 00 00 00 41 c7 86\n[  564.111686] RSP: 0018:ffff8801f3117dc0 EFLAGS: 00010206\n[  564.112775] RAX: 0000000000000384 RBX: 0000000000000000 RCX: ffffffffb88c1e03\n[  564.114250] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e3aa4850\n[  564.115706] RBP: ffff8801f3117f00 R08: 1ffffffff751a1d0 R09: fffffbfff751a1d0\n[  564.117177] R10: 0000000000000001 R11: fffffbfff751a1d0 R12: 00000000fffffffc\n[  564.118634] R13: ffff8801e3aa4400 R14: ffff8801f3117ed8 R15: ffff8801e2050000\n[  564.120094] FS:  0000000000000000(0000) GS:ffff8801f6f00000(0000) knlGS:0000000000000000\n[  564.121748] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  564.122923] CR2: 000000000202b078 CR3: 00000001f11ac000 CR4: 00000000000006e0\n[  564.124383] Call Trace:\n[  564.124924]  ? __issue_discard_cmd+0x480/0x480\n[  564.125882]  ? __sched_text_start+0x8/0x8\n[  564.126756]  ? __kthread_parkme+0xcb/0x100\n[  564.127620]  ? kthread_blkcg+0x70/0x70\n[  564.128412]  kthread+0x180/0x1d0\n[  564.129105]  ? __issue_discard_cmd+0x480/0x480\n[  564.130029]  ? kthread_associate_blkcg+0x150/0x150\n[  564.131033]  ret_from_fork+0x35/0x40\n[  564.131794] Modules linked in: snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mac_hid i2c_piix4 soundcore ib_iser rdma_cm iw_cm ib_cm ib_core iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx raid1 raid0 multipath linear 8139too crct10dif_pclmul crc32_pclmul qxl drm_kms_helper syscopyarea aesni_intel sysfillrect sysimgblt fb_sys_fops ttm drm aes_x86_64 crypto_simd cryptd 8139cp glue_helper mii pata_acpi floppy\n[  564.141798] ---[ end trace 4ce02f25ff7d3df5 ]---\n[  564.142773] RIP: 0010:issue_discard_thread+0x248/0x5c0\n[  564.143885] Code: ff ff 48 8b bd e8 fe ff ff 41 8b 9d 4c 04 00 00 e8 cd b8 ad ff 41 8b 85 50 04 00 00 31 d2 48 8d 04 80 48 8d 04 80 48 c1 e0 02 <48> f7 f3 83 f8 50 7e 16 41 c7 86 7c ff ff ff 01 00 00 00 41 c7 86\n[  564.147776] RSP: 0018:ffff8801f3117dc0 EFLAGS: 00010206\n[  564.148856] RAX: 0000000000000384 RBX: 0000000000000000 RCX: ffffffffb88c1e03\n[  564.150424] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e3aa4850\n[  564.151906] RBP: ffff8801f3117f00 R08: 1ffffffff751a1d0 R09: fffffbfff751a1d0\n[  564.153463] R10: 0000000000000001 R11: fffffbfff751a1d0 R12: 00000000fffffffc\n[  564.154915] R13: ffff8801e3aa4400 R14: ffff8801f3117ed8 R15: ffff8801e2050000\n[  564.156405] FS:  0000000000000000(0000) GS:ffff8801f6f00000(0000) knlGS:0000000000000000\n[  564.158070] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  564.159279] CR2: 000000000202b078 CR3: 00000001f11ac000 CR4: 00000000000006e0\n[  564.161043] ==================================================================\n[  564.162587] BUG: KASAN: stack-out-of-bounds in from_kuid_munged+0x1d/0x50\n[  564.163994] Read of size 4 at addr ffff8801f3117c84 by task f2fs_discard-7:/1298\n\n[  564.165852] CPU: 1 PID: 1298 Comm: f2fs_discard-7: Tainted: G      D           4.18.0-rc1+ #4\n[  564.167593] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  564.169522] Call Trace:\n[  564.170057]  dump_stack+0x7b/0xb5\n[  564.170778]  print_address_description+0x70/0x290\n[  564.171765]  kasan_report+0x291/0x390\n[  564.172540]  ? from_kuid_munged+0x1d/0x50\n[  564.173408]  __asan_load4+0x78/0x80\n[  564.174148]  from_kuid_munged+0x1d/0x50\n[  564.174962]  do_notify_parent+0x1f5/0x4f0\n[  564.175808]  ? send_sigqueue+0x390/0x390\n[  564.176639]  ? css_set_move_task+0x152/0x340\n[  564.184197]  do_exit+0x1290/0x1390\n[  564.184950]  ? __issue_discard_cmd+0x480/0x480\n[  564.185884]  ? mm_update_next_owner+0x380/0x380\n[  564.186829]  ? __sched_text_start+0x8/0x8\n[  564.187672]  ? __kthread_parkme+0xcb/0x100\n[  564.188528]  ? kthread_blkcg+0x70/0x70\n[  564.189333]  ? kthread+0x180/0x1d0\n[  564.190052]  ? __issue_discard_cmd+0x480/0x480\n[  564.190983]  rewind_stack_do_exit+0x17/0x20\n\n[  564.192190] The buggy address belongs to the page:\n[  564.193213] page:ffffea0007cc45c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  564.194856] flags: 0x2ffff0000000000()\n[  564.195644] raw: 02ffff0000000000 0000000000000000 dead000000000200 0000000000000000\n[  564.197247] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\n[  564.198826] page dumped because: kasan: bad access detected\n\n[  564.200299] Memory state around the buggy address:\n[  564.201306]  ffff8801f3117b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  564.202779]  ffff8801f3117c00: 00 00 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3 f3\n[  564.204252] >ffff8801f3117c80: f3 f3 f3 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n[  564.205742]                    ^\n[  564.206424]  ffff8801f3117d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  564.207908]  ffff8801f3117d80: f3 f3 f3 f3 f3 f3 f3 f3 00 00 00 00 00 00 00 00\n[  564.209389] ==================================================================\n[  564.231795] F2FS-fs (loop0): Mounted with checkpoint version = 2\n\n- Location\nhttps://elixir.bootlin.com/linux/v4.18-rc1/source/fs/f2fs/segment.h#L586\n\treturn div_u64((u64)valid_user_blocks(sbi) * 100,\n\t\t\t\t\tsbi->user_block_count);\nMissing checks on sbi->user_block_count.\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2283:  unsigned int sit_segs, nat_segs;",
      "2284:  unsigned int sit_bitmap_size, nat_bitmap_size;",
      "2285:  unsigned int log_blocks_per_seg;",
      "2286:  int i;",
      "2288:  total = le32_to_cpu(raw_super->segment_count);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2286:  unsigned int segment_count_main;",
      "2287:  block_t user_block_count;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2307:   return 1;",
      "2308:  }",
      "2310:  main_segs = le32_to_cpu(raw_super->segment_count_main);",
      "2311:  blocks_per_seg = sbi->blocks_per_seg;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2312:  user_block_count = le64_to_cpu(ckpt->user_block_count);",
      "2313:  segment_count_main = le32_to_cpu(raw_super->segment_count_main);",
      "2314:  log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);",
      "2315:  if (!user_block_count || user_block_count >=",
      "2316:    segment_count_main << log_blocks_per_seg) {",
      "2317:   f2fs_msg(sbi->sb, KERN_ERR,",
      "2318:    \"Wrong user_block_count: %u\", user_block_count);",
      "2319:   return 1;",
      "2320:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2324:  sit_bitmap_size = le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);",
      "2325:  nat_bitmap_size = le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);",
      "2328:  if (sit_bitmap_size != ((sit_segs / 2) << log_blocks_per_seg) / 8 ||",
      "2329:   nat_bitmap_size != ((nat_segs / 2) << log_blocks_per_seg) / 8) {",
      "",
      "[Removed Lines]",
      "2326:  log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9b3d9bb3e4deef41095e513c2ffbebab20f9a982",
      "candidate_info": {
        "commit_hash": "9b3d9bb3e4deef41095e513c2ffbebab20f9a982",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9b3d9bb3e4deef41095e513c2ffbebab20f9a982",
        "files": [
          "drivers/cpufreq/cpufreq.c"
        ],
        "message": "cpufreq: Fix a circular lock dependency problem\n\nWith lockdep turned on, the following circular lock dependency problem\nwas reported:\n\n[   57.470040] ======================================================\n[   57.502900] WARNING: possible circular locking dependency detected\n[   57.535208] 4.18.0-0.rc3.1.el8+7.x86_64+debug #1 Tainted: G\n[   57.577761] ------------------------------------------------------\n[   57.609714] tuned/1505 is trying to acquire lock:\n[   57.633808] 00000000559deec5 (cpu_hotplug_lock.rw_sem){++++}, at: store+0x27/0x120\n[   57.672880]\n[   57.672880] but task is already holding lock:\n[   57.702184] 000000002136ca64 (kn->count#118){++++}, at: kernfs_fop_write+0x1d0/0x410\n[   57.742176]\n[   57.742176] which lock already depends on the new lock.\n[   57.742176]\n[   57.785220]\n[   57.785220] the existing dependency chain (in reverse order) is:\n    :\n[   58.932512] other info that might help us debug this:\n[   58.932512]\n[   58.973344] Chain exists of:\n[   58.973344]   cpu_hotplug_lock.rw_sem --> subsys mutex#5 --> kn->count#118\n[   58.973344]\n[   59.030795]  Possible unsafe locking scenario:\n[   59.030795]\n[   59.061248]        CPU0                    CPU1\n[   59.085377]        ----                    ----\n[   59.108160]   lock(kn->count#118);\n[   59.124935]                                lock(subsys mutex#5);\n[   59.156330]                                lock(kn->count#118);\n[   59.186088]   lock(cpu_hotplug_lock.rw_sem);\n[   59.208541]\n[   59.208541]  *** DEADLOCK ***\n\nIn the cpufreq_register_driver() function, the lock sequence is:\n\n  cpus_read_lock --> kn->count\n\nFor the cpufreq sysfs store method, the lock sequence is:\n\n  kn->count --> cpus_read_lock\n\nThese sequences are actually safe as they are taking a share lock on\ncpu_hotplug_lock. However, the current lockdep code doesn't check for\nshare locking when detecting circular lock dependency.  Fixing that\ncould be a substantial effort.\n\nInstead, we can work around this problem by using cpus_read_trylock()\nin the store method which is much simpler. The chance of not getting\nthe read lock is very small. If that happens, the userspace application\nthat writes the sysfs file will get an error.\n\nSigned-off-by: Waiman Long <longman@redhat.com>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
        "before_after_code_files": [
          "drivers/cpufreq/cpufreq.c||drivers/cpufreq/cpufreq.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/cpufreq/cpufreq.c||drivers/cpufreq/cpufreq.c": [
          "File: drivers/cpufreq/cpufreq.c -> drivers/cpufreq/cpufreq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "923:  struct freq_attr *fattr = to_attr(attr);",
          "924:  ssize_t ret = -EINVAL;",
          "928:  if (cpu_online(policy->cpu)) {",
          "929:   down_write(&policy->rwsem);",
          "",
          "[Removed Lines]",
          "926:  cpus_read_lock();",
          "",
          "[Added Lines]",
          "930:  if (!cpus_read_trylock())",
          "931:   return -EBUSY;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b17b113e0c38e94c2f8c0763926c6a2168293201",
      "candidate_info": {
        "commit_hash": "b17b113e0c38e94c2f8c0763926c6a2168293201",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b17b113e0c38e94c2f8c0763926c6a2168293201",
        "files": [
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h"
        ],
        "message": "mlxsw: spectrum_acl: Add support for C-TCAM eRPs\n\nThe number of eRPs that can be used by a single A-TCAM region is limited\nto 16. When more eRPs are needed, an ordinary circuit TCAM (C-TCAM) can\nbe used to hold the extra eRPs.\n\nUnlike the A-TCAM, only a single (last) lookup is performed in the\nC-TCAM and not a lookup per-eRP. However, modeling the C-TCAM as extra\neRPs will allow us to easily introduce support for pruning in a\nfollow-up patch set and is also logically correct.\n\nThe following diagram depicts the relation between both TCAMs:\n                                                                 C-TCAM\n+-------------------+               +--------------------+    +-----------+\n|                   |               |                    |    |           |\n|  eRP #1 (A-TCAM)  +----> ... +----+  eRP #16 (A-TCAM)  +----+  eRP #17  |\n|                   |               |                    |    |    ...    |\n+-------------------+               +--------------------+    |  eRP #N   |\n                                                              |           |\n                                                              +-----------+\nLookup order is from left to right.\n\nExtend the eRP core APIs with a C-TCAM parameter which indicates whether\nthe requested eRP is to be used with the C-TCAM or not.\n\nSince the C-TCAM is only meant to absorb rules that can't fit in the\nA-TCAM due to exceeded number of eRPs or key collision, an error is\nreturned when a C-TCAM eRP needs to be created when the eRP state\nmachine is in its initial state (i.e., 'no masks'). This should only\nhappen in the face of very unlikely errors when trying to push rules\ninto the A-TCAM.\n\nIn order not to perform unnecessary lookups, the eRP core will only\nenable a C-TCAM lookup for a given region if it knows there are C-TCAM\neRPs present.\n\nSigned-off-by: Ido Schimmel <idosch@mellanox.com>\nReviewed-by: Jiri Pirko <jiri@mellanox.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c": [
          "File: drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c -> drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: struct mlxsw_sp_acl_erp_key {",
          "62:  char mask[MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN];",
          "63: };",
          "65: struct mlxsw_sp_acl_erp {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:  bool ctcam;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:  unsigned long base_index;",
          "91:  unsigned int num_atcam_erps;",
          "92:  unsigned int num_max_atcam_erps;",
          "93: };",
          "95: static const struct rhashtable_params mlxsw_sp_acl_erp_ht_params = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:  unsigned int num_ctcam_erps;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448: }",
          "450: static int",
          "452: {",
          "453:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "454:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "455:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "458:          erp_table->base_index, 0);",
          "459:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "460:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "451: mlxsw_sp_acl_erp_table_enable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "457:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "453: mlxsw_sp_acl_erp_table_enable(struct mlxsw_sp_acl_erp_table *erp_table,",
          "454:          bool ctcam_le)",
          "460:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "471:  struct mlxsw_sp_acl_erp *master_rp;",
          "473:  master_rp = mlxsw_sp_acl_erp_table_master_rp(erp_table);",
          "477:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, false, 0, 0,",
          "479:  mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);",
          "480: }",
          "",
          "[Removed Lines]",
          "474:  if (!master_rp)",
          "475:   return;",
          "478:          master_rp->id);",
          "",
          "[Added Lines]",
          "482:          master_rp ? master_rp->id : 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "506:  unsigned int num_erps, old_num_erps = erp_table->num_max_atcam_erps;",
          "507:  struct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;",
          "508:  unsigned long old_base_index = erp_table->base_index;",
          "509:  int err;",
          "511:  if (erp_table->num_atcam_erps < erp_table->num_max_atcam_erps)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "513:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "526:  if (err)",
          "527:   goto err_table_relocate;",
          "530:  if (err)",
          "531:   goto err_table_enable;",
          "",
          "[Removed Lines]",
          "529:  err = mlxsw_sp_acl_erp_table_enable(erp_table);",
          "",
          "[Added Lines]",
          "534:  err = mlxsw_sp_acl_erp_table_enable(erp_table, ctcam_le);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "579:  if (err)",
          "580:   goto err_table_master_rp_add;",
          "583:  if (err)",
          "584:   goto err_table_enable;",
          "",
          "[Removed Lines]",
          "582:  err = mlxsw_sp_acl_erp_table_enable(erp_table);",
          "",
          "[Added Lines]",
          "587:  err = mlxsw_sp_acl_erp_table_enable(erp_table, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "619: {",
          "620:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "621:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "622:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "625:          erp_table->base_index, 0);",
          "626:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "627:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "624:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "627:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "630:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "635:  struct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;",
          "636:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "637:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "638:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "641:          erp_table->base_index, 0);",
          "642:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "643:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "640:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "644:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "647:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "646:  mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);",
          "647: }",
          "649: static struct mlxsw_sp_acl_erp *",
          "650: mlxsw_sp_acl_erp_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "651:         struct mlxsw_sp_acl_erp_key *key)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656: static int",
          "657: mlxsw_sp_acl_erp_region_ctcam_enable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "658: {",
          "660:  if (erp_table->num_ctcam_erps > 1)",
          "661:   return 0;",
          "663:  return mlxsw_sp_acl_erp_table_enable(erp_table, true);",
          "664: }",
          "666: static void",
          "667: mlxsw_sp_acl_erp_region_ctcam_disable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "668: {",
          "670:  if (erp_table->num_ctcam_erps > 1)",
          "671:   return;",
          "673:  mlxsw_sp_acl_erp_table_enable(erp_table, false);",
          "674: }",
          "676: static void",
          "677: mlxsw_sp_acl_erp_ctcam_table_ops_set(struct mlxsw_sp_acl_erp_table *erp_table)",
          "678: {",
          "679:  switch (erp_table->num_atcam_erps) {",
          "680:  case 2:",
          "685:   erp_table->ops = &erp_two_masks_ops;",
          "686:   break;",
          "687:  case 1:",
          "693:   mlxsw_sp_acl_erp_region_master_mask_trans(erp_table);",
          "694:   erp_table->ops = &erp_single_mask_ops;",
          "695:   break;",
          "696:  case 0:",
          "700:   mlxsw_sp_acl_erp_table_disable(erp_table);",
          "701:   mlxsw_sp_acl_erp_table_free(erp_table->erp_core,",
          "702:          erp_table->num_max_atcam_erps,",
          "703:          erp_table->aregion->type,",
          "704:          erp_table->base_index);",
          "705:   erp_table->ops = &erp_no_mask_ops;",
          "706:   break;",
          "707:  default:",
          "708:   break;",
          "709:  }",
          "710: }",
          "712: static struct mlxsw_sp_acl_erp *",
          "713: __mlxsw_sp_acl_erp_ctcam_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "714:          struct mlxsw_sp_acl_erp_key *key)",
          "715: {",
          "716:  struct mlxsw_sp_acl_erp *erp;",
          "717:  int err;",
          "719:  erp = kzalloc(sizeof(*erp), GFP_KERNEL);",
          "720:  if (!erp)",
          "721:   return ERR_PTR(-ENOMEM);",
          "723:  memcpy(&erp->key, key, sizeof(*key));",
          "724:  bitmap_from_arr32(erp->mask_bitmap, (u32 *) key->mask,",
          "725:      MLXSW_SP_ACL_TCAM_MASK_LEN);",
          "726:  refcount_set(&erp->refcnt, 1);",
          "727:  erp_table->num_ctcam_erps++;",
          "728:  erp->erp_table = erp_table;",
          "730:  err = mlxsw_sp_acl_erp_master_mask_set(erp_table, erp);",
          "731:  if (err)",
          "732:   goto err_master_mask_set;",
          "734:  err = rhashtable_insert_fast(&erp_table->erp_ht, &erp->ht_node,",
          "735:          mlxsw_sp_acl_erp_ht_params);",
          "736:  if (err)",
          "737:   goto err_rhashtable_insert;",
          "739:  err = mlxsw_sp_acl_erp_region_ctcam_enable(erp_table);",
          "740:  if (err)",
          "741:   goto err_erp_region_ctcam_enable;",
          "744:  erp_table->ops = &erp_multiple_masks_ops;",
          "746:  return erp;",
          "748: err_erp_region_ctcam_enable:",
          "749:  rhashtable_remove_fast(&erp_table->erp_ht, &erp->ht_node,",
          "750:           mlxsw_sp_acl_erp_ht_params);",
          "751: err_rhashtable_insert:",
          "752:  mlxsw_sp_acl_erp_master_mask_clear(erp_table, erp);",
          "753: err_master_mask_set:",
          "754:  erp_table->num_ctcam_erps--;",
          "755:  kfree(erp);",
          "756:  return ERR_PTR(err);",
          "757: }",
          "759: static struct mlxsw_sp_acl_erp *",
          "760: mlxsw_sp_acl_erp_ctcam_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "761:        struct mlxsw_sp_acl_erp_key *key)",
          "762: {",
          "763:  struct mlxsw_sp_acl_erp *erp;",
          "764:  int err;",
          "773:  err = mlxsw_sp_acl_erp_region_table_trans(erp_table);",
          "774:  if (err)",
          "775:   return ERR_PTR(err);",
          "777:  erp = __mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "778:  if (IS_ERR(erp)) {",
          "779:   err = PTR_ERR(erp);",
          "780:   goto err_erp_create;",
          "781:  }",
          "783:  return erp;",
          "785: err_erp_create:",
          "786:  mlxsw_sp_acl_erp_region_master_mask_trans(erp_table);",
          "787:  return ERR_PTR(err);",
          "788: }",
          "790: static void",
          "791: mlxsw_sp_acl_erp_ctcam_mask_destroy(struct mlxsw_sp_acl_erp *erp)",
          "792: {",
          "793:  struct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;",
          "795:  mlxsw_sp_acl_erp_region_ctcam_disable(erp_table);",
          "796:  rhashtable_remove_fast(&erp_table->erp_ht, &erp->ht_node,",
          "797:           mlxsw_sp_acl_erp_ht_params);",
          "798:  mlxsw_sp_acl_erp_master_mask_clear(erp_table, erp);",
          "799:  erp_table->num_ctcam_erps--;",
          "800:  kfree(erp);",
          "806:  if (erp_table->num_ctcam_erps > 0)",
          "807:   return;",
          "808:  mlxsw_sp_acl_erp_ctcam_table_ops_set(erp_table);",
          "809: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "653:  struct mlxsw_sp_acl_erp *erp;",
          "654:  int err;",
          "657:  err = mlxsw_sp_acl_erp_table_expand(erp_table);",
          "658:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "818:  if (key->ctcam)",
          "819:   return __mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "691: mlxsw_sp_acl_erp_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,",
          "692:          struct mlxsw_sp_acl_erp *erp)",
          "693: {",
          "694:  mlxsw_sp_acl_erp_region_erp_del(erp);",
          "695:  mlxsw_sp_acl_erp_table_erp_del(erp);",
          "696:  mlxsw_sp_acl_erp_index_put(erp_table, erp->index);",
          "697:  mlxsw_sp_acl_erp_generic_destroy(erp);",
          "700:   erp_table->ops = &erp_two_masks_ops;",
          "701: }",
          "",
          "[Removed Lines]",
          "699:  if (erp_table->num_atcam_erps == 2)",
          "",
          "[Added Lines]",
          "859:  if (erp->key.ctcam)",
          "860:   return mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);",
          "867:  if (erp_table->num_atcam_erps == 2 && erp_table->num_ctcam_erps == 0)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "707:  struct mlxsw_sp_acl_erp *erp;",
          "708:  int err;",
          "711:  err = mlxsw_sp_acl_erp_region_table_trans(erp_table);",
          "712:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878:  if (key->ctcam)",
          "879:   return mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "749: mlxsw_sp_acl_erp_second_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,",
          "750:          struct mlxsw_sp_acl_erp *erp)",
          "751: {",
          "752:  mlxsw_sp_acl_erp_region_erp_del(erp);",
          "753:  mlxsw_sp_acl_erp_table_erp_del(erp);",
          "754:  mlxsw_sp_acl_erp_index_put(erp_table, erp->index);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "923:  if (erp->key.ctcam)",
          "924:   return mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "765: {",
          "766:  struct mlxsw_sp_acl_erp *erp;",
          "768:  erp = mlxsw_sp_acl_erp_generic_create(erp_table, key);",
          "769:  if (IS_ERR(erp))",
          "770:   return erp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "942:  if (key->ctcam)",
          "943:   return ERR_PTR(-EINVAL);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "792: struct mlxsw_sp_acl_erp *",
          "793: mlxsw_sp_acl_erp_get(struct mlxsw_sp_acl_atcam_region *aregion,",
          "795: {",
          "796:  struct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;",
          "797:  struct mlxsw_sp_acl_erp_key key;",
          "",
          "[Removed Lines]",
          "794:        const char *mask)",
          "",
          "[Added Lines]",
          "971:        const char *mask, bool ctcam)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "803:  ASSERT_RTNL();",
          "805:  memcpy(key.mask, mask, MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);",
          "806:  erp = rhashtable_lookup_fast(&erp_table->erp_ht, &key,",
          "807:          mlxsw_sp_acl_erp_ht_params);",
          "808:  if (erp) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "983:  key.ctcam = ctcam;",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h": [
          "File: drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h -> drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "179: u8 mlxsw_sp_acl_erp_id(const struct mlxsw_sp_acl_erp *erp);",
          "180: struct mlxsw_sp_acl_erp *",
          "181: mlxsw_sp_acl_erp_get(struct mlxsw_sp_acl_atcam_region *aregion,",
          "183: void mlxsw_sp_acl_erp_put(struct mlxsw_sp_acl_atcam_region *aregion,",
          "184:      struct mlxsw_sp_acl_erp *erp);",
          "185: int mlxsw_sp_acl_erp_region_init(struct mlxsw_sp_acl_atcam_region *aregion);",
          "",
          "[Removed Lines]",
          "182:        const char *mask);",
          "",
          "[Added Lines]",
          "182:        const char *mask, bool ctcam);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "10d255c3540239c7920f52d2eb223756e186af56",
      "candidate_info": {
        "commit_hash": "10d255c3540239c7920f52d2eb223756e186af56",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/10d255c3540239c7920f52d2eb223756e186af56",
        "files": [
          "fs/f2fs/gc.c"
        ],
        "message": "f2fs: fix to skip GC if type in SSA and SIT is inconsistent\n\nIf segment type in SSA and SIT is inconsistent, we will encounter below\nBUG_ON during GC, to avoid this panic, let's just skip doing GC on such\nsegment.\n\nThe bug is triggered with image reported in below link:\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200223\n\n[  388.060262] ------------[ cut here ]------------\n[  388.060268] kernel BUG at /home/y00370721/git/devf2fs/gc.c:989!\n[  388.061172] invalid opcode: 0000 [#1] SMP\n[  388.061773] Modules linked in: f2fs(O) bluetooth ecdh_generic xt_tcpudp iptable_filter ip_tables x_tables lp ttm drm_kms_helper drm intel_rapl sb_edac crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcbc aesni_intel fb_sys_fops ppdev aes_x86_64 syscopyarea crypto_simd sysfillrect parport_pc joydev sysimgblt glue_helper parport cryptd i2c_piix4 serio_raw mac_hid btrfs hid_generic usbhid hid raid6_pq psmouse pata_acpi floppy\n[  388.064247] CPU: 7 PID: 4151 Comm: f2fs_gc-7:0 Tainted: G           O    4.13.0-rc1+ #26\n[  388.065306] Hardware name: Xen HVM domU, BIOS 4.1.2_115-900.260_ 11/06/2015\n[  388.066058] task: ffff880201583b80 task.stack: ffffc90004d7c000\n[  388.069948] RIP: 0010:do_garbage_collect+0xcc8/0xcd0 [f2fs]\n[  388.070766] RSP: 0018:ffffc90004d7fc68 EFLAGS: 00010202\n[  388.071783] RAX: ffff8801ed227000 RBX: 0000000000000001 RCX: ffffea0007b489c0\n[  388.072700] RDX: ffff880000000000 RSI: 0000000000000001 RDI: ffffea0007b489c0\n[  388.073607] RBP: ffffc90004d7fd58 R08: 0000000000000003 R09: ffffea0007b489dc\n[  388.074619] R10: 0000000000000000 R11: 0052782ab317138d R12: 0000000000000018\n[  388.075625] R13: 0000000000000018 R14: ffff880211ceb000 R15: ffff880211ceb000\n[  388.076687] FS:  0000000000000000(0000) GS:ffff880214fc0000(0000) knlGS:0000000000000000\n[  388.083277] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  388.084536] CR2: 0000000000e18c60 CR3: 00000001ecf2e000 CR4: 00000000001406e0\n[  388.085748] Call Trace:\n[  388.086690]  ? find_next_bit+0xb/0x10\n[  388.088091]  f2fs_gc+0x1a8/0x9d0 [f2fs]\n[  388.088888]  ? lock_timer_base+0x7d/0xa0\n[  388.090213]  ? try_to_del_timer_sync+0x44/0x60\n[  388.091698]  gc_thread_func+0x342/0x4b0 [f2fs]\n[  388.092892]  ? wait_woken+0x80/0x80\n[  388.094098]  kthread+0x109/0x140\n[  388.095010]  ? f2fs_gc+0x9d0/0x9d0 [f2fs]\n[  388.096043]  ? kthread_park+0x60/0x60\n[  388.097281]  ret_from_fork+0x25/0x30\n[  388.098401] Code: ff ff 48 83 e8 01 48 89 44 24 58 e9 27 f8 ff ff 48 83 e8 01 e9 78 fc ff ff 48 8d 78 ff e9 17 fb ff ff 48 83 ef 01 e9 4d f4 ff ff <0f> 0b 66 0f 1f 44 00 00 0f 1f 44 00 00 55 48 89 e5 41 56 41 55\n[  388.100864] RIP: do_garbage_collect+0xcc8/0xcd0 [f2fs] RSP: ffffc90004d7fc68\n[  388.101810] ---[ end trace 81c73d6e6b7da61d ]---\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/gc.c||fs/f2fs/gc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/gc.c||fs/f2fs/gc.c": [
          "File: fs/f2fs/gc.c -> fs/f2fs/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "986:    goto next;",
          "988:   sum = page_address(sum_page);",
          "",
          "[Removed Lines]",
          "989:   f2fs_bug_on(sbi, type != GET_SUM_TYPE((&sum->footer)));",
          "",
          "[Added Lines]",
          "989:   if (type != GET_SUM_TYPE((&sum->footer))) {",
          "990:    f2fs_msg(sbi->sb, KERN_ERR, \"Inconsistent segment (%u) \"",
          "991:     \"type [%d, %d] in SSA and SIT\",",
          "992:     segno, type, GET_SUM_TYPE((&sum->footer)));",
          "993:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "994:    goto next;",
          "995:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b512719f771a82180211c9a315b8a7f628832b3d",
      "candidate_info": {
        "commit_hash": "b512719f771a82180211c9a315b8a7f628832b3d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b512719f771a82180211c9a315b8a7f628832b3d",
        "files": [
          "include/linux/delayacct.h"
        ],
        "message": "delayacct: fix crash in delayacct_blkio_end() after delayacct init failure\n\nWhile forking, if delayacct init fails due to memory shortage, it\ncontinues expecting all delayacct users to check task->delays pointer\nagainst NULL before dereferencing it, which all of them used to do.\n\nCommit c96f5471ce7d (\"delayacct: Account blkio completion on the correct\ntask\"), while updating delayacct_blkio_end() to take the target task\ninstead of always using %current, made the function test NULL on\n%current->delays and then continue to operated on @p->delays.  If\n%current succeeded init while @p didn't, it leads to the following\ncrash.\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000004\n IP: __delayacct_blkio_end+0xc/0x40\n PGD 8000001fd07e1067 P4D 8000001fd07e1067 PUD 1fcffbb067 PMD 0\n Oops: 0000 [#1] SMP PTI\n CPU: 4 PID: 25774 Comm: QIOThread0 Not tainted 4.16.0-9_fbk1_rc2_1180_g6b593215b4d7 #9\n RIP: 0010:__delayacct_blkio_end+0xc/0x40\n Call Trace:\n  try_to_wake_up+0x2c0/0x600\n  autoremove_wake_function+0xe/0x30\n  __wake_up_common+0x74/0x120\n  wake_up_page_bit+0x9c/0xe0\n  mpage_end_io+0x27/0x70\n  blk_update_request+0x78/0x2c0\n  scsi_end_request+0x2c/0x1e0\n  scsi_io_completion+0x20b/0x5f0\n  blk_mq_complete_request+0xa2/0x100\n  ata_scsi_qc_complete+0x79/0x400\n  ata_qc_complete_multiple+0x86/0xd0\n  ahci_handle_port_interrupt+0xc9/0x5c0\n  ahci_handle_port_intr+0x54/0xb0\n  ahci_single_level_irq_intr+0x3b/0x60\n  __handle_irq_event_percpu+0x43/0x190\n  handle_irq_event_percpu+0x20/0x50\n  handle_irq_event+0x2a/0x50\n  handle_edge_irq+0x80/0x1c0\n  handle_irq+0xaf/0x120\n  do_IRQ+0x41/0xc0\n  common_interrupt+0xf/0xf\n\nFix it by updating delayacct_blkio_end() check @p->delays instead.\n\nLink: http://lkml.kernel.org/r/20180724175542.GP1934745@devbig577.frc2.facebook.com\nFixes: c96f5471ce7d (\"delayacct: Account blkio completion on the correct task\")\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Dave Jones <dsj@fb.com>\nDebugged-by: Dave Jones <dsj@fb.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Josh Snyder <joshs@netflix.com>\nCc: <stable@vger.kernel.org>\t[4.15+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/delayacct.h||include/linux/delayacct.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/linux/delayacct.h||include/linux/delayacct.h": [
          "File: include/linux/delayacct.h -> include/linux/delayacct.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "125: static inline void delayacct_blkio_end(struct task_struct *p)",
          "126: {",
          "128:   __delayacct_blkio_end(p);",
          "129:  delayacct_clear_flag(DELAYACCT_PF_BLKIO);",
          "130: }",
          "",
          "[Removed Lines]",
          "127:  if (current->delays)",
          "",
          "[Added Lines]",
          "127:  if (p->delays)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1863c387259b629e4ebfb255495f67cd06aa229b",
      "candidate_info": {
        "commit_hash": "1863c387259b629e4ebfb255495f67cd06aa229b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1863c387259b629e4ebfb255495f67cd06aa229b",
        "files": [
          "kernel/trace/trace_events_trigger.c"
        ],
        "message": "tracing: Fix double free of event_trigger_data\n\nRunning the following:\n\n # cd /sys/kernel/debug/tracing\n # echo 500000 > buffer_size_kb\n[ Or some other number that takes up most of memory ]\n # echo snapshot > events/sched/sched_switch/trigger\n\nTriggers the following bug:\n\n ------------[ cut here ]------------\n kernel BUG at mm/slub.c:296!\n invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC PTI\n CPU: 6 PID: 6878 Comm: bash Not tainted 4.18.0-rc6-test+ #1066\n Hardware name: Hewlett-Packard HP Compaq Pro 6300 SFF/339A, BIOS K01 v03.03 07/14/2016\n RIP: 0010:kfree+0x16c/0x180\n Code: 05 41 0f b6 72 51 5b 5d 41 5c 4c 89 d7 e9 ac b3 f8 ff 48 89 d9 48 89 da 41 b8 01 00 00 00 5b 5d 41 5c 4c 89 d6 e9 f4 f3 ff ff <0f> 0b 0f 0b 48 8b 3d d9 d8 f9 00 e9 c1 fe ff ff 0f 1f 40 00 0f 1f\n RSP: 0018:ffffb654436d3d88 EFLAGS: 00010246\n RAX: ffff91a9d50f3d80 RBX: ffff91a9d50f3d80 RCX: ffff91a9d50f3d80\n RDX: 00000000000006a4 RSI: ffff91a9de5a60e0 RDI: ffff91a9d9803500\n RBP: ffffffff8d267c80 R08: 00000000000260e0 R09: ffffffff8c1a56be\n R10: fffff0d404543cc0 R11: 0000000000000389 R12: ffffffff8c1a56be\n R13: ffff91a9d9930e18 R14: ffff91a98c0c2890 R15: ffffffff8d267d00\n FS:  00007f363ea64700(0000) GS:ffff91a9de580000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000055c1cacc8e10 CR3: 00000000d9b46003 CR4: 00000000001606e0\n Call Trace:\n  event_trigger_callback+0xee/0x1d0\n  event_trigger_write+0xfc/0x1a0\n  __vfs_write+0x33/0x190\n  ? handle_mm_fault+0x115/0x230\n  ? _cond_resched+0x16/0x40\n  vfs_write+0xb0/0x190\n  ksys_write+0x52/0xc0\n  do_syscall_64+0x5a/0x160\n  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n RIP: 0033:0x7f363e16ab50\n Code: 73 01 c3 48 8b 0d 38 83 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 79 db 2c 00 00 75 10 b8 01 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 1e e3 01 00 48 89 04 24\n RSP: 002b:00007fff9a4c6378 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n RAX: ffffffffffffffda RBX: 0000000000000009 RCX: 00007f363e16ab50\n RDX: 0000000000000009 RSI: 000055c1cacc8e10 RDI: 0000000000000001\n RBP: 000055c1cacc8e10 R08: 00007f363e435740 R09: 00007f363ea64700\n R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000009\n R13: 0000000000000001 R14: 00007f363e4345e0 R15: 00007f363e4303c0\n Modules linked in: ip6table_filter ip6_tables snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_seq snd_seq_device i915 snd_pcm snd_timer i2c_i801 snd soundcore i2c_algo_bit drm_kms_helper\n86_pkg_temp_thermal video kvm_intel kvm irqbypass wmi e1000e\n ---[ end trace d301afa879ddfa25 ]---\n\nThe cause is because the register_snapshot_trigger() call failed to\nallocate the snapshot buffer, and then called unregister_trigger()\nwhich freed the data that was passed to it. Then on return to the\nfunction that called register_snapshot_trigger(), as it sees it\nfailed to register, it frees the trigger_data again and causes\na double free.\n\nBy calling event_trigger_init() on the trigger_data (which only ups\nthe reference counter for it), and then event_trigger_free() afterward,\nthe trigger_data would not get freed by the registering trigger function\nas it would only up and lower the ref count for it. If the register\ntrigger function fails, then the event_trigger_free() called after it\nwill free the trigger data normally.\n\nLink: http://lkml.kernel.org/r/20180724191331.738eb819@gandalf.local.home\n\nCc: stable@vger.kerne.org\nFixes: 93e31ffbf417 (\"tracing: Add 'snapshot' event trigger command\")\nReported-by: Masami Hiramatsu <mhiramat@kernel.org>\nReviewed-by: Masami Hiramatsu <mhiramat@kernel.org>\nSigned-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>",
        "before_after_code_files": [
          "kernel/trace/trace_events_trigger.c||kernel/trace/trace_events_trigger.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/trace/trace_events_trigger.c||kernel/trace/trace_events_trigger.c": [
          "File: kernel/trace/trace_events_trigger.c -> kernel/trace/trace_events_trigger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "679:   goto out_free;",
          "681:  out_reg:",
          "682:  ret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "683:  event_trigger_init(trigger_ops, trigger_data);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "688:  if (!ret) {",
          "689:   ret = -ENOENT;",
          "694:  out:",
          "695:  return ret;",
          "",
          "[Removed Lines]",
          "690:   goto out_free;",
          "691:  } else if (ret < 0)",
          "692:   goto out_free;",
          "693:  ret = 0;",
          "",
          "[Added Lines]",
          "691:   cmd_ops->unreg(glob, trigger_ops, trigger_data, file);",
          "693:  } else if (ret > 0)",
          "694:   ret = 0;",
          "697:  event_trigger_free(trigger_ops, trigger_data);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
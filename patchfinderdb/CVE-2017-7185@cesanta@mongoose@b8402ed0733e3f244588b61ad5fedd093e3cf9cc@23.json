{
  "cve_id": "CVE-2017-7185",
  "cve_desc": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.",
  "repo": "cesanta/mongoose",
  "patch_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
  "patch_info": {
    "commit_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "files": [
      "mongoose.c"
    ],
    "message": "Fix crash in multipart handling\n\nClose cesanta/dev#6974\n\nPUBLISHED_FROM=4d4e4a46eceba10aec8dacb7f8f58bd078c92307",
    "before_after_code_files": [
      "mongoose.c||mongoose.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5961:   struct mbuf *io = &c->recv_mbuf;",
      "5962:   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);",
      "5964:   if ((int) io->len < pd->mp_stream.boundary_len + 2) {",
      "5965:     return 0;",
      "5966:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5964:   if (pd->mp_stream.boundary == NULL) {",
      "5965:     pd->mp_stream.state = MPS_FINALIZE;",
      "5966:     DBG((\"Invalid request: boundary not initilaized\"));",
      "5967:     return 0;",
      "5968:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "244e5f67d35dc81167a1d2b7ecbd4b2a243bcedf",
      "candidate_info": {
        "commit_hash": "244e5f67d35dc81167a1d2b7ecbd4b2a243bcedf",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/244e5f67d35dc81167a1d2b7ecbd4b2a243bcedf",
        "files": [
          "docs/c-api/util.h/intro.md",
          "docs/c-api/util.h/mg_match_prefix.md",
          "docs/c-api/util.h/mg_next_comma_list_entry.md",
          "mongoose.c",
          "mongoose.h"
        ],
        "message": "Commonize  pattern matching functions\n\nPUBLISHED_FROM=e69e298a51dbe0f9c47184169ecad06eef0676fc",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1858:   return len;",
          "1859: }",
          "1862: #ifdef MG_MODULE_LINES",
          "1863: #line 1 \"mongoose/src/tun.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1861: const char *mg_next_comma_list_entry(const char *, struct mg_str *,",
          "1862:                                      struct mg_str *) WEAK;",
          "1863: const char *mg_next_comma_list_entry(const char *list, struct mg_str *val,",
          "1864:                                      struct mg_str *eq_val) {",
          "1865:   if (list == NULL || *list == '\\0') {",
          "1867:     list = NULL;",
          "1868:   } else {",
          "1869:     val->p = list;",
          "1870:     if ((list = strchr(val->p, ',')) != NULL) {",
          "1872:       val->len = list - val->p;",
          "1873:       list++;",
          "1874:     } else {",
          "1876:       list = val->p + strlen(val->p);",
          "1877:       val->len = list - val->p;",
          "1878:     }",
          "1880:     if (eq_val != NULL) {",
          "1883:       eq_val->len = 0;",
          "1884:       eq_val->p = (const char *) memchr(val->p, '=', val->len);",
          "1885:       if (eq_val->p != NULL) {",
          "1887:         eq_val->len = val->p + val->len - eq_val->p;",
          "1888:         val->len = (eq_val->p - val->p) - 1;",
          "1889:       }",
          "1890:     }",
          "1891:   }",
          "1893:   return list;",
          "1894: }",
          "1896: int mg_match_prefix_n(const struct mg_str, const struct mg_str) WEAK;",
          "1897: int mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str) {",
          "1898:   const char *or_str;",
          "1899:   size_t len, i = 0, j = 0;",
          "1900:   int res;",
          "1902:   if ((or_str = (const char *) memchr(pattern.p, '|', pattern.len)) != NULL ||",
          "1903:       (or_str = (const char *) memchr(pattern.p, ',', pattern.len)) != NULL) {",
          "1904:     struct mg_str pstr = {pattern.p, (size_t)(or_str - pattern.p)};",
          "1905:     res = mg_match_prefix_n(pstr, str);",
          "1906:     if (res > 0) return res;",
          "1907:     pstr.p = or_str + 1;",
          "1908:     pstr.len = (pattern.p + pattern.len) - (or_str + 1);",
          "1909:     return mg_match_prefix_n(pstr, str);",
          "1910:   }",
          "1912:   for (; i < pattern.len; i++, j++) {",
          "1913:     if (pattern.p[i] == '?' && j != str.len) {",
          "1914:       continue;",
          "1915:     } else if (pattern.p[i] == '$') {",
          "1916:       return j == str.len ? (int) j : -1;",
          "1917:     } else if (pattern.p[i] == '*') {",
          "1918:       i++;",
          "1919:       if (i < pattern.len && pattern.p[i] == '*') {",
          "1920:         i++;",
          "1921:         len = str.len - j;",
          "1922:       } else {",
          "1923:         len = 0;",
          "1924:         while (j + len != str.len && str.p[j + len] != '/') {",
          "1925:           len++;",
          "1926:         }",
          "1927:       }",
          "1928:       if (i == pattern.len) {",
          "1929:         return j + len;",
          "1930:       }",
          "1931:       do {",
          "1932:         const struct mg_str pstr = {pattern.p + i, pattern.len - i};",
          "1933:         const struct mg_str sstr = {str.p + j + len, str.len - j - len};",
          "1934:         res = mg_match_prefix_n(pstr, sstr);",
          "1935:       } while (res == -1 && len-- > 0);",
          "1936:       return res == -1 ? -1 : (int) (j + res + len);",
          "1937:     } else if (str_util_lowercase(&pattern.p[i]) !=",
          "1938:                str_util_lowercase(&str.p[j])) {",
          "1939:       return -1;",
          "1940:     }",
          "1941:   }",
          "1942:   return j;",
          "1943: }",
          "1945: int mg_match_prefix(const char *, int, const char *) WEAK;",
          "1946: int mg_match_prefix(const char *pattern, int pattern_len, const char *str) {",
          "1947:   const struct mg_str pstr = {pattern, (size_t) pattern_len};",
          "1948:   struct mg_str s = {str, 0};",
          "1949:   if (str != NULL) s.len = strlen(str);",
          "1950:   return mg_match_prefix_n(pstr, s);",
          "1951: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9451:   return s;",
          "9452: }",
          "9458: #if MG_ENABLE_FILESYSTEM && !defined(MG_USER_FILE_FUNCTIONS)",
          "9459: int mg_stat(const char *path, cs_stat_t *st) {",
          "9460: #ifdef _WIN32",
          "",
          "[Removed Lines]",
          "9454: static int lowercase(const char *s) {",
          "9455:   return tolower(*(const unsigned char *) s);",
          "9456: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "9707:   return ((char *) &n)[0] == 0;",
          "9708: }",
          "9794: DO_NOT_WARN_UNUSED MG_INTERNAL int mg_get_errno(void) {",
          "9795: #ifndef WINCE",
          "",
          "[Removed Lines]",
          "9710: const char *mg_next_comma_list_entry(const char *list, struct mg_str *val,",
          "9711:                                      struct mg_str *eq_val) {",
          "9712:   if (list == NULL || *list == '\\0') {",
          "9714:     list = NULL;",
          "9715:   } else {",
          "9716:     val->p = list;",
          "9717:     if ((list = strchr(val->p, ',')) != NULL) {",
          "9719:       val->len = list - val->p;",
          "9720:       list++;",
          "9721:     } else {",
          "9723:       list = val->p + strlen(val->p);",
          "9724:       val->len = list - val->p;",
          "9725:     }",
          "9727:     if (eq_val != NULL) {",
          "9730:       eq_val->len = 0;",
          "9731:       eq_val->p = (const char *) memchr(val->p, '=', val->len);",
          "9732:       if (eq_val->p != NULL) {",
          "9734:         eq_val->len = val->p + val->len - eq_val->p;",
          "9735:         val->len = (eq_val->p - val->p) - 1;",
          "9736:       }",
          "9737:     }",
          "9738:   }",
          "9740:   return list;",
          "9741: }",
          "9743: int mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str) {",
          "9744:   const char *or_str;",
          "9745:   size_t len, i = 0, j = 0;",
          "9746:   int res;",
          "9748:   if ((or_str = (const char *) memchr(pattern.p, '|', pattern.len)) != NULL) {",
          "9749:     struct mg_str pstr = {pattern.p, (size_t)(or_str - pattern.p)};",
          "9750:     res = mg_match_prefix_n(pstr, str);",
          "9751:     if (res > 0) return res;",
          "9752:     pstr.p = or_str + 1;",
          "9753:     pstr.len = (pattern.p + pattern.len) - (or_str + 1);",
          "9754:     return mg_match_prefix_n(pstr, str);",
          "9755:   }",
          "9757:   for (; i < pattern.len; i++, j++) {",
          "9758:     if (pattern.p[i] == '?' && j != str.len) {",
          "9759:       continue;",
          "9760:     } else if (pattern.p[i] == '$') {",
          "9761:       return j == str.len ? (int) j : -1;",
          "9762:     } else if (pattern.p[i] == '*') {",
          "9763:       i++;",
          "9764:       if (i < pattern.len && pattern.p[i] == '*') {",
          "9765:         i++;",
          "9766:         len = str.len - j;",
          "9767:       } else {",
          "9768:         len = 0;",
          "9769:         while (j + len != str.len && str.p[j + len] != '/') {",
          "9770:           len++;",
          "9771:         }",
          "9772:       }",
          "9773:       if (i == pattern.len) {",
          "9774:         return j + len;",
          "9775:       }",
          "9776:       do {",
          "9777:         const struct mg_str pstr = {pattern.p + i, pattern.len - i};",
          "9778:         const struct mg_str sstr = {str.p + j + len, str.len - j - len};",
          "9779:         res = mg_match_prefix_n(pstr, sstr);",
          "9780:       } while (res == -1 && len-- > 0);",
          "9781:       return res == -1 ? -1 : (int) (j + res + len);",
          "9782:     } else if (lowercase(&pattern.p[i]) != lowercase(&str.p[j])) {",
          "9783:       return -1;",
          "9784:     }",
          "9785:   }",
          "9786:   return j;",
          "9787: }",
          "9789: int mg_match_prefix(const char *pattern, int pattern_len, const char *str) {",
          "9790:   const struct mg_str pstr = {pattern, (size_t) pattern_len};",
          "9791:   return mg_match_prefix_n(pstr, mg_mk_str(str));",
          "9792: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2050: int mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap);",
          "2052: #ifdef __cplusplus",
          "2053: }",
          "2054: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2066: const char *mg_next_comma_list_entry(const char *list, struct mg_str *val,",
          "2067:                                      struct mg_str *eq_val);",
          "2076: int mg_match_prefix(const char *pattern, int pattern_len, const char *str);",
          "2077: int mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4049: int mg_is_big_endian(void);",
          "",
          "[Removed Lines]",
          "4064: const char *mg_next_comma_list_entry(const char *list, struct mg_str *val,",
          "4065:                                      struct mg_str *eq_val);",
          "4074: int mg_match_prefix(const char *pattern, int pattern_len, const char *str);",
          "4075: int mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "06c5c4d2a428b3320cb4eb335975a803c6b5f6d5",
      "candidate_info": {
        "commit_hash": "06c5c4d2a428b3320cb4eb335975a803c6b5f6d5",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/06c5c4d2a428b3320cb4eb335975a803c6b5f6d5",
        "files": [
          "mongoose.c"
        ],
        "message": "Handle NULL tpcb in mg_lwip_tcp_write\n\nThis can happen if the underlying LWIP TCP PCB has been destroyed (we got tcp_error_cb).\n\nPUBLISHED_FROM=7a060aa4ca2a0c5a818fe9bc6b08cd0733c0ef8f",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14313:                       uint16_t len) {",
          "14314:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14315:   struct tcp_pcb *tpcb = cs->pcb.tcp;",
          "14316:   len = MIN(tpcb->mss, MIN(len, tpcb->snd_buf));",
          "14317:   if (len == 0) {",
          "14318:     DBG((\"%p no buf avail %u %u %u %p %p\", tpcb, tpcb->acked, tpcb->snd_buf,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14316:   if (tpcb == NULL) return -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0bb14abbddf13634eac91257af437ff6ce2cd280",
      "candidate_info": {
        "commit_hash": "0bb14abbddf13634eac91257af437ff6ce2cd280",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/0bb14abbddf13634eac91257af437ff6ce2cd280",
        "files": [
          "examples/mqtt_broker/Makefile",
          "examples/mqtt_broker/mqtt_broker.c",
          "examples/mqtt_client/mqtt_client.c"
        ],
        "message": "Nitpick for MQTT example\n\nPUBLISHED_FROM=a0dd26c00b41363f1cc58c28f530fbdf272ed146",
        "before_after_code_files": [
          "examples/mqtt_broker/mqtt_broker.c||examples/mqtt_broker/mqtt_broker.c",
          "examples/mqtt_client/mqtt_client.c||examples/mqtt_client/mqtt_client.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "examples/mqtt_broker/mqtt_broker.c||examples/mqtt_broker/mqtt_broker.c": [
          "File: examples/mqtt_broker/mqtt_broker.c -> examples/mqtt_broker/mqtt_broker.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include \"../../mongoose.h\"",
          "20: int main(void) {",
          "21:   struct mg_mgr mgr;",
          "24:   struct mg_mqtt_broker brk;",
          "26:   mg_mgr_init(&mgr, NULL);",
          "27:   mg_mqtt_broker_init(&brk, NULL);",
          "31:     exit(EXIT_FAILURE);",
          "32:   }",
          "",
          "[Removed Lines]",
          "22:   const char *address = \"0.0.0.0:1883\";",
          "23:   struct mg_connection *nc;",
          "29:   if ((nc = mg_bind(&mgr, address, mg_mqtt_broker)) == NULL) {",
          "30:     fprintf(stderr, \"mg_bind(%s) failed\\n\", address);",
          "33:   nc->user_data = &brk;",
          "35:   printf(\"MQTT broker started on %s\\n\", address);",
          "",
          "[Added Lines]",
          "20: static const char *s_listening_address = \"0.0.0.0:1883\";",
          "22: static void ev_handler(struct mg_connection *c, int ev, void *ev_data) {",
          "23:   if (ev != MG_EV_POLL) printf(\"USER HANDLER GOT EVENT %d\\n\", ev);",
          "25:   mg_mqtt_broker(c, ev, ev_data);",
          "26: }",
          "30:   struct mg_connection *c;",
          "36:   if ((c = mg_bind(&mgr, s_listening_address, ev_handler)) == NULL) {",
          "37:     fprintf(stderr, \"mg_bind(%s) failed\\n\", s_listening_address);",
          "40:   mg_mqtt_broker_init(&brk, NULL);",
          "41:   c->user_data = &brk;",
          "42:   mg_set_protocol_mqtt(c);",
          "44:   printf(\"MQTT broker started on %s\\n\", s_listening_address);",
          "",
          "---------------"
        ],
        "examples/mqtt_client/mqtt_client.c||examples/mqtt_client/mqtt_client.c": [
          "File: examples/mqtt_client/mqtt_client.c -> examples/mqtt_client/mqtt_client.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:   struct mg_mqtt_message *msg = (struct mg_mqtt_message *) p;",
          "28:   (void) nc;",
          "35:   switch (ev) {",
          "36:     case MG_EV_CONNECT: {",
          "",
          "[Removed Lines]",
          "30: #if 0",
          "31:   if (ev != MG_EV_POLL)",
          "32:     printf(\"USER HANDLER GOT %d\\n\", ev);",
          "33: #endif",
          "",
          "[Added Lines]",
          "30:   if (ev != MG_EV_POLL) printf(\"USER HANDLER GOT EVENT %d\\n\", ev);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a07fb2be510e71ec8a51d2ba8ebf753dc6d64e8f",
      "candidate_info": {
        "commit_hash": "a07fb2be510e71ec8a51d2ba8ebf753dc6d64e8f",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/a07fb2be510e71ec8a51d2ba8ebf753dc6d64e8f",
        "files": [
          "mongoose.c"
        ],
        "message": "Log DNS failures in mOS\n\nTo aid disagnosing cases like https://forum.cesanta.com/index.php?p=/discussion/397/retries-connecting-to-aws-broker\n\nPUBLISHED_FROM=98680b594dbed42234fc53050c9df292feb32f35",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11001:     case MG_EV_CLOSE:",
          "11003:       if (req != NULL) {",
          "11004:         req->callback(NULL, req->data, req->err);",
          "11005:         nc->user_data = NULL;",
          "11006:         MG_FREE(req);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11004:         char addr[32];",
          "11005:         mg_sock_addr_to_str(&nc->sa, addr, sizeof(addr), MG_SOCK_STRINGIFY_IP);",
          "11006: #ifdef MG_LOG_DNS_FAILURES",
          "11007:         LOG(LL_ERROR, (\"Failed to resolve '%s', server %s\", req->name, addr));",
          "11008: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "16700244b0e930187953d44a8f3e7671eeeab94a",
      "candidate_info": {
        "commit_hash": "16700244b0e930187953d44a8f3e7671eeeab94a",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/16700244b0e930187953d44a8f3e7671eeeab94a",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix parsing of MQTT QoS > 0 PUBLISH messages\n\nMessage ID comes after topic, not before.\n\nPUBLISHED_FROM=1ec2a56e290b67061b18c745671dc7f089b9cc0d",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9667:       mm->message_id = getu16(p);",
          "9668:       break;",
          "9669:     case MG_MQTT_CMD_PUBLISH: {",
          "9671:         mm->message_id = getu16(p);",
          "9672:         p += 2;",
          "9673:       }",
          "9676:       mm->payload.p = p;",
          "9677:       mm->payload.len = end - p;",
          "9678:       break;",
          "",
          "[Removed Lines]",
          "9670:       if (MG_MQTT_GET_QOS(header) > 0) {",
          "9674:       p = scanto(p, &mm->topic);",
          "",
          "[Added Lines]",
          "9670:       p = scanto(p, &mm->topic);",
          "9671:       if (mm->qos > 0) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-0798",
  "cve_desc": "Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c.",
  "repo": "openssl/openssl",
  "patch_hash": "380f18ed5f140e0ae1b68f3ab8f4f7c395658d9e",
  "patch_info": {
    "commit_hash": "380f18ed5f140e0ae1b68f3ab8f4f7c395658d9e",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/380f18ed5f140e0ae1b68f3ab8f4f7c395658d9e",
    "files": [
      "CHANGES",
      "apps/s_server.c",
      "crypto/srp/srp_vfy.c",
      "include/openssl/srp.h",
      "util/libeay.num"
    ],
    "message": "CVE-2016-0798: avoid memory leak in SRP\n\nThe SRP user database lookup method SRP_VBASE_get_by_user had confusing\nmemory management semantics; the returned pointer was sometimes newly\nallocated, and sometimes owned by the callee. The calling code has no\nway of distinguishing these two cases.\n\nSpecifically, SRP servers that configure a secret seed to hide valid\nlogin information are vulnerable to a memory leak: an attacker\nconnecting with an invalid username can cause a memory leak of around\n300 bytes per connection.\n\nServers that do not configure SRP, or configure SRP but do not configure\na seed are not vulnerable.\n\nIn Apache, the seed directive is known as SSLSRPUnknownUserSeed.\n\nTo mitigate the memory leak, the seed handling in SRP_VBASE_get_by_user\nis now disabled even if the user has configured a seed.\n\nApplications are advised to migrate to SRP_VBASE_get1_by_user. However,\nnote that OpenSSL makes no strong guarantees about the\nindistinguishability of valid and invalid logins. In particular,\ncomputations are currently not carried out in constant time.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "apps/s_server.c||apps/s_server.c",
      "crypto/srp/srp_vfy.c||crypto/srp/srp_vfy.c",
      "include/openssl/srp.h||include/openssl/srp.h",
      "util/libeay.num||util/libeay.num"
    ]
  },
  "patch_diff": {
    "apps/s_server.c||apps/s_server.c": [
      "File: apps/s_server.c -> apps/s_server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "352: static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)",
      "353: {",
      "354:     srpsrvparm *p = (srpsrvparm *) arg;",
      "355:     if (p->login == NULL && p->user == NULL) {",
      "356:         p->login = SSL_get_srp_username(s);",
      "357:         BIO_printf(bio_err, \"SRP username = \\\"%s\\\"\\n\", p->login);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "355:     int ret = SSL3_AL_FATAL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "361:     if (p->user == NULL) {",
      "362:         BIO_printf(bio_err, \"User %s doesn't exist\\n\", p->login);",
      "364:     }",
      "365:     if (SSL_set_srp_server_param",
      "366:         (s, p->user->N, p->user->g, p->user->s, p->user->v,",
      "367:          p->user->info) < 0) {",
      "370:     }",
      "371:     BIO_printf(bio_err,",
      "372:                \"SRP parameters set: username = \\\"%s\\\" info=\\\"%s\\\" \\n\",",
      "373:                p->login, p->user->info);",
      "375:     p->user = NULL;",
      "376:     p->login = NULL;",
      "378: }",
      "380: #endif",
      "",
      "[Removed Lines]",
      "363:         return SSL3_AL_FATAL;",
      "369:         return SSL3_AL_FATAL;",
      "377:     return SSL_ERROR_NONE;",
      "",
      "[Added Lines]",
      "365:         goto err;",
      "372:         goto err;",
      "377:     ret = SSL_ERROR_NONE;",
      "379: err:",
      "380:     SRP_user_pwd_free(p->user);",
      "383:     return ret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2325: #ifndef OPENSSL_NO_SRP",
      "2326:                 while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {",
      "2327:                     BIO_printf(bio_s_out, \"LOOKUP renego during write\\n\");",
      "2328:                     srp_callback_parm.user =",
      "2331:                     if (srp_callback_parm.user)",
      "2332:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2333:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2329:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2330:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2334:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "2336:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2337:                                                srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2393: #ifndef OPENSSL_NO_SRP",
      "2394:                 while (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {",
      "2395:                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");",
      "2396:                     srp_callback_parm.user =",
      "2399:                     if (srp_callback_parm.user)",
      "2400:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2401:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2397:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2398:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2403:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "2405:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2406:                                                srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2520:         while (i <= 0 && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {",
      "2521:             BIO_printf(bio_s_out, \"LOOKUP during accept %s\\n\",",
      "2522:                        srp_callback_parm.login);",
      "2523:             srp_callback_parm.user =",
      "2526:             if (srp_callback_parm.user)",
      "2527:                 BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2528:                            srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2524:                 SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2525:                                       srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2531:             SRP_user_pwd_free(srp_callback_parm.user);",
      "2533:                 SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2534:                                        srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2732:                 if (BIO_should_io_special(io)",
      "2733:                     && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {",
      "2734:                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");",
      "2735:                     srp_callback_parm.user =",
      "2738:                     if (srp_callback_parm.user)",
      "2739:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2740:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2736:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2737:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2744:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "2746:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2747:                                                srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3093:         if (BIO_should_io_special(io)",
      "3094:             && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {",
      "3095:             BIO_printf(bio_s_out, \"LOOKUP renego during accept\\n\");",
      "3096:             srp_callback_parm.user =",
      "3099:             if (srp_callback_parm.user)",
      "3100:                 BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "3101:                            srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "3097:                 SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "3098:                                       srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "3106:             SRP_user_pwd_free(srp_callback_parm.user);",
      "3108:                 SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "3109:                                        srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "3121:                 if (BIO_should_io_special(io)",
      "3122:                     && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {",
      "3123:                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");",
      "3124:                     srp_callback_parm.user =",
      "3127:                     if (srp_callback_parm.user)",
      "3128:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "3129:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "3125:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "3126:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "3135:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "3137:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "3138:                                                srp_callback_parm.login);",
      "",
      "---------------"
    ],
    "crypto/srp/srp_vfy.c||crypto/srp/srp_vfy.c": [
      "File: crypto/srp/srp_vfy.c -> crypto/srp/srp_vfy.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "184:     return olddst;",
      "185: }",
      "188: {",
      "189:     if (user_pwd == NULL)",
      "190:         return;",
      "",
      "[Removed Lines]",
      "187: static void SRP_user_pwd_free(SRP_user_pwd *user_pwd)",
      "",
      "[Added Lines]",
      "187: void SRP_user_pwd_free(SRP_user_pwd *user_pwd)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "246:     return (vinfo->s != NULL && vinfo->v != NULL);",
      "247: }",
      "249: SRP_VBASE *SRP_VBASE_new(char *seed_key)",
      "250: {",
      "251:     SRP_VBASE *vb = OPENSSL_malloc(sizeof(*vb));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "249: static SRP_user_pwd *srp_user_pwd_dup(SRP_user_pwd *src)",
      "250: {",
      "251:     SRP_user_pwd *ret;",
      "253:     if (src == NULL)",
      "254:         return NULL;",
      "255:     if ((ret = SRP_user_pwd_new()) == NULL)",
      "256:         return NULL;",
      "258:     SRP_user_pwd_set_gN(ret, src->g, src->N);",
      "259:     if (!SRP_user_pwd_set_ids(ret, src->id, src->info)",
      "260:         || !SRP_user_pwd_set_sv_BN(ret, BN_dup(src->s), BN_dup(src->v))) {",
      "261:             SRP_user_pwd_free(ret);",
      "262:             return NULL;",
      "263:     }",
      "264:     return ret;",
      "265: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "468: }",
      "471: {",
      "472:     int i;",
      "473:     SRP_user_pwd *user;",
      "478:     if (vb == NULL)",
      "479:         return NULL;",
      "480:     for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {",
      "481:         user = sk_SRP_user_pwd_value(vb->users_pwd, i);",
      "482:         if (strcmp(user->id, username) == 0)",
      "483:             return user;",
      "484:     }",
      "485:     if ((vb->seed_key == NULL) ||",
      "486:         (vb->default_g == NULL) || (vb->default_N == NULL))",
      "487:         return NULL;",
      "",
      "[Removed Lines]",
      "470: SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)",
      "474:     unsigned char digv[SHA_DIGEST_LENGTH];",
      "475:     unsigned char digs[SHA_DIGEST_LENGTH];",
      "476:     EVP_MD_CTX *ctxt = NULL;",
      "",
      "[Added Lines]",
      "488: static SRP_user_pwd *find_user(SRP_VBASE *vb, char *username)",
      "502:     return NULL;",
      "503: }",
      "511: SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)",
      "512: {",
      "513:     return find_user(vb, username);",
      "514: }",
      "520: SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username)",
      "521: {",
      "522:     SRP_user_pwd *user;",
      "523:     unsigned char digv[SHA_DIGEST_LENGTH];",
      "524:     unsigned char digs[SHA_DIGEST_LENGTH];",
      "525:     EVP_MD_CTX *ctxt = NULL;",
      "527:     if (vb == NULL)",
      "528:         return NULL;",
      "530:     if ((user = find_user(vb, username)) != NULL)",
      "531:         return srp_user_pwd_dup(user);",
      "",
      "---------------"
    ],
    "include/openssl/srp.h||include/openssl/srp.h": [
      "File: include/openssl/srp.h -> include/openssl/srp.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "85: DEFINE_STACK_OF(SRP_gN_cache)",
      "87: typedef struct SRP_user_pwd_st {",
      "88:     char *id;",
      "89:     BIGNUM *s;",
      "90:     BIGNUM *v;",
      "91:     const BIGNUM *g;",
      "92:     const BIGNUM *N;",
      "93:     char *info;",
      "94: } SRP_user_pwd;",
      "96: DEFINE_STACK_OF(SRP_user_pwd)",
      "98: typedef struct SRP_VBASE_st {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "99: void SRP_user_pwd_free(SRP_user_pwd *user_pwd);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "118: SRP_VBASE *SRP_VBASE_new(char *seed_key);",
      "119: void SRP_VBASE_free(SRP_VBASE *vb);",
      "120: int SRP_VBASE_init(SRP_VBASE *vb, char *verifier_file);",
      "122: char *SRP_create_verifier(const char *user, const char *pass, char **salt,",
      "123:                           char **verifier, const char *N, const char *g);",
      "124: int SRP_create_verifier_BN(const char *user, const char *pass, BIGNUM **salt,",
      "",
      "[Removed Lines]",
      "121: SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username);",
      "",
      "[Added Lines]",
      "128: DEPRECATEDIN_1_1_0(SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username))",
      "130: SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username);",
      "",
      "---------------"
    ],
    "util/libeay.num||util/libeay.num": [
      "File: util/libeay.num -> util/libeay.num",
      "--- Hunk 1 ---",
      "[Context before]",
      "4073: OPENSSL_strncasecmp                     4566 1_1_0 EXIST::FUNCTION:",
      "4074: OPENSSL_gmtime                          4567 1_1_0 EXIST::FUNCTION:",
      "4075: OPENSSL_gmtime_adj                      4568 1_1_0 EXIST::FUNCTION:",
      "4077: SRP_Calc_server_key                     4570 1_1_0 EXIST::FUNCTION:SRP",
      "4078: SRP_create_verifier                     4571 1_1_0 EXIST::FUNCTION:SRP",
      "4079: SRP_create_verifier_BN                  4572 1_1_0 EXIST::FUNCTION:SRP",
      "",
      "[Removed Lines]",
      "4076: SRP_VBASE_get_by_user                   4569 1_1_0 EXIST::FUNCTION:SRP",
      "",
      "[Added Lines]",
      "4076: SRP_VBASE_get_by_user                   4569 1_1_0 EXIST::FUNCTION:DEPRECATEDIN_1_1_0,SRP",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4711: OPENSSL_INIT_new                        5215 1_1_0 EXIST::FUNCTION:",
      "4712: OPENSSL_INIT_free                       5216 1_1_0 EXIST::FUNCTION:",
      "4713: OPENSSL_INIT_set_config_filename        5217 1_1_0 EXIST::FUNCTION:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4714: SRP_user_pwd_free                       5218 1_1_0 EXIST::FUNCTION:SRP",
      "4715: SRP_VBASE_get1_by_user                  5219 1_1_0 EXIST::FUNCTION:SRP",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9cc6fa1ce83ce7857660ee11c3285651ceff0f43",
      "candidate_info": {
        "commit_hash": "9cc6fa1ce83ce7857660ee11c3285651ceff0f43",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/9cc6fa1ce83ce7857660ee11c3285651ceff0f43",
        "files": [
          "crypto/evp/Makefile",
          "util/libeay.num"
        ],
        "message": "make update\n\nReviewed-by: Tim Hudson <tjh@openssl.org>",
        "before_after_code_files": [
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4663: ASYNC_block_pause                       5023 EXIST::FUNCTION:",
          "4664: ASYNC_cleanup                           5024 EXIST::FUNCTION:",
          "4665: ASYNC_init                              5025 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4666: EVP_MD_CTX_ctrl                         5026 EXIST::FUNCTION:",
          "4667: EVP_md5_sha1                            5027 EXIST::FUNCTION:MD5",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "74924dcb3802640d7e2ae2e80ca6515d0a53de7a",
      "candidate_info": {
        "commit_hash": "74924dcb3802640d7e2ae2e80ca6515d0a53de7a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/74924dcb3802640d7e2ae2e80ca6515d0a53de7a",
        "files": [
          "CHANGES",
          "crypto/Makefile",
          "crypto/asn1/x_bignum.c",
          "crypto/bio/bss_mem.c",
          "crypto/bn/bn_ctx.c",
          "crypto/bn/bn_lib.c",
          "crypto/buffer/buffer.c",
          "crypto/dh/dh_ameth.c",
          "crypto/dh/dh_key.c",
          "crypto/dsa/dsa_ameth.c",
          "crypto/dsa/dsa_asn1.c",
          "crypto/dsa/dsa_key.c",
          "crypto/ec/ec_asn1.c",
          "crypto/mem.c",
          "crypto/rsa/rsa_asn1.c",
          "crypto/rsa/rsa_gen.c",
          "crypto/sec_mem.c",
          "doc/crypto/BIO_s_mem.pod",
          "doc/crypto/BN_CTX_new.pod",
          "doc/crypto/CRYPTO_secure_malloc.pod",
          "doc/crypto/bio.pod",
          "doc/crypto/bn.pod",
          "doc/crypto/buffer.pod",
          "include/openssl/bio.h",
          "include/openssl/bn.h",
          "include/openssl/buffer.h",
          "include/openssl/crypto.h",
          "test/Makefile",
          "test/secmemtest.c",
          "util/libeay.num"
        ],
        "message": "More secure storage of key material.\n\nAdd secure heap for storage of private keys (when possible).\nAdd BIO_s_secmem(), CBIGNUM, etc.\nAdd BIO_CTX_secure_new so all BIGNUM's in the context are secure.\nContributed by Akamai Technologies under the Corporate CLA.\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "crypto/asn1/x_bignum.c||crypto/asn1/x_bignum.c",
          "crypto/bio/bss_mem.c||crypto/bio/bss_mem.c",
          "crypto/bn/bn_ctx.c||crypto/bn/bn_ctx.c",
          "crypto/bn/bn_lib.c||crypto/bn/bn_lib.c",
          "crypto/buffer/buffer.c||crypto/buffer/buffer.c",
          "crypto/dh/dh_ameth.c||crypto/dh/dh_ameth.c",
          "crypto/dh/dh_key.c||crypto/dh/dh_key.c",
          "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c",
          "crypto/dsa/dsa_asn1.c||crypto/dsa/dsa_asn1.c",
          "crypto/dsa/dsa_key.c||crypto/dsa/dsa_key.c",
          "crypto/ec/ec_asn1.c||crypto/ec/ec_asn1.c",
          "crypto/mem.c||crypto/mem.c",
          "crypto/rsa/rsa_asn1.c||crypto/rsa/rsa_asn1.c",
          "crypto/rsa/rsa_gen.c||crypto/rsa/rsa_gen.c",
          "crypto/sec_mem.c||crypto/sec_mem.c",
          "include/openssl/bio.h||include/openssl/bio.h",
          "include/openssl/bn.h||include/openssl/bn.h",
          "include/openssl/buffer.h||include/openssl/buffer.h",
          "include/openssl/crypto.h||include/openssl/crypto.h",
          "test/secmemtest.c||test/secmemtest.c",
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "crypto/asn1/x_bignum.c||crypto/asn1/x_bignum.c": [
          "File: crypto/asn1/x_bignum.c -> crypto/asn1/x_bignum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: #define BN_SENSITIVE    1",
          "74: static int bn_new(ASN1_VALUE **pval, const ASN1_ITEM *it);",
          "75: static void bn_free(ASN1_VALUE **pval, const ASN1_ITEM *it);",
          "77: static int bn_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype,",
          "78:                   const ASN1_ITEM *it);",
          "79: static int bn_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "80:                   int utype, char *free_cont, const ASN1_ITEM *it);",
          "82: static ASN1_PRIMITIVE_FUNCS bignum_pf = {",
          "83:     NULL, 0,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75: static int bn_secure_new(ASN1_VALUE **pval, const ASN1_ITEM *it);",
          "82: static int bn_secure_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "83:                          int utype, char *free_cont, const ASN1_ITEM *it);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "88:     bn_i2c",
          "89: };",
          "91: ASN1_ITEM_start(BIGNUM)",
          "92:         ASN1_ITYPE_PRIMITIVE, V_ASN1_INTEGER, NULL, 0, &bignum_pf, 0, \"BIGNUM\"",
          "93: ASN1_ITEM_end(BIGNUM)",
          "95: ASN1_ITEM_start(CBIGNUM)",
          "97: ASN1_ITEM_end(CBIGNUM)",
          "99: static int bn_new(ASN1_VALUE **pval, const ASN1_ITEM *it)",
          "",
          "[Removed Lines]",
          "96:         ASN1_ITYPE_PRIMITIVE, V_ASN1_INTEGER, NULL, 0, &bignum_pf, BN_SENSITIVE, \"BIGNUM\"",
          "",
          "[Added Lines]",
          "94: static ASN1_PRIMITIVE_FUNCS cbignum_pf = {",
          "95:     NULL, 0,",
          "96:     bn_secure_new,",
          "97:     bn_free,",
          "98:     0,",
          "99:     bn_secure_c2i,",
          "100:     bn_i2c",
          "101: };",
          "108:         ASN1_ITYPE_PRIMITIVE, V_ASN1_INTEGER, NULL, 0, &cbignum_pf, BN_SENSITIVE, \"CBIGNUM\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:         return 0;",
          "106: }",
          "108: static void bn_free(ASN1_VALUE **pval, const ASN1_ITEM *it)",
          "109: {",
          "110:     if (!*pval)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "120: static int bn_secure_new(ASN1_VALUE **pval, const ASN1_ITEM *it)",
          "121: {",
          "123:     if (*pval)",
          "124:         return 1;",
          "125:     else",
          "126:         return 0;",
          "127: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:     }",
          "151:     return 1;",
          "152: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176: static int bn_secure_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "177:                          int utype, char *free_cont, const ASN1_ITEM *it)",
          "178: {",
          "179:     if (!*pval)",
          "180:         bn_secure_new(pval, it);",
          "181:     return bn_c2i(pval, cont, len, utype, free_cont, it);",
          "182: }",
          "",
          "---------------"
        ],
        "crypto/bio/bss_mem.c||crypto/bio/bss_mem.c": [
          "File: crypto/bio/bss_mem.c -> crypto/bio/bss_mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: static int mem_gets(BIO *h, char *str, int size);",
          "68: static long mem_ctrl(BIO *h, int cmd, long arg1, void *arg2);",
          "69: static int mem_new(BIO *h);",
          "70: static int mem_free(BIO *data);",
          "71: static BIO_METHOD mem_method = {",
          "72:     BIO_TYPE_MEM,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: static int secmem_new(BIO *h);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:     mem_free,",
          "81:     NULL,",
          "82: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84: static BIO_METHOD secmem_method = {",
          "85:     BIO_TYPE_MEM,",
          "86:     \"secure memory buffer\",",
          "87:     mem_write,",
          "88:     mem_read,",
          "89:     mem_puts,",
          "90:     mem_gets,",
          "91:     mem_ctrl,",
          "92:     secmem_new,",
          "93:     mem_free,",
          "94:     NULL,",
          "95: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "91:     return (&mem_method);",
          "92: }",
          "94: BIO *BIO_new_mem_buf(void *buf, int len)",
          "95: {",
          "96:     BIO *ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107: BIO_METHOD *BIO_s_secmem(void)",
          "108: {",
          "109:     return(&secmem_method);",
          "110: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "114:     return ret;",
          "115: }",
          "118: {",
          "119:     BUF_MEM *b;",
          "123:     bi->shutdown = 1;",
          "124:     bi->init = 1;",
          "125:     bi->num = -1;",
          "126:     bi->ptr = (char *)b;",
          "128: }",
          "130: static int mem_free(BIO *a)",
          "",
          "[Removed Lines]",
          "117: static int mem_new(BIO *bi)",
          "121:     if ((b = BUF_MEM_new()) == NULL)",
          "122:         return (0);",
          "127:     return (1);",
          "",
          "[Added Lines]",
          "135: static int mem_init(BIO *bi, unsigned long flags)",
          "139:     if ((b = BUF_MEM_new_ex(flags)) == NULL)",
          "140:         return(0);",
          "145:     return(1);",
          "146: }",
          "148: static int mem_new(BIO *bi)",
          "149: {",
          "150:     return (mem_init(bi, 0L));",
          "151: }",
          "153: static int secmem_new(BIO *bi)",
          "154: {",
          "155:     return (mem_init(bi, BUF_MEM_FLAG_SECURE));",
          "",
          "---------------"
        ],
        "crypto/bn/bn_ctx.c||crypto/bn/bn_ctx.c": [
          "File: crypto/bn/bn_ctx.c -> crypto/bn/bn_ctx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: } BN_POOL;",
          "104: static void BN_POOL_init(BN_POOL *);",
          "105: static void BN_POOL_finish(BN_POOL *);",
          "107: static void BN_POOL_release(BN_POOL *, unsigned int);",
          "",
          "[Removed Lines]",
          "106: static BIGNUM *BN_POOL_get(BN_POOL *);",
          "",
          "[Added Lines]",
          "106: static BIGNUM *BN_POOL_get(BN_POOL *, int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:     int err_stack;",
          "140:     int too_many;",
          "141: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142:     int flags;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "187: BN_CTX *BN_CTX_new(void)",
          "188: {",
          "191:         BNerr(BN_F_BN_CTX_NEW, ERR_R_MALLOC_FAILURE);",
          "192:         return NULL;",
          "193:     }",
          "",
          "[Removed Lines]",
          "189:     BN_CTX *ret = OPENSSL_malloc(sizeof(*ret));",
          "190:     if (!ret) {",
          "",
          "[Added Lines]",
          "191:     BN_CTX *ret;",
          "193:     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "197:     ret->used = 0;",
          "198:     ret->err_stack = 0;",
          "199:     ret->too_many = 0;",
          "200:     return ret;",
          "201: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:     ret->flags = 0;",
          "204:     return ret;",
          "205: }",
          "207: BN_CTX *BN_CTX_secure_new(void)",
          "208: {",
          "209:     BN_CTX *ret = BN_CTX_new();",
          "211:     if (ret)",
          "212:         ret->flags = BN_FLG_SECURE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "258: BIGNUM *BN_CTX_get(BN_CTX *ctx)",
          "259: {",
          "260:     BIGNUM *ret;",
          "261:     CTXDBG_ENTRY(\"BN_CTX_get\", ctx);",
          "262:     if (ctx->err_stack || ctx->too_many)",
          "263:         return NULL;",
          "",
          "[Removed Lines]",
          "264:     if ((ret = BN_POOL_get(&ctx->pool)) == NULL) {",
          "",
          "[Added Lines]",
          "278:     if ((ret = BN_POOL_get(&ctx->pool, ctx->flags)) == NULL) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "290: static void BN_STACK_finish(BN_STACK *st)",
          "291: {",
          "294: }",
          "297: static int BN_STACK_push(BN_STACK *st, unsigned int idx)",
          "298: {",
          "307:             return 0;",
          "308:         if (st->depth)",
          "312:         st->indexes = newitems;",
          "313:         st->size = newsize;",
          "314:     }",
          "",
          "[Removed Lines]",
          "292:     if (st->size)",
          "293:         OPENSSL_free(st->indexes);",
          "299:     if (st->depth == st->size)",
          "301:     {",
          "302:         unsigned int newsize = (st->size ?",
          "303:                                 (st->size * 3 / 2) : BN_CTX_START_FRAMES);",
          "304:         unsigned int *newitems = OPENSSL_malloc(newsize *",
          "305:                                                 sizeof(unsigned int));",
          "306:         if (!newitems)",
          "309:             memcpy(newitems, st->indexes, st->depth * sizeof(unsigned int));",
          "310:         if (st->size)",
          "311:             OPENSSL_free(st->indexes);",
          "",
          "[Added Lines]",
          "306:     OPENSSL_free(st->indexes);",
          "307:     st->indexes = NULL;",
          "313:     if (st->depth == st->size) {",
          "315:         unsigned int newsize =",
          "316:             st->size ? (st->size * 3 / 2) : BN_CTX_START_FRAMES;",
          "317:         unsigned int *newitems = OPENSSL_malloc(sizeof(*newitems) * newsize);",
          "318:         if (newitems == NULL)",
          "321:             memcpy(newitems, st->indexes, sizeof(*newitems) * st->depth);",
          "322:         OPENSSL_free(st->indexes);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "334: static void BN_POOL_finish(BN_POOL *p)",
          "335: {",
          "336:     while (p->head) {",
          "340:             if (bn->d)",
          "341:                 BN_clear_free(bn);",
          "344:         p->current = p->head->next;",
          "345:         OPENSSL_free(p->head);",
          "346:         p->head = p->current;",
          "",
          "[Removed Lines]",
          "337:         unsigned int loop = 0;",
          "338:         BIGNUM *bn = p->head->vals;",
          "339:         while (loop++ < BN_CTX_POOL_SIZE) {",
          "342:             bn++;",
          "343:         }",
          "",
          "[Added Lines]",
          "347:     unsigned int loop;",
          "348:     BIGNUM *bn;",
          "351:         for (loop = 0, bn = p->head->vals; loop++ < BN_CTX_POOL_SIZE; bn++)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "348: }",
          "352: {",
          "353:     if (p->used == p->size) {",
          "356:         BN_POOL_ITEM *item = OPENSSL_malloc(sizeof(*item));",
          "358:             return NULL;",
          "363:         item->prev = p->tail;",
          "364:         item->next = NULL;",
          "367:             p->head = p->current = p->tail = item;",
          "368:         else {",
          "369:             p->tail->next = item;",
          "",
          "[Removed Lines]",
          "351: static BIGNUM *BN_POOL_get(BN_POOL *p)",
          "354:         BIGNUM *bn;",
          "355:         unsigned int loop = 0;",
          "357:         if (!item)",
          "360:         bn = item->vals;",
          "361:         while (loop++ < BN_CTX_POOL_SIZE)",
          "362:             BN_init(bn++);",
          "366:         if (!p->head)",
          "",
          "[Added Lines]",
          "361: static BIGNUM *BN_POOL_get(BN_POOL *p, int flag)",
          "363:     BIGNUM *bn;",
          "364:     unsigned int loop;",
          "369:         if (item == NULL)",
          "371:         for (loop = 0, bn = item->vals; loop++ < BN_CTX_POOL_SIZE; bn++) {",
          "372:             BN_init(bn);",
          "373:             if ((flag & BN_FLG_SECURE) != 0)",
          "374:                 BN_set_flags(bn, BN_FLG_SECURE);",
          "375:         }",
          "379:         if (p->head == NULL)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "385: static void BN_POOL_release(BN_POOL *p, unsigned int num)",
          "386: {",
          "387:     unsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;",
          "388:     p->used -= num;",
          "389:     while (num--) {",
          "390:         bn_check_top(p->current->vals + offset);",
          "392:             offset = BN_CTX_POOL_SIZE - 1;",
          "393:             p->current = p->current->prev;",
          "394:         } else",
          "",
          "[Removed Lines]",
          "391:         if (!offset) {",
          "",
          "[Added Lines]",
          "406:         if (offset == 0) {",
          "",
          "---------------"
        ],
        "crypto/bn/bn_lib.c||crypto/bn/bn_lib.c": [
          "File: crypto/bn/bn_lib.c -> crypto/bn/bn_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:     bn_check_top(a);",
          "233:     if (a->d != NULL) {",
          "234:         OPENSSL_cleanse(a->d, a->dmax * sizeof(a->d[0]));",
          "237:     }",
          "238:     i = BN_get_flags(a, BN_FLG_MALLOCED);",
          "239:     OPENSSL_cleanse(a, sizeof(BIGNUM));",
          "",
          "[Removed Lines]",
          "235:         if (!(BN_get_flags(a, BN_FLG_STATIC_DATA)))",
          "236:             OPENSSL_free(a->d);",
          "",
          "[Added Lines]",
          "235:         if (!(BN_get_flags(a, BN_FLG_STATIC_DATA))) {",
          "236:             if (BN_get_flags(a,BN_FLG_SECURE))",
          "237:                 OPENSSL_secure_free(a->d);",
          "238:             else",
          "239:                 OPENSSL_free(a->d);",
          "240:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:         return;",
          "248:     bn_check_top(a);",
          "249:     if (!BN_get_flags(a, BN_FLG_STATIC_DATA))",
          "251:     if (a->flags & BN_FLG_MALLOCED)",
          "252:         OPENSSL_free(a);",
          "253:     else {",
          "",
          "[Removed Lines]",
          "250:         OPENSSL_free(a->d);",
          "",
          "[Added Lines]",
          "254:     if ((a->d != NULL) && !(BN_get_flags(a, BN_FLG_STATIC_DATA))) {",
          "255:         if (BN_get_flags(a, BN_FLG_SECURE))",
          "256:             OPENSSL_secure_free(a->d);",
          "257:         else",
          "258:             OPENSSL_free(a->d);",
          "259:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "281:     return (ret);",
          "282: }",
          "286: static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:  BIGNUM *BN_secure_new(void)",
          "294:  {",
          "295:      BIGNUM *ret = BN_new();",
          "296:      if (ret)",
          "297:          ret->flags |= BN_FLG_SECURE;",
          "298:      return (ret);",
          "299:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "299:         BNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);",
          "300:         return (NULL);",
          "301:     }",
          "303:     if (A == NULL) {",
          "304:         BNerr(BN_F_BN_EXPAND_INTERNAL, ERR_R_MALLOC_FAILURE);",
          "305:         return (NULL);",
          "",
          "[Removed Lines]",
          "302:     a = A = OPENSSL_malloc(sizeof(*a) * words);",
          "",
          "[Added Lines]",
          "319:     if (BN_get_flags(b,BN_FLG_SECURE))",
          "320:         a = A = OPENSSL_secure_malloc(words * sizeof(*a));",
          "321:     else",
          "322:         a = A = OPENSSL_malloc(words * sizeof(*a));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "378:         BN_ULONG *a = bn_expand_internal(b, words);",
          "379:         if (!a)",
          "380:             return NULL;",
          "382:         b->d = a;",
          "383:         b->dmax = words;",
          "384:     }",
          "",
          "[Removed Lines]",
          "381:         OPENSSL_free(b->d);",
          "",
          "[Added Lines]",
          "401:         if (b->d) {",
          "402:             if (BN_get_flags(b,BN_FLG_SECURE))",
          "403:                 OPENSSL_secure_free(b->d);",
          "404:             else",
          "405:                 OPENSSL_free(b->d);",
          "406:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "395:         return NULL;",
          "396:     bn_check_top(a);",
          "399:     if (t == NULL)",
          "400:         return NULL;",
          "401:     if (!BN_copy(t, a)) {",
          "",
          "[Removed Lines]",
          "398:     t = BN_new();",
          "",
          "[Added Lines]",
          "423:     t = BN_get_flags(a, BN_FLG_SECURE) ? BN_secure_new() : BN_new();",
          "",
          "---------------"
        ],
        "crypto/buffer/buffer.c||crypto/buffer/buffer.c": [
          "File: crypto/buffer/buffer.c -> crypto/buffer/buffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: #define LIMIT_BEFORE_EXPANSION 0x5ffffffc",
          "70: BUF_MEM *BUF_MEM_new(void)",
          "71: {",
          "72:     BUF_MEM *ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: BUF_MEM *BUF_MEM_new_ex(unsigned long flags)",
          "71: {",
          "72:     BUF_MEM *ret;",
          "74:     ret = BUF_MEM_new();",
          "75:     if (ret != NULL)",
          "76:         ret->flags = flags;",
          "77:     return (ret);",
          "78: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:         BUFerr(BUF_F_BUF_MEM_NEW, ERR_R_MALLOC_FAILURE);",
          "77:         return (NULL);",
          "78:     }",
          "79:     ret->length = 0;",
          "80:     ret->max = 0;",
          "81:     ret->data = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89:     ret->flags = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88:         return;",
          "90:     if (a->data != NULL) {",
          "92:     }",
          "93:     OPENSSL_free(a);",
          "94: }",
          "96: size_t BUF_MEM_grow(BUF_MEM *str, size_t len)",
          "97: {",
          "98:     char *ret;",
          "",
          "[Removed Lines]",
          "91:         OPENSSL_clear_free(a->data, a->max);",
          "",
          "[Added Lines]",
          "102:         memset(a->data, 0, (unsigned int)a->max);",
          "103:         if (a->flags & BUF_MEM_FLAG_SECURE)",
          "104:             OPENSSL_secure_free(a->data);",
          "105:         else",
          "106:             OPENSSL_clear_free(a->data, a->max);",
          "113: static char *sec_alloc_realloc(BUF_MEM *str, size_t len)",
          "114: {",
          "115:     char *ret;",
          "117:     ret = OPENSSL_secure_malloc(len);",
          "118:     if (str->data != NULL) {",
          "119:         if (ret != NULL)",
          "120:             memcpy(ret, str->data, str->length);",
          "121:         OPENSSL_secure_free(str->data);",
          "122:     }",
          "123:     return (ret);",
          "124: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "113:         return 0;",
          "114:     }",
          "115:     n = (len + 3) / 3 * 4;",
          "117:     if (ret == NULL) {",
          "118:         BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);",
          "119:         len = 0;",
          "",
          "[Removed Lines]",
          "116:     ret = OPENSSL_realloc(str->data, n);",
          "",
          "[Added Lines]",
          "146:     if ((str->flags & BUF_MEM_FLAG_SECURE))",
          "147:         ret = sec_alloc_realloc(str, n);",
          "148:     else",
          "149:         ret = OPENSSL_realloc(str->data, n);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "147:         return 0;",
          "148:     }",
          "149:     n = (len + 3) / 3 * 4;",
          "151:     if (ret == NULL) {",
          "152:         BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);",
          "153:         len = 0;",
          "",
          "[Removed Lines]",
          "150:     ret = OPENSSL_realloc_clean(str->data, str->max, n);",
          "",
          "[Added Lines]",
          "183:     if ((str->flags & BUF_MEM_FLAG_SECURE))",
          "184:         ret = sec_alloc_realloc(str, n);",
          "185:     else",
          "186:         ret = OPENSSL_realloc_clean(str->data, str->max, n);",
          "",
          "---------------"
        ],
        "crypto/dh/dh_ameth.c||crypto/dh/dh_ameth.c": [
          "File: crypto/dh/dh_ameth.c -> crypto/dh/dh_ameth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:         goto decerr;",
          "232:         DHerr(DH_F_DH_PRIV_DECODE, DH_R_BN_ERROR);",
          "233:         goto dherr;",
          "234:     }",
          "",
          "[Removed Lines]",
          "231:     if ((dh->priv_key = ASN1_INTEGER_to_BN(privkey, NULL)) == NULL) {",
          "",
          "[Added Lines]",
          "231:     if ((dh->priv_key = BN_secure_new()) == NULL",
          "232:         || !ASN1_INTEGER_to_BN(privkey, dh->priv_key)) {",
          "",
          "---------------"
        ],
        "crypto/dh/dh_key.c||crypto/dh/dh_key.c": [
          "File: crypto/dh/dh_key.c -> crypto/dh/dh_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "125:         goto err;",
          "127:     if (dh->priv_key == NULL) {",
          "129:         if (priv_key == NULL)",
          "130:             goto err;",
          "131:         generate_new_key = 1;",
          "",
          "[Removed Lines]",
          "128:         priv_key = BN_new();",
          "",
          "[Added Lines]",
          "128:         priv_key = BN_secure_new();",
          "",
          "---------------"
        ],
        "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c": [
          "File: crypto/dsa/dsa_ameth.c -> crypto/dsa/dsa_ameth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "245:     if ((dsa = d2i_DSAparams(NULL, &pm, pmlen)) == NULL)",
          "246:         goto decerr;",
          "249:         DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);",
          "250:         goto dsaerr;",
          "251:     }",
          "",
          "[Removed Lines]",
          "248:     if ((dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL)) == NULL) {",
          "",
          "[Added Lines]",
          "248:     if ((dsa->priv_key = BN_secure_new()) == NULL",
          "249:         || !ASN1_INTEGER_to_BN(privkey, dsa->priv_key)) {",
          "",
          "---------------"
        ],
        "crypto/dsa/dsa_asn1.c||crypto/dsa/dsa_asn1.c": [
          "File: crypto/dsa/dsa_asn1.c -> crypto/dsa/dsa_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:         ASN1_SIMPLE(DSA, q, BIGNUM),",
          "114:         ASN1_SIMPLE(DSA, g, BIGNUM),",
          "115:         ASN1_SIMPLE(DSA, pub_key, BIGNUM),",
          "117: } ASN1_SEQUENCE_END_cb(DSA, DSAPrivateKey)",
          "119: IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAPrivateKey, DSAPrivateKey)",
          "",
          "[Removed Lines]",
          "116:         ASN1_SIMPLE(DSA, priv_key, BIGNUM)",
          "",
          "[Added Lines]",
          "116:         ASN1_SIMPLE(DSA, priv_key, CBIGNUM)",
          "",
          "---------------"
        ],
        "crypto/dsa/dsa_key.c||crypto/dsa/dsa_key.c": [
          "File: crypto/dsa/dsa_key.c -> crypto/dsa/dsa_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:         goto err;",
          "84:     if (dsa->priv_key == NULL) {",
          "86:             goto err;",
          "87:     } else",
          "88:         priv_key = dsa->priv_key;",
          "",
          "[Removed Lines]",
          "85:         if ((priv_key = BN_new()) == NULL)",
          "",
          "[Added Lines]",
          "85:         if ((priv_key = BN_secure_new()) == NULL)",
          "",
          "---------------"
        ],
        "crypto/ec/ec_asn1.c||crypto/ec/ec_asn1.c": [
          "File: crypto/ec/ec_asn1.c -> crypto/ec/ec_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1023:     ret->version = priv_key->version;",
          "1025:     if (priv_key->privateKey) {",
          "1026:         ret->priv_key = BN_bin2bn(ASN1_STRING_data(priv_key->privateKey),",
          "1027:                                   ASN1_STRING_length(priv_key->privateKey),",
          "1028:                                   ret->priv_key);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1026:         if (ret->priv_key == NULL)",
          "1027:             ret->priv_key = BN_secure_new();",
          "",
          "---------------"
        ],
        "crypto/mem.c||crypto/mem.c": [
          "File: crypto/mem.c -> crypto/mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95: static void (*free_func) (void *) = free;",
          "97: static void *(*malloc_locked_func) (size_t) = malloc;",
          "98: static void *default_malloc_locked_ex(size_t num, const char *file, int line)",
          "99: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97: static void *(*malloc_secure_func)(size_t) = malloc;",
          "98: static void *default_malloc_secure_ex(size_t num, const char *file, int line)",
          "99: {",
          "100:     return malloc_secure_func(num);",
          "101: }",
          "102: static void *(*malloc_secure_ex_func)(size_t, const char *file, int line)",
          "103:     = default_malloc_secure_ex;",
          "104: static void (*free_secure_func)(void *) = free;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:     realloc_func = r;",
          "146:     realloc_ex_func = default_realloc_ex;",
          "147:     free_func = f;",
          "148:     malloc_locked_func = m;",
          "149:     malloc_locked_ex_func = default_malloc_locked_ex;",
          "150:     free_locked_func = f;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:     malloc_secure_func = m;",
          "160:     malloc_secure_ex_func = default_malloc_secure_ex;",
          "161:     free_secure_func = f;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "164:     realloc_func = 0;",
          "165:     realloc_ex_func = r;",
          "166:     free_func = f;",
          "167:     malloc_locked_func = 0;",
          "168:     malloc_locked_ex_func = m;",
          "169:     free_locked_func = f;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181:     malloc_secure_func = 0;",
          "182:     malloc_secure_ex_func = m;",
          "183:     free_secure_func = f;",
          "184:     malloc_locked_func = 0;",
          "185:     malloc_locked_ex_func = m;",
          "186:     free_locked_func = f;",
          "187:     return 1;",
          "188: }",
          "190: int CRYPTO_set_secure_mem_functions(void *(*m)(size_t), void (*f)(void *))",
          "191: {",
          "193:     OPENSSL_init();",
          "194:     if (!allow_customize)",
          "195:         return 0;",
          "196:     if ((m == 0) || (f == 0))",
          "197:         return 0;",
          "198:     malloc_secure_func = m;",
          "199:     malloc_secure_ex_func = default_malloc_secure_ex;",
          "200:     free_secure_func = f;",
          "203:     malloc_locked_func = m;",
          "204:     malloc_locked_ex_func = default_malloc_secure_ex;",
          "205:     free_locked_func = f;",
          "206:     return 1;",
          "207: }",
          "209: int CRYPTO_set_secure_mem_ex_functions(void *(*m)(size_t, const char *, int),",
          "210:                                        void (*f)(void *))",
          "211: {",
          "212:     if (!allow_customize)",
          "213:         return 0;",
          "214:     if ((m == NULL) || (f == NULL))",
          "215:         return 0;",
          "216:     malloc_secure_func = 0;",
          "217:     malloc_secure_ex_func = m;",
          "218:     free_secure_func = f;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191:         return 0;",
          "192:     malloc_locked_func = 0;",
          "193:     malloc_locked_ex_func = m;",
          "195:     return 1;",
          "196: }",
          "",
          "[Removed Lines]",
          "194:     free_func = f;",
          "",
          "[Added Lines]",
          "246:     free_locked_func = f;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "237: }",
          "239: void CRYPTO_get_locked_mem_functions(void *(**m) (size_t),",
          "240:                                      void (**f) (void *))",
          "241: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291: void CRYPTO_get_secure_mem_functions(void *(**m)(size_t), void (**f)(void *))",
          "292: {",
          "293:     if (m != NULL)",
          "295:             malloc_secure_func : 0;",
          "296:     if (f != NULL)",
          "298:  }",
          "300: void CRYPTO_get_secure_mem_ex_functions(void *(**m)(size_t,const char *,int),",
          "301:                                         void (**f)(void *))",
          "302: {",
          "303:     if (m != NULL)",
          "305:             malloc_secure_ex_func : 0;",
          "306:     if (f != NULL)",
          "308: }",
          "",
          "---------------"
        ],
        "crypto/rsa/rsa_asn1.c||crypto/rsa/rsa_asn1.c": [
          "File: crypto/rsa/rsa_asn1.c -> crypto/rsa/rsa_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85:         ASN1_SIMPLE(RSA, version, LONG),",
          "86:         ASN1_SIMPLE(RSA, n, BIGNUM),",
          "87:         ASN1_SIMPLE(RSA, e, BIGNUM),",
          "94: } ASN1_SEQUENCE_END_cb(RSA, RSAPrivateKey)",
          "",
          "[Removed Lines]",
          "88:         ASN1_SIMPLE(RSA, d, BIGNUM),",
          "89:         ASN1_SIMPLE(RSA, p, BIGNUM),",
          "90:         ASN1_SIMPLE(RSA, q, BIGNUM),",
          "91:         ASN1_SIMPLE(RSA, dmp1, BIGNUM),",
          "92:         ASN1_SIMPLE(RSA, dmq1, BIGNUM),",
          "93:         ASN1_SIMPLE(RSA, iqmp, BIGNUM)",
          "",
          "[Added Lines]",
          "88:         ASN1_SIMPLE(RSA, d, CBIGNUM),",
          "89:         ASN1_SIMPLE(RSA, p, CBIGNUM),",
          "90:         ASN1_SIMPLE(RSA, q, CBIGNUM),",
          "91:         ASN1_SIMPLE(RSA, dmp1, CBIGNUM),",
          "92:         ASN1_SIMPLE(RSA, dmq1, CBIGNUM),",
          "93:         ASN1_SIMPLE(RSA, iqmp, CBIGNUM)",
          "",
          "---------------"
        ],
        "crypto/rsa/rsa_gen.c||crypto/rsa/rsa_gen.c": [
          "File: crypto/rsa/rsa_gen.c -> crypto/rsa/rsa_gen.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:     if (!rsa->n && ((rsa->n = BN_new()) == NULL))",
          "119:         goto err;",
          "121:         goto err;",
          "122:     if (!rsa->e && ((rsa->e = BN_new()) == NULL))",
          "123:         goto err;",
          "125:         goto err;",
          "127:         goto err;",
          "129:         goto err;",
          "131:         goto err;",
          "133:         goto err;",
          "135:     BN_copy(rsa->e, e_value);",
          "",
          "[Removed Lines]",
          "120:     if (!rsa->d && ((rsa->d = BN_new()) == NULL))",
          "124:     if (!rsa->p && ((rsa->p = BN_new()) == NULL))",
          "126:     if (!rsa->q && ((rsa->q = BN_new()) == NULL))",
          "128:     if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))",
          "130:     if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))",
          "132:     if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))",
          "",
          "[Added Lines]",
          "120:     if (!rsa->d && ((rsa->d = BN_secure_new()) == NULL))",
          "124:     if (!rsa->p && ((rsa->p = BN_secure_new()) == NULL))",
          "126:     if (!rsa->q && ((rsa->q = BN_secure_new()) == NULL))",
          "128:     if (!rsa->dmp1 && ((rsa->dmp1 = BN_secure_new()) == NULL))",
          "130:     if (!rsa->dmq1 && ((rsa->dmq1 = BN_secure_new()) == NULL))",
          "132:     if (!rsa->iqmp && ((rsa->iqmp = BN_secure_new()) == NULL))",
          "",
          "---------------"
        ],
        "crypto/sec_mem.c||crypto/sec_mem.c": [
          "File: crypto/sec_mem.c -> crypto/sec_mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <openssl/crypto.h>",
          "14: #include <e_os.h>",
          "15: #include <stdlib.h>",
          "16: #include <unistd.h>",
          "17: #include <string.h>",
          "18: #include <assert.h>",
          "20: #if defined(OPENSSL_SYS_LINUX) || defined(OPENSSL_SYS_UNIX)",
          "21: # define IMPLEMENTED",
          "22: # include <sys/mman.h>",
          "23: # include <sys/param.h>",
          "24: #endif",
          "26: #define LOCK()      CRYPTO_w_lock(CRYPTO_LOCK_MALLOC)",
          "27: #define UNLOCK()    CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC)",
          "28: #define CLEAR(p, s) OPENSSL_cleanse(p, s)",
          "29: #define PAGE_SIZE    4096",
          "31: #ifdef IMPLEMENTED",
          "32: size_t secure_mem_used;",
          "34: static int secure_mem_initialized;",
          "35: static int too_late;",
          "40: static int sh_init(size_t size, int minsize);",
          "41: static char *sh_malloc(size_t size);",
          "42: static void sh_free(char *ptr);",
          "43: static void sh_done(void);",
          "44: static int sh_actual_size(char *ptr);",
          "45: static int sh_allocated(const char *ptr);",
          "46: #endif",
          "48: int CRYPTO_secure_malloc_init(size_t size, int minsize)",
          "49: {",
          "50: #ifdef IMPLEMENTED",
          "51:     int ret = 0;",
          "53:     if (too_late)",
          "54:         return ret;",
          "55:     LOCK();",
          "56:     OPENSSL_assert(!secure_mem_initialized);",
          "57:     if (!secure_mem_initialized) {",
          "58:         ret = sh_init(size, minsize);",
          "59:         secure_mem_initialized = 1;",
          "60:     }",
          "61:     UNLOCK();",
          "62:     return ret;",
          "63: #else",
          "64:     return 0;",
          "66: }",
          "68: void CRYPTO_secure_malloc_done()",
          "69: {",
          "70: #ifdef IMPLEMENTED",
          "71:     LOCK();",
          "72:     sh_done();",
          "73:     secure_mem_initialized = 0;",
          "74:     UNLOCK();",
          "76: }",
          "78: int CRYPTO_secure_malloc_initialized()",
          "79: {",
          "80: #ifdef IMPLEMENTED",
          "81:     return secure_mem_initialized;",
          "82: #else",
          "83:     return 0;",
          "85: }",
          "87: void *CRYPTO_secure_malloc(int num, const char *file, int line)",
          "88: {",
          "89: #ifdef IMPLEMENTED",
          "90:     void *ret;",
          "91:     size_t actual_size;",
          "93:     if (!secure_mem_initialized) {",
          "94:         too_late = 1;",
          "95:         return CRYPTO_malloc(num, file, line);",
          "96:     }",
          "97:     LOCK();",
          "98:     ret = sh_malloc(num);",
          "99:     actual_size = ret ? sh_actual_size(ret) : 0;",
          "100:     secure_mem_used += actual_size;",
          "101:     UNLOCK();",
          "102:     return ret;",
          "103: #else",
          "104:     return CRYPTO_malloc(num, file, line);",
          "106: }",
          "108: void CRYPTO_secure_free(void *ptr)",
          "109: {",
          "110: #ifdef IMPLEMENTED",
          "111:     size_t actual_size;",
          "113:     if (ptr == NULL)",
          "114:         return;",
          "115:     if (!secure_mem_initialized) {",
          "116:         CRYPTO_free(ptr);",
          "117:         return;",
          "118:     }",
          "119:     LOCK();",
          "120:     actual_size = sh_actual_size(ptr);",
          "121:     CLEAR(ptr, actual_size);",
          "122:     secure_mem_used -= actual_size;",
          "123:     sh_free(ptr);",
          "124:     UNLOCK();",
          "125: #else",
          "126:     CRYPTO_free(ptr);",
          "128: }",
          "130: int CRYPTO_secure_allocated(const void *ptr)",
          "131: {",
          "132: #ifdef IMPLEMENTED",
          "133:     int ret;",
          "135:     if (!secure_mem_initialized)",
          "136:         return 0;",
          "137:     LOCK();",
          "138:     ret = sh_allocated(ptr);",
          "139:     UNLOCK();",
          "140:     return ret;",
          "141: #else",
          "142:     return 0;",
          "144: }",
          "153: #ifdef IMPLEMENTED",
          "171: # define TESTBIT(t, b)  (t[(b) >> 3] &  (1 << ((b) & 7)))",
          "172: # define SETBIT(t, b)   (t[(b) >> 3] |= (1 << ((b) & 7)))",
          "173: # define CLEARBIT(t, b) (t[(b) >> 3] &= (0xFF & ~(1 << ((b) & 7))))",
          "175: #define WITHIN_ARENA(p) \\",
          "176:     ((char*)(p) >= sh.arena && (char*)(p) < &sh.arena[sh.arena_size])",
          "177: #define WITHIN_FREELIST(p) \\",
          "178:     ((char*)(p) >= (char*)sh.freelist && (char*)(p) < (char*)&sh.freelist[sh.freelist_size])",
          "181: typedef struct sh_list_st",
          "182: {",
          "183:     struct sh_list_st *next;",
          "184:     struct sh_list_st **p_next;",
          "185: } SH_LIST;",
          "187: typedef struct sh_st",
          "188: {",
          "189:     char* map_result;",
          "190:     size_t map_size;",
          "191:     char *arena;",
          "192:     int arena_size;",
          "193:     char **freelist;",
          "194:     int freelist_size;",
          "195:     int minsize;",
          "196:     unsigned char *bittable;",
          "197:     unsigned char *bitmalloc;",
          "199: } SH;",
          "201: static SH sh;",
          "203: static int sh_getlist(char *ptr)",
          "204: {",
          "205:     int list = sh.freelist_size - 1;",
          "206:     int bit = (sh.arena_size + ptr - sh.arena) / sh.minsize;",
          "208:     for (; bit; bit >>= 1, list--) {",
          "209:         if (TESTBIT(sh.bittable, bit))",
          "210:             break;",
          "211:         OPENSSL_assert((bit & 1) == 0);",
          "212:     }",
          "214:     return list;",
          "215: }",
          "218: static int sh_testbit(char *ptr, int list, unsigned char *table)",
          "219: {",
          "220:     int bit;",
          "222:     OPENSSL_assert(list >= 0 && list < sh.freelist_size);",
          "223:     OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);",
          "224:     bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));",
          "225:     OPENSSL_assert(bit > 0 && bit < sh.bittable_size);",
          "226:     return TESTBIT(table, bit);",
          "227: }",
          "229: static void sh_clearbit(char *ptr, int list, unsigned char *table)",
          "230: {",
          "231:     int bit;",
          "233:     OPENSSL_assert(list >= 0 && list < sh.freelist_size);",
          "234:     OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);",
          "235:     bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));",
          "236:     OPENSSL_assert(bit > 0 && bit < sh.bittable_size);",
          "237:     OPENSSL_assert(TESTBIT(table, bit));",
          "238:     CLEARBIT(table, bit);",
          "239: }",
          "241: static void sh_setbit(char *ptr, int list, unsigned char *table)",
          "242: {",
          "243:     int bit;",
          "245:     OPENSSL_assert(list >= 0 && list < sh.freelist_size);",
          "246:     OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);",
          "247:     bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));",
          "248:     OPENSSL_assert(bit > 0 && bit < sh.bittable_size);",
          "249:     OPENSSL_assert(!TESTBIT(table, bit));",
          "250:     SETBIT(table, bit);",
          "251: }",
          "253: static void sh_add_to_list(char **list, char *ptr)",
          "254: {",
          "255:     SH_LIST *temp;",
          "257:     OPENSSL_assert(WITHIN_FREELIST(list));",
          "258:     OPENSSL_assert(WITHIN_ARENA(ptr));",
          "260:     temp = (SH_LIST *)ptr;",
          "261:     temp->next = *(SH_LIST **)list;",
          "262:     OPENSSL_assert(temp->next == NULL || WITHIN_ARENA(temp->next));",
          "263:     temp->p_next = (SH_LIST **)list;",
          "265:     if (temp->next != NULL) {",
          "266:         OPENSSL_assert((char **)temp->next->p_next == list);",
          "267:         temp->next->p_next = &(temp->next);",
          "268:     }",
          "271: }",
          "273: static void sh_remove_from_list(char *ptr, char *list)",
          "274: {",
          "275:     SH_LIST *temp, *temp2;",
          "277:     temp = (SH_LIST *)ptr;",
          "278:     if (temp->next != NULL)",
          "279:         temp->next->p_next = temp->p_next;",
          "281:     if (temp->next == NULL)",
          "282:         return;",
          "284:     temp2 = temp->next;",
          "285:     OPENSSL_assert(WITHIN_FREELIST(temp2->p_next) || WITHIN_ARENA(temp2->p_next));",
          "286: }",
          "289: static int sh_init(size_t size, int minsize)",
          "290: {",
          "291:     int i, ret;",
          "292:     size_t pgsize;",
          "293:     size_t aligned;",
          "295:     memset(&sh, 0, sizeof sh);",
          "298:     OPENSSL_assert(size > 0);",
          "299:     OPENSSL_assert((size & (size - 1)) == 0);",
          "300:     OPENSSL_assert(minsize > 0);",
          "301:     OPENSSL_assert((minsize & (minsize - 1)) == 0);",
          "302:     if (size <= 0 || (size & (size - 1)) != 0)",
          "303:         goto err;",
          "304:     if (minsize <= 0 || (minsize & (minsize - 1)) != 0)",
          "305:         goto err;",
          "307:     sh.arena_size = size;",
          "308:     sh.minsize = minsize;",
          "309:     sh.bittable_size = (sh.arena_size / sh.minsize) * 2;",
          "311:     sh.freelist_size = -1;",
          "312:     for (i = sh.bittable_size; i; i >>= 1)",
          "313:         sh.freelist_size++;",
          "315:     sh.freelist = OPENSSL_malloc(sh.freelist_size * sizeof (char *));",
          "316:     OPENSSL_assert(sh.freelist != NULL);",
          "317:     if (sh.freelist == NULL)",
          "318:         goto err;",
          "319:     memset(sh.freelist, 0, sh.freelist_size * sizeof (char *));",
          "321:     sh.bittable = OPENSSL_malloc(sh.bittable_size >> 3);",
          "322:     OPENSSL_assert(sh.bittable != NULL);",
          "323:     if (sh.bittable == NULL)",
          "324:         goto err;",
          "325:     memset(sh.bittable, 0, sh.bittable_size >> 3);",
          "327:     sh.bitmalloc = OPENSSL_malloc(sh.bittable_size >> 3);",
          "328:     OPENSSL_assert(sh.bitmalloc != NULL);",
          "329:     if (sh.bitmalloc == NULL)",
          "330:         goto err;",
          "331:     memset(sh.bitmalloc, 0, sh.bittable_size >> 3);",
          "334: #ifdef _SC_PAGE_SIZE",
          "335:     pgsize = (size_t)sysconf(_SC_PAGE_SIZE);",
          "336: #else",
          "337:     pgsize = PAGE_SIZE;",
          "338: #endif",
          "339:     sh.map_size = pgsize + sh.arena_size + pgsize;",
          "340:     sh.map_result = mmap(NULL, sh.map_size,",
          "341:                          PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);",
          "342:     OPENSSL_assert(sh.map_result != MAP_FAILED);",
          "343:     if (sh.map_result == MAP_FAILED)",
          "344:         goto err;",
          "345:     sh.arena = (char *)(sh.map_result + pgsize);",
          "346:     sh_setbit(sh.arena, 0, sh.bittable);",
          "347:     sh_add_to_list(&sh.freelist[0], sh.arena);",
          "350:     ret = 1;",
          "353:     if (mprotect(sh.map_result, pgsize, PROT_NONE) < 0)",
          "354:         ret = 2;",
          "357:     aligned = (pgsize + sh.arena_size + (pgsize - 1)) & ~(pgsize - 1);",
          "358:     if (mprotect(sh.map_result + aligned, pgsize, PROT_NONE) < 0)",
          "359:         ret = 2;",
          "361:     if (mlock(sh.arena, sh.arena_size) < 0)",
          "362:         ret = 2;",
          "363: #ifdef MADV_DONTDUMP",
          "364:     if (madvise(sh.arena, sh.arena_size, MADV_DONTDUMP) < 0)",
          "365:         ret = 2;",
          "366: #endif",
          "368:     return ret;",
          "370:  err:",
          "371:     sh_done();",
          "372:     return 0;",
          "373: }",
          "375: static void sh_done()",
          "376: {",
          "377:     OPENSSL_free(sh.freelist);",
          "378:     OPENSSL_free(sh.bittable);",
          "379:     OPENSSL_free(sh.bitmalloc);",
          "380:     if (sh.map_result != NULL && sh.map_size)",
          "381:         munmap(sh.map_result, sh.map_size);",
          "382:     memset(&sh, 0, sizeof sh);",
          "383: }",
          "385: static int sh_allocated(const char *ptr)",
          "386: {",
          "387:     return WITHIN_ARENA(ptr) ? 1 : 0;",
          "388: }",
          "390: static char *sh_find_my_buddy(char *ptr, int list)",
          "391: {",
          "392:     int bit;",
          "393:     char *chunk = NULL;",
          "395:     bit = (1 << list) + (ptr - sh.arena) / (sh.arena_size >> list);",
          "396:     bit ^= 1;",
          "398:     if (TESTBIT(sh.bittable, bit) && !TESTBIT(sh.bitmalloc, bit))",
          "399:         chunk = sh.arena + ((bit & ((1 << list) - 1)) * (sh.arena_size >> list));",
          "401:     return chunk;",
          "402: }",
          "404: static char *sh_malloc(size_t size)",
          "405: {",
          "406:     int list, slist;",
          "407:     size_t i;",
          "408:     char *chunk;",
          "410:     list = sh.freelist_size - 1;",
          "411:     for (i = sh.minsize; i < size; i <<= 1)",
          "412:         list--;",
          "413:     if (list < 0)",
          "414:         return NULL;",
          "417:     for (slist = list; slist >= 0; slist--)",
          "418:         if (sh.freelist[slist] != NULL)",
          "419:             break;",
          "420:     if (slist < 0)",
          "421:         return NULL;",
          "424:     while (slist != list) {",
          "425:         char *temp = sh.freelist[slist];",
          "428:         OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));",
          "429:         sh_clearbit(temp, slist, sh.bittable);",
          "430:         sh_remove_from_list(temp, sh.freelist[slist]);",
          "431:         OPENSSL_assert(temp != sh.freelist[slist]);",
          "434:         slist++;",
          "437:         OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));",
          "438:         sh_setbit(temp, slist, sh.bittable);",
          "439:         sh_add_to_list(&sh.freelist[slist], temp);",
          "440:         OPENSSL_assert(sh.freelist[slist] == temp);",
          "443:         temp += sh.arena_size >> slist;",
          "444:         OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));",
          "445:         sh_setbit(temp, slist, sh.bittable);",
          "446:         sh_add_to_list(&sh.freelist[slist], temp);",
          "447:         OPENSSL_assert(sh.freelist[slist] == temp);",
          "449:         OPENSSL_assert(temp-(sh.arena_size >> slist) == sh_find_my_buddy(temp, slist));",
          "450:     }",
          "453:     chunk = sh.freelist[list];",
          "454:     OPENSSL_assert(sh_testbit(chunk, list, sh.bittable));",
          "455:     sh_setbit(chunk, list, sh.bitmalloc);",
          "456:     sh_remove_from_list(chunk, sh.freelist[list]);",
          "458:     OPENSSL_assert(WITHIN_ARENA(chunk));",
          "460:     return chunk;",
          "461: }",
          "463: static void sh_free(char *ptr)",
          "464: {",
          "465:     int list;",
          "466:     char *buddy;",
          "468:     if (ptr == NULL)",
          "469:         return;",
          "470:     OPENSSL_assert(WITHIN_ARENA(ptr));",
          "471:     if (!WITHIN_ARENA(ptr))",
          "472:         return;",
          "474:     list = sh_getlist(ptr);",
          "475:     OPENSSL_assert(sh_testbit(ptr, list, sh.bittable));",
          "476:     sh_clearbit(ptr, list, sh.bitmalloc);",
          "477:     sh_add_to_list(&sh.freelist[list], ptr);",
          "480:     while ((buddy = sh_find_my_buddy(ptr, list)) != NULL) {",
          "481:         OPENSSL_assert(ptr == sh_find_my_buddy(buddy, list));",
          "482:         OPENSSL_assert(ptr != NULL);",
          "483:         OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));",
          "484:         sh_clearbit(ptr, list, sh.bittable);",
          "485:         sh_remove_from_list(ptr, sh.freelist[list]);",
          "486:         OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));",
          "487:         sh_clearbit(buddy, list, sh.bittable);",
          "488:         sh_remove_from_list(buddy, sh.freelist[list]);",
          "490:         list--;",
          "492:         if (ptr > buddy)",
          "493:             ptr = buddy;",
          "495:         OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));",
          "496:         sh_setbit(ptr, list, sh.bittable);",
          "497:         sh_add_to_list(&sh.freelist[list], ptr);",
          "498:         OPENSSL_assert(sh.freelist[list] == ptr);",
          "499:     }",
          "500: }",
          "502: static int sh_actual_size(char *ptr)",
          "503: {",
          "504:     int list;",
          "506:     OPENSSL_assert(WITHIN_ARENA(ptr));",
          "507:     if (!WITHIN_ARENA(ptr))",
          "508:         return 0;",
          "509:     list = sh_getlist(ptr);",
          "510:     OPENSSL_assert(sh_testbit(ptr, list, sh.bittable));",
          "511:     return sh.arena_size / (1 << list);",
          "512: }",
          "",
          "---------------"
        ],
        "include/openssl/bio.h||include/openssl/bio.h": [
          "File: include/openssl/bio.h -> include/openssl/bio.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "670:                         long argl, long ret);",
          "672: BIO_METHOD *BIO_s_mem(void);",
          "673: BIO *BIO_new_mem_buf(void *buf, int len);",
          "674: BIO_METHOD *BIO_s_socket(void);",
          "675: BIO_METHOD *BIO_s_connect(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "673: BIO_METHOD *BIO_s_secmem(void);",
          "",
          "---------------"
        ],
        "include/openssl/bn.h||include/openssl/bn.h": [
          "File: include/openssl/bn.h -> include/openssl/bn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "270: # define BN_FLG_CONSTTIME        0x04",
          "272: # ifdef OPENSSL_USE_DEPRECATED",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "271: # define BN_FLG_SECURE           0x08",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "349: const BIGNUM *BN_value_one(void);",
          "350: char *BN_options(void);",
          "351: BN_CTX *BN_CTX_new(void);",
          "352: void BN_CTX_free(BN_CTX *c);",
          "353: void BN_CTX_start(BN_CTX *ctx);",
          "354: BIGNUM *BN_CTX_get(BN_CTX *ctx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353: BN_CTX *BN_CTX_secure_new(void);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "361: int BN_num_bits_word(BN_ULONG l);",
          "362: int BN_security_bits(int L, int N);",
          "363: BIGNUM *BN_new(void);",
          "364: void BN_clear_free(BIGNUM *a);",
          "365: BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);",
          "366: void BN_swap(BIGNUM *a, BIGNUM *b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "366: BIGNUM *BN_secure_new(void);",
          "",
          "---------------"
        ],
        "include/openssl/buffer.h||include/openssl/buffer.h": [
          "File: include/openssl/buffer.h -> include/openssl/buffer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:     char *data;",
          "81: };",
          "83: BUF_MEM *BUF_MEM_new(void);",
          "84: void BUF_MEM_free(BUF_MEM *a);",
          "85: size_t BUF_MEM_grow(BUF_MEM *str, size_t len);",
          "86: size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "81:     unsigned long flags;",
          "84: # define BUF_MEM_FLAG_SECURE  0x01",
          "87: BUF_MEM *BUF_MEM_new_ex(unsigned long flags);",
          "",
          "---------------"
        ],
        "include/openssl/crypto.h||include/openssl/crypto.h": [
          "File: include/openssl/crypto.h -> include/openssl/crypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "491: int CRYPTO_set_mem_functions(void *(*m) (size_t), void *(*r) (void *, size_t),",
          "492:                              void (*f) (void *));",
          "493: int CRYPTO_set_locked_mem_functions(void *(*m) (size_t),",
          "495: int CRYPTO_set_mem_ex_functions(void *(*m) (size_t, const char *, int),",
          "496:                                 void *(*r) (void *, size_t, const char *,",
          "497:                                             int), void (*f) (void *));",
          "498: int CRYPTO_set_locked_mem_ex_functions(void *(*m) (size_t, const char *, int),",
          "500: int CRYPTO_set_mem_debug_functions(void (*m)",
          "501:                                     (void *, int, const char *, int, int),",
          "502:                                    void (*r) (void *, void *, int,",
          "",
          "[Removed Lines]",
          "494:                                     void (*free_func) (void *));",
          "499:                                        void (*free_func) (void *));",
          "",
          "[Added Lines]",
          "494:                                     void (*f) (void *));",
          "499:                                        void (*f) (void *));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "532:                            int line);",
          "533: void *CRYPTO_remalloc(void *addr, int num, const char *file, int line);",
          "535: void OPENSSL_cleanse(void *ptr, size_t len);",
          "537: void CRYPTO_set_mem_debug_options(long bits);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535: # define OPENSSL_secure_malloc(num) \\",
          "536:         CRYPTO_secure_malloc((int)num,__FILE__,__LINE__)",
          "537: # define OPENSSL_secure_free(addr) \\",
          "538:         CRYPTO_secure_free(addr)",
          "540: int CRYPTO_secure_malloc_init(size_t sz, int minsize);",
          "541: void CRYPTO_secure_malloc_done(void);",
          "542: void *CRYPTO_secure_malloc(int num, const char *file, int line);",
          "543: void CRYPTO_secure_free(void *ptr);",
          "544: int CRYPTO_secure_allocated(const void *ptr);",
          "545: int CRYPTO_secure_malloc_initialized(void);",
          "547: int CRYPTO_set_secure_mem_functions(void *(*m)(size_t), void (*f)(void *));",
          "548: int CRYPTO_set_secure_mem_ex_functions(void *(*m)(size_t,const char *,int),",
          "549:                                        void (*f)(void *));",
          "550: void CRYPTO_get_secure_mem_functions(void *(**m)(size_t), void (**f)(void *));",
          "551: void CRYPTO_get_secure_mem_ex_functions(void *(**m)(size_t,const char *,int),",
          "552:                                         void (**f)(void *));",
          "",
          "---------------"
        ],
        "test/secmemtest.c||test/secmemtest.c": [
          "File: test/secmemtest.c -> test/secmemtest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include <openssl/crypto.h>",
          "4: int main(int argc, char **argv)",
          "5: {",
          "6: #if defined(OPENSSL_SYS_LINUX) || defined(OPENSSL_SYS_UNIX)",
          "7:     char *p = NULL, *q = NULL;",
          "9:     if (!CRYPTO_secure_malloc_init(4096, 32)) {",
          "10:         perror(\"failed\");",
          "11:         return 1;",
          "12:     }",
          "13:     p = OPENSSL_secure_malloc(20);",
          "14:     if (!CRYPTO_secure_allocated(p)) {",
          "15:         perror(\"failed 1\");",
          "16:         return 1;",
          "17:     }",
          "18:     q = OPENSSL_malloc(20);",
          "19:     if (CRYPTO_secure_allocated(q)) {",
          "20:         perror(\"failed 1\");",
          "21:         return 1;",
          "22:     }",
          "23:     CRYPTO_secure_free(p);",
          "24:     CRYPTO_free(q);",
          "25:     CRYPTO_secure_malloc_done();",
          "26: #else",
          "28:     if (CRYPTO_secure_malloc_init(4096, 32)) {",
          "29:         perror(\"failed\");",
          "30:         return 1;",
          "31:     }",
          "32: #endif",
          "33:     return 0;",
          "34: }",
          "",
          "---------------"
        ],
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4573: PKCS8_set0_pbe                          4932 EXIST::FUNCTION:",
          "4574: DH_bits                                 4933 EXIST::FUNCTION:DH",
          "4575: RSA_bits                                4934 EXIST::FUNCTION:RSA",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4576: CRYPTO_set_secure_mem_ex_functions      4935 EXIST::FUNCTION:",
          "4577: CRYPTO_secure_allocated                 4936 EXIST::FUNCTION:",
          "4578: BN_CTX_secure_new                       4937 EXIST::FUNCTION:",
          "4579: CRYPTO_secure_malloc                    4938 EXIST::FUNCTION:",
          "4580: CRYPTO_secure_malloc_done               4939 EXIST::FUNCTION:",
          "4581: BUF_MEM_new_ex                          4940 EXIST::FUNCTION:",
          "4582: CRYPTO_secure_malloc_initialized        4941 EXIST::FUNCTION:",
          "4583: CRYPTO_secure_malloc_init               4942 EXIST::FUNCTION:",
          "4584: CRYPTO_get_secure_mem_functions         4943 EXIST::FUNCTION:",
          "4585: BN_secure_new                           4944 EXIST::FUNCTION:",
          "4586: CRYPTO_secure_free                      4945 EXIST::FUNCTION:",
          "4587: BIO_s_secmem                            4946 EXIST::FUNCTION:",
          "4588: CRYPTO_get_secure_mem_ex_functions      4947 EXIST::FUNCTION:",
          "4589: CRYPTO_set_secure_mem_functions         4948 EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "551a2f26aa54f0a9210128f3b4c1c4a7e8a85e41",
      "candidate_info": {
        "commit_hash": "551a2f26aa54f0a9210128f3b4c1c4a7e8a85e41",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/551a2f26aa54f0a9210128f3b4c1c4a7e8a85e41",
        "files": [
          "util/libeay.num"
        ],
        "message": "make update\n\nReviewed-by: Tim Hudson <tjh@openssl.org>",
        "before_after_code_files": [
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4610: X509_CRL_get_version                    4961 EXIST::FUNCTION:",
          "4611: X509_CRL_get_lastUpdate                 4962 EXIST::FUNCTION:",
          "4612: EVP_PBE_get                             4964 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4613: X509_get_version                        4965 EXIST::FUNCTION:",
          "4614: X509_get_X509_PUBKEY                    4966 EXIST::FUNCTION:",
          "4615: X509_get_notBefore                      4967 EXIST::FUNCTION:",
          "4616: X509_get_notAfter                       4968 EXIST::FUNCTION:",
          "4617: X509_get_signature_type                 4969 EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c742f56e94176d4274bb31e796e9ea9eb084f60f",
      "candidate_info": {
        "commit_hash": "c742f56e94176d4274bb31e796e9ea9eb084f60f",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/c742f56e94176d4274bb31e796e9ea9eb084f60f",
        "files": [
          "crypto/async/Makefile",
          "crypto/err/Makefile",
          "util/libeay.num"
        ],
        "message": "make update\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
        "before_after_code_files": [
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4660: ASYNC_clear_wake                        5020 EXIST::FUNCTION:",
          "4661: ASYNC_get_current_job                   5021 EXIST::FUNCTION:",
          "4662: ASYNC_get_wait_fd                       5022 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4663: ERR_load_ASYNC_strings                  5023 EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eef53ee50bc6f0a6e74b27b6cfa07df44513074f",
      "candidate_info": {
        "commit_hash": "eef53ee50bc6f0a6e74b27b6cfa07df44513074f",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/eef53ee50bc6f0a6e74b27b6cfa07df44513074f",
        "files": [
          "crypto/ecdh/ecdh.h",
          "crypto/ecdsa/ecdsa.h",
          "util/libeay.num",
          "util/ssleay.num"
        ],
        "message": "Update ordinals, fix error message.\n\nUpdate error messages to say \"EC is disabled\" these can then be picked up\nby mkdef.pl.\n\nUpdate ordinals.\n\nReviewed-by: Kurt Roeckx <kurt@openssl.org>",
        "before_after_code_files": [
          "crypto/ecdh/ecdh.h||crypto/ecdh/ecdh.h",
          "crypto/ecdsa/ecdsa.h||crypto/ecdsa/ecdsa.h",
          "util/libeay.num||util/libeay.num",
          "util/ssleay.num||util/ssleay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "crypto/ecdh/ecdh.h||crypto/ecdh/ecdh.h": [
          "File: crypto/ecdh/ecdh.h -> crypto/ecdh/ecdh.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: # include <openssl/opensslconf.h>",
          "74: # ifdef OPENSSL_NO_EC",
          "76: # endif",
          "78: # include <openssl/ec.h>",
          "",
          "[Removed Lines]",
          "75: #  error ECDH is disabled.",
          "",
          "[Added Lines]",
          "75: #  error EC is disabled.",
          "",
          "---------------"
        ],
        "crypto/ecdsa/ecdsa.h||crypto/ecdsa/ecdsa.h": [
          "File: crypto/ecdsa/ecdsa.h -> crypto/ecdsa/ecdsa.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: # include <openssl/opensslconf.h>",
          "64: # ifdef OPENSSL_NO_EC",
          "66: # endif",
          "68: # include <openssl/ec.h>",
          "",
          "[Removed Lines]",
          "65: #  error ECDSA is disabled.",
          "",
          "[Added Lines]",
          "65: #  error EC is disabled.",
          "",
          "---------------"
        ],
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "2913: GENERAL_SUBTREE_free                    3349 EXIST::FUNCTION:",
          "2914: NAME_CONSTRAINTS_it                     3350 EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:",
          "2915: NAME_CONSTRAINTS_it                     3350 EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:",
          "2917: PKCS12_add_safe                         3352 EXIST::FUNCTION:",
          "2918: EC_KEY_new_by_curve_name                3353 EXIST::FUNCTION:EC",
          "2919: STORE_meth_get_update_store_fn          3354 NOEXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "2916: ECDH_get_default_method                 3351 EXIST::FUNCTION:ECDH",
          "",
          "[Added Lines]",
          "2916: ECDH_get_default_method                 3351 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2961: STORE_modify_arbitrary                  3392 NOEXIST::FUNCTION:",
          "2962: ENGINE_get_static_state                 3393 EXIST::FUNCTION:ENGINE",
          "2963: pqueue_iterator                         3394 EXIST::FUNCTION:",
          "2965: OPENSSL_DIR_end                         3396 EXIST::FUNCTION:",
          "2966: BN_GF2m_mod_sqr                         3397 EXIST::FUNCTION:EC2M",
          "2967: EC_POINT_bn2point                       3398 EXIST::FUNCTION:EC",
          "",
          "[Removed Lines]",
          "2964: ECDSA_SIG_new                           3395 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "2964: ECDSA_SIG_new                           3395 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2969: EC_KEY_set_asn1_flag                    3400 EXIST::FUNCTION:EC",
          "2970: STORE_get_method                        3401 NOEXIST::FUNCTION:",
          "2971: EC_KEY_get_key_method_data              3402 EXIST::FUNCTION:EC",
          "2973: STORE_parse_attrs_end                   3404 NOEXIST::FUNCTION:",
          "2974: EC_GROUP_get_point_conversion_form      3405 EXIST:!VMS:FUNCTION:EC",
          "2975: EC_GROUP_get_point_conv_form            3405 EXIST:VMS:FUNCTION:EC",
          "",
          "[Removed Lines]",
          "2972: ECDSA_sign_ex                           3403 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "2972: ECDSA_sign_ex                           3403 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2983: X509_VERIFY_PARAM_set1_name             3413 EXIST::FUNCTION:",
          "2984: X509_VERIFY_PARAM_set_purpose           3414 EXIST::FUNCTION:",
          "2985: STORE_get_number                        3415 NOEXIST::FUNCTION:",
          "2987: BN_GF2m_mod_solve_quad_arr              3417 EXIST::FUNCTION:EC2M",
          "2988: EC_KEY_up_ref                           3418 EXIST::FUNCTION:EC",
          "2989: POLICY_MAPPING_free                     3419 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "2986: ECDSA_sign_setup                        3416 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "2986: ECDSA_sign_setup                        3416 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3008: STORE_new_engine                        3435 NOEXIST::FUNCTION:",
          "3009: STORE_list_public_key_start             3436 NOEXIST::FUNCTION:",
          "3010: X509_VERIFY_PARAM_new                   3437 EXIST::FUNCTION:",
          "3012: EVP_PKEY_get_attr                       3439 EXIST::FUNCTION:",
          "3014: ENGINE_unregister_ECDH                  3441 EXIST::FUNCTION:ENGINE",
          "3016: EC_KEY_set_conv_form                    3443 EXIST::FUNCTION:EC",
          "3017: EC_POINT_dup                            3444 EXIST::FUNCTION:EC",
          "3018: GENERAL_SUBTREE_new                     3445 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3011: ECDH_get_ex_data                        3438 EXIST::FUNCTION:ECDH",
          "3013: ECDSA_do_sign                           3440 EXIST::FUNCTION:ECDSA",
          "3015: ECDH_OpenSSL                            3442 EXIST::FUNCTION:ECDH",
          "",
          "[Added Lines]",
          "3011: ECDH_get_ex_data                        3438 EXIST::FUNCTION:EC",
          "3013: ECDSA_do_sign                           3440 EXIST::FUNCTION:EC",
          "3015: ECDH_OpenSSL                            3442 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3026: i2d_ECPrivateKey_bio                    3452 EXIST::FUNCTION:EC",
          "3027: ECPKParameters_print_fp                 3453 EXIST::FUNCTION:EC,STDIO",
          "3028: pqueue_find                             3454 EXIST::FUNCTION:",
          "3030: PEM_write_bio_ECPKParameters            3456 EXIST::FUNCTION:EC",
          "3031: STORE_method_set_ctrl_function          3457 NOEXIST::FUNCTION:",
          "3032: STORE_list_public_key_end               3458 NOEXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3029: ECDSA_SIG_free                          3455 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3029: ECDSA_SIG_free                          3455 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3084: STORE_delete_arbitrary                  3506 NOEXIST::FUNCTION:",
          "3085: PEM_read_X509_CERT_PAIR                 3507 NOEXIST::FUNCTION:",
          "3086: X509_STORE_set_depth                    3508 EXIST::FUNCTION:",
          "3088: SHA224                                  3510 EXIST::FUNCTION:",
          "3089: BIO_dump_indent_fp                      3511 EXIST::FUNCTION:STDIO",
          "3090: EC_KEY_set_group                        3512 EXIST::FUNCTION:EC",
          "",
          "[Removed Lines]",
          "3087: ECDSA_get_ex_data                       3509 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3087: ECDSA_get_ex_data                       3509 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3097: PEM_read_bio_EC_PUBKEY                  3519 EXIST::FUNCTION:EC",
          "3098: STORE_list_private_key_end              3520 NOEXIST::FUNCTION:",
          "3099: i2d_EC_PUBKEY                           3521 EXIST::FUNCTION:EC",
          "3101: ASN1_put_eoc                            3523 EXIST::FUNCTION:",
          "3102: X509_STORE_CTX_get_explicit_policy      3524 EXIST:!VMS:FUNCTION:",
          "3103: X509_STORE_CTX_get_expl_policy          3524 EXIST:VMS:FUNCTION:",
          "",
          "[Removed Lines]",
          "3100: ECDSA_get_default_method                3522 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3100: ECDSA_get_default_method                3522 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3128: ENGINE_set_default_ECDSA                3546 EXIST::FUNCTION:ENGINE",
          "3129: POLICY_CONSTRAINTS_new                  3547 EXIST::FUNCTION:",
          "3130: BN_GF2m_mod_sqrt                        3548 EXIST::FUNCTION:EC2M",
          "3132: EC_KEY_generate_key                     3550 EXIST::FUNCTION:EC",
          "3133: SHA384_Update                           3551 EXIST:!VMSVAX:FUNCTION:",
          "3134: BN_GF2m_arr2poly                        3552 EXIST::FUNCTION:EC2M",
          "",
          "[Removed Lines]",
          "3131: ECDH_set_default_method                 3549 EXIST::FUNCTION:ECDH",
          "",
          "[Added Lines]",
          "3131: ECDH_set_default_method                 3549 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3173: EC_GROUP_get_asn1_flag                  3587 EXIST::FUNCTION:EC",
          "3174: STORE_ATTR_INFO_in_ex                   3588 NOEXIST::FUNCTION:",
          "3175: STORE_list_crl_start                    3589 NOEXIST::FUNCTION:",
          "3177: STORE_meth_get_modify_fn                3591 NOEXIST::FUNCTION:",
          "3178: STORE_method_get_modify_function        3591 NOEXIST::FUNCTION:",
          "3179: v2i_ASN1_BIT_STRING                     3592 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3176: ECDH_get_ex_new_index                   3590 EXIST::FUNCTION:ECDH",
          "",
          "[Added Lines]",
          "3176: ECDH_get_ex_new_index                   3590 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3197: EC_KEY_get0_private_key                 3608 EXIST::FUNCTION:EC",
          "3198: PEM_write_EC_PUBKEY                     3609 EXIST::FUNCTION:EC",
          "3199: X509_VERIFY_PARAM_set1                  3610 EXIST::FUNCTION:",
          "3201: v2i_GENERAL_NAME_ex                     3612 EXIST::FUNCTION:",
          "3203: STORE_generate_key                      3614 NOEXIST::FUNCTION:",
          "3204: BN_nist_mod_521                         3615 EXIST::FUNCTION:",
          "3205: X509_policy_tree_get0_level             3616 EXIST::FUNCTION:",
          "3206: EC_GROUP_set_point_conversion_form      3617 EXIST:!VMS:FUNCTION:EC",
          "3207: EC_GROUP_set_point_conv_form            3617 EXIST:VMS:FUNCTION:EC",
          "3208: PEM_read_EC_PUBKEY                      3618 EXIST::FUNCTION:EC",
          "3211: STORE_delete_crl                        3621 NOEXIST::FUNCTION:",
          "3212: EC_KEY_get_enc_flags                    3622 EXIST::FUNCTION:EC",
          "3213: ASN1_const_check_infinite_end           3623 EXIST::FUNCTION:",
          "3214: EVP_PKEY_delete_attr                    3624 EXIST::FUNCTION:",
          "3216: EC_POINT_set_compressed_coordinates_GF2m 3626 EXIST:!VMS:FUNCTION:EC,EC2M",
          "3217: EC_POINT_set_compr_coords_GF2m          3626 EXIST:VMS:FUNCTION:EC,EC2M",
          "3218: EC_GROUP_cmp                            3627 EXIST::FUNCTION:EC",
          "",
          "[Removed Lines]",
          "3200: ECDH_set_method                         3611 EXIST::FUNCTION:ECDH",
          "3202: ECDH_set_ex_data                        3613 EXIST::FUNCTION:ECDH",
          "3209: i2d_ECDSA_SIG                           3619 EXIST::FUNCTION:ECDSA",
          "3210: ECDSA_OpenSSL                           3620 EXIST::FUNCTION:ECDSA",
          "3215: ECDSA_set_default_method                3625 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3200: ECDH_set_method                         3611 EXIST::FUNCTION:EC",
          "3202: ECDH_set_ex_data                        3613 EXIST::FUNCTION:EC",
          "3209: i2d_ECDSA_SIG                           3619 EXIST::FUNCTION:EC",
          "3210: ECDSA_OpenSSL                           3620 EXIST::FUNCTION:EC",
          "3215: ECDSA_set_default_method                3625 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3225: SHA512_Init                             3633 EXIST:!VMSVAX:FUNCTION:",
          "3226: STORE_parse_attrs_endp                  3634 NOEXIST::FUNCTION:",
          "3227: BN_set_negative                         3635 EXIST::FUNCTION:",
          "3229: EC_GROUP_get_basis_type                 3637 EXIST::FUNCTION:EC",
          "3230: STORE_list_public_key_next              3638 NOEXIST::FUNCTION:",
          "3231: i2v_ASN1_BIT_STRING                     3639 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3228: ERR_load_ECDSA_strings                  3636 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3228: ERR_load_ECDSA_strings                  3636 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3233: BN_nist_mod_384                         3641 EXIST::FUNCTION:",
          "3234: i2d_X509_CERT_PAIR                      3642 NOEXIST::FUNCTION:",
          "3235: PEM_write_ECPKParameters                3643 EXIST::FUNCTION:EC",
          "3237: STORE_ATTR_INFO_get0_sha1str            3645 NOEXIST::FUNCTION:",
          "3238: ENGINE_register_all_ECDH                3646 EXIST::FUNCTION:ENGINE",
          "3239: pqueue_pop                              3647 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3236: ECDH_compute_key                        3644 EXIST::FUNCTION:ECDH",
          "",
          "[Added Lines]",
          "3236: ECDH_compute_key                        3644 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3258: EC_KEY_new                              3663 EXIST::FUNCTION:EC",
          "3259: SHA256_Transform                        3664 EXIST::FUNCTION:",
          "3260: EC_KEY_set_enc_flags                    3665 EXIST::FUNCTION:EC",
          "3262: EC_POINT_point2hex                      3667 EXIST::FUNCTION:EC",
          "3263: ENGINE_get_STORE                        3668 EXIST::FUNCTION:ENGINE",
          "3264: SHA512                                  3669 EXIST:!VMSVAX:FUNCTION:",
          "3265: STORE_get_certificate                   3670 NOEXIST::FUNCTION:",
          "3268: d2i_ECPrivateKey_fp                     3673 EXIST::FUNCTION:EC,STDIO",
          "3269: STORE_delete_certificate                3674 NOEXIST::FUNCTION:",
          "3270: SHA512_Transform                        3675 EXIST:!VMSVAX:FUNCTION:",
          "",
          "[Removed Lines]",
          "3261: ECDSA_verify                            3666 EXIST::FUNCTION:ECDSA",
          "3266: ECDSA_do_sign_ex                        3671 EXIST::FUNCTION:ECDSA",
          "3267: ECDSA_do_verify                         3672 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3261: ECDSA_verify                            3666 EXIST::FUNCTION:EC",
          "3266: ECDSA_do_sign_ex                        3671 EXIST::FUNCTION:EC",
          "3267: ECDSA_do_verify                         3672 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3301: X509_VERIFY_PARAM_add0_table            3703 EXIST::FUNCTION:",
          "3302: pqueue_free                             3704 EXIST::FUNCTION:",
          "3303: BN_BLINDING_create_param                3705 EXIST::FUNCTION:",
          "3305: d2i_EC_PUBKEY_bio                       3707 EXIST::FUNCTION:EC",
          "3306: BN_get0_nist_prime_521                  3708 EXIST::FUNCTION:",
          "3307: STORE_ATTR_INFO_modify_sha1str          3709 NOEXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3304: ECDSA_size                              3706 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3304: ECDSA_size                              3706 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3313: STORE_meth_get_cleanup_fn               3715 NOEXIST::FUNCTION:",
          "3314: STORE_method_get_cleanup_function       3715 NOEXIST::FUNCTION:",
          "3315: ENGINE_get_ECDH                         3716 EXIST::FUNCTION:ENGINE",
          "3317: BN_is_prime_fasttest_ex                 3718 EXIST::FUNCTION:",
          "3319: X509_policy_check                       3720 EXIST::FUNCTION:",
          "3320: EVP_PKEY_get_attr_by_NID                3721 EXIST::FUNCTION:",
          "3321: STORE_set_ex_data                       3722 NOEXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3316: d2i_ECDSA_SIG                           3717 EXIST::FUNCTION:ECDSA",
          "3318: ECDSA_sign                              3719 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3316: d2i_ECDSA_SIG                           3717 EXIST::FUNCTION:EC",
          "3318: ECDSA_sign                              3719 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3324: BN_BLINDING_get_flags                   3725 EXIST::FUNCTION:",
          "3325: PKCS12_add_cert                         3726 EXIST::FUNCTION:",
          "3326: STORE_OBJECT_new                        3727 NOEXIST::FUNCTION:",
          "3328: EC_KEY_dup                              3729 EXIST::FUNCTION:EC",
          "3329: EVP_CIPHER_CTX_rand_key                 3730 EXIST::FUNCTION:",
          "3331: a2i_IPADDRESS_NC                        3732 EXIST::FUNCTION:",
          "3332: d2i_ECParameters                        3733 EXIST::FUNCTION:EC",
          "3333: STORE_list_certificate_end              3734 NOEXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3327: ERR_load_ECDH_strings                   3728 EXIST::FUNCTION:ECDH",
          "3330: ECDSA_set_method                        3731 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3327: ERR_load_ECDH_strings                   3728 EXIST::FUNCTION:EC",
          "3330: ECDSA_set_method                        3731 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3335: X509_POLICY_NODE_print                  3736 EXIST::FUNCTION:",
          "3336: SHA384_Init                             3737 EXIST:!VMSVAX:FUNCTION:",
          "3337: EC_GF2m_simple_method                   3738 EXIST::FUNCTION:EC,EC2M",
          "3339: SHA384_Final                            3740 EXIST:!VMSVAX:FUNCTION:",
          "3340: PKCS7_set_digest                        3741 EXIST::FUNCTION:",
          "3341: EC_KEY_print                            3742 EXIST::FUNCTION:EC",
          "3342: STORE_meth_set_lock_store_fn            3743 NOEXIST::FUNCTION:",
          "3343: STORE_method_set_lock_store_function    3743 NOEXIST::FUNCTION:",
          "3345: SHA384                                  3745 EXIST:!VMSVAX:FUNCTION:",
          "3346: POLICY_MAPPING_new                      3746 EXIST::FUNCTION:",
          "3347: STORE_list_certificate_endp             3747 NOEXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3338: ECDSA_set_ex_data                       3739 EXIST::FUNCTION:ECDSA",
          "3344: ECDSA_get_ex_new_index                  3744 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "3338: ECDSA_set_ex_data                       3739 EXIST::FUNCTION:EC",
          "3344: ECDSA_get_ex_new_index                  3744 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "4354: CRYPTO_128_wrap                         4720 EXIST::FUNCTION:",
          "4355: RSA_OAEP_PARAMS_new                     4721 EXIST::FUNCTION:RSA",
          "4356: CRYPTO_128_unwrap                       4722 EXIST::FUNCTION:",
          "4358: CMS_RecipientInfo_kari_decrypt          4724 EXIST::FUNCTION:CMS",
          "4359: CMS_SignerInfo_get0_pkey_ctx            4725 EXIST::FUNCTION:CMS",
          "4362: CMS_RecipientInfo_kari_orig_id_cmp      4728 EXIST:!VMS:FUNCTION:CMS",
          "4363: CMS_RecipInfo_kari_orig_id_cmp          4728 EXIST:VMS:FUNCTION:CMS",
          "4364: CMS_RecipientInfo_kari_get0_alg         4729 EXIST::FUNCTION:CMS",
          "4365: EVP_aes_192_wrap                        4730 EXIST::FUNCTION:AES",
          "4366: EVP_aes_128_cbc_hmac_sha256             4731 EXIST::FUNCTION:AES",
          "4367: DH_compute_key_padded                   4732 EXIST::FUNCTION:DH",
          "4369: CMS_RecipientEncryptedKey_cert_cmp      4734 EXIST:!VMS:FUNCTION:CMS",
          "4370: CMS_RecipEncryptedKey_cert_cmp          4734 EXIST:VMS:FUNCTION:CMS",
          "4371: DH_KDF_X9_42                            4735 EXIST::FUNCTION:DH",
          "",
          "[Removed Lines]",
          "4357: ECDSA_METHOD_set_name                   4723 EXIST::FUNCTION:ECDSA",
          "4360: ECDSA_METHOD_set_flags                  4726 EXIST::FUNCTION:ECDSA",
          "4361: ECDSA_METHOD_set_sign_setup             4727 EXIST::FUNCTION:ECDSA",
          "4368: ECDSA_METHOD_set_sign                   4733 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "4357: ECDSA_METHOD_set_name                   4723 EXIST::FUNCTION:EC",
          "4360: ECDSA_METHOD_set_flags                  4726 EXIST::FUNCTION:EC",
          "4361: ECDSA_METHOD_set_sign_setup             4727 EXIST::FUNCTION:EC",
          "4368: ECDSA_METHOD_set_sign                   4733 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4385: CMS_RecipInfo_kari_set0_pkey            4746 EXIST:VMS:FUNCTION:CMS",
          "4386: i2d_RSA_OAEP_PARAMS                     4747 EXIST::FUNCTION:RSA",
          "4387: d2i_RSA_OAEP_PARAMS                     4748 EXIST::FUNCTION:RSA",
          "4389: CMS_RecipientInfo_kari_get0_ctx         4750 EXIST::FUNCTION:CMS",
          "4391: CMS_RecipientInfo_get0_pkey_ctx         4752 EXIST::FUNCTION:CMS",
          "4392: CMS_RecipientEncryptedKey_get0_id       4753 EXIST:!VMS:FUNCTION:CMS",
          "4393: CMS_RecipEncryptedKey_get0_id           4753 EXIST:VMS:FUNCTION:CMS",
          "4394: RSA_pad_check_PKCS1_OAEP_mgf1           4754 NOEXIST::FUNCTION:",
          "4395: RSA_padding_check_PKCS1_OAEP_mgf1       4754 EXIST:!VMS:FUNCTION:RSA",
          "4396: RSA_padding_chk_PKCS1_OAEP_mgf1         4754 EXIST:VMS:FUNCTION:RSA",
          "4398: CMS_SharedInfo_encode                   4756 EXIST::FUNCTION:CMS",
          "4399: RSA_padding_add_PKCS1_OAEP_mgf1         4757 EXIST::FUNCTION:RSA",
          "4400: CMS_RecipientInfo_kari_get0_orig_id     4758 EXIST:!VMS:FUNCTION:CMS",
          "4401: CMS_RecipInfo_kari_get0_orig_id         4758 EXIST:VMS:FUNCTION:CMS",
          "4403: X509_VERIFY_PARAM_get_count             4760 EXIST::FUNCTION:",
          "4404: X509_VERIFY_PARAM_get0_name             4761 EXIST::FUNCTION:",
          "4405: X509_VERIFY_PARAM_get0                  4762 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "4388: ECDH_KDF_X9_62                          4749 EXIST::FUNCTION:ECDH",
          "4390: ECDSA_METHOD_new                        4751 EXIST::FUNCTION:ECDSA",
          "4397: ECDSA_METHOD_set_verify                 4755 EXIST::FUNCTION:ECDSA",
          "4402: ECDSA_METHOD_free                       4759 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "4388: ECDH_KDF_X9_62                          4749 EXIST::FUNCTION:EC",
          "4390: ECDSA_METHOD_new                        4751 EXIST::FUNCTION:EC",
          "4397: ECDSA_METHOD_set_verify                 4755 EXIST::FUNCTION:EC",
          "4402: ECDSA_METHOD_free                       4759 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4408: X509_VERIFY_PARAM_set_hostflags         4765 EXIST::FUNCTION:",
          "4409: BUF_strnlen                             4766 EXIST::FUNCTION:",
          "4410: X509_VERIFY_PARAM_get0_peername         4767 EXIST::FUNCTION:",
          "4412: sk_deep_copy                            4769 EXIST::FUNCTION:",
          "4414: X509_VERIFY_PARAM_add1_host             4771 EXIST::FUNCTION:",
          "4415: EC_GROUP_get_mont_data                  4772 EXIST::FUNCTION:EC",
          "4416: i2d_re_X509_tbs                         4773 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "4411: ECDSA_METHOD_set_app_data               4768 EXIST::FUNCTION:ECDSA",
          "4413: ECDSA_METHOD_get_app_data               4770 EXIST::FUNCTION:ECDSA",
          "",
          "[Added Lines]",
          "4411: ECDSA_METHOD_set_app_data               4768 EXIST::FUNCTION:EC",
          "4413: ECDSA_METHOD_get_app_data               4770 EXIST::FUNCTION:EC",
          "",
          "---------------"
        ],
        "util/ssleay.num||util/ssleay.num": [
          "File: util/ssleay.num -> util/ssleay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "217: SSL_CTX_set_msg_callback                266 EXIST::FUNCTION:",
          "218: SSL_set_msg_callback                    267 EXIST::FUNCTION:",
          "219: DTLSv1_client_method                    268 EXIST::FUNCTION:",
          "222: SSL_COMP_get_name                       271 EXIST::FUNCTION:COMP",
          "223: SSL_get_current_compression             272 EXIST::FUNCTION:COMP",
          "224: DTLSv1_method                           273 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "220: SSL_CTX_set_tmp_ecdh_callback           269 EXIST::FUNCTION:ECDH",
          "221: SSL_set_tmp_ecdh_callback               270 EXIST::FUNCTION:ECDH",
          "",
          "[Added Lines]",
          "220: SSL_CTX_set_tmp_ecdh_callback           269 EXIST::FUNCTION:EC",
          "221: SSL_set_tmp_ecdh_callback               270 EXIST::FUNCTION:EC",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "388: SSL_set_security_callback               423 EXIST::FUNCTION:",
          "389: SSL_CTX_get_security_level              424 EXIST::FUNCTION:",
          "390: SSL_CTX_get0_security_ex_data           425 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "391: SSL_SESSION_has_ticket                  426 EXIST::FUNCTION:",
          "392: SSL_set_wbio                            427 EXIST::FUNCTION:",
          "393: SSL_SESSION_get0_ticket                 428 EXIST::FUNCTION:",
          "394: SSL_SESSION_get_ticket_lifetime_hint    429 EXIST::FUNCTION:",
          "395: SSL_set_rbio                            430 EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-18811",
  "cve_desc": "A memory leak in the sof_set_get_large_ctrl_data() function in sound/soc/sof/ipc.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering sof_get_ctrl_copy_params() failures, aka CID-45c1380358b1.",
  "repo": "torvalds/linux",
  "patch_hash": "45c1380358b12bf2d1db20a5874e9544f56b34ab",
  "patch_info": {
    "commit_hash": "45c1380358b12bf2d1db20a5874e9544f56b34ab",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/45c1380358b12bf2d1db20a5874e9544f56b34ab",
    "files": [
      "sound/soc/sof/ipc.c"
    ],
    "message": "ASoC: SOF: ipc: Fix memory leak in sof_set_get_large_ctrl_data\n\nIn the implementation of sof_set_get_large_ctrl_data() there is a memory\nleak in case an error. Release partdata if sof_get_ctrl_copy_params()\nfails.\n\nFixes: 54d198d5019d (\"ASoC: SOF: Propagate sof_get_ctrl_copy_params() error properly\")\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nLink: https://lore.kernel.org/r/20191027215330.12729-1-navid.emamdoost@gmail.com\nSigned-off-by: Mark Brown <broonie@kernel.org>",
    "before_after_code_files": [
      "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c"
    ]
  },
  "patch_diff": {
    "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c": [
      "File: sound/soc/sof/ipc.c -> sound/soc/sof/ipc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "572:  else",
      "573:   err = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,",
      "574:             sparams);",
      "576:   return err;",
      "578:  msg_bytes = sparams->msg_bytes;",
      "579:  pl_size = sparams->pl_size;",
      "",
      "[Removed Lines]",
      "575:  if (err < 0)",
      "",
      "[Added Lines]",
      "575:  if (err < 0) {",
      "576:   kfree(partdata);",
      "578:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "53e0c72d98ba3eae314c32476103eac47612aa58",
      "candidate_info": {
        "commit_hash": "53e0c72d98ba3eae314c32476103eac47612aa58",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/53e0c72d98ba3eae314c32476103eac47612aa58",
        "files": [
          "include/sound/sof/control.h",
          "include/sound/sof/dai-intel.h",
          "include/sound/sof/dai.h",
          "include/sound/sof/header.h",
          "include/sound/sof/info.h",
          "include/sound/sof/pm.h",
          "include/sound/sof/stream.h",
          "include/sound/sof/trace.h",
          "sound/soc/sof/ipc.c"
        ],
        "message": "ASoC: SOF: Add support for IPC IO between DSP and Host\n\nDefine an IPC ABI for all host <--> DSP communication. This ABI should\nbe transport agnostic. i.e. it should work on MMIO and SPI/I2C style\ninterfaces.\n\nSigned-off-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>\nSigned-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>\nSigned-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>\nReviewed-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Mark Brown <broonie@kernel.org>",
        "before_after_code_files": [
          "include/sound/sof/control.h||include/sound/sof/control.h",
          "include/sound/sof/dai-intel.h||include/sound/sof/dai-intel.h",
          "include/sound/sof/dai.h||include/sound/sof/dai.h",
          "include/sound/sof/header.h||include/sound/sof/header.h",
          "include/sound/sof/info.h||include/sound/sof/info.h",
          "include/sound/sof/pm.h||include/sound/sof/pm.h",
          "include/sound/sof/stream.h||include/sound/sof/stream.h",
          "include/sound/sof/trace.h||include/sound/sof/trace.h",
          "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c"
          ],
          "candidate": [
            "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c"
          ]
        }
      },
      "candidate_diff": {
        "include/sound/sof/control.h||include/sound/sof/control.h": [
          "File: include/sound/sof/control.h -> include/sound/sof/control.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_CONTROL_H__",
          "10: #define __INCLUDE_SOUND_SOF_CONTROL_H__",
          "12: #include <uapi/sound/sof/header.h>",
          "13: #include <sound/sof/header.h>",
          "20: enum sof_ipc_chmap {",
          "21:  SOF_CHMAP_UNKNOWN = 0,",
          "58:  SOF_CHMAP_LAST = SOF_CHMAP_BRC,",
          "59: };",
          "62: enum sof_ipc_ctrl_type {",
          "64:  SOF_CTRL_TYPE_VALUE_CHAN_GET = 0,",
          "65:  SOF_CTRL_TYPE_VALUE_CHAN_SET,",
          "67:  SOF_CTRL_TYPE_VALUE_COMP_GET,",
          "68:  SOF_CTRL_TYPE_VALUE_COMP_SET,",
          "70:  SOF_CTRL_TYPE_DATA_GET,",
          "71:  SOF_CTRL_TYPE_DATA_SET,",
          "72: };",
          "75: enum sof_ipc_ctrl_cmd {",
          "80: };",
          "83: struct sof_ipc_ctrl_value_chan {",
          "85:  uint32_t value;",
          "86: } __packed;",
          "89: struct sof_ipc_ctrl_value_comp {",
          "91:  union {",
          "92:   uint32_t uvalue;",
          "93:   int32_t svalue;",
          "94:  };",
          "95: } __packed;",
          "98: struct sof_ipc_ctrl_data {",
          "99:  struct sof_ipc_reply rhdr;",
          "100:  uint32_t comp_id;",
          "108:  struct sof_ipc_host_buffer buffer;",
          "115:  uint32_t reserved[6];",
          "118:  union {",
          "120:   struct sof_ipc_ctrl_value_chan chanv[0];",
          "122:   struct sof_ipc_ctrl_value_comp compv[0];",
          "124:   struct sof_abi_hdr data[0];",
          "125:  };",
          "126: } __packed;",
          "129: enum sof_ipc_ctrl_event_type {",
          "134: };",
          "139: struct sof_ipc_comp_event {",
          "140:  struct sof_ipc_reply rhdr;",
          "147:  uint32_t reserved[8];",
          "150:  union {",
          "152:   struct sof_abi_hdr data[0];",
          "154:   uint32_t event_value;",
          "155:  };",
          "156: } __packed;",
          "158: #endif",
          "",
          "---------------"
        ],
        "include/sound/sof/dai-intel.h||include/sound/sof/dai-intel.h": [
          "File: include/sound/sof/dai-intel.h -> include/sound/sof/dai-intel.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_DAI_INTEL_H__",
          "10: #define __INCLUDE_SOUND_SOF_DAI_INTEL_H__",
          "12: #include <sound/sof/header.h>",
          "15: #define SOF_DAI_INTEL_SSP_QUIRK_TINTE  (1 << 0)",
          "17: #define SOF_DAI_INTEL_SSP_QUIRK_PINTE  (1 << 1)",
          "19: #define SOF_DAI_INTEL_SSP_QUIRK_SMTATF  (1 << 2)",
          "21: #define SOF_DAI_INTEL_SSP_QUIRK_MMRATF  (1 << 3)",
          "23: #define SOF_DAI_INTEL_SSP_QUIRK_PSPSTWFDFD (1 << 4)",
          "25: #define SOF_DAI_INTEL_SSP_QUIRK_PSPSRWFDFD (1 << 5)",
          "27: #define SOF_DAI_INTEL_SSP_QUIRK_LBM  (1 << 6)",
          "31: #define SOF_DAI_INTEL_SSP_FRAME_PULSE_WIDTH_MAX  38",
          "32: #define SOF_DAI_INTEL_SSP_SLOT_PADDING_MAX  31",
          "40: #define SOF_DAI_INTEL_SSP_MCLK_0_DISABLE  BIT(0)",
          "42: #define SOF_DAI_INTEL_SSP_MCLK_1_DISABLE  BIT(1)",
          "44: #define SOF_DAI_INTEL_SSP_CLKCTRL_MCLK_KA  BIT(2)",
          "46: #define SOF_DAI_INTEL_SSP_CLKCTRL_BCLK_KA  BIT(3)",
          "48: #define SOF_DAI_INTEL_SSP_CLKCTRL_FS_KA   BIT(4)",
          "50: #define SOF_DAI_INTEL_SSP_CLKCTRL_BCLK_IDLE_HIGH BIT(5)",
          "53: struct sof_ipc_dai_ssp_params {",
          "54:  struct sof_ipc_hdr hdr;",
          "55:  uint16_t reserved1;",
          "56:  uint16_t mclk_id;",
          "63:  uint32_t tdm_slots;",
          "64:  uint32_t rx_slots;",
          "65:  uint32_t tx_slots;",
          "68:  uint32_t sample_valid_bits;",
          "69:  uint16_t tdm_slot_width;",
          "73:  uint32_t mclk_direction;",
          "75:  uint16_t frame_pulse_width;",
          "76:  uint16_t tdm_per_slot_padding_flag;",
          "77:  uint32_t clks_control;",
          "78:  uint32_t quirks;",
          "79: } __packed;",
          "82: struct sof_ipc_dai_hda_params {",
          "83:  struct sof_ipc_hdr hdr;",
          "84:  uint32_t link_dma_ch;",
          "85: } __packed;",
          "106: struct sof_ipc_dai_dmic_pdm_ctrl {",
          "107:  struct sof_ipc_hdr hdr;",
          "120: } __packed;",
          "151: struct sof_ipc_dai_dmic_params {",
          "152:  struct sof_ipc_hdr hdr;",
          "172:  uint32_t reserved[6];",
          "175:  struct sof_ipc_dai_dmic_pdm_ctrl pdm[0];",
          "176: } __packed;",
          "178: #endif",
          "",
          "---------------"
        ],
        "include/sound/sof/dai.h||include/sound/sof/dai.h": [
          "File: include/sound/sof/dai.h -> include/sound/sof/dai.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_DAI_H__",
          "10: #define __INCLUDE_SOUND_SOF_DAI_H__",
          "12: #include <sound/sof/header.h>",
          "13: #include <sound/sof/dai-intel.h>",
          "41: #define SOF_DAI_FMT_FORMAT_MASK  0x000f",
          "42: #define SOF_DAI_FMT_CLOCK_MASK  0x00f0",
          "43: #define SOF_DAI_FMT_INV_MASK  0x0f00",
          "44: #define SOF_DAI_FMT_MASTER_MASK  0xf000",
          "47: enum sof_ipc_dai_type {",
          "52: };",
          "55: struct sof_ipc_dai_config {",
          "56:  struct sof_ipc_cmd_hdr hdr;",
          "65:  uint32_t reserved[8];",
          "68:  union {",
          "69:   struct sof_ipc_dai_ssp_params ssp;",
          "70:   struct sof_ipc_dai_dmic_params dmic;",
          "71:   struct sof_ipc_dai_hda_params hda;",
          "72:  };",
          "73: } __packed;",
          "75: #endif",
          "",
          "---------------"
        ],
        "include/sound/sof/header.h||include/sound/sof/header.h": [
          "File: include/sound/sof/header.h -> include/sound/sof/header.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_HEADER_H__",
          "10: #define __INCLUDE_SOUND_SOF_HEADER_H__",
          "12: #include <uapi/sound/sof/abi.h>",
          "32: #define SOF_GLB_TYPE_SHIFT   28",
          "33: #define SOF_GLB_TYPE_MASK   (0xf << SOF_GLB_TYPE_SHIFT)",
          "34: #define SOF_GLB_TYPE(x)    ((x) << SOF_GLB_TYPE_SHIFT)",
          "37: #define SOF_CMD_TYPE_SHIFT   16",
          "38: #define SOF_CMD_TYPE_MASK   (0xfff << SOF_CMD_TYPE_SHIFT)",
          "39: #define SOF_CMD_TYPE(x)    ((x) << SOF_CMD_TYPE_SHIFT)",
          "42: #define SOF_IPC_GLB_REPLY   SOF_GLB_TYPE(0x1U)",
          "43: #define SOF_IPC_GLB_COMPOUND   SOF_GLB_TYPE(0x2U)",
          "44: #define SOF_IPC_GLB_TPLG_MSG   SOF_GLB_TYPE(0x3U)",
          "45: #define SOF_IPC_GLB_PM_MSG   SOF_GLB_TYPE(0x4U)",
          "46: #define SOF_IPC_GLB_COMP_MSG   SOF_GLB_TYPE(0x5U)",
          "47: #define SOF_IPC_GLB_STREAM_MSG   SOF_GLB_TYPE(0x6U)",
          "48: #define SOF_IPC_FW_READY   SOF_GLB_TYPE(0x7U)",
          "49: #define SOF_IPC_GLB_DAI_MSG   SOF_GLB_TYPE(0x8U)",
          "50: #define SOF_IPC_GLB_TRACE_MSG   SOF_GLB_TYPE(0x9U)",
          "57: #define SOF_IPC_TPLG_COMP_NEW   SOF_CMD_TYPE(0x001)",
          "58: #define SOF_IPC_TPLG_COMP_FREE   SOF_CMD_TYPE(0x002)",
          "59: #define SOF_IPC_TPLG_COMP_CONNECT  SOF_CMD_TYPE(0x003)",
          "60: #define SOF_IPC_TPLG_PIPE_NEW   SOF_CMD_TYPE(0x010)",
          "61: #define SOF_IPC_TPLG_PIPE_FREE   SOF_CMD_TYPE(0x011)",
          "62: #define SOF_IPC_TPLG_PIPE_CONNECT  SOF_CMD_TYPE(0x012)",
          "63: #define SOF_IPC_TPLG_PIPE_COMPLETE  SOF_CMD_TYPE(0x013)",
          "64: #define SOF_IPC_TPLG_BUFFER_NEW   SOF_CMD_TYPE(0x020)",
          "65: #define SOF_IPC_TPLG_BUFFER_FREE  SOF_CMD_TYPE(0x021)",
          "68: #define SOF_IPC_PM_CTX_SAVE   SOF_CMD_TYPE(0x001)",
          "69: #define SOF_IPC_PM_CTX_RESTORE   SOF_CMD_TYPE(0x002)",
          "70: #define SOF_IPC_PM_CTX_SIZE   SOF_CMD_TYPE(0x003)",
          "71: #define SOF_IPC_PM_CLK_SET   SOF_CMD_TYPE(0x004)",
          "72: #define SOF_IPC_PM_CLK_GET   SOF_CMD_TYPE(0x005)",
          "73: #define SOF_IPC_PM_CLK_REQ   SOF_CMD_TYPE(0x006)",
          "74: #define SOF_IPC_PM_CORE_ENABLE   SOF_CMD_TYPE(0x007)",
          "77: #define SOF_IPC_COMP_SET_VALUE   SOF_CMD_TYPE(0x001)",
          "78: #define SOF_IPC_COMP_GET_VALUE   SOF_CMD_TYPE(0x002)",
          "79: #define SOF_IPC_COMP_SET_DATA   SOF_CMD_TYPE(0x003)",
          "80: #define SOF_IPC_COMP_GET_DATA   SOF_CMD_TYPE(0x004)",
          "83: #define SOF_IPC_DAI_CONFIG   SOF_CMD_TYPE(0x001)",
          "84: #define SOF_IPC_DAI_LOOPBACK   SOF_CMD_TYPE(0x002)",
          "87: #define SOF_IPC_STREAM_PCM_PARAMS  SOF_CMD_TYPE(0x001)",
          "88: #define SOF_IPC_STREAM_PCM_PARAMS_REPLY  SOF_CMD_TYPE(0x002)",
          "89: #define SOF_IPC_STREAM_PCM_FREE   SOF_CMD_TYPE(0x003)",
          "90: #define SOF_IPC_STREAM_TRIG_START  SOF_CMD_TYPE(0x004)",
          "91: #define SOF_IPC_STREAM_TRIG_STOP  SOF_CMD_TYPE(0x005)",
          "92: #define SOF_IPC_STREAM_TRIG_PAUSE  SOF_CMD_TYPE(0x006)",
          "93: #define SOF_IPC_STREAM_TRIG_RELEASE  SOF_CMD_TYPE(0x007)",
          "94: #define SOF_IPC_STREAM_TRIG_DRAIN  SOF_CMD_TYPE(0x008)",
          "95: #define SOF_IPC_STREAM_TRIG_XRUN  SOF_CMD_TYPE(0x009)",
          "96: #define SOF_IPC_STREAM_POSITION   SOF_CMD_TYPE(0x00a)",
          "97: #define SOF_IPC_STREAM_VORBIS_PARAMS  SOF_CMD_TYPE(0x010)",
          "98: #define SOF_IPC_STREAM_VORBIS_FREE  SOF_CMD_TYPE(0x011)",
          "101: #define SOF_IPC_TRACE_DMA_PARAMS  SOF_CMD_TYPE(0x001)",
          "102: #define SOF_IPC_TRACE_DMA_POSITION  SOF_CMD_TYPE(0x002)",
          "105: #define SOF_IPC_MESSAGE_ID(x)   ((x) & 0xffff)",
          "108: #define SOF_IPC_MSG_MAX_SIZE   384",
          "117: struct sof_ipc_hdr {",
          "119: } __packed;",
          "128: struct sof_ipc_cmd_hdr {",
          "131: } __packed;",
          "137: struct sof_ipc_reply {",
          "138:  struct sof_ipc_cmd_hdr hdr;",
          "140: }  __packed;",
          "151: struct sof_ipc_compound_hdr {",
          "152:  struct sof_ipc_cmd_hdr hdr;",
          "154: }  __packed;",
          "158: #endif",
          "",
          "---------------"
        ],
        "include/sound/sof/info.h||include/sound/sof/info.h": [
          "File: include/sound/sof/info.h -> include/sound/sof/info.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_INFO_H__",
          "10: #define __INCLUDE_SOUND_SOF_INFO_H__",
          "12: #include <sound/sof/header.h>",
          "13: #include <sound/sof/stream.h>",
          "19: #define SOF_IPC_MAX_ELEMS 16",
          "22: enum sof_ipc_ext_data {",
          "23:  SOF_IPC_EXT_DMA_BUFFER = 0,",
          "24:  SOF_IPC_EXT_WINDOW,",
          "25: };",
          "28: struct sof_ipc_fw_version {",
          "29:  struct sof_ipc_hdr hdr;",
          "30:  uint16_t major;",
          "31:  uint16_t minor;",
          "32:  uint16_t micro;",
          "33:  uint16_t build;",
          "34:  uint8_t date[12];",
          "35:  uint8_t time[10];",
          "36:  uint8_t tag[6];",
          "37:  uint32_t abi_version;",
          "40:  uint32_t reserved[4];",
          "41: } __packed;",
          "44: struct sof_ipc_fw_ready {",
          "45:  struct sof_ipc_cmd_hdr hdr;",
          "48:  uint32_t dspbox_size;",
          "49:  uint32_t hostbox_size;",
          "50:  struct sof_ipc_fw_version version;",
          "53:  union {",
          "54:   uint64_t reserved;",
          "55:   struct {",
          "56:    uint64_t build:1;",
          "57:    uint64_t locks:1;",
          "58:    uint64_t locks_verbose:1;",
          "59:    uint64_t gdb:1;",
          "60:   } bits;",
          "61:  } debug;",
          "64:  uint32_t reserved[4];",
          "65: } __packed;",
          "70: enum sof_ipc_region {",
          "71:  SOF_IPC_REGION_DOWNBOX = 0,",
          "72:  SOF_IPC_REGION_UPBOX,",
          "73:  SOF_IPC_REGION_TRACE,",
          "74:  SOF_IPC_REGION_DEBUG,",
          "75:  SOF_IPC_REGION_STREAM,",
          "76:  SOF_IPC_REGION_REGS,",
          "77:  SOF_IPC_REGION_EXCEPTION,",
          "78: };",
          "80: struct sof_ipc_ext_data_hdr {",
          "81:  struct sof_ipc_cmd_hdr hdr;",
          "83: } __packed;",
          "85: struct sof_ipc_dma_buffer_elem {",
          "86:  struct sof_ipc_hdr hdr;",
          "89:  struct sof_ipc_host_buffer buffer;",
          "90: } __packed;",
          "93: struct sof_ipc_dma_buffer_data {",
          "94:  struct sof_ipc_ext_data_hdr ext_hdr;",
          "95:  uint32_t num_buffers;",
          "98:  struct sof_ipc_dma_buffer_elem buffer[];",
          "99: }  __packed;",
          "101: struct sof_ipc_window_elem {",
          "102:  struct sof_ipc_hdr hdr;",
          "108:  uint32_t offset;",
          "109: } __packed;",
          "112: struct sof_ipc_window {",
          "113:  struct sof_ipc_ext_data_hdr ext_hdr;",
          "114:  uint32_t num_windows;",
          "115:  struct sof_ipc_window_elem window[];",
          "116: }  __packed;",
          "118: #endif",
          "",
          "---------------"
        ],
        "include/sound/sof/pm.h||include/sound/sof/pm.h": [
          "File: include/sound/sof/pm.h -> include/sound/sof/pm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_PM_H__",
          "10: #define __INCLUDE_SOUND_SOF_PM_H__",
          "12: #include <sound/sof/header.h>",
          "19: struct sof_ipc_pm_ctx_elem {",
          "20:  struct sof_ipc_hdr hdr;",
          "21:  uint32_t type;",
          "22:  uint32_t size;",
          "23:  uint64_t addr;",
          "24: }  __packed;",
          "30: struct sof_ipc_pm_ctx {",
          "31:  struct sof_ipc_cmd_hdr hdr;",
          "32:  struct sof_ipc_host_buffer buffer;",
          "33:  uint32_t num_elems;",
          "34:  uint32_t size;",
          "37:  uint32_t reserved[8];",
          "39:  struct sof_ipc_pm_ctx_elem elems[];",
          "40: } __packed;",
          "43: struct sof_ipc_pm_core_config {",
          "44:  struct sof_ipc_cmd_hdr hdr;",
          "45:  uint32_t enable_mask;",
          "46: } __packed;",
          "48: #endif",
          "",
          "---------------"
        ],
        "include/sound/sof/stream.h||include/sound/sof/stream.h": [
          "File: include/sound/sof/stream.h -> include/sound/sof/stream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_STREAM_H__",
          "10: #define __INCLUDE_SOUND_SOF_STREAM_H__",
          "12: #include <sound/sof/header.h>",
          "18: #define SOF_IPC_MAX_CHANNELS   8",
          "44: enum sof_ipc_frame {",
          "45:  SOF_IPC_FRAME_S16_LE = 0,",
          "46:  SOF_IPC_FRAME_S24_4LE,",
          "47:  SOF_IPC_FRAME_S32_LE,",
          "48:  SOF_IPC_FRAME_FLOAT,",
          "50: };",
          "53: enum sof_ipc_buffer_format {",
          "54:  SOF_IPC_BUFFER_INTERLEAVED,",
          "55:  SOF_IPC_BUFFER_NONINTERLEAVED,",
          "57: };",
          "60: enum sof_ipc_stream_direction {",
          "61:  SOF_IPC_STREAM_PLAYBACK = 0,",
          "62:  SOF_IPC_STREAM_CAPTURE,",
          "63: };",
          "66: struct sof_ipc_host_buffer {",
          "67:  struct sof_ipc_hdr hdr;",
          "68:  uint32_t phy_addr;",
          "69:  uint32_t pages;",
          "70:  uint32_t size;",
          "71:  uint32_t reserved[3];",
          "72: } __packed;",
          "74: struct sof_ipc_stream_params {",
          "75:  struct sof_ipc_hdr hdr;",
          "76:  struct sof_ipc_host_buffer buffer;",
          "80:  uint32_t rate;",
          "81:  uint16_t stream_tag;",
          "82:  uint16_t channels;",
          "83:  uint16_t sample_valid_bytes;",
          "84:  uint16_t sample_container_bytes;",
          "87:  uint32_t host_period_bytes;",
          "89:  uint32_t reserved[2];",
          "91: } __packed;",
          "94: struct sof_ipc_pcm_params {",
          "95:  struct sof_ipc_cmd_hdr hdr;",
          "96:  uint32_t comp_id;",
          "98:  uint32_t reserved[2];",
          "99:  struct sof_ipc_stream_params params;",
          "100: }  __packed;",
          "103: struct sof_ipc_pcm_params_reply {",
          "104:  struct sof_ipc_reply rhdr;",
          "105:  uint32_t comp_id;",
          "106:  uint32_t posn_offset;",
          "107: } __packed;",
          "110: struct sof_ipc_stream {",
          "111:  struct sof_ipc_cmd_hdr hdr;",
          "112:  uint32_t comp_id;",
          "113: } __packed;",
          "116: #define SOF_TIME_HOST_SYNC (1 << 0)",
          "117: #define SOF_TIME_DAI_SYNC (1 << 1)",
          "118: #define SOF_TIME_WALL_SYNC (1 << 2)",
          "119: #define SOF_TIME_STAMP_SYNC (1 << 3)",
          "122: #define SOF_TIME_HOST_VALID (1 << 8)",
          "123: #define SOF_TIME_DAI_VALID (1 << 9)",
          "124: #define SOF_TIME_WALL_VALID (1 << 10)",
          "125: #define SOF_TIME_STAMP_VALID (1 << 11)",
          "128: #define SOF_TIME_HOST_64 (1 << 16)",
          "129: #define SOF_TIME_DAI_64  (1 << 17)",
          "130: #define SOF_TIME_WALL_64 (1 << 18)",
          "131: #define SOF_TIME_STAMP_64 (1 << 19)",
          "133: struct sof_ipc_stream_posn {",
          "134:  struct sof_ipc_reply rhdr;",
          "146: }  __packed;",
          "148: #endif",
          "",
          "---------------"
        ],
        "include/sound/sof/trace.h||include/sound/sof/trace.h": [
          "File: include/sound/sof/trace.h -> include/sound/sof/trace.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #ifndef __INCLUDE_SOUND_SOF_TRACE_H__",
          "10: #define __INCLUDE_SOUND_SOF_TRACE_H__",
          "12: #include <sound/sof/header.h>",
          "13: #include <sound/sof/stream.h>",
          "19: #define SOF_TRACE_FILENAME_SIZE  32",
          "22: struct sof_ipc_dma_trace_params {",
          "23:  struct sof_ipc_cmd_hdr hdr;",
          "24:  struct sof_ipc_host_buffer buffer;",
          "25:  uint32_t stream_tag;",
          "26: }  __packed;",
          "29: struct sof_ipc_dma_trace_posn {",
          "30:  struct sof_ipc_reply rhdr;",
          "34: }  __packed;",
          "43: #define SOF_IPC_PANIC_MAGIC   0x0dead000",
          "44: #define SOF_IPC_PANIC_MAGIC_MASK  0x0ffff000",
          "45: #define SOF_IPC_PANIC_CODE_MASK   0x00000fff",
          "46: #define SOF_IPC_PANIC_MEM   (SOF_IPC_PANIC_MAGIC | 0x0)",
          "47: #define SOF_IPC_PANIC_WORK   (SOF_IPC_PANIC_MAGIC | 0x1)",
          "48: #define SOF_IPC_PANIC_IPC   (SOF_IPC_PANIC_MAGIC | 0x2)",
          "49: #define SOF_IPC_PANIC_ARCH   (SOF_IPC_PANIC_MAGIC | 0x3)",
          "50: #define SOF_IPC_PANIC_PLATFORM   (SOF_IPC_PANIC_MAGIC | 0x4)",
          "51: #define SOF_IPC_PANIC_TASK   (SOF_IPC_PANIC_MAGIC | 0x5)",
          "52: #define SOF_IPC_PANIC_EXCEPTION   (SOF_IPC_PANIC_MAGIC | 0x6)",
          "53: #define SOF_IPC_PANIC_DEADLOCK   (SOF_IPC_PANIC_MAGIC | 0x7)",
          "54: #define SOF_IPC_PANIC_STACK   (SOF_IPC_PANIC_MAGIC | 0x8)",
          "55: #define SOF_IPC_PANIC_IDLE   (SOF_IPC_PANIC_MAGIC | 0x9)",
          "56: #define SOF_IPC_PANIC_WFI   (SOF_IPC_PANIC_MAGIC | 0xa)",
          "57: #define SOF_IPC_PANIC_ASSERT   (SOF_IPC_PANIC_MAGIC | 0xb)",
          "60: struct sof_ipc_panic_info {",
          "61:  struct sof_ipc_hdr hdr;",
          "63:  char filename[SOF_TRACE_FILENAME_SIZE];",
          "64:  uint32_t linenum;",
          "65: }  __packed;",
          "67: #endif",
          "",
          "---------------"
        ],
        "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c": [
          "File: sound/soc/sof/ipc.c -> sound/soc/sof/ipc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include <linux/mutex.h>",
          "15: #include <linux/types.h>",
          "17: #include \"sof-priv.h\"",
          "18: #include \"ops.h\"",
          "24: #define IPC_TIMEOUT_MS  300",
          "26: static void ipc_trace_message(struct snd_sof_dev *sdev, u32 msg_id);",
          "27: static void ipc_stream_message(struct snd_sof_dev *sdev, u32 msg_cmd);",
          "34: struct snd_sof_ipc {",
          "35:  struct snd_sof_dev *sdev;",
          "38:  struct mutex tx_mutex;",
          "40:  bool disable_ipc_tx;",
          "42:  struct snd_sof_ipc_msg msg;",
          "43: };",
          "45: struct sof_ipc_ctrl_data_params {",
          "46:  size_t msg_bytes;",
          "47:  size_t hdr_bytes;",
          "48:  size_t pl_size;",
          "49:  size_t elems;",
          "50:  u32 num_msg;",
          "51:  u8 *src;",
          "52:  u8 *dst;",
          "53: };",
          "55: #if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_VERBOSE_IPC)",
          "56: static void ipc_log_header(struct device *dev, u8 *text, u32 cmd)",
          "57: {",
          "58:  u8 *str;",
          "59:  u8 *str2 = NULL;",
          "60:  u32 glb;",
          "61:  u32 type;",
          "63:  glb = cmd & SOF_GLB_TYPE_MASK;",
          "64:  type = cmd & SOF_CMD_TYPE_MASK;",
          "66:  switch (glb) {",
          "67:  case SOF_IPC_GLB_REPLY:",
          "68:   str = \"GLB_REPLY\"; break;",
          "69:  case SOF_IPC_GLB_COMPOUND:",
          "70:   str = \"GLB_COMPOUND\"; break;",
          "71:  case SOF_IPC_GLB_TPLG_MSG:",
          "72:   str = \"GLB_TPLG_MSG\";",
          "73:   switch (type) {",
          "74:   case SOF_IPC_TPLG_COMP_NEW:",
          "75:    str2 = \"COMP_NEW\"; break;",
          "76:   case SOF_IPC_TPLG_COMP_FREE:",
          "77:    str2 = \"COMP_FREE\"; break;",
          "78:   case SOF_IPC_TPLG_COMP_CONNECT:",
          "79:    str2 = \"COMP_CONNECT\"; break;",
          "80:   case SOF_IPC_TPLG_PIPE_NEW:",
          "81:    str2 = \"PIPE_NEW\"; break;",
          "82:   case SOF_IPC_TPLG_PIPE_FREE:",
          "83:    str2 = \"PIPE_FREE\"; break;",
          "84:   case SOF_IPC_TPLG_PIPE_CONNECT:",
          "85:    str2 = \"PIPE_CONNECT\"; break;",
          "86:   case SOF_IPC_TPLG_PIPE_COMPLETE:",
          "87:    str2 = \"PIPE_COMPLETE\"; break;",
          "88:   case SOF_IPC_TPLG_BUFFER_NEW:",
          "89:    str2 = \"BUFFER_NEW\"; break;",
          "90:   case SOF_IPC_TPLG_BUFFER_FREE:",
          "91:    str2 = \"BUFFER_FREE\"; break;",
          "92:   default:",
          "93:    str2 = \"unknown type\"; break;",
          "94:   }",
          "95:   break;",
          "96:  case SOF_IPC_GLB_PM_MSG:",
          "97:   str = \"GLB_PM_MSG\";",
          "98:   switch (type) {",
          "99:   case SOF_IPC_PM_CTX_SAVE:",
          "100:    str2 = \"CTX_SAVE\"; break;",
          "101:   case SOF_IPC_PM_CTX_RESTORE:",
          "102:    str2 = \"CTX_RESTORE\"; break;",
          "103:   case SOF_IPC_PM_CTX_SIZE:",
          "104:    str2 = \"CTX_SIZE\"; break;",
          "105:   case SOF_IPC_PM_CLK_SET:",
          "106:    str2 = \"CLK_SET\"; break;",
          "107:   case SOF_IPC_PM_CLK_GET:",
          "108:    str2 = \"CLK_GET\"; break;",
          "109:   case SOF_IPC_PM_CLK_REQ:",
          "110:    str2 = \"CLK_REQ\"; break;",
          "111:   case SOF_IPC_PM_CORE_ENABLE:",
          "112:    str2 = \"CORE_ENABLE\"; break;",
          "113:   default:",
          "114:    str2 = \"unknown type\"; break;",
          "115:   }",
          "116:   break;",
          "117:  case SOF_IPC_GLB_COMP_MSG:",
          "118:   str = \"GLB_COMP_MSG: SET_VALUE\";",
          "119:   switch (type) {",
          "120:   case SOF_IPC_COMP_SET_VALUE:",
          "121:    str2 = \"SET_VALUE\"; break;",
          "122:   case SOF_IPC_COMP_GET_VALUE:",
          "123:    str2 = \"GET_VALUE\"; break;",
          "124:   case SOF_IPC_COMP_SET_DATA:",
          "125:    str2 = \"SET_DATA\"; break;",
          "126:   case SOF_IPC_COMP_GET_DATA:",
          "127:    str2 = \"GET_DATA\"; break;",
          "128:   default:",
          "129:    str2 = \"unknown type\"; break;",
          "130:   }",
          "131:   break;",
          "132:  case SOF_IPC_GLB_STREAM_MSG:",
          "133:   str = \"GLB_STREAM_MSG\";",
          "134:   switch (type) {",
          "135:   case SOF_IPC_STREAM_PCM_PARAMS:",
          "136:    str2 = \"PCM_PARAMS\"; break;",
          "137:   case SOF_IPC_STREAM_PCM_PARAMS_REPLY:",
          "138:    str2 = \"PCM_REPLY\"; break;",
          "139:   case SOF_IPC_STREAM_PCM_FREE:",
          "140:    str2 = \"PCM_FREE\"; break;",
          "141:   case SOF_IPC_STREAM_TRIG_START:",
          "142:    str2 = \"TRIG_START\"; break;",
          "143:   case SOF_IPC_STREAM_TRIG_STOP:",
          "144:    str2 = \"TRIG_STOP\"; break;",
          "145:   case SOF_IPC_STREAM_TRIG_PAUSE:",
          "146:    str2 = \"TRIG_PAUSE\"; break;",
          "147:   case SOF_IPC_STREAM_TRIG_RELEASE:",
          "148:    str2 = \"TRIG_RELEASE\"; break;",
          "149:   case SOF_IPC_STREAM_TRIG_DRAIN:",
          "150:    str2 = \"TRIG_DRAIN\"; break;",
          "151:   case SOF_IPC_STREAM_TRIG_XRUN:",
          "152:    str2 = \"TRIG_XRUN\"; break;",
          "153:   case SOF_IPC_STREAM_POSITION:",
          "154:    str2 = \"POSITION\"; break;",
          "155:   case SOF_IPC_STREAM_VORBIS_PARAMS:",
          "156:    str2 = \"VORBIS_PARAMS\"; break;",
          "157:   case SOF_IPC_STREAM_VORBIS_FREE:",
          "158:    str2 = \"VORBIS_FREE\"; break;",
          "159:   default:",
          "160:    str2 = \"unknown type\"; break;",
          "161:   }",
          "162:   break;",
          "163:  case SOF_IPC_FW_READY:",
          "164:   str = \"FW_READY\"; break;",
          "165:  case SOF_IPC_GLB_DAI_MSG:",
          "166:   str = \"GLB_DAI_MSG\";",
          "167:   switch (type) {",
          "168:   case SOF_IPC_DAI_CONFIG:",
          "169:    str2 = \"CONFIG\"; break;",
          "170:   case SOF_IPC_DAI_LOOPBACK:",
          "171:    str2 = \"LOOPBACK\"; break;",
          "172:   default:",
          "173:    str2 = \"unknown type\"; break;",
          "174:   }",
          "175:   break;",
          "176:  case SOF_IPC_GLB_TRACE_MSG:",
          "177:   str = \"GLB_TRACE_MSG\"; break;",
          "178:  default:",
          "179:   str = \"unknown GLB command\"; break;",
          "180:  }",
          "182:  if (str2)",
          "183:   dev_dbg(dev, \"%s: 0x%x: %s: %s\\n\", text, cmd, str, str2);",
          "184:  else",
          "185:   dev_dbg(dev, \"%s: 0x%x: %s\\n\", text, cmd, str);",
          "186: }",
          "187: #else",
          "188: static inline void ipc_log_header(struct device *dev, u8 *text, u32 cmd)",
          "189: {",
          "190:  dev_dbg(dev, \"%s: 0x%x\\n\", text, cmd);",
          "191: }",
          "192: #endif",
          "195: static int tx_wait_done(struct snd_sof_ipc *ipc, struct snd_sof_ipc_msg *msg,",
          "196:    void *reply_data)",
          "197: {",
          "198:  struct snd_sof_dev *sdev = ipc->sdev;",
          "199:  struct sof_ipc_cmd_hdr *hdr = msg->msg_data;",
          "200:  int ret;",
          "203:  ret = wait_event_timeout(msg->waitq, msg->ipc_complete,",
          "204:      msecs_to_jiffies(IPC_TIMEOUT_MS));",
          "206:  if (ret == 0) {",
          "207:   dev_err(sdev->dev, \"error: ipc timed out for 0x%x size %d\\n\",",
          "208:    hdr->cmd, hdr->size);",
          "209:   snd_sof_dsp_dbg_dump(ipc->sdev, SOF_DBG_REGS | SOF_DBG_MBOX);",
          "210:   snd_sof_trace_notify_for_error(ipc->sdev);",
          "211:   ret = -ETIMEDOUT;",
          "212:  } else {",
          "214:   ret = msg->reply_error;",
          "215:   if (msg->reply_size)",
          "216:    memcpy(reply_data, msg->reply_data, msg->reply_size);",
          "217:   if (ret < 0)",
          "218:    dev_err(sdev->dev, \"error: ipc error for 0x%x size %zu\\n\",",
          "219:     hdr->cmd, msg->reply_size);",
          "220:   else",
          "221:    ipc_log_header(sdev->dev, \"ipc tx succeeded\", hdr->cmd);",
          "222:  }",
          "224:  return ret;",
          "225: }",
          "228: static int sof_ipc_tx_message_unlocked(struct snd_sof_ipc *ipc, u32 header,",
          "229:            void *msg_data, size_t msg_bytes,",
          "230:            void *reply_data, size_t reply_bytes)",
          "231: {",
          "232:  struct snd_sof_dev *sdev = ipc->sdev;",
          "233:  struct snd_sof_ipc_msg *msg;",
          "234:  int ret;",
          "236:  if (ipc->disable_ipc_tx)",
          "237:   return -ENODEV;",
          "243:  spin_lock_irq(&sdev->ipc_lock);",
          "246:  msg = &ipc->msg;",
          "248:  msg->header = header;",
          "249:  msg->msg_size = msg_bytes;",
          "250:  msg->reply_size = reply_bytes;",
          "251:  msg->reply_error = 0;",
          "254:  if (msg_bytes)",
          "255:   memcpy(msg->msg_data, msg_data, msg_bytes);",
          "257:  sdev->msg = msg;",
          "259:  ret = snd_sof_dsp_send_msg(sdev, msg);",
          "261:  if (!ret)",
          "262:   msg->ipc_complete = false;",
          "264:  spin_unlock_irq(&sdev->ipc_lock);",
          "266:  if (ret < 0) {",
          "268:   dev_err_ratelimited(sdev->dev,",
          "269:         \"error: ipc tx failed with error %d\\n\",",
          "270:         ret);",
          "271:   return ret;",
          "272:  }",
          "274:  ipc_log_header(sdev->dev, \"ipc tx\", msg->header);",
          "277:  if (!ret)",
          "278:   ret = tx_wait_done(ipc, msg, reply_data);",
          "280:  return ret;",
          "281: }",
          "284: int sof_ipc_tx_message(struct snd_sof_ipc *ipc, u32 header,",
          "285:          void *msg_data, size_t msg_bytes, void *reply_data,",
          "286:          size_t reply_bytes)",
          "287: {",
          "288:  int ret;",
          "290:  if (msg_bytes > SOF_IPC_MSG_MAX_SIZE ||",
          "291:      reply_bytes > SOF_IPC_MSG_MAX_SIZE)",
          "292:   return -ENOBUFS;",
          "295:  mutex_lock(&ipc->tx_mutex);",
          "297:  ret = sof_ipc_tx_message_unlocked(ipc, header, msg_data, msg_bytes,",
          "298:        reply_data, reply_bytes);",
          "300:  mutex_unlock(&ipc->tx_mutex);",
          "302:  return ret;",
          "303: }",
          "304: EXPORT_SYMBOL(sof_ipc_tx_message);",
          "307: int snd_sof_ipc_reply(struct snd_sof_dev *sdev, u32 msg_id)",
          "308: {",
          "309:  struct snd_sof_ipc_msg *msg = &sdev->ipc->msg;",
          "310:  unsigned long flags;",
          "319:  spin_lock_irqsave(&sdev->ipc_lock, flags);",
          "321:  if (msg->ipc_complete) {",
          "322:   spin_unlock_irqrestore(&sdev->ipc_lock, flags);",
          "323:   dev_err(sdev->dev, \"error: no reply expected, received 0x%x\",",
          "324:    msg_id);",
          "325:   return -EINVAL;",
          "326:  }",
          "329:  msg->ipc_complete = true;",
          "330:  wake_up(&msg->waitq);",
          "332:  spin_unlock_irqrestore(&sdev->ipc_lock, flags);",
          "334:  return 0;",
          "335: }",
          "336: EXPORT_SYMBOL(snd_sof_ipc_reply);",
          "339: void snd_sof_ipc_msgs_rx(struct snd_sof_dev *sdev)",
          "340: {",
          "341:  struct sof_ipc_cmd_hdr hdr;",
          "342:  u32 cmd, type;",
          "343:  int err = 0;",
          "346:  snd_sof_ipc_msg_data(sdev, NULL, &hdr, sizeof(hdr));",
          "347:  ipc_log_header(sdev->dev, \"ipc rx\", hdr.cmd);",
          "349:  cmd = hdr.cmd & SOF_GLB_TYPE_MASK;",
          "350:  type = hdr.cmd & SOF_CMD_TYPE_MASK;",
          "353:  switch (cmd) {",
          "354:  case SOF_IPC_GLB_REPLY:",
          "355:   dev_err(sdev->dev, \"error: ipc reply unknown\\n\");",
          "356:   break;",
          "357:  case SOF_IPC_FW_READY:",
          "359:   if (!sdev->boot_complete) {",
          "360:    err = sof_ops(sdev)->fw_ready(sdev, cmd);",
          "361:    if (err < 0) {",
          "366:     dev_err(sdev->dev, \"error: ABI mismatch %d\\n\",",
          "367:      err);",
          "368:    } else {",
          "370:     sdev->boot_complete = true;",
          "371:    }",
          "374:    wake_up(&sdev->boot_wait);",
          "375:   }",
          "376:   break;",
          "377:  case SOF_IPC_GLB_COMPOUND:",
          "378:  case SOF_IPC_GLB_TPLG_MSG:",
          "379:  case SOF_IPC_GLB_PM_MSG:",
          "380:  case SOF_IPC_GLB_COMP_MSG:",
          "381:   break;",
          "382:  case SOF_IPC_GLB_STREAM_MSG:",
          "384:   ipc_stream_message(sdev, hdr.cmd);",
          "385:   break;",
          "386:  case SOF_IPC_GLB_TRACE_MSG:",
          "387:   ipc_trace_message(sdev, type);",
          "388:   break;",
          "389:  default:",
          "390:   dev_err(sdev->dev, \"error: unknown DSP message 0x%x\\n\", cmd);",
          "391:   break;",
          "392:  }",
          "394:  ipc_log_header(sdev->dev, \"ipc rx done\", hdr.cmd);",
          "395: }",
          "396: EXPORT_SYMBOL(snd_sof_ipc_msgs_rx);",
          "402: static void ipc_trace_message(struct snd_sof_dev *sdev, u32 msg_id)",
          "403: {",
          "404:  struct sof_ipc_dma_trace_posn posn;",
          "406:  switch (msg_id) {",
          "407:  case SOF_IPC_TRACE_DMA_POSITION:",
          "409:   snd_sof_ipc_msg_data(sdev, NULL, &posn, sizeof(posn));",
          "410:   snd_sof_trace_update_pos(sdev, &posn);",
          "411:   break;",
          "412:  default:",
          "413:   dev_err(sdev->dev, \"error: unhandled trace message %x\\n\",",
          "414:    msg_id);",
          "415:   break;",
          "416:  }",
          "417: }",
          "423: static void ipc_period_elapsed(struct snd_sof_dev *sdev, u32 msg_id)",
          "424: {",
          "425:  struct snd_sof_pcm_stream *stream;",
          "426:  struct sof_ipc_stream_posn posn;",
          "427:  struct snd_sof_pcm *spcm;",
          "428:  int direction;",
          "430:  spcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);",
          "431:  if (!spcm) {",
          "432:   dev_err(sdev->dev,",
          "433:    \"error: period elapsed for unknown stream, msg_id %d\\n\",",
          "434:    msg_id);",
          "435:   return;",
          "436:  }",
          "438:  stream = &spcm->stream[direction];",
          "439:  snd_sof_ipc_msg_data(sdev, stream->substream, &posn, sizeof(posn));",
          "441:  dev_dbg(sdev->dev, \"posn : host 0x%llx dai 0x%llx wall 0x%llx\\n\",",
          "442:   posn.host_posn, posn.dai_posn, posn.wallclock);",
          "444:  memcpy(&stream->posn, &posn, sizeof(posn));",
          "447:  if (!stream->substream->runtime->no_period_wakeup)",
          "448:   snd_pcm_period_elapsed(stream->substream);",
          "449: }",
          "452: static void ipc_xrun(struct snd_sof_dev *sdev, u32 msg_id)",
          "453: {",
          "454:  struct snd_sof_pcm_stream *stream;",
          "455:  struct sof_ipc_stream_posn posn;",
          "456:  struct snd_sof_pcm *spcm;",
          "457:  int direction;",
          "459:  spcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);",
          "460:  if (!spcm) {",
          "461:   dev_err(sdev->dev, \"error: XRUN for unknown stream, msg_id %d\\n\",",
          "462:    msg_id);",
          "463:   return;",
          "464:  }",
          "466:  stream = &spcm->stream[direction];",
          "467:  snd_sof_ipc_msg_data(sdev, stream->substream, &posn, sizeof(posn));",
          "469:  dev_dbg(sdev->dev,  \"posn XRUN: host %llx comp %d size %d\\n\",",
          "470:   posn.host_posn, posn.xrun_comp_id, posn.xrun_size);",
          "472: #if defined(CONFIG_SND_SOC_SOF_DEBUG_XRUN_STOP)",
          "474:  memcpy(&stream->posn, &posn, sizeof(posn));",
          "475:  snd_pcm_stop_xrun(stream->substream);",
          "476: #endif",
          "477: }",
          "480: static void ipc_stream_message(struct snd_sof_dev *sdev, u32 msg_cmd)",
          "481: {",
          "483:  u32 msg_type = msg_cmd & SOF_CMD_TYPE_MASK;",
          "484:  u32 msg_id = SOF_IPC_MESSAGE_ID(msg_cmd);",
          "486:  switch (msg_type) {",
          "487:  case SOF_IPC_STREAM_POSITION:",
          "488:   ipc_period_elapsed(sdev, msg_id);",
          "489:   break;",
          "490:  case SOF_IPC_STREAM_TRIG_XRUN:",
          "491:   ipc_xrun(sdev, msg_id);",
          "492:   break;",
          "493:  default:",
          "494:   dev_err(sdev->dev, \"error: unhandled stream message %x\\n\",",
          "495:    msg_id);",
          "496:   break;",
          "497:  }",
          "498: }",
          "501: int snd_sof_ipc_stream_posn(struct snd_sof_dev *sdev,",
          "502:        struct snd_sof_pcm *spcm, int direction,",
          "503:        struct sof_ipc_stream_posn *posn)",
          "504: {",
          "505:  struct sof_ipc_stream stream;",
          "506:  int err;",
          "509:  stream.hdr.size = sizeof(stream);",
          "510:  stream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_POSITION;",
          "511:  stream.comp_id = spcm->stream[direction].comp_id;",
          "514:  err = sof_ipc_tx_message(sdev->ipc,",
          "515:      stream.hdr.cmd, &stream, sizeof(stream), &posn,",
          "516:      sizeof(*posn));",
          "517:  if (err < 0) {",
          "518:   dev_err(sdev->dev, \"error: failed to get stream %d position\\n\",",
          "519:    stream.comp_id);",
          "520:   return err;",
          "521:  }",
          "523:  return 0;",
          "524: }",
          "525: EXPORT_SYMBOL(snd_sof_ipc_stream_posn);",
          "527: static int sof_get_ctrl_copy_params(enum sof_ipc_ctrl_type ctrl_type,",
          "528:         struct sof_ipc_ctrl_data *src,",
          "529:         struct sof_ipc_ctrl_data *dst,",
          "530:         struct sof_ipc_ctrl_data_params *sparams)",
          "531: {",
          "532:  switch (ctrl_type) {",
          "533:  case SOF_CTRL_TYPE_VALUE_CHAN_GET:",
          "534:  case SOF_CTRL_TYPE_VALUE_CHAN_SET:",
          "535:   sparams->src = (u8 *)src->chanv;",
          "536:   sparams->dst = (u8 *)dst->chanv;",
          "537:   break;",
          "538:  case SOF_CTRL_TYPE_VALUE_COMP_GET:",
          "539:  case SOF_CTRL_TYPE_VALUE_COMP_SET:",
          "540:   sparams->src = (u8 *)src->compv;",
          "541:   sparams->dst = (u8 *)dst->compv;",
          "542:   break;",
          "543:  case SOF_CTRL_TYPE_DATA_GET:",
          "544:  case SOF_CTRL_TYPE_DATA_SET:",
          "545:   sparams->src = (u8 *)src->data->data;",
          "546:   sparams->dst = (u8 *)dst->data->data;",
          "547:   break;",
          "548:  default:",
          "549:   return -EINVAL;",
          "550:  }",
          "553:  sparams->pl_size = SOF_IPC_MSG_MAX_SIZE - sparams->hdr_bytes;",
          "554:  sparams->num_msg = DIV_ROUND_UP(sparams->msg_bytes, sparams->pl_size);",
          "556:  return 0;",
          "557: }",
          "559: static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,",
          "560:            struct sof_ipc_ctrl_data *cdata,",
          "561:            struct sof_ipc_ctrl_data_params *sparams,",
          "562:            bool send)",
          "563: {",
          "564:  struct sof_ipc_ctrl_data *partdata;",
          "565:  size_t send_bytes;",
          "566:  size_t offset = 0;",
          "567:  size_t msg_bytes;",
          "568:  size_t pl_size;",
          "569:  int err = 0;",
          "570:  int i;",
          "573:  partdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);",
          "574:  if (!partdata)",
          "575:   return -ENOMEM;",
          "577:  if (send)",
          "578:   sof_get_ctrl_copy_params(cdata->type, cdata, partdata, sparams);",
          "579:  else",
          "580:   sof_get_ctrl_copy_params(cdata->type, partdata, cdata, sparams);",
          "582:  msg_bytes = sparams->msg_bytes;",
          "583:  pl_size = sparams->pl_size;",
          "586:  memcpy(partdata, cdata, sparams->hdr_bytes);",
          "589:  mutex_lock(&sdev->ipc->tx_mutex);",
          "592:  for (i = 0; i < sparams->num_msg; i++) {",
          "593:   send_bytes = min(msg_bytes, pl_size);",
          "594:   partdata->num_elems = send_bytes;",
          "595:   partdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;",
          "596:   partdata->msg_index = i;",
          "597:   msg_bytes -= send_bytes;",
          "598:   partdata->elems_remaining = msg_bytes;",
          "600:   if (send)",
          "601:    memcpy(sparams->dst, sparams->src + offset, send_bytes);",
          "603:   err = sof_ipc_tx_message_unlocked(sdev->ipc,",
          "604:         partdata->rhdr.hdr.cmd,",
          "605:         partdata,",
          "606:         partdata->rhdr.hdr.size,",
          "607:         partdata,",
          "608:         partdata->rhdr.hdr.size);",
          "609:   if (err < 0)",
          "610:    break;",
          "612:   if (!send)",
          "613:    memcpy(sparams->dst + offset, sparams->src, send_bytes);",
          "615:   offset += pl_size;",
          "616:  }",
          "618:  mutex_unlock(&sdev->ipc->tx_mutex);",
          "620:  kfree(partdata);",
          "621:  return err;",
          "622: }",
          "627: int snd_sof_ipc_set_get_comp_data(struct snd_sof_ipc *ipc,",
          "628:       struct snd_sof_control *scontrol,",
          "629:       u32 ipc_cmd,",
          "630:       enum sof_ipc_ctrl_type ctrl_type,",
          "631:       enum sof_ipc_ctrl_cmd ctrl_cmd,",
          "632:       bool send)",
          "633: {",
          "634:  struct sof_ipc_ctrl_data *cdata = scontrol->control_data;",
          "635:  struct snd_sof_dev *sdev = ipc->sdev;",
          "636:  struct sof_ipc_fw_ready *ready = &sdev->fw_ready;",
          "637:  struct sof_ipc_fw_version *v = &ready->version;",
          "638:  struct sof_ipc_ctrl_data_params sparams;",
          "639:  size_t send_bytes;",
          "640:  int err;",
          "643:  if (scontrol->readback_offset != 0) {",
          "645:   send_bytes = sizeof(struct sof_ipc_ctrl_value_chan) *",
          "646:   cdata->num_elems;",
          "647:   if (send)",
          "648:    snd_sof_dsp_block_write(sdev, sdev->mmio_bar,",
          "649:       scontrol->readback_offset,",
          "650:       cdata->chanv, send_bytes);",
          "652:   else",
          "653:    snd_sof_dsp_block_read(sdev, sdev->mmio_bar,",
          "654:             scontrol->readback_offset,",
          "655:             cdata->chanv, send_bytes);",
          "656:   return 0;",
          "657:  }",
          "659:  cdata->rhdr.hdr.cmd = SOF_IPC_GLB_COMP_MSG | ipc_cmd;",
          "660:  cdata->cmd = ctrl_cmd;",
          "661:  cdata->type = ctrl_type;",
          "662:  cdata->comp_id = scontrol->comp_id;",
          "663:  cdata->msg_index = 0;",
          "666:  switch (cdata->type) {",
          "667:  case SOF_CTRL_TYPE_VALUE_CHAN_GET:",
          "668:  case SOF_CTRL_TYPE_VALUE_CHAN_SET:",
          "669:   sparams.msg_bytes = scontrol->num_channels *",
          "670:    sizeof(struct sof_ipc_ctrl_value_chan);",
          "671:   sparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data);",
          "672:   sparams.elems = scontrol->num_channels;",
          "673:   break;",
          "674:  case SOF_CTRL_TYPE_VALUE_COMP_GET:",
          "675:  case SOF_CTRL_TYPE_VALUE_COMP_SET:",
          "676:   sparams.msg_bytes = scontrol->num_channels *",
          "677:    sizeof(struct sof_ipc_ctrl_value_comp);",
          "678:   sparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data);",
          "679:   sparams.elems = scontrol->num_channels;",
          "680:   break;",
          "681:  case SOF_CTRL_TYPE_DATA_GET:",
          "682:  case SOF_CTRL_TYPE_DATA_SET:",
          "683:   sparams.msg_bytes = cdata->data->size;",
          "684:   sparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data) +",
          "685:    sizeof(struct sof_abi_hdr);",
          "686:   sparams.elems = cdata->data->size;",
          "687:   break;",
          "688:  default:",
          "689:   return -EINVAL;",
          "690:  }",
          "692:  cdata->rhdr.hdr.size = sparams.msg_bytes + sparams.hdr_bytes;",
          "693:  cdata->num_elems = sparams.elems;",
          "694:  cdata->elems_remaining = 0;",
          "697:  if (cdata->rhdr.hdr.size <= SOF_IPC_MSG_MAX_SIZE) {",
          "698:   err = sof_ipc_tx_message(sdev->ipc, cdata->rhdr.hdr.cmd, cdata,",
          "699:       cdata->rhdr.hdr.size, cdata,",
          "700:       cdata->rhdr.hdr.size);",
          "702:   if (err < 0)",
          "703:    dev_err(sdev->dev, \"error: set/get ctrl ipc comp %d\\n\",",
          "704:     cdata->comp_id);",
          "706:   return err;",
          "707:  }",
          "710:  dev_dbg(sdev->dev, \"large ipc size %u, control size %u\\n\",",
          "711:   cdata->rhdr.hdr.size, scontrol->size);",
          "714:  if (v->abi_version < SOF_ABI_VER(3, 3, 0)) {",
          "715:   dev_err(sdev->dev, \"error: incompatible FW ABI version\\n\");",
          "716:   return -EINVAL;",
          "717:  }",
          "719:  err = sof_set_get_large_ctrl_data(sdev, cdata, &sparams, send);",
          "721:  if (err < 0)",
          "722:   dev_err(sdev->dev, \"error: set/get large ctrl ipc comp %d\\n\",",
          "723:    cdata->comp_id);",
          "725:  return err;",
          "726: }",
          "727: EXPORT_SYMBOL(snd_sof_ipc_set_get_comp_data);",
          "733: int snd_sof_dsp_mailbox_init(struct snd_sof_dev *sdev, u32 dspbox,",
          "734:         size_t dspbox_size, u32 hostbox,",
          "735:         size_t hostbox_size)",
          "736: {",
          "737:  sdev->dsp_box.offset = dspbox;",
          "738:  sdev->dsp_box.size = dspbox_size;",
          "739:  sdev->host_box.offset = hostbox;",
          "740:  sdev->host_box.size = hostbox_size;",
          "741:  return 0;",
          "742: }",
          "743: EXPORT_SYMBOL(snd_sof_dsp_mailbox_init);",
          "745: int snd_sof_ipc_valid(struct snd_sof_dev *sdev)",
          "746: {",
          "747:  struct sof_ipc_fw_ready *ready = &sdev->fw_ready;",
          "748:  struct sof_ipc_fw_version *v = &ready->version;",
          "750:  dev_info(sdev->dev,",
          "751:    \"Firmware info: version %d:%d:%d-%s\\n\",  v->major, v->minor,",
          "752:    v->micro, v->tag);",
          "753:  dev_info(sdev->dev,",
          "754:    \"Firmware: ABI %d:%d:%d Kernel ABI %d:%d:%d\\n\",",
          "755:    SOF_ABI_VERSION_MAJOR(v->abi_version),",
          "756:    SOF_ABI_VERSION_MINOR(v->abi_version),",
          "757:    SOF_ABI_VERSION_PATCH(v->abi_version),",
          "758:    SOF_ABI_MAJOR, SOF_ABI_MINOR, SOF_ABI_PATCH);",
          "760:  if (SOF_ABI_VERSION_INCOMPATIBLE(SOF_ABI_VERSION, v->abi_version)) {",
          "761:   dev_err(sdev->dev, \"error: incompatible FW ABI version\\n\");",
          "762:   return -EINVAL;",
          "763:  }",
          "765:  if (ready->debug.bits.build) {",
          "766:   dev_info(sdev->dev,",
          "767:     \"Firmware debug build %d on %s-%s - options:\\n\"",
          "768:     \" GDB: %s\\n\"",
          "769:     \" lock debug: %s\\n\"",
          "770:     \" lock vdebug: %s\\n\",",
          "771:     v->build, v->date, v->time,",
          "772:     ready->debug.bits.gdb ? \"enabled\" : \"disabled\",",
          "773:     ready->debug.bits.locks ? \"enabled\" : \"disabled\",",
          "774:     ready->debug.bits.locks_verbose ? \"enabled\" : \"disabled\");",
          "775:  }",
          "778:  memcpy(&sdev->fw_version, v, sizeof(*v));",
          "780:  return 0;",
          "781: }",
          "782: EXPORT_SYMBOL(snd_sof_ipc_valid);",
          "784: struct snd_sof_ipc *snd_sof_ipc_init(struct snd_sof_dev *sdev)",
          "785: {",
          "786:  struct snd_sof_ipc *ipc;",
          "787:  struct snd_sof_ipc_msg *msg;",
          "790:  if (!sof_ops(sdev)->fw_ready) {",
          "791:   dev_err(sdev->dev, \"error: ipc mandatory ops not defined\\n\");",
          "792:   return NULL;",
          "793:  }",
          "795:  ipc = devm_kzalloc(sdev->dev, sizeof(*ipc), GFP_KERNEL);",
          "796:  if (!ipc)",
          "797:   return NULL;",
          "799:  mutex_init(&ipc->tx_mutex);",
          "800:  ipc->sdev = sdev;",
          "801:  msg = &ipc->msg;",
          "804:  msg->ipc_complete = true;",
          "807:  msg->msg_data = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE,",
          "808:          GFP_KERNEL);",
          "809:  if (!msg->msg_data)",
          "810:   return NULL;",
          "812:  msg->reply_data = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE,",
          "813:            GFP_KERNEL);",
          "814:  if (!msg->reply_data)",
          "815:   return NULL;",
          "817:  init_waitqueue_head(&msg->waitq);",
          "819:  return ipc;",
          "820: }",
          "821: EXPORT_SYMBOL(snd_sof_ipc_init);",
          "823: void snd_sof_ipc_free(struct snd_sof_dev *sdev)",
          "824: {",
          "825:  struct snd_sof_ipc *ipc = sdev->ipc;",
          "828:  mutex_lock(&ipc->tx_mutex);",
          "829:  ipc->disable_ipc_tx = true;",
          "830:  mutex_unlock(&ipc->tx_mutex);",
          "831: }",
          "832: EXPORT_SYMBOL(snd_sof_ipc_free);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "54d198d5019dd98b9bcb9099a389608d7e2cccad",
      "candidate_info": {
        "commit_hash": "54d198d5019dd98b9bcb9099a389608d7e2cccad",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/54d198d5019dd98b9bcb9099a389608d7e2cccad",
        "files": [
          "sound/soc/sof/ipc.c"
        ],
        "message": "ASoC: SOF: Propagate sof_get_ctrl_copy_params() error properly\n\nThis fixes a compile warning below by properly handling the error code\nfrom sof_get_ctrl_copy_params():\n  include/linux/kernel.h:843:43: warning: 'sparams.pl_size' may be used uninitialized in this function [-Wmaybe-uninitialized]\n  sound/soc/sof/ipc.c:639:34: note: 'sparams.pl_size' was declared here\n\nThe function returns an error before setting sparams.pl_size, so it'd\nassign an uninitialized value at a later point.\n\nFixes: 53e0c72d98ba (\"ASoC: SOF: Add support for IPC IO between DSP and Host\")\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Mark Brown <broonie@kernel.org>",
        "before_after_code_files": [
          "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c"
          ],
          "candidate": [
            "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c"
          ]
        }
      },
      "candidate_diff": {
        "sound/soc/sof/ipc.c||sound/soc/sof/ipc.c": [
          "File: sound/soc/sof/ipc.c -> sound/soc/sof/ipc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "567:  size_t offset = 0;",
          "568:  size_t msg_bytes;",
          "569:  size_t pl_size;",
          "571:  int i;",
          "",
          "[Removed Lines]",
          "570:  int err = 0;",
          "",
          "[Added Lines]",
          "570:  int err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "576:   return -ENOMEM;",
          "578:  if (send)",
          "580:  else",
          "583:  msg_bytes = sparams->msg_bytes;",
          "584:  pl_size = sparams->pl_size;",
          "",
          "[Removed Lines]",
          "579:   sof_get_ctrl_copy_params(cdata->type, cdata, partdata, sparams);",
          "581:   sof_get_ctrl_copy_params(cdata->type, partdata, cdata, sparams);",
          "",
          "[Added Lines]",
          "579:   err = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,",
          "580:             sparams);",
          "582:   err = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,",
          "583:             sparams);",
          "584:  if (err < 0)",
          "585:   return err;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
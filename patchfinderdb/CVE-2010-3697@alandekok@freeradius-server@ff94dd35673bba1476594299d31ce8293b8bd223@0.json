{
  "cve_id": "CVE-2010-3697",
  "cve_desc": "The wait_for_child_to_die function in main/event.c in FreeRADIUS 2.1.x before 2.1.10, in certain circumstances involving long-term database outages, does not properly handle long queue times for requests, which allows remote attackers to cause a denial of service (daemon crash) by sending many requests.",
  "repo": "alandekok/freeradius-server",
  "patch_hash": "ff94dd35673bba1476594299d31ce8293b8bd223",
  "patch_info": {
    "commit_hash": "ff94dd35673bba1476594299d31ce8293b8bd223",
    "repo": "alandekok/freeradius-server",
    "commit_url": "https://github.com/alandekok/freeradius-server/commit/ff94dd35673bba1476594299d31ce8293b8bd223",
    "files": [
      "src/main/event.c"
    ],
    "message": "Do not delete \"old\" requests until they are free.\n\nIf the request is in the queue for 30+ seconds, do NOT delete it.\nInstead, mark it as \"STOP PROCESSING\", and do \"wait_for_child_to_die\",\nwhich waits for a child thread to pick it up, and acknowledge that it's\ndone.  Once it's marked done, we can finally clean it up.\n\nThis may be the underlying issue behind bug #35",
    "before_after_code_files": [
      "src/main/event.c||src/main/event.c"
    ]
  },
  "patch_diff": {
    "src/main/event.c||src/main/event.c": [
      "File: src/main/event.c -> src/main/event.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "479:  REQUEST *request = ctx;",
      "481:  rad_assert(request->magic == REQUEST_MAGIC);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "482:  remove_from_request_hash(request);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "490:       (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {",
      "496:    request->delay += (request->delay >> 1);",
      "497:    radlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",",
      "498:           request->number, request->component, request->module);",
      "499:   } else {",
      "501:     request->number);",
      "502:   }",
      "503:   tv_add(&request->when, request->delay);",
      "",
      "[Removed Lines]",
      "495:   if (request->delay < (USEC * 60 * 5)) {",
      "500:    RDEBUG2(\"Child is still stuck for request %u\",",
      "",
      "[Added Lines]",
      "496:   if (request->delay < (USEC * request->root->max_request_time)) {",
      "501:    request->delay = USEC * request->root->max_request_time;",
      "502:    RDEBUG2(\"WARNING: Child is still stuck for request %u\",",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "507:  }",
      "509:  RDEBUG2(\"Child is finally responsive for request %u\", request->number);",
      "512: #ifdef WITH_PROXY",
      "513:  if (request->proxy) {",
      "",
      "[Removed Lines]",
      "510:  remove_from_request_hash(request);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1140:  switch (request->child_state) {",
      "1141:  case REQUEST_QUEUED:",
      "1142:  case REQUEST_RUNNING:",
      "1143:   when = request->received;",
      "1144:   when.tv_sec += request->root->max_request_time;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1150: #ifdef HAVE_PTHREAD_H",
      "1151:   if (!have_children)",
      "1152: #endif",
      "1153:   {",
      "1154:    rad_assert(\"We do not have threads, but the request is marked as queued or running in a child thread\" == NULL);",
      "1155:    break;",
      "1156:   }",
      "1158: #ifdef HAVE_PTHREAD_H",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1162:    if (request->delay < (USEC / 10)) {",
      "1163:     request->delay = USEC / 10;",
      "1164:    }",
      "1165:    request->delay += request->delay >> 1;",
      "1174:     request->delay = request->root->max_request_time * USEC;",
      "1175:    }",
      "1178:    request->when = now;",
      "1179:    tv_add(&request->when, request->delay);",
      "",
      "[Removed Lines]",
      "1159:   if (timercmp(&now, &when, <) ||",
      "1160:       ((request->listener->type == RAD_LISTEN_DETAIL) &&",
      "1161:        (request->child_state == REQUEST_QUEUED))) {",
      "1167: #ifdef WITH_DETAIL",
      "1172:    if ((request->listener->type == RAD_LISTEN_DETAIL) &&",
      "1173:        (request->delay > (request->root->max_request_time * USEC))) {",
      "1176: #endif",
      "",
      "[Added Lines]",
      "1179:   if (timercmp(&now, &when, <)) {",
      "1188:    if (request->delay > (request->root->max_request_time * USEC)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1181:    break;",
      "1182:   }",
      "",
      "[Removed Lines]",
      "1184: #if defined(HAVE_PTHREAD_H)",
      "",
      "[Added Lines]",
      "1198:   request->master_state = REQUEST_STOP_PROCESSING;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1190:   if (have_children &&",
      "1191:       (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {",
      "1194:    radlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",",
      "1195:           request->number,",
      "1196:           request->module ? request->module : \"<server core>\",",
      "1197:           request->component ? request->component : \"<server core>\");",
      "1203:   }",
      "1204: #endif",
      "",
      "[Removed Lines]",
      "1192:    request->master_state = REQUEST_STOP_PROCESSING;",
      "1199:    request->delay = USEC / 4;",
      "1200:    tv_add(&request->when, request->delay);",
      "1201:    callback = wait_for_child_to_die;",
      "1202:    break;",
      "1214:   request->child_state = REQUEST_DONE;",
      "",
      "[Added Lines]",
      "1213:   request->delay = USEC;",
      "1214:   tv_add(&request->when, request->delay);",
      "1215:   callback = wait_for_child_to_die;",
      "1216:   break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a72256c046771e7cb4bdf74fa709065fb6fe54fb",
      "candidate_info": {
        "commit_hash": "a72256c046771e7cb4bdf74fa709065fb6fe54fb",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/a72256c046771e7cb4bdf74fa709065fb6fe54fb",
        "files": [
          "src/lib/hash.c"
        ],
        "message": "Fix node comparison on delete\n\nThis could be the cause of bug #35.",
        "before_after_code_files": [
          "src/lib/hash.c||src/lib/hash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/lib/hash.c||src/lib/hash.c": [
          "File: src/lib/hash.c -> src/lib/hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "243:  last = head;",
          "245:  for (cur = *head; cur != &ht->null; cur = cur->next) {",
          "254:   last = &(cur->next);",
          "255:  }",
          "",
          "[Removed Lines]",
          "246:   if (cur == node) {",
          "247:    if (ht->cmp) {",
          "248:     int cmp = ht->cmp(node->data, cur->data);",
          "249:     if (cmp > 0) break;",
          "250:     if (cmp < 0) continue;",
          "251:    }",
          "252:    break;",
          "253:   }",
          "",
          "[Added Lines]",
          "246:   if (cur == node) break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e8d9a588dd8b228f612fd305b0e0899174179ac",
      "candidate_info": {
        "commit_hash": "6e8d9a588dd8b228f612fd305b0e0899174179ac",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/6e8d9a588dd8b228f612fd305b0e0899174179ac",
        "files": [
          "src/lib/packet.c"
        ],
        "message": "Work around for bug #35.\n\nThe packet is apparently getting freed when the request structure is still\nin the list.  Since it's hard to tell when / why this is happening,\nthe short-term fix is to work around it.\n\nIt's better to leak memory slowly than to crash quickly.",
        "before_after_code_files": [
          "src/lib/packet.c||src/lib/packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/lib/packet.c||src/lib/packet.c": [
          "File: src/lib/packet.c -> src/lib/packet.c"
        ]
      }
    },
    {
      "candidate_hash": "1fc58a22dd71e5900e1d0e5a6bfad5410546efe6",
      "candidate_info": {
        "commit_hash": "1fc58a22dd71e5900e1d0e5a6bfad5410546efe6",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/1fc58a22dd71e5900e1d0e5a6bfad5410546efe6",
        "files": [
          "src/lib/packet.c"
        ],
        "message": "Move proxy ID handler to RB trees instead of hashes\n\nThis is apparently the root cause behind bug #35.  It's not\nclear why the hash table has that problem, but making this change\nfixes it.",
        "before_after_code_files": [
          "src/lib/packet.c||src/lib/packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/lib/packet.c||src/lib/packet.c": [
          "File: src/lib/packet.c -> src/lib/packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "312: struct fr_packet_list_t {",
          "317:  int  alloc_id;",
          "318:  int  num_outgoing;",
          "",
          "[Removed Lines]",
          "313:  fr_hash_table_t *ht;",
          "315:  fr_hash_table_t *dst2id_ht;",
          "",
          "[Added Lines]",
          "313:  rbtree_t *tree;",
          "315:  fr_hash_table_t *dst2id_ht;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "432:  return 1;",
          "433: }",
          "440: static int packet_entry_cmp(const void *one, const void *two)",
          "441: {",
          "442:  const RADIUS_PACKET * const *a = one;",
          "",
          "[Removed Lines]",
          "435: static uint32_t packet_entry_hash(const void *data)",
          "436: {",
          "437:  return fr_request_packet_hash(*(const RADIUS_PACKET * const *) data);",
          "438: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "515: {",
          "516:  if (!pl) return;",
          "519:  fr_hash_table_free(pl->dst2id_ht);",
          "520:  free(pl);",
          "521: }",
          "",
          "[Removed Lines]",
          "518:  fr_hash_table_free(pl->ht);",
          "",
          "[Added Lines]",
          "513:  rbtree_free(pl->tree);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "533:  if (!pl) return NULL;",
          "534:  memset(pl, 0, sizeof(*pl));",
          "540:   fr_packet_list_free(pl);",
          "541:   return NULL;",
          "542:  }",
          "",
          "[Removed Lines]",
          "536:  pl->ht = fr_hash_table_create(packet_entry_hash,",
          "537:      packet_entry_cmp,",
          "538:      NULL);",
          "539:  if (!pl->ht) {",
          "",
          "[Added Lines]",
          "531:  pl->tree = rbtree_create(packet_entry_cmp, NULL, 0);",
          "532:  if (!pl->tree) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "570: {",
          "571:  if (!pl || !request_p || !*request_p) return 0;",
          "576: }",
          "578: RADIUS_PACKET **fr_packet_list_find(fr_packet_list_t *pl,",
          "",
          "[Removed Lines]",
          "573:  (*request_p)->hash = fr_request_packet_hash(*request_p);",
          "575:  return fr_hash_table_insert(pl->ht, request_p);",
          "",
          "[Added Lines]",
          "566:  return rbtree_insert(pl->tree, request_p);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "580: {",
          "581:  if (!pl || !request) return 0;",
          "584: }",
          "",
          "[Removed Lines]",
          "583:  return fr_hash_table_finddata(pl->ht, &request);",
          "",
          "[Added Lines]",
          "574:  return rbtree_finddata(pl->tree, &request);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "618:  my_request.dst_ipaddr = reply->src_ipaddr;",
          "619:  my_request.dst_port = reply->src_port;",
          "622:  request = &my_request;",
          "625: }",
          "628: RADIUS_PACKET **fr_packet_list_yank(fr_packet_list_t *pl,",
          "629:           RADIUS_PACKET *request)",
          "630: {",
          "631:  if (!pl || !request) return NULL;",
          "634: }",
          "636: int fr_packet_list_num_elements(fr_packet_list_t *pl)",
          "637: {",
          "638:  if (!pl) return 0;",
          "641: }",
          "",
          "[Removed Lines]",
          "620:  my_request.hash = 0;",
          "624:  return fr_hash_table_finddata(pl->ht, &request);",
          "633:  return fr_hash_table_yank(pl->ht, &request);",
          "640:  return fr_hash_table_num_elements(pl->ht);",
          "",
          "[Added Lines]",
          "614:  return rbtree_finddata(pl->tree, &request);",
          "621:  RADIUS_PACKET **packet_p;",
          "625:  packet_p = rbtree_finddata(pl->tree, &request);",
          "626:  if (!packet_p) return NULL;",
          "628:  rbtree_deletebydata(pl->tree, packet_p);",
          "629:  return packet_p;",
          "637:  return rbtree_num_elements(pl->tree);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "833: {",
          "834:  if (!pl || !callback) return 0;",
          "837: }",
          "839: int fr_packet_list_fd_set(fr_packet_list_t *pl, fd_set *set)",
          "",
          "[Removed Lines]",
          "836:  return fr_hash_table_walk(pl->ht, callback, ctx);",
          "",
          "[Added Lines]",
          "832:  return rbtree_walk(pl->tree, InOrder, callback, ctx);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "901:  if (!pl) return 0;",
          "906:  return num_elements - pl->num_outgoing;",
          "",
          "[Removed Lines]",
          "903:  num_elements = fr_hash_table_num_elements(pl->ht);",
          "",
          "[Added Lines]",
          "899:  num_elements = rbtree_num_elements(pl->tree);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5849d7aa697fac412f0c7901bd3a93bdac3885b2",
      "candidate_info": {
        "commit_hash": "5849d7aa697fac412f0c7901bd3a93bdac3885b2",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/5849d7aa697fac412f0c7901bd3a93bdac3885b2",
        "files": [
          "src/main/event.c"
        ],
        "message": "Fix corner case when not threaded.\n\nIf the request is still running after 30s, it's probably because\nit was proxied, and the home server didn't bother to respond.",
        "before_after_code_files": [
          "src/main/event.c||src/main/event.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/main/event.c||src/main/event.c"
          ],
          "candidate": [
            "src/main/event.c||src/main/event.c"
          ]
        }
      },
      "candidate_diff": {
        "src/main/event.c||src/main/event.c": [
          "File: src/main/event.c -> src/main/event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1170:  case REQUEST_RUNNING:",
          "1177: #ifdef HAVE_PTHREAD_H",
          "1178:   if (!have_children)",
          "1179: #endif",
          "1180:   {",
          "1183:   }",
          "1185: #ifdef HAVE_PTHREAD_H",
          "",
          "[Removed Lines]",
          "1181:    rad_assert(\"We do not have threads, but the request is marked as queued or running in a child thread\" == NULL);",
          "1182:    break;",
          "",
          "[Added Lines]",
          "1182:    goto done;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1251:  case REQUEST_DONE:",
          "1252: #ifdef HAVE_PTHREAD_H",
          "1253:   request->child_pid = NO_SUCH_CHILD_PID;",
          "1254: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1252:  done:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eba544e21a79826d78cb99a3e534d2f38b1d17d8",
      "candidate_info": {
        "commit_hash": "eba544e21a79826d78cb99a3e534d2f38b1d17d8",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/eba544e21a79826d78cb99a3e534d2f38b1d17d8",
        "files": [
          "src/main/event.c"
        ],
        "message": "Clean up state machine.\n\n  This error happens when \"max_request_time\" is set VERY low.\ni.e. lower than \"response_window\".  (12s versus 30s).\n\n  The current logic for enforcing the various timers is pretty bad.  There\nis one timer per request, and it bounces around between the different\nrequirements.  At the time it was written, it seemed simpler than trying\nto manage 3-4 simultaneous timers per request.\n\n  When the request is proxied, the timer being applied is for\n\"response_window\".  BUT by the time that expires, the \"max_request_time\"\nhas expired.  The code *does* notice that it has expired.  BUT it doesn't\nnotice that there's no child thread processing the request.  So it waits\nfor the child thread to exit... forever.\n\n  At some point, a timer overflows, and it dies.\n\n  There are a few changes to make:\n\n1) check for \"no child\" in this situation, and clean up the request rather\n  than waiting forever.\n\n2) cap the timer to 5 minutes (this can still happen, for example, when a\n   bad DB locks a thread for hours at a time).\n\n3) don't overflow when adding timer values.",
        "before_after_code_files": [
          "src/main/event.c||src/main/event.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/main/event.c||src/main/event.c"
          ],
          "candidate": [
            "src/main/event.c||src/main/event.c"
          ]
        }
      },
      "candidate_diff": {
        "src/main/event.c||src/main/event.c": [
          "File: src/main/event.c -> src/main/event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:  tv->tv_usec += usec_delay;",
          "133:  if (tv->tv_usec > USEC) {",
          "136:  }",
          "137: }",
          "",
          "[Removed Lines]",
          "134:   tv->tv_usec -= USEC;",
          "135:   tv->tv_sec++;",
          "",
          "[Added Lines]",
          "134:   tv->tv_sec += tv->tv_usec / USEC;",
          "135:   tv->tv_usec %= USEC;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "472:  if ((request->child_state == REQUEST_QUEUED) |",
          "473:      (request->child_state == REQUEST_RUNNING)) {",
          "479:   INSERT_EVENT(wait_for_child_to_die, request);",
          "480:   return;",
          "",
          "[Removed Lines]",
          "474:   request->delay += (request->delay >> 1);",
          "475:   tv_add(&request->when, request->delay);",
          "477:   RDEBUG2(\"Child is still stuck for request %d\", request->number);",
          "",
          "[Added Lines]",
          "478:   if (request->delay < (USEC * 60 * 5)) {",
          "479:    request->delay += (request->delay >> 1);",
          "480:    radlog(L_INFO, \"WARNING: Child is hung for request %d.\",",
          "481:           request->number);",
          "482:   } else {",
          "483:    RDEBUG2(\"Child is still stuck for request %d\",",
          "484:     request->number);",
          "485:   }",
          "486:   tv_add(&request->when, request->delay);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1049:   post_proxy_fail_handler(request);",
          "1050:  } else {",
          "1054:   request->child_state = REQUEST_RUNNING;",
          "1055:   wait_a_bit(request);",
          "1056:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1060:   rad_assert(request->ev == NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1154:    break;",
          "1155:   }",
          "1157: #if defined(HAVE_PTHREAD_H) || defined(WITH_PROXY)",
          "1181:    request->master_state = REQUEST_STOP_PROCESSING;",
          "1183:    request->delay = USEC / 4;",
          "1184:    tv_add(&request->when, request->delay);",
          "",
          "[Removed Lines]",
          "1163:   if (have_children) {",
          "1174:    if (!pthread_equal(request->child_pid, NO_SUCH_CHILD_PID)) {",
          "1175:     radlog(L_ERR, \"WARNING: Unresponsive child for request %d, in module %s component %s\",",
          "1176:            request->number,",
          "1177:            request->module ? request->module : \"<server core>\",",
          "1178:            request->component ? request->component : \"<server core>\");",
          "1179:    }",
          "",
          "[Added Lines]",
          "1164:  stop_processing:",
          "1171:   if (have_children &&",
          "1172:       (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {",
          "1175:    radlog(L_ERR, \"WARNING: Unresponsive child for request %d, in module %s component %s\",",
          "1176:           request->number,",
          "1177:           request->module ? request->module : \"<server core>\",",
          "1178:           request->component ? request->component : \"<server core>\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-3733",
  "cve_desc": "During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected.",
  "repo": "openssl/openssl",
  "patch_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "patch_info": {
    "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
    "files": [
      "include/openssl/ssl3.h",
      "ssl/record/rec_layer_s3.c",
      "ssl/record/ssl3_record.c",
      "ssl/ssl_locl.h",
      "ssl/t1_enc.c",
      "ssl/t1_lib.c"
    ],
    "message": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
    "before_after_code_files": [
      "include/openssl/ssl3.h||include/openssl/ssl3.h",
      "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c",
      "ssl/record/ssl3_record.c||ssl/record/ssl3_record.c",
      "ssl/ssl_locl.h||ssl/ssl_locl.h",
      "ssl/t1_enc.c||ssl/t1_enc.c",
      "ssl/t1_lib.c||ssl/t1_lib.c"
    ]
  },
  "patch_diff": {
    "include/openssl/ssl3.h||include/openssl/ssl3.h": [
      "File: include/openssl/ssl3.h -> include/openssl/ssl3.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "264: # define TLS1_FLAGS_SKIP_CERT_VERIFY             0x0010",
      "270: # define TLS1_FLAGS_RECEIVED_EXTMS               0x0200",
      "272: # define SSL3_MT_HELLO_REQUEST                   0",
      "273: # define SSL3_MT_CLIENT_HELLO                    1",
      "274: # define SSL3_MT_SERVER_HELLO                    2",
      "",
      "[Removed Lines]",
      "267: # define TLS1_FLAGS_ENCRYPT_THEN_MAC             0x0100",
      "",
      "[Added Lines]",
      "267: # define TLS1_FLAGS_ENCRYPT_THEN_MAC_READ        0x0100",
      "268: # define TLS1_FLAGS_ENCRYPT_THEN_MAC             TLS1_FLAGS_ENCRYPT_THEN_MAC_READ",
      "273: # define TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE       0x0400",
      "",
      "---------------"
    ],
    "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c": [
      "File: ssl/record/rec_layer_s3.c -> ssl/record/rec_layer_s3.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "395:     if (type == SSL3_RT_APPLICATION_DATA &&",
      "396:         u_len >= 4 * (max_send_fragment = s->max_send_fragment) &&",
      "397:         s->compress == NULL && s->msg_callback == NULL &&",
      "399:         EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &",
      "400:         EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {",
      "401:         unsigned char aad[13];",
      "",
      "[Removed Lines]",
      "398:         !SSL_USE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&",
      "",
      "[Added Lines]",
      "398:         !SSL_WRITE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "795:             if (s->method->ssl3_enc->mac(s, &wr[j],",
      "796:                                          &(outbuf[j][wr[j].length + eivlen]),",
      "797:                                          1) < 0)",
      "",
      "[Removed Lines]",
      "794:         if (!SSL_USE_ETM(s) && mac_size != 0) {",
      "",
      "[Added Lines]",
      "794:         if (!SSL_WRITE_ETM(s) && mac_size != 0) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "814:         goto err;",
      "816:     for (j = 0; j < numpipes; j++) {",
      "818:             if (s->method->ssl3_enc->mac(s, &wr[j],",
      "819:                                          outbuf[j] + wr[j].length, 1) < 0)",
      "820:                 goto err;",
      "",
      "[Removed Lines]",
      "817:         if (SSL_USE_ETM(s) && mac_size != 0) {",
      "",
      "[Added Lines]",
      "817:         if (SSL_WRITE_ETM(s) && mac_size != 0) {",
      "",
      "---------------"
    ],
    "ssl/record/ssl3_record.c||ssl/record/ssl3_record.c": [
      "File: ssl/record/ssl3_record.c -> ssl/record/ssl3_record.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "350:         unsigned char *mac;",
      "351:         mac_size = EVP_MD_CTX_size(s->read_hash);",
      "352:         OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);",
      "",
      "[Removed Lines]",
      "349:     if (SSL_USE_ETM(s) && s->read_hash) {",
      "",
      "[Added Lines]",
      "349:     if (SSL_READ_ETM(s) && s->read_hash) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "394:     if ((sess != NULL) &&",
      "395:         (s->enc_read_ctx != NULL) &&",
      "398:         unsigned char *mac = NULL;",
      "399:         unsigned char mac_tmp[EVP_MAX_MD_SIZE];",
      "",
      "[Removed Lines]",
      "396:         (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {",
      "",
      "[Added Lines]",
      "396:         (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "823:         }",
      "825:         ret = 1;",
      "827:             mac_size = EVP_MD_CTX_size(s->read_hash);",
      "828:         if ((bs != 1) && !send) {",
      "829:             int tmpret;",
      "",
      "[Removed Lines]",
      "826:         if (!SSL_USE_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)",
      "",
      "[Added Lines]",
      "826:         if (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "997:     header[11] = (rec->length) >> 8;",
      "998:     header[12] = (rec->length) & 0xff;",
      "1001:         EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
      "1002:         ssl3_cbc_record_digest_supported(mac_ctx)) {",
      "",
      "[Removed Lines]",
      "1000:     if (!send && !SSL_USE_ETM(ssl) &&",
      "",
      "[Added Lines]",
      "1000:     if (!send && !SSL_READ_ETM(ssl) &&",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1022:             EVP_MD_CTX_free(hmac);",
      "1023:             return -1;",
      "1024:         }",
      "1026:             if (!tls_fips_digest_extra(ssl->enc_read_ctx,",
      "1027:                                        mac_ctx, rec->input,",
      "1028:                                        rec->length, rec->orig_len)) {",
      "",
      "[Removed Lines]",
      "1025:         if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())",
      "",
      "[Added Lines]",
      "1025:         if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())",
      "",
      "---------------"
    ],
    "ssl/ssl_locl.h||ssl/ssl_locl.h": [
      "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "378: # define SSL_CLIENT_USE_SIGALGS(s)        \\",
      "379:     SSL_CLIENT_USE_TLS1_2_CIPHERS(s)",
      "384: # define SSL_PKEY_RSA_ENC        0",
      "",
      "[Removed Lines]",
      "381: # define SSL_USE_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC)",
      "",
      "[Added Lines]",
      "381: # define SSL_READ_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_READ)",
      "382: # define SSL_WRITE_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1111:     unsigned char *alpn_client_proto_list;",
      "1112:     unsigned alpn_client_proto_list_len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1116:     int tlsext_use_etm;",
      "",
      "---------------"
    ],
    "ssl/t1_enc.c||ssl/t1_enc.c": [
      "File: ssl/t1_enc.c -> ssl/t1_enc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130: #endif",
      "132:     if (which & SSL3_CC_READ) {",
      "133:         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)",
      "134:             s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;",
      "135:         else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:         if (s->tlsext_use_etm)",
      "134:             s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;",
      "135:         else",
      "136:             s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "168:         mac_secret = &(s->s3->read_mac_secret[0]);",
      "169:         mac_secret_size = &(s->s3->read_mac_secret_size);",
      "170:     } else {",
      "171:         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)",
      "172:             s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;",
      "173:         else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "176:         if (s->tlsext_use_etm)",
      "177:             s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;",
      "178:         else",
      "179:             s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "367:     if (s->s3->tmp.key_block_length != 0)",
      "368:         return (1);",
      "373:         SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);",
      "374:         return (0);",
      "375:     }",
      "",
      "[Removed Lines]",
      "370:     if (!ssl_cipher_get_evp",
      "371:         (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp,",
      "372:          SSL_USE_ETM(s))) {",
      "",
      "[Added Lines]",
      "380:     if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size,",
      "381:                             &comp, s->tlsext_use_etm)) {",
      "",
      "---------------"
    ],
    "ssl/t1_lib.c||ssl/t1_lib.c": [
      "File: ssl/t1_lib.c -> ssl/t1_lib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1674: #endif",
      "1675:     if (!custom_ext_add(s, 1, &ret, limit, al))",
      "1676:         return NULL;",
      "",
      "[Removed Lines]",
      "1677:     if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {",
      "",
      "[Added Lines]",
      "1677:     if (s->tlsext_use_etm) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1683:             || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4",
      "1684:             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT",
      "1685:             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)",
      "1687:         else {",
      "",
      "[Removed Lines]",
      "1686:             s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "1686:             s->tlsext_use_etm = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1917:     OPENSSL_free(s->s3->tmp.peer_sigalgs);",
      "1918:     s->s3->tmp.peer_sigalgs = NULL;",
      "1921: #ifndef OPENSSL_NO_SRP",
      "1922:     OPENSSL_free(s->srp_ctx.login);",
      "",
      "[Removed Lines]",
      "1919:     s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "1919:     s->tlsext_use_etm = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2264:         }",
      "2265: #endif",
      "2266:         else if (type == TLSEXT_TYPE_encrypt_then_mac)",
      "",
      "[Removed Lines]",
      "2267:             s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "2267:             s->tlsext_use_etm = 1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2366:                              SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);",
      "2367: #endif",
      "2371:     s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;",
      "",
      "[Removed Lines]",
      "2369:     s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "2369:     s->tlsext_use_etm = 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2586:             if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD",
      "2587:                 && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)",
      "2589:         } else if (type == TLSEXT_TYPE_extended_master_secret) {",
      "2590:             s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;",
      "2591:             if (!s->hit)",
      "",
      "[Removed Lines]",
      "2588:                 s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "2588:                 s->tlsext_use_etm = 1;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "263390c32cd4f6baefd41346407eee51c1fd3fa2",
      "candidate_info": {
        "commit_hash": "263390c32cd4f6baefd41346407eee51c1fd3fa2",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/263390c32cd4f6baefd41346407eee51c1fd3fa2",
        "files": [
          "ssl/ssl_lib.c"
        ],
        "message": "Don't read uninitialised data for short session IDs.\n\nWhile it's always safe to read |SSL_MAX_SSL_SESSION_ID_LENGTH| bytes\nfrom an |SSL_SESSION|'s |session_id| array, the hash function would do\nso with without considering if all those bytes had been written to.\n\nThis change checks |session_id_length| before possibly reading\nuninitialised memory. Since the result of the hash function was already\nattacker controlled, and since a lookup of a short session ID will\nalways fail, it doesn't appear that this is anything more than a clean\nup.\n\nIn particular, |ssl_get_prev_session| uses a stack-allocated placeholder\n|SSL_SESSION| as a lookup key, so the |session_id| array may be\nuninitialised.\n\nThis was originally found with libFuzzer and MSan in\nhttps://boringssl.googlesource.com/boringssl/+/e976e4349d693b4bbb97e1694f45be5a1b22c8c7,\nthen by Robert Swiecki with honggfuzz and MSan here. Thanks to both.\n\nReviewed-by: Geoff Thorpe <geoff@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2583)\n(cherry picked from commit bd5d27c1c6d3f83464ddf5124f18a2cac2cbb37f)",
        "before_after_code_files": [
          "ssl/ssl_lib.c||ssl/ssl_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ssl/ssl_lib.c||ssl/ssl_lib.c": [
          "File: ssl/ssl_lib.c -> ssl/ssl_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2306: static unsigned long ssl_session_hash(const SSL_SESSION *a)",
          "2307: {",
          "2308:     unsigned long l;",
          "2310:     l = (unsigned long)",
          "2315:     return (l);",
          "2316: }",
          "",
          "[Removed Lines]",
          "2311:         ((unsigned int)a->session_id[0]) |",
          "2312:         ((unsigned int)a->session_id[1] << 8L) |",
          "2313:         ((unsigned long)a->session_id[2] << 16L) |",
          "2314:         ((unsigned long)a->session_id[3] << 24L);",
          "",
          "[Added Lines]",
          "2308:     const unsigned char *session_id = a->session_id;",
          "2310:     unsigned char tmp_storage[4];",
          "2312:     if (a->session_id_length < sizeof(tmp_storage)) {",
          "2313:         memset(tmp_storage, 0, sizeof(tmp_storage));",
          "2314:         memcpy(tmp_storage, a->session_id, a->session_id_length);",
          "2315:         session_id = tmp_storage;",
          "2316:     }",
          "2319:         ((unsigned long)session_id[0]) |",
          "2320:         ((unsigned long)session_id[1] << 8L) |",
          "2321:         ((unsigned long)session_id[2] << 16L) |",
          "2322:         ((unsigned long)session_id[3] << 24L);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20b53c3efedd192c5a4050bfd44d317e5d802d2e",
      "candidate_info": {
        "commit_hash": "20b53c3efedd192c5a4050bfd44d317e5d802d2e",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/20b53c3efedd192c5a4050bfd44d317e5d802d2e",
        "files": [
          "crypto/init.c"
        ],
        "message": "Add a warning stipulating how things should be coded in ossl_init_base\n\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1922)\n(cherry picked from commit 8aa9cf7e655ae1e41f283fbf16dcc810970058a0)",
        "before_after_code_files": [
          "crypto/init.c||crypto/init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/init.c||crypto/init.c": [
          "File: crypto/init.c -> crypto/init.c"
        ]
      }
    },
    {
      "candidate_hash": "723f616df81ea05f31407f7417f49eea89bb459a",
      "candidate_info": {
        "commit_hash": "723f616df81ea05f31407f7417f49eea89bb459a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/723f616df81ea05f31407f7417f49eea89bb459a",
        "files": [
          "crypto/asn1/bio_asn1.c"
        ],
        "message": "Exit the loop on failure\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2805)\n(cherry picked from commit f125430063dd81efe098c99542b02b2a918adc1d)",
        "before_after_code_files": [
          "crypto/asn1/bio_asn1.c||crypto/asn1/bio_asn1.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/asn1/bio_asn1.c||crypto/asn1/bio_asn1.c": [
          "File: crypto/asn1/bio_asn1.c -> crypto/asn1/bio_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "209:                 wrmax = inl;",
          "210:             ret = BIO_write(next, in, wrmax);",
          "211:             if (ret <= 0)",
          "213:             wrlen += ret;",
          "214:             ctx->copylen -= ret;",
          "215:             in += ret;",
          "",
          "[Removed Lines]",
          "212:                 break;",
          "",
          "[Added Lines]",
          "212:                 goto done;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "249452df67f7a5e4b203d71837cc0e8a31d62c75",
      "candidate_info": {
        "commit_hash": "249452df67f7a5e4b203d71837cc0e8a31d62c75",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/249452df67f7a5e4b203d71837cc0e8a31d62c75",
        "files": [
          "crypto/asn1/x_long.c"
        ],
        "message": "Fix decoding of ASN.1 LONG and ZLONG items\n\nLONG and ZLONG items (which are OpenSSL private special cases of\nASN1_INTEGER) are encoded into DER with padding if the leading octet\nhas the high bit set, where the padding can be 0x00 (for positive\nnumbers) or 0xff (for negative ones).\n\nWhen decoding DER to LONG or ZLONG, the padding wasn't taken in\naccount at all, which means that if the encoded size with padding\nis one byte more than the size of long, decoding fails.  This change\nfixes that issue.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3000)",
        "before_after_code_files": [
          "crypto/asn1/x_long.c||crypto/asn1/x_long.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/asn1/x_long.c||crypto/asn1/x_long.c": [
          "File: crypto/asn1/x_long.c -> crypto/asn1/x_long.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "105: static int long_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "106:                     int utype, char *free_cont, const ASN1_ITEM *it)",
          "107: {",
          "109:     long ltmp;",
          "110:     unsigned long utmp = 0;",
          "111:     char *cp = (char *)pval;",
          "112:     if (len > (int)sizeof(long)) {",
          "113:         ASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);",
          "114:         return 0;",
          "115:     }",
          "121:     utmp = 0;",
          "122:     for (i = 0; i < len; i++) {",
          "123:         utmp <<= 8;",
          "",
          "[Removed Lines]",
          "108:     int neg, i;",
          "117:     if (len && (cont[0] & 0x80))",
          "118:         neg = 1;",
          "119:     else",
          "120:         neg = 0;",
          "",
          "[Added Lines]",
          "108:     int neg = -1, i;",
          "113:     if (len) {",
          "119:         switch (cont[0]) {",
          "120:         case 0xff:",
          "121:             cont++;",
          "122:             len--;",
          "123:             neg = 1;",
          "124:             break;",
          "125:         case 0:",
          "126:             cont++;",
          "127:             len--;",
          "128:             neg = 0;",
          "129:             break;",
          "130:         }",
          "131:     }",
          "136:     if (neg == -1) {",
          "138:         if (len && (cont[0] & 0x80))",
          "139:             neg = 1;",
          "140:         else",
          "141:             neg = 0;",
          "142:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "11361f5998a98b29207e0bcc3d40f638f91ab5d8",
      "candidate_info": {
        "commit_hash": "11361f5998a98b29207e0bcc3d40f638f91ab5d8",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/11361f5998a98b29207e0bcc3d40f638f91ab5d8",
        "files": [
          "test/ecdhtest.c",
          "test/ecdhtest_cavs.h",
          "test/evptests.txt"
        ],
        "message": "ecdhtest.c: move co-factor ECDH KATs to evptests\n\nmove NIST SP800-56A co-factor ECDH KATs from ecdhtest.c to evptests.txt\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3218)",
        "before_after_code_files": [
          "test/ecdhtest.c||test/ecdhtest.c",
          "test/ecdhtest_cavs.h||test/ecdhtest_cavs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/ecdhtest.c||test/ecdhtest.c": [
          "File: test/ecdhtest.c -> test/ecdhtest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: static const char rnd_seed[] =",
          "50:     \"string to make the random number generator think it has entropy\";",
          "213: int main(int argc, char *argv[])",
          "214: {",
          "215:     int ret = 1;",
          "217:     BIO *out;",
          "219:     CRYPTO_set_mem_debug(1);",
          "",
          "[Removed Lines]",
          "54: static EC_KEY *mk_eckey(int nid, const char *str)",
          "55: {",
          "56:     int ok = 0;",
          "57:     EC_KEY *k = NULL;",
          "58:     BIGNUM *priv = NULL;",
          "59:     EC_POINT *pub = NULL;",
          "60:     const EC_GROUP *grp;",
          "61:     k = EC_KEY_new_by_curve_name(nid);",
          "62:     if (!k)",
          "63:         goto err;",
          "64:     if(!BN_hex2bn(&priv, str))",
          "65:         goto err;",
          "66:     if (!priv)",
          "67:         goto err;",
          "68:     if (!EC_KEY_set_private_key(k, priv))",
          "69:         goto err;",
          "70:     grp = EC_KEY_get0_group(k);",
          "71:     pub = EC_POINT_new(grp);",
          "72:     if (!pub)",
          "73:         goto err;",
          "74:     if (!EC_POINT_mul(grp, pub, priv, NULL, NULL, NULL))",
          "75:         goto err;",
          "76:     if (!EC_KEY_set_public_key(k, pub))",
          "77:         goto err;",
          "78:     ok = 1;",
          "79:  err:",
          "80:     BN_clear_free(priv);",
          "81:     EC_POINT_free(pub);",
          "82:     if (ok)",
          "83:         return k;",
          "84:     EC_KEY_free(k);",
          "85:     return NULL;",
          "86: }",
          "88: #include \"ecdhtest_cavs.h\"",
          "111: static int ecdh_cavs_kat(BIO *out, const ecdh_cavs_kat_t *kat)",
          "112: {",
          "113:     int rv = 0, is_char_two = 0;",
          "114:     EC_KEY *key1 = NULL;",
          "115:     EC_POINT *pub = NULL;",
          "116:     const EC_GROUP *group = NULL;",
          "117:     BIGNUM *bnz = NULL, *x = NULL, *y = NULL;",
          "118:     unsigned char *Ztmp = NULL, *Z = NULL;",
          "119:     size_t Ztmplen, Zlen;",
          "120:     BIO_puts(out, \"Testing ECC CDH Primitive SP800-56A with \");",
          "121:     BIO_puts(out, OBJ_nid2sn(kat->nid));",
          "124:     if ((key1 = mk_eckey(kat->nid, kat->dIUT)) == NULL)",
          "125:         goto err;",
          "127:     EC_KEY_set_flags(key1, EC_FLAG_COFACTOR_ECDH);",
          "129:     if ((group = EC_KEY_get0_group(key1)) == NULL)",
          "130:         goto err;",
          "131:     if ((pub = EC_POINT_new(group)) == NULL)",
          "132:         goto err;",
          "134:     if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_characteristic_two_field)",
          "135:         is_char_two = 1;",
          "138:     if(!BN_hex2bn(&x, kat->QIUTx))",
          "139:         goto err;",
          "140:     if(!BN_hex2bn(&y, kat->QIUTy))",
          "141:         goto err;",
          "142:     if (is_char_two) {",
          "143: #ifdef OPENSSL_NO_EC2M",
          "144:         goto err;",
          "145: #else",
          "146:         if (!EC_POINT_set_affine_coordinates_GF2m(group, pub, x, y, NULL))",
          "147:             goto err;",
          "148: #endif",
          "149:     }",
          "150:     else {",
          "151:         if (!EC_POINT_set_affine_coordinates_GFp(group, pub, x, y, NULL))",
          "152:             goto err;",
          "153:     }",
          "155:     if (EC_POINT_cmp(group, EC_KEY_get0_public_key(key1), pub, NULL))",
          "156:         goto err;",
          "159:     if(!BN_hex2bn(&x, kat->QCAVSx))",
          "160:         goto err;",
          "161:     if(!BN_hex2bn(&y, kat->QCAVSy))",
          "162:         goto err;",
          "163:     if (is_char_two) {",
          "164: #ifdef OPENSSL_NO_EC2M",
          "165:         goto err;",
          "166: #else",
          "167:         if (!EC_POINT_set_affine_coordinates_GF2m(group, pub, x, y, NULL))",
          "168:             goto err;",
          "169: #endif",
          "170:     }",
          "171:     else {",
          "172:         if (!EC_POINT_set_affine_coordinates_GFp(group, pub, x, y, NULL))",
          "173:             goto err;",
          "174:     }",
          "177:     if(!BN_hex2bn(&bnz, kat->ZIUT))",
          "178:         goto err;",
          "179:     Ztmplen = (EC_GROUP_get_degree(EC_KEY_get0_group(key1)) + 7) / 8;",
          "180:     Zlen = BN_num_bytes(bnz);",
          "181:     if (Zlen > Ztmplen)",
          "182:         goto err;",
          "183:     if((Ztmp = OPENSSL_zalloc(Ztmplen)) == NULL)",
          "184:         goto err;",
          "185:     if((Z = OPENSSL_zalloc(Ztmplen)) == NULL)",
          "186:         goto err;",
          "187:     if(!BN_bn2binpad(bnz, Z, Ztmplen))",
          "188:         goto err;",
          "189:     if (!ECDH_compute_key(Ztmp, Ztmplen, pub, key1, 0))",
          "190:         goto err;",
          "192:     if (memcmp(Ztmp, Z, Ztmplen))",
          "193:         goto err;",
          "194:     rv = 1;",
          "195:  err:",
          "196:     EC_KEY_free(key1);",
          "197:     EC_POINT_free(pub);",
          "198:     BN_free(bnz);",
          "199:     BN_free(x);",
          "200:     BN_free(y);",
          "201:     OPENSSL_free(Ztmp);",
          "202:     OPENSSL_free(Z);",
          "203:     if (rv) {",
          "204:         BIO_puts(out, \" ok\\n\");",
          "205:     }",
          "206:     else {",
          "207:         fprintf(stderr, \"Error in ECC CDH routines\\n\");",
          "208:         ERR_print_errors_fp(stderr);",
          "209:     }",
          "210:     return rv;",
          "211: }",
          "216:     size_t n = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "239:     ret = 0;",
          "",
          "[Removed Lines]",
          "234:     for (n = 0; n < (sizeof(ecdh_cavs_kats)/sizeof(ecdh_cavs_kat_t)); n++) {",
          "235:         if (!ecdh_cavs_kat(out, &ecdh_cavs_kats[n]))",
          "236:             goto err;",
          "237:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/ecdhtest_cavs.h||test/ecdhtest_cavs.h": [
          "File: test/ecdhtest_cavs.h -> test/ecdhtest_cavs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-18021",
  "cve_desc": "arch/arm64/kvm/guest.c in KVM in the Linux kernel before 4.18.12 on the arm64 platform mishandles the KVM_SET_ON_REG ioctl. This is exploitable by attackers who can create virtual machines. An attacker can arbitrarily redirect the hypervisor flow of control (with full register control). An attacker can also cause a denial of service (hypervisor panic) via an illegal exception return. This occurs because of insufficient restrictions on userspace access to the core register file, and because PSTATE.M validation does not prevent unintended execution modes.",
  "repo": "torvalds/linux",
  "patch_hash": "d26c25a9d19b5976b319af528886f89cf455692d",
  "patch_info": {
    "commit_hash": "d26c25a9d19b5976b319af528886f89cf455692d",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d26c25a9d19b5976b319af528886f89cf455692d",
    "files": [
      "arch/arm64/kvm/guest.c"
    ],
    "message": "arm64: KVM: Tighten guest core register access from userspace\n\nWe currently allow userspace to access the core register file\nin about any possible way, including straddling multiple\nregisters and doing unaligned accesses.\n\nThis is not the expected use of the ABI, and nobody is actually\nusing it that way. Let's tighten it by explicitly checking\nthe size and alignment for each field of the register file.\n\nCc: <stable@vger.kernel.org>\nFixes: 2f4a07c5f9fe (\"arm64: KVM: guest one-reg interface\")\nReviewed-by: Christoffer Dall <christoffer.dall@arm.com>\nReviewed-by: Mark Rutland <mark.rutland@arm.com>\nSigned-off-by: Dave Martin <Dave.Martin@arm.com>\n[maz: rewrote Dave's initial patch to be more easily backported]\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
    "before_after_code_files": [
      "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
    ]
  },
  "patch_diff": {
    "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c": [
      "File: arch/arm64/kvm/guest.c -> arch/arm64/kvm/guest.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:  return id & ~(KVM_REG_ARCH_MASK | KVM_REG_SIZE_MASK | KVM_REG_ARM_CORE);",
      "58: }",
      "60: static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)",
      "61: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "60: static int validate_core_offset(const struct kvm_one_reg *reg)",
      "61: {",
      "62:  u64 off = core_reg_offset_from_id(reg->id);",
      "63:  int size;",
      "65:  switch (off) {",
      "66:  case KVM_REG_ARM_CORE_REG(regs.regs[0]) ...",
      "67:       KVM_REG_ARM_CORE_REG(regs.regs[30]):",
      "68:  case KVM_REG_ARM_CORE_REG(regs.sp):",
      "69:  case KVM_REG_ARM_CORE_REG(regs.pc):",
      "70:  case KVM_REG_ARM_CORE_REG(regs.pstate):",
      "71:  case KVM_REG_ARM_CORE_REG(sp_el1):",
      "72:  case KVM_REG_ARM_CORE_REG(elr_el1):",
      "73:  case KVM_REG_ARM_CORE_REG(spsr[0]) ...",
      "74:       KVM_REG_ARM_CORE_REG(spsr[KVM_NR_SPSR - 1]):",
      "75:   size = sizeof(__u64);",
      "76:   break;",
      "78:  case KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...",
      "79:       KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):",
      "80:   size = sizeof(__uint128_t);",
      "81:   break;",
      "83:  case KVM_REG_ARM_CORE_REG(fp_regs.fpsr):",
      "84:  case KVM_REG_ARM_CORE_REG(fp_regs.fpcr):",
      "85:   size = sizeof(__u32);",
      "86:   break;",
      "88:  default:",
      "89:   return -EINVAL;",
      "90:  }",
      "92:  if (KVM_REG_SIZE(reg->id) == size &&",
      "93:      IS_ALIGNED(off, size / sizeof(__u32)))",
      "94:   return 0;",
      "96:  return -EINVAL;",
      "97: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "76:      (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)",
      "77:   return -ENOENT;",
      "79:  if (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))",
      "80:   return -EFAULT;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "118:  if (validate_core_offset(reg))",
      "119:   return -EINVAL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "98:      (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)",
      "99:   return -ENOENT;",
      "101:  if (KVM_REG_SIZE(reg->id) > sizeof(tmp))",
      "102:   return -EINVAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "143:  if (validate_core_offset(reg))",
      "144:   return -EINVAL;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8c86dfe39d5d3c91fb201b67b72826f75bd2b655",
      "candidate_info": {
        "commit_hash": "8c86dfe39d5d3c91fb201b67b72826f75bd2b655",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8c86dfe39d5d3c91fb201b67b72826f75bd2b655",
        "files": [
          "arch/arm64/kvm/guest.c"
        ],
        "message": "KVM: arm64: Reject ioctl access to FPSIMD V-regs on SVE vcpus\n\nIn order to avoid the pointless complexity of maintaining two ioctl\nregister access views of the same data, this patch blocks ioctl\naccess to the FPSIMD V-registers on vcpus that support SVE.\n\nThis will make it more straightforward to add SVE register access\nsupport.\n\nSince SVE is an opt-in feature for userspace, this will not affect\nexisting users.\n\nSigned-off-by: Dave Martin <Dave.Martin@arm.com>\nReviewed-by: Julien Thierry <julien.thierry@arm.com>\nTested-by: zhang.lei <zhang.lei@jp.fujitsu.com>\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>",
        "before_after_code_files": [
          "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
          ],
          "candidate": [
            "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c": [
          "File: arch/arm64/kvm/guest.c -> arch/arm64/kvm/guest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:  return 0;",
          "55: }",
          "57: static u64 core_reg_offset_from_id(u64 id)",
          "58: {",
          "59:  return id & ~(KVM_REG_ARCH_MASK | KVM_REG_SIZE_MASK | KVM_REG_ARM_CORE);",
          "60: }",
          "63: {",
          "64:  u64 off = core_reg_offset_from_id(reg->id);",
          "65:  int size;",
          "",
          "[Removed Lines]",
          "62: static int validate_core_offset(const struct kvm_one_reg *reg)",
          "",
          "[Added Lines]",
          "57: static bool core_reg_offset_is_vreg(u64 off)",
          "58: {",
          "59:  return off >= KVM_REG_ARM_CORE_REG(fp_regs.vregs) &&",
          "60:   off < KVM_REG_ARM_CORE_REG(fp_regs.fpsr);",
          "61: }",
          "68: static int validate_core_offset(const struct kvm_vcpu *vcpu,",
          "69:     const struct kvm_one_reg *reg)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:   return -EINVAL;",
          "92:  }",
          "99: }",
          "101: static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)",
          "",
          "[Removed Lines]",
          "94:  if (KVM_REG_SIZE(reg->id) == size &&",
          "95:      IS_ALIGNED(off, size / sizeof(__u32)))",
          "96:   return 0;",
          "98:  return -EINVAL;",
          "",
          "[Added Lines]",
          "101:  if (KVM_REG_SIZE(reg->id) != size ||",
          "102:      !IS_ALIGNED(off, size / sizeof(__u32)))",
          "103:   return -EINVAL;",
          "110:  if (vcpu_has_sve(vcpu) && core_reg_offset_is_vreg(off))",
          "111:   return -EINVAL;",
          "113:  return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "117:      (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)",
          "118:   return -ENOENT;",
          "121:   return -EINVAL;",
          "123:  if (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))",
          "",
          "[Removed Lines]",
          "120:  if (validate_core_offset(reg))",
          "",
          "[Added Lines]",
          "135:  if (validate_core_offset(vcpu, reg))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "142:      (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)",
          "143:   return -ENOENT;",
          "146:   return -EINVAL;",
          "148:  if (KVM_REG_SIZE(reg->id) > sizeof(tmp))",
          "",
          "[Removed Lines]",
          "145:  if (validate_core_offset(reg))",
          "",
          "[Added Lines]",
          "160:  if (validate_core_offset(vcpu, reg))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "195:  return -EINVAL;",
          "196: }",
          "199: {",
          "200:  unsigned int i;",
          "201:  int n = 0;",
          "202:  const u64 core_reg = KVM_REG_ARM64 | KVM_REG_SIZE_U64 | KVM_REG_ARM_CORE;",
          "204:  for (i = 0; i < sizeof(struct kvm_regs) / sizeof(__u32); i++) {",
          "205:   if (uindices) {",
          "206:    if (put_user(core_reg | i, uindices))",
          "207:     return -EFAULT;",
          "",
          "[Removed Lines]",
          "198: static int kvm_arm_copy_core_reg_indices(u64 __user *uindices)",
          "",
          "[Added Lines]",
          "213: static int copy_core_reg_indices(const struct kvm_vcpu *vcpu,",
          "214:      u64 __user *uindices)",
          "226:   if (vcpu_has_sve(vcpu) && core_reg_offset_is_vreg(i))",
          "227:    continue;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "214:  return n;",
          "215: }",
          "218: {",
          "220: }",
          "",
          "[Removed Lines]",
          "217: static unsigned long num_core_regs(void)",
          "219:  return kvm_arm_copy_core_reg_indices(NULL);",
          "",
          "[Added Lines]",
          "241: static unsigned long num_core_regs(const struct kvm_vcpu *vcpu)",
          "243:  return copy_core_reg_indices(vcpu, NULL);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "281: {",
          "282:  unsigned long res = 0;",
          "285:  res += kvm_arm_num_sys_reg_descs(vcpu);",
          "286:  res += kvm_arm_get_fw_num_regs(vcpu);",
          "287:  res += NUM_TIMER_REGS;",
          "",
          "[Removed Lines]",
          "284:  res += num_core_regs();",
          "",
          "[Added Lines]",
          "308:  res += num_core_regs(vcpu);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "298: {",
          "299:  int ret;",
          "302:  if (ret)",
          "303:   return ret;",
          "304:  uindices += ret;",
          "",
          "[Removed Lines]",
          "301:  ret = kvm_arm_copy_core_reg_indices(uindices);",
          "",
          "[Added Lines]",
          "325:  ret = copy_core_reg_indices(vcpu, uindices);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df205b5c63281e4f32caac22adda18fd68795e80",
      "candidate_info": {
        "commit_hash": "df205b5c63281e4f32caac22adda18fd68795e80",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/df205b5c63281e4f32caac22adda18fd68795e80",
        "files": [
          "arch/arm64/kvm/guest.c"
        ],
        "message": "KVM: arm64: Filter out invalid core register IDs in KVM_GET_REG_LIST\n\nSince commit d26c25a9d19b (\"arm64: KVM: Tighten guest core register\naccess from userspace\"), KVM_{GET,SET}_ONE_REG rejects register IDs\nthat do not correspond to a single underlying architectural register.\n\nKVM_GET_REG_LIST was not changed to match however: instead, it\nsimply yields a list of 32-bit register IDs that together cover the\nwhole kvm_regs struct.  This means that if userspace tries to use\nthe resulting list of IDs directly to drive calls to KVM_*_ONE_REG,\nsome of those calls will now fail.\n\nThis was not the intention.  Instead, iterating KVM_*_ONE_REG over\nthe list of IDs returned by KVM_GET_REG_LIST should be guaranteed\nto work.\n\nThis patch fixes the problem by splitting validate_core_offset()\ninto a backend core_reg_size_from_offset() which does all of the\nwork except for checking that the size field in the register ID\nmatches, and kvm_arm_copy_reg_indices() and num_core_regs() are\nconverted to use this to enumerate the valid offsets.\n\nkvm_arm_copy_reg_indices() now also sets the register ID size field\nappropriately based on the value returned, so the register ID\nsupplied to userspace is fully qualified for use with the register\naccess ioctls.\n\nCc: stable@vger.kernel.org\nFixes: d26c25a9d19b (\"arm64: KVM: Tighten guest core register access from userspace\")\nSigned-off-by: Dave Martin <Dave.Martin@arm.com>\nReviewed-by: Andrew Jones <drjones@redhat.com>\nTested-by: Andrew Jones <drjones@redhat.com>\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>",
        "before_after_code_files": [
          "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
          ],
          "candidate": [
            "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c": [
          "File: arch/arm64/kvm/guest.c -> arch/arm64/kvm/guest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:  return id & ~(KVM_REG_ARCH_MASK | KVM_REG_SIZE_MASK | KVM_REG_ARM_CORE);",
          "71: }",
          "75: {",
          "77:  int size;",
          "79:  switch (off) {",
          "",
          "[Removed Lines]",
          "73: static int validate_core_offset(const struct kvm_vcpu *vcpu,",
          "74:     const struct kvm_one_reg *reg)",
          "76:  u64 off = core_reg_offset_from_id(reg->id);",
          "",
          "[Added Lines]",
          "73: static int core_reg_size_from_offset(const struct kvm_vcpu *vcpu, u64 off)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "103:   return -EINVAL;",
          "104:  }",
          "108:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "106:  if (KVM_REG_SIZE(reg->id) != size ||",
          "107:      !IS_ALIGNED(off, size / sizeof(__u32)))",
          "",
          "[Added Lines]",
          "104:  if (!IS_ALIGNED(off, size / sizeof(__u32)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "115:  if (vcpu_has_sve(vcpu) && core_reg_offset_is_vreg(off))",
          "116:   return -EINVAL;",
          "118:  return 0;",
          "119: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "115:  return size;",
          "116: }",
          "118: static int validate_core_offset(const struct kvm_vcpu *vcpu,",
          "119:     const struct kvm_one_reg *reg)",
          "120: {",
          "121:  u64 off = core_reg_offset_from_id(reg->id);",
          "122:  int size = core_reg_size_from_offset(vcpu, off);",
          "124:  if (size < 0)",
          "125:   return -EINVAL;",
          "127:  if (KVM_REG_SIZE(reg->id) != size)",
          "128:   return -EINVAL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "447: {",
          "448:  unsigned int i;",
          "449:  int n = 0;",
          "452:  for (i = 0; i < sizeof(struct kvm_regs) / sizeof(__u32); i++) {",
          "459:    continue;",
          "461:   if (uindices) {",
          "463:     return -EFAULT;",
          "464:    uindices++;",
          "465:   }",
          "",
          "[Removed Lines]",
          "450:  const u64 core_reg = KVM_REG_ARM64 | KVM_REG_SIZE_U64 | KVM_REG_ARM_CORE;",
          "458:   if (vcpu_has_sve(vcpu) && core_reg_offset_is_vreg(i))",
          "462:    if (put_user(core_reg | i, uindices))",
          "",
          "[Added Lines]",
          "464:   u64 reg = KVM_REG_ARM64 | KVM_REG_ARM_CORE | i;",
          "465:   int size = core_reg_size_from_offset(vcpu, i);",
          "467:   if (size < 0)",
          "468:    continue;",
          "470:   switch (size) {",
          "471:   case sizeof(__u32):",
          "472:    reg |= KVM_REG_SIZE_U32;",
          "473:    break;",
          "475:   case sizeof(__u64):",
          "476:    reg |= KVM_REG_SIZE_U64;",
          "477:    break;",
          "479:   case sizeof(__uint128_t):",
          "480:    reg |= KVM_REG_SIZE_U128;",
          "481:    break;",
          "483:   default:",
          "484:    WARN_ON(1);",
          "486:   }",
          "489:    if (put_user(reg, uindices))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
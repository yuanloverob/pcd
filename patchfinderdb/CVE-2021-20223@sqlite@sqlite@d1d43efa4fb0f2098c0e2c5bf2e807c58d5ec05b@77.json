{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c37577bb2dfb602a5cdbba8322a01b548c34c185",
      "candidate_info": {
        "commit_hash": "c37577bb2dfb602a5cdbba8322a01b548c34c185",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c37577bb2dfb602a5cdbba8322a01b548c34c185",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/resolve.c",
          "src/window.c",
          "test/window1.test"
        ],
        "message": "When rewriting a query for window functions, if the rewrite changes the depth of TK_AGG_FUNCTION nodes, be sure to adjust the Expr.op2 field appropriately.  Fix for ticket [7a5279a25c57adf1]\n\nFossilOrigin-Name: ad7bb70af9bb68d192137188bb2528f1e9e43ad164c925174ca1dafc9e1f5339",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/resolve.c||src/resolve.c",
          "src/window.c||src/window.c",
          "test/window1.test||test/window1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: dac438236f7c5419d4e7e094e8b3f19f83cd3b1a18bc8acb14aee90d4514fa3c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "916:   return pList;",
          "917: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "927: static int sqlite3WindowExtraAggFuncDepth(Walker *pWalker, Expr *pExpr){",
          "928:   if( pExpr->op==TK_AGG_FUNCTION",
          "929:    && pExpr->op2>=pWalker->walkerDepth",
          "930:   ){",
          "931:     pExpr->op2++;",
          "932:   }",
          "933:   return WRC_Continue;",
          "934: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1025:     p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);",
          "1026:     if( p->pSrc ){",
          "1027:       Table *pTab2;",
          "1028:       p->pSrc->a[0].pSelect = pSub;",
          "1029:       sqlite3SrcListAssignCursors(pParse, p->pSrc);",
          "1030:       pSub->selFlags |= SF_Expanded;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1045:       Walker w;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1040:         pTab->tabFlags |= TF_Ephemeral;",
          "1041:         p->pSrc->a[0].pTab = pTab;",
          "1042:         pTab = pTab2;",
          "1043:       }",
          "1044:     }else{",
          "1045:       sqlite3SelectDelete(db, pSub);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1061:         memset(&w, 0, sizeof(w));",
          "1062:         w.xExprCallback = sqlite3WindowExtraAggFuncDepth;",
          "1063:         w.xSelectCallback = sqlite3WalkerDepthIncrease;",
          "1064:         w.xSelectCallback2 = sqlite3WalkerDepthDecrease;",
          "1065:         sqlite3WalkSelect(&w, pSub);",
          "",
          "---------------"
        ],
        "test/window1.test||test/window1.test": [
          "File: test/window1.test -> test/window1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1727:   4 938 938 4",
          "1728: }",
          "1731: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1730: # 2020-05-23",
          "1731: # ticket 7a5279a25c57adf1",
          "1732: #",
          "1733: reset_db",
          "1734: do_execsql_test 53.0 {",
          "1735:   CREATE TABLE a(c UNIQUE);",
          "1736:   INSERT INTO a VALUES(4),(0),(9),(-9);",
          "1737:   SELECT a.c",
          "1738:     FROM a",
          "1739:     JOIN a AS b ON a.c=4",
          "1740:     JOIN a AS e ON a.c=e.c",
          "1741:    WHERE a.c=(SELECT (SELECT coalesce(lead(2) OVER(),0) + sum(d.c))",
          "1742:                 FROM a AS d",
          "1743:                WHERE a.c);",
          "1744: } {4 4 4 4}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "896366282dae3789fb277c2dad8660784a0895a3",
      "candidate_info": {
        "commit_hash": "896366282dae3789fb277c2dad8660784a0895a3",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/896366282dae3789fb277c2dad8660784a0895a3",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/expr.c",
          "src/select.c",
          "src/sqliteInt.h",
          "src/window.c",
          "test/fuzzdata8.db",
          "test/window1.test"
        ],
        "message": "Alternative fix to ticket [c8d3b9f0a750a529]:  Prior to deleting or modifying an Expr not that is referenced by an AggInfo, modify the AggInfo to get its own copy of the original Expr.\n\nFossilOrigin-Name: 7682d8a768fbccfe0cc956e9f6481637146e1ab9763b248ff11052761ce32e32",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/expr.c||src/expr.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/window.c||src/window.c",
          "test/window1.test||test/window1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c1c8937a30feff6aa4385b0c264fd8e70d54422a0629c2ce38082d85d3334a57",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "208:       sqlite3AutoincrementBegin(pParse);",
          "211:       if( pParse->pConstExpr ){",
          "212:         ExprList *pEL = pParse->pConstExpr;",
          "213:         pParse->okConstFactor = 0;",
          "214:         for(i=0; i<pEL->nExpr; i++){",
          "216:         }",
          "217:       }",
          "",
          "[Removed Lines]",
          "215:           sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);",
          "",
          "[Added Lines]",
          "221:           int iReg = pEL->a[i].u.iConstExprReg;",
          "222:           if( iReg>0 ){",
          "223:             sqlite3ExprCode(pParse, pEL->a[i].pExpr, iReg);",
          "224:           }",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5709:   return cnt.nThis>0 || cnt.nOther==0;",
          "5710: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5725: static int agginfoPersistExprCb(Walker *pWalker, Expr *pExpr){",
          "5726:   if( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced)",
          "5727:    && pExpr->pAggInfo!=0",
          "5728:   ){",
          "5729:     AggInfo *pAggInfo = pExpr->pAggInfo;",
          "5730:     int iAgg = pExpr->iAgg;",
          "5731:     Parse *pParse = pWalker->pParse;",
          "5732:     sqlite3 *db = pParse->db;",
          "5733:     assert( pAggInfo->iAggMagic==AggInfoMagic );",
          "5734:     assert( pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN",
          "5735:             || pExpr->op==TK_FUNCTION || pExpr->op==TK_AGG_FUNCTION );",
          "5736:     if( pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN ){",
          "5737:       assert( iAgg>=0 && iAgg<pAggInfo->nColumn );",
          "5738:       if( pAggInfo->aCol[iAgg].pExpr==pExpr ){",
          "5739:         pExpr = sqlite3ExprDup(db, pExpr, 0);",
          "5740:         if( pExpr ){",
          "5741:           pAggInfo->aCol[iAgg].pExpr = pExpr;",
          "5742:           pParse->pConstExpr =",
          "5743:              sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);",
          "5744:         }",
          "5745:       }",
          "5746:     }else{",
          "5747:       assert( iAgg>=0 && iAgg<pAggInfo->nFunc );",
          "5748:       if( pAggInfo->aFunc[iAgg].pExpr==pExpr ){",
          "5749:         pExpr = sqlite3ExprDup(db, pExpr, 0);",
          "5750:         if( pExpr ){",
          "5751:           pAggInfo->aFunc[iAgg].pExpr = pExpr;",
          "5752:           pParse->pConstExpr =",
          "5753:              sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);",
          "5754:         }",
          "5755:       }",
          "5756:     }",
          "5757:   }",
          "5758:   return WRC_Continue;",
          "5759: }",
          "5765: void sqlite3AggInfoPersistWalkerInit(Walker *pWalker, Parse *pParse){",
          "5766:   memset(pWalker, 0, sizeof(*pWalker));",
          "5767:   pWalker->pParse = pParse;",
          "5768:   pWalker->xExprCallback = agginfoPersistExprCb;",
          "5769:   pWalker->xSelectCallback = sqlite3SelectWalkNoop;",
          "5770: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5739:        &i",
          "5740:   );",
          "5741:   return i;",
          "",
          "[Removed Lines]",
          "5742: }",
          "",
          "[Added Lines]",
          "5802: }",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4168:   sqlite3SelectDelete(db, pSub1);",
          "4170: #if SELECTTRACE_ENABLED",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4169:   sqlite3AggInfoPersistWalkerInit(&w, pParse);",
          "4170:   sqlite3WalkSelect(&w,pSub1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5765:   }",
          "5766:   if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;",
          "5767:   memset(&sAggInfo, 0, sizeof(sAggInfo));",
          "5768: #if SELECTTRACE_ENABLED",
          "5769:   SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));",
          "5770:   if( sqlite3SelectTrace & 0x100 ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5771: #ifdef SQLITE_DEBUG",
          "5772:   sAggInfo.iAggMagic = AggInfoMagic;",
          "5773: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5917:     }",
          "5918: #endif",
          "5919:     if( p->pNext==0 ) ExplainQueryPlanPop(pParse);",
          "5920:     return rc;",
          "5921:   }",
          "5922: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5926:     assert( sAggInfo.nFunc==0 && sAggInfo.nColumn==0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6790: select_end:",
          "6791:   sqlite3ExprListDelete(db, pMinMaxOrderBy);",
          "6794: #if SELECTTRACE_ENABLED",
          "6795:   SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));",
          "6796:   if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){",
          "",
          "[Removed Lines]",
          "6792:   sqlite3DbFree(db, sAggInfo.aCol);",
          "6793:   sqlite3DbFree(db, sAggInfo.aFunc);",
          "",
          "[Added Lines]",
          "6799:   if( sAggInfo.aCol ){",
          "6800: #ifdef SQLITE_DEBUG",
          "6801:     for(i=0; i<sAggInfo.nColumn; i++){",
          "6802:       Expr *pExpr = sAggInfo.aCol[i].pExpr;",
          "6803:       assert( pExpr!=0 || pParse->db->mallocFailed );",
          "6804:       if( pExpr==0 ) continue;",
          "6805:       assert( pExpr->pAggInfo==&sAggInfo );",
          "6806:       assert( pExpr->iAgg==i );",
          "6807:     }",
          "6808: #endif",
          "6809:     sqlite3DbFree(db, sAggInfo.aCol);",
          "6810:   }",
          "6811:   if( sAggInfo.aFunc ){",
          "6812: #ifdef SQLITE_DEBUG",
          "6813:     for(i=0; i<sAggInfo.nFunc; i++){",
          "6814:       Expr *pExpr = sAggInfo.aFunc[i].pExpr;",
          "6815:       assert( pExpr!=0 || pParse->db->mallocFailed );",
          "6816:       if( pExpr==0 ) continue;",
          "6817:       assert( pExpr->pAggInfo==&sAggInfo );",
          "6818:       assert( pExpr->iAgg==i );",
          "6819:     }",
          "6820: #endif",
          "6821:     sqlite3DbFree(db, sAggInfo.aFunc);",
          "6822:   }",
          "6823: #ifdef SQLITE_DEBUG",
          "6824:   sAggInfo.iAggMagic = 0;",
          "6825: #endif",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2524:   } *aFunc;",
          "2526: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2526: #ifdef SQLITE_DEBUG",
          "2528: #endif",
          "2534: #define AggInfoMagic  0x2059e99e",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4287: int sqlite3ExprListCompare(ExprList*, ExprList*, int);",
          "4288: int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);",
          "4289: int sqlite3ExprImpliesNonNullRow(Expr*,int);",
          "4290: void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);",
          "4291: void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);",
          "4292: int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4298: void sqlite3AggInfoPersistWalkerInit(Walker*,Parse*);",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "958:     Table *pTab;",
          "959:     u32 selFlags = p->selFlags;",
          "961:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
          "962:     if( pTab==0 ){",
          "963:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
          "964:     }",
          "966:     p->pSrc = 0;",
          "967:     p->pWhere = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "959:     Walker w;",
          "967:     sqlite3AggInfoPersistWalkerInit(&w, pParse);",
          "968:     sqlite3WalkSelect(&w, p);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1042:     p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);",
          "1043:     if( p->pSrc ){",
          "1044:       Table *pTab2;",
          "1046:       p->pSrc->a[0].pSelect = pSub;",
          "1047:       sqlite3SrcListAssignCursors(pParse, p->pSrc);",
          "1048:       pSub->selFlags |= SF_Expanded;",
          "",
          "[Removed Lines]",
          "1045:       Walker w;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/window1.test||test/window1.test": [
          "File: test/window1.test -> test/window1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1743:                WHERE a.c);",
          "1744: } {4 4 4 4}",
          "1747: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1746: #-------------------------------------------------------------------------",
          "1747: reset_db",
          "1748: do_execsql_test 54.1 {",
          "1749:   CREATE TABLE t1(a VARCHAR(20), b FLOAT);",
          "1750:   INSERT INTO t1 VALUES('1',10.0);",
          "1751: }",
          "1753: do_catchsql_test 54.2 {",
          "1754:   SELECT * FROM (",
          "1755:     SELECT sum(b) OVER() AS c FROM t1",
          "1756:       UNION",
          "1757:     SELECT b AS c FROM t1",
          "1758:   ) WHERE c>10;",
          "1759: } {1 {misuse of window function sum()}}",
          "1761: do_execsql_test 54.3 {",
          "1762:   INSERT INTO t1 VALUES('2',5.0);",
          "1763:   INSERT INTO t1 VALUES('3',15.0);",
          "1764: }",
          "1766: do_catchsql_test 54.4 {",
          "1767:   SELECT * FROM (",
          "1768:     SELECT sum(b) OVER() AS c FROM t1",
          "1769:       UNION",
          "1770:     SELECT b AS c FROM t1",
          "1771:   ) WHERE c>10;",
          "1772: } {1 {misuse of window function sum()}}",
          "1774: # 2020-06-05 ticket c8d3b9f0a750a529",
          "1775: reset_db",
          "1776: do_execsql_test 55.1 {",
          "1777:    CREATE TABLE a(b);",
          "1778:    SELECT",
          "1779:       (SELECT b FROM a",
          "1780:         GROUP BY b",
          "1781:         HAVING (SELECT COUNT()OVER() + lead(b)OVER(ORDER BY SUM(DISTINCT b) + b))",
          "1782:       )",
          "1783:     FROM a",
          "1784:   UNION",
          "1785:    SELECT 99",
          "1786:     ORDER BY 1;",
          "1787: } {99}",
          "1789: #------------------------------------------------------------------------",
          "1790: reset_db",
          "1791: do_execsql_test 56.1 {",
          "1792:   CREATE TABLE t1(a, b INTEGER);",
          "1793:   CREATE TABLE t2(c, d);",
          "1794: }",
          "1795: do_catchsql_test 56.2 {",
          "1796:   SELECT avg(b) FROM t1",
          "1797:     UNION ALL",
          "1798:   SELECT min(c) OVER () FROM t2",
          "1799:   ORDER BY nosuchcolumn;",
          "1800: } {1 {1st ORDER BY term does not match any column in the result set}}",
          "1802: reset_db",
          "1803: do_execsql_test 57.1 {",
          "1804:   CREATE TABLE t4(a, b, c, d, e);",
          "1805: }",
          "1807: do_catchsql_test 57.2  {",
          "1808:   SELECT b FROM t4",
          "1809:   UNION",
          "1810:   SELECT a FROM t4",
          "1811:   ORDER BY (",
          "1812:     SELECT sum(x) OVER() FROM (",
          "1813:       SELECT c AS x FROM t4",
          "1814:       UNION",
          "1815:       SELECT d FROM t4",
          "1816:       ORDER BY (SELECT e FROM t4)",
          "1817:     )",
          "1818:   );",
          "1819: } {1 {1st ORDER BY term does not match any column in the result set}}",
          "1821: # 2020-06-06 various dbsqlfuzz finds and",
          "1822: # ticket 0899cf62f597d7e7",
          "1823: #",
          "1824: reset_db",
          "1825: do_execsql_test 57.1 {",
          "1826:   CREATE TABLE t1(a, b, c);",
          "1827:   INSERT INTO t1 VALUES(NULL,NULL,NULL);",
          "1828:   SELECT",
          "1829:     sum(a),",
          "1830:     min(b) OVER (),",
          "1831:     count(c) OVER (ORDER BY b)",
          "1832:   FROM t1;",
          "1833: } {{} {} 0}",
          "1834: do_execsql_test 57.2 {",
          "1835:   CREATE TABLE v0 ( v1 INTEGER PRIMARY KEY ) ;",
          "1836:   INSERT INTO v0 VALUES ( 10 ) ;",
          "1837:   SELECT DISTINCT v1, lead(v1) OVER() FROM v0 GROUP BY v1 ORDER BY 2;",
          "1838: } {10 {}}",
          "1839: do_catchsql_test 57.3 {",
          "1840:   DROP TABLE t1;",
          "1841:   CREATE TABLE t1(a);",
          "1842:   INSERT INTO t1(a) VALUES(22);",
          "1843:   CREATE TABLE t3(y);",
          "1844:   INSERT INTO t3(y) VALUES(5),(11),(-9);",
          "1845:   SELECT (",
          "1846:     SELECT max(y) OVER( ORDER BY (SELECT x FROM (SELECT sum(y) AS x FROM t1)))",
          "1847:   )",
          "1848:   FROM t3;",
          "1849: } {1 {misuse of aggregate: sum()}}",
          "1851: # 2020-06-06 ticket 1f6f353b684fc708",
          "1852: reset_db",
          "1853: do_execsql_test 58.1 {",
          "1854:   CREATE TABLE a(a, b, c);",
          "1855:   INSERT INTO a VALUES(1, 2, 3);",
          "1856:   INSERT INTO a VALUES(4, 5, 6);",
          "1857:   SELECT sum(345+b)      OVER (ORDER BY b),",
          "1858:          sum(avg(678)) OVER (ORDER BY c) FROM a;",
          "1859: } {347 678.0}",
          "1861: # 2020-06-06 ticket e5504e987e419fb0",
          "1862: do_catchsql_test 59.1 {",
          "1863:   DROP TABLE IF EXISTS t1;",
          "1864:   CREATE TABLE t1(x INTEGER PRIMARY KEY);",
          "1865:   INSERT INTO t1 VALUES (123);",
          "1866:   SELECT",
          "1867:      ntile( (SELECT sum(x)) ) OVER(ORDER BY x),",
          "1868:      min(x) OVER(ORDER BY x)",
          "1869:     FROM t1;",
          "1870: } {1 {misuse of aggregate: sum()}}",
          "1872: # 2020-06-07 ticket f7d890858f361402",
          "1873: do_execsql_test 60.1 {",
          "1874:   DROP TABLE IF EXISTS t1;",
          "1875:   CREATE TABLE t1 (x INTEGER PRIMARY KEY);",
          "1876:   INSERT INTO t1 VALUES (99);",
          "1877:   SELECT EXISTS(SELECT count(*) OVER() FROM t1 ORDER BY sum(x) OVER());",
          "1878: } {1}",
          "1880: reset_db",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2e22579dea165f11a1dad802c23e96022307f302",
      "candidate_info": {
        "commit_hash": "2e22579dea165f11a1dad802c23e96022307f302",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/2e22579dea165f11a1dad802c23e96022307f302",
        "files": [
          "ext/misc/fossildelta.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Fix the fossildelta.c extension so that it will compile on mingw.\n\nFossilOrigin-Name: 20237d5dc4451f142b511e50a4acef4574cef17b9222c87dcebfe1ed1bab0ad9",
        "before_after_code_files": [
          "ext/misc/fossildelta.c||ext/misc/fossildelta.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/fossildelta.c||ext/misc/fossildelta.c": [
          "File: ext/misc/fossildelta.c -> ext/misc/fossildelta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1071:   char **pzErrMsg,",
          "1072:   const sqlite3_api_routines *pApi",
          "1073: ){",
          "1075:   int rc = SQLITE_OK;",
          "1076:   SQLITE_EXTENSION_INIT2(pApi);",
          "",
          "[Removed Lines]",
          "1074:   static const enc = SQLITE_UTF8|SQLITE_INNOCUOUS;",
          "",
          "[Added Lines]",
          "1074:   static const int enc = SQLITE_UTF8|SQLITE_INNOCUOUS;",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 5720924cb07766cd54fb042da58f4b4acf12b60029fba86a23a606ad0d0f7c68",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20cee7d0bb8f627c3952f24a5c4772f8fbb4d720",
      "candidate_info": {
        "commit_hash": "20cee7d0bb8f627c3952f24a5c4772f8fbb4d720",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/20cee7d0bb8f627c3952f24a5c4772f8fbb4d720",
        "files": [
          "ext/misc/totype.c",
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/resolve.c",
          "src/sqliteInt.h",
          "src/vdbeaux.c",
          "test/check.test",
          "test/date2.test",
          "test/indexexpr1.test"
        ],
        "message": "Always disallow the use of non-deterministic functions in CHECK constraints, even date/time functions that use the 'now' or similar keywords.  Provide improved error messages when this requirement is not met. Ticket [830277d9db6c3ba1]\n\nFossilOrigin-Name: 2978b65ebe25eeabe543b67cb266308cceb20082a4ae71565d6d083d7c08bc9f",
        "before_after_code_files": [
          "ext/misc/totype.c||ext/misc/totype.c",
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/resolve.c||src/resolve.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/vdbeaux.c||src/vdbeaux.c",
          "test/check.test||test/check.test",
          "test/date2.test||test/date2.test",
          "test/indexexpr1.test||test/indexexpr1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/totype.c||ext/misc/totype.c": [
          "File: ext/misc/totype.c -> ext/misc/totype.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "502:   int rc = SQLITE_OK;",
          "503:   SQLITE_EXTENSION_INIT2(pApi);",
          "507:   if( rc==SQLITE_OK ){",
          "510:   }",
          "511:   return rc;",
          "512: }",
          "",
          "[Removed Lines]",
          "505:   rc = sqlite3_create_function(db, \"tointeger\", 1, SQLITE_UTF8, 0,",
          "506:                                tointegerFunc, 0, 0);",
          "508:     rc = sqlite3_create_function(db, \"toreal\", 1, SQLITE_UTF8, 0,",
          "509:                                  torealFunc, 0, 0);",
          "",
          "[Added Lines]",
          "505:   rc = sqlite3_create_function(db, \"tointeger\", 1,",
          "506:         SQLITE_UTF8 | SQLITE_DETERMINISTIC, 0,",
          "507:         tointegerFunc, 0, 0);",
          "509:     rc = sqlite3_create_function(db, \"toreal\", 1,",
          "510:         SQLITE_UTF8 | SQLITE_DETERMINISTIC, 0,",
          "511:         torealFunc, 0, 0);",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 84e02d773d60cffe619104991d21d7f0c68616c0f6bb99686bf54f5306c756d0",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4033: #endif",
          "4034:       {",
          "4035:         sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,",
          "4037:       }",
          "4038:       if( nFarg && constMask==0 ){",
          "4039:         sqlite3ReleaseTempRange(pParse, r1, nFarg);",
          "",
          "[Removed Lines]",
          "4036:                                    pDef, pParse->iSelfTab);",
          "",
          "[Added Lines]",
          "4036:                                    pDef, pExpr->op2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5028:      && (combinedFlags & EP_Reduced)==0",
          "5029:     ){",
          "5030:       if( pA->iColumn!=pB->iColumn ) return 2;",
          "5032:       if( pA->op!=TK_IN && pA->iTable!=pB->iTable && pA->iTable!=iTab ){",
          "5033:         return 2;",
          "5034:       }",
          "",
          "[Removed Lines]",
          "5031:       if( pA->op2!=pB->op2 ) return 2;",
          "",
          "[Added Lines]",
          "5031:       if( pA->op2!=pB->op2 && (pA->op!=TK_FUNCTION || iTab<0) ) return 2;",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "815:         if( pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG) ){",
          "819:           ExprSetProperty(pExpr,EP_ConstFunc);",
          "820:         }",
          "821:         if( (pDef->funcFlags & SQLITE_FUNC_CONSTANT)==0 ){",
          "827:         }",
          "828:         if( (pDef->funcFlags & SQLITE_FUNC_INTERNAL)!=0",
          "829:          && pParse->nested==0",
          "",
          "[Removed Lines]",
          "825:           notValid(pParse, pNC, \"non-deterministic functions\",",
          "826:                    NC_IdxExpr|NC_PartIdx|NC_GenCol);",
          "",
          "[Added Lines]",
          "826:           notValid(pParse, pNC, \"non-deterministic functions\", NC_SelfRef);",
          "827:         }else{",
          "829:           pExpr->op2 = pNC->ncFlags & NC_SelfRef;",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2487: struct Expr {",
          "2491:   union {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2490:   u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2532:   union {",
          "2533:     Table *pTab;           /* TK_COLUMN: Table containing column. Can be NULL",
          "",
          "[Removed Lines]",
          "2528:   u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "365:   }",
          "366:   pCtx->pOut = 0;",
          "367:   pCtx->pFunc = (FuncDef*)pFunc;",
          "369:   pCtx->isError = 0;",
          "370:   pCtx->argc = nArg;",
          "371:   addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,",
          "372:                            p1, p2, p3, (char*)pCtx, P4_FUNCCTX);",
          "373:   pCtx->iOp = addr;",
          "374:   return addr;",
          "375: }",
          "",
          "[Removed Lines]",
          "368:   pCtx->pVdbe = v;",
          "",
          "[Added Lines]",
          "368:   pCtx->pVdbe = 0;",
          "373:   sqlite3VdbeChangeP5(v, eCallCtx & NC_SelfRef);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5001: int sqlite3NotPureFunc(sqlite3_context *pCtx){",
          "5002: #ifdef SQLITE_ENABLE_STAT4",
          "5003:   if( pCtx->pVdbe==0 ) return 1;",
          "5004: #endif",
          "5010:     sqlite3_result_error(pCtx, zMsg, -1);",
          "5011:     sqlite3_free(zMsg);",
          "5017:     return 0;",
          "5018:   }",
          "5019:   return 1;",
          "",
          "[Removed Lines]",
          "5005:   if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==OP_PureFunc ){",
          "5006: #if 0",
          "5007:     char *zMsg = sqlite3_mprintf(",
          "5008:        \"non-deterministic use of %s() in an index, CHECK constraint, \"",
          "5009:        \"or generated column\", pCtx->pFunc->zName);",
          "5012: #else",
          "5013:     sqlite3_result_error(pCtx,",
          "5014:        \"non-deterministic function in index expression or CHECK constraint\",",
          "5015:        -1);",
          "5016: #endif",
          "",
          "[Added Lines]",
          "5003:   const VdbeOp *pOp;",
          "5007:   pOp = pCtx->pVdbe->aOp + pCtx->iOp;",
          "5008:   if( pOp->opcode==OP_PureFunc ){",
          "5009:     const char *zContext;",
          "5010:     char *zMsg;",
          "5011:     if( pOp->p5 & NC_IsCheck ){",
          "5012:       zContext = \"a CHECK constraint\";",
          "5013:     }else if( pOp->p5 & NC_GenCol ){",
          "5014:       zContext = \"a generated column\";",
          "5015:     }else{",
          "5016:       zContext = \"an index\";",
          "5017:     }",
          "5018:     zMsg = sqlite3_mprintf(\"non-deterministic use of %s() in %s\",",
          "5019:                            pCtx->pFunc->zName, zContext);",
          "",
          "---------------"
        ],
        "test/check.test||test/check.test": [
          "File: test/check.test -> test/check.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "442: #",
          "443: reset_db",
          "444: proc myfunc {x} {expr $x < 10}",
          "447: do_execsql_test  7.1 { CREATE TABLE t6(a CHECK (myfunc(a))) }",
          "448: do_execsql_test  7.2 { INSERT INTO t6 VALUES(9)  }",
          "",
          "[Removed Lines]",
          "445: db func myfunc myfunc",
          "",
          "[Added Lines]",
          "445: db func myfunc -deterministic myfunc",
          "",
          "---------------"
        ],
        "test/date2.test||test/date2.test": [
          "File: test/date2.test -> test/date2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: } {}",
          "31: do_catchsql_test date2-110 {",
          "32:   INSERT INTO t1(x,y) VALUES('now','two');",
          "34: do_execsql_test date2-120 {",
          "35:   SELECT * FROM t1;",
          "36: } {2017-07-20 one}",
          "",
          "[Removed Lines]",
          "33: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "33: } {1 {non-deterministic use of date() in a CHECK constraint}}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45: }",
          "46: do_catchsql_test date2-210 {",
          "47:   INSERT INTO t2(x,y) VALUES(3, 'now');",
          "49: do_execsql_test date2-220 {",
          "50:   SELECT x, y FROM t2 ORDER BY x;",
          "51: } {1 2017-07-20 2 xyzzy}",
          "",
          "[Removed Lines]",
          "48: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "48: } {1 {non-deterministic use of date() in an index}}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "58: }",
          "59: do_catchsql_test date2-310 {",
          "60:   CREATE INDEX t3b1 ON t3(datetime(b));",
          "62: do_catchsql_test date2-320 {",
          "63:   CREATE INDEX t3b1 ON t3(datetime(b)) WHERE typeof(b)='real';",
          "64: } {0 {}}",
          "",
          "[Removed Lines]",
          "61: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "61: } {1 {non-deterministic use of datetime() in an index}}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "84: do_catchsql_test date2-410 {",
          "85:   CREATE INDEX t4b1 ON t4(b)",
          "86:     WHERE date(b) BETWEEN '2017-06-01' AND '2017-08-31';",
          "88: do_execsql_test date2-420 {",
          "89:   DELETE FROM t4 WHERE a=500;",
          "90:   CREATE INDEX t4b1 ON t4(b)",
          "",
          "[Removed Lines]",
          "87: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "87: } {1 {non-deterministic use of date() in an index}}",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "92: }",
          "93: do_catchsql_test date2-430 {",
          "94:   INSERT INTO t4(a,b) VALUES(9999,'now');",
          "97: do_execsql_test date2-500 {",
          "98:   CREATE TABLE mods(x);",
          "",
          "[Removed Lines]",
          "95: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "95: } {1 {non-deterministic use of date() in an index}}",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "121: }",
          "122: do_catchsql_test date2-510 {",
          "123:   INSERT INTO t5(y,m) VALUES('2017-07-20','localtime');",
          "125: do_catchsql_test date2-520 {",
          "126:   INSERT INTO t5(y,m) VALUES('2017-07-20','utc');",
          "134: finish_test",
          "",
          "[Removed Lines]",
          "124: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "127: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "124: } {1 {non-deterministic use of datetime() in an index}}",
          "127: } {1 {non-deterministic use of datetime() in an index}}",
          "129: # 2019-10-30 Ticket 830277d9db6c3ba1",
          "130: #",
          "131: do_catchsql_test date2-600 {",
          "132:   CREATE TABLE t600(a REAL CHECK( a<julianday('now') ));",
          "133:   INSERT INTO t600(a) VALUES(1.0);",
          "134: } {1 {non-deterministic use of julianday() in a CHECK constraint}}",
          "135: do_catchsql_test date2-601 {",
          "136:   CREATE TABLE t601(a REAL, b TEXT, CHECK( a<julianday(b) ));",
          "137:   INSERT INTO t601(a,b) VALUES(1.0, '1970-01-01');",
          "138: } {0 {}}",
          "139: do_catchsql_test date2-602 {",
          "140:   INSERT INTO t601(a,b) VALUES(1e100, '1970-01-01');",
          "141: } {1 {CHECK constraint failed: t601}}",
          "142: do_catchsql_test date2-603 {",
          "143:   INSERT INTO t601(a,b) VALUES(10, 'now');",
          "144: } {1 {non-deterministic use of julianday() in a CHECK constraint}}",
          "145: do_catchsql_test date2-604 {",
          "146:   INSERT INTO t600(a) VALUES(julianday('now')+10);",
          "147: } {1 {non-deterministic use of julianday() in a CHECK constraint}}",
          "150: do_catchsql_test date2-610 {",
          "151:   CREATE TABLE t610(a,b);",
          "152:   CREATE INDEX t610x1 ON t610(julianday('now')+b);",
          "153:   INSERT INTO t610(a,b) VALUES(123,456);",
          "154: } {1 {non-deterministic use of julianday() in an index}}",
          "155: do_catchsql_test date2-611 {",
          "156:   CREATE TABLE t611(a,b);",
          "157:   CREATE INDEX t611x1 ON t611(julianday(a)+b);",
          "158:   INSERT INTO t611(a,b) VALUES('1970-01-01',10.0);",
          "159: } {0 {}}",
          "160: do_catchsql_test date2-612 {",
          "161:   INSERT INTO t611(a,b) VALUES('now',10.0);",
          "162: } {1 {non-deterministic use of julianday() in an index}}",
          "164: do_catchsql_test date3-620 {",
          "165:   CREATE TABLE t620(a, b AS (a+julianday('now')));",
          "166:   INSERT INTO t620 VALUES(10);",
          "167: } {1 {non-deterministic use of julianday() in a generated column}}",
          "",
          "---------------"
        ],
        "test/indexexpr1.test||test/indexexpr1.test": [
          "File: test/indexexpr1.test -> test/indexexpr1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "186: } {1 {non-deterministic functions prohibited in index expressions}}",
          "187: do_catchsql_test indexexpr1-301 {",
          "188:   CREATE INDEX t2x1 ON t2(julianday('now',a));",
          "190: do_catchsql_test indexexpr1-310 {",
          "191:   CREATE INDEX t2x2 ON t2(a,b+(SELECT 15));",
          "192: } {1 {subqueries prohibited in index expressions}}",
          "",
          "[Removed Lines]",
          "189: } {1 {non-deterministic function in index expression or CHECK constraint}}",
          "",
          "[Added Lines]",
          "189: } {1 {non-deterministic use of julianday() in an index}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "340558540e4799bbcb00ab901c327d5000054920",
      "candidate_info": {
        "commit_hash": "340558540e4799bbcb00ab901c327d5000054920",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/340558540e4799bbcb00ab901c327d5000054920",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/select.c",
          "test/with1.test",
          "test/with3.test",
          "test/with5.test"
        ],
        "message": "Allow multiple recursive terms in the compound SELECT of a recursive CTE. This facilitates writing a query to find find the connected components of an undirected graph.\n\nFossilOrigin-Name: 5481fa8c79c34f434e99ab633ff3d0942a309a74fb0cf38e3d3617b51d5d21dd",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/select.c||src/select.c",
          "test/with1.test||test/with1.test",
          "test/with3.test||test/with3.test",
          "test/with5.test||test/with5.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: d6fac8a1d3efeb2c4f03dae437b5b314765c93770a70603803a8039291dbcabb",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4460:   assert(pList || pParse->db->mallocFailed );",
          "4461:   if( pList ){",
          "4462:     for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){",
          "4464:       pItem->iCursor = pParse->nTab++;",
          "4465:       if( pItem->pSelect ){",
          "4466:         sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);",
          "",
          "[Removed Lines]",
          "4463:       if( pItem->iCursor>=0 ) break;",
          "",
          "[Added Lines]",
          "4463:       if( pItem->iCursor>=0 ) continue;",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2416:   p->pOrderBy = 0;",
          "2419:   pSetup->pNext = 0;",
          "2420:   ExplainQueryPlan((pParse, 1, \"SETUP\"));",
          "2421:   rc = sqlite3Select(pParse, pSetup, &destQueue);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2426:   pFirstRec = p;",
          "2427:   for(pFirstRec=p; ALWAYS(pFirstRec!=0); pFirstRec=pFirstRec->pPrior){",
          "2428:     if( pFirstRec->selFlags & SF_Aggregate ){",
          "2429:       sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");",
          "2430:       goto end_of_recursive_query;",
          "2431:     }",
          "2432:     pFirstRec->op = TK_ALL;",
          "2433:     if( (pFirstRec->pPrior->selFlags & SF_Recursive)==0 ) break;",
          "2434:   }",
          "2437:   pSetup = pFirstRec->pPrior;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2462:   sqlite3VdbeGoto(v, addrTop);",
          "",
          "[Removed Lines]",
          "2451:   if( p->selFlags & SF_Aggregate ){",
          "2452:     sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");",
          "2453:   }else{",
          "2454:     p->pPrior = 0;",
          "2455:     ExplainQueryPlan((pParse, 1, \"RECURSIVE STEP\"));",
          "2456:     sqlite3Select(pParse, p, &destQueue);",
          "2457:     assert( p->pPrior==0 );",
          "2458:     p->pPrior = pSetup;",
          "2459:   }",
          "",
          "[Added Lines]",
          "2470:   pFirstRec->pPrior = 0;",
          "2471:   ExplainQueryPlan((pParse, 1, \"RECURSIVE STEP\"));",
          "2472:   sqlite3Select(pParse, p, &destQueue);",
          "2473:   assert( pFirstRec->pPrior==0 );",
          "2474:   pFirstRec->pPrior = pSetup;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2525:   return rc;",
          "2526: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2548: static int hasAnchor(Select *p){",
          "2549:   while( p && (p->selFlags & SF_Recursive)!=0 ){ p = p->pPrior; }",
          "2550:   return p!=0;",
          "2551: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2610:   assert( p->pEList->nExpr==pPrior->pEList->nExpr );",
          "2612: #ifndef SQLITE_OMIT_CTE",
          "2614:     generateWithRecursiveQuery(pParse, p, &dest);",
          "2615:   }else",
          "2616: #endif",
          "",
          "[Removed Lines]",
          "2613:   if( p->selFlags & SF_Recursive ){",
          "",
          "[Added Lines]",
          "2638:   if( (p->selFlags & SF_Recursive)!=0 && hasAnchor(p) ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4820:     assert( pFrom->pSelect );",
          "4824:     bMayRecursive = ( pSel->op==TK_ALL || pSel->op==TK_UNION );",
          "4826:       int i;",
          "4828:       for(i=0; i<pSrc->nSrc; i++){",
          "4829:         struct SrcList_item *pItem = &pSrc->a[i];",
          "4830:         if( pItem->zDatabase==0",
          "4831:          && pItem->zName!=0",
          "4832:          && 0==sqlite3StrICmp(pItem->zName, pCte->zName)",
          "4834:           pItem->pTab = pTab;",
          "4835:           pItem->fg.isRecursive = 1;",
          "4836:           pTab->nTabRef++;",
          "4838:         }",
          "4839:       }",
          "4840:     }",
          "4852:     pCte->zCteErr = \"circular reference: %s\";",
          "4853:     pSavedWith = pParse->pWith;",
          "4854:     pParse->pWith = pWith;",
          "4861:     }else{",
          "4862:       sqlite3WalkSelect(pWalker, pSel);",
          "4863:     }",
          "",
          "[Removed Lines]",
          "4823:     pSel = pFrom->pSelect;",
          "4825:     if( bMayRecursive ){",
          "4827:       SrcList *pSrc = pFrom->pSelect->pSrc;",
          "4833:           ){",
          "4837:           pSel->selFlags |= SF_Recursive;",
          "4843:     if( pTab->nTabRef>2 ){",
          "4844:       sqlite3ErrorMsg(",
          "4845:           pParse, \"multiple references to recursive table: %s\", pCte->zName",
          "4846:       );",
          "4847:       return SQLITE_ERROR;",
          "4848:     }",
          "4849:     assert( pTab->nTabRef==1 ||",
          "4850:             ((pSel->selFlags&SF_Recursive) && pTab->nTabRef==2 ));",
          "4855:     if( bMayRecursive ){",
          "4856:       Select *pPrior = pSel->pPrior;",
          "4857:       assert( pPrior->pWith==0 );",
          "4858:       pPrior->pWith = pSel->pWith;",
          "4859:       sqlite3WalkSelect(pWalker, pPrior);",
          "4860:       pPrior->pWith = 0;",
          "",
          "[Added Lines]",
          "4851:     pRecTerm = pSel = pFrom->pSelect;",
          "4853:     while( bMayRecursive && pRecTerm->op==pSel->op ){",
          "4855:       SrcList *pSrc = pRecTerm->pSrc;",
          "4856:       assert( pRecTerm->pPrior!=0 );",
          "4862:         ){",
          "4865:           if( pRecTerm->selFlags & SF_Recursive ){",
          "4866:             sqlite3ErrorMsg(pParse,",
          "4867:                \"multiple references to recursive table: %s\", pCte->zName",
          "4868:             );",
          "4869:             return SQLITE_ERROR;",
          "4870:           }",
          "4872:           pRecTerm->selFlags |= SF_Recursive;",
          "4873:           if( iRecTab<0 ) iRecTab = pParse->nTab++;",
          "4874:           pItem->iCursor = iRecTab;",
          "4877:       if( (pRecTerm->selFlags & SF_Recursive)==0 ) break;",
          "4878:       pRecTerm = pRecTerm->pPrior;",
          "4884:     if( pSel->selFlags & SF_Recursive ){",
          "4885:       assert( pRecTerm!=0 );",
          "4886:       assert( (pRecTerm->selFlags & SF_Recursive)==0 );",
          "4887:       assert( pRecTerm->pNext!=0 );",
          "4888:       assert( (pRecTerm->pNext->selFlags & SF_Recursive)!=0 );",
          "4889:       assert( pRecTerm->pWith==0 );",
          "4890:       pRecTerm->pWith = pSel->pWith;",
          "4891:       sqlite3WalkSelect(pWalker, pRecTerm);",
          "4892:       pRecTerm->pWith = 0;",
          "",
          "---------------"
        ],
        "test/with1.test||test/with1.test": [
          "File: test/with1.test -> test/with1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "352:     SELECT i FROM tree WHERE p IN (SELECT id FROM t)",
          "353:   )",
          "354:   SELECT id FROM t;",
          "357: do_catchsql_test 7.5 {",
          "358:   WITH t(id) AS (",
          "",
          "[Removed Lines]",
          "355: } {1 {recursive reference in a subquery: t}}",
          "",
          "[Added Lines]",
          "355: } {1 {circular reference: t}}",
          "",
          "---------------"
        ],
        "test/with3.test||test/with3.test": [
          "File: test/with3.test -> test/with3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:     SELECT 5 FROM t0 UNION SELECT 8 FROM m",
          "31:   )",
          "32:   SELECT * FROM i;",
          "35: # 2019-11-09 dbfuzzcheck find",
          "36: do_catchsql_test 1.1 {",
          "",
          "[Removed Lines]",
          "33: } {1 {no such table: t0}}",
          "",
          "[Added Lines]",
          "33: } {1 {no such table: m}}",
          "",
          "---------------"
        ],
        "test/with5.test||test/with5.test": [
          "File: test/with5.test -> test/with5.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020-10-19",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this file is recursive common table expressions with",
          "13: # multiple recursive terms in the compound select.",
          "14: #",
          "16: set testdir [file dirname $argv0]",
          "17: source $testdir/tester.tcl",
          "18: set ::testprefix with5",
          "20: ifcapable {!cte} {",
          "21:   finish_test",
          "22:   return",
          "23: }",
          "25: do_execsql_test 100 {",
          "26:   CREATE TABLE link(aa INT, bb INT);",
          "27:   CREATE INDEX link_f ON link(aa,bb);",
          "28:   CREATE INDEX link_t ON link(bb,aa);",
          "29:   INSERT INTO link(aa,bb) VALUES",
          "30:     (1,3),",
          "31:     (5,3),",
          "32:     (7,1),",
          "33:     (7,9),",
          "34:     (9,9),",
          "35:     (5,11),",
          "36:     (11,7),",
          "37:     (2,4),",
          "38:     (4,6),",
          "39:     (8,6);",
          "40: } {}",
          "41: do_execsql_test 110 {",
          "42:   WITH RECURSIVE closure(x) AS (",
          "43:      VALUES(1)",
          "44:      UNION",
          "45:      SELECT aa FROM closure, link WHERE link.bb=closure.x",
          "46:      UNION",
          "47:      SELECT bb FROM closure, link WHERE link.aa=closure.x",
          "48:   )",
          "49:   SELECT x FROM closure ORDER BY x;",
          "50: } {1 3 5 7 9 11}",
          "51: do_execsql_test 111 {",
          "52:   WITH RECURSIVE closure(x) AS (",
          "53:      VALUES(1)",
          "54:      UNION",
          "55:      SELECT aa FROM link, closure WHERE link.bb=closure.x",
          "56:      UNION",
          "57:      SELECT bb FROM closure, link WHERE link.aa=closure.x",
          "58:   )",
          "59:   SELECT x FROM closure ORDER BY x;",
          "60: } {1 3 5 7 9 11}",
          "61: do_execsql_test 112 {",
          "62:   WITH RECURSIVE closure(x) AS (",
          "63:      VALUES(1)",
          "64:      UNION",
          "65:      SELECT bb FROM closure, link WHERE link.aa=closure.x",
          "66:      UNION",
          "67:      SELECT aa FROM link, closure WHERE link.bb=closure.x",
          "68:   )",
          "69:   SELECT x FROM closure ORDER BY x;",
          "70: } {1 3 5 7 9 11}",
          "71: do_execsql_test 113 {",
          "72:   WITH RECURSIVE closure(x) AS (",
          "73:      VALUES(1),(200),(300),(400)",
          "74:      INTERSECT",
          "75:      VALUES(1)",
          "76:      UNION",
          "77:      SELECT bb FROM closure, link WHERE link.aa=closure.x",
          "78:      UNION",
          "79:      SELECT aa FROM link, closure WHERE link.bb=closure.x",
          "80:   )",
          "81:   SELECT x FROM closure ORDER BY x;",
          "82: } {1 3 5 7 9 11}",
          "83: do_execsql_test 114 {",
          "84:   WITH RECURSIVE closure(x) AS (",
          "85:      VALUES(1),(200),(300),(400)",
          "86:      UNION ALL",
          "87:      VALUES(2)",
          "88:      UNION",
          "89:      SELECT bb FROM closure, link WHERE link.aa=closure.x",
          "90:      UNION",
          "91:      SELECT aa FROM link, closure WHERE link.bb=closure.x",
          "92:   )",
          "93:   SELECT x FROM closure ORDER BY x;",
          "94: } {1 2 3 4 5 6 7 8 9 11 200 300 400}",
          "96: finish_test",
          "",
          "---------------"
        ]
      }
    }
  ]
}
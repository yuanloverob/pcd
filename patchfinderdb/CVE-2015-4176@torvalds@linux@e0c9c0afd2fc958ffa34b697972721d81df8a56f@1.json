{
  "cve_id": "CVE-2015-4176",
  "cve_desc": "fs/namespace.c in the Linux kernel before 4.0.2 does not properly support mount connectivity, which allows local users to read arbitrary files by leveraging user-namespace root access for deletion of a file or directory.",
  "repo": "torvalds/linux",
  "patch_hash": "e0c9c0afd2fc958ffa34b697972721d81df8a56f",
  "patch_info": {
    "commit_hash": "e0c9c0afd2fc958ffa34b697972721d81df8a56f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e0c9c0afd2fc958ffa34b697972721d81df8a56f",
    "files": [
      "fs/namespace.c"
    ],
    "message": "mnt: Update detach_mounts to leave mounts connected\n\nNow that it is possible to lazily unmount an entire mount tree and\nleave the individual mounts connected to each other add a new flag\nUMOUNT_CONNECTED to umount_tree to force this behavior and use\nthis flag in detach_mounts.\n\nThis closes a bug where the deletion of a file or directory could\ntrigger an unmount and reveal data under a mount point.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "fs/namespace.c||fs/namespace.c"
    ]
  },
  "patch_diff": {
    "fs/namespace.c||fs/namespace.c": [
      "File: fs/namespace.c -> fs/namespace.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1348: enum umount_tree_flags {",
      "1349:  UMOUNT_SYNC = 1,",
      "1350:  UMOUNT_PROPAGATE = 2,",
      "1351: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1351:  UMOUNT_CONNECTED = 4,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1386:   if (how & UMOUNT_SYNC)",
      "1387:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
      "1391:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
      "1392:      disconnect ? &unmounted : NULL);",
      "",
      "[Removed Lines]",
      "1389:   disconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
      "",
      "[Added Lines]",
      "1390:   disconnect = !(((how & UMOUNT_CONNECTED) &&",
      "1391:     mnt_has_parent(p) &&",
      "1392:     (p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||",
      "1393:           IS_MNT_LOCKED_AND_LAZY(p));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1529:     umount_mnt(p);",
      "1530:    }",
      "1531:   }",
      "1533:  }",
      "1534:  unlock_mount_hash();",
      "1535:  put_mountpoint(mp);",
      "",
      "[Removed Lines]",
      "1532:   else umount_tree(mnt, 0);",
      "",
      "[Added Lines]",
      "1536:   else umount_tree(mnt, UMOUNT_CONNECTED);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8318e667f176f7ea34451a1a530634e293f216ac",
      "candidate_info": {
        "commit_hash": "8318e667f176f7ea34451a1a530634e293f216ac",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8318e667f176f7ea34451a1a530634e293f216ac",
        "files": [
          "fs/namespace.c"
        ],
        "message": "mnt: Don't propagate umounts in __detach_mounts\n\nInvoking mount propagation from __detach_mounts is inefficient and\nwrong.\n\nIt is inefficient because __detach_mounts already walks the list of\nmounts that where something needs to be done, and mount propagation\nwalks some subset of those mounts again.\n\nIt is actively wrong because if the dentry that is passed to\n__detach_mounts is not part of the path to a mount that mount should\nnot be affected.\n\nchange_mnt_propagation(p,MS_PRIVATE) modifies the mount propagation\ntree of a master mount so it's slaves are connected to another master\nif possible.  Which means even removing a mount from the middle of a\nmount tree with __detach_mounts will not deprive any mount propagated\nmount events.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1485:  lock_mount_hash();",
          "1486:  while (!hlist_empty(&mp->m_list)) {",
          "1487:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
          "1489:  }",
          "1490:  unlock_mount_hash();",
          "1491:  put_mountpoint(mp);",
          "",
          "[Removed Lines]",
          "1488:   umount_tree(mnt, UMOUNT_PROPAGATE);",
          "",
          "[Added Lines]",
          "1488:   umount_tree(mnt, 0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
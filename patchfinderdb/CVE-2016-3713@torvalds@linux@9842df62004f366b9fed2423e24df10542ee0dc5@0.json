{
  "cve_id": "CVE-2016-3713",
  "cve_desc": "The msr_mtrr_valid function in arch/x86/kvm/mtrr.c in the Linux kernel before 4.6.1 supports MSR 0x2f8, which allows guest OS users to read or write to the kvm_arch_vcpu data structure, and consequently obtain sensitive information or cause a denial of service (system crash), via a crafted ioctl call.",
  "repo": "torvalds/linux",
  "patch_hash": "9842df62004f366b9fed2423e24df10542ee0dc5",
  "patch_info": {
    "commit_hash": "9842df62004f366b9fed2423e24df10542ee0dc5",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/9842df62004f366b9fed2423e24df10542ee0dc5",
    "files": [
      "arch/x86/kvm/mtrr.c"
    ],
    "message": "KVM: MTRR: remove MSR 0x2f8\n\nMSR 0x2f8 accessed the 124th Variable Range MTRR ever since MTRR support\nwas introduced by 9ba075a664df (\"KVM: MTRR support\").\n\n0x2f8 became harmful when 910a6aae4e2e (\"KVM: MTRR: exactly define the\nsize of variable MTRRs\") shrinked the array of VR MTRRs from 256 to 8,\nwhich made access to index 124 out of bounds.  The surrounding code only\nWARNs in this situation, thus the guest gained a limited read/write\naccess to struct kvm_arch_vcpu.\n\n0x2f8 is not a valid VR MTRR MSR, because KVM has/advertises only 16 VR\nMTRR MSRs, 0x200-0x20f.  Every VR MTRR is set up using two MSRs, 0x2f8\nwas treated as a PHYSBASE and 0x2f9 would be its PHYSMASK, but 0x2f9 was\nnot implemented in KVM, therefore 0x2f8 could never do anything useful\nand getting rid of it is safe.\n\nThis fixes CVE-2016-3713.\n\nFixes: 910a6aae4e2e (\"KVM: MTRR: exactly define the size of variable MTRRs\")\nCc: stable@vger.kernel.org\nReported-by: David Matlack <dmatlack@google.com>\nSigned-off-by: Andy Honig <ahonig@google.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/mtrr.c||arch/x86/kvm/mtrr.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/mtrr.c||arch/x86/kvm/mtrr.c": [
      "File: arch/x86/kvm/mtrr.c -> arch/x86/kvm/mtrr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "44:  case MSR_MTRRdefType:",
      "45:  case MSR_IA32_CR_PAT:",
      "46:   return true;",
      "49:  }",
      "50:  return false;",
      "51: }",
      "",
      "[Removed Lines]",
      "47:  case 0x2f8:",
      "48:   return true;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ff53604b40b439cbb235f89bda99839ca81d3b9d",
      "candidate_info": {
        "commit_hash": "ff53604b40b439cbb235f89bda99839ca81d3b9d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ff53604b40b439cbb235f89bda99839ca81d3b9d",
        "files": [
          "arch/x86/include/asm/kvm_host.h",
          "arch/x86/kvm/Makefile",
          "arch/x86/kvm/mmu.c",
          "arch/x86/kvm/mtrr.c",
          "arch/x86/kvm/vmx.c",
          "arch/x86/kvm/x86.c",
          "arch/x86/kvm/x86.h"
        ],
        "message": "KVM: x86: move MTRR related code to a separate file\n\nMTRR code locates in x86.c and mmu.c so that move them to a separate file to\nmake the organization more clearer and it will be the place where we fully\nimplement vMTRR\n\nSigned-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/include/asm/kvm_host.h||arch/x86/include/asm/kvm_host.h",
          "arch/x86/kvm/mmu.c||arch/x86/kvm/mmu.c",
          "arch/x86/kvm/mtrr.c||arch/x86/kvm/mtrr.c",
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c",
          "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c",
          "arch/x86/kvm/x86.h||arch/x86/kvm/x86.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/mtrr.c||arch/x86/kvm/mtrr.c"
          ],
          "candidate": [
            "arch/x86/kvm/mtrr.c||arch/x86/kvm/mtrr.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/include/asm/kvm_host.h||arch/x86/include/asm/kvm_host.h": [
          "File: arch/x86/include/asm/kvm_host.h -> arch/x86/include/asm/kvm_host.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "895: int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,",
          "896:      const void *val, int bytes);",
          "899: struct kvm_irq_mask_notifier {",
          "900:  void (*func)(struct kvm_irq_mask_notifier *kimn, bool masked);",
          "",
          "[Removed Lines]",
          "897: u8 kvm_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "arch/x86/kvm/mmu.c||arch/x86/kvm/mmu.c": [
          "File: arch/x86/kvm/mmu.c -> arch/x86/kvm/mmu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2437: }",
          "2438: EXPORT_SYMBOL_GPL(kvm_mmu_unprotect_page);",
          "2543: static void __kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)",
          "2544: {",
          "2545:  trace_kvm_mmu_unsync_page(sp);",
          "",
          "[Removed Lines]",
          "2444: static int get_mtrr_type(struct mtrr_state_type *mtrr_state,",
          "2445:     u64 start, u64 end)",
          "2446: {",
          "2447:  u64 base, mask;",
          "2448:  u8 prev_match, curr_match;",
          "2449:  int i, num_var_ranges = KVM_NR_VAR_MTRR;",
          "2452:  if (!(mtrr_state->enabled & 0x2))",
          "2453:   return MTRR_TYPE_UNCACHABLE;",
          "2456:  end--;",
          "2459:  if (mtrr_state->have_fixed && (mtrr_state->enabled & 0x1) &&",
          "2460:        (start < 0x100000)) {",
          "2461:   int idx;",
          "2463:   if (start < 0x80000) {",
          "2464:    idx = 0;",
          "2465:    idx += (start >> 16);",
          "2466:    return mtrr_state->fixed_ranges[idx];",
          "2467:   } else if (start < 0xC0000) {",
          "2468:    idx = 1 * 8;",
          "2469:    idx += ((start - 0x80000) >> 14);",
          "2470:    return mtrr_state->fixed_ranges[idx];",
          "2471:   } else if (start < 0x1000000) {",
          "2472:    idx = 3 * 8;",
          "2473:    idx += ((start - 0xC0000) >> 12);",
          "2474:    return mtrr_state->fixed_ranges[idx];",
          "2475:   }",
          "2476:  }",
          "2483:  prev_match = 0xFF;",
          "2484:  for (i = 0; i < num_var_ranges; ++i) {",
          "2485:   unsigned short start_state, end_state;",
          "2487:   if (!(mtrr_state->var_ranges[i].mask_lo & (1 << 11)))",
          "2488:    continue;",
          "2490:   base = (((u64)mtrr_state->var_ranges[i].base_hi) << 32) +",
          "2491:          (mtrr_state->var_ranges[i].base_lo & PAGE_MASK);",
          "2492:   mask = (((u64)mtrr_state->var_ranges[i].mask_hi) << 32) +",
          "2493:          (mtrr_state->var_ranges[i].mask_lo & PAGE_MASK);",
          "2495:   start_state = ((start & mask) == (base & mask));",
          "2496:   end_state = ((end & mask) == (base & mask));",
          "2497:   if (start_state != end_state)",
          "2498:    return 0xFE;",
          "2500:   if ((start & mask) != (base & mask))",
          "2501:    continue;",
          "2503:   curr_match = mtrr_state->var_ranges[i].base_lo & 0xff;",
          "2504:   if (prev_match == 0xFF) {",
          "2505:    prev_match = curr_match;",
          "2506:    continue;",
          "2507:   }",
          "2509:   if (prev_match == MTRR_TYPE_UNCACHABLE ||",
          "2510:       curr_match == MTRR_TYPE_UNCACHABLE)",
          "2511:    return MTRR_TYPE_UNCACHABLE;",
          "2513:   if ((prev_match == MTRR_TYPE_WRBACK &&",
          "2514:        curr_match == MTRR_TYPE_WRTHROUGH) ||",
          "2515:       (prev_match == MTRR_TYPE_WRTHROUGH &&",
          "2516:        curr_match == MTRR_TYPE_WRBACK)) {",
          "2517:    prev_match = MTRR_TYPE_WRTHROUGH;",
          "2518:    curr_match = MTRR_TYPE_WRTHROUGH;",
          "2519:   }",
          "2521:   if (prev_match != curr_match)",
          "2522:    return MTRR_TYPE_UNCACHABLE;",
          "2523:  }",
          "2525:  if (prev_match != 0xFF)",
          "2526:   return prev_match;",
          "2528:  return mtrr_state->def_type;",
          "2529: }",
          "2531: u8 kvm_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)",
          "2532: {",
          "2533:  u8 mtrr;",
          "2535:  mtrr = get_mtrr_type(&vcpu->arch.mtrr_state, gfn << PAGE_SHIFT,",
          "2536:         (gfn << PAGE_SHIFT) + PAGE_SIZE);",
          "2537:  if (mtrr == 0xfe || mtrr == 0xff)",
          "2538:   mtrr = MTRR_TYPE_WRBACK;",
          "2539:  return mtrr;",
          "2540: }",
          "2541: EXPORT_SYMBOL_GPL(kvm_get_guest_memory_type);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "arch/x86/kvm/mtrr.c||arch/x86/kvm/mtrr.c": [
          "File: arch/x86/kvm/mtrr.c -> arch/x86/kvm/mtrr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <linux/kvm_host.h>",
          "20: #include <asm/mtrr.h>",
          "22: #include \"cpuid.h\"",
          "23: #include \"mmu.h\"",
          "25: static bool msr_mtrr_valid(unsigned msr)",
          "26: {",
          "27:  switch (msr) {",
          "28:  case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:",
          "29:  case MSR_MTRRfix64K_00000:",
          "30:  case MSR_MTRRfix16K_80000:",
          "31:  case MSR_MTRRfix16K_A0000:",
          "32:  case MSR_MTRRfix4K_C0000:",
          "33:  case MSR_MTRRfix4K_C8000:",
          "34:  case MSR_MTRRfix4K_D0000:",
          "35:  case MSR_MTRRfix4K_D8000:",
          "36:  case MSR_MTRRfix4K_E0000:",
          "37:  case MSR_MTRRfix4K_E8000:",
          "38:  case MSR_MTRRfix4K_F0000:",
          "39:  case MSR_MTRRfix4K_F8000:",
          "40:  case MSR_MTRRdefType:",
          "41:  case MSR_IA32_CR_PAT:",
          "42:   return true;",
          "43:  case 0x2f8:",
          "44:   return true;",
          "45:  }",
          "46:  return false;",
          "47: }",
          "49: static bool valid_pat_type(unsigned t)",
          "50: {",
          "52: }",
          "54: static bool valid_mtrr_type(unsigned t)",
          "55: {",
          "57: }",
          "59: bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)",
          "60: {",
          "61:  int i;",
          "62:  u64 mask;",
          "64:  if (!msr_mtrr_valid(msr))",
          "65:   return false;",
          "67:  if (msr == MSR_IA32_CR_PAT) {",
          "68:   for (i = 0; i < 8; i++)",
          "69:    if (!valid_pat_type((data >> (i * 8)) & 0xff))",
          "70:     return false;",
          "71:   return true;",
          "72:  } else if (msr == MSR_MTRRdefType) {",
          "73:   if (data & ~0xcff)",
          "74:    return false;",
          "75:   return valid_mtrr_type(data & 0xff);",
          "76:  } else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {",
          "77:   for (i = 0; i < 8 ; i++)",
          "78:    if (!valid_mtrr_type((data >> (i * 8)) & 0xff))",
          "79:     return false;",
          "80:   return true;",
          "81:  }",
          "84:  WARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));",
          "86:  mask = (~0ULL) << cpuid_maxphyaddr(vcpu);",
          "87:  if ((msr & 1) == 0) {",
          "89:   if (!valid_mtrr_type(data & 0xff))",
          "90:    return false;",
          "91:   mask |= 0xf00;",
          "92:  } else",
          "94:   mask |= 0x7ff;",
          "95:  if (data & mask) {",
          "96:   kvm_inject_gp(vcpu, 0);",
          "97:   return false;",
          "98:  }",
          "100:  return true;",
          "101: }",
          "102: EXPORT_SYMBOL_GPL(kvm_mtrr_valid);",
          "104: static void update_mtrr(struct kvm_vcpu *vcpu, u32 msr)",
          "105: {",
          "106:  struct mtrr_state_type *mtrr_state = &vcpu->arch.mtrr_state;",
          "107:  unsigned char mtrr_enabled = mtrr_state->enabled;",
          "108:  gfn_t start, end, mask;",
          "109:  int index;",
          "110:  bool is_fixed = true;",
          "112:  if (msr == MSR_IA32_CR_PAT || !tdp_enabled ||",
          "113:        !kvm_arch_has_noncoherent_dma(vcpu->kvm))",
          "114:   return;",
          "116:  if (!(mtrr_enabled & 0x2) && msr != MSR_MTRRdefType)",
          "117:   return;",
          "119:  switch (msr) {",
          "120:  case MSR_MTRRfix64K_00000:",
          "121:   start = 0x0;",
          "122:   end = 0x80000;",
          "123:   break;",
          "124:  case MSR_MTRRfix16K_80000:",
          "125:   start = 0x80000;",
          "126:   end = 0xa0000;",
          "127:   break;",
          "128:  case MSR_MTRRfix16K_A0000:",
          "129:   start = 0xa0000;",
          "130:   end = 0xc0000;",
          "131:   break;",
          "132:  case MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:",
          "133:   index = msr - MSR_MTRRfix4K_C0000;",
          "134:   start = 0xc0000 + index * (32 << 10);",
          "135:   end = start + (32 << 10);",
          "136:   break;",
          "137:  case MSR_MTRRdefType:",
          "138:   is_fixed = false;",
          "139:   start = 0x0;",
          "140:   end = ~0ULL;",
          "141:   break;",
          "142:  default:",
          "144:   is_fixed = false;",
          "145:   index = (msr - 0x200) / 2;",
          "146:   start = (((u64)mtrr_state->var_ranges[index].base_hi) << 32) +",
          "147:          (mtrr_state->var_ranges[index].base_lo & PAGE_MASK);",
          "148:   mask = (((u64)mtrr_state->var_ranges[index].mask_hi) << 32) +",
          "149:          (mtrr_state->var_ranges[index].mask_lo & PAGE_MASK);",
          "150:   mask |= ~0ULL << cpuid_maxphyaddr(vcpu);",
          "152:   end = ((start & mask) | ~mask) + 1;",
          "153:  }",
          "155:  if (is_fixed && !(mtrr_enabled & 0x1))",
          "156:   return;",
          "158:  kvm_zap_gfn_range(vcpu->kvm, gpa_to_gfn(start), gpa_to_gfn(end));",
          "159: }",
          "161: int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)",
          "162: {",
          "163:  u64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;",
          "165:  if (!kvm_mtrr_valid(vcpu, msr, data))",
          "166:   return 1;",
          "168:  if (msr == MSR_MTRRdefType) {",
          "169:   vcpu->arch.mtrr_state.def_type = data;",
          "170:   vcpu->arch.mtrr_state.enabled = (data & 0xc00) >> 10;",
          "171:  } else if (msr == MSR_MTRRfix64K_00000)",
          "172:   p[0] = data;",
          "173:  else if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)",
          "174:   p[1 + msr - MSR_MTRRfix16K_80000] = data;",
          "175:  else if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)",
          "176:   p[3 + msr - MSR_MTRRfix4K_C0000] = data;",
          "177:  else if (msr == MSR_IA32_CR_PAT)",
          "178:   vcpu->arch.pat = data;",
          "180:   int idx, is_mtrr_mask;",
          "181:   u64 *pt;",
          "183:   idx = (msr - 0x200) / 2;",
          "184:   is_mtrr_mask = msr - 0x200 - 2 * idx;",
          "185:   if (!is_mtrr_mask)",
          "186:    pt =",
          "187:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;",
          "188:   else",
          "189:    pt =",
          "190:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;",
          "192:  }",
          "194:  update_mtrr(vcpu, msr);",
          "195:  return 0;",
          "196: }",
          "198: int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)",
          "199: {",
          "200:  u64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;",
          "202:  if (!msr_mtrr_valid(msr))",
          "203:   return 1;",
          "205:  if (msr == MSR_MTRRdefType)",
          "207:     (vcpu->arch.mtrr_state.enabled << 10);",
          "208:  else if (msr == MSR_MTRRfix64K_00000)",
          "210:  else if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)",
          "212:  else if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)",
          "214:  else if (msr == MSR_IA32_CR_PAT)",
          "217:   int idx, is_mtrr_mask;",
          "218:   u64 *pt;",
          "220:   idx = (msr - 0x200) / 2;",
          "221:   is_mtrr_mask = msr - 0x200 - 2 * idx;",
          "222:   if (!is_mtrr_mask)",
          "223:    pt =",
          "224:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;",
          "225:   else",
          "226:    pt =",
          "227:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;",
          "229:  }",
          "231:  return 0;",
          "232: }",
          "238: static int get_mtrr_type(struct mtrr_state_type *mtrr_state,",
          "239:     u64 start, u64 end)",
          "240: {",
          "241:  u64 base, mask;",
          "242:  u8 prev_match, curr_match;",
          "243:  int i, num_var_ranges = KVM_NR_VAR_MTRR;",
          "246:  if (!(mtrr_state->enabled & 0x2))",
          "247:   return MTRR_TYPE_UNCACHABLE;",
          "250:  end--;",
          "253:  if (mtrr_state->have_fixed && (mtrr_state->enabled & 0x1) &&",
          "254:        (start < 0x100000)) {",
          "255:   int idx;",
          "257:   if (start < 0x80000) {",
          "258:    idx = 0;",
          "259:    idx += (start >> 16);",
          "260:    return mtrr_state->fixed_ranges[idx];",
          "261:   } else if (start < 0xC0000) {",
          "262:    idx = 1 * 8;",
          "263:    idx += ((start - 0x80000) >> 14);",
          "264:    return mtrr_state->fixed_ranges[idx];",
          "265:   } else if (start < 0x1000000) {",
          "266:    idx = 3 * 8;",
          "267:    idx += ((start - 0xC0000) >> 12);",
          "268:    return mtrr_state->fixed_ranges[idx];",
          "269:   }",
          "270:  }",
          "277:  prev_match = 0xFF;",
          "278:  for (i = 0; i < num_var_ranges; ++i) {",
          "279:   unsigned short start_state, end_state;",
          "281:   if (!(mtrr_state->var_ranges[i].mask_lo & (1 << 11)))",
          "282:    continue;",
          "284:   base = (((u64)mtrr_state->var_ranges[i].base_hi) << 32) +",
          "285:          (mtrr_state->var_ranges[i].base_lo & PAGE_MASK);",
          "286:   mask = (((u64)mtrr_state->var_ranges[i].mask_hi) << 32) +",
          "287:          (mtrr_state->var_ranges[i].mask_lo & PAGE_MASK);",
          "289:   start_state = ((start & mask) == (base & mask));",
          "290:   end_state = ((end & mask) == (base & mask));",
          "291:   if (start_state != end_state)",
          "292:    return 0xFE;",
          "294:   if ((start & mask) != (base & mask))",
          "295:    continue;",
          "297:   curr_match = mtrr_state->var_ranges[i].base_lo & 0xff;",
          "298:   if (prev_match == 0xFF) {",
          "299:    prev_match = curr_match;",
          "300:    continue;",
          "301:   }",
          "303:   if (prev_match == MTRR_TYPE_UNCACHABLE ||",
          "304:       curr_match == MTRR_TYPE_UNCACHABLE)",
          "305:    return MTRR_TYPE_UNCACHABLE;",
          "307:   if ((prev_match == MTRR_TYPE_WRBACK &&",
          "308:        curr_match == MTRR_TYPE_WRTHROUGH) ||",
          "309:       (prev_match == MTRR_TYPE_WRTHROUGH &&",
          "310:        curr_match == MTRR_TYPE_WRBACK)) {",
          "311:    prev_match = MTRR_TYPE_WRTHROUGH;",
          "312:    curr_match = MTRR_TYPE_WRTHROUGH;",
          "313:   }",
          "315:   if (prev_match != curr_match)",
          "316:    return MTRR_TYPE_UNCACHABLE;",
          "317:  }",
          "319:  if (prev_match != 0xFF)",
          "320:   return prev_match;",
          "322:  return mtrr_state->def_type;",
          "323: }",
          "325: u8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)",
          "326: {",
          "327:  u8 mtrr;",
          "329:  mtrr = get_mtrr_type(&vcpu->arch.mtrr_state, gfn << PAGE_SHIFT,",
          "330:         (gfn << PAGE_SHIFT) + PAGE_SIZE);",
          "331:  if (mtrr == 0xfe || mtrr == 0xff)",
          "332:   mtrr = MTRR_TYPE_WRBACK;",
          "333:  return mtrr;",
          "334: }",
          "335: EXPORT_SYMBOL_GPL(kvm_mtrr_get_guest_memory_type);",
          "",
          "---------------"
        ],
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8659:   goto exit;",
          "8660:  }",
          "8664: exit:",
          "8665:  return (cache << VMX_EPT_MT_EPTE_SHIFT) | ipat;",
          "",
          "[Removed Lines]",
          "8662:  cache = kvm_get_guest_memory_type(vcpu, gfn);",
          "",
          "[Added Lines]",
          "8662:  cache = kvm_mtrr_get_guest_memory_type(vcpu, gfn);",
          "",
          "---------------"
        ],
        "arch/x86/kvm/x86.c||arch/x86/kvm/x86.c": [
          "File: arch/x86/kvm/x86.c -> arch/x86/kvm/x86.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #include <asm/debugreg.h>",
          "58: #include <asm/msr.h>",
          "59: #include <asm/desc.h>",
          "61: #include <asm/mce.h>",
          "62: #include <asm/i387.h>",
          "",
          "[Removed Lines]",
          "60: #include <asm/mtrr.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1803:      KVMCLOCK_SYNC_PERIOD);",
          "1804: }",
          "1979: static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)",
          "1980: {",
          "1981:  u64 mcg_cap = vcpu->arch.mcg_cap;",
          "",
          "[Removed Lines]",
          "1806: static bool msr_mtrr_valid(unsigned msr)",
          "1807: {",
          "1808:  switch (msr) {",
          "1809:  case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:",
          "1810:  case MSR_MTRRfix64K_00000:",
          "1811:  case MSR_MTRRfix16K_80000:",
          "1812:  case MSR_MTRRfix16K_A0000:",
          "1813:  case MSR_MTRRfix4K_C0000:",
          "1814:  case MSR_MTRRfix4K_C8000:",
          "1815:  case MSR_MTRRfix4K_D0000:",
          "1816:  case MSR_MTRRfix4K_D8000:",
          "1817:  case MSR_MTRRfix4K_E0000:",
          "1818:  case MSR_MTRRfix4K_E8000:",
          "1819:  case MSR_MTRRfix4K_F0000:",
          "1820:  case MSR_MTRRfix4K_F8000:",
          "1821:  case MSR_MTRRdefType:",
          "1822:  case MSR_IA32_CR_PAT:",
          "1823:   return true;",
          "1824:  case 0x2f8:",
          "1825:   return true;",
          "1826:  }",
          "1827:  return false;",
          "1828: }",
          "1830: static bool valid_pat_type(unsigned t)",
          "1831: {",
          "1833: }",
          "1835: static bool valid_mtrr_type(unsigned t)",
          "1836: {",
          "1838: }",
          "1840: bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)",
          "1841: {",
          "1842:  int i;",
          "1843:  u64 mask;",
          "1845:  if (!msr_mtrr_valid(msr))",
          "1846:   return false;",
          "1848:  if (msr == MSR_IA32_CR_PAT) {",
          "1849:   for (i = 0; i < 8; i++)",
          "1850:    if (!valid_pat_type((data >> (i * 8)) & 0xff))",
          "1851:     return false;",
          "1852:   return true;",
          "1853:  } else if (msr == MSR_MTRRdefType) {",
          "1854:   if (data & ~0xcff)",
          "1855:    return false;",
          "1856:   return valid_mtrr_type(data & 0xff);",
          "1857:  } else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {",
          "1858:   for (i = 0; i < 8 ; i++)",
          "1859:    if (!valid_mtrr_type((data >> (i * 8)) & 0xff))",
          "1860:     return false;",
          "1861:   return true;",
          "1862:  }",
          "1865:  WARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));",
          "1867:  mask = (~0ULL) << cpuid_maxphyaddr(vcpu);",
          "1868:  if ((msr & 1) == 0) {",
          "1870:   if (!valid_mtrr_type(data & 0xff))",
          "1871:    return false;",
          "1872:   mask |= 0xf00;",
          "1873:  } else",
          "1875:   mask |= 0x7ff;",
          "1876:  if (data & mask) {",
          "1877:   kvm_inject_gp(vcpu, 0);",
          "1878:   return false;",
          "1879:  }",
          "1881:  return true;",
          "1882: }",
          "1883: EXPORT_SYMBOL_GPL(kvm_mtrr_valid);",
          "1885: static void update_mtrr(struct kvm_vcpu *vcpu, u32 msr)",
          "1886: {",
          "1887:  struct mtrr_state_type *mtrr_state = &vcpu->arch.mtrr_state;",
          "1888:  unsigned char mtrr_enabled = mtrr_state->enabled;",
          "1889:  gfn_t start, end, mask;",
          "1890:  int index;",
          "1891:  bool is_fixed = true;",
          "1893:  if (msr == MSR_IA32_CR_PAT || !tdp_enabled ||",
          "1894:        !kvm_arch_has_noncoherent_dma(vcpu->kvm))",
          "1895:   return;",
          "1897:  if (!(mtrr_enabled & 0x2) && msr != MSR_MTRRdefType)",
          "1898:   return;",
          "1900:  switch (msr) {",
          "1901:  case MSR_MTRRfix64K_00000:",
          "1902:   start = 0x0;",
          "1903:   end = 0x80000;",
          "1904:   break;",
          "1905:  case MSR_MTRRfix16K_80000:",
          "1906:   start = 0x80000;",
          "1907:   end = 0xa0000;",
          "1908:   break;",
          "1909:  case MSR_MTRRfix16K_A0000:",
          "1910:   start = 0xa0000;",
          "1911:   end = 0xc0000;",
          "1912:   break;",
          "1913:  case MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:",
          "1914:   index = msr - MSR_MTRRfix4K_C0000;",
          "1915:   start = 0xc0000 + index * (32 << 10);",
          "1916:   end = start + (32 << 10);",
          "1917:   break;",
          "1918:  case MSR_MTRRdefType:",
          "1919:   is_fixed = false;",
          "1920:   start = 0x0;",
          "1921:   end = ~0ULL;",
          "1922:   break;",
          "1923:  default:",
          "1925:   is_fixed = false;",
          "1926:   index = (msr - 0x200) / 2;",
          "1927:   start = (((u64)mtrr_state->var_ranges[index].base_hi) << 32) +",
          "1928:          (mtrr_state->var_ranges[index].base_lo & PAGE_MASK);",
          "1929:   mask = (((u64)mtrr_state->var_ranges[index].mask_hi) << 32) +",
          "1930:          (mtrr_state->var_ranges[index].mask_lo & PAGE_MASK);",
          "1931:   mask |= ~0ULL << cpuid_maxphyaddr(vcpu);",
          "1933:   end = ((start & mask) | ~mask) + 1;",
          "1934:  }",
          "1936:  if (is_fixed && !(mtrr_enabled & 0x1))",
          "1937:   return;",
          "1939:  kvm_zap_gfn_range(vcpu->kvm, gpa_to_gfn(start), gpa_to_gfn(end));",
          "1940: }",
          "1942: static int set_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 data)",
          "1943: {",
          "1944:  u64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;",
          "1946:  if (!kvm_mtrr_valid(vcpu, msr, data))",
          "1947:   return 1;",
          "1949:  if (msr == MSR_MTRRdefType) {",
          "1950:   vcpu->arch.mtrr_state.def_type = data;",
          "1951:   vcpu->arch.mtrr_state.enabled = (data & 0xc00) >> 10;",
          "1952:  } else if (msr == MSR_MTRRfix64K_00000)",
          "1953:   p[0] = data;",
          "1954:  else if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)",
          "1955:   p[1 + msr - MSR_MTRRfix16K_80000] = data;",
          "1956:  else if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)",
          "1957:   p[3 + msr - MSR_MTRRfix4K_C0000] = data;",
          "1958:  else if (msr == MSR_IA32_CR_PAT)",
          "1959:   vcpu->arch.pat = data;",
          "1961:   int idx, is_mtrr_mask;",
          "1962:   u64 *pt;",
          "1964:   idx = (msr - 0x200) / 2;",
          "1965:   is_mtrr_mask = msr - 0x200 - 2 * idx;",
          "1966:   if (!is_mtrr_mask)",
          "1967:    pt =",
          "1968:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;",
          "1969:   else",
          "1970:    pt =",
          "1971:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;",
          "1973:  }",
          "1975:  update_mtrr(vcpu, msr);",
          "1976:  return 0;",
          "1977: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2267:        __func__, data);",
          "2268:   break;",
          "2269:  case 0x200 ... 0x2ff:",
          "2271:  case MSR_IA32_APICBASE:",
          "2272:   return kvm_set_apic_base(vcpu, msr_info);",
          "2273:  case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:",
          "",
          "[Removed Lines]",
          "2270:   return set_msr_mtrr(vcpu, msr, data);",
          "",
          "[Added Lines]",
          "2096:   return kvm_mtrr_set_msr(vcpu, msr, data);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2479: }",
          "2480: EXPORT_SYMBOL_GPL(kvm_get_msr);",
          "2518: static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)",
          "2519: {",
          "2520:  u64 data;",
          "",
          "[Removed Lines]",
          "2482: static int get_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)",
          "2483: {",
          "2484:  u64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;",
          "2486:  if (!msr_mtrr_valid(msr))",
          "2487:   return 1;",
          "2489:  if (msr == MSR_MTRRdefType)",
          "2491:     (vcpu->arch.mtrr_state.enabled << 10);",
          "2492:  else if (msr == MSR_MTRRfix64K_00000)",
          "2494:  else if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)",
          "2496:  else if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)",
          "2498:  else if (msr == MSR_IA32_CR_PAT)",
          "2501:   int idx, is_mtrr_mask;",
          "2502:   u64 *pt;",
          "2504:   idx = (msr - 0x200) / 2;",
          "2505:   is_mtrr_mask = msr - 0x200 - 2 * idx;",
          "2506:   if (!is_mtrr_mask)",
          "2507:    pt =",
          "2508:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;",
          "2509:   else",
          "2510:    pt =",
          "2511:      (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;",
          "2513:  }",
          "2515:  return 0;",
          "2516: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2656:   msr_info->data = 0x500 | KVM_NR_VAR_MTRR;",
          "2657:   break;",
          "2658:  case 0x200 ... 0x2ff:",
          "2661:   msr_info->data = 3;",
          "2662:   break;",
          "",
          "[Removed Lines]",
          "2659:   return get_msr_mtrr(vcpu, msr_info->index, &msr_info->data);",
          "",
          "[Added Lines]",
          "2449:   return kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);",
          "",
          "---------------"
        ],
        "arch/x86/kvm/x86.h||arch/x86/kvm/x86.h": [
          "File: arch/x86/kvm/x86.h -> arch/x86/kvm/x86.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:  gva_t addr, void *val, unsigned int bytes,",
          "163:  struct x86_exception *exception);",
          "165: bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data);",
          "167: #define KVM_SUPPORTED_XCR0     (XSTATE_FP | XSTATE_SSE | XSTATE_YMM \\",
          "168:     | XSTATE_BNDREGS | XSTATE_BNDCSR \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165: u8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn);",
          "167: int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data);",
          "168: int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
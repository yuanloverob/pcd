{
  "cve_id": "CVE-2017-2920",
  "cve_desc": "An memory corruption vulnerability exists in the .SVG parsing functionality of Computerinsel Photoline 20.02. A specially crafted .SVG file can cause a vulnerability resulting in memory corruption, which can potentially lead to arbitrary code execution. An attacker can send a specific .SVG file to trigger this vulnerability.",
  "repo": "libofx/libofx",
  "patch_hash": "a70934eea95c76a7737b83773bffe8738935082d",
  "patch_info": {
    "commit_hash": "a70934eea95c76a7737b83773bffe8738935082d",
    "repo": "libofx/libofx",
    "commit_url": "https://github.com/libofx/libofx/commit/a70934eea95c76a7737b83773bffe8738935082d",
    "files": [
      "lib/ofx_preproc.cpp"
    ],
    "message": "Fix a buffer overflow.\n\nThis is only the minimum workaround to prevent buffer overflow:\nStop iterating once the (fixed!) size of the output buffers is\nreached. In response to\nhttps://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0317\n\nHowever, this code is a huge mess anyway and is in no way\nanything like up-to-date C++ code. Please, anyone, replace it\nwith something more modern. Thanks.",
    "before_after_code_files": [
      "lib/ofx_preproc.cpp||lib/ofx_preproc.cpp"
    ]
  },
  "patch_diff": {
    "lib/ofx_preproc.cpp||lib/ofx_preproc.cpp": [
      "File: lib/ofx_preproc.cpp -> lib/ofx_preproc.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "417: string sanitize_proprietary_tags(string input_string)",
      "418: {",
      "419:   unsigned int i;",
      "421:   bool strip = false;",
      "422:   bool tag_open = false;",
      "423:   int tag_open_idx = 0; //Are we within < > ?",
      "",
      "[Removed Lines]",
      "420:   size_t input_string_size;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "438:     close_tagname[i] = 0;",
      "439:   }",
      "444:   {",
      "445:     if (input_string.c_str()[i] == '<')",
      "446:     {",
      "",
      "[Removed Lines]",
      "441:   input_string_size = input_string.size();",
      "443:   for (i = 0; i < input_string_size; i++)",
      "",
      "[Added Lines]",
      "440:   size_t input_string_size = input_string.size();",
      "450:   for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dcf34ade9eb34f9c88a2a20648da43bf0841e0ec",
      "candidate_info": {
        "commit_hash": "dcf34ade9eb34f9c88a2a20648da43bf0841e0ec",
        "repo": "libofx/libofx",
        "commit_url": "https://github.com/libofx/libofx/commit/dcf34ade9eb34f9c88a2a20648da43bf0841e0ec",
        "files": [
          "lib/ofx_preproc.cpp"
        ],
        "message": "Rewrite sanitize_proprietary_tags\n\nInstead of iterating of each character in the input string\nactively search for opening and (optional) closing tags.\nIf the opening tag turns out to be proprietary remove everything\nuntil (and including) it's matching closing tag. In the absence of a matching\nclosing tag, remove everything until (but not including) the next\ntag.",
        "before_after_code_files": [
          "lib/ofx_preproc.cpp||lib/ofx_preproc.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/ofx_preproc.cpp||lib/ofx_preproc.cpp"
          ],
          "candidate": [
            "lib/ofx_preproc.cpp||lib/ofx_preproc.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lib/ofx_preproc.cpp||lib/ofx_preproc.cpp": [
          "File: lib/ofx_preproc.cpp -> lib/ofx_preproc.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:   \"/usr/share/libofx/dtd\",",
          "74:   \"~\"",
          "75: };",
          "",
          "[Removed Lines]",
          "76: const unsigned int READ_BUFFER_SIZE = 1024;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "408:   return 0;",
          "409: }",
          "417: {",
          "481:     {",
          "491:     }",
          "493:     {",
          "497:         {",
          "500:         }",
          "504:     }",
          "507:     {",
          "519:     }",
          "523:   {",
          "525:     {",
          "527:     }",
          "532:   }",
          "533:   return input_string;",
          "534: }",
          "",
          "[Removed Lines]",
          "413:    This function will strip all the OFX proprietary tags and SGML comments from the SGML string passed to it",
          "416: string sanitize_proprietary_tags(string input_string)",
          "418:   unsigned int i;",
          "419:   bool strip = false;",
          "420:   bool tag_open = false;",
          "421:   int tag_open_idx = 0; //Are we within < > ?",
          "422:   bool closing_tag_open = false; //Are we within </ > ?",
          "423:   int orig_tag_open_idx = 0;",
          "424:   bool proprietary_tag = false; //Are we within a proprietary element?",
          "425:   bool proprietary_closing_tag = false;",
          "426:   int crop_end_idx = 0;",
          "427:   char buffer[READ_BUFFER_SIZE] = \"\";",
          "428:   char tagname[READ_BUFFER_SIZE] = \"\";",
          "429:   int tagname_idx = 0;",
          "430:   char close_tagname[READ_BUFFER_SIZE] = \"\";",
          "432:   for (i = 0; i < READ_BUFFER_SIZE; i++)",
          "433:   {",
          "434:     buffer[i] = 0;",
          "435:     tagname[i] = 0;",
          "436:     close_tagname[i] = 0;",
          "437:   }",
          "439:   size_t input_string_size = input_string.size();",
          "449:   for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)",
          "450:   {",
          "451:     if (input_string.c_str()[i] == '<')",
          "452:     {",
          "453:       tag_open = true;",
          "454:       tag_open_idx = i;",
          "455:       if (proprietary_tag == true && input_string.c_str()[i+1] == '/')",
          "456:       {",
          "458:         closing_tag_open = true;",
          "460:         if (strncmp(tagname, &(input_string.c_str()[i+2]), strlen(tagname)) != 0)",
          "461:         {",
          "464:           crop_end_idx = i - 1;",
          "465:           strip = true;",
          "466:         }",
          "467:         else",
          "468:         {",
          "470:           proprietary_closing_tag = true;",
          "471:         }",
          "472:       }",
          "473:       else if (proprietary_tag == true)",
          "474:       {",
          "476:         crop_end_idx = i - 1;",
          "477:         strip = true;",
          "478:       }",
          "479:     }",
          "480:     else if (input_string.c_str()[i] == '>')",
          "482:       tag_open = false;",
          "483:       closing_tag_open = false;",
          "484:       tagname[tagname_idx] = 0;",
          "485:       tagname_idx = 0;",
          "486:       if (proprietary_closing_tag == true)",
          "487:       {",
          "488:         crop_end_idx = i;",
          "489:         strip = true;",
          "490:       }",
          "492:     else if (tag_open == true && closing_tag_open == false)",
          "494:       if (input_string.c_str()[i] == '.')",
          "495:       {",
          "496:         if (proprietary_tag != true)",
          "498:           orig_tag_open_idx = tag_open_idx;",
          "499:           proprietary_tag = true;",
          "501:       }",
          "502:       tagname[tagname_idx] = input_string.c_str()[i];",
          "503:       tagname_idx++;",
          "506:     if (strip == true && orig_tag_open_idx < input_string.size())",
          "508:       input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);",
          "509:       message_out(INFO, \"sanitize_proprietary_tags() (end tag or new tag) removed: \" + string(buffer));",
          "510:       input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);",
          "511:       i = orig_tag_open_idx - 1;",
          "512:       proprietary_tag = false;",
          "513:       proprietary_closing_tag = false;",
          "514:       closing_tag_open = false;",
          "515:       tag_open = false;",
          "516:       strip = false;",
          "518:       input_string_size = input_string.size();",
          "521:   }//end for",
          "522:   if (proprietary_tag == true && orig_tag_open_idx < input_string.size())",
          "524:     if (crop_end_idx == 0)   //no closing tag",
          "526:       crop_end_idx = input_string.size() - 1;",
          "528:     input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);",
          "529:     message_out(INFO, \"sanitize_proprietary_tags() (end of line) removed: \" + string(buffer));",
          "530:     input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);",
          "531:     input_string_size = input_string.size();",
          "",
          "[Added Lines]",
          "414: static string find_tag_open (string& input_string, size_t& pos)",
          "416:     size_t start_idx = input_string.find ('<', pos);",
          "418:     if (start_idx == string::npos)",
          "420:         pos = string::npos;",
          "421:         return string();",
          "424:     size_t end_idx = input_string.find ('>', start_idx + 1);",
          "425:     if (end_idx != string::npos)",
          "426:         pos = end_idx + 1;",
          "427:     end_idx = end_idx - (start_idx + 1);",
          "428:     return input_string.substr(start_idx + 1, end_idx);",
          "429: }",
          "436: static void find_tag_close (string& input_string, string& tag_name, size_t& pos)",
          "437: {",
          "438:     size_t start_idx = input_string.find (\"</\" + tag_name + \">\", pos);",
          "440:     if (start_idx == string::npos)",
          "442:         string new_tag_name = find_tag_open (input_string, pos);",
          "443:         if (!new_tag_name.empty())",
          "447:             pos = pos - new_tag_name.length() - 2;",
          "450:     else",
          "452:         pos = std::min(input_string.length(), start_idx + tag_name.length() + 3);",
          "454:     return;",
          "455: }",
          "459:    This function will strip all the OFX proprietary tags and SGML comments from the SGML string passed to it",
          "460:    Note this function assumes in case a proprietary tag comes in an open and closing pair,",
          "461:    they both appear on the same line (and hence are part of the same input_string passed to this function).",
          "462:    So an ofx file with a single line like this <proprietary>abc</proprietary> will properly sanitized",
          "463:    But an ofx file where this is split on multiple lines will not:",
          "464:    <proprietary>",
          "465:      abc",
          "466:    </proprietary>",
          "469: string sanitize_proprietary_tags(string input_string)",
          "470: {",
          "471:   size_t last_known_good_pos = 0;",
          "472:   size_t find_pos = last_known_good_pos;",
          "473:   string tag_name = find_tag_open(input_string, find_pos);",
          "474:   while (!tag_name.empty())",
          "477:     if (tag_name.find('.') != string::npos)",
          "478:     {",
          "479:         find_tag_close (input_string, tag_name, find_pos);",
          "480:         size_t tag_size = find_pos - last_known_good_pos;",
          "481:         string prop_tag = input_string.substr(last_known_good_pos, tag_size);",
          "482:         message_out(INFO, \"sanitize_proprietary_tags() removed: \" + prop_tag);",
          "483:         input_string.erase(last_known_good_pos, tag_size);",
          "484:         find_pos = last_known_good_pos;",
          "485:     }",
          "486:     else",
          "488:         last_known_good_pos = find_pos;",
          "490:     tag_name.clear();",
          "491:     if (last_known_good_pos != string::npos)",
          "492:         tag_name = find_tag_open(input_string, find_pos);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
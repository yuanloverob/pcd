{
  "cve_id": "CVE-2014-9718",
  "cve_desc": "The (1) BMDMA and (2) AHCI HBA interfaces in the IDE functionality in QEMU 1.0 through 2.1.3 have multiple interpretations of a function's return value, which allows guest OS users to cause a host OS denial of service (memory consumption or infinite loop, and system crash) via a PRDT with zero complete sectors, related to the bmdma_prepare_buf and ahci_dma_prepare_buf functions.",
  "repo": "qemu/qemu",
  "patch_hash": "3251bdcf1c67427d964517053c3d185b46e618e8",
  "patch_info": {
    "commit_hash": "3251bdcf1c67427d964517053c3d185b46e618e8",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/3251bdcf1c67427d964517053c3d185b46e618e8",
    "files": [
      "hw/ide/ahci.c",
      "hw/ide/core.c",
      "hw/ide/internal.h",
      "hw/ide/macio.c",
      "hw/ide/pci.c"
    ],
    "message": "ide: Correct handling of malformed/short PRDTs\n\nThis impacts both BMDMA and AHCI HBA interfaces for IDE.\nCurrently, we confuse the difference between a PRDT having\n\"0 bytes\" and a PRDT having \"0 complete sectors.\"\n\nWhen we receive an incomplete sector, inconsistent error checking\nleads to an infinite loop wherein the call succeeds, but it\ndidn't give us enough bytes -- leading us to re-call the\nDMA chain over and over again. This leads to, in the BMDMA case,\nleaked memory for short PRDTs, and infinite loops and resource\nusage in the AHCI case.\n\nThe .prepare_buf() callback is reworked to return the number of\nbytes that it successfully prepared. 0 is a valid, non-error\nanswer that means the table was empty and described no bytes.\n-1 indicates an error.\n\nOur current implementation uses the io_buffer in IDEState to\nultimately describe the size of a prepared scatter-gather list.\nEven though the AHCI PRDT/SGList can be as large as 256GiB, the\nAHCI command header limits transactions to just 4GiB. ATA8-ACS3,\nhowever, defines the largest transaction to be an LBA48 command\nthat transfers 65,536 sectors. With a 512 byte sector size, this\nis just 32MiB.\n\nSince our current state structures use the int type to describe\nthe size of the buffer, and this state is migrated as int32, we\nare limited to describing 2GiB buffer sizes unless we change the\nmigration protocol.\n\nFor this reason, this patch begins to unify the assertions in the\nIDE pathways that the scatter-gather list provided by either the\nAHCI PRDT or the PCI BMDMA PRDs can only describe, at a maximum,\n2GiB. This should be resilient enough unless we need a sector\nsize that exceeds 32KiB.\n\nFurther, the likelihood of any guest operating system actually\nattempting to transfer this much data in a single operation is\nvery slim.\n\nTo this end, the IDEState variables have been updated to more\nexplicitly clarify our maximum supported size. Callers to the\nprepare_buf callback have been reworked to understand the new\nreturn code, and all versions of the prepare_buf callback have\nbeen adjusted accordingly.\n\nLastly, the ahci_populate_sglist helper, relied upon by the\nAHCI implementation of .prepare_buf() as well as the PCI\nimplementation of the callback have had overflow assertions\nadded to help make clear the reasonings behind the various\ntype changes.\n\n[Added %d -> %\"PRId64\" fix John sent because off_pos changed from int to\nint64_t.\n--Stefan]\n\nSigned-off-by: John Snow <jsnow@redhat.com>\nReviewed-by: Paolo Bonzini <pbonzini@redhat.com>\nMessage-id: 1414785819-26209-4-git-send-email-jsnow@redhat.com\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>",
    "before_after_code_files": [
      "hw/ide/ahci.c||hw/ide/ahci.c",
      "hw/ide/core.c||hw/ide/core.c",
      "hw/ide/internal.h||hw/ide/internal.h",
      "hw/ide/macio.c||hw/ide/macio.c",
      "hw/ide/pci.c||hw/ide/pci.c"
    ]
  },
  "patch_diff": {
    "hw/ide/ahci.c||hw/ide/ahci.c": [
      "File: hw/ide/ahci.c -> hw/ide/ahci.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "730:     return (le32_to_cpu(tbl->flags_size) & AHCI_PRDT_SIZE_MASK) + 1;",
      "731: }",
      "734: {",
      "735:     AHCICmdHdr *cmd = ad->cur_cmd;",
      "736:     uint32_t opts = le32_to_cpu(cmd->opts);",
      "",
      "[Removed Lines]",
      "733: static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)",
      "",
      "[Added Lines]",
      "733: static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,",
      "734:                                 int32_t offset)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "741:     uint8_t *prdt;",
      "742:     int i;",
      "743:     int r = 0;",
      "745:     int off_idx = -1;",
      "747:     int tbl_entry_size;",
      "748:     IDEBus *bus = &ad->port;",
      "749:     BusState *qbus = BUS(bus);",
      "751:     if (!sglist_alloc_hint) {",
      "752:         DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);",
      "753:         return -1;",
      "",
      "[Removed Lines]",
      "744:     int sum = 0;",
      "746:     int off_pos = -1;",
      "",
      "[Added Lines]",
      "745:     uint64_t sum = 0;",
      "747:     int64_t off_pos = -1;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "782:         }",
      "783:         if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {",
      "784:             DPRINTF(ad->port_no, \"%s: Incorrect offset! \"",
      "786:                             __func__, off_idx, off_pos);",
      "787:             r = -1;",
      "788:             goto out;",
      "",
      "[Removed Lines]",
      "785:                             \"off_idx: %d, off_pos: %d\\n\",",
      "",
      "[Added Lines]",
      "794:                             \"off_idx: %d, off_pos: %\"PRId64\"\\n\",",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "798:             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),",
      "799:                             prdt_tbl_entry_size(&tbl[i]));",
      "800:         }",
      "801:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "809:             if (sglist->size > INT32_MAX) {",
      "810:                 error_report(\"AHCI Physical Region Descriptor Table describes \"",
      "811:                              \"more than 2 GiB.\\n\");",
      "812:                 qemu_sglist_destroy(sglist);",
      "813:                 r = -1;",
      "814:                 goto out;",
      "815:             }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1144: {",
      "1145:     AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);",
      "1146:     IDEState *s = &ad->port.ifs[0];",
      "1149:     s->io_buffer_size = s->sg.size;",
      "1151:     DPRINTF(ad->port_no, \"len=%#x\\n\", s->io_buffer_size);",
      "1153: }",
      "",
      "[Removed Lines]",
      "1143: static int ahci_dma_prepare_buf(IDEDMA *dma, int is_write)",
      "1148:     ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset);",
      "1152:     return s->io_buffer_size != 0;",
      "",
      "[Added Lines]",
      "1159: static int32_t ahci_dma_prepare_buf(IDEDMA *dma, int is_write)",
      "1164:     if (ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset) == -1) {",
      "1165:         DPRINTF(ad->port_no, \"ahci_dma_prepare_buf failed.\\n\");",
      "1166:         return -1;",
      "1167:     }",
      "1171:     return s->io_buffer_size;",
      "",
      "---------------"
    ],
    "hw/ide/core.c||hw/ide/core.c": [
      "File: hw/ide/core.c -> hw/ide/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "731:     n = s->nsector;",
      "732:     s->io_buffer_index = 0;",
      "733:     s->io_buffer_size = n * 512;",
      "737:         s->status = READY_STAT | SEEK_STAT;",
      "738:         goto eot;",
      "739:     }",
      "",
      "[Removed Lines]",
      "734:     if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {",
      "",
      "[Added Lines]",
      "734:     if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) < 512) {",
      "738:         dma_buf_commit(s, 0);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2313:     return 0;",
      "2314: }",
      "2316: static void ide_nop_restart(void *opaque, int x, RunState y)",
      "2317: {",
      "2318: }",
      "2320: static const IDEDMAOps ide_dma_nop_ops = {",
      "2322:     .rw_buf         = ide_nop_int,",
      "2323:     .set_unit       = ide_nop_int,",
      "2324:     .restart_cb     = ide_nop_restart,",
      "",
      "[Removed Lines]",
      "2321:     .prepare_buf    = ide_nop_int,",
      "",
      "[Added Lines]",
      "2317: static int32_t ide_nop_int32(IDEDMA *dma, int x)",
      "2318: {",
      "2319:     return 0;",
      "2320: }",
      "2327:     .prepare_buf    = ide_nop_int32,",
      "",
      "---------------"
    ],
    "hw/ide/internal.h||hw/ide/internal.h": [
      "File: hw/ide/internal.h -> hw/ide/internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "322: typedef void DMAStartFunc(IDEDMA *, IDEState *, BlockCompletionFunc *);",
      "323: typedef void DMAVoidFunc(IDEDMA *);",
      "324: typedef int DMAIntFunc(IDEDMA *, int);",
      "325: typedef void DMAu32Func(IDEDMA *, uint32_t);",
      "326: typedef void DMAStopFunc(IDEDMA *, bool);",
      "327: typedef void DMARestartFunc(void *, int, RunState);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "325: typedef int32_t DMAInt32Func(IDEDMA *, int);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "385:     uint8_t cdrom_changed;",
      "386:     int packet_transfer_size;",
      "387:     int elementary_transfer_size;",
      "389:     int lba;",
      "390:     int cd_sector_size;",
      "",
      "[Removed Lines]",
      "388:     int io_buffer_index;",
      "",
      "[Added Lines]",
      "389:     int32_t io_buffer_index;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "394:     struct iovec iov;",
      "395:     QEMUIOVector qiov;",
      "399:     QEMUSGList sg;",
      "",
      "[Removed Lines]",
      "397:     int io_buffer_offset;",
      "398:     int io_buffer_size;",
      "",
      "[Added Lines]",
      "398:     int32_t io_buffer_offset;",
      "399:     int32_t io_buffer_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "405:     uint8_t *io_buffer;",
      "407:     int32_t io_buffer_total_len;",
      "410:     uint8_t end_transfer_fn_idx;",
      "",
      "[Removed Lines]",
      "408:     int cur_io_buffer_offset;",
      "409:     int cur_io_buffer_len;",
      "",
      "[Added Lines]",
      "409:     int32_t cur_io_buffer_offset;",
      "410:     int32_t cur_io_buffer_len;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "430: struct IDEDMAOps {",
      "431:     DMAStartFunc *start_dma;",
      "432:     DMAVoidFunc *start_transfer;",
      "434:     DMAu32Func *commit_buf;",
      "435:     DMAIntFunc *rw_buf;",
      "436:     DMAIntFunc *set_unit;",
      "",
      "[Removed Lines]",
      "433:     DMAIntFunc *prepare_buf;",
      "",
      "[Added Lines]",
      "434:     DMAInt32Func *prepare_buf;",
      "",
      "---------------"
    ],
    "hw/ide/macio.c||hw/ide/macio.c": [
      "File: hw/ide/macio.c -> hw/ide/macio.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "553:     return 0;",
      "554: }",
      "556: static void ide_nop_restart(void *opaque, int x, RunState y)",
      "557: {",
      "558: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "556: static int32_t ide_nop_int32(IDEDMA *dma, int x)",
      "557: {",
      "558:     return 0;",
      "559: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "570: static const IDEDMAOps dbdma_ops = {",
      "571:     .start_dma      = ide_dbdma_start,",
      "573:     .rw_buf         = ide_nop_int,",
      "574:     .set_unit       = ide_nop_int,",
      "575:     .restart_cb     = ide_nop_restart,",
      "",
      "[Removed Lines]",
      "572:     .prepare_buf    = ide_nop_int,",
      "",
      "[Added Lines]",
      "577:     .prepare_buf    = ide_nop_int32,",
      "",
      "---------------"
    ],
    "hw/ide/pci.c||hw/ide/pci.c": [
      "File: hw/ide/pci.c -> hw/ide/pci.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "28: #include <hw/isa/isa.h>",
      "29: #include \"sysemu/block-backend.h\"",
      "30: #include \"sysemu/dma.h\"",
      "32: #include <hw/ide/pci.h>",
      "34: #define BMDMA_PAGE_SIZE 4096",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "31: #include \"qemu/error-report.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "55:     }",
      "56: }",
      "60: {",
      "61:     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);",
      "62:     IDEState *s = bmdma_active_if(bm);",
      "",
      "[Removed Lines]",
      "59: static int bmdma_prepare_buf(IDEDMA *dma, int is_write)",
      "",
      "[Added Lines]",
      "62: static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "74:         if (bm->cur_prd_len == 0) {",
      "76:             if (bm->cur_prd_last ||",
      "79:             pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);",
      "80:             bm->cur_addr += 8;",
      "81:             prd.addr = le32_to_cpu(prd.addr);",
      "",
      "[Removed Lines]",
      "77:                 (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE)",
      "78:                 return s->io_buffer_size != 0;",
      "",
      "[Added Lines]",
      "80:                 (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {",
      "81:                 return s->io_buffer_size;",
      "82:             }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "90:         l = bm->cur_prd_len;",
      "91:         if (l > 0) {",
      "92:             qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);",
      "93:             bm->cur_prd_addr += l;",
      "94:             bm->cur_prd_len -= l;",
      "95:             s->io_buffer_size += l;",
      "96:         }",
      "97:     }",
      "99: }",
      "",
      "[Removed Lines]",
      "98:     return 1;",
      "",
      "[Added Lines]",
      "101:             if (s->sg.size > INT32_MAX) {",
      "102:                 error_report(\"IDE: sglist describes more than 2GiB.\\n\");",
      "103:                 break;",
      "104:             }",
      "111:     qemu_sglist_destroy(&s->sg);",
      "112:     s->io_buffer_size = 0;",
      "113:     return -1;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a718978ed58abc1ad92567a9c17525136be02a71",
      "candidate_info": {
        "commit_hash": "a718978ed58abc1ad92567a9c17525136be02a71",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/a718978ed58abc1ad92567a9c17525136be02a71",
        "files": [
          "hw/ide/ahci.c",
          "hw/ide/core.c",
          "hw/ide/internal.h",
          "hw/ide/macio.c",
          "hw/ide/pci.c"
        ],
        "message": "ide: add limit to .prepare_buf()\n\nprepare_buf should not always grab as many descriptors\nas it can, sometimes it should self-limit.\n\nFor example, an NCQ transfer of 1 sector with a PRDT that\ndescribes 4GiB of data should not copy 4GiB of data, it\nshould just transfer that first 512 bytes.\n\nPIO is not affected, because the dma_buf_rw dma helpers\nalready have a byte limit built-in to them, but DMA/NCQ\nwill exhaust the entire list regardless of requested size.\n\nAHCI 1.3 specifies in section 6.1.6 Command List Underflow that\nNCQ is not required to detect underflow conditions. Non-NCQ\npathways signal underflow by writing to the PRDBC field, which\nwill already occur by writing the actual transferred byte count\nto the PRDBC, signaling the underflow.\n\nOur NCQ pathways aren't required to detect underflow, but since our DMA\nbackend uses the size of the PRDT to determine the size of the transer,\nif our PRDT is bigger than the transaction (the underflow condition) it\ndoesn't cost us anything to detect it and truncate the PRDT.\n\nThis is a recoverable error and is not signaled to the guest, in either\nNCQ or normal DMA cases.\n\nFor BMDMA, the existing pathways should see no guest-visible difference,\nbut any bytes described in the overage will no longer be transferred\nbefore indicating to the guest that there was an underflow.\n\nSigned-off-by: John Snow <jsnow@redhat.com>\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\nMessage-id: 1435767578-32743-2-git-send-email-jsnow@redhat.com",
        "before_after_code_files": [
          "hw/ide/ahci.c||hw/ide/ahci.c",
          "hw/ide/core.c||hw/ide/core.c",
          "hw/ide/internal.h||hw/ide/internal.h",
          "hw/ide/macio.c||hw/ide/macio.c",
          "hw/ide/pci.c||hw/ide/pci.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/ide/ahci.c||hw/ide/ahci.c",
            "hw/ide/core.c||hw/ide/core.c",
            "hw/ide/internal.h||hw/ide/internal.h",
            "hw/ide/macio.c||hw/ide/macio.c",
            "hw/ide/pci.c||hw/ide/pci.c"
          ],
          "candidate": [
            "hw/ide/ahci.c||hw/ide/ahci.c",
            "hw/ide/core.c||hw/ide/core.c",
            "hw/ide/internal.h||hw/ide/internal.h",
            "hw/ide/macio.c||hw/ide/macio.c",
            "hw/ide/pci.c||hw/ide/pci.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/ide/ahci.c||hw/ide/ahci.c": [
          "File: hw/ide/ahci.c -> hw/ide/ahci.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: static void ahci_reset_port(AHCIState *s, int port);",
          "50: static void ahci_write_fis_d2h(AHCIDevice *ad, uint8_t *cmd_fis);",
          "51: static void ahci_init_d2h(AHCIDevice *ad);",
          "53: static void ahci_commit_buf(IDEDMA *dma, uint32_t tx_bytes);",
          "54: static bool ahci_map_clb_address(AHCIDevice *ad);",
          "55: static bool ahci_map_fis_address(AHCIDevice *ad);",
          "",
          "[Removed Lines]",
          "52: static int ahci_dma_prepare_buf(IDEDMA *dma, int is_write);",
          "",
          "[Added Lines]",
          "52: static int ahci_dma_prepare_buf(IDEDMA *dma, int32_t limit);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "828: static int prdt_tbl_entry_size(const AHCI_SG *tbl)",
          "829: {",
          "830:     return (le32_to_cpu(tbl->flags_size) & AHCI_PRDT_SIZE_MASK) + 1;",
          "831: }",
          "833: static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,",
          "835: {",
          "836:     AHCICmdHdr *cmd = ad->cur_cmd;",
          "837:     uint16_t opts = le16_to_cpu(cmd->opts);",
          "",
          "[Removed Lines]",
          "834:                                 int32_t offset)",
          "",
          "[Added Lines]",
          "835:                                 int64_t limit, int32_t offset)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "881:         AHCI_SG *tbl = (AHCI_SG *)prdt;",
          "882:         sum = 0;",
          "883:         for (i = 0; i < prdtl; i++) {",
          "885:             tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);",
          "887:                 off_idx = i;",
          "888:                 off_pos = offset - sum;",
          "889:                 break;",
          "",
          "[Removed Lines]",
          "886:             if (offset <= (sum + tbl_entry_size)) {",
          "",
          "[Added Lines]",
          "886:             if (offset < (sum + tbl_entry_size)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "901:         qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),",
          "902:                          ad->hba->as);",
          "903:         qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,",
          "908:             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),",
          "910:             if (sglist->size > INT32_MAX) {",
          "911:                 error_report(\"AHCI Physical Region Descriptor Table describes \"",
          "912:                              \"more than 2 GiB.\\n\");",
          "",
          "[Removed Lines]",
          "904:                         prdt_tbl_entry_size(&tbl[off_idx]) - off_pos);",
          "906:         for (i = off_idx + 1; i < prdtl; i++) {",
          "909:                             prdt_tbl_entry_size(&tbl[i]));",
          "",
          "[Added Lines]",
          "904:                         MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,",
          "905:                             limit));",
          "907:         for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {",
          "909:                             MIN(prdt_tbl_entry_size(&tbl[i]),",
          "910:                                 limit - sglist->size));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1025:     ncq_tfs->sector_count = ((uint16_t)ncq_fis->sector_count_high << 8) |",
          "1026:                                 ncq_fis->sector_count_low;",
          "1028:     size = ncq_tfs->sector_count * 512;",
          "1030:     if (ncq_tfs->sglist.size < size) {",
          "1031:         error_report(\"ahci: PRDT length for NCQ command (0x%zx) \"",
          "",
          "[Removed Lines]",
          "1027:     ahci_populate_sglist(ad, &ncq_tfs->sglist, 0);",
          "",
          "[Added Lines]",
          "1029:     ahci_populate_sglist(ad, &ncq_tfs->sglist, size, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1262:         goto out;",
          "1263:     }",
          "1266:         has_sglist = 1;",
          "1267:     }",
          "",
          "[Removed Lines]",
          "1265:     if (ahci_dma_prepare_buf(dma, is_write)) {",
          "",
          "[Added Lines]",
          "1266:     if (ahci_dma_prepare_buf(dma, size)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1316: {",
          "1317:     AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);",
          "1318:     IDEState *s = &ad->port.ifs[0];",
          "1321:         DPRINTF(ad->port_no, \"ahci_dma_prepare_buf failed.\\n\");",
          "1322:         return -1;",
          "1323:     }",
          "",
          "[Removed Lines]",
          "1315: static int32_t ahci_dma_prepare_buf(IDEDMA *dma, int is_write)",
          "1320:     if (ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset) == -1) {",
          "",
          "[Added Lines]",
          "1316: static int32_t ahci_dma_prepare_buf(IDEDMA *dma, int32_t limit)",
          "1321:     if (ahci_populate_sglist(ad, &s->sg, limit, s->io_buffer_offset) == -1) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1352:     uint8_t *p = s->io_buffer + s->io_buffer_index;",
          "1353:     int l = s->io_buffer_size - s->io_buffer_index;",
          "1356:         return 0;",
          "1357:     }",
          "",
          "[Removed Lines]",
          "1355:     if (ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset)) {",
          "",
          "[Added Lines]",
          "1356:     if (ahci_populate_sglist(ad, &s->sg, l, s->io_buffer_offset)) {",
          "",
          "---------------"
        ],
        "hw/ide/core.c||hw/ide/core.c": [
          "File: hw/ide/core.c -> hw/ide/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "717:     sector_num = ide_get_sector(s);",
          "718:     if (n > 0) {",
          "721:         sector_num += n;",
          "722:         ide_set_sector(s, sector_num);",
          "723:         s->nsector -= n;",
          "",
          "[Removed Lines]",
          "719:         assert(s->io_buffer_size == s->sg.size);",
          "720:         dma_buf_commit(s, s->io_buffer_size);",
          "",
          "[Added Lines]",
          "719:         assert(n * 512 == s->sg.size);",
          "720:         dma_buf_commit(s, s->sg.size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "734:     n = s->nsector;",
          "735:     s->io_buffer_index = 0;",
          "736:     s->io_buffer_size = n * 512;",
          "740:         s->status = READY_STAT | SEEK_STAT;",
          "",
          "[Removed Lines]",
          "737:     if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) < 512) {",
          "",
          "[Added Lines]",
          "737:     if (s->bus->dma->ops->prepare_buf(s->bus->dma, s->io_buffer_size) < 512) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2326: {",
          "2327: }",
          "2330: {",
          "2331:     return 0;",
          "2332: }",
          "",
          "[Removed Lines]",
          "2329: static int32_t ide_nop_int32(IDEDMA *dma, int x)",
          "",
          "[Added Lines]",
          "2329: static int32_t ide_nop_int32(IDEDMA *dma, int32_t l)",
          "",
          "---------------"
        ],
        "hw/ide/internal.h||hw/ide/internal.h": [
          "File: hw/ide/internal.h -> hw/ide/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "324: typedef void DMAStartFunc(IDEDMA *, IDEState *, BlockCompletionFunc *);",
          "325: typedef void DMAVoidFunc(IDEDMA *);",
          "326: typedef int DMAIntFunc(IDEDMA *, int);",
          "328: typedef void DMAu32Func(IDEDMA *, uint32_t);",
          "329: typedef void DMAStopFunc(IDEDMA *, bool);",
          "330: typedef void DMARestartFunc(void *, int, RunState);",
          "",
          "[Removed Lines]",
          "327: typedef int32_t DMAInt32Func(IDEDMA *, int);",
          "",
          "[Added Lines]",
          "327: typedef int32_t DMAInt32Func(IDEDMA *, int32_t len);",
          "",
          "---------------"
        ],
        "hw/ide/macio.c||hw/ide/macio.c": [
          "File: hw/ide/macio.c -> hw/ide/macio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "499:     return 0;",
          "500: }",
          "503: {",
          "504:     return 0;",
          "505: }",
          "",
          "[Removed Lines]",
          "502: static int32_t ide_nop_int32(IDEDMA *dma, int x)",
          "",
          "[Added Lines]",
          "502: static int32_t ide_nop_int32(IDEDMA *dma, int32_t l)",
          "",
          "---------------"
        ],
        "hw/ide/pci.c||hw/ide/pci.c": [
          "File: hw/ide/pci.c -> hw/ide/pci.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: }",
          "60: {",
          "61:     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);",
          "62:     IDEState *s = bmdma_active_if(bm);",
          "",
          "[Removed Lines]",
          "59: static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)",
          "",
          "[Added Lines]",
          "63: static int32_t bmdma_prepare_buf(IDEDMA *dma, int32_t limit)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:             if (bm->cur_prd_last ||",
          "77:                 (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {",
          "79:             }",
          "80:             pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);",
          "81:             bm->cur_addr += 8;",
          "",
          "[Removed Lines]",
          "78:                 return s->io_buffer_size;",
          "",
          "[Added Lines]",
          "82:                 return s->sg.size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90:         }",
          "91:         l = bm->cur_prd_len;",
          "92:         if (l > 0) {",
          "",
          "[Removed Lines]",
          "93:             qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);",
          "",
          "[Added Lines]",
          "97:             uint64_t sg_len;",
          "101:             sg_len = MIN(limit - s->sg.size, bm->cur_prd_len);",
          "102:             if (sg_len) {",
          "103:                 qemu_sglist_add(&s->sg, bm->cur_prd_addr, sg_len);",
          "104:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-20014",
  "cve_desc": "In pam_tacplus.c in pam_tacplus before 1.4.1, pam_sm_acct_mgmt does not zero out the arep data structure.",
  "repo": "kravietz/pam_tacplus",
  "patch_hash": "e4c00eba70a0f72c4de77b5f072c69708ec2beab",
  "patch_info": {
    "commit_hash": "e4c00eba70a0f72c4de77b5f072c69708ec2beab",
    "repo": "kravietz/pam_tacplus",
    "commit_url": "https://github.com/kravietz/pam_tacplus/commit/e4c00eba70a0f72c4de77b5f072c69708ec2beab",
    "files": [
      "pam_tacplus.c"
    ],
    "message": "zero the arep structure (Coverity #115822)",
    "before_after_code_files": [
      "pam_tacplus.c||pam_tacplus.c"
    ]
  },
  "patch_diff": {
    "pam_tacplus.c||pam_tacplus.c": [
      "File: pam_tacplus.c -> pam_tacplus.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "516:     int tac_fd;",
      "518:     user = tty = r_addr = NULL;",
      "521:        this should be normally performed by pam_get_item(PAM_SERVICE)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "519:     memset(&arep, 0, sizeof(arep));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "87a678a7ce94b7d6cd22e2e57523b638b2811d06",
      "candidate_info": {
        "commit_hash": "87a678a7ce94b7d6cd22e2e57523b638b2811d06",
        "repo": "kravietz/pam_tacplus",
        "commit_url": "https://github.com/kravietz/pam_tacplus/commit/87a678a7ce94b7d6cd22e2e57523b638b2811d06",
        "files": [
          "libtac/include/libtac.h",
          "libtac/lib/authen_s.c",
          "libtac/lib/author_r.c",
          "libtac/lib/author_s.c",
          "libtac/lib/cont_s.c",
          "libtac/lib/md5.c",
          "libtac/lib/md5.h",
          "libtac/lib/read_wait.c",
          "libtac/lib/xalloc.c",
          "pam_tacplus.c",
          "pam_tacplus.h",
          "tacc.c"
        ],
        "message": "source formatting",
        "before_after_code_files": [
          "libtac/include/libtac.h||libtac/include/libtac.h",
          "libtac/lib/authen_s.c||libtac/liauthen_s.c",
          "libtac/lib/author_r.c||libtac/liauthor_r.c",
          "libtac/lib/author_s.c||libtac/liauthor_s.c",
          "libtac/lib/cont_s.c||libtac/licont_s.c",
          "libtac/lib/md5.c||libtac/limd5.c",
          "libtac/lib/md5.h||libtac/limd5.h",
          "libtac/lib/read_wait.c||libtac/liread_wait.c",
          "libtac/lib/xalloc.c||libtac/lixalloc.c",
          "pam_tacplus.c||pam_tacplus.c",
          "pam_tacplus.h||pam_tacplus.h",
          "tacc.c||tacc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pam_tacplus.c||pam_tacplus.c"
          ],
          "candidate": [
            "pam_tacplus.c||pam_tacplus.c"
          ]
        }
      },
      "candidate_diff": {
        "libtac/include/libtac.h||libtac/include/libtac.h": [
          "File: libtac/include/libtac.h -> libtac/include/libtac.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: #endif",
          "69: struct tac_attrib {",
          "73: };",
          "75: struct areply {",
          "81: };",
          "83: #ifndef TAC_PLUS_MAXSERVERS",
          "",
          "[Removed Lines]",
          "70:     char *attr;",
          "71:     u_char attr_len;",
          "72:     struct tac_attrib *next;",
          "76:     struct tac_attrib *attr;",
          "77:     char *msg;",
          "78:     int status : 8;",
          "79:     int flags : 8;",
          "80:     int seq_no : 8;",
          "",
          "[Added Lines]",
          "70:  char *attr;",
          "71:  u_char attr_len;",
          "72:  struct tac_attrib *next;",
          "76:  struct tac_attrib *attr;",
          "77:  char *msg;",
          "78:  int status :8;",
          "79:  int flags :8;",
          "80:  int seq_no :8;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "136: extern int tac_timeout;",
          "138: int tac_connect(struct addrinfo **, char **, int);",
          "140: char *tac_ntop(const struct sockaddr *);",
          "144: int tac_authen_read(int, struct areply *);",
          "145: int tac_cont_send_seq(int, char *, int);",
          "146: #define tac_cont_send(fd, pass) tac_cont_send_seq((fd), (pass), 3)",
          "",
          "[Removed Lines]",
          "139: int tac_connect_single(const struct addrinfo *, const char *, struct addrinfo *, int);",
          "142: int tac_authen_send(int, const char *, const char *, const char *,",
          "143:     const char *, u_char);",
          "",
          "[Added Lines]",
          "139: int tac_connect_single(const struct addrinfo *, const char *, struct addrinfo *,",
          "140:   int);",
          "143: int tac_authen_send(int, const char *, const char *, const char *, const char *,",
          "144:   u_char);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150: void tac_add_attrib(struct tac_attrib **, char *, char *);",
          "151: void tac_free_attrib(struct tac_attrib **);",
          "152: char *tac_acct_flag2str(int);",
          "155: int tac_acct_read(int, struct areply *);",
          "156: void *xcalloc(size_t, size_t);",
          "157: void *xrealloc(void *, size_t);",
          "158: char *xstrcpy(char *, const char *, size_t);",
          "159: char *_tac_check_header(HDR *, int);",
          "162: int tac_author_read(int, struct areply *);",
          "165: int tac_read_wait(int, int, int, int *);",
          "",
          "[Removed Lines]",
          "153: int tac_acct_send(int, int, const char *, char *, char *,",
          "154:     struct tac_attrib *);",
          "160: int tac_author_send(int, const char *, char *, char *,",
          "161:     struct tac_attrib *);",
          "163: void tac_add_attrib_pair(struct tac_attrib **, char *, char,",
          "164:     char *);",
          "",
          "[Added Lines]",
          "154: int tac_acct_send(int, int, const char *, char *, char *, struct tac_attrib *);",
          "160: int tac_author_send(int, const char *, char *, char *, struct tac_attrib *);",
          "162: void tac_add_attrib_pair(struct tac_attrib **, char *, char, char *);",
          "",
          "---------------"
        ],
        "libtac/lib/authen_s.c||libtac/liauthen_s.c": [
          "File: libtac/lib/authen_s.c -> libtac/liauthen_s.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #ifdef HAVE_CONFIG_H",
          "24: #endif",
          "26: #include \"libtac.h\"",
          "",
          "[Removed Lines]",
          "23:   #include \"config.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: int tac_authen_send(int fd, const char *user, const char *pass, const char *tty,",
          "84: #if defined(HAVE_OPENSSL_MD5_H) && defined(HAVE_LIBCRYPTO)",
          "86:   MD5_Update(&mdcontext, mdp, mdp_len);",
          "87:   MD5_Final((u_char *) digest, &mdcontext);",
          "88: #else",
          "",
          "[Removed Lines]",
          "49:     const char *r_addr, u_char action) {",
          "53:     int user_len, port_len, chal_len, mdp_len, token_len, bodylength, w;",
          "54:     int r_addr_len;",
          "55:     int pkt_len = 0;",
          "56:     int ret = 0;",
          "57:     char *chal = \"1234123412341234\";",
          "58:     char digest[MD5_LEN];",
          "59:     char *token = NULL;",
          "60:     u_char *pkt = NULL, *mdp = NULL;",
          "61:     MD5_CTX mdcontext;",
          "63:     th=_tac_req_header(TAC_PLUS_AUTHEN, 0);",
          "66:     if (!strcmp(tac_login,\"login\")) {",
          "67:         th->version = TAC_PLUS_VER_0;",
          "68:     } else {",
          "69:         th->version = TAC_PLUS_VER_1;",
          "70:     }",
          "71:     th->encryption = tac_encryption ? TAC_PLUS_ENCRYPTED_FLAG : TAC_PLUS_UNENCRYPTED_FLAG;",
          "73:     TACDEBUG((LOG_DEBUG, \"%s: user '%s', tty '%s', rem_addr '%s', encrypt: %s\", \\",
          "74:         __FUNCTION__, user, tty, r_addr, \\",
          "75:         (tac_encryption) ? \"yes\" : \"no\"))",
          "77:     if (!strcmp(tac_login,\"chap\")) {",
          "78:         chal_len = strlen(chal);",
          "79:         mdp_len = sizeof(u_char) + strlen(pass) + chal_len;",
          "80:         mdp = (u_char *) xcalloc(1, mdp_len);",
          "81:         mdp[0] = 5;",
          "82:         memcpy(&mdp[1], pass, strlen(pass));",
          "83:         memcpy(mdp + strlen(pass) + 1, chal, chal_len);",
          "85:         MD5_Init(&mdcontext);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90:   MD5Update(&mdcontext, mdp, mdp_len);",
          "91:   MD5Final((u_char *) digest, &mdcontext);",
          "92: #endif",
          "",
          "[Removed Lines]",
          "93:         free(mdp);",
          "94:         token = (char*) xcalloc(1, sizeof(u_char) + 1 + chal_len + MD5_LEN);",
          "95:         token[0] = 5;",
          "96:         memcpy(&token[1], chal, chal_len);",
          "97:         memcpy(token + chal_len + 1, digest, MD5_LEN);",
          "98:     } else {",
          "99:         token = xstrdup(pass);",
          "100:     }",
          "103:     user_len = strlen(user);",
          "104:     port_len = strlen(tty);",
          "105:     r_addr_len = strlen(r_addr);",
          "106:     token_len = strlen(token);",
          "109:     tb.action = action;",
          "110:     tb.priv_lvl = tac_priv_lvl;",
          "111:     if (!*tac_login) {",
          "113:         tb.authen_type = TAC_PLUS_AUTHEN_CHPASS == action ? TAC_PLUS_AUTHEN_TYPE_ASCII : TAC_PLUS_AUTHEN_TYPE_PAP;",
          "114:     } else {",
          "115:         if (!strcmp(tac_login,\"chap\")) {",
          "116:             tb.authen_type = TAC_PLUS_AUTHEN_TYPE_CHAP;",
          "117:         } else if (!strcmp(tac_login,\"login\")) {",
          "118:             tb.authen_type = TAC_PLUS_AUTHEN_TYPE_ASCII;",
          "119:         } else {",
          "120:             tb.authen_type = TAC_PLUS_AUTHEN_TYPE_PAP;",
          "121:         }",
          "122:     }",
          "123:     tb.service = tac_authen_service;",
          "124:     tb.user_len = user_len;",
          "125:     tb.port_len = port_len;",
          "127:     tb.data_len = token_len;",
          "130:     bodylength = sizeof(tb) + user_len",
          "131:         + port_len + r_addr_len + token_len;",
          "133:     th->datalength = htonl(bodylength);",
          "136:     w = write(fd, th, TAC_PLUS_HDR_SIZE);",
          "137:     if (w < 0 || w < TAC_PLUS_HDR_SIZE) {",
          "138:         TACSYSLOG((LOG_ERR,\\",
          "139:             \"%s: short write on header, wrote %d of %d: %m\",\\",
          "140:             __FUNCTION__, w, TAC_PLUS_HDR_SIZE))",
          "141:         free(token);",
          "142:         free(pkt);",
          "143:         free(th);",
          "144:         return LIBTAC_STATUS_WRITE_ERR;",
          "145:     }",
          "148:     pkt = (u_char *) xcalloc(1, bodylength+10);",
          "151:     pkt_len += sizeof(tb);",
          "153:     pkt_len += user_len;",
          "155:     pkt_len += port_len;",
          "157:     pkt_len += r_addr_len;",
          "160:     pkt_len += token_len;",
          "163:     if (pkt_len != bodylength) {",
          "164:         TACSYSLOG((LOG_ERR, \"%s: bodylength %d != pkt_len %d\",\\",
          "165:             __FUNCTION__, bodylength, pkt_len))",
          "166:         free(token);",
          "167:         free(pkt);",
          "168:         free(th);",
          "169:         return LIBTAC_STATUS_ASSEMBLY_ERR;",
          "170:     }",
          "173:     _tac_crypt(pkt, th, bodylength);",
          "175:     w = write(fd, pkt, pkt_len);",
          "176:     if (w < 0 || w < pkt_len) {",
          "177:         TACSYSLOG((LOG_ERR,\\",
          "178:             \"%s: short write on body, wrote %d of %d: %m\",\\",
          "179:             __FUNCTION__, w, pkt_len))",
          "180:         ret = LIBTAC_STATUS_WRITE_ERR;",
          "181:     }",
          "183:     free(token);",
          "184:     free(pkt);",
          "185:     free(th);",
          "186:     TACDEBUG((LOG_DEBUG, \"%s: exit status=%d\", __FUNCTION__, ret))",
          "187:     return ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libtac/lib/author_r.c||libtac/liauthor_r.c": [
          "File: libtac/lib/author_r.c -> libtac/liauthor_r.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"messages.h\"",
          "",
          "[Removed Lines]",
          "27:     1. status (granted/denied)",
          "28:     2. message for the user",
          "29:     3. list of attributes returned by server",
          "30:    The attributes should be applied to service authorization",
          "31:    is requested for.",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41: int tac_author_read(int fd, struct areply *re) {",
          "48:  int timeleft = 0;",
          "208:   for (unsigned int r = 0; r < tb->arg_cnt && r < TAC_PLUS_MAX_ARGCOUNT;",
          "209:     r++) {",
          "264: }",
          "",
          "[Removed Lines]",
          "42:     HDR th;",
          "43:     struct author_reply *tb = NULL;",
          "44:     size_t len_from_header, len_from_body;",
          "45:     ssize_t packet_read;",
          "46:     u_char *pktp = NULL;",
          "47:     char *msg = NULL;",
          "49:     re->msg = NULL;",
          "51:     bzero(re, sizeof(struct areply));",
          "52:     if (tac_readtimeout_enable &&",
          "53:         tac_read_wait(fd,tac_timeout*1000,TAC_PLUS_HDR_SIZE,&timeleft) < 0 ) {",
          "55:         TACSYSLOG((LOG_ERR,\\",
          "56:             \"%s: reply timeout after %u secs\", __FUNCTION__, tac_timeout))",
          "57:         re->msg = xstrdup(author_syserr_msg);",
          "58:         re->status = LIBTAC_STATUS_READ_TIMEOUT;",
          "59:         free(tb);",
          "60:         return re->status;",
          "61:     }",
          "63:     packet_read = read(fd, &th, TAC_PLUS_HDR_SIZE);",
          "64:     if(packet_read < TAC_PLUS_HDR_SIZE) {",
          "65:         TACSYSLOG((LOG_ERR,\\",
          "66:             \"%s: short reply header, read %zd of %d: %m\", __FUNCTION__,\\",
          "67:             packet_read, TAC_PLUS_HDR_SIZE))",
          "68:         re->msg = xstrdup(author_syserr_msg);",
          "69:         re->status = LIBTAC_STATUS_SHORT_HDR;",
          "70:         free(tb);",
          "71:         return re->status;",
          "72:     }",
          "75:     msg = _tac_check_header(&th, TAC_PLUS_AUTHOR);",
          "76:     if (msg != NULL) {",
          "78:         re->msg = xstrdup(msg);",
          "79:         re->status = LIBTAC_STATUS_PROTOCOL_ERR;",
          "80:         free(tb);",
          "81:         return re->status;",
          "82:     }",
          "84:     len_from_header = ntohl(th.datalength);",
          "85:     if (len_from_header > TAC_PLUS_MAX_PACKET_SIZE) {",
          "86:         TACSYSLOG((LOG_ERR,\\",
          "87:             \"%s: length declared in the packet %zu exceeds max packet size %d\",\\",
          "88:             __FUNCTION__,\\",
          "89:             len_from_header, TAC_PLUS_MAX_PACKET_SIZE))",
          "90:         re->status = LIBTAC_STATUS_PROTOCOL_ERR;",
          "91:         free(tb);",
          "92:         return re->status;",
          "93:     }",
          "94:     tb = (struct author_reply *) xcalloc(1, len_from_header);",
          "97:     if (tac_readtimeout_enable &&",
          "98:         tac_read_wait(fd,timeleft,len_from_header,NULL) < 0 ) {",
          "100:         TACSYSLOG((LOG_ERR,\\",
          "101:             \"%s: reply timeout after %u secs\", __FUNCTION__, tac_timeout))",
          "102:         re->msg = xstrdup(author_syserr_msg);",
          "103:         re->status = LIBTAC_STATUS_READ_TIMEOUT;",
          "104:         free(tb);",
          "105:         return re->status;",
          "106:     }",
          "107:     packet_read = read(fd, tb, len_from_header);",
          "108:     if (packet_read < len_from_header) {",
          "109:         TACSYSLOG((LOG_ERR,\\",
          "110:             \"%s: short reply body, read %zd of %zu\", __FUNCTION__,\\",
          "111:             packet_read, len_from_header))",
          "112:         re->msg = xstrdup(author_syserr_msg);",
          "113:         re->status = LIBTAC_STATUS_SHORT_BODY;",
          "114:         free(tb);",
          "115:         return re->status;",
          "116:     }",
          "119:     _tac_crypt((u_char *) tb, &th, len_from_header);",
          "122:     tb->msg_len  = ntohs(tb->msg_len);",
          "123:     tb->data_len = ntohs(tb->data_len);",
          "129:     len_from_body = TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE +",
          "130:         tb->msg_len + tb->data_len;",
          "132:     pktp = (u_char *) tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE;",
          "135:     for (unsigned int r = 0; r < tb->arg_cnt && r < TAC_PLUS_MAX_ARGCOUNT; r++) {",
          "136:         if (len_from_body > packet_read || ((void *)pktp - (void *) tb) > packet_read) {",
          "137:             TACSYSLOG((LOG_ERR,\\",
          "138:                 \"%s: arguments supplied in packet seem to exceed its size\",\\",
          "139:                 __FUNCTION__))",
          "140:             re->msg = xstrdup(protocol_err_msg);",
          "141:             re->status = LIBTAC_STATUS_PROTOCOL_ERR;",
          "142:             free(tb);",
          "143:             return re->status;",
          "144:         }",
          "147:         pktp++;",
          "148:     }",
          "150:     if(len_from_header != len_from_body) {",
          "151:         TACSYSLOG((LOG_ERR,\\",
          "152:             \"%s: inconsistent reply body, incorrect key?\",\\",
          "153:             __FUNCTION__))",
          "154:         re->msg = xstrdup(protocol_err_msg);",
          "155:         re->status = LIBTAC_STATUS_PROTOCOL_ERR;",
          "156:         free(tb);",
          "157:         return re->status;",
          "158:     }",
          "162:     if(tb->msg_len) {",
          "163:         char *msg = (char *) xcalloc(1, tb->msg_len+1);",
          "164:         bcopy((u_char *) tb+TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE",
          "165:             + (tb->arg_cnt)*sizeof(u_char),",
          "166:             msg, tb->msg_len);",
          "167:         msg[(int) tb->msg_len] = '\\0';",
          "169:     }",
          "172:     if(tb->data_len) {",
          "173:         char *smsg=(char *) xcalloc(1, tb->data_len+1);",
          "174:         bcopy((u_char *) tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE",
          "175:             + (tb->arg_cnt)*sizeof(u_char)",
          "176:             + tb->msg_len, smsg,",
          "177:             tb->data_len);",
          "178:         smsg[(int) tb->data_len] = '\\0';",
          "179:         TACSYSLOG((LOG_ERR, \"%s: reply message: %s\", __FUNCTION__,smsg))",
          "180:         free(smsg);",
          "181:     }",
          "183:     TACDEBUG((LOG_DEBUG, \"%s: authorization reply status=%d\",\\",
          "184:         __FUNCTION__, tb->status));",
          "187:     switch(tb->status) {",
          "190:         case TAC_PLUS_AUTHOR_STATUS_PASS_REPL:",
          "191:             tac_free_attrib(&re->attr);",
          "193:         case TAC_PLUS_AUTHOR_STATUS_PASS_ADD:",
          "194:             {",
          "195:                 u_char *argp;",
          "197:                 if(!re->msg) re->msg=xstrdup(author_ok_msg);",
          "198:                     re->status=tb->status;",
          "202:                 pktp = (u_char *) tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE;",
          "203:                 argp = pktp + (tb->arg_cnt * sizeof(u_char)) + tb->msg_len +",
          "204:                     tb->data_len;",
          "205:                 TACSYSLOG((LOG_DEBUG, \"Args cnt %d\", tb->arg_cnt));",
          "210:                     unsigned char buff[256];",
          "211:                     unsigned char *sep;",
          "212:                     unsigned",
          "213:      char *value;",
          "214:                     unsigned char sepchar = '=';",
          "216:                     bcopy(argp, buff, (int)*pktp);",
          "217:                     buff[(int)*pktp] = '\\0';",
          "218:                     sep = strchr(buff, '=');",
          "219:                 if ( sep == NULL ) {",
          "220:                     sep = strchr(buff, '*');",
          "221:                 }",
          "222:                 if(sep == NULL) {",
          "223:                     TACSYSLOG((LOG_WARNING,\\",
          "224:                         \"AUTHOR_STATUS_PASS_ADD/REPL: av pair does not contain a separator: %s\",\\",
          "225:                         buff))",
          "228:                     value = \"\";",
          "229:                 } else {",
          "230:                     sepchar = *sep;",
          "232:                     value = ++sep;",
          "235:                 }",
          "236:                 TACSYSLOG((LOG_DEBUG, \"Adding buf/value pair (%s,%s)\", buff, value));",
          "237:                 tac_add_attrib_pair(&re->attr, buff, sepchar, value);",
          "238:                 argp += *pktp;",
          "239:                 pktp++;",
          "240:             }",
          "241:         }",
          "242:         free(tb);",
          "243:         return re->status;",
          "244:         break;",
          "245:     }",
          "247:     switch (tb->status) {",
          "250:         case TAC_PLUS_AUTHOR_STATUS_FOLLOW:",
          "251:         case TAC_PLUS_AUTHOR_STATUS_FAIL:",
          "252:             if(!re->msg) re->msg = xstrdup(author_fail_msg);",
          "253:             re->status=TAC_PLUS_AUTHOR_STATUS_FAIL;",
          "254:             break;",
          "256:         case TAC_PLUS_AUTHOR_STATUS_ERROR:",
          "257:         default:",
          "258:             if(!re->msg) re->msg = xstrdup(author_err_msg);",
          "259:             re->status=TAC_PLUS_AUTHOR_STATUS_ERROR;",
          "260:     }",
          "262:     free(tb);",
          "263:     return re->status;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libtac/lib/author_s.c||libtac/liauthor_s.c": [
          "File: libtac/lib/author_s.c -> libtac/liauthor_s.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"xalloc.h\"",
          "",
          "[Removed Lines]",
          "26:    specified in attribute list prepared with tac_add_attrib.",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35: int tac_author_send(int fd, const char *user, char *tty, char *r_addr,",
          "112:     pktp = pkt + pkt_len; \\",
          "113:     pkt_len += len; \\",
          "114:     pkt = xrealloc(pkt, pkt_len); \\",
          "115:     bcopy(data, pktp, len);",
          "118: #define PUTATTR(data, len) \\",
          "119:     pktl = pkt_len; \\",
          "",
          "[Removed Lines]",
          "36:     struct tac_attrib *attr) {",
          "38:     HDR *th;",
          "39:     struct author tb;",
          "40:     u_char user_len, port_len, r_addr_len;",
          "41:     struct tac_attrib *a;",
          "48:     int ret = 0;",
          "50:     th=_tac_req_header(TAC_PLUS_AUTHOR, 0);",
          "53:     th->version=TAC_PLUS_VER_0;",
          "54:     th->encryption=tac_encryption ? TAC_PLUS_ENCRYPTED_FLAG : TAC_PLUS_UNENCRYPTED_FLAG;",
          "56:     TACDEBUG((LOG_DEBUG, \"%s: user '%s', tty '%s', rem_addr '%s', encrypt: %s\", \\",
          "57:         __FUNCTION__, user, \\",
          "58:         tty, r_addr, tac_encryption ? \"yes\" : \"no\"))",
          "60:     user_len = (u_char) strlen(user);",
          "61:     port_len = (u_char) strlen(tty);",
          "62:     r_addr_len = (u_char) strlen(r_addr);",
          "64:     tb.authen_method = tac_authen_method;",
          "65:     tb.priv_lvl = tac_priv_lvl;",
          "66:     if (!*tac_login) {",
          "68:         tb.authen_type = TAC_PLUS_AUTHEN_TYPE_PAP;",
          "69:     } else {",
          "70:         if (strcmp(tac_login,\"chap\") == 0) {",
          "71:             tb.authen_type = TAC_PLUS_AUTHEN_TYPE_CHAP;",
          "72:         } else if (strcmp(tac_login,\"login\") == 0) {",
          "73:             tb.authen_type = TAC_PLUS_AUTHEN_TYPE_ASCII;",
          "74:         } else {",
          "75:             tb.authen_type = TAC_PLUS_AUTHEN_TYPE_PAP;",
          "76:         }",
          "77:     }",
          "78:     tb.service = tac_authen_service;",
          "79:     tb.user_len = user_len;",
          "80:     tb.port_len = port_len;",
          "81:     tb.r_addr_len = r_addr_len;",
          "84:     pkt = (u_char *) xcalloc(1, TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE);",
          "85:     pkt_len = sizeof(tb);",
          "88:     a = attr;",
          "89:     while (a) {",
          "90:         pktl = pkt_len;",
          "91:         pkt_len += sizeof(a->attr_len);",
          "92:         pkt = (u_char*) xrealloc(pkt, pkt_len);",
          "95:            with each call",
          "96:         pktp=pkt + pkt_len;",
          "97:         pkt_len += sizeof(a->attr_len);",
          "98:         pkt = xrealloc(pkt, pkt_len);",
          "101:         bcopy(&a->attr_len, pkt + pktl, sizeof(a->attr_len));",
          "102:         i++;",
          "104:         a = a->next;",
          "105:     }",
          "108:     tb.arg_cnt = i;",
          "109:     bcopy(&tb, pkt, TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE);",
          "111: #define PUTATTR(data, len) \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "121:     pkt = (u_char*) xrealloc(pkt, pkt_len); \\",
          "122:     bcopy(data, pkt + pktl, len);",
          "168: }",
          "",
          "[Removed Lines]",
          "125:     PUTATTR(user, user_len)",
          "126:     PUTATTR(tty, port_len)",
          "127:     PUTATTR(r_addr, r_addr_len)",
          "130:     a = attr;",
          "131:     while (a) {",
          "132:         PUTATTR(a->attr, a->attr_len)",
          "134:         a = a->next;",
          "135:     }",
          "138:     th->datalength = htonl(pkt_len);",
          "141:     w = write(fd, th, TAC_PLUS_HDR_SIZE);",
          "143:     if (w < TAC_PLUS_HDR_SIZE) {",
          "144:         TACSYSLOG((LOG_ERR,\\",
          "145:             \"%s: short write on header, wrote %d of %d: %m\",\\",
          "146:             __FUNCTION__, w, TAC_PLUS_HDR_SIZE))",
          "147:         free(pkt);",
          "148:         free(th);",
          "149:         return LIBTAC_STATUS_WRITE_ERR;",
          "150:     }",
          "153:     _tac_crypt(pkt, th, pkt_len);",
          "156:     w = write(fd, pkt, pkt_len);",
          "157:     if (w < pkt_len) {",
          "158:         TACSYSLOG((LOG_ERR,\\",
          "159:             \"%s: short write on body, wrote %d of %d: %m\",\\",
          "160:             __FUNCTION__, w, pkt_len))",
          "161:         ret = LIBTAC_STATUS_WRITE_ERR;",
          "162:     }",
          "164:     free(pkt);",
          "165:     free(th);",
          "166:     TACDEBUG((LOG_DEBUG, \"%s: exit status=%d\", __FUNCTION__, ret))",
          "167:     return ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libtac/lib/cont_s.c||libtac/licont_s.c": [
          "File: libtac/lib/cont_s.c -> libtac/licont_s.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: int tac_cont_send_seq(int fd, char *pass, int seq) {",
          "",
          "[Removed Lines]",
          "37:     int pass_len, bodylength, w;",
          "38:     int pkt_len = 0;",
          "39:     int ret = 0;",
          "40:     u_char *pkt = NULL;",
          "42:     th = _tac_req_header(TAC_PLUS_AUTHEN, 1);",
          "45:     th->version = TAC_PLUS_VER_0;",
          "47:     th->encryption = tac_encryption ? TAC_PLUS_ENCRYPTED_FLAG : TAC_PLUS_UNENCRYPTED_FLAG;",
          "50:     pass_len = strlen(pass);",
          "53:     tb.user_msg_len = htons(pass_len);",
          "54:     tb.user_data_len = tb.flags = 0;",
          "57:     bodylength = TAC_AUTHEN_CONT_FIXED_FIELDS_SIZE+0+pass_len;",
          "59:     th->datalength = htonl(bodylength);",
          "62:     w = write(fd, th, TAC_PLUS_HDR_SIZE);",
          "63:     if (w < 0 || w < TAC_PLUS_HDR_SIZE) {",
          "64:         TACSYSLOG((LOG_ERR, \"%s: short write on header, wrote %d of %d: %m\",\\",
          "65:             __FUNCTION__, w, TAC_PLUS_HDR_SIZE))",
          "66:         free(pkt);",
          "67:         free(th);",
          "68:         return LIBTAC_STATUS_WRITE_ERR;",
          "69:     }",
          "72:     pkt = (u_char *) xcalloc(1, bodylength);",
          "75:     pkt_len += TAC_AUTHEN_CONT_FIXED_FIELDS_SIZE;",
          "77:     pkt_len += pass_len;",
          "80:     if (pkt_len != bodylength) {",
          "81:         TACSYSLOG((LOG_ERR,\\",
          "82:             \"%s: bodylength %d != pkt_len %d\",\\",
          "83:             __FUNCTION__, bodylength, pkt_len))",
          "84:         free(pkt);",
          "85:         free(th);",
          "86:         return LIBTAC_STATUS_ASSEMBLY_ERR;",
          "87:     }",
          "90:     _tac_crypt(pkt, th, bodylength);",
          "92:     w = write(fd, pkt, pkt_len);",
          "93:     if (w < 0 || w < pkt_len) {",
          "94:         TACSYSLOG((LOG_ERR,\\",
          "95:             \"%s: short write on body, wrote %d of %d: %m\",\\",
          "96:             __FUNCTION__, w, pkt_len))",
          "97:         ret=LIBTAC_STATUS_WRITE_ERR;",
          "98:     }",
          "100:     free(pkt);",
          "101:     free(th);",
          "102:     TACDEBUG((LOG_DEBUG, \"%s: exit status=%d\", __FUNCTION__, ret))",
          "103:     return ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libtac/lib/md5.c||libtac/limd5.c": [
          "File: libtac/lib/md5.c -> libtac/limd5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #ifdef HAVE_CONFIG_H",
          "23: #endif",
          "",
          "[Removed Lines]",
          "22:   #include \"config.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: static void Transform __P((UINT4 *buf, UINT4 *in));",
          "34: static unsigned char PADDING[64] = {",
          "43: };",
          "",
          "[Removed Lines]",
          "35:     0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "36:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "37:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "38:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "39:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "40:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "41:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "42:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81: #endif",
          "86: void MD5Init (MD5_CTX *mdContext) {",
          "94: }",
          "100: void MD5Update ( MD5_CTX *mdContext, unsigned char *inBuf,",
          "131: }",
          "136: void MD5Final (unsigned char hash[], MD5_CTX *mdContext) {",
          "172: }",
          "176: static void Transform ( UINT4 *buf, UINT4 *in) {",
          "180: #define S11 7",
          "181: #define S12 12",
          "182: #define S13 17",
          "183: #define S14 22",
          "202: #define S21 5",
          "203: #define S22 9",
          "204: #define S23 14",
          "205: #define S24 20",
          "224: #define S31 4",
          "225: #define S32 11",
          "226: #define S33 16",
          "227: #define S34 23",
          "246: #define S41 6",
          "247: #define S42 10",
          "248: #define S43 15",
          "249: #define S44 21",
          "271: }",
          "273: #endif",
          "",
          "[Removed Lines]",
          "84:    mdContext. All fields are set to zero.",
          "87:     mdContext->i[0] = mdContext->i[1] = (UINT4)0;",
          "90:     mdContext->buf[0] = (UINT4)0x67452301;",
          "91:     mdContext->buf[1] = (UINT4)0xefcdab89;",
          "92:     mdContext->buf[2] = (UINT4)0x98badcfe;",
          "93:     mdContext->buf[3] = (UINT4)0x10325476;",
          "97:    account for the presence of each of the characters inBuf[0..inLen-1]",
          "98:    in the message whose digest is being computed.",
          "101:     unsigned int inLen) {",
          "103:     UINT4 in[16];",
          "104:     int mdi;",
          "105:     unsigned int i, ii;",
          "108:     mdi = (int)((mdContext->i[0] >> 3) & 0x3F);",
          "111:     if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])",
          "112:         mdContext->i[1]++;",
          "113:     mdContext->i[0] += ((UINT4)inLen << 3);",
          "114:     mdContext->i[1] += ((UINT4)inLen >> 29);",
          "116:     while (inLen--) {",
          "118:         mdContext->in[mdi++] = *inBuf++;",
          "121:         if (mdi == 0x40) {",
          "122:             for (i = 0, ii = 0; i < 16; i++, ii += 4)",
          "123:                 in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |",
          "124:                     (((UINT4)mdContext->in[ii+2]) << 16) |",
          "125:                     (((UINT4)mdContext->in[ii+1]) << 8) |",
          "126:                     ((UINT4)mdContext->in[ii]);",
          "127:             Transform (mdContext->buf, in);",
          "128:             mdi = 0;",
          "129:         }",
          "130:     }",
          "134:    ends with the desired message digest in mdContext->digest[0...15].",
          "137:     UINT4 in[16];",
          "138:     int mdi;",
          "139:     unsigned int i, ii;",
          "140:     unsigned int padLen;",
          "143:     in[14] = mdContext->i[0];",
          "144:     in[15] = mdContext->i[1];",
          "147:     mdi = (int)((mdContext->i[0] >> 3) & 0x3F);",
          "150:     padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);",
          "151:     MD5Update (mdContext, PADDING, padLen);",
          "154:     for (i = 0, ii = 0; i < 14; i++, ii += 4)",
          "155:         in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |",
          "156:             (((UINT4)mdContext->in[ii+2]) << 16) |",
          "157:             (((UINT4)mdContext->in[ii+1]) << 8) |",
          "158:             ((UINT4)mdContext->in[ii]);",
          "159:         Transform (mdContext->buf, in);",
          "162:     for (i = 0, ii = 0; i < 4; i++, ii += 4) {",
          "163:         mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);",
          "164:         mdContext->digest[ii+1] =",
          "165:             (unsigned char)((mdContext->buf[i] >> 8) & 0xFF);",
          "166:         mdContext->digest[ii+2] =",
          "167:             (unsigned char)((mdContext->buf[i] >> 16) & 0xFF);",
          "168:         mdContext->digest[ii+3] =",
          "169:             (unsigned char)((mdContext->buf[i] >> 24) & 0xFF);",
          "170:     }",
          "171:     memcpy(hash, mdContext->digest, 16);",
          "177:     UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];",
          "267:     buf[0] += a;",
          "268:     buf[1] += b;",
          "269:     buf[2] += c;",
          "270:     buf[3] += d;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libtac/lib/md5.h||libtac/limd5.h": [
          "File: libtac/lib/md5.h -> libtac/limd5.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: typedef struct {",
          "34: } MD5_CTX;",
          "36: __BEGIN_DECLS",
          "40: __END_DECLS",
          "42: #define MD5_LEN 16",
          "",
          "[Removed Lines]",
          "37: void MD5Init __P((MD5_CTX*));",
          "38: void MD5Update __P((MD5_CTX*, unsigned char*, UINT4));",
          "39: void MD5Final __P((unsigned char[], MD5_CTX*));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libtac/lib/read_wait.c||libtac/liread_wait.c": [
          "File: libtac/lib/read_wait.c -> libtac/liread_wait.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #endif",
          "33: static int delta_msecs(struct timeval *newer, struct timeval *older) {",
          "51: }",
          "",
          "[Removed Lines]",
          "34:     long deltasecs, deltausecs;",
          "35:     struct timeval now;",
          "37:     if (newer == NULL) {",
          "38:         gettimeofday(&now, NULL);",
          "39:         newer = &now;",
          "40:     }",
          "42:     deltasecs = newer->tv_sec - older->tv_sec;",
          "44:     if ( newer->tv_usec < older->tv_usec ) {",
          "45:         deltasecs--;",
          "46:         deltausecs = (1000000+newer->tv_usec) - older->tv_usec;",
          "47:     } else {",
          "48:         deltausecs = newer->tv_usec - older->tv_usec;",
          "49:     }",
          "50:     return (deltasecs*1000)+(deltausecs/1000);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71: int tac_read_wait(int fd, int timeout, int size, int *time_left) {",
          "",
          "[Removed Lines]",
          "72:     int retval = 0;",
          "73:     int remaining;",
          "74:     struct pollfd fds[1];",
          "76:     struct timeval start;",
          "78:     gettimeofday(&start, NULL);",
          "87:     fds[0].fd = fd;",
          "88:     fds[0].events = POLLIN;",
          "90:     while (remaining > 0) {",
          "91:         int rc;",
          "92:         int avail = 0;",
          "93:         rc = poll(fds, 1, remaining);",
          "94:         remaining -= delta_msecs(NULL, &start);",
          "95:         if ( time_left != NULL ) {",
          "97:         }",
          "101:             retval = -1;",
          "102:             break;",
          "103:         }",
          "107:                 ioctl(fd,FIONREAD,(char*)&avail) == 0 && avail < size) {",
          "109:             } else {",
          "110:                 break;",
          "111:             }",
          "112:         }",
          "115:             continue;",
          "116:         }",
          "119:         retval = errno;",
          "120:         break;",
          "121:     }",
          "122:     return retval;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libtac/lib/xalloc.c||libtac/lixalloc.c": [
          "File: libtac/lib/xalloc.c -> libtac/lixalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"xalloc.h\"",
          "25: void *xcalloc(size_t nmemb, size_t size) {",
          "33: }",
          "35: void *xrealloc(void *ptr, size_t size) {",
          "42: }",
          "44: char *xstrdup(const char *s) {",
          "53: }",
          "59: char *xstrcpy(char *dst, const char *src, size_t dst_size) {",
          "77: }",
          "",
          "[Removed Lines]",
          "26:     void *val = calloc(nmemb, size);",
          "27:     if(val == 0) {",
          "28:         TACSYSLOG((LOG_ERR, \"%s: calloc(%u,%u) failed\", __FUNCTION__,\\",
          "29:             (unsigned) nmemb, (unsigned) size))",
          "30:         exit(1);",
          "31:     }",
          "32:     return val;",
          "36:     void *val = realloc(ptr, size);",
          "37:     if(val == 0) {",
          "38:         TACSYSLOG((LOG_ERR, \"%s: realloc(%u) failed\", __FUNCTION__, (unsigned) size))",
          "39:         exit(1);",
          "40:     }",
          "41:     return val;",
          "45:     char *p;",
          "46:     if (s == NULL) return NULL;",
          "48:     if ( (p = strdup(s)) == NULL ) {",
          "49:         TACSYSLOG((LOG_ERR, \"%s: strdup(%s) failed: %m\", __FUNCTION__, s))",
          "50:         exit(1);",
          "51:     }",
          "52:     return p;",
          "57:     safe string copy that aborts when destination buffer is too small",
          "60:     if (dst == NULL) {",
          "61:         TACSYSLOG((LOG_ERR, \"xstrcpy(): dst == NULL\"));",
          "62:         abort();",
          "63:     }",
          "64:     if (src == NULL) {",
          "65:         TACSYSLOG((LOG_ERR, \"xstrcpy(): src == NULL\"));",
          "66:         abort();",
          "67:     }",
          "68:     if (!dst_size)",
          "69:         return NULL;",
          "71:     if (strlen(src) >= dst_size) {",
          "72:         TACSYSLOG((LOG_ERR, \"xstrcpy(): argument too long, aborting\"));",
          "73:         abort();",
          "74:     }",
          "76:     return strcpy(dst, src);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "pam_tacplus.c||pam_tacplus.c": [
          "File: pam_tacplus.c -> pam_tacplus.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #include <strings.h>",
          "40: #ifdef HAVE_CONFIG_H",
          "42: #endif",
          "44: #if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)",
          "",
          "[Removed Lines]",
          "41:   #include \"config.h\"",
          "",
          "[Added Lines]",
          "41: #include \"config.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: static short int task_id = 0;",
          "58: int _pam_send_account(int tac_fd, int type, const char *user, char *tty,",
          "116: }",
          "210: }",
          "",
          "[Removed Lines]",
          "59:     char *r_addr, char *cmd) {",
          "61:     char buf[64];",
          "62:     struct tac_attrib *attr;",
          "63:     int retval;",
          "65:     attr=(struct tac_attrib *)xcalloc(1, sizeof(struct tac_attrib));",
          "67:     sprintf(buf, \"%lu\", (unsigned long)time(NULL));",
          "69:     if (type == TAC_PLUS_ACCT_FLAG_START) {",
          "70:         tac_add_attrib(&attr, \"start_time\", buf);",
          "71:     } else if (type == TAC_PLUS_ACCT_FLAG_STOP) {",
          "72:         tac_add_attrib(&attr, \"stop_time\", buf);",
          "73:     }",
          "74:     sprintf(buf, \"%hu\", task_id);",
          "75:     tac_add_attrib(&attr, \"task_id\", buf);",
          "76:     tac_add_attrib(&attr, \"service\", tac_service);",
          "77:     if(tac_protocol[0] != '\\0')",
          "78:       tac_add_attrib(&attr, \"protocol\", tac_protocol);",
          "79:     if (cmd != NULL) {",
          "80:         tac_add_attrib(&attr, \"cmd\", cmd);",
          "81:     }",
          "83:     retval = tac_acct_send(tac_fd, type, user, tty, r_addr, attr);",
          "86:     tac_free_attrib(&attr);",
          "88:     if(retval < 0) {",
          "89:         _pam_log (LOG_WARNING, \"%s: send %s accounting failed (task %hu)\",",
          "90:             __FUNCTION__,",
          "91:             tac_acct_flag2str(type),",
          "92:             task_id);",
          "93:         close(tac_fd);",
          "94:         return -1;",
          "95:     }",
          "97:     struct areply re;",
          "98:     if( tac_acct_read(tac_fd, &re) != TAC_PLUS_ACCT_STATUS_SUCCESS ) {",
          "99:         _pam_log (LOG_WARNING, \"%s: accounting %s failed (task %hu)\",",
          "100:             __FUNCTION__,",
          "101:             tac_acct_flag2str(type),",
          "102:             task_id);",
          "104:         if(re.msg != NULL)",
          "105:             free(re.msg);",
          "107:         close(tac_fd);",
          "108:         return -1;",
          "109:     }",
          "111:     if(re.msg != NULL)",
          "112:         free(re.msg);",
          "114:     close(tac_fd);",
          "115:     return 0;",
          "118: int _pam_account(pam_handle_t *pamh, int argc, const char **argv,",
          "119:     int type, char *cmd) {",
          "121:     int retval;",
          "122:     static int ctrl;",
          "123:     char *user = NULL;",
          "124:     char *tty = NULL;",
          "125:     char *r_addr = NULL;",
          "126:     char *typemsg;",
          "127:     int status = PAM_SESSION_ERR;",
          "128:     int srv_i, tac_fd;",
          "130:     typemsg = tac_acct_flag2str(type);",
          "131:     ctrl = _pam_parse (argc, argv);",
          "133:     if (ctrl & PAM_TAC_DEBUG) {",
          "134:         syslog (LOG_DEBUG, \"%s: [%s] called (pam_tacplus v%u.%u.%u)\",",
          "135:             __FUNCTION__, typemsg, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "136:         syslog(LOG_DEBUG, \"%s: tac_srv_no=%d\", __FUNCTION__, tac_srv_no);",
          "137:     }",
          "139:     if ((user = _pam_get_user(pamh)) == NULL)",
          "140:         return PAM_USER_UNKNOWN;",
          "142:     if (ctrl & PAM_TAC_DEBUG)",
          "143:         syslog(LOG_DEBUG, \"%s: username [%s] obtained\", __FUNCTION__, user);",
          "145:     tty = _pam_get_terminal(pamh);",
          "146:     if(!strncmp(tty, \"/dev/\", 5))",
          "147:         tty += 5;",
          "148:     if (ctrl & PAM_TAC_DEBUG)",
          "149:         syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);",
          "151:     r_addr = _pam_get_rhost(pamh);",
          "152:     if (ctrl & PAM_TAC_DEBUG)",
          "153:         syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);",
          "157:     if(*tac_service == '\\0') {",
          "158:         _pam_log (LOG_ERR, \"ACC: TACACS+ service type not configured\");",
          "159:         return PAM_AUTH_ERR;",
          "160:     }",
          "161:     if(*tac_protocol == '\\0') {",
          "162:         _pam_log (LOG_ERR, \"ACC: TACACS+ protocol type not configured (IGNORED)\");",
          "163:     }",
          "166:        application dealing with serial lines, it is likely",
          "167:        that we will get hit with signal caused by modem hangup;",
          "168:        this is important only for STOP packets, it's relatively",
          "170:     if(type == TAC_PLUS_ACCT_FLAG_STOP) {",
          "171:         signal(SIGALRM, SIG_IGN);",
          "172:         signal(SIGCHLD, SIG_IGN);",
          "173:         signal(SIGHUP, SIG_IGN);",
          "174:     }",
          "176:     status = PAM_SESSION_ERR;",
          "177:     for(srv_i = 0; srv_i < tac_srv_no; srv_i++) {",
          "178:         tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);",
          "179:         if (tac_fd < 0) {",
          "180:             _pam_log(LOG_WARNING, \"%s: error sending %s (fd)\",",
          "181:                 __FUNCTION__, typemsg);",
          "182:             continue;",
          "183:         }",
          "184:         if (ctrl & PAM_TAC_DEBUG)",
          "185:             syslog(LOG_DEBUG, \"%s: connected with fd=%d (srv %d)\", __FUNCTION__, tac_fd, srv_i);",
          "187:         retval = _pam_send_account(tac_fd, type, user, tty, r_addr, cmd);",
          "188:         if (retval < 0) {",
          "189:             _pam_log(LOG_WARNING, \"%s: error sending %s (acct)\",",
          "190:                 __FUNCTION__, typemsg);",
          "191:         } else {",
          "192:             status = PAM_SUCCESS;",
          "193:             if (ctrl & PAM_TAC_DEBUG)",
          "194:                 syslog(LOG_DEBUG, \"%s: [%s] for [%s] sent\", __FUNCTION__, typemsg, user);",
          "195:         }",
          "196:         close(tac_fd);",
          "198:         if ((status == PAM_SUCCESS) && !(ctrl & PAM_TAC_ACCT)) {",
          "200:             break;",
          "201:         }",
          "202:     }",
          "204:     if (type == TAC_PLUS_ACCT_FLAG_STOP) {",
          "205:         signal(SIGALRM, SIG_DFL);",
          "206:         signal(SIGCHLD, SIG_DFL);",
          "207:         signal(SIGHUP, SIG_DFL);",
          "208:     }",
          "209:     return status;",
          "",
          "[Added Lines]",
          "58:   char *r_addr, char *cmd) {",
          "60:  char buf[64];",
          "61:  struct tac_attrib *attr;",
          "62:  int retval;",
          "64:  attr = (struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib));",
          "66:  sprintf(buf, \"%lu\", (unsigned long) time(NULL));",
          "68:  if (type == TAC_PLUS_ACCT_FLAG_START) {",
          "69:   tac_add_attrib(&attr, \"start_time\", buf);",
          "70:  } else if (type == TAC_PLUS_ACCT_FLAG_STOP) {",
          "71:   tac_add_attrib(&attr, \"stop_time\", buf);",
          "72:  }",
          "73:  sprintf(buf, \"%hu\", task_id);",
          "74:  tac_add_attrib(&attr, \"task_id\", buf);",
          "75:  tac_add_attrib(&attr, \"service\", tac_service);",
          "76:  if (tac_protocol[0] != '\\0')",
          "77:   tac_add_attrib(&attr, \"protocol\", tac_protocol);",
          "78:  if (cmd != NULL) {",
          "79:   tac_add_attrib(&attr, \"cmd\", cmd);",
          "80:  }",
          "82:  retval = tac_acct_send(tac_fd, type, user, tty, r_addr, attr);",
          "85:  tac_free_attrib(&attr);",
          "87:  if (retval < 0) {",
          "88:   _pam_log(LOG_WARNING, \"%s: send %s accounting failed (task %hu)\",",
          "89:     __FUNCTION__, tac_acct_flag2str(type), task_id);",
          "90:   close(tac_fd);",
          "91:   return -1;",
          "92:  }",
          "94:  struct areply re;",
          "95:  if (tac_acct_read(tac_fd, &re) != TAC_PLUS_ACCT_STATUS_SUCCESS) {",
          "96:   _pam_log(LOG_WARNING, \"%s: accounting %s failed (task %hu)\",",
          "97:     __FUNCTION__, tac_acct_flag2str(type), task_id);",
          "99:   if (re.msg != NULL)",
          "100:    free(re.msg);",
          "102:   close(tac_fd);",
          "103:   return -1;",
          "104:  }",
          "106:  if (re.msg != NULL)",
          "107:   free(re.msg);",
          "109:  close(tac_fd);",
          "110:  return 0;",
          "113: int _pam_account(pam_handle_t *pamh, int argc, const char **argv, int type,",
          "114:   char *cmd) {",
          "116:  int retval;",
          "117:  static int ctrl;",
          "118:  char *user = NULL;",
          "119:  char *tty = NULL;",
          "120:  char *r_addr = NULL;",
          "121:  char *typemsg;",
          "122:  int status = PAM_SESSION_ERR;",
          "123:  int srv_i, tac_fd;",
          "125:  typemsg = tac_acct_flag2str(type);",
          "126:  ctrl = _pam_parse(argc, argv);",
          "128:  if (ctrl & PAM_TAC_DEBUG) {",
          "129:   syslog(LOG_DEBUG, \"%s: [%s] called (pam_tacplus v%u.%u.%u)\",",
          "130:     __FUNCTION__, typemsg, PAM_TAC_VMAJ, PAM_TAC_VMIN,",
          "131:     PAM_TAC_VPAT);",
          "132:   syslog(LOG_DEBUG, \"%s: tac_srv_no=%d\", __FUNCTION__, tac_srv_no);",
          "133:  }",
          "135:  if ((user = _pam_get_user(pamh)) == NULL)",
          "136:   return PAM_USER_UNKNOWN;",
          "138:  if (ctrl & PAM_TAC_DEBUG)",
          "139:   syslog(LOG_DEBUG, \"%s: username [%s] obtained\", __FUNCTION__, user);",
          "141:  tty = _pam_get_terminal(pamh);",
          "142:  if (!strncmp(tty, \"/dev/\", 5))",
          "143:   tty += 5;",
          "144:  if (ctrl & PAM_TAC_DEBUG)",
          "145:   syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);",
          "147:  r_addr = _pam_get_rhost(pamh);",
          "148:  if (ctrl & PAM_TAC_DEBUG)",
          "149:   syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);",
          "153:  if (*tac_service == '\\0') {",
          "154:   _pam_log(LOG_ERR, \"ACC: TACACS+ service type not configured\");",
          "155:   return PAM_AUTH_ERR;",
          "156:  }",
          "157:  if (*tac_protocol == '\\0') {",
          "158:   _pam_log(LOG_ERR,",
          "159:     \"ACC: TACACS+ protocol type not configured (IGNORED)\");",
          "160:  }",
          "163:   application dealing with serial lines, it is likely",
          "164:   that we will get hit with signal caused by modem hangup;",
          "165:   this is important only for STOP packets, it's relatively",
          "167:  if (type == TAC_PLUS_ACCT_FLAG_STOP) {",
          "168:   signal(SIGALRM, SIG_IGN);",
          "169:   signal(SIGCHLD, SIG_IGN);",
          "170:   signal(SIGHUP, SIG_IGN);",
          "171:  }",
          "173:  status = PAM_SESSION_ERR;",
          "174:  for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {",
          "175:   tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key,",
          "176:     NULL, tac_timeout);",
          "177:   if (tac_fd < 0) {",
          "178:    _pam_log(LOG_WARNING, \"%s: error sending %s (fd)\", __FUNCTION__,",
          "179:      typemsg);",
          "180:    continue;",
          "181:   }",
          "182:   if (ctrl & PAM_TAC_DEBUG)",
          "183:    syslog(LOG_DEBUG, \"%s: connected with fd=%d (srv %d)\", __FUNCTION__,",
          "184:      tac_fd, srv_i);",
          "186:   retval = _pam_send_account(tac_fd, type, user, tty, r_addr, cmd);",
          "187:   if (retval < 0) {",
          "188:    _pam_log(LOG_WARNING, \"%s: error sending %s (acct)\", __FUNCTION__,",
          "189:      typemsg);",
          "190:   } else {",
          "191:    status = PAM_SUCCESS;",
          "192:    if (ctrl & PAM_TAC_DEBUG)",
          "193:     syslog(LOG_DEBUG, \"%s: [%s] for [%s] sent\", __FUNCTION__,",
          "194:       typemsg, user);",
          "195:   }",
          "196:   close(tac_fd);",
          "198:   if ((status == PAM_SUCCESS) && !(ctrl & PAM_TAC_ACCT)) {",
          "200:    break;",
          "201:   }",
          "202:  }",
          "204:  if (type == TAC_PLUS_ACCT_FLAG_STOP) {",
          "205:   signal(SIGALRM, SIG_DFL);",
          "206:   signal(SIGCHLD, SIG_DFL);",
          "207:   signal(SIGHUP, SIG_DFL);",
          "208:  }",
          "209:  return status;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "219: PAM_EXTERN",
          "494: PAM_EXTERN",
          "512: PAM_EXTERN",
          "",
          "[Removed Lines]",
          "220: int pam_sm_authenticate (pam_handle_t * pamh, int flags,",
          "221:     int argc, const char **argv) {",
          "223:     int ctrl, retval;",
          "224:     char *user;",
          "225:     char *pass;",
          "226:     char *tty;",
          "227:     char *r_addr;",
          "228:     int srv_i;",
          "229:     int tac_fd, status, msg, communicating;",
          "231:     user = pass = tty = r_addr = NULL;",
          "233:     ctrl = _pam_parse(argc, argv);",
          "235:     if (ctrl & PAM_TAC_DEBUG)",
          "236:         syslog(LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\",",
          "237:             __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "239:     if ((user = _pam_get_user(pamh)) == NULL)",
          "240:         return PAM_USER_UNKNOWN;",
          "242:     if (ctrl & PAM_TAC_DEBUG)",
          "243:         syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);",
          "245:     retval = tacacs_get_password (pamh, flags, ctrl, &pass);",
          "246:     if (retval != PAM_SUCCESS || pass == NULL || *pass == '\\0') {",
          "247:         _pam_log(LOG_ERR, \"unable to obtain password\");",
          "248:         free(pass);",
          "249:         return PAM_CRED_INSUFFICIENT;",
          "250:     }",
          "252:     retval = pam_set_item (pamh, PAM_AUTHTOK, pass);",
          "253:     if (retval != PAM_SUCCESS) {",
          "254:         _pam_log(LOG_ERR, \"unable to set password\");",
          "255:         free(pass);",
          "256:         return PAM_CRED_INSUFFICIENT;",
          "257:     }",
          "259:     if (ctrl & PAM_TAC_DEBUG)",
          "260:         syslog(LOG_DEBUG, \"%s: password obtained\", __FUNCTION__);",
          "262:     tty = _pam_get_terminal(pamh);",
          "263:     if (!strncmp(tty, \"/dev/\", 5))",
          "264:         tty += 5;",
          "265:     if (ctrl & PAM_TAC_DEBUG)",
          "266:         syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);",
          "268:     r_addr = _pam_get_rhost(pamh);",
          "269:     if (ctrl & PAM_TAC_DEBUG)",
          "270:         syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);",
          "272:     status = PAM_AUTHINFO_UNAVAIL;",
          "273:     for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {",
          "274:         if (ctrl & PAM_TAC_DEBUG)",
          "275:             syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i );",
          "277:         tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);",
          "278:         if (tac_fd < 0) {",
          "279:             _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);",
          "280:             continue;",
          "281:         }",
          "282:         if (tac_authen_send(tac_fd, user, pass, tty, r_addr, TAC_PLUS_AUTHEN_LOGIN) < 0) {",
          "283:             close(tac_fd);",
          "284:             _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");",
          "285:             continue;",
          "286:         }",
          "287:         communicating = 1;",
          "288:         while (communicating) {",
          "289:             struct areply re = { .attr = NULL, .msg = NULL, .status = 0, .flags = 0 };",
          "290:             struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };",
          "291:             struct pam_response *resp = NULL;",
          "293:             msg = tac_authen_read(tac_fd, &re);",
          "295:             if (NULL != re.msg) {",
          "296:                 conv_msg.msg = re.msg;",
          "297:             }",
          "300:             switch (msg) {",
          "301:                 case TAC_PLUS_AUTHEN_STATUS_PASS:",
          "303:                     if (ctrl & PAM_TAC_DEBUG)",
          "304:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");",
          "306:                     if (NULL != conv_msg.msg) {",
          "307:                         int retval = -1;",
          "309:                         conv_msg.msg_style = PAM_TEXT_INFO;",
          "310:                         retval = converse(pamh, 1, &conv_msg, &resp);",
          "311:                         if (PAM_SUCCESS == retval) {",
          "312:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "313:                                 syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "314:                         }",
          "315:                         else {",
          "316:                             _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "317:                                      __FUNCTION__, conv_msg.msg, retval);",
          "318:                         }",
          "320:                     }",
          "321:                     status = PAM_SUCCESS;",
          "322:                     communicating = 0;",
          "323:                     active_server.addr = tac_srv[srv_i].addr;",
          "324:                     active_server.key = tac_srv[srv_i].key;",
          "326:                     if (ctrl & PAM_TAC_DEBUG)",
          "327:                         syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);",
          "329:                     break;",
          "331:                 case TAC_PLUS_AUTHEN_STATUS_FAIL:",
          "332:                     if (ctrl & PAM_TAC_DEBUG)",
          "333:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");",
          "335:                     if (NULL != conv_msg.msg) {",
          "336:                         int retval = -1;",
          "338:                         conv_msg.msg_style = PAM_ERROR_MSG;",
          "339:                         retval = converse(pamh, 1, &conv_msg, &resp);",
          "340:                         if (PAM_SUCCESS == retval) {",
          "341:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "342:                                 syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "343:                         }",
          "344:                         else {",
          "345:                             _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "346:                                      __FUNCTION__, conv_msg.msg, retval);",
          "347:                         }",
          "349:                     }",
          "350:                     status = PAM_AUTH_ERR;",
          "351:                     communicating = 0;",
          "353:                     _pam_log(LOG_ERR, \"auth failed: %d\", msg);",
          "355:                     break;",
          "357:                 case TAC_PLUS_AUTHEN_STATUS_GETDATA:",
          "358:                     if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "359:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");",
          "361:                     if (NULL != conv_msg.msg) {",
          "362:                         int retval = -1;",
          "363:                         int echo_off = (0x1 == (re.flags & 0x1));",
          "365:                         conv_msg.msg_style = echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;",
          "366:                         retval = converse(pamh, 1, &conv_msg, &resp);",
          "367:                         if (PAM_SUCCESS == retval) {",
          "368:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "369:                                 syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",",
          "370:                                        conv_msg.msg, resp->resp);",
          "372:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "373:                                 syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);",
          "375:                             if (0 > tac_cont_send_seq(tac_fd, resp->resp, re.seq_no + 1)) {",
          "376:                                 _pam_log(LOG_ERR, \"error sending continue req to TACACS+ server\");",
          "377:                                 status = PAM_AUTH_ERR;",
          "378:                                 communicating = 0;",
          "379:                             }",
          "380:                         }",
          "381:                         else {",
          "382:                             _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d (%s)\",",
          "383:                                      __FUNCTION__, conv_msg.msg, retval, pam_strerror(pamh, retval));",
          "384:                             status = PAM_AUTH_ERR;",
          "385:                             communicating = 0;",
          "386:                         }",
          "387:                     }",
          "388:                     else {",
          "389:                         syslog(LOG_ERR, \"GETDATA response with no message, returning PAM_AUTH_ERR\");",
          "391:                         status = PAM_AUTH_ERR;",
          "392:                         communicating = 0;",
          "393:                     }",
          "395:                     break;",
          "397:                 case TAC_PLUS_AUTHEN_STATUS_GETUSER:",
          "399:                     if (ctrl & PAM_TAC_DEBUG)",
          "400:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");",
          "402:                     communicating = 0;",
          "403:                     break;",
          "405:                 case TAC_PLUS_AUTHEN_STATUS_GETPASS:",
          "406:                     if (ctrl & PAM_TAC_DEBUG)",
          "407:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");",
          "409:                     if (ctrl & PAM_TAC_DEBUG)",
          "410:                         syslog(LOG_DEBUG, \"%s: tac_cont_send called\", __FUNCTION__);",
          "412:                     if (tac_cont_send(tac_fd, pass) < 0) {",
          "413:                         _pam_log (LOG_ERR, \"error sending continue req to TACACS+ server\");",
          "414:                         communicating = 0;",
          "415:                     }",
          "417:                     break;",
          "419:                 case TAC_PLUS_AUTHEN_STATUS_RESTART:",
          "421:                     if (ctrl & PAM_TAC_DEBUG)",
          "422:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");",
          "429:                     communicating = 0;",
          "430:                     break;",
          "432:                 case TAC_PLUS_AUTHEN_STATUS_ERROR:",
          "434:                     if (ctrl & PAM_TAC_DEBUG)",
          "435:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");",
          "437:                     communicating = 0;",
          "438:                     break;",
          "440:                 case TAC_PLUS_AUTHEN_STATUS_FOLLOW:",
          "443:                     if (ctrl & PAM_TAC_DEBUG)",
          "444:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");",
          "446:                     communicating = 0;",
          "447:                     break;",
          "449:                 default:",
          "450:                     if (msg < 0) {",
          "452:                         communicating = 0;",
          "453:                         if (ctrl & PAM_TAC_DEBUG)",
          "454:                             syslog(LOG_DEBUG, \"error communicating with tacacs server\");",
          "455:                         break;",
          "456:                     }",
          "459:                     communicating = 0;",
          "460:                     if (ctrl & PAM_TAC_DEBUG)",
          "461:                         syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\", msg);",
          "462:             }",
          "464:             if (NULL != resp) {",
          "465:                 free(resp->resp);",
          "466:                 free(resp);",
          "467:             }",
          "469:             free(re.msg);",
          "472:         close(tac_fd);",
          "474:         if (status == PAM_SUCCESS || status == PAM_AUTH_ERR)",
          "475:             break;",
          "476:     }",
          "477:     if (status != PAM_SUCCESS && status != PAM_AUTH_ERR)",
          "478:         _pam_log(LOG_ERR, \"no more servers to connect\");",
          "480:     if (ctrl & PAM_TAC_DEBUG)",
          "481:         syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);",
          "483:     if (NULL != pass) {",
          "484:         bzero(pass, strlen (pass));",
          "485:         free(pass);",
          "486:         pass = NULL;",
          "487:     }",
          "489:     return status;",
          "495: int pam_sm_setcred (pam_handle_t * pamh, int flags,",
          "496:     int argc, const char **argv) {",
          "498:     int ctrl = _pam_parse (argc, argv);",
          "500:     if (ctrl & PAM_TAC_DEBUG)",
          "501:         syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"",
          "502:             , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "504:     return PAM_SUCCESS;",
          "513: int pam_sm_acct_mgmt (pam_handle_t * pamh, int flags,",
          "514:     int argc, const char **argv) {",
          "516:     int retval, ctrl, status=PAM_AUTH_ERR;",
          "517:     char *user;",
          "518:     char *tty;",
          "519:     char *r_addr;",
          "520:     struct areply arep;",
          "521:     struct tac_attrib *attr = NULL;",
          "522:     int tac_fd;",
          "524:     user = tty = r_addr = NULL;",
          "525:     memset(&arep, 0, sizeof(arep));",
          "528:        this should be normally performed by pam_get_item(PAM_SERVICE)",
          "529:        but since PAM service names are incompatible TACACS+",
          "530:        we have to pass it via command line argument until a better",
          "532:     ctrl = _pam_parse (argc, argv);",
          "534:     if (ctrl & PAM_TAC_DEBUG)",
          "535:         syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"",
          "536:             , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "538:     if ((user = _pam_get_user(pamh)) == NULL)",
          "539:         return PAM_USER_UNKNOWN;",
          "541:     if (ctrl & PAM_TAC_DEBUG)",
          "542:         syslog(LOG_DEBUG, \"%s: username obtained [%s]\", __FUNCTION__, user);",
          "544:     tty = _pam_get_terminal(pamh);",
          "545:     if(!strncmp(tty, \"/dev/\", 5))",
          "546:         tty += 5;",
          "547:     if (ctrl & PAM_TAC_DEBUG)",
          "548:         syslog(LOG_DEBUG, \"%s: tty obtained [%s]\", __FUNCTION__, tty);",
          "550:     r_addr = _pam_get_rhost(pamh);",
          "551:     if (ctrl & PAM_TAC_DEBUG)",
          "552:         syslog(LOG_DEBUG, \"%s: rhost obtained [%s]\", __FUNCTION__, r_addr);",
          "555:        by TACACS+; we cannot solely authorize user if it hasn't",
          "556:        been authenticated or has been authenticated by method other",
          "558:     if(active_server.addr == NULL) {",
          "559:         _pam_log (LOG_ERR, \"user not authenticated by TACACS+\");",
          "560:         return PAM_AUTH_ERR;",
          "561:     }",
          "562:     if (ctrl & PAM_TAC_DEBUG)",
          "563:         syslog (LOG_DEBUG, \"%s: active server is [%s]\", __FUNCTION__,",
          "564:             tac_ntop(active_server.addr->ai_addr));",
          "568:     if(!*tac_service) {",
          "569:         _pam_log (LOG_ERR, \"SM: TACACS+ service type not configured\");",
          "570:         return PAM_AUTH_ERR;",
          "571:     }",
          "572:     if(!*tac_protocol) {",
          "573:         _pam_log (LOG_ERR, \"SM: TACACS+ protocol type not configured (IGNORED)\");",
          "574:     }",
          "576:     tac_add_attrib(&attr, \"service\", tac_service);",
          "577:     if(tac_protocol[0] != '\\0')",
          "578:       tac_add_attrib(&attr, \"protocol\", tac_protocol);",
          "580:     tac_fd = tac_connect_single(active_server.addr, active_server.key, NULL, tac_timeout);",
          "581:     if(tac_fd < 0) {",
          "582:         _pam_log (LOG_ERR, \"TACACS+ server unavailable\");",
          "583:         if(arep.msg != NULL)",
          "584:             free (arep.msg);",
          "585:         return PAM_AUTH_ERR;",
          "586:     }",
          "588:     retval = tac_author_send(tac_fd, user, tty, r_addr, attr);",
          "590:     tac_free_attrib(&attr);",
          "592:     if(retval < 0) {",
          "593:         _pam_log (LOG_ERR, \"error getting authorization\");",
          "594:         if(arep.msg != NULL)",
          "595:             free (arep.msg);",
          "597:         close(tac_fd);",
          "598:         return PAM_AUTH_ERR;",
          "599:     }",
          "601:     if (ctrl & PAM_TAC_DEBUG)",
          "602:         syslog(LOG_DEBUG, \"%s: sent authorization request\", __FUNCTION__);",
          "604:     tac_author_read(tac_fd, &arep);",
          "606:     if(arep.status != AUTHOR_STATUS_PASS_ADD &&",
          "607:         arep.status != AUTHOR_STATUS_PASS_REPL) {",
          "609:         _pam_log (LOG_ERR, \"TACACS+ authorisation failed for [%s]\", user);",
          "610:         if(arep.msg != NULL)",
          "611:             free (arep.msg);",
          "613:         close(tac_fd);",
          "614:         return PAM_PERM_DENIED;",
          "615:     }",
          "617:     if (ctrl & PAM_TAC_DEBUG)",
          "618:         syslog(LOG_DEBUG, \"%s: user [%s] successfully authorized\", __FUNCTION__, user);",
          "620:     status = PAM_SUCCESS;",
          "622:     attr = arep.attr;",
          "623:     while (attr != NULL)  {",
          "624:         char attribute[attr->attr_len];",
          "625:         char value[attr->attr_len];",
          "626:         char *sep;",
          "628:         sep = index(attr->attr, '=');",
          "629:         if(sep == NULL)",
          "630:             sep = index(attr->attr, '*');",
          "631:         if(sep != NULL) {",
          "632:             bcopy(attr->attr, attribute, attr->attr_len-strlen(sep));",
          "633:             attribute[attr->attr_len-strlen(sep)] = '\\0';",
          "634:             bcopy(sep, value, strlen(sep));",
          "635:             value[strlen(sep)] = '\\0';",
          "637:             size_t i;",
          "638:             for (i = 0; attribute[i] != '\\0'; i++) {",
          "639:                 attribute[i] = toupper(attribute[i]);",
          "640:                 if (attribute[i] == '-')",
          "641:                     attribute[i] = '_';",
          "642:             }",
          "644:             if (ctrl & PAM_TAC_DEBUG)",
          "645:                 syslog(LOG_DEBUG, \"%s: returned attribute `%s%s' from server\", __FUNCTION__, attribute, value);",
          "648:             if (pam_putenv(pamh, strncat(attribute, value, strlen(value))) != PAM_SUCCESS)",
          "649:                 syslog(LOG_WARNING, \"%s: unable to set PAM environment\", __FUNCTION__);",
          "651:         } else {",
          "652:             syslog(LOG_WARNING, \"%s: invalid attribute `%s', no separator\", __FUNCTION__, attr->attr);",
          "653:         }",
          "654:         attr = attr->next;",
          "655:     }",
          "658:     if(arep.attr != NULL)",
          "659:         tac_free_attrib(&arep.attr);",
          "661:     if(arep.msg != NULL)",
          "662:         free (arep.msg);",
          "664:     close(tac_fd);",
          "666:     return status;",
          "",
          "[Added Lines]",
          "219: int pam_sm_authenticate(pam_handle_t * pamh, int flags, int argc,",
          "220:   const char **argv) {",
          "222:  int ctrl, retval;",
          "223:  char *user;",
          "224:  char *pass;",
          "225:  char *tty;",
          "226:  char *r_addr;",
          "227:  int srv_i;",
          "228:  int tac_fd, status, msg, communicating;",
          "230:  user = pass = tty = r_addr = NULL;",
          "232:  ctrl = _pam_parse(argc, argv);",
          "234:  if (ctrl & PAM_TAC_DEBUG)",
          "235:   syslog(LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\", __FUNCTION__,",
          "236:     PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "238:  if ((user = _pam_get_user(pamh)) == NULL)",
          "239:   return PAM_USER_UNKNOWN;",
          "241:  if (ctrl & PAM_TAC_DEBUG)",
          "242:   syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);",
          "244:  retval = tacacs_get_password(pamh, flags, ctrl, &pass);",
          "245:  if (retval != PAM_SUCCESS || pass == NULL || *pass == '\\0') {",
          "246:   _pam_log(LOG_ERR, \"unable to obtain password\");",
          "247:   free(pass);",
          "248:   return PAM_CRED_INSUFFICIENT;",
          "249:  }",
          "251:  retval = pam_set_item(pamh, PAM_AUTHTOK, pass);",
          "252:  if (retval != PAM_SUCCESS) {",
          "253:   _pam_log(LOG_ERR, \"unable to set password\");",
          "254:   free(pass);",
          "255:   return PAM_CRED_INSUFFICIENT;",
          "256:  }",
          "258:  if (ctrl & PAM_TAC_DEBUG)",
          "259:   syslog(LOG_DEBUG, \"%s: password obtained\", __FUNCTION__);",
          "261:  tty = _pam_get_terminal(pamh);",
          "262:  if (!strncmp(tty, \"/dev/\", 5))",
          "263:   tty += 5;",
          "264:  if (ctrl & PAM_TAC_DEBUG)",
          "265:   syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);",
          "267:  r_addr = _pam_get_rhost(pamh);",
          "268:  if (ctrl & PAM_TAC_DEBUG)",
          "269:   syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);",
          "271:  status = PAM_AUTHINFO_UNAVAIL;",
          "272:  for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {",
          "273:   if (ctrl & PAM_TAC_DEBUG)",
          "274:    syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i);",
          "276:   tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key,",
          "277:     NULL, tac_timeout);",
          "278:   if (tac_fd < 0) {",
          "279:    _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);",
          "280:    continue;",
          "281:   }",
          "282:   if (tac_authen_send(tac_fd, user, pass, tty, r_addr,",
          "283:     TAC_PLUS_AUTHEN_LOGIN) < 0) {",
          "284:    close(tac_fd);",
          "285:    _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");",
          "286:    continue;",
          "287:   }",
          "288:   communicating = 1;",
          "289:   while (communicating) {",
          "290:    struct areply re = { .attr = NULL, .msg = NULL, .status = 0,",
          "291:      .flags = 0 };",
          "292:    struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };",
          "293:    struct pam_response *resp = NULL;",
          "295:    msg = tac_authen_read(tac_fd, &re);",
          "297:    if (NULL != re.msg) {",
          "298:     conv_msg.msg = re.msg;",
          "299:    }",
          "302:    switch (msg) {",
          "303:    case TAC_PLUS_AUTHEN_STATUS_PASS:",
          "305:     if (ctrl & PAM_TAC_DEBUG)",
          "306:      syslog(LOG_DEBUG,",
          "307:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");",
          "309:     if (NULL != conv_msg.msg) {",
          "310:      int retval = -1;",
          "312:      conv_msg.msg_style = PAM_TEXT_INFO;",
          "313:      retval = converse(pamh, 1, &conv_msg, &resp);",
          "314:      if (PAM_SUCCESS == retval) {",
          "315:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "316:        syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "317:      } else {",
          "318:       _pam_log(LOG_WARNING,",
          "319:         \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "320:         __FUNCTION__, conv_msg.msg, retval);",
          "321:      }",
          "323:     }",
          "324:     status = PAM_SUCCESS;",
          "325:     communicating = 0;",
          "326:     active_server.addr = tac_srv[srv_i].addr;",
          "327:     active_server.key = tac_srv[srv_i].key;",
          "329:     if (ctrl & PAM_TAC_DEBUG)",
          "330:      syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);",
          "332:     break;",
          "334:    case TAC_PLUS_AUTHEN_STATUS_FAIL:",
          "335:     if (ctrl & PAM_TAC_DEBUG)",
          "336:      syslog(LOG_DEBUG,",
          "337:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");",
          "339:     if (NULL != conv_msg.msg) {",
          "340:      int retval = -1;",
          "342:      conv_msg.msg_style = PAM_ERROR_MSG;",
          "343:      retval = converse(pamh, 1, &conv_msg, &resp);",
          "344:      if (PAM_SUCCESS == retval) {",
          "345:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "346:        syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "347:      } else {",
          "348:       _pam_log(LOG_WARNING,",
          "349:         \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "350:         __FUNCTION__, conv_msg.msg, retval);",
          "351:      }",
          "353:     }",
          "354:     status = PAM_AUTH_ERR;",
          "355:     communicating = 0;",
          "357:     _pam_log(LOG_ERR, \"auth failed: %d\", msg);",
          "359:     break;",
          "361:    case TAC_PLUS_AUTHEN_STATUS_GETDATA:",
          "362:     if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "363:      syslog(LOG_DEBUG,",
          "364:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");",
          "366:     if (NULL != conv_msg.msg) {",
          "367:      int retval = -1;",
          "368:      int echo_off = (0x1 == (re.flags & 0x1));",
          "370:      conv_msg.msg_style =",
          "371:        echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;",
          "372:      retval = converse(pamh, 1, &conv_msg, &resp);",
          "373:      if (PAM_SUCCESS == retval) {",
          "374:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "375:        syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",",
          "376:          conv_msg.msg, resp->resp);",
          "378:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "379:        syslog(LOG_DEBUG, \"%s: calling tac_cont_send\",",
          "380:          __FUNCTION__);",
          "382:       if (0",
          "383:         > tac_cont_send_seq(tac_fd, resp->resp,",
          "384:           re.seq_no + 1)) {",
          "385:        _pam_log(LOG_ERR,",
          "386:          \"error sending continue req to TACACS+ server\");",
          "387:        status = PAM_AUTH_ERR;",
          "388:        communicating = 0;",
          "389:       }",
          "390:      } else {",
          "391:       _pam_log(LOG_WARNING,",
          "392:         \"%s: error sending msg=\\\"%s\\\", retval=%d (%s)\",",
          "393:         __FUNCTION__, conv_msg.msg, retval,",
          "394:         pam_strerror(pamh, retval));",
          "395:       status = PAM_AUTH_ERR;",
          "396:       communicating = 0;",
          "397:      }",
          "398:     } else {",
          "399:      syslog(LOG_ERR,",
          "400:        \"GETDATA response with no message, returning PAM_AUTH_ERR\");",
          "402:      status = PAM_AUTH_ERR;",
          "403:      communicating = 0;",
          "404:     }",
          "406:     break;",
          "408:    case TAC_PLUS_AUTHEN_STATUS_GETUSER:",
          "410:     if (ctrl & PAM_TAC_DEBUG)",
          "411:      syslog(LOG_DEBUG,",
          "412:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");",
          "414:     communicating = 0;",
          "415:     break;",
          "417:    case TAC_PLUS_AUTHEN_STATUS_GETPASS:",
          "418:     if (ctrl & PAM_TAC_DEBUG)",
          "419:      syslog(LOG_DEBUG,",
          "420:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");",
          "422:     if (ctrl & PAM_TAC_DEBUG)",
          "423:      syslog(LOG_DEBUG, \"%s: tac_cont_send called\", __FUNCTION__);",
          "425:     if (tac_cont_send(tac_fd, pass) < 0) {",
          "426:      _pam_log(LOG_ERR,",
          "427:        \"error sending continue req to TACACS+ server\");",
          "428:      communicating = 0;",
          "429:     }",
          "431:     break;",
          "433:    case TAC_PLUS_AUTHEN_STATUS_RESTART:",
          "435:     if (ctrl & PAM_TAC_DEBUG)",
          "436:      syslog(LOG_DEBUG,",
          "437:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");",
          "444:     communicating = 0;",
          "445:     break;",
          "447:    case TAC_PLUS_AUTHEN_STATUS_ERROR:",
          "449:     if (ctrl & PAM_TAC_DEBUG)",
          "450:      syslog(LOG_DEBUG,",
          "451:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");",
          "453:     communicating = 0;",
          "454:     break;",
          "456:    case TAC_PLUS_AUTHEN_STATUS_FOLLOW:",
          "459:     if (ctrl & PAM_TAC_DEBUG)",
          "460:      syslog(LOG_DEBUG,",
          "461:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");",
          "463:     communicating = 0;",
          "464:     break;",
          "466:    default:",
          "467:     if (msg < 0) {",
          "469:      communicating = 0;",
          "470:      if (ctrl & PAM_TAC_DEBUG)",
          "471:       syslog(LOG_DEBUG,",
          "472:         \"error communicating with tacacs server\");",
          "473:      break;",
          "474:     }",
          "477:     communicating = 0;",
          "478:     if (ctrl & PAM_TAC_DEBUG)",
          "479:      syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\",",
          "480:        msg);",
          "481:    }",
          "483:    if (NULL != resp) {",
          "484:     free(resp->resp);",
          "485:     free(resp);",
          "486:    }",
          "488:    free(re.msg);",
          "491:   close(tac_fd);",
          "493:   if (status == PAM_SUCCESS || status == PAM_AUTH_ERR)",
          "494:    break;",
          "495:  }",
          "496:  if (status != PAM_SUCCESS && status != PAM_AUTH_ERR)",
          "497:   _pam_log(LOG_ERR, \"no more servers to connect\");",
          "499:  if (ctrl & PAM_TAC_DEBUG)",
          "500:   syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);",
          "502:  if (NULL != pass) {",
          "503:   bzero(pass, strlen(pass));",
          "504:   free(pass);",
          "505:   pass = NULL;",
          "506:  }",
          "508:  return status;",
          "513: int pam_sm_setcred(pam_handle_t * pamh, int flags, int argc, const char **argv) {",
          "515:  int ctrl = _pam_parse(argc, argv);",
          "517:  if (ctrl & PAM_TAC_DEBUG)",
          "518:   syslog(LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\", __FUNCTION__,",
          "519:     PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "521:  return PAM_SUCCESS;",
          "529: int pam_sm_acct_mgmt(pam_handle_t * pamh, int flags, int argc,",
          "530:   const char **argv) {",
          "532:  int retval, ctrl, status = PAM_AUTH_ERR;",
          "533:  char *user;",
          "534:  char *tty;",
          "535:  char *r_addr;",
          "536:  struct areply arep;",
          "537:  struct tac_attrib *attr = NULL;",
          "538:  int tac_fd;",
          "540:  user = tty = r_addr = NULL;",
          "541:  memset(&arep, 0, sizeof(arep));",
          "544:   this should be normally performed by pam_get_item(PAM_SERVICE)",
          "545:   but since PAM service names are incompatible TACACS+",
          "546:   we have to pass it via command line argument until a better",
          "548:  ctrl = _pam_parse(argc, argv);",
          "550:  if (ctrl & PAM_TAC_DEBUG)",
          "551:   syslog(LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\", __FUNCTION__,",
          "552:     PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "554:  if ((user = _pam_get_user(pamh)) == NULL)",
          "555:   return PAM_USER_UNKNOWN;",
          "557:  if (ctrl & PAM_TAC_DEBUG)",
          "558:   syslog(LOG_DEBUG, \"%s: username obtained [%s]\", __FUNCTION__, user);",
          "560:  tty = _pam_get_terminal(pamh);",
          "561:  if (!strncmp(tty, \"/dev/\", 5))",
          "562:   tty += 5;",
          "563:  if (ctrl & PAM_TAC_DEBUG)",
          "564:   syslog(LOG_DEBUG, \"%s: tty obtained [%s]\", __FUNCTION__, tty);",
          "566:  r_addr = _pam_get_rhost(pamh);",
          "567:  if (ctrl & PAM_TAC_DEBUG)",
          "568:   syslog(LOG_DEBUG, \"%s: rhost obtained [%s]\", __FUNCTION__, r_addr);",
          "571:   by TACACS+; we cannot solely authorize user if it hasn't",
          "572:   been authenticated or has been authenticated by method other",
          "574:  if (active_server.addr == NULL) {",
          "575:   _pam_log(LOG_ERR, \"user not authenticated by TACACS+\");",
          "576:   return PAM_AUTH_ERR;",
          "577:  }",
          "578:  if (ctrl & PAM_TAC_DEBUG)",
          "579:   syslog(LOG_DEBUG, \"%s: active server is [%s]\", __FUNCTION__,",
          "580:     tac_ntop(active_server.addr->ai_addr));",
          "584:  if (!*tac_service) {",
          "585:   _pam_log(LOG_ERR, \"SM: TACACS+ service type not configured\");",
          "586:   return PAM_AUTH_ERR;",
          "587:  }",
          "588:  if (!*tac_protocol) {",
          "589:   _pam_log(LOG_ERR, \"SM: TACACS+ protocol type not configured (IGNORED)\");",
          "590:  }",
          "592:  tac_add_attrib(&attr, \"service\", tac_service);",
          "593:  if (tac_protocol[0] != '\\0')",
          "594:   tac_add_attrib(&attr, \"protocol\", tac_protocol);",
          "596:  tac_fd = tac_connect_single(active_server.addr, active_server.key, NULL,",
          "597:    tac_timeout);",
          "598:  if (tac_fd < 0) {",
          "599:   _pam_log(LOG_ERR, \"TACACS+ server unavailable\");",
          "600:   if (arep.msg != NULL)",
          "601:    free(arep.msg);",
          "602:   return PAM_AUTH_ERR;",
          "603:  }",
          "605:  retval = tac_author_send(tac_fd, user, tty, r_addr, attr);",
          "607:  tac_free_attrib(&attr);",
          "609:  if (retval < 0) {",
          "610:   _pam_log(LOG_ERR, \"error getting authorization\");",
          "611:   if (arep.msg != NULL)",
          "612:    free(arep.msg);",
          "614:   close(tac_fd);",
          "615:   return PAM_AUTH_ERR;",
          "616:  }",
          "618:  if (ctrl & PAM_TAC_DEBUG)",
          "619:   syslog(LOG_DEBUG, \"%s: sent authorization request\", __FUNCTION__);",
          "621:  tac_author_read(tac_fd, &arep);",
          "623:  if (arep.status != AUTHOR_STATUS_PASS_ADD",
          "624:    && arep.status != AUTHOR_STATUS_PASS_REPL) {",
          "626:   _pam_log(LOG_ERR, \"TACACS+ authorisation failed for [%s]\", user);",
          "627:   if (arep.msg != NULL)",
          "628:    free(arep.msg);",
          "630:   close(tac_fd);",
          "631:   return PAM_PERM_DENIED;",
          "632:  }",
          "634:  if (ctrl & PAM_TAC_DEBUG)",
          "635:   syslog(LOG_DEBUG, \"%s: user [%s] successfully authorized\", __FUNCTION__,",
          "636:     user);",
          "638:  status = PAM_SUCCESS;",
          "640:  attr = arep.attr;",
          "641:  while (attr != NULL) {",
          "642:   char attribute[attr->attr_len];",
          "643:   char value[attr->attr_len];",
          "644:   char *sep;",
          "646:   sep = index(attr->attr, '=');",
          "647:   if (sep == NULL)",
          "648:    sep = index(attr->attr, '*');",
          "649:   if (sep != NULL) {",
          "650:    bcopy(attr->attr, attribute, attr->attr_len - strlen(sep));",
          "651:    attribute[attr->attr_len - strlen(sep)] = '\\0';",
          "652:    bcopy(sep, value, strlen(sep));",
          "653:    value[strlen(sep)] = '\\0';",
          "655:    size_t i;",
          "656:    for (i = 0; attribute[i] != '\\0'; i++) {",
          "657:     attribute[i] = toupper(attribute[i]);",
          "658:     if (attribute[i] == '-')",
          "659:      attribute[i] = '_';",
          "660:    }",
          "662:    if (ctrl & PAM_TAC_DEBUG)",
          "663:     syslog(LOG_DEBUG, \"%s: returned attribute `%s%s' from server\",",
          "664:       __FUNCTION__, attribute, value);",
          "667:    if (pam_putenv(pamh,",
          "668:      strncat(attribute, value, strlen(value))) != PAM_SUCCESS)",
          "669:     syslog(LOG_WARNING, \"%s: unable to set PAM environment\",",
          "670:       __FUNCTION__);",
          "672:   } else {",
          "673:    syslog(LOG_WARNING, \"%s: invalid attribute `%s', no separator\",",
          "674:      __FUNCTION__, attr->attr);",
          "675:   }",
          "676:   attr = attr->next;",
          "677:  }",
          "680:  if (arep.attr != NULL)",
          "681:   tac_free_attrib(&arep.attr);",
          "683:  if (arep.msg != NULL)",
          "684:   free(arep.msg);",
          "686:  close(tac_fd);",
          "688:  return status;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "677: PAM_EXTERN",
          "680: #if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)",
          "682: #else",
          "684: #endif",
          "692: PAM_EXTERN",
          "700: #ifdef PAM_SM_PASSWORD",
          "702: PAM_EXTERN",
          "987: #endif",
          "990: #ifdef PAM_STATIC",
          "991: struct pam_module _pam_tacplus_modstruct {",
          "998: #ifdef PAM_SM_PASSWORD",
          "1000: #else",
          "1002: #endif",
          "1003: };",
          "1004: #endif",
          "",
          "[Removed Lines]",
          "678: int pam_sm_open_session (pam_handle_t * pamh, int flags,",
          "679:     int argc, const char **argv) {",
          "681:         RAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));",
          "683:         task_id=(short int) magic();",
          "685:     return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);",
          "693: int pam_sm_close_session (pam_handle_t * pamh, int flags,",
          "694:     int argc, const char **argv) {",
          "696:     return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);",
          "703: int pam_sm_chauthtok(pam_handle_t * pamh, int flags,",
          "704:     int argc, const char **argv) {",
          "706:     int ctrl, retval;",
          "707:     char *user;",
          "708:     char *pass;",
          "709:     char *tty;",
          "710:     char *r_addr;",
          "711:     const void *pam_pass = NULL;",
          "712:     int srv_i;",
          "713:     int tac_fd, status, msg, communicating;",
          "715:     user = pass = tty = r_addr = NULL;",
          "717:     ctrl = _pam_parse(argc, argv);",
          "719:     if (ctrl & PAM_TAC_DEBUG)",
          "720:         syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"",
          "721:             , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "723:     syslog(LOG_DEBUG, \"%s(flags=%d, argc=%d)\", __func__, flags, argc);",
          "725:     if (   (pam_get_item(pamh, PAM_OLDAUTHTOK, &pam_pass) == PAM_SUCCESS)",
          "726:         && (pam_pass != NULL) ) {",
          "727:          if ((pass = strdup(pam_pass)) == NULL)",
          "728:               return PAM_BUF_ERR;",
          "729:     } else {",
          "730:         pass = strdup(\"\");",
          "731:     }",
          "733:     if ((user = _pam_get_user(pamh)) == NULL) {",
          "734:         if(pass) {",
          "735:                 free(pass);",
          "736:         }",
          "737:         return PAM_USER_UNKNOWN;",
          "738:     }",
          "740:     if (ctrl & PAM_TAC_DEBUG)",
          "741:         syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);",
          "743:     tty = _pam_get_terminal(pamh);",
          "744:     if (!strncmp(tty, \"/dev/\", 5))",
          "745:         tty += 5;",
          "746:     if (ctrl & PAM_TAC_DEBUG)",
          "747:         syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);",
          "749:     r_addr = _pam_get_rhost(pamh);",
          "750:     if (ctrl & PAM_TAC_DEBUG)",
          "751:         syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);",
          "753:     if (PAM_SILENT == (flags & PAM_SILENT)) {",
          "754:         status = PAM_AUTHTOK_ERR;",
          "755:         goto finish;",
          "756:     }",
          "758:     status = PAM_TRY_AGAIN;",
          "759:     for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {",
          "760:         if (ctrl & PAM_TAC_DEBUG)",
          "761:             syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i );",
          "763:         tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);",
          "764:         if (tac_fd < 0) {",
          "765:             _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);",
          "766:             continue;",
          "767:         }",
          "768:         if (PAM_PRELIM_CHECK == (flags & PAM_PRELIM_CHECK)) {",
          "769:             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "770:                 syslog(LOG_DEBUG, \"%s: finishing PAM_PRELIM_CHECK with srv %d\",",
          "771:                        __FUNCTION__, srv_i);",
          "773:             close(tac_fd);",
          "774:             status = PAM_SUCCESS;",
          "775:             goto finish;",
          "776:         }",
          "778:         if (tac_authen_send(tac_fd, user, \"\", tty, r_addr, TAC_PLUS_AUTHEN_CHPASS) < 0) {",
          "779:             close(tac_fd);",
          "780:             _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");",
          "781:             continue;",
          "782:         }",
          "783:         communicating = 1;",
          "784:         while (communicating) {",
          "785:             struct areply re = { .attr = NULL, .msg = NULL, .status = 0, .flags = 0 };",
          "786:             struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };",
          "787:             struct pam_response *resp = NULL;",
          "789:             msg = tac_authen_read(tac_fd, &re);",
          "791:             if (NULL != re.msg) {",
          "792:                 conv_msg.msg = re.msg;",
          "793:             }",
          "796:             switch (msg) {",
          "797:                 case TAC_PLUS_AUTHEN_STATUS_PASS:",
          "799:                     if (ctrl & PAM_TAC_DEBUG)",
          "800:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");",
          "802:                     if (NULL != conv_msg.msg) {",
          "803:                         int retval = -1;",
          "805:                         conv_msg.msg_style = PAM_TEXT_INFO;",
          "806:                         retval = converse(pamh, 1, &conv_msg, &resp);",
          "807:                         if (PAM_SUCCESS == retval) {",
          "808:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "809:                                 syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "810:                         }",
          "811:                         else {",
          "812:                             _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "813:                                      __FUNCTION__, conv_msg.msg, retval);",
          "814:                         }",
          "816:                     }",
          "817:                     status = PAM_SUCCESS;",
          "818:                     communicating = 0;",
          "820:                     active_server.addr = tac_srv[srv_i].addr;",
          "821:                     active_server.key = tac_srv[srv_i].key;",
          "823:                     if (ctrl & PAM_TAC_DEBUG)",
          "824:                         syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);",
          "826:                     break;",
          "828:                 case TAC_PLUS_AUTHEN_STATUS_FAIL:",
          "829:                     if (ctrl & PAM_TAC_DEBUG)",
          "830:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");",
          "832:                     if (NULL != conv_msg.msg) {",
          "833:                         int retval = -1;",
          "835:                         conv_msg.msg_style = PAM_ERROR_MSG;",
          "836:                         retval = converse(pamh, 1, &conv_msg, &resp);",
          "837:                         if (PAM_SUCCESS == retval) {",
          "838:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "839:                                 syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "840:                         }",
          "841:                         else {",
          "842:                             _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "843:                                      __FUNCTION__, conv_msg.msg, retval);",
          "844:                         }",
          "846:                     }",
          "847:                     status = PAM_AUTHTOK_ERR;",
          "848:                     communicating = 0;",
          "850:                     _pam_log(LOG_ERR, \"chauthtok failed: %d\", msg);",
          "852:                     break;",
          "854:                 case TAC_PLUS_AUTHEN_STATUS_GETDATA:",
          "855:                     if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "856:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");",
          "858:                     if (NULL != conv_msg.msg) {",
          "859:                         int retval = -1;",
          "860:                         int echo_off = (0x1 == (re.flags & 0x1));",
          "862:                         conv_msg.msg_style = echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;",
          "863:                         retval = converse(pamh, 1, &conv_msg, &resp);",
          "864:                         if (PAM_SUCCESS == retval) {",
          "865:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "866:                                 syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",",
          "867:                                        conv_msg.msg, resp->resp);",
          "869:                             if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "870:                                 syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);",
          "872:                             if (0 > tac_cont_send_seq(tac_fd, resp->resp, re.seq_no + 1)) {",
          "873:                                 _pam_log(LOG_ERR, \"error sending continue req to TACACS+ server\");",
          "874:                                 communicating = 0;",
          "875:                             }",
          "876:                         }",
          "877:                         else {",
          "878:                             _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "879:                                      __FUNCTION__, conv_msg.msg, retval);",
          "880:                             communicating = 0;",
          "881:                         }",
          "882:                     }",
          "883:                     else {",
          "884:                         syslog(LOG_ERR, \"GETDATA response with no message, returning PAM_TRY_AGAIN\");",
          "885:                         communicating = 0;",
          "886:                     }",
          "888:                     break;",
          "890:                 case TAC_PLUS_AUTHEN_STATUS_GETUSER:",
          "892:                     if (ctrl & PAM_TAC_DEBUG)",
          "893:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");",
          "895:                     communicating = 0;",
          "896:                     break;",
          "898:                 case TAC_PLUS_AUTHEN_STATUS_GETPASS:",
          "899:                     if (ctrl & PAM_TAC_DEBUG)",
          "900:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");",
          "902:                     if (ctrl & PAM_TAC_DEBUG)",
          "903:                         syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);",
          "905:                     if (tac_cont_send(tac_fd, pass) < 0) {",
          "906:                         _pam_log (LOG_ERR, \"error sending continue req to TACACS+ server\");",
          "907:                         communicating = 0;",
          "908:                         break;",
          "909:                     }",
          "911:                     break;",
          "913:                 case TAC_PLUS_AUTHEN_STATUS_RESTART:",
          "915:                     if (ctrl & PAM_TAC_DEBUG)",
          "916:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");",
          "923:                     communicating = 0;",
          "924:                     break;",
          "926:                 case TAC_PLUS_AUTHEN_STATUS_ERROR:",
          "928:                     if (ctrl & PAM_TAC_DEBUG)",
          "929:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");",
          "931:                     communicating = 0;",
          "932:                     break;",
          "934:                 case TAC_PLUS_AUTHEN_STATUS_FOLLOW:",
          "937:                     if (ctrl & PAM_TAC_DEBUG)",
          "938:                         syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");",
          "940:                     communicating = 0;",
          "941:                     break;",
          "943:                 default:",
          "944:                     if (msg < 0) {",
          "946:                         communicating = 0;",
          "947:                         if (ctrl & PAM_TAC_DEBUG)",
          "948:                             syslog(LOG_DEBUG, \"error communicating with tacacs server\");",
          "949:                         break;",
          "950:                     }",
          "953:                     communicating = 0;",
          "954:                     if (ctrl & PAM_TAC_DEBUG)",
          "955:                         syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\", msg);",
          "956:             }",
          "958:             if (NULL != resp) {",
          "959:                 free(resp->resp);",
          "960:                 free(resp);",
          "961:             }",
          "963:             free(re.msg);",
          "966:         close(tac_fd);",
          "968:         if (status == PAM_SUCCESS || status == PAM_AUTHTOK_ERR)",
          "969:             break;",
          "970:     }",
          "972: finish:",
          "973:     if (status != PAM_SUCCESS && status != PAM_AUTHTOK_ERR)",
          "974:         _pam_log(LOG_ERR, \"no more servers to connect\");",
          "976:     if (ctrl & PAM_TAC_DEBUG)",
          "977:         syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);",
          "979:     if (NULL != pass) {",
          "980:         bzero(pass, strlen(pass));",
          "981:         free(pass);",
          "982:         pass = NULL;",
          "983:     }",
          "985:     return status;",
          "992:     \"pam_tacplus\",",
          "993:     pam_sm_authenticate,",
          "994:     pam_sm_setcred,",
          "995:     pam_sm_acct_mgmt,",
          "996:     pam_sm_open_session,",
          "997:     pam_sm_close_session,",
          "999:     pam_sm_chauthtok",
          "1001:     NULL",
          "",
          "[Added Lines]",
          "700: int pam_sm_open_session(pam_handle_t * pamh, int flags, int argc,",
          "701:   const char **argv) {",
          "703:  RAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));",
          "705:  task_id=(short int) magic();",
          "707:  return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);",
          "715: int pam_sm_close_session(pam_handle_t * pamh, int flags, int argc,",
          "716:   const char **argv) {",
          "718:  return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);",
          "724: int pam_sm_chauthtok(pam_handle_t * pamh, int flags, int argc,",
          "725:   const char **argv) {",
          "727:  int ctrl, retval;",
          "728:  char *user;",
          "729:  char *pass;",
          "730:  char *tty;",
          "731:  char *r_addr;",
          "732:  const void *pam_pass = NULL;",
          "733:  int srv_i;",
          "734:  int tac_fd, status, msg, communicating;",
          "736:  user = pass = tty = r_addr = NULL;",
          "738:  ctrl = _pam_parse(argc, argv);",
          "740:  if (ctrl & PAM_TAC_DEBUG)",
          "741:   syslog(LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\", __FUNCTION__,",
          "742:     PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);",
          "744:  syslog(LOG_DEBUG, \"%s(flags=%d, argc=%d)\", __func__, flags, argc);",
          "746:  if ((pam_get_item(pamh, PAM_OLDAUTHTOK, &pam_pass) == PAM_SUCCESS)",
          "747:    && (pam_pass != NULL)) {",
          "748:   if ((pass = strdup(pam_pass)) == NULL)",
          "749:    return PAM_BUF_ERR;",
          "750:  } else {",
          "751:   pass = strdup(\"\");",
          "752:  }",
          "754:  if ((user = _pam_get_user(pamh)) == NULL) {",
          "755:   if (pass) {",
          "756:    free(pass);",
          "757:   }",
          "758:   return PAM_USER_UNKNOWN;",
          "759:  }",
          "761:  if (ctrl & PAM_TAC_DEBUG)",
          "762:   syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);",
          "764:  tty = _pam_get_terminal(pamh);",
          "765:  if (!strncmp(tty, \"/dev/\", 5))",
          "766:   tty += 5;",
          "767:  if (ctrl & PAM_TAC_DEBUG)",
          "768:   syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);",
          "770:  r_addr = _pam_get_rhost(pamh);",
          "771:  if (ctrl & PAM_TAC_DEBUG)",
          "772:   syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);",
          "774:  if (PAM_SILENT == (flags & PAM_SILENT)) {",
          "775:   status = PAM_AUTHTOK_ERR;",
          "776:   goto finish;",
          "777:  }",
          "779:  status = PAM_TRY_AGAIN;",
          "780:  for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {",
          "781:   if (ctrl & PAM_TAC_DEBUG)",
          "782:    syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i);",
          "784:   tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key,",
          "785:     NULL, tac_timeout);",
          "786:   if (tac_fd < 0) {",
          "787:    _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);",
          "788:    continue;",
          "789:   }",
          "790:   if (PAM_PRELIM_CHECK == (flags & PAM_PRELIM_CHECK)) {",
          "791:    if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "792:     syslog(LOG_DEBUG, \"%s: finishing PAM_PRELIM_CHECK with srv %d\",",
          "793:       __FUNCTION__, srv_i);",
          "795:    close(tac_fd);",
          "796:    status = PAM_SUCCESS;",
          "797:    goto finish;",
          "798:   }",
          "800:   if (tac_authen_send(tac_fd, user, \"\", tty, r_addr,",
          "801:     TAC_PLUS_AUTHEN_CHPASS) < 0) {",
          "802:    close(tac_fd);",
          "803:    _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");",
          "804:    continue;",
          "805:   }",
          "806:   communicating = 1;",
          "807:   while (communicating) {",
          "808:    struct areply re = { .attr = NULL, .msg = NULL, .status = 0,",
          "809:      .flags = 0 };",
          "810:    struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };",
          "811:    struct pam_response *resp = NULL;",
          "813:    msg = tac_authen_read(tac_fd, &re);",
          "815:    if (NULL != re.msg) {",
          "816:     conv_msg.msg = re.msg;",
          "817:    }",
          "820:    switch (msg) {",
          "821:    case TAC_PLUS_AUTHEN_STATUS_PASS:",
          "823:     if (ctrl & PAM_TAC_DEBUG)",
          "824:      syslog(LOG_DEBUG,",
          "825:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");",
          "827:     if (NULL != conv_msg.msg) {",
          "828:      int retval = -1;",
          "830:      conv_msg.msg_style = PAM_TEXT_INFO;",
          "831:      retval = converse(pamh, 1, &conv_msg, &resp);",
          "832:      if (PAM_SUCCESS == retval) {",
          "833:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "834:        syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "835:      } else {",
          "836:       _pam_log(LOG_WARNING,",
          "837:         \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "838:         __FUNCTION__, conv_msg.msg, retval);",
          "839:      }",
          "841:     }",
          "842:     status = PAM_SUCCESS;",
          "843:     communicating = 0;",
          "845:     active_server.addr = tac_srv[srv_i].addr;",
          "846:     active_server.key = tac_srv[srv_i].key;",
          "848:     if (ctrl & PAM_TAC_DEBUG)",
          "849:      syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);",
          "851:     break;",
          "853:    case TAC_PLUS_AUTHEN_STATUS_FAIL:",
          "854:     if (ctrl & PAM_TAC_DEBUG)",
          "855:      syslog(LOG_DEBUG,",
          "856:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");",
          "858:     if (NULL != conv_msg.msg) {",
          "859:      int retval = -1;",
          "861:      conv_msg.msg_style = PAM_ERROR_MSG;",
          "862:      retval = converse(pamh, 1, &conv_msg, &resp);",
          "863:      if (PAM_SUCCESS == retval) {",
          "864:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "865:        syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);",
          "866:      } else {",
          "867:       _pam_log(LOG_WARNING,",
          "868:         \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "869:         __FUNCTION__, conv_msg.msg, retval);",
          "870:      }",
          "872:     }",
          "873:     status = PAM_AUTHTOK_ERR;",
          "874:     communicating = 0;",
          "876:     _pam_log(LOG_ERR, \"chauthtok failed: %d\", msg);",
          "878:     break;",
          "880:    case TAC_PLUS_AUTHEN_STATUS_GETDATA:",
          "881:     if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "882:      syslog(LOG_DEBUG,",
          "883:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");",
          "885:     if (NULL != conv_msg.msg) {",
          "886:      int retval = -1;",
          "887:      int echo_off = (0x1 == (re.flags & 0x1));",
          "889:      conv_msg.msg_style =",
          "890:        echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;",
          "891:      retval = converse(pamh, 1, &conv_msg, &resp);",
          "892:      if (PAM_SUCCESS == retval) {",
          "893:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "894:        syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",",
          "895:          conv_msg.msg, resp->resp);",
          "897:       if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))",
          "898:        syslog(LOG_DEBUG, \"%s: calling tac_cont_send\",",
          "899:          __FUNCTION__);",
          "901:       if (0",
          "902:         > tac_cont_send_seq(tac_fd, resp->resp,",
          "903:           re.seq_no + 1)) {",
          "904:        _pam_log(LOG_ERR,",
          "905:          \"error sending continue req to TACACS+ server\");",
          "906:        communicating = 0;",
          "907:       }",
          "908:      } else {",
          "909:       _pam_log(LOG_WARNING,",
          "910:         \"%s: error sending msg=\\\"%s\\\", retval=%d\",",
          "911:         __FUNCTION__, conv_msg.msg, retval);",
          "912:       communicating = 0;",
          "913:      }",
          "914:     } else {",
          "915:      syslog(LOG_ERR,",
          "916:        \"GETDATA response with no message, returning PAM_TRY_AGAIN\");",
          "917:      communicating = 0;",
          "918:     }",
          "920:     break;",
          "922:    case TAC_PLUS_AUTHEN_STATUS_GETUSER:",
          "924:     if (ctrl & PAM_TAC_DEBUG)",
          "925:      syslog(LOG_DEBUG,",
          "926:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");",
          "928:     communicating = 0;",
          "929:     break;",
          "931:    case TAC_PLUS_AUTHEN_STATUS_GETPASS:",
          "932:     if (ctrl & PAM_TAC_DEBUG)",
          "933:      syslog(LOG_DEBUG,",
          "934:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");",
          "936:     if (ctrl & PAM_TAC_DEBUG)",
          "937:      syslog(LOG_DEBUG, \"%s: calling tac_cont_send\",",
          "938:        __FUNCTION__);",
          "940:     if (tac_cont_send(tac_fd, pass) < 0) {",
          "941:      _pam_log(LOG_ERR,",
          "942:        \"error sending continue req to TACACS+ server\");",
          "943:      communicating = 0;",
          "944:      break;",
          "945:     }",
          "947:     break;",
          "949:    case TAC_PLUS_AUTHEN_STATUS_RESTART:",
          "951:     if (ctrl & PAM_TAC_DEBUG)",
          "952:      syslog(LOG_DEBUG,",
          "953:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");",
          "960:     communicating = 0;",
          "961:     break;",
          "963:    case TAC_PLUS_AUTHEN_STATUS_ERROR:",
          "965:     if (ctrl & PAM_TAC_DEBUG)",
          "966:      syslog(LOG_DEBUG,",
          "967:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");",
          "969:     communicating = 0;",
          "970:     break;",
          "972:    case TAC_PLUS_AUTHEN_STATUS_FOLLOW:",
          "975:     if (ctrl & PAM_TAC_DEBUG)",
          "976:      syslog(LOG_DEBUG,",
          "977:        \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");",
          "979:     communicating = 0;",
          "980:     break;",
          "982:    default:",
          "983:     if (msg < 0) {",
          "985:      communicating = 0;",
          "986:      if (ctrl & PAM_TAC_DEBUG)",
          "987:       syslog(LOG_DEBUG,",
          "988:         \"error communicating with tacacs server\");",
          "989:      break;",
          "990:     }",
          "993:     communicating = 0;",
          "994:     if (ctrl & PAM_TAC_DEBUG)",
          "995:      syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\",",
          "996:        msg);",
          "997:    }",
          "999:    if (NULL != resp) {",
          "1000:     free(resp->resp);",
          "1001:     free(resp);",
          "1002:    }",
          "1004:    free(re.msg);",
          "1007:   close(tac_fd);",
          "1009:   if (status == PAM_SUCCESS || status == PAM_AUTHTOK_ERR)",
          "1010:    break;",
          "1011:  }",
          "1013:  finish: if (status != PAM_SUCCESS && status != PAM_AUTHTOK_ERR)",
          "1014:   _pam_log(LOG_ERR, \"no more servers to connect\");",
          "1016:  if (ctrl & PAM_TAC_DEBUG)",
          "1017:   syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);",
          "1019:  if (NULL != pass) {",
          "1020:   bzero(pass, strlen(pass));",
          "1021:   free(pass);",
          "1022:   pass = NULL;",
          "1023:  }",
          "1025:  return status;",
          "1031:  \"pam_tacplus\",",
          "1032:  pam_sm_authenticate,",
          "1033:  pam_sm_setcred,",
          "1034:  pam_sm_acct_mgmt,",
          "1035:  pam_sm_open_session,",
          "1036:  pam_sm_close_session,",
          "1038:  pam_sm_chauthtok",
          "1040:  NULL",
          "",
          "---------------"
        ],
        "pam_tacplus.h||pam_tacplus.h": [
          "File: pam_tacplus.h -> pam_tacplus.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: #define PAM_TAC_VPAT 8",
          "45: #ifndef PAM_EXTERN",
          "47: #endif",
          "",
          "[Removed Lines]",
          "46:   #define PAM_EXTERN extern",
          "",
          "[Added Lines]",
          "46: #define PAM_EXTERN extern",
          "",
          "---------------"
        ],
        "tacc.c||tacc.c": [
          "File: tacc.c -> tacc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: void showusage(char *progname);",
          "63: void showversion(char *progname);",
          "64: void authenticate(const struct addrinfo *tac_server, const char *tac_secret,",
          "66: void timeout_handler(int signum);",
          "68: #define EXIT_OK  0",
          "",
          "[Removed Lines]",
          "65:   const char *user, const char *pass, const char *tty, const char *remote_addr);",
          "",
          "[Added Lines]",
          "65:   const char *user, const char *pass, const char *tty,",
          "66:   const char *remote_addr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110: char *opt_string = \"TRAVhu:p:s:k:c:qr:wnS:P:L:\";",
          "",
          "[Removed Lines]",
          "81: static struct option long_options[] = {",
          "83:     { \"authenticate\", no_argument, NULL, 'T' },",
          "84:     { \"authorize\", no_argument, NULL, 'R' },",
          "85:     { \"account\", no_argument, NULL, 'A' },",
          "86:     { \"version\", no_argument, NULL, 'V' },",
          "87:     { \"help\", no_argument, NULL, 'h' },",
          "90:     { \"username\", required_argument, NULL, 'u' },",
          "91:     { \"remote\", required_argument, NULL, 'r' },",
          "92:     { \"password\", required_argument, NULL, 'p' },",
          "93:     { \"server\", required_argument, NULL, 's' },",
          "94:     { \"secret\", required_argument, NULL, 'k' },",
          "95:     { \"command\", required_argument, NULL, 'c' },",
          "96:     { \"exec\", required_argument, NULL, 'c' },",
          "97:     { \"service\", required_argument, NULL, 'S' },",
          "98:     { \"protocol\", required_argument, NULL, 'P' },",
          "99:     { \"remote\", required_argument, NULL, 'r' },",
          "100:  { \"login\", required_argument, NULL, 'L' },",
          "103:     { \"quiet\", no_argument, NULL, 'q' },",
          "104:     { \"silent\", no_argument, NULL, 'q' },",
          "105:     { \"no-wtmp\", no_argument, NULL, 'w' },",
          "106:     { \"no-encrypt\", no_argument, NULL, 'n' },",
          "107:     { 0, 0, 0, 0 } };",
          "",
          "[Added Lines]",
          "82: static struct option long_options[] =",
          "83:   {",
          "85:   { \"authenticate\", no_argument, NULL, 'T' }, { \"authorize\", no_argument,",
          "86:     NULL, 'R' }, { \"account\", no_argument, NULL, 'A' }, { \"version\",",
          "87:     no_argument, NULL, 'V' }, { \"help\", no_argument, NULL, 'h' },",
          "90:   { \"username\", required_argument, NULL, 'u' }, { \"remote\",",
          "91:     required_argument, NULL, 'r' }, { \"password\", required_argument,",
          "92:     NULL, 'p' }, { \"server\", required_argument, NULL, 's' }, {",
          "93:     \"secret\", required_argument, NULL, 'k' }, { \"command\",",
          "94:     required_argument, NULL, 'c' }, { \"exec\", required_argument,",
          "95:     NULL, 'c' }, { \"service\", required_argument, NULL, 'S' }, {",
          "96:     \"protocol\", required_argument, NULL, 'P' }, { \"remote\",",
          "97:     required_argument, NULL, 'r' }, { \"login\", required_argument,",
          "98:     NULL, 'L' },",
          "101:   { \"quiet\", no_argument, NULL, 'q' },",
          "102:     { \"silent\", no_argument, NULL, 'q' }, { \"no-wtmp\", no_argument,",
          "103:       NULL, 'w' }, { \"no-encrypt\", no_argument, NULL, 'n' }, {",
          "104:       0, 0, 0, 0 } };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "114:  char *tty;",
          "115:  char *command = NULL;",
          "116:  char *remote_addr = NULL;",
          "119:  struct addrinfo *tac_server;",
          "120:  char *tac_server_name = NULL;",
          "121:  char *tac_secret = NULL;",
          "",
          "[Removed Lines]",
          "117:     char *service = NULL;",
          "118:     char *protocol = NULL;",
          "",
          "[Added Lines]",
          "114:  char *service = NULL;",
          "115:  char *protocol = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "328:    exit(EXIT_ERR);",
          "329:   }",
          "333:   ret = tac_acct_read(tac_fd, &arep);",
          "335:    if (!quiet)",
          "336:     printf(\"Accounting: START failed: %s\\n\", arep.msg);",
          "337:    syslog(LOG_INFO, \"TACACS+ accounting start failed: %s\", arep.msg);",
          "",
          "[Removed Lines]",
          "331:   tac_acct_send(tac_fd, TAC_PLUS_ACCT_FLAG_START, user, tty, remote_addr, attr);",
          "334:   if(ret == 0) {",
          "",
          "[Added Lines]",
          "328:   tac_acct_send(tac_fd, TAC_PLUS_ACCT_FLAG_START, user, tty, remote_addr,",
          "329:     attr);",
          "332:   if (ret == 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "348: #ifdef HAVE_LOGWTMP",
          "349:  if (log_wtmp)",
          "351: #endif",
          "353:  if (command != NULL) {",
          "",
          "[Removed Lines]",
          "350:  logwtmp(tty, user, \"dialup\");",
          "",
          "[Added Lines]",
          "348:   logwtmp(tty, user, \"dialup\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "411:    exit(EXIT_ERR);",
          "412:   }",
          "415:   ret = tac_acct_read(tac_fd, &arep);",
          "416:   if (ret == 0) {",
          "417:    if (!quiet)",
          "",
          "[Removed Lines]",
          "414:   tac_acct_send(tac_fd, TAC_PLUS_ACCT_FLAG_STOP, user, tty, remote_addr, attr);",
          "",
          "[Added Lines]",
          "412:   tac_acct_send(tac_fd, TAC_PLUS_ACCT_FLAG_STOP, user, tty, remote_addr,",
          "413:     attr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "429: #ifdef HAVE_LOGWTMP",
          "430:  if (log_wtmp)",
          "432: #endif",
          "434:  exit(EXIT_OK);",
          "",
          "[Removed Lines]",
          "431:  logwtmp(tty, \"\", \"\");",
          "",
          "[Added Lines]",
          "430:   logwtmp(tty, \"\", \"\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "439: }",
          "441: void authenticate(const struct addrinfo *tac_server, const char *tac_secret,",
          "443:  int tac_fd;",
          "444:  char *msg;",
          "445:  int ret;",
          "",
          "[Removed Lines]",
          "442:   const char *user, const char *pass, const char *tty, const char *remote_addr) {",
          "",
          "[Added Lines]",
          "441:   const char *user, const char *pass, const char *tty,",
          "442:   const char *remote_addr) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "458:   if (!quiet)",
          "459:    printf(\"Error sending query to TACACS+ server\\n\");",
          "460:   exit(EXIT_ERR);",
          "",
          "[Removed Lines]",
          "457:  if (tac_authen_send(tac_fd, user, pass, tty, remote_addr, TAC_PLUS_AUTHEN_LOGIN) < 0) {",
          "",
          "[Added Lines]",
          "457:  if (tac_authen_send(tac_fd, user, pass, tty, remote_addr,",
          "458:    TAC_PLUS_AUTHEN_LOGIN) < 0) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "487:  printf(\"Copyright 1997-2016 by Pawel Krawczyk <pawel.krawczyk@hush.com>\\n\");",
          "488:  printf(\"Usage: %s option [option, ...]\\n\\n\", progname);",
          "489:  printf(\" Action:\\n\");",
          "492:  printf(\"  -A, --account       account session beginning and end\\n\");",
          "493:  printf(\"  -h, --help          display this help and exit\\n\");",
          "494:  printf(\"  -V, --version       display version number and exit\\n\\n\");",
          "",
          "[Removed Lines]",
          "490:  printf(\"  -T, --authenticate  perform authentication with username and password\\n\");",
          "491:  printf(\"  -R, --authorize     perform authorization for requested service\\n\");",
          "",
          "[Added Lines]",
          "491:  printf(",
          "492:    \"  -T, --authenticate  perform authentication with username and password\\n\");",
          "493:  printf(",
          "494:    \"  -R, --authorize     perform authorization for requested service\\n\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "504:  printf(\"  -c, --command       command to execute after successful AAA\\n\");",
          "505:  printf(\"       --exec         alias for --command\\n\\n\");",
          "506:  printf(\" Modifiers:\\n\");",
          "508:  printf(\"      --silent        report them via syslog(3))\\n\");",
          "509:  printf(\"  -w, --no-wtmp       don't write records to wtmp(5)\\n\");",
          "514:  exit(EXIT_ERR);",
          "515: }",
          "",
          "[Removed Lines]",
          "507:  printf(\"  -q, --quiet         don't display messages to screen (but still\\n\");",
          "510:  printf(\"  -n, --no-encrypt    don't encrypt AAA packets sent to servers\\n\\n\");",
          "511:     printf(\"Example usage:\\n\\n\");",
          "512:     printf(\"  tacc -TRA -u test1 -p test1 -s localhost -r 1.1.1.1 -k test1 -S ppp -P ip\\n\");",
          "",
          "[Added Lines]",
          "510:  printf(",
          "511:    \"  -q, --quiet         don't display messages to screen (but still\\n\");",
          "514:  printf(",
          "515:    \"  -n, --no-encrypt    don't encrypt AAA packets sent to servers\\n\\n\");",
          "516:  printf(\"Example usage:\\n\\n\");",
          "517:  printf(",
          "518:    \"  tacc -TRA -u test1 -p test1 -s localhost -r 1.1.1.1 -k test1 -S ppp -P ip\\n\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
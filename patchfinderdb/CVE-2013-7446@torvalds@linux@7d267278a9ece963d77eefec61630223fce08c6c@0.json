{
  "cve_id": "CVE-2013-7446",
  "cve_desc": "Use-after-free vulnerability in net/unix/af_unix.c in the Linux kernel before 4.3.3 allows local users to bypass intended AF_UNIX socket permissions or cause a denial of service (panic) via crafted epoll_ctl calls.",
  "repo": "torvalds/linux",
  "patch_hash": "7d267278a9ece963d77eefec61630223fce08c6c",
  "patch_info": {
    "commit_hash": "7d267278a9ece963d77eefec61630223fce08c6c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c",
    "files": [
      "include/net/af_unix.h",
      "net/unix/af_unix.c"
    ],
    "message": "unix: avoid use-after-free in ep_remove_wait_queue\n\nRainer Weikusat <rweikusat@mobileactivedefense.com> writes:\nAn AF_UNIX datagram socket being the client in an n:1 association with\nsome server socket is only allowed to send messages to the server if the\nreceive queue of this socket contains at most sk_max_ack_backlog\ndatagrams. This implies that prospective writers might be forced to go\nto sleep despite none of the message presently enqueued on the server\nreceive queue were sent by them. In order to ensure that these will be\nwoken up once space becomes again available, the present unix_dgram_poll\nroutine does a second sock_poll_wait call with the peer_wait wait queue\nof the server socket as queue argument (unix_dgram_recvmsg does a wake\nup on this queue after a datagram was received). This is inherently\nproblematic because the server socket is only guaranteed to remain alive\nfor as long as the client still holds a reference to it. In case the\nconnection is dissolved via connect or by the dead peer detection logic\nin unix_dgram_sendmsg, the server socket may be freed despite \"the\npolling mechanism\" (in particular, epoll) still has a pointer to the\ncorresponding peer_wait queue. There's no way to forcibly deregister a\nwait queue with epoll.\n\nBased on an idea by Jason Baron, the patch below changes the code such\nthat a wait_queue_t belonging to the client socket is enqueued on the\npeer_wait queue of the server whenever the peer receive queue full\ncondition is detected by either a sendmsg or a poll. A wake up on the\npeer queue is then relayed to the ordinary wait queue of the client\nsocket via wake function. The connection to the peer wait queue is again\ndissolved if either a wake up is about to be relayed or the client\nsocket reconnects or a dead peer is detected or the client socket is\nitself closed. This enables removing the second sock_poll_wait from\nunix_dgram_poll, thus avoiding the use-after-free, while still ensuring\nthat no blocked writer sleeps forever.\n\nSigned-off-by: Rainer Weikusat <rweikusat@mobileactivedefense.com>\nFixes: ec0d215f9420 (\"af_unix: fix 'poll for write'/connected DGRAM sockets\")\nReviewed-by: Jason Baron <jbaron@akamai.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "include/net/af_unix.h||include/net/af_unix.h",
      "net/unix/af_unix.c||net/unix/af_unix.c"
    ]
  },
  "patch_diff": {
    "include/net/af_unix.h||include/net/af_unix.h": [
      "File: include/net/af_unix.h -> include/net/af_unix.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "62: #define UNIX_GC_CANDIDATE 0",
      "63: #define UNIX_GC_MAYBE_CYCLE 1",
      "64:  struct socket_wq peer_wq;",
      "65: };",
      "67: static inline struct unix_sock *unix_sk(const struct sock *sk)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "65:  wait_queue_t  peer_wake;",
      "",
      "---------------"
    ],
    "net/unix/af_unix.c||net/unix/af_unix.c": [
      "File: net/unix/af_unix.c -> net/unix/af_unix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "326:  return s;",
      "327: }",
      "329: static int unix_writable(const struct sock *sk)",
      "330: {",
      "331:  return sk->sk_state != TCP_LISTEN &&",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "354: static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,",
      "355:           void *key)",
      "356: {",
      "357:  struct unix_sock *u;",
      "358:  wait_queue_head_t *u_sleep;",
      "360:  u = container_of(q, struct unix_sock, peer_wake);",
      "362:  __remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,",
      "363:        q);",
      "364:  u->peer_wake.private = NULL;",
      "367:  u_sleep = sk_sleep(&u->sk);",
      "368:  if (u_sleep)",
      "369:   wake_up_interruptible_poll(u_sleep, key);",
      "371:  return 0;",
      "372: }",
      "374: static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)",
      "375: {",
      "376:  struct unix_sock *u, *u_other;",
      "377:  int rc;",
      "379:  u = unix_sk(sk);",
      "380:  u_other = unix_sk(other);",
      "381:  rc = 0;",
      "382:  spin_lock(&u_other->peer_wait.lock);",
      "384:  if (!u->peer_wake.private) {",
      "385:   u->peer_wake.private = other;",
      "386:   __add_wait_queue(&u_other->peer_wait, &u->peer_wake);",
      "388:   rc = 1;",
      "389:  }",
      "391:  spin_unlock(&u_other->peer_wait.lock);",
      "392:  return rc;",
      "393: }",
      "395: static void unix_dgram_peer_wake_disconnect(struct sock *sk,",
      "396:          struct sock *other)",
      "397: {",
      "398:  struct unix_sock *u, *u_other;",
      "400:  u = unix_sk(sk);",
      "401:  u_other = unix_sk(other);",
      "402:  spin_lock(&u_other->peer_wait.lock);",
      "404:  if (u->peer_wake.private == other) {",
      "405:   __remove_wait_queue(&u_other->peer_wait, &u->peer_wake);",
      "406:   u->peer_wake.private = NULL;",
      "407:  }",
      "409:  spin_unlock(&u_other->peer_wait.lock);",
      "410: }",
      "412: static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,",
      "413:          struct sock *other)",
      "414: {",
      "415:  unix_dgram_peer_wake_disconnect(sk, other);",
      "416:  wake_up_interruptible_poll(sk_sleep(sk),",
      "417:        POLLOUT |",
      "418:        POLLWRNORM |",
      "419:        POLLWRBAND);",
      "420: }",
      "426: static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)",
      "427: {",
      "428:  int connected;",
      "430:  connected = unix_dgram_peer_wake_connect(sk, other);",
      "432:  if (unix_recvq_full(other))",
      "433:   return 1;",
      "435:  if (connected)",
      "436:   unix_dgram_peer_wake_disconnect(sk, other);",
      "438:  return 0;",
      "439: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "431:    skpair->sk_state_change(skpair);",
      "432:    sk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);",
      "433:   }",
      "435:   unix_peer(sk) = NULL;",
      "436:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "547:   unix_dgram_peer_wake_disconnect(sk, skpair);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "666:  INIT_LIST_HEAD(&u->link);",
      "668:  init_waitqueue_head(&u->peer_wait);",
      "669:  unix_insert_socket(unix_sockets_unbound(sk), sk);",
      "670: out:",
      "671:  if (sk == NULL)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "783:  init_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1033:  if (unix_peer(sk)) {",
      "1034:   struct sock *old_peer = unix_peer(sk);",
      "1035:   unix_peer(sk) = other;",
      "1036:   unix_state_double_unlock(sk, other);",
      "1038:   if (other != old_peer)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1151:   unix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1472:  struct scm_cookie scm;",
      "1473:  int max_level;",
      "1474:  int data_len = 0;",
      "1476:  wait_for_unix_gc();",
      "1477:  err = scm_send(sock, msg, &scm, false);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1592:  int sk_locked;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1550:   goto out_free;",
      "1551:  }",
      "1553:  unix_state_lock(other);",
      "1554:  err = -EPERM;",
      "1555:  if (!unix_may_send(sk, other))",
      "1556:   goto out_unlock;",
      "",
      "[Removed Lines]",
      "1558:  if (sock_flag(other, SOCK_DEAD)) {",
      "",
      "[Added Lines]",
      "1671:  sk_locked = 0;",
      "1673: restart_locked:",
      "1678:  if (unlikely(sock_flag(other, SOCK_DEAD))) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1563:   unix_state_unlock(other);",
      "1564:   sock_put(other);",
      "1566:   err = 0;",
      "1568:   if (unix_peer(sk) == other) {",
      "1569:    unix_peer(sk) = NULL;",
      "1570:    unix_state_unlock(sk);",
      "1572:    unix_dgram_disconnected(sk, other);",
      "",
      "[Removed Lines]",
      "1567:   unix_state_lock(sk);",
      "",
      "[Added Lines]",
      "1686:   if (!sk_locked)",
      "1687:    unix_state_lock(sk);",
      "1692:    unix_dgram_peer_wake_disconnect_wakeup(sk, other);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1592:    goto out_unlock;",
      "1593:  }",
      "1599:   }",
      "1608:  }",
      "1610:  if (sock_flag(other, SOCK_RCVTSTAMP))",
      "1611:   __net_timestamp(skb);",
      "1612:  maybe_add_creds(skb, sock, other);",
      "",
      "[Removed Lines]",
      "1595:  if (unix_peer(other) != sk && unix_recvq_full(other)) {",
      "1596:   if (!timeo) {",
      "1597:    err = -EAGAIN;",
      "1598:    goto out_unlock;",
      "1601:   timeo = unix_wait_for_peer(other, timeo);",
      "1603:   err = sock_intr_errno(timeo);",
      "1604:   if (signal_pending(current))",
      "1605:    goto out_free;",
      "1607:   goto restart;",
      "",
      "[Added Lines]",
      "1719:  if (unlikely(unix_peer(other) != sk && unix_recvq_full(other))) {",
      "1720:   if (timeo) {",
      "1721:    timeo = unix_wait_for_peer(other, timeo);",
      "1723:    err = sock_intr_errno(timeo);",
      "1724:    if (signal_pending(current))",
      "1725:     goto out_free;",
      "1727:    goto restart;",
      "1730:   if (!sk_locked) {",
      "1731:    unix_state_unlock(other);",
      "1732:    unix_state_double_lock(sk, other);",
      "1733:   }",
      "1735:   if (unix_peer(sk) != other ||",
      "1736:       unix_dgram_peer_wake_me(sk, other)) {",
      "1737:    err = -EAGAIN;",
      "1738:    sk_locked = 1;",
      "1739:    goto out_unlock;",
      "1740:   }",
      "1742:   if (!sk_locked) {",
      "1743:    sk_locked = 1;",
      "1744:    goto restart_locked;",
      "1745:   }",
      "1748:  if (unlikely(sk_locked))",
      "1749:   unix_state_unlock(sk);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1620:  return len;",
      "1622: out_unlock:",
      "1623:  unix_state_unlock(other);",
      "1624: out_free:",
      "1625:  kfree_skb(skb);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1764:  if (sk_locked)",
      "1765:   unix_state_unlock(sk);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2476:   return mask;",
      "2478:  writable = unix_writable(sk);",
      "2487:  }",
      "2489:  if (writable)",
      "",
      "[Removed Lines]",
      "2479:  other = unix_peer_get(sk);",
      "2480:  if (other) {",
      "2481:   if (unix_peer(other) != sk) {",
      "2482:    sock_poll_wait(file, &unix_sk(other)->peer_wait, wait);",
      "2483:    if (unix_recvq_full(other))",
      "2484:     writable = 0;",
      "2485:   }",
      "2486:   sock_put(other);",
      "",
      "[Added Lines]",
      "2622:  if (writable) {",
      "2623:   unix_state_lock(sk);",
      "2625:   other = unix_peer(sk);",
      "2626:   if (other && unix_peer(other) != sk &&",
      "2627:       unix_recvq_full(other) &&",
      "2628:       unix_dgram_peer_wake_me(sk, other))",
      "2629:    writable = 0;",
      "2631:   unix_state_unlock(sk);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a5527dda344fff0514b7989ef7a755729769daa1",
      "candidate_info": {
        "commit_hash": "a5527dda344fff0514b7989ef7a755729769daa1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a5527dda344fff0514b7989ef7a755729769daa1",
        "files": [
          "net/unix/af_unix.c"
        ],
        "message": "af_unix: Guard against other == sk in unix_dgram_sendmsg\n\nThe unix_dgram_sendmsg routine use the following test\n\nif (unlikely(unix_peer(other) != sk && unix_recvq_full(other))) {\n\nto determine if sk and other are in an n:1 association (either\nestablished via connect or by using sendto to send messages to an\nunrelated socket identified by address). This isn't correct as the\nspecified address could have been bound to the sending socket itself or\nbecause this socket could have been connected to itself by the time of\nthe unix_peer_get but disconnected before the unix_state_lock(other). In\nboth cases, the if-block would be entered despite other == sk which\nmight either block the sender unintentionally or lead to trying to unlock\nthe same spin lock twice for a non-blocking send. Add a other != sk\ncheck to guard against this.\n\nFixes: 7d267278a9ec (\"unix: avoid use-after-free in ep_remove_wait_queue\")\nReported-By: Philipp Hahn <pmhahn@pmhahn.de>\nSigned-off-by: Rainer Weikusat <rweikusat@mobileactivedefense.com>\nTested-by: Philipp Hahn <pmhahn@pmhahn.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/unix/af_unix.c||net/unix/af_unix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/unix/af_unix.c||net/unix/af_unix.c"
          ],
          "candidate": [
            "net/unix/af_unix.c||net/unix/af_unix.c"
          ]
        }
      },
      "candidate_diff": {
        "net/unix/af_unix.c||net/unix/af_unix.c": [
          "File: net/unix/af_unix.c -> net/unix/af_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1781:    goto out_unlock;",
          "1782:  }",
          "1785:   if (timeo) {",
          "1786:    timeo = unix_wait_for_peer(other, timeo);",
          "",
          "[Removed Lines]",
          "1784:  if (unlikely(unix_peer(other) != sk && unix_recvq_full(other))) {",
          "",
          "[Added Lines]",
          "1788:  if (other != sk &&",
          "1789:      unlikely(unix_peer(other) != sk && unix_recvq_full(other))) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7cc05662682da4b0e0a4fdf3c3f190577803ae81",
      "candidate_info": {
        "commit_hash": "7cc05662682da4b0e0a4fdf3c3f190577803ae81",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7cc05662682da4b0e0a4fdf3c3f190577803ae81",
        "files": [
          "include/net/sock.h",
          "net/netlink/af_netlink.c",
          "net/socket.c",
          "net/unix/af_unix.c"
        ],
        "message": "net: remove sock_iocb\n\nThe sock_iocb structure is allocate on stack for each read/write-like\noperation on sockets, and contains various fields of which only the\nembedded msghdr and sometimes a pointer to the scm_cookie is ever used.\nGet rid of the sock_iocb and put a msghdr directly on the stack and pass\nthe scm_cookie explicitly to netlink_mmap_sendmsg.\n\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/sock.h||include/net/sock.h",
          "net/netlink/af_netlink.c||net/netlink/af_netlink.c",
          "net/socket.c||net/socket.c",
          "net/unix/af_unix.c||net/unix/af_unix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/unix/af_unix.c||net/unix/af_unix.c"
          ],
          "candidate": [
            "net/unix/af_unix.c||net/unix/af_unix.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/sock.h||include/net/sock.h": [
          "File: include/net/sock.h -> include/net/sock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1374: #define SOCK_BINDADDR_LOCK 4",
          "1375: #define SOCK_BINDPORT_LOCK 8",
          "1400: struct socket_alloc {",
          "1401:  struct socket socket;",
          "1402:  struct inode vfs_inode;",
          "",
          "[Removed Lines]",
          "1378: struct sock_iocb {",
          "1379:  struct list_head list;",
          "1381:  int   flags;",
          "1382:  int   size;",
          "1383:  struct socket  *sock;",
          "1384:  struct sock  *sk;",
          "1385:  struct scm_cookie *scm;",
          "1386:  struct msghdr  *msg, async_msg;",
          "1387:  struct kiocb  *kiocb;",
          "1388: };",
          "1390: static inline struct sock_iocb *kiocb_to_siocb(struct kiocb *iocb)",
          "1391: {",
          "1392:  return (struct sock_iocb *)iocb->private;",
          "1393: }",
          "1395: static inline struct kiocb *siocb_to_kiocb(struct sock_iocb *si)",
          "1396: {",
          "1397:  return si->kiocb;",
          "1398: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "net/netlink/af_netlink.c||net/netlink/af_netlink.c": [
          "File: net/netlink/af_netlink.c -> net/netlink/af_netlink.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696: static int netlink_mmap_sendmsg(struct sock *sk, struct msghdr *msg,",
          "697:     u32 dst_portid, u32 dst_group,",
          "699: {",
          "700:  struct netlink_sock *nlk = nlk_sk(sk);",
          "701:  struct netlink_ring *ring;",
          "",
          "[Removed Lines]",
          "698:     struct sock_iocb *siocb)",
          "",
          "[Added Lines]",
          "698:     struct scm_cookie *scm)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "742:   NETLINK_CB(skb).portid   = nlk->portid;",
          "743:   NETLINK_CB(skb).dst_group = dst_group;",
          "746:   err = security_netlink_send(sk, skb);",
          "747:   if (err) {",
          "",
          "[Removed Lines]",
          "744:   NETLINK_CB(skb).creds   = siocb->scm->creds;",
          "",
          "[Added Lines]",
          "744:   NETLINK_CB(skb).creds   = scm->creds;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "820: #define netlink_tx_is_mmaped(sk) false",
          "821: #define netlink_mmap   sock_no_mmap",
          "822: #define netlink_poll   datagram_poll",
          "826: static void netlink_skb_destructor(struct sk_buff *skb)",
          "",
          "[Removed Lines]",
          "823: #define netlink_mmap_sendmsg(sk, msg, dst_portid, dst_group, siocb) 0",
          "",
          "[Added Lines]",
          "823: #define netlink_mmap_sendmsg(sk, msg, dst_portid, dst_group, scm) 0",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2259: static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,",
          "2260:       struct msghdr *msg, size_t len)",
          "2261: {",
          "2263:  struct sock *sk = sock->sk;",
          "2264:  struct netlink_sock *nlk = nlk_sk(sk);",
          "2265:  DECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
          "",
          "[Removed Lines]",
          "2262:  struct sock_iocb *siocb = kiocb_to_siocb(kiocb);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2273:  if (msg->msg_flags&MSG_OOB)",
          "2274:   return -EOPNOTSUPP;",
          "2280:  if (err < 0)",
          "2281:   return err;",
          "",
          "[Removed Lines]",
          "2276:  if (NULL == siocb->scm)",
          "2277:   siocb->scm = &scm;",
          "2279:  err = scm_send(sock, msg, siocb->scm, true);",
          "",
          "[Added Lines]",
          "2275:  err = scm_send(sock, msg, &scm, true);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2305:  if (netlink_tx_is_mmaped(sk) &&",
          "2306:      msg->msg_iter.iov->iov_base == NULL) {",
          "2307:   err = netlink_mmap_sendmsg(sk, msg, dst_portid, dst_group,",
          "2309:   goto out;",
          "2310:  }",
          "",
          "[Removed Lines]",
          "2308:         siocb);",
          "",
          "[Added Lines]",
          "2304:         &scm);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2320:  NETLINK_CB(skb).portid = nlk->portid;",
          "2321:  NETLINK_CB(skb).dst_group = dst_group;",
          "2323:  NETLINK_CB(skb).flags = netlink_skb_flags;",
          "2325:  err = -EFAULT;",
          "",
          "[Removed Lines]",
          "2322:  NETLINK_CB(skb).creds = siocb->scm->creds;",
          "",
          "[Added Lines]",
          "2318:  NETLINK_CB(skb).creds = scm.creds;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2341:  err = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);",
          "2343: out:",
          "2345:  return err;",
          "2346: }",
          "",
          "[Removed Lines]",
          "2344:  scm_destroy(siocb->scm);",
          "",
          "[Added Lines]",
          "2340:  scm_destroy(&scm);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2349:       struct msghdr *msg, size_t len,",
          "2350:       int flags)",
          "2351: {",
          "2353:  struct scm_cookie scm;",
          "2354:  struct sock *sk = sock->sk;",
          "2355:  struct netlink_sock *nlk = nlk_sk(sk);",
          "",
          "[Removed Lines]",
          "2352:  struct sock_iocb *siocb = kiocb_to_siocb(kiocb);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2412:  if (nlk->flags & NETLINK_RECV_PKTINFO)",
          "2413:   netlink_cmsg_recv_pktinfo(msg, skb);",
          "2420:  if (flags & MSG_TRUNC)",
          "2421:   copied = data_skb->len;",
          "",
          "[Removed Lines]",
          "2415:  if (NULL == siocb->scm) {",
          "2416:   memset(&scm, 0, sizeof(scm));",
          "2417:   siocb->scm = &scm;",
          "2418:  }",
          "2419:  siocb->scm->creds = *NETLINK_CREDS(skb);",
          "",
          "[Added Lines]",
          "2410:  memset(&scm, 0, sizeof(scm));",
          "2411:  scm.creds = *NETLINK_CREDS(skb);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2431:   }",
          "2432:  }",
          "2435: out:",
          "2436:  netlink_rcv_wake(sk);",
          "2437:  return err ? : copied;",
          "",
          "[Removed Lines]",
          "2434:  scm_recv(sock, msg, siocb->scm, flags);",
          "",
          "[Added Lines]",
          "2426:  scm_recv(sock, msg, &scm, flags);",
          "",
          "---------------"
        ],
        "net/socket.c||net/socket.c": [
          "File: net/socket.c -> net/socket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "613: static inline int __sock_sendmsg_nosec(struct kiocb *iocb, struct socket *sock,",
          "614:            struct msghdr *msg, size_t size)",
          "615: {",
          "623:  return sock->ops->sendmsg(iocb, sock, msg, size);",
          "624: }",
          "",
          "[Removed Lines]",
          "616:  struct sock_iocb *si = kiocb_to_siocb(iocb);",
          "618:  si->sock = sock;",
          "619:  si->scm = NULL;",
          "620:  si->msg = msg;",
          "621:  si->size = size;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "635:       size_t size, bool nosec)",
          "636: {",
          "637:  struct kiocb iocb;",
          "639:  int ret;",
          "641:  init_sync_kiocb(&iocb, NULL);",
          "643:  ret = nosec ? __sock_sendmsg_nosec(&iocb, sock, msg, size) :",
          "644:         __sock_sendmsg(&iocb, sock, msg, size);",
          "645:  if (-EIOCBQUEUED == ret)",
          "",
          "[Removed Lines]",
          "638:  struct sock_iocb siocb;",
          "642:  iocb.private = &siocb;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "756: static inline int __sock_recvmsg_nosec(struct kiocb *iocb, struct socket *sock,",
          "757:            struct msghdr *msg, size_t size, int flags)",
          "758: {",
          "767:  return sock->ops->recvmsg(iocb, sock, msg, size, flags);",
          "768: }",
          "",
          "[Removed Lines]",
          "759:  struct sock_iocb *si = kiocb_to_siocb(iocb);",
          "761:  si->sock = sock;",
          "762:  si->scm = NULL;",
          "763:  si->msg = msg;",
          "764:  si->size = size;",
          "765:  si->flags = flags;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "779:    size_t size, int flags)",
          "780: {",
          "781:  struct kiocb iocb;",
          "783:  int ret;",
          "785:  init_sync_kiocb(&iocb, NULL);",
          "787:  ret = __sock_recvmsg(&iocb, sock, msg, size, flags);",
          "788:  if (-EIOCBQUEUED == ret)",
          "789:   ret = wait_on_sync_kiocb(&iocb);",
          "",
          "[Removed Lines]",
          "782:  struct sock_iocb siocb;",
          "786:  iocb.private = &siocb;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "795:          size_t size, int flags)",
          "796: {",
          "797:  struct kiocb iocb;",
          "799:  int ret;",
          "801:  init_sync_kiocb(&iocb, NULL);",
          "803:  ret = __sock_recvmsg_nosec(&iocb, sock, msg, size, flags);",
          "804:  if (-EIOCBQUEUED == ret)",
          "805:   ret = wait_on_sync_kiocb(&iocb);",
          "",
          "[Removed Lines]",
          "798:  struct sock_iocb siocb;",
          "802:  iocb.private = &siocb;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "866:  return sock->ops->splice_read(sock, ppos, pipe, len, flags);",
          "867: }",
          "877: static ssize_t do_sock_read(struct msghdr *msg, struct kiocb *iocb,",
          "878:   struct file *file, const struct iovec *iov,",
          "879:   unsigned long nr_segs)",
          "",
          "[Removed Lines]",
          "869: static struct sock_iocb *alloc_sock_iocb(struct kiocb *iocb,",
          "870:       struct sock_iocb *siocb)",
          "871: {",
          "872:  siocb->kiocb = iocb;",
          "873:  iocb->private = siocb;",
          "874:  return siocb;",
          "875: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "893: static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,",
          "894:     unsigned long nr_segs, loff_t pos)",
          "895: {",
          "898:  if (pos != 0)",
          "899:   return -ESPIPE;",
          "",
          "[Removed Lines]",
          "896:  struct sock_iocb siocb, *x;",
          "",
          "[Added Lines]",
          "867:  struct msghdr msg;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "902:   return 0;",
          "909: }",
          "911: static ssize_t do_sock_write(struct msghdr *msg, struct kiocb *iocb,",
          "",
          "[Removed Lines]",
          "905:  x = alloc_sock_iocb(iocb, &siocb);",
          "906:  if (!x)",
          "907:   return -ENOMEM;",
          "908:  return do_sock_read(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);",
          "",
          "[Added Lines]",
          "875:  return do_sock_read(&msg, iocb, iocb->ki_filp, iov, nr_segs);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "929: static ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,",
          "930:      unsigned long nr_segs, loff_t pos)",
          "931: {",
          "934:  if (pos != 0)",
          "935:   return -ESPIPE;",
          "942: }",
          "",
          "[Removed Lines]",
          "932:  struct sock_iocb siocb, *x;",
          "937:  x = alloc_sock_iocb(iocb, &siocb);",
          "938:  if (!x)",
          "939:   return -ENOMEM;",
          "941:  return do_sock_write(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);",
          "",
          "[Added Lines]",
          "899:  struct msghdr msg;",
          "904:  return do_sock_write(&msg, iocb, iocb->ki_filp, iov, nr_segs);",
          "",
          "---------------"
        ],
        "net/unix/af_unix.c||net/unix/af_unix.c": [
          "File: net/unix/af_unix.c -> net/unix/af_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1445: static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,",
          "1446:          struct msghdr *msg, size_t len)",
          "1447: {",
          "1449:  struct sock *sk = sock->sk;",
          "1450:  struct net *net = sock_net(sk);",
          "1451:  struct unix_sock *u = unix_sk(sk);",
          "",
          "[Removed Lines]",
          "1448:  struct sock_iocb *siocb = kiocb_to_siocb(kiocb);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1456:  unsigned int hash;",
          "1457:  struct sk_buff *skb;",
          "1458:  long timeo;",
          "1460:  int max_level;",
          "1461:  int data_len = 0;",
          "1465:  wait_for_unix_gc();",
          "1467:  if (err < 0)",
          "1468:   return err;",
          "",
          "[Removed Lines]",
          "1459:  struct scm_cookie tmp_scm;",
          "1463:  if (NULL == siocb->scm)",
          "1464:   siocb->scm = &tmp_scm;",
          "1466:  err = scm_send(sock, msg, siocb->scm, false);",
          "",
          "[Added Lines]",
          "1458:  struct scm_cookie scm;",
          "1463:  err = scm_send(sock, msg, &scm, false);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1507:  if (skb == NULL)",
          "1508:   goto out;",
          "1511:  if (err < 0)",
          "1512:   goto out_free;",
          "1513:  max_level = err + 1;",
          "1516:  skb_put(skb, len - data_len);",
          "1517:  skb->data_len = data_len;",
          "",
          "[Removed Lines]",
          "1510:  err = unix_scm_to_skb(siocb->scm, skb, true);",
          "1514:  unix_get_secdata(siocb->scm, skb);",
          "",
          "[Added Lines]",
          "1507:  err = unix_scm_to_skb(&scm, skb, true);",
          "1511:  unix_get_secdata(&scm, skb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1606:  unix_state_unlock(other);",
          "1607:  other->sk_data_ready(other);",
          "1608:  sock_put(other);",
          "1610:  return len;",
          "1612: out_unlock:",
          "",
          "[Removed Lines]",
          "1609:  scm_destroy(siocb->scm);",
          "",
          "[Added Lines]",
          "1606:  scm_destroy(&scm);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1616: out:",
          "1617:  if (other)",
          "1618:   sock_put(other);",
          "1620:  return err;",
          "1621: }",
          "",
          "[Removed Lines]",
          "1619:  scm_destroy(siocb->scm);",
          "",
          "[Added Lines]",
          "1616:  scm_destroy(&scm);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1628: static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,",
          "1629:           struct msghdr *msg, size_t len)",
          "1630: {",
          "1632:  struct sock *sk = sock->sk;",
          "1633:  struct sock *other = NULL;",
          "1634:  int err, size;",
          "1635:  struct sk_buff *skb;",
          "1636:  int sent = 0;",
          "1638:  bool fds_sent = false;",
          "1639:  int max_level;",
          "1640:  int data_len;",
          "1644:  wait_for_unix_gc();",
          "1646:  if (err < 0)",
          "1647:   return err;",
          "",
          "[Removed Lines]",
          "1631:  struct sock_iocb *siocb = kiocb_to_siocb(kiocb);",
          "1637:  struct scm_cookie tmp_scm;",
          "1642:  if (NULL == siocb->scm)",
          "1643:   siocb->scm = &tmp_scm;",
          "1645:  err = scm_send(sock, msg, siocb->scm, false);",
          "",
          "[Added Lines]",
          "1633:  struct scm_cookie scm;",
          "1639:  err = scm_send(sock, msg, &scm, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1683:    goto out_err;",
          "1687:   if (err < 0) {",
          "1688:    kfree_skb(skb);",
          "1689:    goto out_err;",
          "",
          "[Removed Lines]",
          "1686:   err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);",
          "",
          "[Added Lines]",
          "1680:   err = unix_scm_to_skb(&scm, skb, !fds_sent);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1715:   sent += size;",
          "1716:  }",
          "1721:  return sent;",
          "",
          "[Removed Lines]",
          "1718:  scm_destroy(siocb->scm);",
          "1719:  siocb->scm = NULL;",
          "",
          "[Added Lines]",
          "1712:  scm_destroy(&scm);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1728:   send_sig(SIGPIPE, current, 0);",
          "1729:  err = -EPIPE;",
          "1730: out_err:",
          "1733:  return sent ? : err;",
          "1734: }",
          "",
          "[Removed Lines]",
          "1731:  scm_destroy(siocb->scm);",
          "1732:  siocb->scm = NULL;",
          "",
          "[Added Lines]",
          "1724:  scm_destroy(&scm);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1778:          struct msghdr *msg, size_t size,",
          "1779:          int flags)",
          "1780: {",
          "1783:  struct sock *sk = sock->sk;",
          "1784:  struct unix_sock *u = unix_sk(sk);",
          "1785:  int noblock = flags & MSG_DONTWAIT;",
          "",
          "[Removed Lines]",
          "1781:  struct sock_iocb *siocb = kiocb_to_siocb(iocb);",
          "1782:  struct scm_cookie tmp_scm;",
          "",
          "[Added Lines]",
          "1773:  struct scm_cookie scm;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1831:  if (sock_flag(sk, SOCK_RCVTSTAMP))",
          "1832:   __sock_recv_timestamp(msg, sk, skb);",
          "1841:  if (!(flags & MSG_PEEK)) {",
          "1842:   if (UNIXCB(skb).fp)",
          "1845:   sk_peek_offset_bwd(sk, skb->len);",
          "1846:  } else {",
          "",
          "[Removed Lines]",
          "1834:  if (!siocb->scm) {",
          "1835:   siocb->scm = &tmp_scm;",
          "1836:   memset(&tmp_scm, 0, sizeof(tmp_scm));",
          "1837:  }",
          "1838:  scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);",
          "1839:  unix_set_secdata(siocb->scm, skb);",
          "1843:    unix_detach_fds(siocb->scm, skb);",
          "",
          "[Added Lines]",
          "1825:  memset(&scm, 0, sizeof(scm));",
          "1827:  scm_set_cred(&scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);",
          "1828:  unix_set_secdata(&scm, skb);",
          "1832:    unix_detach_fds(&scm, skb);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1860:   sk_peek_offset_fwd(sk, size);",
          "1862:   if (UNIXCB(skb).fp)",
          "1864:  }",
          "1865:  err = (flags & MSG_TRUNC) ? skb->len - skip : size;",
          "1869: out_free:",
          "1870:  skb_free_datagram(sk, skb);",
          "",
          "[Removed Lines]",
          "1863:    siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);",
          "1867:  scm_recv(sock, msg, siocb->scm, flags);",
          "",
          "[Added Lines]",
          "1852:    scm.fp = scm_fp_dup(UNIXCB(skb).fp);",
          "1856:  scm_recv(sock, msg, &scm, flags);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1915:           struct msghdr *msg, size_t size,",
          "1916:           int flags)",
          "1917: {",
          "1920:  struct sock *sk = sock->sk;",
          "1921:  struct unix_sock *u = unix_sk(sk);",
          "1922:  DECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, msg->msg_name);",
          "",
          "[Removed Lines]",
          "1918:  struct sock_iocb *siocb = kiocb_to_siocb(iocb);",
          "1919:  struct scm_cookie tmp_scm;",
          "",
          "[Added Lines]",
          "1907:  struct scm_cookie scm;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1951:  err = mutex_lock_interruptible(&u->readlock);",
          "1952:  if (unlikely(err)) {",
          "",
          "[Removed Lines]",
          "1946:  if (!siocb->scm) {",
          "1947:   siocb->scm = &tmp_scm;",
          "1948:   memset(&tmp_scm, 0, sizeof(tmp_scm));",
          "1949:  }",
          "",
          "[Added Lines]",
          "1934:  memset(&scm, 0, sizeof(scm));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2013:   if (check_creds) {",
          "2018:     break;",
          "2019:   } else if (test_bit(SOCK_PASSCRED, &sock->flags)) {",
          "2022:    check_creds = 1;",
          "2023:   }",
          "",
          "[Removed Lines]",
          "2015:    if ((UNIXCB(skb).pid  != siocb->scm->pid) ||",
          "2016:        !uid_eq(UNIXCB(skb).uid, siocb->scm->creds.uid) ||",
          "2017:        !gid_eq(UNIXCB(skb).gid, siocb->scm->creds.gid))",
          "2021:    scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);",
          "",
          "[Added Lines]",
          "2000:    if ((UNIXCB(skb).pid  != scm.pid) ||",
          "2001:        !uid_eq(UNIXCB(skb).uid, scm.creds.uid) ||",
          "2002:        !gid_eq(UNIXCB(skb).gid, scm.creds.gid))",
          "2006:    scm_set_cred(&scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2045:    sk_peek_offset_bwd(sk, chunk);",
          "2047:    if (UNIXCB(skb).fp)",
          "2050:    if (unix_skb_len(skb))",
          "2051:     break;",
          "",
          "[Removed Lines]",
          "2048:     unix_detach_fds(siocb->scm, skb);",
          "",
          "[Added Lines]",
          "2033:     unix_detach_fds(&scm, skb);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2053:    skb_unlink(skb, &sk->sk_receive_queue);",
          "2054:    consume_skb(skb);",
          "2057:     break;",
          "2058:   } else {",
          "2061:    if (UNIXCB(skb).fp)",
          "2064:    sk_peek_offset_fwd(sk, chunk);",
          "",
          "[Removed Lines]",
          "2056:    if (siocb->scm->fp)",
          "2062:     siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);",
          "",
          "[Added Lines]",
          "2041:    if (scm.fp)",
          "2047:     scm.fp = scm_fp_dup(UNIXCB(skb).fp);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2068:  } while (size);",
          "2070:  mutex_unlock(&u->readlock);",
          "2072: out:",
          "2073:  return copied ? : err;",
          "2074: }",
          "",
          "[Removed Lines]",
          "2071:  scm_recv(sock, msg, siocb->scm, flags);",
          "",
          "[Added Lines]",
          "2056:  scm_recv(sock, msg, &scm, flags);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
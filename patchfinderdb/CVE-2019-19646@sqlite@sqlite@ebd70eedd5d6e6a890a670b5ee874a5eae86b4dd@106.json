{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5710f1ad4822394087defa0cfefec9129fa8e885",
      "candidate_info": {
        "commit_hash": "5710f1ad4822394087defa0cfefec9129fa8e885",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/5710f1ad4822394087defa0cfefec9129fa8e885",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/e_expr.test",
          "test/func.test"
        ],
        "message": "Modify three test cases so that they work even with unusual versions of the library printf().\n\nFossilOrigin-Name: 8f4a3750b7d272daf96831655ffee80d457875ee121fc4537008046b9a00d0e7",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/e_expr.test||test/e_expr.test",
          "test/func.test||test/func.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 2c35d3f67b67a53ead08b1c395e7ca8e5bf65f94a5a962a0562994a3c66c95d9",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/e_expr.test||test/e_expr.test": [
          "File: test/e_expr.test -> test/e_expr.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1663: do_expr_test e_expr-32.1.5 { CAST('11.1abc' AS NUMERIC) } real 11.1",
          "1664: do_expr_test e_expr-32.1.6 {CAST( '9.223372036e14' AS NUMERIC)} integer  922337203600000",
          "1665: do_expr_test e_expr-32.1.7 {CAST('-9.223372036e14' AS NUMERIC)} integer -922337203600000",
          "1670: # EVIDENCE-OF: R-50300-26941 Any text input that describes a value",
          "1671: # outside the range of a 64-bit signed integer yields a REAL result.",
          "",
          "[Removed Lines]",
          "1666: do_expr_test e_expr-32.1.8 {CAST( '9.223372036e15' AS NUMERIC)} real     9223372036000000.0",
          "1667: do_expr_test e_expr-32.1.9 {CAST('-9.223372036e15' AS NUMERIC)} real    -9223372036000000.0",
          "",
          "[Added Lines]",
          "1666: do_test e_expr-32.1.8 {",
          "1667:   set expr {CAST( '9.223372036e15' AS NUMERIC)}",
          "1668:   db eval \"SELECT typeof($expr) AS type, printf('%.5e',$expr) AS value\"  break;",
          "1669:   list $type $value",
          "1670: } {real 9.22337e+15}",
          "1671: do_test e_expr-32.1.9 {",
          "1672:   set expr {CAST('-9.223372036e15' AS NUMERIC)}",
          "1673:   db eval \"SELECT typeof($expr) AS type, printf('%.5e',$expr) AS value\"  break;",
          "1674:   list $type $value",
          "1675: } {real -9.22337e+15}",
          "",
          "---------------"
        ],
        "test/func.test||test/func.test": [
          "File: test/func.test -> test/func.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "315:   do_test func-4.38 {",
          "316:     execsql {SELECT round(9999999999999.556,2);}",
          "317:   } {9999999999999.56}",
          "321: }",
          "323: # Test the upper() and lower() functions",
          "",
          "[Removed Lines]",
          "318:   do_execsql_test func-4.39 {",
          "319:     SELECT round(1e500), round(-1e500);",
          "320:   } {Inf -Inf}",
          "",
          "[Added Lines]",
          "318:   do_test func-4.39 {",
          "319:     string tolower [db eval {SELECT round(1e500), round(-1e500);}]",
          "320:   } {inf -inf}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b0968b6b140d415e2ebac0583d9b323913d6ad16",
      "candidate_info": {
        "commit_hash": "b0968b6b140d415e2ebac0583d9b323913d6ad16",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b0968b6b140d415e2ebac0583d9b323913d6ad16",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c"
        ],
        "message": "Add an assert() as an additional test for fix in check-in [523b42371122d9e1b3].\n\nFossilOrigin-Name: f9e85e6c79162081f8f512d22951931a89d157a32b24afdc48b7eb865379abe7",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 523b42371122d9e1b3185425745f1490138bff7f7cc941ee26ee81df7ade5bf4",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2542:   assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );",
          "2543:   db = pParse->db;",
          "2544:   pPrior = p->pPrior;",
          "2545:   dest = *pDest;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2543:   assert( p->selFlags & SF_Compound );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cde342df7063b09a47e960da640d03ca3e3a5e8f",
      "candidate_info": {
        "commit_hash": "cde342df7063b09a47e960da640d03ca3e3a5e8f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/cde342df7063b09a47e960da640d03ca3e3a5e8f",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/dbstat.c",
          "test/stat.test"
        ],
        "message": "Enhancements to DBSTAT:  (1) Make name=? queries efficient.  (2) Add the ability to aggregate results across each individual btree using the aggregate=TRUE constraint in the WHERE clause.\n\nFossilOrigin-Name: a48f6e17599d7ec794cfcd60858d6a69cf05caaae9321048b111fedd86a3b5b2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/dbstat.c||src/dbstat.c",
          "test/stat.test||test/stat.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4330f0795dbc2ab41dddd41d5979331fb9b78c477c66367c4be52f929531a45f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/dbstat.c||src/dbstat.c": [
          "File: src/dbstat.c -> src/dbstat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "75: typedef struct StatTable StatTable;",
          "76: typedef struct StatCursor StatCursor;",
          "77: typedef struct StatPage StatPage;",
          "78: typedef struct StatCell StatCell;",
          "80: struct StatCell {",
          "",
          "[Removed Lines]",
          "59: #define VTAB_SCHEMA                                                         \\",
          "60:   \"CREATE TABLE xx( \"                                                       \\",
          "61:   \"  name       TEXT,             /* Name of table or index */\"             \\",
          "62:   \"  path       TEXT,             /* Path to page from root */\"             \\",
          "63:   \"  pageno     INTEGER,          /* Page number */\"                        \\",
          "64:   \"  pagetype   TEXT,             /* 'internal', 'leaf' or 'overflow' */\"   \\",
          "65:   \"  ncell      INTEGER,          /* Cells on page (0 for overflow) */\"     \\",
          "66:   \"  payload    INTEGER,          /* Bytes of payload on this page */\"      \\",
          "67:   \"  unused     INTEGER,          /* Bytes of unused space on this page */\" \\",
          "68:   \"  mx_payload INTEGER,          /* Largest payload size of all cells */\"  \\",
          "69:   \"  pgoffset   INTEGER,          /* Offset of page in file */\"             \\",
          "70:   \"  pgsize     INTEGER,          /* Size of the page */\"                   \\",
          "71:   \"  schema     TEXT HIDDEN       /* Database schema being analyzed */\"     \\",
          "72:   \");\"",
          "",
          "[Added Lines]",
          "59: static const char zDbstatSchema[] =",
          "60:   \"CREATE TABLE x(\"",
          "73:   \")\"",
          "74: ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87: };",
          "89: struct StatPage {",
          "",
          "[Removed Lines]",
          "90:   u32 iPgno;",
          "91:   DbPage *pPg;",
          "92:   int iCell;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103: };",
          "105: struct StatCursor {",
          "125: };",
          "127: struct StatTable {",
          "131: };",
          "",
          "[Removed Lines]",
          "106:   sqlite3_vtab_cursor base;",
          "111:   StatPage aPage[32];",
          "128:   sqlite3_vtab base;",
          "129:   sqlite3 *db;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "159:   }else{",
          "160:     iDb = 0;",
          "161:   }",
          "163:   if( rc==SQLITE_OK ){",
          "164:     pTab = (StatTable *)sqlite3_malloc64(sizeof(StatTable));",
          "165:     if( pTab==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Removed Lines]",
          "162:   rc = sqlite3_declare_vtab(db, VTAB_SCHEMA);",
          "",
          "[Added Lines]",
          "170:   rc = sqlite3_declare_vtab(db, zDbstatSchema);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "185: }",
          "194: static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){",
          "195:   int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:   int iSchema = -1;",
          "208:   int iName = -1;",
          "209:   int iAgg = -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "202:   for(i=0; i<pIdxInfo->nConstraint; i++){",
          "205:     if( pIdxInfo->aConstraint[i].op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;",
          "211:   }",
          "",
          "[Removed Lines]",
          "203:     if( pIdxInfo->aConstraint[i].iColumn!=10 ) continue;",
          "204:     if( pIdxInfo->aConstraint[i].usable==0 ) return SQLITE_CONSTRAINT;",
          "206:     pIdxInfo->idxNum = 1;",
          "207:     pIdxInfo->estimatedCost = 1.0;",
          "208:     pIdxInfo->aConstraintUsage[i].argvIndex = 1;",
          "209:     pIdxInfo->aConstraintUsage[i].omit = 1;",
          "210:     break;",
          "",
          "[Added Lines]",
          "218:     if( pIdxInfo->aConstraint[i].usable==0 ){",
          "220:       return SQLITE_CONSTRAINT;",
          "221:     }",
          "222:     switch( pIdxInfo->aConstraint[i].iColumn ){",
          "224:         iName = i;",
          "225:         break;",
          "226:       }",
          "228:         iSchema = i;",
          "229:         break;",
          "230:       }",
          "232:         iAgg = i;",
          "233:         break;",
          "234:       }",
          "235:     }",
          "237:   i = 0;",
          "238:   if( iSchema>=0 ){",
          "239:     pIdxInfo->aConstraintUsage[iSchema].argvIndex = ++i;",
          "240:     pIdxInfo->aConstraintUsage[iSchema].omit = 1;",
          "241:     pIdxInfo->idxNum |= 0x01;",
          "242:   }",
          "243:   if( iName>=0 ){",
          "244:     pIdxInfo->aConstraintUsage[iName].argvIndex = ++i;",
          "245:     pIdxInfo->aConstraintUsage[iName].omit = 1;",
          "246:     pIdxInfo->idxNum |= 0x02;",
          "247:   }",
          "248:   if( iAgg>=0 ){",
          "249:     pIdxInfo->aConstraintUsage[iAgg].argvIndex = ++i;",
          "250:     pIdxInfo->aConstraintUsage[iAgg].omit = 1;",
          "251:     pIdxInfo->idxNum |= 0x04;",
          "252:   }",
          "253:   pIdxInfo->estimatedCost = 1.0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "227:      )",
          "228:   ){",
          "229:     pIdxInfo->orderByConsumed = 1;",
          "230:   }",
          "232:   return SQLITE_OK;",
          "233: }",
          "238: static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){",
          "239:   StatTable *pTab = (StatTable *)pVTab;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "271:     pIdxInfo->idxNum |= 0x08;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "283:   pCsr->isEof = 0;",
          "284: }",
          "289: static int statClose(sqlite3_vtab_cursor *pCursor){",
          "290:   StatCursor *pCsr = (StatCursor *)pCursor;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329: static void statResetCounts(StatCursor *pCsr){",
          "330:   pCsr->nCell = 0;",
          "331:   pCsr->nMxPayload = 0;",
          "332:   pCsr->nUnused = 0;",
          "333:   pCsr->nPayload = 0;",
          "334:   pCsr->szPage = 0;",
          "335:   pCsr->nPage = 0;",
          "336: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "294:   return SQLITE_OK;",
          "295: }",
          "302: ){",
          "303:   int nLocal;",
          "304:   int nMinLocal;",
          "",
          "[Removed Lines]",
          "297: static void getLocalPayload(",
          "",
          "[Added Lines]",
          "354: static int getLocalPayload(",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "315:   nLocal = nMinLocal + (nTotal - nMinLocal) % (nUsable - 4);",
          "316:   if( nLocal>nMaxLocal ) nLocal = nMinLocal;",
          "318: }",
          "320: static int statDecodePage(Btree *pBt, StatPage *p){",
          "321:   int nUnused;",
          "322:   int iOff;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "373:   return nLocal;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "387:           iOff += sqlite3GetVarint(&aData[iOff], &dummy);",
          "388:         }",
          "389:         if( nPayload>(u32)p->nMxPayload ) p->nMxPayload = nPayload;",
          "391:         if( nLocal<0 ) goto statPageIsCorrupt;",
          "392:         pCell->nLocal = nLocal;",
          "393:         assert( nPayload>=(u32)nLocal );",
          "",
          "[Removed Lines]",
          "390:         getLocalPayload(nUsable, p->flags, nPayload, &nLocal);",
          "",
          "[Added Lines]",
          "449:         nLocal = getLocalPayload(nUsable, p->flags, nPayload);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "437:   sqlite3_file *fd;",
          "438:   sqlite3_int64 x[2];",
          "447:   fd = sqlite3PagerFile(pPager);",
          "448:   x[0] = pCsr->iPageno;",
          "449:   if( sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){",
          "450:     pCsr->iOffset = x[0];",
          "452:   }",
          "453: }",
          "458: static int statNext(sqlite3_vtab_cursor *pCursor){",
          "459:   int rc;",
          "",
          "[Removed Lines]",
          "441:   pCsr->szPage = sqlite3BtreeGetPageSize(pBt);",
          "442:   pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "451:     pCsr->szPage = (int)x[1];",
          "",
          "[Added Lines]",
          "506:     pCsr->szPage += x[1];",
          "507:   }else{",
          "509:     pCsr->szPage += sqlite3BtreeGetPageSize(pBt);",
          "510:     pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "470: statNextRestart:",
          "471:   if( pCsr->aPage[0].pPg==0 ){",
          "472:     rc = sqlite3_step(pCsr->pStmt);",
          "473:     if( rc==SQLITE_ROW ){",
          "474:       int nPage;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:     statResetCounts(pCsr);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "481:       rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg, 0);",
          "482:       pCsr->aPage[0].iPgno = iRoot;",
          "483:       pCsr->aPage[0].iCell = 0;",
          "485:       pCsr->iPage = 0;",
          "487:     }else{",
          "488:       pCsr->isEof = 1;",
          "489:       return sqlite3_reset(pCsr->pStmt);",
          "490:     }",
          "491:   }else{",
          "494:     StatPage *p = &pCsr->aPage[pCsr->iPage];",
          "496:     while( p->iCell<p->nCell ){",
          "497:       StatCell *pCell = &p->aCell[p->iCell];",
          "500:         sqlite3BtreeEnter(pBt);",
          "501:         nUsable = sqlite3BtreeGetPageSize(pBt) -",
          "502:                         sqlite3BtreeGetReserveNoMutex(pBt);",
          "503:         sqlite3BtreeLeave(pBt);",
          "512:         if( pCell->iOvfl<pCell->nOvfl-1 ){",
          "515:         }else{",
          "518:         }",
          "519:         pCell->iOvfl++;",
          "522:       }",
          "523:       if( p->iRightChildPg ) break;",
          "524:       p->iCell++;",
          "",
          "[Removed Lines]",
          "484:       pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "486:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "498:       if( pCell->iOvfl<pCell->nOvfl ){",
          "499:         int nUsable;",
          "504:         pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "505:         pCsr->iPageno = pCell->aOvfl[pCell->iOvfl];",
          "506:         pCsr->zPagetype = \"overflow\";",
          "507:         pCsr->nCell = 0;",
          "508:         pCsr->nMxPayload = 0;",
          "509:         pCsr->zPath = z = sqlite3_mprintf(",
          "510:             \"%s%.3x+%.6x\", p->zPath, p->iCell, pCell->iOvfl",
          "511:         );",
          "513:           pCsr->nUnused = 0;",
          "514:           pCsr->nPayload = nUsable - 4;",
          "516:           pCsr->nPayload = pCell->nLastOvfl;",
          "517:           pCsr->nUnused = nUsable - 4 - pCsr->nPayload;",
          "520:         statSizeAndOffset(pCsr);",
          "521:         return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "",
          "[Added Lines]",
          "547:       if( !pCsr->isAgg ){",
          "548:         pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "549:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "550:       }",
          "552:       pCsr->nPage = 1;",
          "560:     if( !pCsr->isAgg ) statResetCounts(pCsr);",
          "563:       while( pCell->iOvfl<pCell->nOvfl ){",
          "564:         int nUsable, iOvfl;",
          "569:         pCsr->nPage++;",
          "570:         statSizeAndOffset(pCsr);",
          "572:           pCsr->nPayload += nUsable - 4;",
          "574:           pCsr->nPayload += pCell->nLastOvfl;",
          "575:           pCsr->nUnused += nUsable - 4 - pCell->nLastOvfl;",
          "577:         iOvfl = pCell->iOvfl;",
          "579:         if( !pCsr->isAgg ){",
          "580:           pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "581:           pCsr->iPageno = pCell->aOvfl[iOvfl];",
          "582:           pCsr->zPagetype = \"overflow\";",
          "583:           pCsr->zPath = z = sqlite3_mprintf(",
          "584:               \"%s%.3x+%.6x\", p->zPath, p->iCell, iOvfl",
          "585:           );",
          "586:           return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "587:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "527:     if( !p->iRightChildPg || p->iCell>p->nCell ){",
          "528:       statClearPage(p);",
          "532:     }",
          "533:     pCsr->iPage++;",
          "",
          "[Removed Lines]",
          "529:       if( pCsr->iPage==0 ) return statNext(pCursor);",
          "530:       pCsr->iPage--;",
          "",
          "[Added Lines]",
          "595:       if( pCsr->iPage>0 ){",
          "596:         pCsr->iPage--;",
          "597:       }else if( pCsr->isAgg ){",
          "600:         return SQLITE_OK;",
          "601:       }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "543:       p[1].iPgno = p->aCell[p->iCell].iChildPg;",
          "544:     }",
          "545:     rc = sqlite3PagerGet(pPager, p[1].iPgno, &p[1].pPg, 0);",
          "546:     p[1].iCell = 0;",
          "548:     p->iCell++;",
          "550:   }",
          "",
          "[Removed Lines]",
          "547:     p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "549:     if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Added Lines]",
          "617:     pCsr->nPage++;",
          "619:     if( !pCsr->isAgg ){",
          "620:       p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "621:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "622:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "576:           pCsr->zPagetype = \"corrupted\";",
          "577:           break;",
          "578:       }",
          "584:       nPayload = 0;",
          "585:       for(i=0; i<p->nCell; i++){",
          "586:         nPayload += p->aCell[i].nLocal;",
          "587:       }",
          "589:     }",
          "590:   }",
          "",
          "[Removed Lines]",
          "579:       pCsr->nCell = p->nCell;",
          "580:       pCsr->nUnused = p->nUnused;",
          "581:       pCsr->nMxPayload = p->nMxPayload;",
          "582:       pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "583:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "588:       pCsr->nPayload = nPayload;",
          "",
          "[Added Lines]",
          "653:       pCsr->nCell += p->nCell;",
          "654:       pCsr->nUnused += p->nUnused;",
          "655:       if( p->nMxPayload>pCsr->nMxPayload ) pCsr->nMxPayload = p->nMxPayload;",
          "656:       if( !pCsr->isAgg ){",
          "657:         pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "658:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "659:       }",
          "664:       pCsr->nPayload += nPayload;",
          "669:       if( pCsr->isAgg ) goto statNextRestart;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "604: ){",
          "605:   StatCursor *pCsr = (StatCursor *)pCursor;",
          "606:   StatTable *pTab = (StatTable*)(pCursor->pVtab);",
          "612:     pCsr->iDb = sqlite3FindDbName(pTab->db, zDbase);",
          "613:     if( pCsr->iDb<0 ){",
          "614:       sqlite3_free(pCursor->pVtab->zErrMsg);",
          "",
          "[Removed Lines]",
          "607:   char *zSql;",
          "608:   int rc = SQLITE_OK;",
          "610:   if( idxNum==1 ){",
          "611:     const char *zDbase = (const char*)sqlite3_value_text(argv[0]);",
          "",
          "[Added Lines]",
          "698:   statResetCsr(pCsr);",
          "699:   sqlite3_finalize(pCsr->pStmt);",
          "700:   pCsr->pStmt = 0;",
          "701:   if( idxNum & 0x01 ){",
          "703:     const char *zDbase = (const char*)sqlite3_value_text(argv[iArg++]);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "618:   }else{",
          "619:     pCsr->iDb = pTab->iDb;",
          "620:   }",
          "630:   if( zSql==0 ){",
          "631:     return SQLITE_NOMEM_BKPT;",
          "632:   }else{",
          "",
          "[Removed Lines]",
          "621:   statResetCsr(pCsr);",
          "622:   sqlite3_finalize(pCsr->pStmt);",
          "623:   pCsr->pStmt = 0;",
          "624:   zSql = sqlite3_mprintf(",
          "625:       \"SELECT 'sqlite_master' AS name, 1 AS rootpage, 'table' AS type\"",
          "626:       \"  UNION ALL  \"",
          "627:       \"SELECT name, rootpage, type\"",
          "628:       \"  FROM \\\"%w\\\".sqlite_master WHERE rootpage!=0\"",
          "629:       \"  ORDER BY name\", pTab->db->aDb[pCsr->iDb].zDbSName);",
          "",
          "[Added Lines]",
          "713:   if( idxNum & 0x02 ){",
          "715:     zName = (const char*)sqlite3_value_text(argv[iArg++]);",
          "716:   }",
          "717:   if( idxNum & 0x04 ){",
          "719:     pCsr->isAgg = sqlite3_value_double(argv[iArg++])!=0.0;",
          "720:   }else{",
          "721:     pCsr->isAgg = 0;",
          "722:   }",
          "723:   pSql = sqlite3_str_new(pTab->db);",
          "724:   sqlite3_str_appendf(pSql,",
          "725:       \"SELECT * FROM (\"",
          "726:         \"SELECT 'sqlite_master' AS name,1 AS rootpage,'table' AS type\"",
          "727:         \" UNION ALL \"",
          "728:         \"SELECT name,rootpage,type\"",
          "729:         \" FROM \\\"%w\\\".sqlite_master WHERE rootpage!=0)\",",
          "730:       pTab->db->aDb[pCsr->iDb].zDbSName);",
          "731:   if( zName ){",
          "732:     sqlite3_str_appendf(pSql, \"WHERE name=%Q\", zName);",
          "733:   }",
          "734:   if( idxNum & 0x08 ){",
          "735:     sqlite3_str_appendf(pSql, \" ORDER BY name\");",
          "736:   }",
          "737:   zSql = sqlite3_str_finish(pSql);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "651:       sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_TRANSIENT);",
          "652:       break;",
          "655:       break;",
          "658:       break;",
          "661:       break;",
          "663:       sqlite3_result_int(ctx, pCsr->nCell);",
          "",
          "[Removed Lines]",
          "654:       sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "657:       sqlite3_result_int64(ctx, pCsr->iPageno);",
          "660:       sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "",
          "[Added Lines]",
          "762:       if( !pCsr->isAgg ){",
          "763:         sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "764:       }",
          "767:       if( pCsr->isAgg ){",
          "768:         sqlite3_result_int64(ctx, pCsr->nPage);",
          "769:       }else{",
          "770:         sqlite3_result_int64(ctx, pCsr->iPageno);",
          "771:       }",
          "774:       if( !pCsr->isAgg ){",
          "775:         sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "776:       }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "672:       sqlite3_result_int(ctx, pCsr->nMxPayload);",
          "673:       break;",
          "676:       break;",
          "678:       sqlite3_result_int(ctx, pCsr->szPage);",
          "679:       break;",
          "681:       sqlite3 *db = sqlite3_context_db_handle(ctx);",
          "682:       int iDb = pCsr->iDb;",
          "683:       sqlite3_result_text(ctx, db->aDb[iDb].zDbSName, -1, SQLITE_STATIC);",
          "684:       break;",
          "685:     }",
          "686:   }",
          "687:   return SQLITE_OK;",
          "688: }",
          "",
          "[Removed Lines]",
          "675:       sqlite3_result_int64(ctx, pCsr->iOffset);",
          "",
          "[Added Lines]",
          "791:       if( !pCsr->isAgg ){",
          "792:         sqlite3_result_int64(ctx, pCsr->iOffset);",
          "793:       }",
          "805:       sqlite3_result_int(ctx, pCsr->isAgg);",
          "806:       break;",
          "807:     }",
          "",
          "---------------"
        ],
        "test/stat.test||test/stat.test": [
          "File: test/stat.test -> test/stat.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:   INSERT INTO t3 SELECT a_string(110+rowid), a_string(221+rowid) FROM t3",
          "109:    ORDER BY rowid;",
          "110:   SELECT name, path, pageno, pagetype, ncell, payload, unused, mx_payload",
          "112: } [list \\",
          "113:   sqlite_autoindex_t3_1 / 3 internal 3 368 623 125       \\",
          "114:   sqlite_autoindex_t3_1 /000/ 8 leaf 8 946 46 123        \\",
          "",
          "[Removed Lines]",
          "111:     FROM stat WHERE name != 'sqlite_master';",
          "",
          "[Added Lines]",
          "111:     FROM stat WHERE name != 'sqlite_master' ORDER BY name;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134:   t3 /00f/ 23 leaf 2 738 268 370                         \\",
          "135: ]",
          "137: # With every index entry overflowing, make sure no pages are missed",
          "138: # (other than the locking page which is 64 in this test build.)",
          "139: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: do_execsql_test stat-2.1agg {",
          "138:   SELECT * FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "139: } [list \\",
          "140:   sqlite_autoindex_t3_1 {}  5 {} 32  3898 1065 132 {}  5120 \\",
          "141:   sqlite_master         {}  1 {}  2    84  824  49 {}  1024 \\",
          "142:   t3                    {} 17 {} 47 11188 5815 370 {} 17408 \\",
          "143: ]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:   CREATE INDEX i4 ON t4(x);",
          "151:   INSERT INTO t4(rowid, x) VALUES(2, a_string(7777));",
          "152:   SELECT name, path, pageno, pagetype, ncell, payload, unused, mx_payload",
          "154: } [list \\",
          "155:   i4 / 3 leaf 1 103 905 7782                 \\",
          "156:   i4 /000+000000 4 overflow 0 1020 0 0       \\",
          "",
          "[Removed Lines]",
          "153:     FROM stat WHERE name != 'sqlite_master';",
          "",
          "[Added Lines]",
          "161:     FROM stat WHERE name != 'sqlite_master' ORDER BY name;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "171:   t4 /000+000006 18 overflow 0 1020 0 0      \\",
          "172: ]",
          "174: do_execsql_test stat-4.1 {",
          "175:   CREATE TABLE t5(x);",
          "176:   CREATE INDEX i5 ON t5(x);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: do_execsql_test stat-3.2 {",
          "183:   SELECT *, '|' FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "184: } [list \\",
          "185:   i4            {} 9 {} 1 7782 1386 7782 {} 9216 | \\",
          "186:   sqlite_master {} 1 {} 2   74  834   40 {} 1024 | \\",
          "187:   t4            {} 8 {} 1 7780  367 7780 {} 8192 | \\",
          "188: ]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "201:   t1 /001+000000 4 overflow 0 1020 0 0    \\",
          "202: ]",
          "204: do_catchsql_test stat-6.1 {",
          "205:   CREATE VIRTUAL TABLE temp.s2 USING dbstat(mainx);",
          "206: } {1 {no such database: mainx}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221: do_execsql_test stat-5.20 {",
          "222:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "223:          unused, mx_payload, '|' FROM dbstat('main',1);",
          "224: } {sqlite_master NULL 1 NULL 1 34 878 34 | tx NULL 1 NULL 0 0 1016 0 |}",
          "225: do_execsql_test stat-5.21 {",
          "226:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "227:          unused, mx_payload, '|' FROM dbstat('aux1',1);",
          "228: } {sqlite_master NULL 1 NULL 1 34 878 34 | t1 NULL 3 NULL 2 3033 5 1517 |}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "27e80a3b68010d7ece74ed4a6836ab9f0b2fb9ac",
      "candidate_info": {
        "commit_hash": "27e80a3b68010d7ece74ed4a6836ab9f0b2fb9ac",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/27e80a3b68010d7ece74ed4a6836ab9f0b2fb9ac",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "test/fuzzdata8.db"
        ],
        "message": "Ensure that the cell overwrite optimization does not overwrite the header of the b-tree page.\n\nFossilOrigin-Name: 4cc5694cbd69749c146679c367860952fdf3f5356426ddfd1dce470569702bc1",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b517a52fa36df0a0854a75858b5e81861771d2e9032a5a0ad79aa76ae64130a2",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7676:     memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));",
          "7677:     if( pOld->nOverflow>0 ){",
          "7679:         rc = SQLITE_CORRUPT_BKPT;",
          "7680:         goto balance_cleanup;",
          "7681:       }",
          "",
          "[Removed Lines]",
          "7678:       if( limit<pOld->aiOvfl[0] ){",
          "",
          "[Added Lines]",
          "7678:       if( NEVER(limit<pOld->aiOvfl[0]) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8480:     return SQLITE_CORRUPT_BKPT;",
          "8481:   }",
          "",
          "[Removed Lines]",
          "8479:   if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd ){",
          "",
          "[Added Lines]",
          "8479:   if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd",
          "8480:    || pCur->info.pPayload < pPage->aData + pPage->cellOffset",
          "8481:   ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d35300f9b69d0260ef1e28340355c0b2c87f4904",
      "candidate_info": {
        "commit_hash": "d35300f9b69d0260ef1e28340355c0b2c87f4904",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d35300f9b69d0260ef1e28340355c0b2c87f4904",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/parse.y",
          "src/sqliteInt.h",
          "src/window.c",
          "tool/mkkeywordhash.c"
        ],
        "message": "Parse EXCLUDE clauses in window frames. They do not yet work.\n\nFossilOrigin-Name: d03c7533a1e993f1b12392a5193b2127484307b27072236a1255e7a30849a381",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/parse.y||src/parse.y",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/window.c||src/window.c",
          "tool/mkkeywordhash.c||tool/mkkeywordhash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7d66cd2013206ebad50c7cdb7dab9211fa8b47f5cb7067dcb314b3e0180875f8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "1688: }",
          "1690: frame_opt(A) ::= .                             {",
          "1692: }",
          "1695: }",
          "1698: }",
          "1700: range_or_rows(A) ::= RANGE.   { A = TK_RANGE; }",
          "",
          "[Removed Lines]",
          "1691:   A = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0);",
          "1693: frame_opt(A) ::= range_or_rows(X) frame_bound_s(Y). {",
          "1694:   A = sqlite3WindowAlloc(pParse, X, Y.eType, Y.pExpr, TK_CURRENT, 0);",
          "1696: frame_opt(A) ::= range_or_rows(X) BETWEEN frame_bound_s(Y) AND frame_bound_e(Z). {",
          "1697:   A = sqlite3WindowAlloc(pParse, X, Y.eType, Y.pExpr, Z.eType, Z.pExpr);",
          "",
          "[Added Lines]",
          "1691:   A = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);",
          "1693: frame_opt(A) ::= range_or_rows(X) frame_bound_s(Y) frame_exclude_opt(Z). {",
          "1694:   A = sqlite3WindowAlloc(pParse, X, Y.eType, Y.pExpr, TK_CURRENT, 0, Z);",
          "1696: frame_opt(A) ::= range_or_rows(X) BETWEEN frame_bound_s(Y) AND frame_bound_e(Z) frame_exclude_opt(W). {",
          "1697:   A = sqlite3WindowAlloc(pParse, X, Y.eType, Y.pExpr, Z.eType, Z.pExpr, W);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1711: frame_bound(A) ::= CURRENT ROW.         { A.eType = TK_CURRENT  ; A.pExpr = 0; }",
          "1712: frame_bound(A) ::= expr(X) FOLLOWING.   { A.eType = TK_FOLLOWING; A.pExpr = X; }",
          "1714: %type window_clause {Window*}",
          "1715: %destructor window_clause {sqlite3WindowListDelete(pParse->db, $$);}",
          "1716: window_clause(A) ::= WINDOW windowdefn_list(B). { A = B; }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1714: %type frame_exclude_opt {u8}",
          "1715: frame_exclude_opt(A) ::= . { A = TK_NO; }",
          "1716: frame_exclude_opt(A) ::= EXCLUDE frame_exclude(X). { A = X; }",
          "1718: %type frame_exclude {u8}",
          "1719: frame_exclude(A) ::= NO OTHERS.   { A = 0; }",
          "1720: frame_exclude(A) ::= CURRENT ROW. { A = TK_CURRENT; }",
          "1721: frame_exclude(A) ::= GROUP.       { A = TK_GROUP; }",
          "1722: frame_exclude(A) ::= TIES.        { A = TK_TIES; }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3585: #ifndef SQLITE_OMIT_WINDOWFUNC",
          "3586: void sqlite3WindowDelete(sqlite3*, Window*);",
          "3587: void sqlite3WindowListDelete(sqlite3 *db, Window *p);",
          "3589: void sqlite3WindowAttach(Parse*, Expr*, Window*);",
          "3590: int sqlite3WindowCompare(Parse*, Window*, Window*);",
          "3591: void sqlite3WindowCodeInit(Parse*, Window*);",
          "",
          "[Removed Lines]",
          "3588: Window *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*);",
          "",
          "[Added Lines]",
          "3588: Window *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*, u8);",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1039:   pWin->eType = eType;",
          "1040:   pWin->eStart = eStart;",
          "1041:   pWin->eEnd = eEnd;",
          "1042:   pWin->bImplicitFrame = bImplicitFrame;",
          "1043:   pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);",
          "1044:   pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1043:   pWin->eExclude = eExclude;",
          "",
          "---------------"
        ],
        "tool/mkkeywordhash.c||tool/mkkeywordhash.c": [
          "File: tool/mkkeywordhash.c -> tool/mkkeywordhash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:   { \"ESCAPE\",           \"TK_ESCAPE\",       ALWAYS                 },",
          "206:   { \"EXCEPT\",           \"TK_EXCEPT\",       COMPOUND               },",
          "207:   { \"EXCLUSIVE\",        \"TK_EXCLUSIVE\",    ALWAYS                 },",
          "208:   { \"EXISTS\",           \"TK_EXISTS\",       ALWAYS                 },",
          "209:   { \"EXPLAIN\",          \"TK_EXPLAIN\",      EXPLAIN                },",
          "210:   { \"FAIL\",             \"TK_FAIL\",         CONFLICT|TRIGGER       },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "208:   { \"EXCLUDE\",          \"TK_EXCLUDE\",      WINDOWFUNC             },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "239:   { \"LIMIT\",            \"TK_LIMIT\",        ALWAYS                 },",
          "240:   { \"MATCH\",            \"TK_MATCH\",        ALWAYS                 },",
          "241:   { \"NATURAL\",          \"TK_JOIN_KW\",      ALWAYS                 },",
          "243:   { \"NOT\",              \"TK_NOT\",          ALWAYS                 },",
          "244:   { \"NOTHING\",          \"TK_NOTHING\",      UPSERT                 },",
          "245:   { \"NOTNULL\",          \"TK_NOTNULL\",      ALWAYS                 },",
          "",
          "[Removed Lines]",
          "242:   { \"NO\",               \"TK_NO\",           FKEY                   },",
          "",
          "[Added Lines]",
          "243:   { \"NO\",               \"TK_NO\",           FKEY|WINDOWFUNC        },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "249:   { \"ON\",               \"TK_ON\",           ALWAYS                 },",
          "250:   { \"OR\",               \"TK_OR\",           ALWAYS                 },",
          "251:   { \"ORDER\",            \"TK_ORDER\",        ALWAYS                 },",
          "252:   { \"OUTER\",            \"TK_JOIN_KW\",      ALWAYS                 },",
          "253:   { \"OVER\",             \"TK_OVER\",         WINDOWFUNC             },",
          "254:   { \"PARTITION\",        \"TK_PARTITION\",    WINDOWFUNC             },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "253:   { \"OTHERS\",           \"TK_OTHERS\",       WINDOWFUNC             },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "278:   { \"TEMP\",             \"TK_TEMP\",         ALWAYS                 },",
          "279:   { \"TEMPORARY\",        \"TK_TEMP\",         ALWAYS                 },",
          "280:   { \"THEN\",             \"TK_THEN\",         ALWAYS                 },",
          "281:   { \"TO\",               \"TK_TO\",           ALWAYS                 },",
          "282:   { \"TRANSACTION\",      \"TK_TRANSACTION\",  ALWAYS                 },",
          "283:   { \"TRIGGER\",          \"TK_TRIGGER\",      TRIGGER                },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283:   { \"TIES\",             \"TK_TIES\",         WINDOWFUNC             },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-5418",
  "cve_desc": "The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file.",
  "repo": "libarchive/libarchive",
  "patch_hash": "dfd6b54ce33960e420fb206d8872fb759b577ad9",
  "patch_info": {
    "commit_hash": "dfd6b54ce33960e420fb206d8872fb759b577ad9",
    "repo": "libarchive/libarchive",
    "commit_url": "https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9",
    "files": [
      "libarchive/archive_write_disk_posix.c"
    ],
    "message": "Fixes for Issue #745 and Issue #746 from Doran Moppert.",
    "before_after_code_files": [
      "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
    ]
  },
  "patch_diff": {
    "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
      "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "327: #define HFS_BLOCKS(s) ((s) >> 12)",
      "329: static int check_symlinks(struct archive_write_disk *);",
      "330: static int create_filesystem_object(struct archive_write_disk *);",
      "331: static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);",
      "332: #if defined(HAVE_FCHDIR) && defined(PATH_MAX)",
      "333: static void edit_deep_directories(struct archive_write_disk *ad);",
      "334: #endif",
      "335: static int cleanup_pathname(struct archive_write_disk *);",
      "336: static int create_dir(struct archive_write_disk *, char *);",
      "337: static int create_parent_dir(struct archive_write_disk *, char *);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "329: static int check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);",
      "336: static int cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2014:  const char *linkname;",
      "2015:  mode_t final_mode, mode;",
      "2016:  int r;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2021:  struct archive_string error_string;",
      "2022:  int error_number;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2022: #if !HAVE_LINK",
      "2023:   return (EPERM);",
      "2024: #else",
      "2025:   r = link(linkname, a->name) ? errno : 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2031:   archive_string_init(&error_string);",
      "2032:   linkname_copy = strdup(linkname);",
      "2033:   if (linkname_copy == NULL) {",
      "2034:       return (EPERM);",
      "2035:   }",
      "2037:   r = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);",
      "2038:   if (r != ARCHIVE_OK) {",
      "2039:    archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2040:    free(linkname_copy);",
      "2042:    return (EPERM);",
      "2043:   }",
      "2044:   r = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);",
      "2045:   if (r != ARCHIVE_OK) {",
      "2046:    archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2047:    free(linkname_copy);",
      "2049:    return (EPERM);",
      "2050:   }",
      "2051:   free(linkname_copy);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2365: static int",
      "2367: {",
      "2368: #if !defined(HAVE_LSTAT)",
      "2371:  return (ARCHIVE_OK);",
      "2372: #else",
      "2374:  char c;",
      "2375:  int r;",
      "2376:  struct stat st;",
      "2402:   if (r != 0) {",
      "2404:    if (errno == ENOENT) {",
      "2405:     break;",
      "2406:    } else {",
      "2415:    }",
      "2416:   } else if (S_ISLNK(st.st_mode)) {",
      "2429:     }",
      "2441:     }",
      "2453:     }",
      "2455:    } else {",
      "2461:    }",
      "2462:   }",
      "2466:  }",
      "2471: #endif",
      "2472: }",
      "2474: #if defined(__CYGWIN__)",
      "",
      "[Removed Lines]",
      "2366: check_symlinks(struct archive_write_disk *a)",
      "2373:  char *pn;",
      "2383:  pn = a->name;",
      "2384:  if (archive_strlen(&(a->path_safe)) > 0) {",
      "2385:   char *p = a->path_safe.s;",
      "2386:   while ((*pn != '\\0') && (*p == *pn))",
      "2387:    ++p, ++pn;",
      "2388:  }",
      "2390:  if(pn == a->name && pn[0] == '/')",
      "2391:   ++pn;",
      "2392:  c = pn[0];",
      "2394:  while (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {",
      "2396:   while (*pn != '\\0' && *pn != '/')",
      "2397:    ++pn;",
      "2398:   c = pn[0];",
      "2399:   pn[0] = '\\0';",
      "2401:   r = lstat(a->name, &st);",
      "2414:     return (ARCHIVE_FAILED);",
      "2417:    if (c == '\\0') {",
      "2423:     if (unlink(a->name)) {",
      "2424:      archive_set_error(&a->archive, errno,",
      "2425:          \"Could not remove symlink %s\",",
      "2426:          a->name);",
      "2427:      pn[0] = c;",
      "2428:      return (ARCHIVE_FAILED);",
      "2430:     a->pst = NULL;",
      "2437:     if (!S_ISLNK(a->mode)) {",
      "2438:      archive_set_error(&a->archive, 0,",
      "2439:          \"Removing symlink %s\",",
      "2440:          a->name);",
      "2443:     pn[0] = c;",
      "2444:     return (0);",
      "2445:    } else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {",
      "2447:     if (unlink(a->name) != 0) {",
      "2448:      archive_set_error(&a->archive, 0,",
      "2449:          \"Cannot remove intervening symlink %s\",",
      "2450:          a->name);",
      "2451:      pn[0] = c;",
      "2452:      return (ARCHIVE_FAILED);",
      "2454:     a->pst = NULL;",
      "2456:     archive_set_error(&a->archive, 0,",
      "2457:         \"Cannot extract through symlink %s\",",
      "2458:         a->name);",
      "2459:     pn[0] = c;",
      "2460:     return (ARCHIVE_FAILED);",
      "2463:   pn[0] = c;",
      "2464:   if (pn[0] != '\\0')",
      "2467:  pn[0] = c;",
      "2469:  archive_strcpy(&a->path_safe, a->name);",
      "2470:  return (ARCHIVE_OK);",
      "",
      "[Added Lines]",
      "2398: check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)",
      "2409:  int res = ARCHIVE_OK;",
      "2410:  char *tail;",
      "2411:  char *head;",
      "2412:  int last;",
      "2416:  int restore_pwd;",
      "2419:  if(path[0] == '\\0')",
      "2420:      return (ARCHIVE_OK);",
      "2436:  restore_pwd = open(\".\", O_RDONLY | O_BINARY | O_CLOEXEC);",
      "2437:  __archive_ensure_cloexec_flag(restore_pwd);",
      "2438:  if (restore_pwd < 0)",
      "2439:   return (ARCHIVE_FATAL);",
      "2440:  head = path;",
      "2441:  tail = path;",
      "2442:  last = 0;",
      "2445:  if(tail == path && tail[0] == '/')",
      "2446:   ++tail;",
      "2453:  while (!last) {",
      "2455:   while (*tail == '/')",
      "2456:       ++tail;",
      "2458:   while (*tail != '\\0' && *tail != '/')",
      "2459:    ++tail;",
      "2461:   last = (tail[0] == '\\0') || (tail[0] == '/' && tail[1] == '\\0');",
      "2463:   c = tail[0];",
      "2464:   tail[0] = '\\0';",
      "2466:   r = lstat(head, &st);",
      "2468:    tail[0] = c;",
      "2481:     if (error_number) *error_number = errno;",
      "2482:     if (error_string)",
      "2483:      archive_string_sprintf(error_string,",
      "2484:        \"Could not stat %s\",",
      "2485:        path);",
      "2486:     res = ARCHIVE_FAILED;",
      "2487:     break;",
      "2488:    }",
      "2489:   } else if (S_ISDIR(st.st_mode)) {",
      "2490:    if (!last) {",
      "2491:     if (chdir(head) != 0) {",
      "2492:      tail[0] = c;",
      "2493:      if (error_number) *error_number = errno;",
      "2494:      if (error_string)",
      "2495:       archive_string_sprintf(error_string,",
      "2496:         \"Could not chdir %s\",",
      "2497:         path);",
      "2498:      res = (ARCHIVE_FATAL);",
      "2499:      break;",
      "2500:     }",
      "2502:     head = tail + 1;",
      "2505:    if (last) {",
      "2511:     if (unlink(head)) {",
      "2512:      tail[0] = c;",
      "2513:      if (error_number) *error_number = errno;",
      "2514:      if (error_string)",
      "2515:       archive_string_sprintf(error_string,",
      "2516:         \"Could not remove symlink %s\",",
      "2517:         path);",
      "2518:      res = ARCHIVE_FAILED;",
      "2519:      break;",
      "2527:     tail[0] = c;",
      "2529:     if (!S_ISLNK(path)) {",
      "2530:      if (error_number) *error_number = 0;",
      "2531:      if (error_string)",
      "2532:       archive_string_sprintf(error_string,",
      "2533:         \"Removing symlink %s\",",
      "2534:         path);",
      "2538:     res = ARCHIVE_OK;",
      "2539:     break;",
      "2540:    } else if (flags & ARCHIVE_EXTRACT_UNLINK) {",
      "2542:     if (unlink(head) != 0) {",
      "2543:      tail[0] = c;",
      "2544:      if (error_number) *error_number = 0;",
      "2545:      if (error_string)",
      "2546:       archive_string_sprintf(error_string,",
      "2547:         \"Cannot remove intervening symlink %s\",",
      "2548:         path);",
      "2549:      res = ARCHIVE_FAILED;",
      "2550:      break;",
      "2552:     tail[0] = c;",
      "2554:     tail[0] = c;",
      "2555:     if (error_number) *error_number = 0;",
      "2556:     if (error_string)",
      "2557:      archive_string_sprintf(error_string,",
      "2558:        \"Cannot extract through symlink %s\",",
      "2559:        path);",
      "2560:     res = ARCHIVE_FAILED;",
      "2561:     break;",
      "2565:   tail[0] = c;",
      "2566:   if (tail[0] != '\\0')",
      "2568:  }",
      "2570:  tail[0] = c;",
      "2571: #ifdef HAVE_FCHDIR",
      "2573:  if (restore_pwd >= 0) {",
      "2574:   r = fchdir(restore_pwd);",
      "2575:   if (r != 0) {",
      "2576:    if(error_number) *error_number = errno;",
      "2577:    if(error_string)",
      "2578:     archive_string_sprintf(error_string,",
      "2579:       \"chdir() failure\");",
      "2580:   }",
      "2581:   close(restore_pwd);",
      "2582:   restore_pwd = -1;",
      "2583:   if (r != 0) {",
      "2584:    res = (ARCHIVE_FATAL);",
      "2585:   }",
      "2587: #endif",
      "2589:  return res;",
      "2597: static int",
      "2598: check_symlinks(struct archive_write_disk *a)",
      "2599: {",
      "2600:  struct archive_string error_string;",
      "2601:  int error_number;",
      "2602:  int rc;",
      "2603:  archive_string_init(&error_string);",
      "2604:  rc = check_symlinks_fsobj(a->name, &error_number, &error_string, a->flags);",
      "2605:  if (rc != ARCHIVE_OK) {",
      "2606:   archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2607:  }",
      "2608:  archive_string_free(&error_string);",
      "2610:  return rc;",
      "2611: }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2546: static int",
      "2548: {",
      "2549:  char *dest, *src;",
      "2550:  char separator = '\\0';",
      "2553:  if (*src == '\\0') {",
      "2556:   return (ARCHIVE_FAILED);",
      "2557:  }",
      "",
      "[Removed Lines]",
      "2547: cleanup_pathname(struct archive_write_disk *a)",
      "2552:  dest = src = a->name;",
      "2554:   archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
      "2555:       \"Invalid empty pathname\");",
      "",
      "[Added Lines]",
      "2687: cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)",
      "2692:  dest = src = path;",
      "2694:   if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
      "2695:   if (error_string)",
      "2696:       archive_string_sprintf(error_string,",
      "2697:        \"Invalid empty pathname\");",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2561: #endif",
      "2563:  if (*src == '/') {",
      "2567:    return (ARCHIVE_FAILED);",
      "2568:   }",
      "",
      "[Removed Lines]",
      "2564:   if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
      "2565:    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
      "2566:                      \"Path is absolute\");",
      "",
      "[Added Lines]",
      "2706:   if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
      "2707:    if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
      "2708:    if (error_string)",
      "2709:        archive_string_sprintf(error_string,",
      "2710:         \"Path is absolute\");",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2590:    } else if (src[1] == '.') {",
      "2591:     if (src[2] == '/' || src[2] == '\\0') {",
      "2597:       return (ARCHIVE_FAILED);",
      "2598:      }",
      "2599:     }",
      "",
      "[Removed Lines]",
      "2593:      if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {",
      "2594:       archive_set_error(&a->archive,",
      "2595:           ARCHIVE_ERRNO_MISC,",
      "2596:           \"Path contains '..'\");",
      "",
      "[Added Lines]",
      "2737:      if (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {",
      "2738:       if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
      "2739:       if (error_string)",
      "2740:           archive_string_sprintf(error_string,",
      "2741:            \"Path contains '..'\");",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "2627:  if (dest == a->name) {",
      "",
      "[Added Lines]",
      "2772:  if (dest == path) {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2639:  return (ARCHIVE_OK);",
      "2640: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2787: static int",
      "2788: cleanup_pathname(struct archive_write_disk *a)",
      "2789: {",
      "2790:  struct archive_string error_string;",
      "2791:  int error_number;",
      "2792:  int rc;",
      "2793:  archive_string_init(&error_string);",
      "2794:  rc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);",
      "2795:  if (rc != ARCHIVE_OK) {",
      "2796:   archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2797:  }",
      "2798:  archive_string_free(&error_string);",
      "2799:  return rc;",
      "2800: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "063ea3ea3fcb569a380b2ebe9c9ddd8bd6ce0d49",
      "candidate_info": {
        "commit_hash": "063ea3ea3fcb569a380b2ebe9c9ddd8bd6ce0d49",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/063ea3ea3fcb569a380b2ebe9c9ddd8bd6ce0d49",
        "files": [
          "Makefile.am",
          "libarchive/test/CMakeLists.txt",
          "libarchive/test/main.c",
          "libarchive/test/test.h",
          "libarchive/test/test_write_disk_secure744.c",
          "libarchive/test/test_write_disk_secure745.c",
          "libarchive/test/test_write_disk_secure746.c"
        ],
        "message": "Test cases for Github Issue #744, #745, and #746.",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "libarchive/test/main.c||libarchive/test/main.c",
          "libarchive/test/test.h||libarchive/test/test.h",
          "libarchive/test/test_write_disk_secure744.c||libarchive/test/test_write_disk_secure744.c",
          "libarchive/test/test_write_disk_secure745.c||libarchive/test/test_write_disk_secure745.c",
          "libarchive/test/test_write_disk_secure746.c||libarchive/test/test_write_disk_secure746.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "509:  libarchive/test/test_write_disk_no_hfs_compression.c \\",
          "510:  libarchive/test/test_write_disk_perms.c \\",
          "511:  libarchive/test/test_write_disk_secure.c \\",
          "512:  libarchive/test/test_write_disk_sparse.c \\",
          "513:  libarchive/test/test_write_disk_symlink.c \\",
          "514:  libarchive/test/test_write_disk_times.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "512:  libarchive/test/test_write_disk_secure744.c \\",
          "513:  libarchive/test/test_write_disk_secure745.c \\",
          "514:  libarchive/test/test_write_disk_secure746.c \\",
          "",
          "---------------"
        ],
        "libarchive/test/main.c||libarchive/test/main.c": [
          "File: libarchive/test/main.c -> libarchive/test/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1440:  return (0);",
          "1441: }",
          "1444: int",
          "1445: assertion_is_dir(const char *file, int line, const char *pathname, int mode)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1444: int",
          "1445: assertion_file_mode(const char *file, int line, const char *pathname, int expected_mode)",
          "1446: {",
          "1447:  int mode;",
          "1448:  int r;",
          "1450:  assertion_count(file, line);",
          "1451: #if defined(_WIN32) && !defined(__CYGWIN__)",
          "1452:  failure_start(file, line, \"assertFileMode not yet implemented for Windows\");",
          "1453: #else",
          "1454:  {",
          "1455:   struct stat st;",
          "1456:   r = lstat(pathname, &st);",
          "1457:   mode = (int)(st.st_mode & 0777);",
          "1458:  }",
          "1459:  if (r == 0 && mode == expected_mode)",
          "1460:    return (1);",
          "1461:  failure_start(file, line, \"File %s has mode %o, expected %o\",",
          "1462:      pathname, mode, expected_mode);",
          "1463: #endif",
          "1464:  failure_finish(NULL);",
          "1465:  return (0);",
          "1466: }",
          "",
          "---------------"
        ],
        "libarchive/test/test.h||libarchive/test/test.h": [
          "File: libarchive/test/test.h -> libarchive/test/test.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "182:   assertion_file_nlinks(__FILE__, __LINE__, pathname, nlinks)",
          "183: #define assertFileSize(pathname, size)  \\",
          "184:   assertion_file_size(__FILE__, __LINE__, pathname, size)",
          "185: #define assertTextFileContents(text, pathname) \\",
          "186:   assertion_text_file_contents(__FILE__, __LINE__, text, pathname)",
          "187: #define assertFileContainsLinesAnyOrder(pathname, lines) \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "185: #define assertFileMode(pathname, mode)  \\",
          "186:   assertion_file_mode(__FILE__, __LINE__, pathname, mode)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "246: int assertion_file_nlinks(const char *, int, const char *, int);",
          "247: int assertion_file_not_exists(const char *, int, const char *);",
          "248: int assertion_file_size(const char *, int, const char *, long);",
          "249: int assertion_is_dir(const char *, int, const char *, int);",
          "250: int assertion_is_hardlink(const char *, int, const char *, const char *);",
          "251: int assertion_is_not_hardlink(const char *, int, const char *, const char *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "251: int assertion_file_mode(const char *, int, const char *, int);",
          "",
          "---------------"
        ],
        "libarchive/test/test_write_disk_secure744.c||libarchive/test/test_write_disk_secure744.c": [
          "File: libarchive/test/test_write_disk_secure744.c -> libarchive/test/test_write_disk_secure744.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"test.h\"",
          "26: __FBSDID(\"$FreeBSD$\");",
          "28: #define UMASK 022",
          "35: DEFINE_TEST(test_write_disk_secure744)",
          "36: {",
          "37: #if defined(_WIN32) && !defined(__CYGWIN__)",
          "38:  skipping(\"archive_write_disk security checks not supported on Windows\");",
          "39: #else",
          "40:  struct archive *a;",
          "41:  struct archive_entry *ae;",
          "42:  size_t buff_size = 8192;",
          "43:  char *buff = malloc(buff_size);",
          "44:  char *p = buff;",
          "45:  int n = 0;",
          "46:  int t;",
          "48:  assert(buff != NULL);",
          "51:  assertUmask(UMASK);",
          "54:  assert((a = archive_write_disk_new()) != NULL);",
          "55:  archive_write_disk_set_options(a, ARCHIVE_EXTRACT_SECURE_SYMLINKS);",
          "57:  while (p + 500 < buff + buff_size) {",
          "58:   memset(p, 'x', 100);",
          "59:   p += 100;",
          "60:   p[0] = '\\0';",
          "62:   buff[0] = ((n / 1000) % 10) + '0';",
          "63:   buff[1] = ((n / 100) % 10)+ '0';",
          "64:   buff[2] = ((n / 10) % 10)+ '0';",
          "65:   buff[3] = ((n / 1) % 10)+ '0';",
          "66:   buff[4] = '_';",
          "67:   ++n;",
          "70:   assert((ae = archive_entry_new()) != NULL);",
          "71:   archive_entry_copy_pathname(ae, buff);",
          "72:   archive_entry_set_mode(ae, S_IFREG | 0777);",
          "73:   archive_entry_copy_symlink(ae, testworkdir);",
          "74:   assertEqualIntA(a, ARCHIVE_OK, archive_write_header(a, ae));",
          "75:   archive_entry_free(ae);",
          "78:   sprintf(p, \"target%d\", n);",
          "81:   assert((ae = archive_entry_new()) != NULL);",
          "82:   archive_entry_copy_pathname(ae, buff);",
          "83:   archive_entry_set_mode(ae, S_IFDIR | 0777);",
          "85:   t = archive_write_header(a, ae);",
          "86:   archive_entry_free(ae);",
          "87:   failure(\"Attempt to create target%d via %d-character symlink should have failed\", n, (int)strlen(buff));",
          "88:   if(!assertEqualInt(ARCHIVE_FAILED, t)) {",
          "89:    break;",
          "90:   }",
          "91:  }",
          "92:  archive_free(a);",
          "93:  free(buff);",
          "94: #endif",
          "95: }",
          "",
          "---------------"
        ],
        "libarchive/test/test_write_disk_secure745.c||libarchive/test/test_write_disk_secure745.c": [
          "File: libarchive/test/test_write_disk_secure745.c -> libarchive/test/test_write_disk_secure745.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"test.h\"",
          "26: __FBSDID(\"$FreeBSD$\");",
          "28: #define UMASK 022",
          "36: DEFINE_TEST(test_write_disk_secure745)",
          "37: {",
          "38: #if defined(_WIN32) && !defined(__CYGWIN__)",
          "39:  skipping(\"archive_write_disk security checks not supported on Windows\");",
          "40: #else",
          "41:  struct archive *a;",
          "42:  struct archive_entry *ae;",
          "45:  assertUmask(UMASK);",
          "48:  assert((a = archive_write_disk_new()) != NULL);",
          "49:  archive_write_disk_set_options(a, ARCHIVE_EXTRACT_SECURE_SYMLINKS);",
          "52:  assertMakeDir(\"target\", 0700);",
          "55:  assertMakeDir(\"sandbox\", 0700);",
          "56:  assertChdir(\"sandbox\");",
          "59:  assert((ae = archive_entry_new()) != NULL);",
          "60:  archive_entry_copy_pathname(ae, \"sym\");",
          "61:  archive_entry_set_mode(ae, S_IFREG | 0777);",
          "62:  archive_entry_copy_symlink(ae, \"../target\");",
          "63:  assert(0 == archive_write_header(a, ae));",
          "64:  archive_entry_free(ae);",
          "67:  assert((ae = archive_entry_new()) != NULL);",
          "68:  archive_entry_copy_pathname(ae, \"sym\");",
          "69:  archive_entry_set_mode(ae, S_IFDIR | 0777);",
          "70:  assert(0 == archive_write_header(a, ae));",
          "71:  archive_entry_free(ae);",
          "74:  assertFileMode(\"../target\", 0700);",
          "75: #endif",
          "76: }",
          "",
          "---------------"
        ],
        "libarchive/test/test_write_disk_secure746.c||libarchive/test/test_write_disk_secure746.c": [
          "File: libarchive/test/test_write_disk_secure746.c -> libarchive/test/test_write_disk_secure746.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"test.h\"",
          "26: __FBSDID(\"$FreeBSD$\");",
          "28: #define UMASK 022",
          "40: DEFINE_TEST(test_write_disk_secure746a)",
          "41: {",
          "42: #if defined(_WIN32) && !defined(__CYGWIN__)",
          "43:  skipping(\"archive_write_disk security checks not supported on Windows\");",
          "44: #else",
          "45:  struct archive *a;",
          "46:  struct archive_entry *ae;",
          "49:  assertUmask(UMASK);",
          "52:  assertMakeDir(\"target\", 0700);",
          "53:  assertMakeFile(\"target/foo\", 0700, \"unmodified\");",
          "56:  assertMakeDir(\"sandbox\", 0700);",
          "57:  assertChdir(\"sandbox\");",
          "60:  assert((a = archive_write_disk_new()) != NULL);",
          "61:  archive_write_disk_set_options(a, ARCHIVE_EXTRACT_SECURE_NODOTDOT);",
          "64:  assert((ae = archive_entry_new()) != NULL);",
          "65:  archive_entry_copy_pathname(ae, \"bar\");",
          "66:  archive_entry_set_mode(ae, S_IFREG | 0777);",
          "67:  archive_entry_set_size(ae, 8);",
          "68:  archive_entry_copy_hardlink(ae, \"../target/foo\");",
          "69:  assertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));",
          "70:  assertEqualInt(ARCHIVE_FAILED, archive_write_data(a, \"modified\", 8));",
          "71:  archive_entry_free(ae);",
          "74:  assertTextFileContents(\"unmodified\", \"../target/foo\");",
          "75: #endif",
          "76: }",
          "82: DEFINE_TEST(test_write_disk_secure746b)",
          "83: {",
          "84: #if defined(_WIN32) && !defined(__CYGWIN__)",
          "85:  skipping(\"archive_write_disk security checks not supported on Windows\");",
          "86: #else",
          "87:  struct archive *a;",
          "88:  struct archive_entry *ae;",
          "91:  assertUmask(UMASK);",
          "94:  assertMakeDir(\"target\", 0700);",
          "95:  assertMakeFile(\"target/foo\", 0700, \"unmodified\");",
          "98:  assertMakeDir(\"sandbox\", 0700);",
          "99:  assertChdir(\"sandbox\");",
          "102:  assert((a = archive_write_disk_new()) != NULL);",
          "103:  archive_write_disk_set_options(a, ARCHIVE_EXTRACT_SECURE_SYMLINKS);",
          "106:  assert((ae = archive_entry_new()) != NULL);",
          "107:  archive_entry_copy_pathname(ae, \"symlink\");",
          "108:  archive_entry_copy_symlink(ae, \"../target\");",
          "109:  assertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));",
          "110:  archive_entry_free(ae);",
          "113:  assert((ae = archive_entry_new()) != NULL);",
          "114:  archive_entry_copy_pathname(ae, \"bar\");",
          "115:  archive_entry_set_mode(ae, S_IFREG | 0777);",
          "116:  archive_entry_set_size(ae, 8);",
          "117:  archive_entry_copy_hardlink(ae, \"symlink/foo\");",
          "118:  assertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));",
          "119:  assertEqualInt(ARCHIVE_FAILED, archive_write_data(a, \"modified\", 8));",
          "120:  archive_entry_free(ae);",
          "123:  assertTextFileContents(\"unmodified\", \"../target/foo\");",
          "124: #endif",
          "125: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50952acd22df3326c49771f5e5ba48630899468c",
      "candidate_info": {
        "commit_hash": "50952acd22df3326c49771f5e5ba48630899468c",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/50952acd22df3326c49771f5e5ba48630899468c",
        "files": [
          "libarchive/test/test_write_disk_secure745.c",
          "libarchive/test/test_write_disk_secure746.c"
        ],
        "message": "Fix the test cases for Issue #745 and Issue #746\n\nThanks to Doran Moppert for pointing out the inconsistencies here.",
        "before_after_code_files": [
          "libarchive/test/test_write_disk_secure745.c||libarchive/test/test_write_disk_secure745.c",
          "libarchive/test/test_write_disk_secure746.c||libarchive/test/test_write_disk_secure746.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libarchive/test/test_write_disk_secure745.c||libarchive/test/test_write_disk_secure745.c": [
          "File: libarchive/test/test_write_disk_secure745.c -> libarchive/test/test_write_disk_secure745.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:  assert((ae = archive_entry_new()) != NULL);",
          "60:  archive_entry_copy_pathname(ae, \"sym\");",
          "62:  archive_entry_copy_symlink(ae, \"../target\");",
          "63:  assert(0 == archive_write_header(a, ae));",
          "64:  archive_entry_free(ae);",
          "",
          "[Removed Lines]",
          "61:  archive_entry_set_mode(ae, S_IFREG | 0777);",
          "",
          "[Added Lines]",
          "61:  archive_entry_set_mode(ae, AE_IFLNK | 0777);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:  assertFileMode(\"../target\", 0700);",
          "75: #endif",
          "76: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76:  assert(0 == archive_write_close(a));",
          "77:  archive_write_free(a);",
          "",
          "---------------"
        ],
        "libarchive/test/test_write_disk_secure746.c||libarchive/test/test_write_disk_secure746.c": [
          "File: libarchive/test/test_write_disk_secure746.c -> libarchive/test/test_write_disk_secure746.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:  assert((ae = archive_entry_new()) != NULL);",
          "65:  archive_entry_copy_pathname(ae, \"bar\");",
          "67:  archive_entry_set_size(ae, 8);",
          "68:  archive_entry_copy_hardlink(ae, \"../target/foo\");",
          "69:  assertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));",
          "71:  archive_entry_free(ae);",
          "",
          "[Removed Lines]",
          "66:  archive_entry_set_mode(ae, S_IFREG | 0777);",
          "70:  assertEqualInt(ARCHIVE_FAILED, archive_write_data(a, \"modified\", 8));",
          "",
          "[Added Lines]",
          "66:  archive_entry_set_mode(ae, AE_IFREG | 0777);",
          "70:  assertEqualInt(ARCHIVE_FATAL, archive_write_data(a, \"modified\", 8));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "106:  assert((ae = archive_entry_new()) != NULL);",
          "107:  archive_entry_copy_pathname(ae, \"symlink\");",
          "108:  archive_entry_copy_symlink(ae, \"../target\");",
          "110:  archive_entry_free(ae);",
          "113:  assert((ae = archive_entry_new()) != NULL);",
          "114:  archive_entry_copy_pathname(ae, \"bar\");",
          "116:  archive_entry_set_size(ae, 8);",
          "117:  archive_entry_copy_hardlink(ae, \"symlink/foo\");",
          "120:  archive_entry_free(ae);",
          "123:  assertTextFileContents(\"unmodified\", \"../target/foo\");",
          "124: #endif",
          "125: }",
          "",
          "[Removed Lines]",
          "109:  assertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));",
          "115:  archive_entry_set_mode(ae, S_IFREG | 0777);",
          "118:  assertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));",
          "119:  assertEqualInt(ARCHIVE_FAILED, archive_write_data(a, \"modified\", 8));",
          "",
          "[Added Lines]",
          "108:  archive_entry_set_mode(ae, AE_IFLNK | 0777);",
          "110:  assertEqualIntA(a, ARCHIVE_OK, archive_write_header(a, ae));",
          "116:  archive_entry_set_mode(ae, AE_IFREG | 0777);",
          "119:  assertEqualIntA(a, ARCHIVE_FAILED, archive_write_header(a, ae));",
          "120:  assertEqualIntA(a, ARCHIVE_FATAL, archive_write_data(a, \"modified\", 8));",
          "126:  assertEqualIntA(a, ARCHIVE_FATAL, archive_write_close(a));",
          "127:  archive_write_free(a);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1fa9c7bf90f0862036a99896b0501c381584451a",
      "candidate_info": {
        "commit_hash": "1fa9c7bf90f0862036a99896b0501c381584451a",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/1fa9c7bf90f0862036a99896b0501c381584451a",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "Issue #744 (part of Issue #743): Enforce sandbox with very long pathnames\n\nBecause check_symlinks is handled separately from the deep-directory\nsupport, very long pathnames cause problems.  Previously, the code\nignored most failures to lstat() a path component.  In particular,\nthis led to check_symlinks always passing for very long paths, which\nin turn provides a way to evade the symlink checks in the sandboxing\ncode.\n\nWe now fail on unrecognized lstat() failures, which plugs this\nhole at the cost of disabling deep directory support when the\nuser requests sandboxing.\n\nTODO:  This probably cannot be completely fixed without\nentirely reimplementing the deep directory support to\nintegrate the symlink checks.  I want to reimplement the\ndeep directory hanlding someday anyway; openat() and\nrelated system calls now provide a much cleaner way to\nhandle deep directories than the chdir approach used by this\ncode.",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2401:   r = lstat(a->name, &st);",
          "2402:   if (r != 0) {",
          "2405:     break;",
          "2406:   } else if (S_ISLNK(st.st_mode)) {",
          "2407:    if (c == '\\0') {",
          "",
          "[Removed Lines]",
          "2404:    if (errno == ENOENT)",
          "",
          "[Added Lines]",
          "2404:    if (errno == ENOENT) {",
          "2406:    } else {",
          "2414:     return (ARCHIVE_FAILED);",
          "2415:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "41ae0cf83bd0c144d0f4c296223341e54513eebd",
      "candidate_info": {
        "commit_hash": "41ae0cf83bd0c144d0f4c296223341e54513eebd",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/41ae0cf83bd0c144d0f4c296223341e54513eebd",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "Skip root directory symlink check\n\nThe first time check_symlinks is called on an absolute path it will use\nthe entry pathname directly, blanking the leading slash.  This leads to\ncalling lstat on an empty string, which returns ENOENT, terminating the\nloop early and falsely marking the path as safe.",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2386:   while ((*pn != '\\0') && (*p == *pn))",
          "2387:    ++p, ++pn;",
          "2388:  }",
          "2389:  c = pn[0];",
          "2391:  while (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2390:  if(pn == a->name && pn[0] == '/')",
          "2391:   ++pn;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1bed2f317ec184cea5294e01beda661d506fe752",
      "candidate_info": {
        "commit_hash": "1bed2f317ec184cea5294e01beda661d506fe752",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/1bed2f317ec184cea5294e01beda661d506fe752",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "archive_write_disk_posix.c: make *_fsobj functions more readable",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "337: #define HFS_BLOCKS(s) ((s) >> 12)",
          "341: static int check_symlinks(struct archive_write_disk *);",
          "342: static int create_filesystem_object(struct archive_write_disk *);",
          "343: static struct fixup_entry *current_fixup(struct archive_write_disk *,",
          "",
          "[Removed Lines]",
          "339: static int check_symlinks_fsobj(char *path, int *error_number,",
          "340:       struct archive_string *error_string, int flags);",
          "",
          "[Added Lines]",
          "339: static void fsobj_error(int *, struct archive_string *, int, const char *,",
          "340:       const char *);",
          "341: static int check_symlinks_fsobj(char *, int *, struct archive_string *,",
          "342:       int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "345: #if defined(HAVE_FCHDIR) && defined(PATH_MAX)",
          "346: static void edit_deep_directories(struct archive_write_disk *ad);",
          "347: #endif",
          "350: static int cleanup_pathname(struct archive_write_disk *);",
          "351: static int create_dir(struct archive_write_disk *, char *);",
          "352: static int create_parent_dir(struct archive_write_disk *, char *);",
          "",
          "[Removed Lines]",
          "348: static int cleanup_pathname_fsobj(char *path, int *error_number,",
          "349:       struct archive_string *error_string, int flags);",
          "",
          "[Added Lines]",
          "350: static int cleanup_pathname_fsobj(char *, int *, struct archive_string *,",
          "351:       int);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2016:  if (en) {",
          "2020:   return (ARCHIVE_FAILED);",
          "2021:  }",
          "",
          "[Removed Lines]",
          "2018:   archive_set_error(&a->archive, en, \"Can't create '%s'\",",
          "2019:       a->name);",
          "",
          "[Added Lines]",
          "2020:   if ((&a->archive)->error == NULL)",
          "2021:    archive_set_error(&a->archive, en, \"Can't create '%s'\",",
          "2022:        a->name);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2411:  return (a->current_fixup);",
          "2412: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2418: static void",
          "2419: fsobj_error(int *a_eno, struct archive_string *a_estr,",
          "2420:     int err, const char *errstr, const char *path)",
          "2421: {",
          "2422:  if (a_eno)",
          "2424:  if (a_estr)",
          "2425:   archive_string_sprintf(a_estr, errstr, path);",
          "2426: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2425: static int",
          "2428: {",
          "2429: #if !defined(HAVE_LSTAT)",
          "",
          "[Removed Lines]",
          "2426: check_symlinks_fsobj(char *path, int *error_number,",
          "2427:     struct archive_string *error_string, int flags)",
          "",
          "[Added Lines]",
          "2440: check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,",
          "2441:     int flags)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2523:     res = ARCHIVE_FAILED;",
          "2524:     break;",
          "2525:    }",
          "",
          "[Removed Lines]",
          "2516:     if (error_number)",
          "2518:     if (error_string) {",
          "2519:      archive_string_sprintf(error_string,",
          "2520:          \"Could not stat %s\",",
          "2521:          path);",
          "2522:     }",
          "",
          "[Added Lines]",
          "2530:     fsobj_error(a_eno, a_estr, errno,",
          "2531:         \"Could not stat %s\", path);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2527:    if (!last) {",
          "2528:     if (chdir(head) != 0) {",
          "2529:      tail[0] = c;",
          "2538:      res = (ARCHIVE_FATAL);",
          "2539:      break;",
          "2540:     }",
          "",
          "[Removed Lines]",
          "2530:      if (error_number)",
          "2532:      if (error_string) {",
          "2533:       archive_string_sprintf(",
          "2534:           error_string,",
          "2535:           \"Could not chdir %s\",",
          "2536:           path);",
          "2537:      }",
          "",
          "[Added Lines]",
          "2539:      fsobj_error(a_eno, a_estr, errno,",
          "2540:          \"Could not chdir %s\", path);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2551:     if (unlink(head)) {",
          "2552:      tail[0] = c;",
          "2560:      res = ARCHIVE_FAILED;",
          "2561:      break;",
          "2562:     }",
          "",
          "[Removed Lines]",
          "2553:      if (error_number)",
          "2555:      if (error_string)",
          "2556:       archive_string_sprintf(",
          "2557:           error_string,",
          "2558:           \"Could not remove \"",
          "2559:           \"symlink %s\", path);",
          "",
          "[Added Lines]",
          "2556:      fsobj_error(a_eno, a_estr, errno,",
          "2557:          \"Could not remove symlink %s\",",
          "2558:          path);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2575:     if (!S_ISLNK(path)) {",
          "2584:     }",
          "",
          "[Removed Lines]",
          "2576:      if (error_number)",
          "2578:      if (error_string) {",
          "2579:       archive_string_sprintf(",
          "2580:           error_string,",
          "2581:           \"Removing symlink %s\",",
          "2582:           path);",
          "2583:      }",
          "",
          "[Added Lines]",
          "2575:      fsobj_error(a_eno, a_estr, 0,",
          "2576:          \"Removing symlink %s\", path);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2591:     if (unlink(head) != 0) {",
          "2592:      tail[0] = c;",
          "2602:      res = ARCHIVE_FAILED;",
          "2603:      break;",
          "2604:     }",
          "2605:     tail[0] = c;",
          "2606:    } else {",
          "2607:     tail[0] = c;",
          "2615:     res = ARCHIVE_FAILED;",
          "2616:     break;",
          "2617:    }",
          "",
          "[Removed Lines]",
          "2593:      if (error_number)",
          "2595:      if (error_string) {",
          "2596:       archive_string_sprintf(",
          "2597:           error_string,",
          "2598:           \"Cannot remove \"",
          "2599:           \"intervening symlink %s\",",
          "2600:           path);",
          "2601:      }",
          "2608:     if (error_number)",
          "2610:     if (error_string) {",
          "2611:      archive_string_sprintf(error_string,",
          "2612:          \"Cannot extract through \"",
          "2613:          \"symlink %s\", path);",
          "2614:     }",
          "",
          "[Added Lines]",
          "2586:      fsobj_error(a_eno, a_estr, 0,",
          "2587:          \"Cannot remove intervening \"",
          "2588:          \"symlink %s\", path);",
          "2595:     fsobj_error(a_eno, a_estr, 0,",
          "2596:         \"Cannot extract through symlink %s\", path);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2628:  if (restore_pwd >= 0) {",
          "2629:   r = fchdir(restore_pwd);",
          "2630:   if (r != 0) {",
          "2637:   }",
          "2638:   close(restore_pwd);",
          "2639:   restore_pwd = -1;",
          "",
          "[Removed Lines]",
          "2631:    if (error_number)",
          "2633:    if (error_string) {",
          "2634:     archive_string_sprintf(error_string,",
          "2635:       \"chdir() failure\");",
          "2636:    }",
          "",
          "[Added Lines]",
          "2613:    fsobj_error(a_eno, a_estr, errno,",
          "2614:        \"chdir() failure\", \"\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2745: static int",
          "2748: {",
          "2749:  char *dest, *src;",
          "2750:  char separator = '\\0';",
          "2752:  dest = src = path;",
          "2753:  if (*src == '\\0') {",
          "2760:   return (ARCHIVE_FAILED);",
          "2761:  }",
          "",
          "[Removed Lines]",
          "2746: cleanup_pathname_fsobj(char *path, int *error_number,",
          "2747:     struct archive_string *error_string, int flags)",
          "2754:   if (error_number)",
          "2756:   if (error_string) {",
          "2757:    archive_string_sprintf(error_string,",
          "2758:        \"Invalid empty pathname\");",
          "2759:   }",
          "",
          "[Added Lines]",
          "2724: cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,",
          "2725:     int flags)",
          "2732:   fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,",
          "2733:       \"Invalid empty \", \"pathname\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2767:  if (*src == '/') {",
          "2768:   if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
          "2775:    return (ARCHIVE_FAILED);",
          "2776:   }",
          "",
          "[Removed Lines]",
          "2769:    if (error_number)",
          "2771:    if (error_string) {",
          "2772:     archive_string_sprintf(error_string,",
          "2773:         \"Path is absolute\");",
          "2774:    }",
          "",
          "[Added Lines]",
          "2743:    fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,",
          "2744:        \"Path is \", \"absolute\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2801:      if (flags",
          "2802:          & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {",
          "2813:       return (ARCHIVE_FAILED);",
          "2814:      }",
          "2815:     }",
          "",
          "[Removed Lines]",
          "2803:       if (error_number) {",
          "2805:            ARCHIVE_ERRNO_MISC;",
          "2806:       }",
          "2807:       if (error_string) {",
          "2808:        archive_string_sprintf(",
          "2809:            error_string,",
          "2810:            \"Path \"",
          "2811:            \"contains '..'\");",
          "2812:       }",
          "",
          "[Added Lines]",
          "2773:       fsobj_error(a_eno, a_estr,",
          "2774:           ARCHIVE_ERRNO_MISC,",
          "2775:           \"Path contains \", \"'..'\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
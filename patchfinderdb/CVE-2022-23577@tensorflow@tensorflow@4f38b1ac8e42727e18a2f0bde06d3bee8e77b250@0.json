{
  "cve_id": "CVE-2022-23577",
  "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `GetInitOp` is vulnerable to a crash caused by dereferencing a null pointer. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "4f38b1ac8e42727e18a2f0bde06d3bee8e77b250",
  "patch_info": {
    "commit_hash": "4f38b1ac8e42727e18a2f0bde06d3bee8e77b250",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/4f38b1ac8e42727e18a2f0bde06d3bee8e77b250",
    "files": [
      "tensorflow/cc/saved_model/loader_util.cc"
    ],
    "message": "Prevent null dereference read in `GetInitOp`.\n\nWe have a map of maps. We test that the key exists in the first map but then we don't have any validation that this also means the second map has the needed key. In the scenarios where this is not the case, we'll dereference a nullptr, if we don't have this check\n\nPiperOrigin-RevId: 408739325\nChange-Id: If9bb7ed759aba1f3b56a34913f209508dbaf65ce",
    "before_after_code_files": [
      "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc": [
      "File: tensorflow/cc/saved_model/loader_util.cc -> tensorflow/cc/saved_model/loader_util.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "34:   const auto& init_op_sig_it =",
      "35:       meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);",
      "36:   if (init_op_sig_it != sig_def_map.end()) {",
      "40:     return Status::OK();",
      "41:   }",
      "",
      "[Removed Lines]",
      "38:                         .find(kSavedModelInitOpSignatureKey)",
      "39:                         ->second.name();",
      "",
      "[Added Lines]",
      "37:     const auto& sig_def_outputs = init_op_sig_it->second.outputs();",
      "38:     const auto& sig_def_outputs_it =",
      "39:         sig_def_outputs.find(kSavedModelInitOpSignatureKey);",
      "40:     if (sig_def_outputs_it == sig_def_outputs.end()) {",
      "41:       return errors::FailedPrecondition(\"Could not find output \",",
      "42:                                         kSavedModelInitOpSignatureKey);",
      "43:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "66f0e6f4661765562c79fd1dd177173b9b67b345",
      "candidate_info": {
        "commit_hash": "66f0e6f4661765562c79fd1dd177173b9b67b345",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/66f0e6f4661765562c79fd1dd177173b9b67b345",
        "files": [
          "tensorflow/cc/saved_model/loader_util.cc"
        ],
        "message": "Prevent null dereference read in `GetInitOp`.\n\nWe have a map of maps. We test that the key exists in the first map but then we don't have any validation that this also means the second map has the needed key. In the scenarios where this is not the case, we'll dereference a nullptr, if we don't have this check\n\nPiperOrigin-RevId: 408739325\nChange-Id: If9bb7ed759aba1f3b56a34913f209508dbaf65ce",
        "before_after_code_files": [
          "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
          ],
          "candidate": [
            "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc": [
          "File: tensorflow/cc/saved_model/loader_util.cc -> tensorflow/cc/saved_model/loader_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   const auto& init_op_sig_it =",
          "35:       meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);",
          "36:   if (init_op_sig_it != sig_def_map.end()) {",
          "40:     return Status::OK();",
          "41:   }",
          "",
          "[Removed Lines]",
          "38:                         .find(kSavedModelInitOpSignatureKey)",
          "39:                         ->second.name();",
          "",
          "[Added Lines]",
          "37:     const auto& sig_def_outputs = init_op_sig_it->second.outputs();",
          "38:     const auto& sig_def_outputs_it =",
          "39:         sig_def_outputs.find(kSavedModelInitOpSignatureKey);",
          "40:     if (sig_def_outputs_it == sig_def_outputs.end()) {",
          "41:       return errors::FailedPrecondition(\"Could not find output \",",
          "42:                                         kSavedModelInitOpSignatureKey);",
          "43:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ce53b406626c6e32f91dc87b26a5e843108afe99",
      "candidate_info": {
        "commit_hash": "ce53b406626c6e32f91dc87b26a5e843108afe99",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/ce53b406626c6e32f91dc87b26a5e843108afe99",
        "files": [
          "tensorflow/cc/saved_model/loader_util.cc"
        ],
        "message": "Prevent null dereference read in `GetInitOp`.\n\nWe have a map of maps. We test that the key exists in the first map but then we don't have any validation that this also means the second map has the needed key. In the scenarios where this is not the case, we'll dereference a nullptr, if we don't have this check\n\nPiperOrigin-RevId: 408739325\nChange-Id: If9bb7ed759aba1f3b56a34913f209508dbaf65ce",
        "before_after_code_files": [
          "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
          ],
          "candidate": [
            "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc": [
          "File: tensorflow/cc/saved_model/loader_util.cc -> tensorflow/cc/saved_model/loader_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   const auto& init_op_sig_it =",
          "35:       meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);",
          "36:   if (init_op_sig_it != sig_def_map.end()) {",
          "40:     return Status::OK();",
          "41:   }",
          "",
          "[Removed Lines]",
          "38:                         .find(kSavedModelInitOpSignatureKey)",
          "39:                         ->second.name();",
          "",
          "[Added Lines]",
          "37:     const auto& sig_def_outputs = init_op_sig_it->second.outputs();",
          "38:     const auto& sig_def_outputs_it =",
          "39:         sig_def_outputs.find(kSavedModelInitOpSignatureKey);",
          "40:     if (sig_def_outputs_it == sig_def_outputs.end()) {",
          "41:       return errors::FailedPrecondition(\"Could not find output \",",
          "42:                                         kSavedModelInitOpSignatureKey);",
          "43:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f8f445a84a7cda4cccfab689be09c9f82b41943c",
      "candidate_info": {
        "commit_hash": "f8f445a84a7cda4cccfab689be09c9f82b41943c",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/f8f445a84a7cda4cccfab689be09c9f82b41943c",
        "files": [
          "tensorflow/cc/saved_model/loader_util.cc"
        ],
        "message": "Prevent null dereference read in `GetInitOp`.\n\nWe have a map of maps. We test that the key exists in the first map but then we don't have any validation that this also means the second map has the needed key. In the scenarios where this is not the case, we'll dereference a nullptr, if we don't have this check\n\nPiperOrigin-RevId: 408739325\nChange-Id: If9bb7ed759aba1f3b56a34913f209508dbaf65ce",
        "before_after_code_files": [
          "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
          ],
          "candidate": [
            "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/cc/saved_model/loader_util.cc||tensorflow/cc/saved_model/loader_util.cc": [
          "File: tensorflow/cc/saved_model/loader_util.cc -> tensorflow/cc/saved_model/loader_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   const auto& init_op_sig_it =",
          "35:       meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);",
          "36:   if (init_op_sig_it != sig_def_map.end()) {",
          "40:     return Status::OK();",
          "41:   }",
          "",
          "[Removed Lines]",
          "38:                         .find(kSavedModelInitOpSignatureKey)",
          "39:                         ->second.name();",
          "",
          "[Added Lines]",
          "37:     const auto& sig_def_outputs = init_op_sig_it->second.outputs();",
          "38:     const auto& sig_def_outputs_it =",
          "39:         sig_def_outputs.find(kSavedModelInitOpSignatureKey);",
          "40:     if (sig_def_outputs_it == sig_def_outputs.end()) {",
          "41:       return errors::FailedPrecondition(\"Could not find output \",",
          "42:                                         kSavedModelInitOpSignatureKey);",
          "43:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
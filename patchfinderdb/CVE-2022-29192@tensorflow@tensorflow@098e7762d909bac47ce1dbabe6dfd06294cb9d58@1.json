{
  "cve_id": "CVE-2022-29192",
  "cve_desc": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "098e7762d909bac47ce1dbabe6dfd06294cb9d58",
  "patch_info": {
    "commit_hash": "098e7762d909bac47ce1dbabe6dfd06294cb9d58",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/098e7762d909bac47ce1dbabe6dfd06294cb9d58",
    "files": [
      "tensorflow/core/kernels/quantize_and_dequantize_op.cc"
    ],
    "message": "Fix tf.raw_ops.QuantizeAndDequantizeV4Grad vulnerability with invalid input_min or input_max.\n\nCheck that argument is actually a scalar before treating it as such.\n\nPiperOrigin-RevId: 445198280",
    "before_after_code_files": [
      "tensorflow/core/kernels/quantize_and_dequantize_op.cc||tensorflow/core/kernels/quantize_and_dequantize_op.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/quantize_and_dequantize_op.cc||tensorflow/core/kernels/quantize_and_dequantize_op.cc": [
      "File: tensorflow/core/kernels/quantize_and_dequantize_op.cc -> tensorflow/core/kernels/quantize_and_dequantize_op.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "174:     OP_REQUIRES(ctx,",
      "175:                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,",
      "176:                 errors::InvalidArgument(",
      "178:                     input_min_tensor.dims(), \".\"));",
      "179:     const Tensor& input_max_tensor = ctx->input(3);",
      "180:     OP_REQUIRES(ctx,",
      "181:                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,",
      "182:                 errors::InvalidArgument(",
      "184:                     input_max_tensor.dims(), \".\"));",
      "185:     if (axis_ != -1) {",
      "186:       OP_REQUIRES(",
      "",
      "[Removed Lines]",
      "177:                     \"Input min tensor must have dimension 1. Recieved \",",
      "183:                     \"Input max tensor must have dimension 1. Recieved \",",
      "",
      "[Added Lines]",
      "177:                     \"Input min tensor must have dimension 0 or 1. Received \",",
      "183:                     \"Input max tensor must have dimension 0 or 1. Received \",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "203:                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));",
      "205:     if (axis_ == -1) {",
      "206:       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;",
      "207:       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),",
      "208:         input.template flat<T>(), input_min_tensor.scalar<T>(),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "206:       OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),",
      "207:                   errors::InvalidArgument(",
      "208:                       \"input_min must be a scalar if axis is unspecified\"));",
      "209:       OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),",
      "210:                   errors::InvalidArgument(",
      "211:                       \"input_max must be a scalar if axis is unspecified\"));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "585f733fcb41dfbeb201146a66efe081865a129e",
      "candidate_info": {
        "commit_hash": "585f733fcb41dfbeb201146a66efe081865a129e",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/585f733fcb41dfbeb201146a66efe081865a129e",
        "files": [
          "tensorflow/core/kernels/quantize_and_dequantize_op.cc"
        ],
        "message": "Fix tf.raw_ops.QuantizeAndDequantizeV4Grad vulnerability with invalid input_min or input_max.\n\nCheck that argument is actually a scalar before treating it as such.\n\nPiperOrigin-RevId: 445198280",
        "before_after_code_files": [
          "tensorflow/core/kernels/quantize_and_dequantize_op.cc||tensorflow/core/kernels/quantize_and_dequantize_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/quantize_and_dequantize_op.cc||tensorflow/core/kernels/quantize_and_dequantize_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/quantize_and_dequantize_op.cc||tensorflow/core/kernels/quantize_and_dequantize_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/quantize_and_dequantize_op.cc||tensorflow/core/kernels/quantize_and_dequantize_op.cc": [
          "File: tensorflow/core/kernels/quantize_and_dequantize_op.cc -> tensorflow/core/kernels/quantize_and_dequantize_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:     OP_REQUIRES(ctx,",
          "175:                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,",
          "176:                 errors::InvalidArgument(",
          "178:                     input_min_tensor.dims(), \".\"));",
          "179:     const Tensor& input_max_tensor = ctx->input(3);",
          "180:     OP_REQUIRES(ctx,",
          "181:                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,",
          "182:                 errors::InvalidArgument(",
          "184:                     input_max_tensor.dims(), \".\"));",
          "185:     if (axis_ != -1) {",
          "186:       OP_REQUIRES(",
          "",
          "[Removed Lines]",
          "177:                     \"Input min tensor must have dimension 1. Recieved \",",
          "183:                     \"Input max tensor must have dimension 1. Recieved \",",
          "",
          "[Added Lines]",
          "177:                     \"Input min tensor must have dimension 0 or 1. Received \",",
          "183:                     \"Input max tensor must have dimension 0 or 1. Received \",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "203:                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));",
          "205:     if (axis_ == -1) {",
          "206:       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;",
          "207:       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),",
          "208:         input.template flat<T>(), input_min_tensor.scalar<T>(),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206:       OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),",
          "207:                   errors::InvalidArgument(",
          "208:                       \"input_min must be a scalar if axis is unspecified\"));",
          "209:       OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),",
          "210:                   errors::InvalidArgument(",
          "211:                       \"input_max must be a scalar if axis is unspecified\"));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-6906",
  "cve_desc": "The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file, related to the decompression buffer.",
  "repo": "libgd/libgd",
  "patch_hash": "fb0e0cce0b9f25389ab56604c3547351617e1415",
  "patch_info": {
    "commit_hash": "fb0e0cce0b9f25389ab56604c3547351617e1415",
    "repo": "libgd/libgd",
    "commit_url": "https://github.com/libgd/libgd/commit/fb0e0cce0b9f25389ab56604c3547351617e1415",
    "files": [
      "src/gd_tga.c",
      "tests/tga/.gitignore",
      "tests/tga/CMakeLists.txt",
      "tests/tga/Makemodule.am",
      "tests/tga/heap_overflow.c",
      "tests/tga/heap_overflow.tga"
    ],
    "message": "Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we augment the check for the\nbitmap's overflow with a check for the buffer's overflow.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6906",
    "before_after_code_files": [
      "src/gd_tga.c||src/gd_tga.c",
      "tests/tga/Makemodule.am||tests/tga/Makemodule.am",
      "tests/tga/heap_overflow.c||tests/tga/heap_overflow.c"
    ]
  },
  "patch_diff": {
    "src/gd_tga.c||src/gd_tga.c": [
      "File: src/gd_tga.c -> src/gd_tga.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "300:     encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );",
      "301:     buffer_caret++;",
      "304:      gdFree( decompression_buffer );",
      "305:      gdFree( conversion_buffer );",
      "306:      return -1;",
      "",
      "[Removed Lines]",
      "303:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {",
      "",
      "[Added Lines]",
      "303:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size",
      "304:       || buffer_caret + pixel_block_size > rle_size) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "316:     encoded_pixels = decompression_buffer[ buffer_caret ] + 1;",
      "317:     buffer_caret++;",
      "320:      gdFree( decompression_buffer );",
      "321:      gdFree( conversion_buffer );",
      "322:      return -1;",
      "",
      "[Removed Lines]",
      "319:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {",
      "",
      "[Added Lines]",
      "320:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size",
      "321:       || buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {",
      "",
      "---------------"
    ],
    "tests/tga/Makemodule.am||tests/tga/Makemodule.am": [
      "File: tests/tga/Makemodule.am -> tests/tga/Makemodule.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "4:  tga/bug00247a \\",
      "5:  tga/bug00248 \\",
      "6:  tga/bug00248a \\",
      "7:  tga/tga_null \\",
      "8:  tga/tga_read",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7:  tga/heap_overflow \\",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "14:  tga/bug00247a.tga \\",
      "15:  tga/bug00248.tga \\",
      "16:  tga/bug00248a.tga \\",
      "17:  tga/tga_read_rgb.png \\",
      "18:  tga/tga_read_rgb.tga \\",
      "19:  tga/tga_read_rgb_rle.tga",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18:  tga/heap_overflow.tga \\",
      "",
      "---------------"
    ],
    "tests/tga/heap_overflow.c||tests/tga/heap_overflow.c": [
      "File: tests/tga/heap_overflow.c -> tests/tga/heap_overflow.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6: #include \"gd.h\"",
      "7: #include \"gdtest.h\"",
      "10: static size_t read_test_file(char **buffer, char *basename);",
      "13: int main()",
      "14: {",
      "15:     gdImagePtr im;",
      "16:     char *buffer;",
      "17:     size_t size;",
      "19:     size = read_test_file(&buffer, \"heap_overflow.tga\");",
      "20:     im = gdImageCreateFromTgaPtr(size, (void *) buffer);",
      "21:     gdTestAssert(im == NULL);",
      "22:     free(buffer);",
      "24:     return gdNumFailures();",
      "25: }",
      "28: static size_t read_test_file(char **buffer, char *basename)",
      "29: {",
      "30:     char *filename;",
      "31:     FILE *fp;",
      "32:     size_t exp_size, act_size;",
      "34:     filename = gdTestFilePath2(\"tga\", basename);",
      "35:     fp = fopen(filename, \"rb\");",
      "36:     gdTestAssert(fp != NULL);",
      "38:  fseek(fp, 0, SEEK_END);",
      "39:  exp_size = ftell(fp);",
      "40:  fseek(fp, 0, SEEK_SET);",
      "43:     gdTestAssert(*buffer != NULL);",
      "44:     act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);",
      "45:     gdTestAssert(act_size == exp_size);",
      "47:     fclose(fp);",
      "48:     free(filename);",
      "50:     return act_size;",
      "51: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ff0234f4da6d1116c0baa66eebd8497526f7a5d9",
      "candidate_info": {
        "commit_hash": "ff0234f4da6d1116c0baa66eebd8497526f7a5d9",
        "repo": "libgd/libgd",
        "commit_url": "https://github.com/libgd/libgd/commit/ff0234f4da6d1116c0baa66eebd8497526f7a5d9",
        "files": [
          "src/gd_tga.c"
        ],
        "message": "Proper fix for #248",
        "before_after_code_files": [
          "src/gd_tga.c||src/gd_tga.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/gd_tga.c||src/gd_tga.c"
          ],
          "candidate": [
            "src/gd_tga.c||src/gd_tga.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gd_tga.c||src/gd_tga.c": [
          "File: src/gd_tga.c -> src/gd_tga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "196:  int buffer_caret = 0;",
          "197:  int bitmap_caret = 0;",
          "198:  int i = 0;",
          "200:  uint8_t encoded_pixels;",
          "202:  if(overflow2(tga->width, tga->height)) {",
          "",
          "[Removed Lines]",
          "199:  int j = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "280:   while( bitmap_caret < image_block_size ) {",
          "282:    if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {",
          "284:     buffer_caret++;",
          "299:     }",
          "300:     buffer_caret += pixel_block_size;",
          "301:    } else {",
          "302:     encoded_pixels = decompression_buffer[ buffer_caret ] + 1;",
          "303:     buffer_caret++;",
          "319:     }",
          "320:    }",
          "321:   }",
          "322:   gdFree( decompression_buffer );",
          "",
          "[Removed Lines]",
          "283:     encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );",
          "286:     if (encoded_pixels != 0) {",
          "288:      if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {",
          "289:       gdFree( decompression_buffer );",
          "290:       gdFree( conversion_buffer );",
          "291:       return -1;",
          "292:      }",
          "294:      for (i = 0; i < encoded_pixels; i++) {",
          "295:       for (j = 0; j < pixel_block_size; j++, bitmap_caret++) {",
          "296:        tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];",
          "297:       }",
          "298:      }",
          "305:     if (encoded_pixels != 0) {",
          "307:      if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {",
          "308:       gdFree( decompression_buffer );",
          "309:       gdFree( conversion_buffer );",
          "310:       return -1;",
          "311:      }",
          "313:      for (i = 0; i < encoded_pixels; i++) {",
          "314:       for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {",
          "315:        tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];",
          "316:       }",
          "317:       buffer_caret += pixel_block_size;",
          "318:      }",
          "",
          "[Added Lines]",
          "282:     encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & !TGA_RLE_FLAG ) + 1 );",
          "285:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {",
          "286:      gdFree( decompression_buffer );",
          "287:      gdFree( conversion_buffer );",
          "288:      return -1;",
          "289:     }",
          "291:     for (i = 0; i < encoded_pixels; i++) {",
          "292:      memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size);",
          "293:      bitmap_caret += pixel_block_size;",
          "301:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {",
          "302:      gdFree( decompression_buffer );",
          "303:      gdFree( conversion_buffer );",
          "304:      return -1;",
          "307:     memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size);",
          "308:     bitmap_caret += (encoded_pixels * pixel_block_size);",
          "309:     buffer_caret += (encoded_pixels * pixel_block_size);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58b6dde319c301b0eae27d12e2a659e067d80558",
      "candidate_info": {
        "commit_hash": "58b6dde319c301b0eae27d12e2a659e067d80558",
        "repo": "libgd/libgd",
        "commit_url": "https://github.com/libgd/libgd/commit/58b6dde319c301b0eae27d12e2a659e067d80558",
        "files": [
          "src/gd_tga.c",
          "tests/tga/Makemodule.am",
          "tests/tga/heap_overflow.c",
          "tests/tga/heap_overflow_1.tga",
          "tests/tga/heap_overflow_2.tga"
        ],
        "message": "Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we also have to check for\npotential decompression buffer overflows.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org;\na modified case exposing an off-by-one error of the first patch had been\nprovided by Konrad Beckmann.\n\nThis commit is an amendment to commit fb0e0cce, so we use CVE-2016-6906\nas well.",
        "before_after_code_files": [
          "src/gd_tga.c||src/gd_tga.c",
          "tests/tga/Makemodule.am||tests/tga/Makemodule.am",
          "tests/tga/heap_overflow.c||tests/tga/heap_overflow.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/gd_tga.c||src/gd_tga.c",
            "tests/tga/Makemodule.am||tests/tga/Makemodule.am",
            "tests/tga/heap_overflow.c||tests/tga/heap_overflow.c"
          ],
          "candidate": [
            "src/gd_tga.c||src/gd_tga.c",
            "tests/tga/Makemodule.am||tests/tga/Makemodule.am",
            "tests/tga/heap_overflow.c||tests/tga/heap_overflow.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gd_tga.c||src/gd_tga.c": [
          "File: src/gd_tga.c -> src/gd_tga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "295:   buffer_caret = 0;",
          "297:   while( bitmap_caret < image_block_size ) {",
          "299:    if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {",
          "300:     encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );",
          "301:     buffer_caret++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "299:    if (buffer_caret + pixel_block_size > rle_size) {",
          "300:     gdFree( decompression_buffer );",
          "301:     gdFree( conversion_buffer );",
          "302:     return -1;",
          "303:    }",
          "",
          "---------------"
        ],
        "tests/tga/Makemodule.am||tests/tga/Makemodule.am": [
          "File: tests/tga/Makemodule.am -> tests/tga/Makemodule.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:  tga/bug00247a.tga \\",
          "16:  tga/bug00248.tga \\",
          "17:  tga/bug00248a.tga \\",
          "19:  tga/tga_read_rgb.png \\",
          "20:  tga/tga_read_rgb.tga \\",
          "21:  tga/tga_read_rgb_rle.tga",
          "",
          "[Removed Lines]",
          "18:  tga/heap_overflow.tga \\",
          "",
          "[Added Lines]",
          "18:  tga/heap_overflow_1.tga \\",
          "19:  tga/heap_overflow_2.tga \\",
          "",
          "---------------"
        ],
        "tests/tga/heap_overflow.c||tests/tga/heap_overflow.c": [
          "File: tests/tga/heap_overflow.c -> tests/tga/heap_overflow.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #include \"gdtest.h\"",
          "10: static size_t read_test_file(char **buffer, char *basename);",
          "13: int main()",
          "14: {",
          "15:     gdImagePtr im;",
          "16:     char *buffer;",
          "17:     size_t size;",
          "20:     im = gdImageCreateFromTgaPtr(size, (void *) buffer);",
          "21:     gdTestAssert(im == NULL);",
          "22:     free(buffer);",
          "25: }",
          "",
          "[Removed Lines]",
          "19:     size = read_test_file(&buffer, \"heap_overflow.tga\");",
          "24:     return gdNumFailures();",
          "",
          "[Added Lines]",
          "10: static void check_file(char *basename);",
          "15: {",
          "16:     check_file(\"heap_overflow_1.tga\");",
          "17:     check_file(\"heap_overflow_2.tga\");",
          "19:     return gdNumFailures();",
          "20: }",
          "23: static void check_file(char *basename)",
          "29:     size = read_test_file(&buffer, basename);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "981060efd6415ed9a08a6aa343e6e195bf65fb47",
      "candidate_info": {
        "commit_hash": "981060efd6415ed9a08a6aa343e6e195bf65fb47",
        "repo": "libgd/libgd",
        "commit_url": "https://github.com/libgd/libgd/commit/981060efd6415ed9a08a6aa343e6e195bf65fb47",
        "files": [
          "src/gd_tga.c"
        ],
        "message": "bug #248, fix Out-Of-Bounds Read in read_image_tga",
        "before_after_code_files": [
          "src/gd_tga.c||src/gd_tga.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/gd_tga.c||src/gd_tga.c"
          ],
          "candidate": [
            "src/gd_tga.c||src/gd_tga.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gd_tga.c||src/gd_tga.c": [
          "File: src/gd_tga.c -> src/gd_tga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "278:   buffer_caret = 0;",
          "280:   while( bitmap_caret < image_block_size ) {",
          "282:    if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {",
          "283:     encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );",
          "284:     buffer_caret++;",
          "289:      }",
          "290:     }",
          "291:     buffer_caret += pixel_block_size;",
          "",
          "[Removed Lines]",
          "286:     for (i = 0; i < encoded_pixels; i++) {",
          "287:      for (j = 0; j < pixel_block_size; j++, bitmap_caret++) {",
          "288:       tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];",
          "",
          "[Added Lines]",
          "286:     if (encoded_pixels != 0) {",
          "288:      if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {",
          "289:       gdFree( decompression_buffer );",
          "290:       gdFree( conversion_buffer );",
          "291:       return -1;",
          "292:      }",
          "294:      for (i = 0; i < encoded_pixels; i++) {",
          "295:       for (j = 0; j < pixel_block_size; j++, bitmap_caret++) {",
          "296:        tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];",
          "297:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "293:     encoded_pixels = decompression_buffer[ buffer_caret ] + 1;",
          "294:     buffer_caret++;",
          "299:      }",
          "301:     }",
          "302:    }",
          "303:   }",
          "",
          "[Removed Lines]",
          "296:     for (i = 0; i < encoded_pixels; i++) {",
          "297:      for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {",
          "298:       tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];",
          "300:      buffer_caret += pixel_block_size;",
          "",
          "[Added Lines]",
          "305:     if (encoded_pixels != 0) {",
          "307:      if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {",
          "308:       gdFree( decompression_buffer );",
          "309:       gdFree( conversion_buffer );",
          "310:       return -1;",
          "311:      }",
          "313:      for (i = 0; i < encoded_pixels; i++) {",
          "314:       for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {",
          "315:        tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];",
          "316:       }",
          "317:       buffer_caret += pixel_block_size;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f8e26f2a40ffaa3a5b77be6a49989a1a42e2b83",
      "candidate_info": {
        "commit_hash": "4f8e26f2a40ffaa3a5b77be6a49989a1a42e2b83",
        "repo": "libgd/libgd",
        "commit_url": "https://github.com/libgd/libgd/commit/4f8e26f2a40ffaa3a5b77be6a49989a1a42e2b83",
        "files": [
          "src/gd_tga.c",
          "tests/tga/CMakeLists.txt",
          "tests/tga/Makemodule.am",
          "tests/tga/tga_read.c",
          "tests/tga/tga_read_rgb.png",
          "tests/tga/tga_read_rgb.tga",
          "tests/tga/tga_read_rgb_rle.tga"
        ],
        "message": "Fix #290: TGA RLE decoding is broken\n\nWe make it work only, for now. Actually, it doesn't make sense that\n`oTga::bitmap` is an `int *` as we're storing only bytes there. If this\nwill be changed, we can even get rid of the `conversion_buffer` in\n`read_image_tga` altogether, and read the image data into the\n`decompression_buffer` (if RLE'd) or the `tga->bitmap` (if uncompressed)\ndirectly.",
        "before_after_code_files": [
          "src/gd_tga.c||src/gd_tga.c",
          "tests/tgMakemodule.am||tests/tga/Makemodule.am",
          "tests/tgtga_read.c||tests/tga/tga_read.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/gd_tga.c||src/gd_tga.c"
          ],
          "candidate": [
            "src/gd_tga.c||src/gd_tga.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gd_tga.c||src/gd_tga.c": [
          "File: src/gd_tga.c -> src/gd_tga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "207: {",
          "208:  int pixel_block_size = (tga->bits / 8);",
          "209:  int image_block_size = (tga->width * tga->height) * pixel_block_size;",
          "211:  unsigned char* conversion_buffer = NULL;",
          "212:  int buffer_caret = 0;",
          "213:  int bitmap_caret = 0;",
          "214:  int i = 0;",
          "215:  int encoded_pixels;",
          "217:  if(overflow2(tga->width, tga->height)) {",
          "218:   return -1;",
          "",
          "[Removed Lines]",
          "210:  uint8_t* decompression_buffer = NULL;",
          "",
          "[Added Lines]",
          "210:  int* decompression_buffer = NULL;",
          "216:  int rle_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:   if (decompression_buffer == NULL) {",
          "271:    return -1;",
          "272:   }",
          "",
          "[Removed Lines]",
          "269:   decompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));",
          "",
          "[Added Lines]",
          "270:   decompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277:    return -1;",
          "278:   }",
          "281:    gdFree(conversion_buffer);",
          "282:    gdFree(decompression_buffer);",
          "283:    return -1;",
          "",
          "[Removed Lines]",
          "280:   if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {",
          "",
          "[Added Lines]",
          "281:   rle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);",
          "282:   if (rle_size <= 0) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "286:   buffer_caret = 0;",
          "289:    decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];",
          "290:    buffer_caret++;",
          "291:   }",
          "",
          "[Removed Lines]",
          "288:   while( buffer_caret < image_block_size) {",
          "",
          "[Added Lines]",
          "290:   while( buffer_caret < rle_size) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "298:     encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );",
          "299:     buffer_caret++;",
          "302:      gdFree( decompression_buffer );",
          "303:      gdFree( conversion_buffer );",
          "304:      return -1;",
          "305:     }",
          "307:     for (i = 0; i < encoded_pixels; i++) {",
          "309:      bitmap_caret += pixel_block_size;",
          "310:     }",
          "311:     buffer_caret += pixel_block_size;",
          "",
          "[Removed Lines]",
          "301:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {",
          "308:      memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size);",
          "",
          "[Added Lines]",
          "303:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {",
          "310:      memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "314:     encoded_pixels = decompression_buffer[ buffer_caret ] + 1;",
          "315:     buffer_caret++;",
          "318:      gdFree( decompression_buffer );",
          "319:      gdFree( conversion_buffer );",
          "320:      return -1;",
          "321:     }",
          "324:     bitmap_caret += (encoded_pixels * pixel_block_size);",
          "325:     buffer_caret += (encoded_pixels * pixel_block_size);",
          "326:    }",
          "",
          "[Removed Lines]",
          "317:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {",
          "323:     memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size);",
          "",
          "[Added Lines]",
          "319:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {",
          "325:     memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));",
          "",
          "---------------"
        ],
        "tests/tgMakemodule.am||tests/tga/Makemodule.am": [
          "File: tests/tgMakemodule.am -> tests/tga/Makemodule.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7:  tga/tga_null \\",
          "8:  tga/tga_read",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16:  tga/bug00248a.tga \\",
          "17:  tga/tga_read_rgb.png \\",
          "18:  tga/tga_read_rgb.tga \\",
          "19:  tga/tga_read_rgb_rle.tga",
          "",
          "---------------"
        ],
        "tests/tgtga_read.c||tests/tga/tga_read.c": [
          "File: tests/tgtga_read.c -> tests/tga/tga_read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #include \"gd.h\"",
          "7: #include \"gdtest.h\"",
          "10: static void assert_equals(char *exp, char *orig);",
          "13: int main()",
          "14: {",
          "15:     assert_equals(\"tga_read_rgb.png\", \"tga_read_rgb.tga\");",
          "16:     assert_equals(\"tga_read_rgb.png\", \"tga_read_rgb_rle.tga\");",
          "18:     return gdNumFailures();",
          "19: }",
          "22: static void assert_equals(char *exp, char *orig)",
          "23: {",
          "24:     gdImagePtr im;",
          "25:     FILE *fp;",
          "26:     char *filename;",
          "28:     fp = gdTestFileOpen2(\"tga\", orig);",
          "29:     gdTestAssertMsg(fp != NULL, \"can't open %s\", orig);",
          "31:     im = gdImageCreateFromTga(fp);",
          "32:     gdTestAssertMsg(im != NULL, \"can't read %s\", orig);",
          "33:     fclose(fp);",
          "35:     filename = gdTestFilePath2(\"tga\", exp);",
          "36:     gdAssertImageEqualsToFile(filename, im);",
          "37:     gdFree(filename);",
          "39:     gdImageDestroy(im);",
          "40: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8b9eaf06e425be4c641e0b8b457e992504993a47",
      "candidate_info": {
        "commit_hash": "8b9eaf06e425be4c641e0b8b457e992504993a47",
        "repo": "libgd/libgd",
        "commit_url": "https://github.com/libgd/libgd/commit/8b9eaf06e425be4c641e0b8b457e992504993a47",
        "files": [
          "src/gd_tga.c",
          "tests/tga/.gitignore",
          "tests/tga/CMakeLists.txt",
          "tests/tga/Makemodule.am",
          "tests/tga/heap_overflow.c",
          "tests/tga/heap_overflow.tga"
        ],
        "message": "Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we augment the check for the\nbitmap's overflow with a check for the buffer's overflow.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.",
        "before_after_code_files": [
          "src/gd_tga.c||src/gd_tga.c",
          "tests/tgMakemodule.am||tests/tga/Makemodule.am",
          "tests/tgheap_overflow.c||tests/tga/heap_overflow.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/gd_tga.c||src/gd_tga.c"
          ],
          "candidate": [
            "src/gd_tga.c||src/gd_tga.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gd_tga.c||src/gd_tga.c": [
          "File: src/gd_tga.c -> src/gd_tga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "300:     encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );",
          "301:     buffer_caret++;",
          "304:      gdFree( decompression_buffer );",
          "305:      gdFree( conversion_buffer );",
          "306:      return -1;",
          "",
          "[Removed Lines]",
          "303:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {",
          "",
          "[Added Lines]",
          "303:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size",
          "304:       || buffer_caret + pixel_block_size > rle_size) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "316:     encoded_pixels = decompression_buffer[ buffer_caret ] + 1;",
          "317:     buffer_caret++;",
          "320:      gdFree( decompression_buffer );",
          "321:      gdFree( conversion_buffer );",
          "322:      return -1;",
          "",
          "[Removed Lines]",
          "319:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {",
          "",
          "[Added Lines]",
          "320:     if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size",
          "321:       || buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {",
          "",
          "---------------"
        ],
        "tests/tgMakemodule.am||tests/tga/Makemodule.am": [
          "File: tests/tgMakemodule.am -> tests/tga/Makemodule.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7:  tga/heap_overflow \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18:  tga/heap_overflow.tga \\",
          "",
          "---------------"
        ],
        "tests/tgheap_overflow.c||tests/tga/heap_overflow.c": [
          "File: tests/tgheap_overflow.c -> tests/tga/heap_overflow.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #include \"gd.h\"",
          "7: #include \"gdtest.h\"",
          "10: static size_t read_test_file(char **buffer, char *basename);",
          "13: int main()",
          "14: {",
          "15:     gdImagePtr im;",
          "16:     char *buffer;",
          "17:     size_t size;",
          "19:     size = read_test_file(&buffer, \"heap_overflow.tga\");",
          "20:     im = gdImageCreateFromTgaPtr(size, (void *) buffer);",
          "21:     gdTestAssert(im == NULL);",
          "22:     free(buffer);",
          "24:     return gdNumFailures();",
          "25: }",
          "28: static size_t read_test_file(char **buffer, char *basename)",
          "29: {",
          "30:     char *filename;",
          "31:     FILE *fp;",
          "32:     size_t exp_size, act_size;",
          "34:     filename = gdTestFilePath2(\"tga\", basename);",
          "35:     fp = fopen(filename, \"rb\");",
          "36:     gdTestAssert(fp != NULL);",
          "38:  fseek(fp, 0, SEEK_END);",
          "39:  exp_size = ftell(fp);",
          "40:  fseek(fp, 0, SEEK_SET);",
          "43:     gdTestAssert(*buffer != NULL);",
          "44:     act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);",
          "45:     gdTestAssert(act_size == exp_size);",
          "47:     fclose(fp);",
          "48:     free(filename);",
          "50:     return act_size;",
          "51: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-35525",
  "cve_desc": "PostSRSd before 1.11 allows a denial of service (subprocess hang) if Postfix sends certain long data fields such as multiple concatenated email addresses. NOTE: the PostSRSd maintainer acknowledges \"theoretically, this error should never occur ... I'm not sure if there's a reliable way to trigger this condition by an external attacker, but it is a security bug in PostSRSd nevertheless.\"",
  "repo": "roehling/postsrsd",
  "patch_hash": "077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
  "patch_info": {
    "commit_hash": "077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
    "repo": "roehling/postsrsd",
    "commit_url": "https://github.com/roehling/postsrsd/commit/077be98d8c8a9847e4ae0c7dc09e7474cbe27db2",
    "files": [
      "postsrsd.c",
      "run_postsrsd_tests.bats"
    ],
    "message": "SECURITY: Fix DoS on overly long input from Postfix\n\nThanks to Mateusz Jo\u0144czyk who reported this issue and gave valuable\nfeedback for its resolution.\n\nPostSRSd would hang on an overly long GET request, because the\nfread()/fwrite() logic in the subprocess would get confused by the\nremaining input line in its buffer.\n\nTheoretically, this error should never occur, as Postfix is supposed to\nsend valid email addresses only, which are shorter than the buffer, even\nassuming every single character is percent-encoded. However, Postfix\nsometimes does seem to send malformed request with multiple concatenated\nemail addresses. I'm not sure if there's a reliable way to trigger this\ncondition by an external attacker, but it is a security bug in PostSRSd\nnevertheless.",
    "before_after_code_files": [
      "postsrsd.c||postsrsd.c",
      "run_postsrsd_tests.bats||run_postsrsd_tests.bats"
    ]
  },
  "patch_diff": {
    "postsrsd.c||postsrsd.c": [
      "File: postsrsd.c -> postsrsd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "645:     while (TRUE)",
      "646:     {",
      "647:         int conn;",
      "649:         char linebuf[1024], *line;",
      "650:         char keybuf[1024], *key;",
      "",
      "[Removed Lines]",
      "648:         FILE *fp;",
      "",
      "[Added Lines]",
      "648:         FILE *fp_read, *fp_write;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "675:                     for (i = 0; i < socket_count; ++i)",
      "676:                         close(sockets[i]);",
      "684:                         return EXIT_FAILURE;",
      "687:                     {",
      "689:                         char *token;",
      "690:                         token = strtok(line, \" \\r\\n\");",
      "691:                         if (token == NULL || strcmp(token, \"get\") != 0)",
      "692:                         {",
      "695:                             return EXIT_FAILURE;",
      "696:                         }",
      "697:                         token = strtok(NULL, \"\\r\\n\");",
      "698:                         if (!token)",
      "699:                         {",
      "702:                             return EXIT_FAILURE;",
      "703:                         }",
      "704:                         key = url_decode(keybuf, sizeof(keybuf), token);",
      "705:                         if (!key)",
      "706:                         {",
      "709:                             return EXIT_FAILURE;",
      "710:                         }",
      "716:                     }",
      "718:                     return EXIT_SUCCESS;",
      "719:                 }",
      "720:                 close(conn);",
      "",
      "[Removed Lines]",
      "678:                     fp = fdopen(conn, \"r+\");",
      "679:                     if (fp == NULL)",
      "680:                         exit(EXIT_FAILURE);",
      "681:                     fds[0].fd = conn;",
      "682:                     fds[0].events = POLLIN;",
      "683:                     if (poll(fds, 1, timeout * 1000) <= 0)",
      "685:                     line = fgets(linebuf, sizeof(linebuf), fp);",
      "686:                     while (line)",
      "693:                             fprintf(fp, \"500 Invalid request\\n\");",
      "694:                             fflush(fp);",
      "700:                             fprintf(fp, \"500 Invalid request\\n\");",
      "701:                             fflush(fp);",
      "707:                             fprintf(fp, \"500 Invalid request\\n\");",
      "708:                             fflush(fp);",
      "711:                         handler[sc](srs, fp, key, domain, excludes);",
      "712:                         fflush(fp);",
      "713:                         if (poll(fds, 1, timeout * 1000) <= 0)",
      "714:                             break;",
      "715:                         line = fgets(linebuf, sizeof(linebuf), fp);",
      "717:                     fclose(fp);",
      "",
      "[Added Lines]",
      "678:                     fp_read = fdopen(conn, \"r\");",
      "679:                     if (fp_read == NULL)",
      "680:                         return EXIT_FAILURE;",
      "681:                     fp_write = fdopen(dup(conn), \"w\");",
      "682:                     if (fp_write == NULL)",
      "684:                     errno = 0;",
      "685:                     alarm(timeout);",
      "686:                     if (errno != 0)",
      "687:                         return EXIT_FAILURE;",
      "688:                     while ((line = fgets(linebuf, sizeof(linebuf), fp_read)))",
      "691:                         alarm(0);",
      "692:                         if (strlen(line) >= sizeof(linebuf) - 1)",
      "693:                         {",
      "694:                             fprintf(fp_write, \"500 Invalid request\\n\");",
      "695:                             fflush(fp_write);",
      "696:                             return EXIT_FAILURE;",
      "697:                         }",
      "701:                             fprintf(fp_write, \"500 Invalid request\\n\");",
      "702:                             fflush(fp_write);",
      "708:                             fprintf(fp_write, \"500 Invalid request\\n\");",
      "709:                             fflush(fp_write);",
      "715:                             fprintf(fp_write, \"500 Invalid request\\n\");",
      "716:                             fflush(fp_write);",
      "719:                         handler[sc](srs, fp_write, key, domain, excludes);",
      "720:                         fflush(fp_write);",
      "721:                         errno = 0;",
      "722:                         alarm(timeout);",
      "723:                         if (errno != 0)",
      "724:                             return EXIT_FAILURE;",
      "726:                     fclose(fp_write);",
      "727:                     fclose(fp_read);",
      "",
      "---------------"
    ],
    "run_postsrsd_tests.bats||run_postsrsd_tests.bats": [
      "File: run_postsrsd_tests.bats -> run_postsrsd_tests.bats",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: if [ ! -x \"$POSTSRSD\" ]",
      "5: then",
      "7:  do",
      "8:   if [ -x \"${builddir}/postsrsd\" ]",
      "9:   then",
      "",
      "[Removed Lines]",
      "6:  for builddir in . build* obj*",
      "",
      "[Added Lines]",
      "6:  for builddir in . build* obj* _build*",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "15: if [ ! -x \"$POSTSRSD\" ]",
      "16: then",
      "17:  cat>&2 <<- EOF",
      "19:  please build the executable first, or set the POSTSRSD",
      "20:  environment variable if it is in a different location.",
      "",
      "[Removed Lines]",
      "18:  cannot find postsrsd executable (looked in ., build*, obj*)",
      "",
      "[Added Lines]",
      "18:  cannot find postsrsd executable (looked in ., build*, obj*, _build*)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "26: LANG=C.UTF-8",
      "29: start_postsrsd_at()",
      "30: {",
      "31:  echo 'tops3cr3t' > \"$BATS_TMPDIR/postsrsd.secret\"",
      "32:  local faketime=\"$1\"",
      "33:  shift",
      "35: }",
      "37: stop_postsrsd()",
      "",
      "[Removed Lines]",
      "34:  faketime \"${faketime}\" ${POSTSRSD} -D -f 10001 -r 10002 -p \"$BATS_TMPDIR/postsrsd.pid\" -s \"$BATS_TMPDIR/postsrsd.secret\" -d example.com \"$@\"",
      "",
      "[Added Lines]",
      "29: fillchar()",
      "30: {",
      "31:         local count=\"$1\"",
      "32:         local char=\"$2\"",
      "33:         eval 'printf \"'\"$char\"'%.0s\" {1..'\"$count\"'}'",
      "34: }",
      "41:  faketime \"${faketime}\" ${POSTSRSD} -D -t1 -f 10001 -r 10002 -p \"$BATS_TMPDIR/postsrsd.pid\" -s \"$BATS_TMPDIR/postsrsd.secret\" -d example.com \"$@\"",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "159:  [[ \"$line\" =~ ^\"500 Domain excluded\" ]]",
      "160: }",
      "163:  start_postsrsd_at \"2020-01-01 00:01:00 UTC\"",
      "164:  exec 9<>/dev/tcp/127.0.0.1/10001",
      "165:  echo>&9 \"get\"",
      "",
      "[Removed Lines]",
      "162: @test \"SRS invalid requests\" {",
      "",
      "[Added Lines]",
      "169: @test \"Malformed or invalid requests\" {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "173:  echo>&9 \"get encoding%error@otherdomain.com\"",
      "174:  read<&9 line",
      "175:  [[ \"$line\" =~ ^500 ]]",
      "176: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "183:  exec 9<>/dev/tcp/127.0.0.1/10001",
      "184:  # Try to overflow the input buffer",
      "185:  echo>&9 \"get too_long@`fillchar 1024 a`.com\"",
      "186:  read<&9 line",
      "187:  [[ \"$line\" =~ ^500 ]]",
      "188: }",
      "190: @test \"Pipelining multiple requests\" {",
      "191:  start_postsrsd_at \"2020-01-01 00:01:00 UTC\"",
      "192:  exec 9<>/dev/tcp/127.0.0.1/10001",
      "193:  # Send two requests at once and see if PostSRSd answers both",
      "194:  echo>&9 -e \"get test@domain1.com\\nget test@domain2.com\"",
      "195:  read<&9 line",
      "196:  [[ \"$line\" =~ ^200 ]]",
      "197:  read<&9 line",
      "198:  [[ \"$line\" =~ ^200 ]]",
      "199: }",
      "201: @test \"Session timeout\" {",
      "202:  start_postsrsd_at \"2020-01-01 00:01:00 UTC\"",
      "203:  exec 9<>/dev/tcp/127.0.0.1/10001",
      "204:  # Wait until PostSRSd disconnects due to inactivity",
      "205:  sleep 2",
      "206:  echo >&9 \"get test@example.com\"",
      "207:  ! read <&9 line",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "db2e3bc637fffff470723e3a665503ec90a4f493",
      "candidate_info": {
        "commit_hash": "db2e3bc637fffff470723e3a665503ec90a4f493",
        "repo": "roehling/postsrsd",
        "commit_url": "https://github.com/roehling/postsrsd/commit/db2e3bc637fffff470723e3a665503ec90a4f493",
        "files": [
          ".clang-format",
          "postsrsd.c",
          "sha1.c",
          "srs2.c",
          "srs2.h",
          "tests.c"
        ],
        "message": "Use clang-format",
        "before_after_code_files": [
          "postsrsd.c||postsrsd.c",
          "sha1.c||sha1.c",
          "srs2.c||srs2.c",
          "srs2.h||srs2.h",
          "tests.c||tests.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "postsrsd.c||postsrsd.c"
          ],
          "candidate": [
            "postsrsd.c||postsrsd.c"
          ]
        }
      },
      "candidate_diff": {
        "postsrsd.c||postsrsd.c": [
          "File: postsrsd.c -> postsrsd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"srs2.h\"",
          "25: #include <errno.h>",
          "27: #include <fcntl.h>",
          "28: #include <pwd.h>",
          "29: #include <string.h>",
          "31: #ifdef HAVE_SYS_TIME_H",
          "33: #endif",
          "34: #ifdef HAVE_TIME_H",
          "36: #endif",
          "37: #ifdef HAVE_SYS_WAIT_H",
          "39: #endif",
          "40: #ifdef HAVE_WAIT_H",
          "42: #endif",
          "43: #include <syslog.h>",
          "45: static char *self = NULL;",
          "48: {",
          "62:     return count;",
          "87: }",
          "90: {",
          "92: }",
          "95: {",
          "100: }",
          "103: {",
          "106: }",
          "109: {",
          "111: }",
          "114: {",
          "117: }",
          "120: {",
          "134:     }",
          "138: }",
          "141: {",
          "152:     }",
          "156: }",
          "159: {",
          "175:     }",
          "195: }",
          "198: {",
          "213: }",
          "216: {",
          "250: }",
          "255: {",
          "344:                 return EXIT_FAILURE;",
          "351:         }",
          "391:         }",
          "396:     }",
          "427:     }",
          "435:     }",
          "464:     }",
          "471:     }",
          "475:     }",
          "482:     }",
          "486:     }",
          "534:     }",
          "570:             }",
          "578:         }",
          "581:     }",
          "585: }",
          "",
          "[Removed Lines]",
          "22: #include <sys/types.h>",
          "23: #include <sys/socket.h>",
          "24: #include <netdb.h>",
          "26: #include <unistd.h>",
          "30: #include <poll.h>",
          "32: #include <sys/time.h>",
          "35: #include <time.h>",
          "38: #include <sys/wait.h>",
          "41: #include <wait.h>",
          "47: static size_t bind_service (const char *listen_addr, const char *service, int family, int* socks, size_t max_socks)",
          "49:   struct addrinfo *addr, *it;",
          "50:   struct addrinfo hints;",
          "51:   int err, sock, flags;",
          "52:   size_t count = 0;",
          "53:   static const int one = 1;",
          "55:   memset (&hints, 0, sizeof(hints));",
          "56:   hints.ai_family = family;",
          "57:   hints.ai_socktype = SOCK_STREAM;",
          "59:   err = getaddrinfo(listen_addr, service, &hints, &addr);",
          "60:   if (err != 0) {",
          "61:     fprintf(stderr, \"%s: bind_service(%s): %s\\n\", self, service, gai_strerror(err));",
          "63:   }",
          "64:   sock = -1;",
          "65:   for (it = addr; it; it = it->ai_next) {",
          "66:     if (max_socks == 0) break;",
          "67:     sock = socket(it->ai_family, it->ai_socktype, it->ai_protocol);",
          "68:     if (sock < 0) goto fail;",
          "69:     if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) < 0) goto fail;",
          "70:     if (bind(sock, it->ai_addr, it->ai_addrlen) < 0) goto fail;",
          "71:     if (listen(sock, 10) < 0) goto fail;",
          "72:     flags = fcntl (sock, F_GETFL, 0);",
          "73:     if (flags < 0) goto fail;",
          "74:     if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) goto fail;",
          "76:     ++count;",
          "77:     --max_socks;",
          "78:     continue;",
          "79:   fail:",
          "80:     err = errno;",
          "81:     if (sock >= 0) close (sock);",
          "82:   }",
          "83:   freeaddrinfo (addr);",
          "84:   if (count == 0)",
          "85:     fprintf (stderr, \"%s: bind_service(%s): %s\\n\", self, service, strerror(err));",
          "86:   return count;",
          "89: static int is_hexdigit (char c)",
          "91:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');",
          "94: static char hex2num (char c)",
          "96:   if (c >= '0' && c <= '9') return c - '0';",
          "97:   if (c >= 'a' && c <= 'f') return c - 'a' + 10;",
          "98:   if (c >= 'A' && c <= 'F') return c - 'A' + 10;",
          "99:   return 0;",
          "102: static char num2hex (char c)",
          "104:   if (c < 10) return '0' + c;",
          "105:   return 'a' + c - 10;",
          "108: static char hex2char (const char *s)",
          "110:   return 16 * hex2num(s[0]) + hex2num(s[1]);",
          "113: static void char2hex (char c, char *buf)",
          "115:   buf[0] = num2hex((c >> 4) & 0xf);",
          "116:   buf[1] = num2hex((c     ) & 0xf);",
          "119: static char* url_decode (char *buf, size_t len, const char *input)",
          "121:   char *output = buf;",
          "122:   if (!input || !output || len == 0) return NULL;",
          "124:   while (*input && --len) {",
          "125:     if (*input == '%') {",
          "126:       if (is_hexdigit(input[1]) && is_hexdigit(input[2])) {",
          "128:         input += 2;",
          "129:       } else {",
          "130:         return 0;",
          "131:       }",
          "132:     } else {",
          "135:   }",
          "137:   return buf;",
          "140: static char* url_encode (char* buf, size_t len, const char *input)",
          "142:   char *output = buf;",
          "143:   if (!input || !output || len == 0) return NULL;",
          "144:   while (*input && --len) {",
          "145:     if (!isascii(*input) || !isgraph(*input) || *input == '%') {",
          "146:       if (len <= 2) break;",
          "148:       char2hex(*input++, output);",
          "149:       output += 2; len -= 2;",
          "150:     } else {",
          "153:   }",
          "155:   return buf;",
          "158: static void handle_forward (srs_t *srs, FILE *fp, const char *address, const char *domain, const char **excludes)",
          "160:   int result;",
          "161:   size_t addrlen;",
          "162:   char value[1024];",
          "163:   char outputbuf[1024], *output;",
          "165:   addrlen = strlen(address);",
          "166:   for(; *excludes; excludes++) {",
          "167:     size_t len;",
          "168:     len = strlen(*excludes);",
          "169:     if (len >= addrlen) continue;",
          "170:     if (strcasecmp(*excludes, &address[addrlen - len]) == 0 && (**excludes == '.' || address[addrlen - len - 1] == '@')) {",
          "171:       syslog (LOG_MAIL | LOG_INFO, \"srs_forward: <%s> not rewritten: Domain excluded by policy\", address);",
          "172:       fputs (\"500 Domain excluded py policy\\n\", fp);",
          "173:       fflush (fp);",
          "174:       return;",
          "176:   }",
          "177:   if (srs_reverse(srs, value, sizeof(value), address) == SRS_SUCCESS)",
          "178:   {",
          "179:     fprintf (fp, \"500 Already rewritten\\n\");",
          "180:     fflush (fp);",
          "181:     syslog (LOG_MAIL | LOG_NOTICE, \"srs_forward: <%s> not rewritten: Valid SRS address for <%s>\", address, value);",
          "182:     return;",
          "183:   }",
          "184:   result = srs_forward(srs, value, sizeof(value), address, domain);",
          "185:   if (result == SRS_SUCCESS) {",
          "186:     output = url_encode(outputbuf, sizeof(outputbuf), value);",
          "187:     fprintf (fp, \"200 %s\\n\", output);",
          "188:     if (strcmp(address, value) != 0) syslog (LOG_MAIL | LOG_INFO, \"srs_forward: <%s> rewritten as <%s>\", address, value);",
          "189:   } else {",
          "190:     fprintf (fp, \"500 %s\\n\", srs_strerror(result));",
          "191:     if (result != SRS_ENOTREWRITTEN)",
          "192:       syslog (LOG_MAIL | LOG_INFO, \"srs_forward: <%s> not rewritten: %s\", address, srs_strerror(result));",
          "193:   }",
          "194:   fflush (fp);",
          "197: static void handle_reverse (srs_t *srs, FILE *fp, const char *address, const char *domain __attribute__((unused)), const char **excludes __attribute__((unused)) )",
          "199:   int result;",
          "200:   char value[1024];",
          "201:   char outputbuf[1024], *output;",
          "202:   result = srs_reverse(srs, value, sizeof(value), address);",
          "203:   if (result == SRS_SUCCESS) {",
          "204:     output = url_encode(outputbuf, sizeof(outputbuf), value);",
          "205:     fprintf (fp, \"200 %s\\n\", output);",
          "206:     syslog (LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> rewritten as <%s>\", address, value);",
          "207:   } else {",
          "208:     fprintf (fp, \"500 %s\\n\", srs_strerror(result));",
          "209:     if (result != SRS_ENOTREWRITTEN && result != SRS_ENOTSRSADDRESS)",
          "210:       syslog (LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> not rewritten: %s\", address, srs_strerror(result));",
          "211:   }",
          "212:   fflush (fp);",
          "215: static void show_help ()",
          "217:   fprintf (stdout,",
          "218:     \"Sender Rewriting Scheme implementation for Postfix.\\n\\n\"",
          "219:     \"Implements two TCP lookup tables to rewrite mail addresses\\n\"",
          "220:     \"as needed. The forward SRS is for sender envelope addresses\\n\"",
          "221:     \"to prevent SPF-related bounces. The reverse SRS is for\\n\"",
          "222:     \"recipient envelope addresses so that bounced mails can be\\n\"",
          "223:     \"routed back to their original sender.\\n\"",
          "224:     \"\\n\"",
          "225:     \"Usage: %s -s<file> -d<domain> [other options]\\n\"",
          "226:     \"Options:\\n\"",
          "227:     \"   -s<file>       read secrets from file (required)\\n\"",
          "228:     \"   -d<domain>     set domain name for rewrite (required)\\n\"",
          "229:     \"   -a<char>       set first separator character which can be one of: -=+ (default: =)\\n\"",
          "230:     \"   -n<num>        length of hash to be used in rewritten addresses (default: 4)\\n\"",
          "231:     \"   -N<num>        minimum length of hash to accept for validation (default: 4)\\n\"",
          "232:     \"   -l<addr>       set socket listen address (default: 127.0.0.1)\\n\"",
          "233:     \"   -f<port>       set port for the forward SRS lookup (default: 10001)\\n\"",
          "234:     \"   -r<port>       set port for the reverse SRS lookup (default: 10002)\\n\"",
          "235:     \"   -p<pidfile>    write process ID to pidfile (default: none)\\n\"",
          "236:     \"   -c<dir>        chroot to <dir> (default: none)\\n\"",
          "237:     \"   -u<user>       switch user id after port bind (default: none)\\n\"",
          "238:     \"   -t<seconds>    timeout for idle client connections (default: 1800)\\n\"",
          "239:     \"   -X<domain>     exclude additional domain from address rewriting\\n\"",
          "240:     \"   -A             always rewrite addresses\\n\"",
          "241:     \"   -e             attempt to read above parameters from environment\\n\"",
          "242:     \"   -D             fork into background\\n\"",
          "243:     \"   -4             force IPv4 socket (default: any)\\n\"",
          "244:     \"   -6             force IPv6 socket (default: any)\\n\"",
          "245:     \"   -h             show this help\\n\"",
          "246:     \"   -v             show version\\n\"",
          "247:     \"\\n\",",
          "248:     self",
          "249:   );",
          "252: typedef void(*handle_t)(srs_t*, FILE*, const char*, const char*, const char**);",
          "254: int main (int argc, char **argv)",
          "256:   int opt, timeout = 1800, family = AF_UNSPEC, hashlength = 0, hashmin = 0;",
          "257:   int daemonize = FALSE, always_rewrite = FALSE;",
          "258:   char *listen_addr = NULL, *forward_service = NULL, *reverse_service = NULL,",
          "260:   char separator = '=';",
          "261:   char *secret_file = NULL, *pid_file = NULL;",
          "262:   FILE *pf = NULL, *sf = NULL;",
          "263:   struct passwd *pwd = NULL;",
          "264:   char secretbuf[1024], *secret = NULL;",
          "265:   char *tmp;",
          "266:   time_t now;",
          "267:   srs_t *srs;",
          "268:   const char **excludes;",
          "269:   size_t s1 = 0, s2 = 1;",
          "270:   struct pollfd fds[4];",
          "271:   size_t socket_count = 0, sc;",
          "272:   int sockets[4] = { -1, -1, -1, -1 };",
          "273:   handle_t handler[4] = { 0, 0, 0, 0 };",
          "274:   int fd, maxfd;",
          "276:   excludes = (const char**)calloc(1, sizeof(char*));",
          "277:   tmp = strrchr(argv[0], '/');",
          "278:   if (tmp) self = strdup(tmp + 1); else self = strdup(argv[0]);",
          "280:   while ((opt = getopt(argc, argv, \"46d:a:l:f:r:s:n:N:u:t:p:c:X::ADhev\")) != -1) {",
          "281:     switch (opt) {",
          "282:       case '?':",
          "283:         return EXIT_FAILURE;",
          "284:       case '4':",
          "285:         family = AF_INET;",
          "286:         break;",
          "287:       case '6':",
          "288:         family = AF_INET6;",
          "289:         break;",
          "290:       case 'd':",
          "291:         domain = strdup(optarg);",
          "292:         break;",
          "293:       case 'a':",
          "294:         separator = *optarg;",
          "295:         break;",
          "296:       case 'l':",
          "297:         listen_addr = strdup(optarg);",
          "298:         break;",
          "299:       case 'f':",
          "300:         forward_service = strdup(optarg);",
          "301:         break;",
          "302:       case 'r':",
          "303:         reverse_service = strdup(optarg);",
          "304:         break;",
          "305:       case 't':",
          "306:         timeout = atoi(optarg);",
          "307:         break;",
          "308:       case 's':",
          "309:         secret_file = strdup(optarg);",
          "310:         break;",
          "311:       case 'n':",
          "312:         hashlength = atoi(optarg);",
          "313:         break;",
          "314:       case 'N':",
          "315:         hashmin = atoi(optarg);",
          "316:         break;",
          "317:       case 'p':",
          "318:         pid_file = strdup(optarg);",
          "319:         break;",
          "320:       case 'u':",
          "321:         user = strdup(optarg);",
          "322:         break;",
          "323:       case 'c':",
          "324:         chroot_dir = strdup(optarg);",
          "325:         break;",
          "326:       case 'D':",
          "327:         daemonize = TRUE;",
          "328:         break;",
          "329:       case 'A':",
          "330:         always_rewrite = TRUE;",
          "331:         break;",
          "332:       case 'h':",
          "333:         show_help();",
          "334:         return EXIT_SUCCESS;",
          "335:       case 'X':",
          "336:         if (optarg != NULL) {",
          "337:           tmp = strtok(optarg, \",; \\t\\r\\n\");",
          "338:           while (tmp) {",
          "339:             if (s1 + 1 >= s2) {",
          "340:               s2 *= 2;",
          "341:               excludes = (const char **)realloc(excludes, s2 * sizeof(char*));",
          "342:               if (excludes == NULL) {",
          "343:                 fprintf (stderr, \"%s: Out of memory\\n\\n\", self);",
          "345:               }",
          "346:             }",
          "347:             excludes[s1++] = strdup(tmp);",
          "348:             tmp = strtok(NULL, \",; \\t\\r\\n\");",
          "349:           }",
          "350:           excludes[s1] = NULL;",
          "352:         break;",
          "353:       case 'e':",
          "354:         if ( getenv(\"SRS_DOMAIN\") != NULL )",
          "355:           domain = strdup(getenv(\"SRS_DOMAIN\"));",
          "356:         if ( getenv(\"SRS_SEPARATOR\") != NULL )",
          "357:           separator = *getenv(\"SRS_SEPARATOR\");",
          "358:         if ( getenv(\"SRS_HASHLENGTH\") != NULL )",
          "359:           hashlength = atoi(getenv(\"SRS_HASHLENGTH\"));",
          "360:         if ( getenv(\"SRS_HASHMIN\") != NULL )",
          "361:           hashmin = atoi(getenv(\"SRS_HASHMIN\"));",
          "362:         if ( getenv(\"SRS_FORWARD_PORT\") != NULL )",
          "363:           forward_service = strdup(getenv(\"SRS_FORWARD_PORT\"));",
          "364:         if ( getenv(\"SRS_REVERSE_PORT\") != NULL )",
          "365:           reverse_service = strdup(getenv(\"SRS_REVERSE_PORT\"));",
          "366:         if ( getenv(\"SRS_TIMEOUT\") != NULL )",
          "367:           timeout = atoi(getenv(\"SRS_TIMEOUT\"));",
          "368:         if ( getenv(\"SRS_SECRET\") != NULL )",
          "369:           secret_file = strdup(getenv(\"SRS_SECRET\"));",
          "370:         if ( getenv(\"SRS_PID_FILE\") != NULL )",
          "371:           pid_file = strdup(getenv(\"SRS_PID_FILE\"));",
          "372:         if ( getenv(\"RUN_AS\") != NULL )",
          "373:           user = strdup(getenv(\"RUN_AS\"));",
          "374:         if ( getenv(\"CHROOT\") != NULL )",
          "375:           chroot_dir = strdup(getenv(\"CHROOT\"));",
          "376:         if (getenv(\"SRS_EXCLUDE_DOMAINS\") != NULL) {",
          "377:           tmp = strtok(getenv(\"SRS_EXCLUDE_DOMAINS\"), \",; \\t\\r\\n\");",
          "378:           while (tmp) {",
          "379:             if (s1 + 1 >= s2) {",
          "380:               s2 *= 2;",
          "381:               excludes = (const char **)realloc(excludes, s2 * sizeof(char*));",
          "382:               if (excludes == NULL) {",
          "383:                 fprintf (stderr, \"%s: Out of memory\\n\\n\", self);",
          "384:                 return EXIT_FAILURE;",
          "385:               }",
          "386:             }",
          "387:             excludes[s1++] = strdup(tmp);",
          "388:             tmp = strtok(NULL, \",; \\t\\r\\n\");",
          "389:           }",
          "390:           excludes[s1] = NULL;",
          "392:         break;",
          "393:       case 'v':",
          "394:         fprintf (stdout, \"%s\\n\", POSTSRSD_VERSION);",
          "395:         return EXIT_SUCCESS;",
          "397:   }",
          "398:   if (optind < argc) {",
          "399:     fprintf (stderr, \"%s: extra argument on command line: %s\\n\", self, argv[optind]);",
          "400:     return EXIT_FAILURE;",
          "401:   }",
          "402:   if (domain == NULL || *domain == 0) {",
          "403:     fprintf (stderr, \"%s: You must set a home domain (-d)\\n\", self);",
          "404:     return EXIT_FAILURE;",
          "405:   }",
          "407:   if (separator != '=' && separator != '+' && separator != '-') {",
          "408:     fprintf (stderr, \"%s: SRS separator character must be one of '=+-'\\n\", self);",
          "409:     return EXIT_FAILURE;",
          "410:   }",
          "411:   if (forward_service == NULL) forward_service = strdup(\"10001\");",
          "412:   if (reverse_service == NULL) reverse_service = strdup(\"10002\");",
          "415:   maxfd = sysconf(_SC_OPEN_MAX);",
          "416:   for(fd = 3; fd < maxfd; fd++)",
          "417:     close(fd);",
          "422:   if (pid_file) {",
          "423:     pf = fopen (pid_file, \"w\");",
          "424:     if (pf == NULL) {",
          "425:       fprintf (stderr, \"%s: Cannot write PID: %s\\n\\n\", self, pid_file);",
          "426:       return EXIT_FAILURE;",
          "428:   }",
          "430:   if (secret_file != NULL) {",
          "431:     sf = fopen(secret_file, \"rb\");",
          "432:     if (sf == NULL) {",
          "433:       fprintf (stderr, \"%s: Cannot open file with secret: %s\\n\", self, secret_file);",
          "434:       return EXIT_FAILURE;",
          "436:   } else {",
          "437:     fprintf (stderr, \"%s: You must set a secret (-s)\\n\", self);",
          "438:     return EXIT_FAILURE;",
          "439:   }",
          "441:   sc = bind_service(listen_addr, forward_service, family, &sockets[socket_count], 4 - socket_count);",
          "442:   if (sc == 0) return EXIT_FAILURE;",
          "443:   while (sc-- > 0) handler[socket_count++] = handle_forward;",
          "444:   free (forward_service);",
          "445:   sc = bind_service(listen_addr, reverse_service, family, &sockets[socket_count], 4 - socket_count);",
          "446:   if (sc == 0) return EXIT_FAILURE;",
          "447:   while (sc-- > 0) handler[socket_count++] = handle_reverse;",
          "448:   free (reverse_service);",
          "450:   openlog (self, LOG_PID | LOG_NDELAY, LOG_MAIL);",
          "452:   now = time(NULL);",
          "453:   localtime (&now);",
          "455:   if (user) {",
          "456:     errno = 0;",
          "457:     pwd = getpwnam(user);",
          "458:     if (pwd == NULL) {",
          "459:       if (errno != 0)",
          "460:         fprintf (stderr, \"%s: Failed to lookup user: %s\\n\", self, strerror(errno));",
          "461:       else",
          "462:         fprintf (stderr, \"%s: No such user: %s\\n\", self, user);",
          "463:       return EXIT_FAILURE;",
          "465:   }",
          "467:   if (chroot_dir) {",
          "468:     if (chdir(chroot_dir) < 0) {",
          "469:       fprintf (stderr, \"%s: Cannot change to chroot: %s\\n\", self, strerror(errno));",
          "470:       return EXIT_FAILURE;",
          "472:     if (chroot(chroot_dir) < 0) {",
          "473:       fprintf (stderr, \"%s: Failed to enable chroot: %s\\n\", self, strerror(errno));",
          "474:       return EXIT_FAILURE;",
          "476:   }",
          "478:   if (pwd) {",
          "479:     if (setgid(pwd->pw_gid) < 0) {",
          "480:       fprintf(stderr, \"%s: Failed to switch group id: %s\\n\", self, strerror(errno));",
          "481:       return EXIT_FAILURE;",
          "483:     if (setuid(pwd->pw_uid) < 0) {",
          "484:       fprintf (stderr, \"%s: Failed to switch user id: %s\\n\", self, strerror(errno));",
          "485:       return EXIT_FAILURE;",
          "487:   }",
          "489:   if (daemonize) {",
          "490:     close(0); close(1); close(2);",
          "491:     if (fork() != 0) return EXIT_SUCCESS;",
          "492:     setsid();",
          "493:     if (fork() != 0) return EXIT_SUCCESS;",
          "494:   }",
          "496:   if (pf) {",
          "497:     fprintf (pf, \"%d\", (int)getpid());",
          "498:     fclose (pf);",
          "499:   }",
          "501:   srs = srs_new();",
          "502:   while ((secret = fgets(secretbuf, sizeof(secretbuf), sf))) {",
          "503:     secret = strtok(secret, \"\\r\\n\");",
          "504:     if (secret)",
          "505:       srs_add_secret (srs, secret);",
          "506:   }",
          "507:   fclose (sf);",
          "509:   srs_set_alwaysrewrite (srs, always_rewrite);",
          "510:   srs_set_separator (srs, separator);",
          "511:   if (hashlength)",
          "512:     srs_set_hashlength (srs, hashlength);",
          "513:   if (hashmin)",
          "514:     srs_set_hashmin (srs, hashmin);",
          "516:   for (sc = 0; sc < socket_count; ++sc) {",
          "517:     fds[sc].fd = sockets[sc];",
          "518:     fds[sc].events = POLLIN;",
          "519:   }",
          "520:   while(TRUE) {",
          "521:     int conn;",
          "522:     FILE *fp;",
          "523:     char linebuf[1024], *line;",
          "524:     char keybuf[1024], *key;",
          "526:     if (poll(fds, socket_count, 1000) < 0) {",
          "527:       if (errno == EINTR)",
          "528:         continue;",
          "529:       if (daemonize)",
          "530:         syslog (LOG_MAIL | LOG_ERR, \"Poll failure: %s\", strerror(errno));",
          "531:       else",
          "532:         fprintf (stderr, \"%s: Poll failure: %s\\n\", self, strerror(errno));",
          "533:       return EXIT_FAILURE;",
          "535:     for (sc = 0; sc < socket_count; ++sc) {",
          "536:       if (fds[sc].revents) {",
          "537:         conn = accept(fds[sc].fd, NULL, NULL);",
          "538:         if (conn < 0) continue;",
          "539:         if (fork() == 0) {",
          "540:           int i;",
          "542:           for (i = 0; i < socket_count; ++i) close (sockets[i]);",
          "544:           fp = fdopen(conn, \"r+\");",
          "545:           if (fp == NULL) exit(EXIT_FAILURE);",
          "546:           fds[0].fd = conn;",
          "547:           fds[0].events = POLLIN;",
          "548:           if (poll(fds, 1, timeout * 1000) <= 0) return EXIT_FAILURE;",
          "549:           line = fgets(linebuf, sizeof(linebuf), fp);",
          "550:           while (line) {",
          "552:             char* token;",
          "553:             token = strtok(line, \" \\r\\n\");",
          "554:             if (token == NULL || strcmp(token, \"get\") != 0) {",
          "555:               fprintf (fp, \"500 Invalid request\\n\");",
          "556:               fflush (fp);",
          "557:               return EXIT_FAILURE;",
          "558:             }",
          "559:             token = strtok(NULL, \"\\r\\n\");",
          "560:             if (!token) {",
          "561:               fprintf (fp, \"500 Invalid request\\n\");",
          "562:               fflush (fp);",
          "563:               return EXIT_FAILURE;",
          "564:             }",
          "565:             key = url_decode(keybuf, sizeof(keybuf), token);",
          "566:             if (!key) {",
          "567:               fprintf (fp, \"500 Invalid request\\n\");",
          "568:               fflush(fp);",
          "569:               return EXIT_FAILURE;",
          "571:             handler[sc](srs, fp, key, domain, excludes);",
          "572:             fflush (fp);",
          "573:             if (poll(fds, 1, timeout * 1000) <= 0) break;",
          "574:             line = fgets(linebuf, sizeof(linebuf), fp);",
          "575:           }",
          "576:           fclose (fp);",
          "577:           return EXIT_SUCCESS;",
          "579:         close (conn);",
          "580:       }",
          "582:     waitpid(-1, NULL, WNOHANG);",
          "583:   }",
          "584:   return EXIT_SUCCESS;",
          "",
          "[Added Lines]",
          "25: #include <netdb.h>",
          "26: #include <poll.h>",
          "29: #include <sys/socket.h>",
          "30: #include <sys/types.h>",
          "31: #include <unistd.h>",
          "33: #    include <sys/time.h>",
          "36: #    include <time.h>",
          "39: #    include <sys/wait.h>",
          "42: #    include <wait.h>",
          "48: static size_t bind_service(const char *listen_addr, const char *service,",
          "49:                            int family, int *socks, size_t max_socks)",
          "51:     struct addrinfo *addr, *it;",
          "52:     struct addrinfo hints;",
          "53:     int err, sock, flags;",
          "54:     size_t count = 0;",
          "55:     static const int one = 1;",
          "57:     memset(&hints, 0, sizeof(hints));",
          "58:     hints.ai_family = family;",
          "59:     hints.ai_socktype = SOCK_STREAM;",
          "61:     err = getaddrinfo(listen_addr, service, &hints, &addr);",
          "62:     if (err != 0)",
          "63:     {",
          "64:         fprintf(stderr, \"%s: bind_service(%s): %s\\n\", self, service,",
          "65:                 gai_strerror(err));",
          "66:         return count;",
          "67:     }",
          "68:     sock = -1;",
          "69:     for (it = addr; it; it = it->ai_next)",
          "70:     {",
          "71:         if (max_socks == 0)",
          "72:             break;",
          "73:         sock = socket(it->ai_family, it->ai_socktype, it->ai_protocol);",
          "74:         if (sock < 0)",
          "75:             goto fail;",
          "76:         if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) < 0)",
          "77:             goto fail;",
          "78:         if (bind(sock, it->ai_addr, it->ai_addrlen) < 0)",
          "79:             goto fail;",
          "80:         if (listen(sock, 10) < 0)",
          "81:             goto fail;",
          "82:         flags = fcntl(sock, F_GETFL, 0);",
          "83:         if (flags < 0)",
          "84:             goto fail;",
          "85:         if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0)",
          "86:             goto fail;",
          "88:         ++count;",
          "89:         --max_socks;",
          "90:         continue;",
          "91:     fail:",
          "92:         err = errno;",
          "93:         if (sock >= 0)",
          "94:             close(sock);",
          "95:     }",
          "96:     freeaddrinfo(addr);",
          "97:     if (count == 0)",
          "98:         fprintf(stderr, \"%s: bind_service(%s): %s\\n\", self, service,",
          "99:                 strerror(err));",
          "103: static int is_hexdigit(char c)",
          "105:     return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')",
          "106:            || (c >= 'A' && c <= 'F');",
          "109: static char hex2num(char c)",
          "111:     if (c >= '0' && c <= '9')",
          "112:         return c - '0';",
          "113:     if (c >= 'a' && c <= 'f')",
          "114:         return c - 'a' + 10;",
          "115:     if (c >= 'A' && c <= 'F')",
          "116:         return c - 'A' + 10;",
          "117:     return 0;",
          "120: static char num2hex(char c)",
          "122:     if (c < 10)",
          "123:         return '0' + c;",
          "124:     return 'a' + c - 10;",
          "127: static char hex2char(const char *s)",
          "129:     return 16 * hex2num(s[0]) + hex2num(s[1]);",
          "132: static void char2hex(char c, char *buf)",
          "134:     buf[0] = num2hex((c >> 4) & 0xf);",
          "135:     buf[1] = num2hex((c)&0xf);",
          "138: static char *url_decode(char *buf, size_t len, const char *input)",
          "140:     char *output = buf;",
          "141:     if (!input || !output || len == 0)",
          "142:         return NULL;",
          "144:     while (*input && --len)",
          "145:     {",
          "146:         if (*input == '%')",
          "147:         {",
          "148:             if (is_hexdigit(input[1]) && is_hexdigit(input[2]))",
          "149:             {",
          "151:                 input += 2;",
          "152:             }",
          "153:             else",
          "154:             {",
          "155:                 return 0;",
          "156:             }",
          "157:         }",
          "158:         else",
          "159:         {",
          "161:         }",
          "164:     return buf;",
          "167: static char *url_encode(char *buf, size_t len, const char *input)",
          "169:     char *output = buf;",
          "170:     if (!input || !output || len == 0)",
          "171:         return NULL;",
          "172:     while (*input && --len)",
          "173:     {",
          "174:         if (!isascii(*input) || !isgraph(*input) || *input == '%')",
          "175:         {",
          "176:             if (len <= 2)",
          "177:                 break;",
          "179:             char2hex(*input++, output);",
          "180:             output += 2;",
          "181:             len -= 2;",
          "182:         }",
          "183:         else",
          "184:         {",
          "186:         }",
          "189:     return buf;",
          "192: static void handle_forward(srs_t *srs, FILE *fp, const char *address,",
          "193:                            const char *domain, const char **excludes)",
          "195:     int result;",
          "196:     size_t addrlen;",
          "197:     char value[1024];",
          "198:     char outputbuf[1024], *output;",
          "200:     addrlen = strlen(address);",
          "201:     for (; *excludes; excludes++)",
          "202:     {",
          "203:         size_t len;",
          "204:         len = strlen(*excludes);",
          "205:         if (len >= addrlen)",
          "206:             continue;",
          "207:         if (strcasecmp(*excludes, &address[addrlen - len]) == 0",
          "208:             && (**excludes == '.' || address[addrlen - len - 1] == '@'))",
          "209:         {",
          "210:             syslog(LOG_MAIL | LOG_INFO,",
          "211:                    \"srs_forward: <%s> not rewritten: Domain excluded by policy\",",
          "212:                    address);",
          "213:             fputs(\"500 Domain excluded py policy\\n\", fp);",
          "214:             fflush(fp);",
          "215:             return;",
          "216:         }",
          "218:     if (srs_reverse(srs, value, sizeof(value), address) == SRS_SUCCESS)",
          "219:     {",
          "220:         fprintf(fp, \"500 Already rewritten\\n\");",
          "221:         fflush(fp);",
          "222:         syslog(LOG_MAIL | LOG_NOTICE,",
          "223:                \"srs_forward: <%s> not rewritten: Valid SRS address for <%s>\",",
          "224:                address, value);",
          "225:         return;",
          "226:     }",
          "227:     result = srs_forward(srs, value, sizeof(value), address, domain);",
          "228:     if (result == SRS_SUCCESS)",
          "229:     {",
          "230:         output = url_encode(outputbuf, sizeof(outputbuf), value);",
          "231:         fprintf(fp, \"200 %s\\n\", output);",
          "232:         if (strcmp(address, value) != 0)",
          "233:             syslog(LOG_MAIL | LOG_INFO, \"srs_forward: <%s> rewritten as <%s>\",",
          "234:                    address, value);",
          "235:     }",
          "236:     else",
          "237:     {",
          "238:         fprintf(fp, \"500 %s\\n\", srs_strerror(result));",
          "239:         if (result != SRS_ENOTREWRITTEN)",
          "240:             syslog(LOG_MAIL | LOG_INFO, \"srs_forward: <%s> not rewritten: %s\",",
          "241:                    address, srs_strerror(result));",
          "242:     }",
          "243:     fflush(fp);",
          "246: static void handle_reverse(srs_t *srs, FILE *fp, const char *address,",
          "247:                            const char *domain __attribute__((unused)),",
          "248:                            const char **excludes __attribute__((unused)))",
          "250:     int result;",
          "251:     char value[1024];",
          "252:     char outputbuf[1024], *output;",
          "253:     result = srs_reverse(srs, value, sizeof(value), address);",
          "254:     if (result == SRS_SUCCESS)",
          "255:     {",
          "256:         output = url_encode(outputbuf, sizeof(outputbuf), value);",
          "257:         fprintf(fp, \"200 %s\\n\", output);",
          "258:         syslog(LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> rewritten as <%s>\",",
          "259:                address, value);",
          "260:     }",
          "261:     else",
          "262:     {",
          "263:         fprintf(fp, \"500 %s\\n\", srs_strerror(result));",
          "264:         if (result != SRS_ENOTREWRITTEN && result != SRS_ENOTSRSADDRESS)",
          "265:             syslog(LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> not rewritten: %s\",",
          "266:                    address, srs_strerror(result));",
          "267:     }",
          "268:     fflush(fp);",
          "271: static void show_help()",
          "273:     fprintf(",
          "274:         stdout,",
          "275:         \"Sender Rewriting Scheme implementation for Postfix.\\n\\n\"",
          "276:         \"Implements two TCP lookup tables to rewrite mail addresses\\n\"",
          "277:         \"as needed. The forward SRS is for sender envelope addresses\\n\"",
          "278:         \"to prevent SPF-related bounces. The reverse SRS is for\\n\"",
          "279:         \"recipient envelope addresses so that bounced mails can be\\n\"",
          "280:         \"routed back to their original sender.\\n\"",
          "281:         \"\\n\"",
          "282:         \"Usage: %s -s<file> -d<domain> [other options]\\n\"",
          "283:         \"Options:\\n\"",
          "284:         \"   -s<file>       read secrets from file (required)\\n\"",
          "285:         \"   -d<domain>     set domain name for rewrite (required)\\n\"",
          "286:         \"   -a<char>       set first separator character which can be one of: \"",
          "287:         \"-=+ (default: =)\\n\"",
          "288:         \"   -n<num>        length of hash to be used in rewritten addresses \"",
          "289:         \"(default: 4)\\n\"",
          "290:         \"   -N<num>        minimum length of hash to accept for validation \"",
          "291:         \"(default: 4)\\n\"",
          "292:         \"   -l<addr>       set socket listen address (default: 127.0.0.1)\\n\"",
          "293:         \"   -f<port>       set port for the forward SRS lookup (default: \"",
          "294:         \"10001)\\n\"",
          "295:         \"   -r<port>       set port for the reverse SRS lookup (default: \"",
          "296:         \"10002)\\n\"",
          "297:         \"   -p<pidfile>    write process ID to pidfile (default: none)\\n\"",
          "298:         \"   -c<dir>        chroot to <dir> (default: none)\\n\"",
          "299:         \"   -u<user>       switch user id after port bind (default: none)\\n\"",
          "300:         \"   -t<seconds>    timeout for idle client connections (default: \"",
          "301:         \"1800)\\n\"",
          "302:         \"   -X<domain>     exclude additional domain from address rewriting\\n\"",
          "303:         \"   -A             always rewrite addresses\\n\"",
          "304:         \"   -e             attempt to read above parameters from environment\\n\"",
          "305:         \"   -D             fork into background\\n\"",
          "306:         \"   -4             force IPv4 socket (default: any)\\n\"",
          "307:         \"   -6             force IPv6 socket (default: any)\\n\"",
          "308:         \"   -h             show this help\\n\"",
          "309:         \"   -v             show version\\n\"",
          "310:         \"\\n\",",
          "311:         self);",
          "314: typedef void (*handle_t)(srs_t *, FILE *, const char *, const char *,",
          "315:                          const char **);",
          "317: int main(int argc, char **argv)",
          "319:     int opt, timeout = 1800, family = AF_UNSPEC, hashlength = 0, hashmin = 0;",
          "320:     int daemonize = FALSE, always_rewrite = FALSE;",
          "321:     char *listen_addr = NULL, *forward_service = NULL, *reverse_service = NULL,",
          "323:     char separator = '=';",
          "324:     char *secret_file = NULL, *pid_file = NULL;",
          "325:     FILE *pf = NULL, *sf = NULL;",
          "326:     struct passwd *pwd = NULL;",
          "327:     char secretbuf[1024], *secret = NULL;",
          "328:     char *tmp;",
          "329:     time_t now;",
          "330:     srs_t *srs;",
          "331:     const char **excludes;",
          "332:     size_t s1 = 0, s2 = 1;",
          "333:     struct pollfd fds[4];",
          "334:     size_t socket_count = 0, sc;",
          "335:     int sockets[4] = {-1, -1, -1, -1};",
          "336:     handle_t handler[4] = {0, 0, 0, 0};",
          "337:     int fd, maxfd;",
          "339:     excludes = (const char **)calloc(1, sizeof(char *));",
          "340:     tmp = strrchr(argv[0], '/');",
          "341:     if (tmp)",
          "342:         self = strdup(tmp + 1);",
          "343:     else",
          "344:         self = strdup(argv[0]);",
          "346:     while ((opt = getopt(argc, argv, \"46d:a:l:f:r:s:n:N:u:t:p:c:X::ADhev\"))",
          "347:            != -1)",
          "348:     {",
          "349:         switch (opt)",
          "350:         {",
          "351:             case '?':",
          "353:             case '4':",
          "354:                 family = AF_INET;",
          "355:                 break;",
          "356:             case '6':",
          "357:                 family = AF_INET6;",
          "358:                 break;",
          "359:             case 'd':",
          "360:                 domain = strdup(optarg);",
          "361:                 break;",
          "362:             case 'a':",
          "363:                 separator = *optarg;",
          "364:                 break;",
          "365:             case 'l':",
          "366:                 listen_addr = strdup(optarg);",
          "367:                 break;",
          "368:             case 'f':",
          "369:                 forward_service = strdup(optarg);",
          "370:                 break;",
          "371:             case 'r':",
          "372:                 reverse_service = strdup(optarg);",
          "373:                 break;",
          "374:             case 't':",
          "375:                 timeout = atoi(optarg);",
          "376:                 break;",
          "377:             case 's':",
          "378:                 secret_file = strdup(optarg);",
          "379:                 break;",
          "380:             case 'n':",
          "381:                 hashlength = atoi(optarg);",
          "382:                 break;",
          "383:             case 'N':",
          "384:                 hashmin = atoi(optarg);",
          "385:                 break;",
          "386:             case 'p':",
          "387:                 pid_file = strdup(optarg);",
          "388:                 break;",
          "389:             case 'u':",
          "390:                 user = strdup(optarg);",
          "391:                 break;",
          "392:             case 'c':",
          "393:                 chroot_dir = strdup(optarg);",
          "394:                 break;",
          "395:             case 'D':",
          "396:                 daemonize = TRUE;",
          "397:                 break;",
          "398:             case 'A':",
          "399:                 always_rewrite = TRUE;",
          "400:                 break;",
          "401:             case 'h':",
          "402:                 show_help();",
          "403:                 return EXIT_SUCCESS;",
          "404:             case 'X':",
          "405:                 if (optarg != NULL)",
          "406:                 {",
          "407:                     tmp = strtok(optarg, \",; \\t\\r\\n\");",
          "408:                     while (tmp)",
          "409:                     {",
          "410:                         if (s1 + 1 >= s2)",
          "411:                         {",
          "412:                             s2 *= 2;",
          "413:                             excludes = (const char **)realloc(",
          "414:                                 excludes, s2 * sizeof(char *));",
          "415:                             if (excludes == NULL)",
          "416:                             {",
          "417:                                 fprintf(stderr, \"%s: Out of memory\\n\\n\", self);",
          "418:                                 return EXIT_FAILURE;",
          "419:                             }",
          "420:                         }",
          "421:                         excludes[s1++] = strdup(tmp);",
          "422:                         tmp = strtok(NULL, \",; \\t\\r\\n\");",
          "423:                     }",
          "424:                     excludes[s1] = NULL;",
          "425:                 }",
          "426:                 break;",
          "427:             case 'e':",
          "428:                 if (getenv(\"SRS_DOMAIN\") != NULL)",
          "429:                     domain = strdup(getenv(\"SRS_DOMAIN\"));",
          "430:                 if (getenv(\"SRS_SEPARATOR\") != NULL)",
          "431:                     separator = *getenv(\"SRS_SEPARATOR\");",
          "432:                 if (getenv(\"SRS_HASHLENGTH\") != NULL)",
          "433:                     hashlength = atoi(getenv(\"SRS_HASHLENGTH\"));",
          "434:                 if (getenv(\"SRS_HASHMIN\") != NULL)",
          "435:                     hashmin = atoi(getenv(\"SRS_HASHMIN\"));",
          "436:                 if (getenv(\"SRS_FORWARD_PORT\") != NULL)",
          "437:                     forward_service = strdup(getenv(\"SRS_FORWARD_PORT\"));",
          "438:                 if (getenv(\"SRS_REVERSE_PORT\") != NULL)",
          "439:                     reverse_service = strdup(getenv(\"SRS_REVERSE_PORT\"));",
          "440:                 if (getenv(\"SRS_TIMEOUT\") != NULL)",
          "441:                     timeout = atoi(getenv(\"SRS_TIMEOUT\"));",
          "442:                 if (getenv(\"SRS_SECRET\") != NULL)",
          "443:                     secret_file = strdup(getenv(\"SRS_SECRET\"));",
          "444:                 if (getenv(\"SRS_PID_FILE\") != NULL)",
          "445:                     pid_file = strdup(getenv(\"SRS_PID_FILE\"));",
          "446:                 if (getenv(\"RUN_AS\") != NULL)",
          "447:                     user = strdup(getenv(\"RUN_AS\"));",
          "448:                 if (getenv(\"CHROOT\") != NULL)",
          "449:                     chroot_dir = strdup(getenv(\"CHROOT\"));",
          "450:                 if (getenv(\"SRS_EXCLUDE_DOMAINS\") != NULL)",
          "451:                 {",
          "452:                     tmp = strtok(getenv(\"SRS_EXCLUDE_DOMAINS\"), \",; \\t\\r\\n\");",
          "453:                     while (tmp)",
          "454:                     {",
          "455:                         if (s1 + 1 >= s2)",
          "456:                         {",
          "457:                             s2 *= 2;",
          "458:                             excludes = (const char **)realloc(",
          "459:                                 excludes, s2 * sizeof(char *));",
          "460:                             if (excludes == NULL)",
          "461:                             {",
          "462:                                 fprintf(stderr, \"%s: Out of memory\\n\\n\", self);",
          "463:                                 return EXIT_FAILURE;",
          "464:                             }",
          "465:                         }",
          "466:                         excludes[s1++] = strdup(tmp);",
          "467:                         tmp = strtok(NULL, \",; \\t\\r\\n\");",
          "468:                     }",
          "469:                     excludes[s1] = NULL;",
          "470:                 }",
          "471:                 break;",
          "472:             case 'v':",
          "473:                 fprintf(stdout, \"%s\\n\", POSTSRSD_VERSION);",
          "474:                 return EXIT_SUCCESS;",
          "476:     }",
          "477:     if (optind < argc)",
          "478:     {",
          "479:         fprintf(stderr, \"%s: extra argument on command line: %s\\n\", self,",
          "480:                 argv[optind]);",
          "481:         return EXIT_FAILURE;",
          "482:     }",
          "483:     if (domain == NULL || *domain == 0)",
          "484:     {",
          "485:         fprintf(stderr, \"%s: You must set a home domain (-d)\\n\", self);",
          "486:         return EXIT_FAILURE;",
          "487:     }",
          "489:     if (separator != '=' && separator != '+' && separator != '-')",
          "490:     {",
          "491:         fprintf(stderr, \"%s: SRS separator character must be one of '=+-'\\n\",",
          "492:                 self);",
          "493:         return EXIT_FAILURE;",
          "494:     }",
          "495:     if (forward_service == NULL)",
          "496:         forward_service = strdup(\"10001\");",
          "497:     if (reverse_service == NULL)",
          "498:         reverse_service = strdup(\"10002\");",
          "501:     maxfd = sysconf(_SC_OPEN_MAX);",
          "502:     for (fd = 3; fd < maxfd; fd++)",
          "503:         close(fd);",
          "509:     if (pid_file)",
          "510:     {",
          "511:         pf = fopen(pid_file, \"w\");",
          "512:         if (pf == NULL)",
          "513:         {",
          "514:             fprintf(stderr, \"%s: Cannot write PID: %s\\n\\n\", self, pid_file);",
          "515:             return EXIT_FAILURE;",
          "519:     if (secret_file != NULL)",
          "520:     {",
          "521:         sf = fopen(secret_file, \"rb\");",
          "522:         if (sf == NULL)",
          "523:         {",
          "524:             fprintf(stderr, \"%s: Cannot open file with secret: %s\\n\", self,",
          "525:                     secret_file);",
          "526:             return EXIT_FAILURE;",
          "527:         }",
          "529:     else",
          "530:     {",
          "531:         fprintf(stderr, \"%s: You must set a secret (-s)\\n\", self);",
          "532:         return EXIT_FAILURE;",
          "536:     sc = bind_service(listen_addr, forward_service, family,",
          "537:                       &sockets[socket_count], 4 - socket_count);",
          "538:     if (sc == 0)",
          "539:         return EXIT_FAILURE;",
          "540:     while (sc-- > 0)",
          "541:         handler[socket_count++] = handle_forward;",
          "542:     free(forward_service);",
          "543:     sc = bind_service(listen_addr, reverse_service, family,",
          "544:                       &sockets[socket_count], 4 - socket_count);",
          "545:     if (sc == 0)",
          "546:         return EXIT_FAILURE;",
          "547:     while (sc-- > 0)",
          "548:         handler[socket_count++] = handle_reverse;",
          "549:     free(reverse_service);",
          "552:     openlog(self, LOG_PID | LOG_NDELAY, LOG_MAIL);",
          "554:     now = time(NULL);",
          "555:     localtime(&now);",
          "558:     if (user)",
          "559:     {",
          "560:         errno = 0;",
          "561:         pwd = getpwnam(user);",
          "562:         if (pwd == NULL)",
          "563:         {",
          "564:             if (errno != 0)",
          "565:                 fprintf(stderr, \"%s: Failed to lookup user: %s\\n\", self,",
          "566:                         strerror(errno));",
          "567:             else",
          "568:                 fprintf(stderr, \"%s: No such user: %s\\n\", self, user);",
          "569:             return EXIT_FAILURE;",
          "570:         }",
          "573:     if (chroot_dir)",
          "574:     {",
          "575:         if (chdir(chroot_dir) < 0)",
          "576:         {",
          "577:             fprintf(stderr, \"%s: Cannot change to chroot: %s\\n\", self,",
          "578:                     strerror(errno));",
          "579:             return EXIT_FAILURE;",
          "580:         }",
          "581:         if (chroot(chroot_dir) < 0)",
          "582:         {",
          "583:             fprintf(stderr, \"%s: Failed to enable chroot: %s\\n\", self,",
          "584:                     strerror(errno));",
          "585:             return EXIT_FAILURE;",
          "586:         }",
          "589:     if (pwd)",
          "590:     {",
          "591:         if (setgid(pwd->pw_gid) < 0)",
          "592:         {",
          "593:             fprintf(stderr, \"%s: Failed to switch group id: %s\\n\", self,",
          "594:                     strerror(errno));",
          "595:             return EXIT_FAILURE;",
          "596:         }",
          "597:         if (setuid(pwd->pw_uid) < 0)",
          "598:         {",
          "599:             fprintf(stderr, \"%s: Failed to switch user id: %s\\n\", self,",
          "600:                     strerror(errno));",
          "601:             return EXIT_FAILURE;",
          "602:         }",
          "606:     if (daemonize)",
          "607:     {",
          "608:         close(0);",
          "609:         close(1);",
          "610:         close(2);",
          "611:         if (fork() != 0)",
          "612:             return EXIT_SUCCESS;",
          "613:         setsid();",
          "614:         if (fork() != 0)",
          "615:             return EXIT_SUCCESS;",
          "618:     if (pf)",
          "619:     {",
          "620:         fprintf(pf, \"%d\", (int)getpid());",
          "621:         fclose(pf);",
          "624:     srs = srs_new();",
          "625:     while ((secret = fgets(secretbuf, sizeof(secretbuf), sf)))",
          "626:     {",
          "627:         secret = strtok(secret, \"\\r\\n\");",
          "628:         if (secret)",
          "629:             srs_add_secret(srs, secret);",
          "631:     fclose(sf);",
          "633:     srs_set_alwaysrewrite(srs, always_rewrite);",
          "634:     srs_set_separator(srs, separator);",
          "635:     if (hashlength)",
          "636:         srs_set_hashlength(srs, hashlength);",
          "637:     if (hashmin)",
          "638:         srs_set_hashmin(srs, hashmin);",
          "640:     for (sc = 0; sc < socket_count; ++sc)",
          "641:     {",
          "642:         fds[sc].fd = sockets[sc];",
          "643:         fds[sc].events = POLLIN;",
          "644:     }",
          "645:     while (TRUE)",
          "646:     {",
          "647:         int conn;",
          "648:         FILE *fp;",
          "649:         char linebuf[1024], *line;",
          "650:         char keybuf[1024], *key;",
          "652:         if (poll(fds, socket_count, 1000) < 0)",
          "653:         {",
          "654:             if (errno == EINTR)",
          "655:                 continue;",
          "656:             if (daemonize)",
          "657:                 syslog(LOG_MAIL | LOG_ERR, \"Poll failure: %s\", strerror(errno));",
          "658:             else",
          "659:                 fprintf(stderr, \"%s: Poll failure: %s\\n\", self,",
          "660:                         strerror(errno));",
          "661:             return EXIT_FAILURE;",
          "662:         }",
          "663:         for (sc = 0; sc < socket_count; ++sc)",
          "664:         {",
          "665:             if (fds[sc].revents)",
          "666:             {",
          "667:                 conn = accept(fds[sc].fd, NULL, NULL);",
          "668:                 if (conn < 0)",
          "669:                     continue;",
          "670:                 if (fork() == 0)",
          "671:                 {",
          "672:                     int i;",
          "675:                     for (i = 0; i < socket_count; ++i)",
          "676:                         close(sockets[i]);",
          "678:                     fp = fdopen(conn, \"r+\");",
          "679:                     if (fp == NULL)",
          "680:                         exit(EXIT_FAILURE);",
          "681:                     fds[0].fd = conn;",
          "682:                     fds[0].events = POLLIN;",
          "683:                     if (poll(fds, 1, timeout * 1000) <= 0)",
          "684:                         return EXIT_FAILURE;",
          "685:                     line = fgets(linebuf, sizeof(linebuf), fp);",
          "686:                     while (line)",
          "687:                     {",
          "689:                         char *token;",
          "690:                         token = strtok(line, \" \\r\\n\");",
          "691:                         if (token == NULL || strcmp(token, \"get\") != 0)",
          "692:                         {",
          "693:                             fprintf(fp, \"500 Invalid request\\n\");",
          "694:                             fflush(fp);",
          "695:                             return EXIT_FAILURE;",
          "696:                         }",
          "697:                         token = strtok(NULL, \"\\r\\n\");",
          "698:                         if (!token)",
          "699:                         {",
          "700:                             fprintf(fp, \"500 Invalid request\\n\");",
          "701:                             fflush(fp);",
          "702:                             return EXIT_FAILURE;",
          "703:                         }",
          "704:                         key = url_decode(keybuf, sizeof(keybuf), token);",
          "705:                         if (!key)",
          "706:                         {",
          "707:                             fprintf(fp, \"500 Invalid request\\n\");",
          "708:                             fflush(fp);",
          "709:                             return EXIT_FAILURE;",
          "710:                         }",
          "711:                         handler[sc](srs, fp, key, domain, excludes);",
          "712:                         fflush(fp);",
          "713:                         if (poll(fds, 1, timeout * 1000) <= 0)",
          "714:                             break;",
          "715:                         line = fgets(linebuf, sizeof(linebuf), fp);",
          "716:                     }",
          "717:                     fclose(fp);",
          "718:                     return EXIT_SUCCESS;",
          "719:                 }",
          "720:                 close(conn);",
          "723:         waitpid(-1, NULL, WNOHANG);",
          "725:     return EXIT_SUCCESS;",
          "",
          "---------------"
        ],
        "sha1.c||sha1.c": [
          "File: sha1.c -> sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"srs2.h\"",
          "26: #ifdef SIZEOF_UNSIGNED_LONG",
          "30: #endif",
          "32: #if SIZEOF_UNSIGNED_LONG == 4",
          "38: #elif SIZEOF_UNSIGNED_LONG == 8",
          "44: #else",
          "46: #endif",
          "",
          "[Removed Lines]",
          "18: #include <stdarg.h>",
          "27: #if SIZEOF_UNSIGNED_LONG < 4",
          "28: #error \"SHA1 requires an unsigned long of at least 32 bits\"",
          "29: #endif",
          "33: #  ifdef WORDS_BIGENDIAN",
          "34: #    define BYTEORDER 0x4321",
          "35: #  else",
          "36: #    define BYTEORDER 0x1234",
          "37: #  endif",
          "39: #  ifdef WORDS_BIGENDIAN",
          "40: #    define BYTEORDER 0x87654321",
          "41: #  else",
          "42: #    define BYTEORDER 0x12345678",
          "43: #  endif",
          "45: #  error \"SHA1 requires an unsigned long of either 4 or 8 bytes\"",
          "",
          "[Added Lines]",
          "20: #include <stdarg.h>",
          "27: #    if SIZEOF_UNSIGNED_LONG < 4",
          "28: #        error \"SHA1 requires an unsigned long of at least 32 bits\"",
          "29: #    endif",
          "33: #    ifdef WORDS_BIGENDIAN",
          "34: #        define BYTEORDER 0x4321",
          "35: #    else",
          "36: #        define BYTEORDER 0x1234",
          "37: #    endif",
          "39: #    ifdef WORDS_BIGENDIAN",
          "40: #        define BYTEORDER 0x87654321",
          "41: #    else",
          "42: #        define BYTEORDER 0x12345678",
          "43: #    endif",
          "45: #    error \"SHA1 requires an unsigned long of either 4 or 8 bytes\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99: static void sha_transform(SHA_INFO *sha_info)",
          "100: {",
          "108: the following makes sure that at least one code block below is",
          "",
          "[Removed Lines]",
          "57: #define f1(x,y,z)  ((x & y) | (~x & z))",
          "58: #define f2(x,y,z)  (x ^ y ^ z)",
          "59: #define f3(x,y,z)  ((x & y) | (x & z) | (y & z))",
          "60: #define f4(x,y,z)  (x ^ y ^ z)",
          "63: #define CONST1    0x5a827999L",
          "64: #define CONST2    0x6ed9eba1L",
          "65: #define CONST3    0x8f1bbcdcL",
          "66: #define CONST4    0xca62c1d6L",
          "69: #define T32(x)  ((x) & 0xffffffffL)",
          "72: #define R32(x,n)  T32(((x << n) | (x >> (32 - n))))",
          "75: #define FG(n)  \\",
          "76:  T = T32(R32(A,5) + f##n(B,C,D) + E + *WP++ + CONST##n);  \\",
          "77:  E = D; D = C; C = R32(B,30); B = A; A = T",
          "80: #define FA(n)  \\",
          "81:  T = T32(R32(A,5) + f##n(B,C,D) + E + *WP++ + CONST##n); B = R32(B,30)",
          "83: #define FB(n)  \\",
          "84:  E = T32(R32(T,5) + f##n(A,B,C) + D + *WP++ + CONST##n); A = R32(A,30)",
          "86: #define FC(n)  \\",
          "87:  D = T32(R32(E,5) + f##n(T,A,B) + C + *WP++ + CONST##n); T = R32(T,30)",
          "89: #define FD(n)  \\",
          "90:  C = T32(R32(D,5) + f##n(E,T,A) + B + *WP++ + CONST##n); E = R32(E,30)",
          "92: #define FE(n)  \\",
          "93:  B = T32(R32(C,5) + f##n(D,E,T) + A + *WP++ + CONST##n); D = R32(D,30)",
          "95: #define FT(n)  \\",
          "96:  A = T32(R32(B,5) + f##n(C,D,E) + T + *WP++ + CONST##n); C = R32(C,30)",
          "101:  int i;",
          "102:  sha_byte *dp;",
          "103:  ULONG T, A, B, C, D, E, W[80], *WP;",
          "105:  dp = sha_info->data;",
          "",
          "[Added Lines]",
          "57: #define f1(x, y, z) ((x & y) | (~x & z))",
          "58: #define f2(x, y, z) (x ^ y ^ z)",
          "59: #define f3(x, y, z) ((x & y) | (x & z) | (y & z))",
          "60: #define f4(x, y, z) (x ^ y ^ z)",
          "63: #define CONST1 0x5a827999L",
          "64: #define CONST2 0x6ed9eba1L",
          "65: #define CONST3 0x8f1bbcdcL",
          "66: #define CONST4 0xca62c1d6L",
          "69: #define T32(x) ((x)&0xffffffffL)",
          "72: #define R32(x, n) T32(((x << n) | (x >> (32 - n))))",
          "75: #define FG(n)                                                  \\",
          "76:     T = T32(R32(A, 5) + f##n(B, C, D) + E + *WP++ + CONST##n); \\",
          "77:     E = D;                                                     \\",
          "78:     D = C;                                                     \\",
          "79:     C = R32(B, 30);                                            \\",
          "80:     B = A;                                                     \\",
          "81:     A = T",
          "84: #define FA(n)                                                  \\",
          "85:     T = T32(R32(A, 5) + f##n(B, C, D) + E + *WP++ + CONST##n); \\",
          "86:     B = R32(B, 30)",
          "88: #define FB(n)                                                  \\",
          "89:     E = T32(R32(T, 5) + f##n(A, B, C) + D + *WP++ + CONST##n); \\",
          "90:     A = R32(A, 30)",
          "92: #define FC(n)                                                  \\",
          "93:     D = T32(R32(E, 5) + f##n(T, A, B) + C + *WP++ + CONST##n); \\",
          "94:     T = R32(T, 30)",
          "96: #define FD(n)                                                  \\",
          "97:     C = T32(R32(D, 5) + f##n(E, T, A) + B + *WP++ + CONST##n); \\",
          "98:     E = R32(E, 30)",
          "100: #define FE(n)                                                  \\",
          "101:     B = T32(R32(C, 5) + f##n(D, E, T) + A + *WP++ + CONST##n); \\",
          "102:     D = R32(D, 30)",
          "104: #define FT(n)                                                  \\",
          "105:     A = T32(R32(B, 5) + f##n(C, D, E) + T + *WP++ + CONST##n); \\",
          "106:     C = R32(C, 30)",
          "110:     int i;",
          "111:     sha_byte *dp;",
          "112:     ULONG T, A, B, C, D, E, W[80], *WP;",
          "114:     dp = sha_info->data;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113: #undef SWAP_DONE",
          "115: #if BYTEORDER == 0x1234",
          "124: #endif",
          "126: #if BYTEORDER == 0x4321",
          "134: #endif",
          "136: #if BYTEORDER == 0x12345678",
          "148: #endif",
          "150: #if BYTEORDER == 0x87654321",
          "159: #endif",
          "161: #ifndef SWAP_DONE",
          "167: #if (SHA_VERSION == 1)",
          "177: #ifdef UNRAVEL",
          "213: }",
          "219: {",
          "228: }",
          "234: {",
          "267: }",
          "272: {",
          "294: }",
          "299: {",
          "324: }",
          "347: {",
          "352: }",
          "356: {",
          "377: }",
          "381: {",
          "383: }",
          "387: {",
          "395: }",
          "",
          "[Removed Lines]",
          "116: #define SWAP_DONE",
          "118:  for (i = 0; i < 16; ++i) {",
          "119:   T = *((ULONG *) dp);",
          "120:   dp += 4;",
          "121:   W[i] =  ((T << 24) & 0xff000000) | ((T <<  8) & 0x00ff0000) |",
          "122:     ((T >>  8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);",
          "123:  }",
          "127: #define SWAP_DONE",
          "129:  for (i = 0; i < 16; ++i) {",
          "130:   T = *((ULONG *) dp);",
          "131:   dp += 4;",
          "132:   W[i] = T32(T);",
          "133:  }",
          "137: #define SWAP_DONE",
          "139:  for (i = 0; i < 16; i += 2) {",
          "140:   T = *((ULONG *) dp);",
          "141:   dp += 8;",
          "142:   W[i] =  ((T << 24) & 0xff000000) | ((T <<  8) & 0x00ff0000) |",
          "143:     ((T >>  8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);",
          "144:   T >>= 32;",
          "145:   W[i+1] = ((T << 24) & 0xff000000) | ((T <<  8) & 0x00ff0000) |",
          "146:      ((T >>  8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);",
          "147:  }",
          "151: #define SWAP_DONE",
          "153:  for (i = 0; i < 16; i += 2) {",
          "154:   T = *((ULONG *) dp);",
          "155:   dp += 8;",
          "156:   W[i] = T32(T >> 32);",
          "157:   W[i+1] = T32(T);",
          "158:  }",
          "162: #error Unknown byte order -- you need to add code here",
          "165:  for (i = 16; i < 80; ++i) {",
          "166:   W[i] = W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16];",
          "168:   W[i] = R32(W[i], 1);",
          "170:  }",
          "171:  A = sha_info->digest[0];",
          "172:  B = sha_info->digest[1];",
          "173:  C = sha_info->digest[2];",
          "174:  D = sha_info->digest[3];",
          "175:  E = sha_info->digest[4];",
          "176:  WP = W;",
          "178:  FA(1); FB(1); FC(1); FD(1); FE(1); FT(1); FA(1); FB(1); FC(1); FD(1);",
          "179:  FE(1); FT(1); FA(1); FB(1); FC(1); FD(1); FE(1); FT(1); FA(1); FB(1);",
          "180:  FC(2); FD(2); FE(2); FT(2); FA(2); FB(2); FC(2); FD(2); FE(2); FT(2);",
          "181:  FA(2); FB(2); FC(2); FD(2); FE(2); FT(2); FA(2); FB(2); FC(2); FD(2);",
          "182:  FE(3); FT(3); FA(3); FB(3); FC(3); FD(3); FE(3); FT(3); FA(3); FB(3);",
          "183:  FC(3); FD(3); FE(3); FT(3); FA(3); FB(3); FC(3); FD(3); FE(3); FT(3);",
          "184:  FA(4); FB(4); FC(4); FD(4); FE(4); FT(4); FA(4); FB(4); FC(4); FD(4);",
          "185:  FE(4); FT(4); FA(4); FB(4); FC(4); FD(4); FE(4); FT(4); FA(4); FB(4);",
          "186:  sha_info->digest[0] = T32(sha_info->digest[0] + E);",
          "187:  sha_info->digest[1] = T32(sha_info->digest[1] + T);",
          "188:  sha_info->digest[2] = T32(sha_info->digest[2] + A);",
          "189:  sha_info->digest[3] = T32(sha_info->digest[3] + B);",
          "190:  sha_info->digest[4] = T32(sha_info->digest[4] + C);",
          "192: #ifdef UNROLL_LOOPS",
          "193:  FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1);",
          "194:  FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1);",
          "195:  FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2);",
          "196:  FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2);",
          "197:  FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3);",
          "198:  FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3);",
          "199:  FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4);",
          "200:  FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4);",
          "202:  for (i =  0; i < 20; ++i) { FG(1); }",
          "203:  for (i = 20; i < 40; ++i) { FG(2); }",
          "204:  for (i = 40; i < 60; ++i) { FG(3); }",
          "205:  for (i = 60; i < 80; ++i) { FG(4); }",
          "207:  sha_info->digest[0] = T32(sha_info->digest[0] + A);",
          "208:  sha_info->digest[1] = T32(sha_info->digest[1] + B);",
          "209:  sha_info->digest[2] = T32(sha_info->digest[2] + C);",
          "210:  sha_info->digest[3] = T32(sha_info->digest[3] + D);",
          "211:  sha_info->digest[4] = T32(sha_info->digest[4] + E);",
          "217: static void",
          "218: sha_init(SHA_INFO *sha_info)",
          "220:  sha_info->digest[0] = 0x67452301L;",
          "221:  sha_info->digest[1] = 0xefcdab89L;",
          "222:  sha_info->digest[2] = 0x98badcfeL;",
          "223:  sha_info->digest[3] = 0x10325476L;",
          "224:  sha_info->digest[4] = 0xc3d2e1f0L;",
          "225:  sha_info->count_lo = 0L;",
          "226:  sha_info->count_hi = 0L;",
          "227:  sha_info->local = 0;",
          "232: static void",
          "233: sha_update(SHA_INFO *sha_info, sha_byte *buffer, int count)",
          "235:  int i;",
          "236:  ULONG clo;",
          "238:  clo = T32(sha_info->count_lo + ((ULONG) count << 3));",
          "239:  if (clo < sha_info->count_lo) {",
          "240:   ++sha_info->count_hi;",
          "241:  }",
          "242:  sha_info->count_lo = clo;",
          "243:  sha_info->count_hi += (ULONG) count >> 29;",
          "244:  if (sha_info->local) {",
          "245:   i = SHA_BLOCKSIZE - sha_info->local;",
          "246:   if (i > count) {",
          "247:    i = count;",
          "248:   }",
          "249:   memcpy(((sha_byte *) sha_info->data) + sha_info->local, buffer, i);",
          "250:   count -= i;",
          "251:   buffer += i;",
          "252:   sha_info->local += i;",
          "253:   if (sha_info->local == SHA_BLOCKSIZE) {",
          "254:    sha_transform(sha_info);",
          "255:   } else {",
          "256:    return;",
          "257:   }",
          "258:  }",
          "259:  while (count >= SHA_BLOCKSIZE) {",
          "260:   memcpy(sha_info->data, buffer, SHA_BLOCKSIZE);",
          "261:   buffer += SHA_BLOCKSIZE;",
          "262:   count -= SHA_BLOCKSIZE;",
          "263:   sha_transform(sha_info);",
          "264:  }",
          "265:  memcpy(sha_info->data, buffer, count);",
          "266:  sha_info->local = count;",
          "270: static void",
          "271: sha_transform_and_copy(unsigned char digest[20], SHA_INFO *sha_info)",
          "273:  sha_transform(sha_info);",
          "274:  digest[ 0] = (unsigned char) ((sha_info->digest[0] >> 24) & 0xff);",
          "275:  digest[ 1] = (unsigned char) ((sha_info->digest[0] >> 16) & 0xff);",
          "276:  digest[ 2] = (unsigned char) ((sha_info->digest[0] >>  8) & 0xff);",
          "277:  digest[ 3] = (unsigned char) ((sha_info->digest[0]      ) & 0xff);",
          "278:  digest[ 4] = (unsigned char) ((sha_info->digest[1] >> 24) & 0xff);",
          "279:  digest[ 5] = (unsigned char) ((sha_info->digest[1] >> 16) & 0xff);",
          "280:  digest[ 6] = (unsigned char) ((sha_info->digest[1] >>  8) & 0xff);",
          "281:  digest[ 7] = (unsigned char) ((sha_info->digest[1]      ) & 0xff);",
          "282:  digest[ 8] = (unsigned char) ((sha_info->digest[2] >> 24) & 0xff);",
          "283:  digest[ 9] = (unsigned char) ((sha_info->digest[2] >> 16) & 0xff);",
          "284:  digest[10] = (unsigned char) ((sha_info->digest[2] >>  8) & 0xff);",
          "285:  digest[11] = (unsigned char) ((sha_info->digest[2]      ) & 0xff);",
          "286:  digest[12] = (unsigned char) ((sha_info->digest[3] >> 24) & 0xff);",
          "287:  digest[13] = (unsigned char) ((sha_info->digest[3] >> 16) & 0xff);",
          "288:  digest[14] = (unsigned char) ((sha_info->digest[3] >>  8) & 0xff);",
          "289:  digest[15] = (unsigned char) ((sha_info->digest[3]      ) & 0xff);",
          "290:  digest[16] = (unsigned char) ((sha_info->digest[4] >> 24) & 0xff);",
          "291:  digest[17] = (unsigned char) ((sha_info->digest[4] >> 16) & 0xff);",
          "292:  digest[18] = (unsigned char) ((sha_info->digest[4] >>  8) & 0xff);",
          "293:  digest[19] = (unsigned char) ((sha_info->digest[4]      ) & 0xff);",
          "297: static void",
          "298: sha_final(unsigned char digest[20], SHA_INFO *sha_info)",
          "300:  int count;",
          "301:  ULONG lo_bit_count, hi_bit_count;",
          "303:  lo_bit_count = sha_info->count_lo;",
          "304:  hi_bit_count = sha_info->count_hi;",
          "305:  count = (int) ((lo_bit_count >> 3) & 0x3f);",
          "306:  ((sha_byte *) sha_info->data)[count++] = 0x80;",
          "307:  if (count > SHA_BLOCKSIZE - 8) {",
          "308:   memset(((sha_byte *) sha_info->data) + count, 0, SHA_BLOCKSIZE - count);",
          "309:   sha_transform(sha_info);",
          "310:   memset((sha_byte *) sha_info->data, 0, SHA_BLOCKSIZE - 8);",
          "311:  } else {",
          "312:   memset(((sha_byte *) sha_info->data) + count, 0,",
          "313:    SHA_BLOCKSIZE - 8 - count);",
          "314:  }",
          "315:  sha_info->data[56] = (hi_bit_count >> 24) & 0xff;",
          "316:  sha_info->data[57] = (hi_bit_count >> 16) & 0xff;",
          "317:  sha_info->data[58] = (hi_bit_count >>  8) & 0xff;",
          "318:  sha_info->data[59] = (hi_bit_count >>  0) & 0xff;",
          "319:  sha_info->data[60] = (lo_bit_count >> 24) & 0xff;",
          "320:  sha_info->data[61] = (lo_bit_count >> 16) & 0xff;",
          "321:  sha_info->data[62] = (lo_bit_count >>  8) & 0xff;",
          "322:  sha_info->data[63] = (lo_bit_count >>  0) & 0xff;",
          "323:  sha_transform_and_copy(digest, sha_info);",
          "331:   SHA_INFO ctx;",
          "332:   unsigned char *data;",
          "333:  STRLEN len;",
          "334:   unsigned char digeststr[20];",
          "336:   sha_init(&ctx);",
          "338:   for (i = 0; i < items; i++) {",
          "339:    data = (unsigned char *)(SvPVbyte(ST(i), len));",
          "340:    sha_update(&ctx, data, len);",
          "341:   }",
          "342:   sha_final(digeststr, &ctx);",
          "345: static void",
          "346: sha_digest(char *out, char *data, unsigned len)",
          "348:  SHA_INFO ctx;",
          "349:  sha_init(&ctx);",
          "350:  sha_update(&ctx, (sha_byte*)data, len);",
          "351:  sha_final((sha_byte*)out, &ctx);",
          "354: void",
          "355: srs_hmac_init(srs_hmac_ctx_t *ctx, char *secret, unsigned len)",
          "357:  char  sbuf[SHA_BLOCKSIZE];",
          "358:  unsigned   i;",
          "360:  if (len > SHA_BLOCKSIZE) {",
          "361:   sha_digest(sbuf, secret, len);",
          "362:   secret = sbuf;",
          "363:   len = SHA_DIGESTSIZE;",
          "364:  }",
          "366:  memset(ctx->ipad, 0x36, SHA_BLOCKSIZE);",
          "367:  memset(ctx->opad, 0x5c, SHA_BLOCKSIZE);",
          "368:  for (i = 0; i < len; i++) {",
          "369:   ctx->ipad[i] ^= secret[i];",
          "370:   ctx->opad[i] ^= secret[i];",
          "371:  }",
          "373:  memset(sbuf, 0, SHA_BLOCKSIZE);",
          "375:  sha_init(&ctx->sctx);",
          "376:  sha_update(&ctx->sctx, (sha_byte*)ctx->ipad, SHA_BLOCKSIZE);",
          "379: void",
          "380: srs_hmac_update(srs_hmac_ctx_t *ctx, char *data, unsigned len)",
          "382:  sha_update(&ctx->sctx, (sha_byte*)data, len);",
          "385: void",
          "386: srs_hmac_fini(srs_hmac_ctx_t *ctx, char *out)",
          "388:  sha_byte buf[SHA_DIGESTSIZE + 1];",
          "390:  sha_final(buf, &ctx->sctx);",
          "391:  sha_init(&ctx->sctx);",
          "392:  sha_update(&ctx->sctx, (sha_byte*)ctx->opad, SHA_BLOCKSIZE);",
          "393:  sha_update(&ctx->sctx, buf, SHA_DIGESTSIZE);",
          "394:  sha_final((sha_byte*)out, &ctx->sctx);",
          "",
          "[Added Lines]",
          "125: #    define SWAP_DONE",
          "127:     for (i = 0; i < 16; ++i)",
          "128:     {",
          "129:         T = *((ULONG *)dp);",
          "130:         dp += 4;",
          "131:         W[i] = ((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000)",
          "132:                | ((T >> 8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);",
          "133:     }",
          "137: #    define SWAP_DONE",
          "139:     for (i = 0; i < 16; ++i)",
          "140:     {",
          "141:         T = *((ULONG *)dp);",
          "142:         dp += 4;",
          "143:         W[i] = T32(T);",
          "144:     }",
          "148: #    define SWAP_DONE",
          "150:     for (i = 0; i < 16; i += 2)",
          "151:     {",
          "152:         T = *((ULONG *)dp);",
          "153:         dp += 8;",
          "154:         W[i] = ((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000)",
          "155:                | ((T >> 8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);",
          "156:         T >>= 32;",
          "157:         W[i + 1] = ((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000)",
          "158:                    | ((T >> 8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);",
          "159:     }",
          "163: #    define SWAP_DONE",
          "165:     for (i = 0; i < 16; i += 2)",
          "166:     {",
          "167:         T = *((ULONG *)dp);",
          "168:         dp += 8;",
          "169:         W[i] = T32(T >> 32);",
          "170:         W[i + 1] = T32(T);",
          "171:     }",
          "175: #    error Unknown byte order -- you need to add code here",
          "176: #endif",
          "178:     for (i = 16; i < 80; ++i)",
          "179:     {",
          "180:         W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];",
          "182:         W[i] = R32(W[i], 1);",
          "183: #endif",
          "184:     }",
          "185:     A = sha_info->digest[0];",
          "186:     B = sha_info->digest[1];",
          "187:     C = sha_info->digest[2];",
          "188:     D = sha_info->digest[3];",
          "189:     E = sha_info->digest[4];",
          "190:     WP = W;",
          "193:     FA(1); FB(1); FC(1); FD(1); FE(1); FT(1); FA(1); FB(1); FC(1); FD(1);",
          "194:     FE(1); FT(1); FA(1); FB(1); FC(1); FD(1); FE(1); FT(1); FA(1); FB(1);",
          "195:     FC(2); FD(2); FE(2); FT(2); FA(2); FB(2); FC(2); FD(2); FE(2); FT(2);",
          "196:     FA(2); FB(2); FC(2); FD(2); FE(2); FT(2); FA(2); FB(2); FC(2); FD(2);",
          "197:     FE(3); FT(3); FA(3); FB(3); FC(3); FD(3); FE(3); FT(3); FA(3); FB(3);",
          "198:     FC(3); FD(3); FE(3); FT(3); FA(3); FB(3); FC(3); FD(3); FE(3); FT(3);",
          "199:     FA(4); FB(4); FC(4); FD(4); FE(4); FT(4); FA(4); FB(4); FC(4); FD(4);",
          "200:     FE(4); FT(4); FA(4); FB(4); FC(4); FD(4); FE(4); FT(4); FA(4); FB(4);",
          "202:     sha_info->digest[0] = T32(sha_info->digest[0] + E);",
          "203:     sha_info->digest[1] = T32(sha_info->digest[1] + T);",
          "204:     sha_info->digest[2] = T32(sha_info->digest[2] + A);",
          "205:     sha_info->digest[3] = T32(sha_info->digest[3] + B);",
          "206:     sha_info->digest[4] = T32(sha_info->digest[4] + C);",
          "207: #else",
          "208: #    ifdef UNROLL_LOOPS",
          "210:     FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1);",
          "211:     FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1);",
          "212:     FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2);",
          "213:     FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2);",
          "214:     FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3);",
          "215:     FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3);",
          "216:     FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4);",
          "217:     FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4);",
          "219: #    else",
          "220:     for (i = 0; i < 20; ++i)",
          "221:     {",
          "222:         FG(1);",
          "223:     }",
          "224:     for (i = 20; i < 40; ++i)",
          "225:     {",
          "226:         FG(2);",
          "227:     }",
          "228:     for (i = 40; i < 60; ++i)",
          "229:     {",
          "230:         FG(3);",
          "231:     }",
          "232:     for (i = 60; i < 80; ++i)",
          "233:     {",
          "234:         FG(4);",
          "235:     }",
          "236: #    endif",
          "237:     sha_info->digest[0] = T32(sha_info->digest[0] + A);",
          "238:     sha_info->digest[1] = T32(sha_info->digest[1] + B);",
          "239:     sha_info->digest[2] = T32(sha_info->digest[2] + C);",
          "240:     sha_info->digest[3] = T32(sha_info->digest[3] + D);",
          "241:     sha_info->digest[4] = T32(sha_info->digest[4] + E);",
          "242: #endif",
          "247: static void sha_init(SHA_INFO *sha_info)",
          "249:     sha_info->digest[0] = 0x67452301L;",
          "250:     sha_info->digest[1] = 0xefcdab89L;",
          "251:     sha_info->digest[2] = 0x98badcfeL;",
          "252:     sha_info->digest[3] = 0x10325476L;",
          "253:     sha_info->digest[4] = 0xc3d2e1f0L;",
          "254:     sha_info->count_lo = 0L;",
          "255:     sha_info->count_hi = 0L;",
          "256:     sha_info->local = 0;",
          "261: static void sha_update(SHA_INFO *sha_info, sha_byte *buffer, int count)",
          "263:     int i;",
          "264:     ULONG clo;",
          "266:     clo = T32(sha_info->count_lo + ((ULONG)count << 3));",
          "267:     if (clo < sha_info->count_lo)",
          "268:     {",
          "269:         ++sha_info->count_hi;",
          "270:     }",
          "271:     sha_info->count_lo = clo;",
          "272:     sha_info->count_hi += (ULONG)count >> 29;",
          "273:     if (sha_info->local)",
          "274:     {",
          "275:         i = SHA_BLOCKSIZE - sha_info->local;",
          "276:         if (i > count)",
          "277:         {",
          "278:             i = count;",
          "279:         }",
          "280:         memcpy(((sha_byte *)sha_info->data) + sha_info->local, buffer, i);",
          "281:         count -= i;",
          "282:         buffer += i;",
          "283:         sha_info->local += i;",
          "284:         if (sha_info->local == SHA_BLOCKSIZE)",
          "285:         {",
          "286:             sha_transform(sha_info);",
          "287:         }",
          "288:         else",
          "289:         {",
          "290:             return;",
          "291:         }",
          "292:     }",
          "293:     while (count >= SHA_BLOCKSIZE)",
          "294:     {",
          "295:         memcpy(sha_info->data, buffer, SHA_BLOCKSIZE);",
          "296:         buffer += SHA_BLOCKSIZE;",
          "297:         count -= SHA_BLOCKSIZE;",
          "298:         sha_transform(sha_info);",
          "299:     }",
          "300:     memcpy(sha_info->data, buffer, count);",
          "301:     sha_info->local = count;",
          "304: static void sha_transform_and_copy(unsigned char digest[20], SHA_INFO *sha_info)",
          "306:     sha_transform(sha_info);",
          "307:     digest[0] = (unsigned char)((sha_info->digest[0] >> 24) & 0xff);",
          "308:     digest[1] = (unsigned char)((sha_info->digest[0] >> 16) & 0xff);",
          "309:     digest[2] = (unsigned char)((sha_info->digest[0] >> 8) & 0xff);",
          "310:     digest[3] = (unsigned char)((sha_info->digest[0]) & 0xff);",
          "311:     digest[4] = (unsigned char)((sha_info->digest[1] >> 24) & 0xff);",
          "312:     digest[5] = (unsigned char)((sha_info->digest[1] >> 16) & 0xff);",
          "313:     digest[6] = (unsigned char)((sha_info->digest[1] >> 8) & 0xff);",
          "314:     digest[7] = (unsigned char)((sha_info->digest[1]) & 0xff);",
          "315:     digest[8] = (unsigned char)((sha_info->digest[2] >> 24) & 0xff);",
          "316:     digest[9] = (unsigned char)((sha_info->digest[2] >> 16) & 0xff);",
          "317:     digest[10] = (unsigned char)((sha_info->digest[2] >> 8) & 0xff);",
          "318:     digest[11] = (unsigned char)((sha_info->digest[2]) & 0xff);",
          "319:     digest[12] = (unsigned char)((sha_info->digest[3] >> 24) & 0xff);",
          "320:     digest[13] = (unsigned char)((sha_info->digest[3] >> 16) & 0xff);",
          "321:     digest[14] = (unsigned char)((sha_info->digest[3] >> 8) & 0xff);",
          "322:     digest[15] = (unsigned char)((sha_info->digest[3]) & 0xff);",
          "323:     digest[16] = (unsigned char)((sha_info->digest[4] >> 24) & 0xff);",
          "324:     digest[17] = (unsigned char)((sha_info->digest[4] >> 16) & 0xff);",
          "325:     digest[18] = (unsigned char)((sha_info->digest[4] >> 8) & 0xff);",
          "326:     digest[19] = (unsigned char)((sha_info->digest[4]) & 0xff);",
          "330: static void sha_final(unsigned char digest[20], SHA_INFO *sha_info)",
          "332:     int count;",
          "333:     ULONG lo_bit_count, hi_bit_count;",
          "335:     lo_bit_count = sha_info->count_lo;",
          "336:     hi_bit_count = sha_info->count_hi;",
          "337:     count = (int)((lo_bit_count >> 3) & 0x3f);",
          "338:     ((sha_byte *)sha_info->data)[count++] = 0x80;",
          "339:     if (count > SHA_BLOCKSIZE - 8)",
          "340:     {",
          "341:         memset(((sha_byte *)sha_info->data) + count, 0, SHA_BLOCKSIZE - count);",
          "342:         sha_transform(sha_info);",
          "343:         memset((sha_byte *)sha_info->data, 0, SHA_BLOCKSIZE - 8);",
          "344:     }",
          "345:     else",
          "346:     {",
          "347:         memset(((sha_byte *)sha_info->data) + count, 0,",
          "348:                SHA_BLOCKSIZE - 8 - count);",
          "349:     }",
          "350:     sha_info->data[56] = (hi_bit_count >> 24) & 0xff;",
          "351:     sha_info->data[57] = (hi_bit_count >> 16) & 0xff;",
          "352:     sha_info->data[58] = (hi_bit_count >> 8) & 0xff;",
          "353:     sha_info->data[59] = (hi_bit_count >> 0) & 0xff;",
          "354:     sha_info->data[60] = (lo_bit_count >> 24) & 0xff;",
          "355:     sha_info->data[61] = (lo_bit_count >> 16) & 0xff;",
          "356:     sha_info->data[62] = (lo_bit_count >> 8) & 0xff;",
          "357:     sha_info->data[63] = (lo_bit_count >> 0) & 0xff;",
          "358:     sha_transform_and_copy(digest, sha_info);",
          "363:     SHA_INFO ctx;",
          "364:     unsigned char *data;",
          "365:     STRLEN len;",
          "366:     unsigned char digeststr[20];",
          "368:     sha_init(&ctx);",
          "370:     for (i = 0; i < items; i++) {",
          "371:             data = (unsigned char *)(SvPVbyte(ST(i), len));",
          "372:             sha_update(&ctx, data, len);",
          "373:     }",
          "374:     sha_final(digeststr, &ctx);",
          "377: static void sha_digest(char *out, char *data, unsigned len)",
          "379:     SHA_INFO ctx;",
          "380:     sha_init(&ctx);",
          "381:     sha_update(&ctx, (sha_byte *)data, len);",
          "382:     sha_final((sha_byte *)out, &ctx);",
          "385: void srs_hmac_init(srs_hmac_ctx_t *ctx, char *secret, unsigned len)",
          "387:     char sbuf[SHA_BLOCKSIZE];",
          "388:     unsigned i;",
          "390:     if (len > SHA_BLOCKSIZE)",
          "391:     {",
          "392:         sha_digest(sbuf, secret, len);",
          "393:         secret = sbuf;",
          "394:         len = SHA_DIGESTSIZE;",
          "395:     }",
          "397:     memset(ctx->ipad, 0x36, SHA_BLOCKSIZE);",
          "398:     memset(ctx->opad, 0x5c, SHA_BLOCKSIZE);",
          "399:     for (i = 0; i < len; i++)",
          "400:     {",
          "401:         ctx->ipad[i] ^= secret[i];",
          "402:         ctx->opad[i] ^= secret[i];",
          "403:     }",
          "405:     memset(sbuf, 0, SHA_BLOCKSIZE);",
          "407:     sha_init(&ctx->sctx);",
          "408:     sha_update(&ctx->sctx, (sha_byte *)ctx->ipad, SHA_BLOCKSIZE);",
          "411: void srs_hmac_update(srs_hmac_ctx_t *ctx, char *data, unsigned len)",
          "413:     sha_update(&ctx->sctx, (sha_byte *)data, len);",
          "416: void srs_hmac_fini(srs_hmac_ctx_t *ctx, char *out)",
          "418:     sha_byte buf[SHA_DIGESTSIZE + 1];",
          "420:     sha_final(buf, &ctx->sctx);",
          "421:     sha_init(&ctx->sctx);",
          "422:     sha_update(&ctx->sctx, (sha_byte *)ctx->opad, SHA_BLOCKSIZE);",
          "423:     sha_update(&ctx->sctx, buf, SHA_DIGESTSIZE);",
          "424:     sha_final((sha_byte *)out, &ctx->sctx);",
          "",
          "---------------"
        ],
        "srs2.c||srs2.c": [
          "File: srs2.c -> srs2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #undef USE_OPENSSL",
          "19: #include <stdarg.h>",
          "21: #ifdef HAVE_ALLOCA_H",
          "23: #endif",
          "25: #ifdef USE_OPENSSL",
          "27: #endif",
          "29: #include \"srs2.h\"",
          "32: #ifndef EVP_MAX_MD_SIZE",
          "34: #endif",
          "36: #ifndef HAVE_STRCASECMP",
          "40: #endif",
          "42: #ifndef HAVE_STRNCASECMP",
          "46: #endif",
          "49: #define STRINGP(s) ((s != NULL) && (*(s) != '\\0'))",
          "51: static const char *srs_separators = \"=-+\";",
          "59: {",
          "64: }",
          "68: {",
          "117: }",
          "121: {",
          "125: }",
          "129: {",
          "138: }",
          "142: {",
          "150: }",
          "154: {",
          "159: }",
          "163: {",
          "167: }",
          "180: {",
          "185: }",
          "189: {",
          "191: }",
          "193: SRS_PARAM_DEFINE(maxage, int)",
          "195: SRS_PARAM_DEFINE(hashlength, int)",
          "196: SRS_PARAM_DEFINE(hashmin, int)",
          "197: SRS_PARAM_DEFINE(alwaysrewrite, srs_bool)",
          "",
          "[Removed Lines]",
          "22: #include <alloca.h>",
          "26: #include <openssl/hmac.h>",
          "37: # ifdef HAVE__STRICMP",
          "38: #  define strcasecmp _stricmp",
          "39: # endif",
          "43: # ifdef HAVE__STRNICMP",
          "44: #  define strncasecmp _strnicmp",
          "45: # endif",
          "53: static srs_malloc_t  srs_f_malloc = malloc;",
          "54: static srs_realloc_t srs_f_realloc = realloc;",
          "55: static srs_free_t  srs_f_free  = free;",
          "57: int",
          "58: srs_set_malloc(srs_malloc_t m, srs_realloc_t r, srs_free_t f)",
          "60:  srs_f_malloc = m;",
          "61:  srs_f_realloc = r;",
          "62:  srs_f_free = f;",
          "63:  return SRS_SUCCESS;",
          "66: const char *",
          "67: srs_strerror(int code)",
          "69:  switch (code) {",
          "71:   case SRS_SUCCESS:",
          "72:    return \"Success\";",
          "73:   case SRS_ENOTSRSADDRESS:",
          "74:    return \"Not an SRS address.\";",
          "77:   case SRS_ENOSECRETS:",
          "78:    return \"No secrets in SRS configuration.\";",
          "79:   case SRS_ESEPARATORINVALID:",
          "80:    return \"Invalid separator suggested.\";",
          "83:   case SRS_ENOSENDERATSIGN:",
          "84:    return \"No at sign in sender address\";",
          "85:   case SRS_EBUFTOOSMALL:",
          "86:    return \"Buffer too small.\";",
          "89:   case SRS_ENOSRS0HOST:",
          "90:    return \"No host in SRS0 address.\";",
          "91:   case SRS_ENOSRS0USER:",
          "92:    return \"No user in SRS0 address.\";",
          "93:   case SRS_ENOSRS0HASH:",
          "94:    return \"No hash in SRS0 address.\";",
          "95:   case SRS_ENOSRS0STAMP:",
          "96:    return \"No timestamp in SRS0 address.\";",
          "97:   case SRS_ENOSRS1HOST:",
          "98:    return \"No host in SRS1 address.\";",
          "99:   case SRS_ENOSRS1USER:",
          "100:    return \"No user in SRS1 address.\";",
          "101:   case SRS_ENOSRS1HASH:",
          "102:    return \"No hash in SRS1 address.\";",
          "103:   case SRS_EBADTIMESTAMPCHAR:",
          "104:    return \"Bad base32 character in timestamp.\";",
          "105:   case SRS_EHASHTOOSHORT:",
          "106:    return \"Hash too short in SRS address.\";",
          "109:   case SRS_ETIMESTAMPOUTOFDATE:",
          "110:    return \"Time stamp out of date.\";",
          "111:   case SRS_EHASHINVALID:",
          "112:    return \"Hash invalid in SRS address.\";",
          "114:   default:",
          "115:    return \"Unknown error in SRS library.\";",
          "116:  }",
          "119: srs_t *",
          "120: srs_new()",
          "122:  srs_t *srs = (srs_t *)srs_f_malloc(sizeof(srs_t));",
          "123:  srs_init(srs);",
          "124:  return srs;",
          "127: void",
          "128: srs_init(srs_t *srs)",
          "130:  memset(srs, 0, sizeof(srs_t));",
          "131:  srs->secrets = NULL;",
          "132:  srs->numsecrets = 0;",
          "133:  srs->separator = '=';",
          "134:  srs->maxage = 21;",
          "135:  srs->hashlength = 4;",
          "136:  srs->hashmin = srs->hashlength;",
          "137:  srs->alwaysrewrite = FALSE;",
          "140: void",
          "141: srs_free(srs_t *srs)",
          "143:  int  i;",
          "144:  for (i = 0; i < srs->numsecrets; i++) {",
          "145:   memset(srs->secrets[i], 0, strlen(srs->secrets[i]));",
          "146:   srs_f_free(srs->secrets[i]);",
          "147:   srs->secrets[i] = 0;",
          "148:  }",
          "149:  srs_f_free(srs);",
          "152: int",
          "153: srs_add_secret(srs_t *srs, const char *secret)",
          "155:  int  newlen = (srs->numsecrets + 1) * sizeof(char *);",
          "156:  srs->secrets = (char **)srs_f_realloc(srs->secrets, newlen);",
          "157:  srs->secrets[srs->numsecrets++] = strdup(secret);",
          "158:  return SRS_SUCCESS;",
          "161: const char *",
          "162: srs_get_secret(srs_t *srs, int idx)",
          "164:  if (idx < srs->numsecrets)",
          "165:   return srs->secrets[idx];",
          "166:  return NULL;",
          "169: #define SRS_PARAM_DEFINE(n, t) \\",
          "170:  int srs_set_ ## n (srs_t *srs, t value) { \\",
          "171:   srs->n = value; \\",
          "172:   return SRS_SUCCESS; \\",
          "173:  } \\",
          "174:  t srs_get_ ## n (srs_t *srs) { \\",
          "175:   return srs->n; \\",
          "176:  }",
          "178: int",
          "179: srs_set_separator(srs_t *srs, char value)",
          "181:  if (strchr(srs_separators, value) == NULL)",
          "182:   return SRS_ESEPARATORINVALID;",
          "183:  srs->separator = value;",
          "184:  return SRS_SUCCESS;",
          "187: char",
          "188: srs_get_separator(srs_t *srs)",
          "190:  return srs->separator;",
          "",
          "[Added Lines]",
          "22: #    include <alloca.h>",
          "26: #    include <openssl/hmac.h>",
          "36: #    ifdef HAVE__STRICMP",
          "37: #        define strcasecmp _stricmp",
          "38: #    endif",
          "42: #    ifdef HAVE__STRNICMP",
          "43: #        define strncasecmp _strnicmp",
          "44: #    endif",
          "52: static srs_malloc_t srs_f_malloc = malloc;",
          "53: static srs_realloc_t srs_f_realloc = realloc;",
          "54: static srs_free_t srs_f_free = free;",
          "56: int srs_set_malloc(srs_malloc_t m, srs_realloc_t r, srs_free_t f)",
          "58:     srs_f_malloc = m;",
          "59:     srs_f_realloc = r;",
          "60:     srs_f_free = f;",
          "61:     return SRS_SUCCESS;",
          "64: const char *srs_strerror(int code)",
          "66:     switch (code)",
          "67:     {",
          "69:         case SRS_SUCCESS:",
          "70:             return \"Success\";",
          "71:         case SRS_ENOTSRSADDRESS:",
          "72:             return \"Not an SRS address.\";",
          "75:         case SRS_ENOSECRETS:",
          "76:             return \"No secrets in SRS configuration.\";",
          "77:         case SRS_ESEPARATORINVALID:",
          "78:             return \"Invalid separator suggested.\";",
          "81:         case SRS_ENOSENDERATSIGN:",
          "82:             return \"No at sign in sender address\";",
          "83:         case SRS_EBUFTOOSMALL:",
          "84:             return \"Buffer too small.\";",
          "87:         case SRS_ENOSRS0HOST:",
          "88:             return \"No host in SRS0 address.\";",
          "89:         case SRS_ENOSRS0USER:",
          "90:             return \"No user in SRS0 address.\";",
          "91:         case SRS_ENOSRS0HASH:",
          "92:             return \"No hash in SRS0 address.\";",
          "93:         case SRS_ENOSRS0STAMP:",
          "94:             return \"No timestamp in SRS0 address.\";",
          "95:         case SRS_ENOSRS1HOST:",
          "96:             return \"No host in SRS1 address.\";",
          "97:         case SRS_ENOSRS1USER:",
          "98:             return \"No user in SRS1 address.\";",
          "99:         case SRS_ENOSRS1HASH:",
          "100:             return \"No hash in SRS1 address.\";",
          "101:         case SRS_EBADTIMESTAMPCHAR:",
          "102:             return \"Bad base32 character in timestamp.\";",
          "103:         case SRS_EHASHTOOSHORT:",
          "104:             return \"Hash too short in SRS address.\";",
          "107:         case SRS_ETIMESTAMPOUTOFDATE:",
          "108:             return \"Time stamp out of date.\";",
          "109:         case SRS_EHASHINVALID:",
          "110:             return \"Hash invalid in SRS address.\";",
          "112:         default:",
          "113:             return \"Unknown error in SRS library.\";",
          "114:     }",
          "117: srs_t *srs_new()",
          "119:     srs_t *srs = (srs_t *)srs_f_malloc(sizeof(srs_t));",
          "120:     srs_init(srs);",
          "121:     return srs;",
          "124: void srs_init(srs_t *srs)",
          "126:     memset(srs, 0, sizeof(srs_t));",
          "127:     srs->secrets = NULL;",
          "128:     srs->numsecrets = 0;",
          "129:     srs->separator = '=';",
          "130:     srs->maxage = 21;",
          "131:     srs->hashlength = 4;",
          "132:     srs->hashmin = srs->hashlength;",
          "133:     srs->alwaysrewrite = FALSE;",
          "136: void srs_free(srs_t *srs)",
          "138:     int i;",
          "139:     for (i = 0; i < srs->numsecrets; i++)",
          "140:     {",
          "141:         memset(srs->secrets[i], 0, strlen(srs->secrets[i]));",
          "142:         srs_f_free(srs->secrets[i]);",
          "143:         srs->secrets[i] = 0;",
          "144:     }",
          "145:     srs_f_free(srs);",
          "148: int srs_add_secret(srs_t *srs, const char *secret)",
          "150:     int newlen = (srs->numsecrets + 1) * sizeof(char *);",
          "151:     srs->secrets = (char **)srs_f_realloc(srs->secrets, newlen);",
          "152:     srs->secrets[srs->numsecrets++] = strdup(secret);",
          "153:     return SRS_SUCCESS;",
          "156: const char *srs_get_secret(srs_t *srs, int idx)",
          "158:     if (idx < srs->numsecrets)",
          "159:         return srs->secrets[idx];",
          "160:     return NULL;",
          "163: #define SRS_PARAM_DEFINE(n, t)           \\",
          "164:     int srs_set_##n(srs_t *srs, t value) \\",
          "165:     {                                    \\",
          "166:         srs->n = value;                  \\",
          "167:         return SRS_SUCCESS;              \\",
          "168:     }                                    \\",
          "169:     t srs_get_##n(srs_t *srs) { return srs->n; }",
          "171: int srs_set_separator(srs_t *srs, char value)",
          "173:     if (strchr(srs_separators, value) == NULL)",
          "174:         return SRS_ESEPARATORINVALID;",
          "175:     srs->separator = value;",
          "176:     return SRS_SUCCESS;",
          "179: char srs_get_separator(srs_t *srs)",
          "181:     return srs->separator;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209: const char *SRS_TIME_BASECHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";",
          "215: {",
          "222: }",
          "226: {",
          "252: }",
          "260: {",
          "261: #ifdef USE_OPENSSL",
          "265: #else",
          "268: #endif",
          "280: #ifdef USE_OPENSSL",
          "283: #else",
          "285: #endif",
          "297: #ifdef USE_OPENSSL",
          "299: #else",
          "301: #endif",
          "304: #ifdef USE_OPENSSL",
          "308: #else",
          "311: #endif",
          "342: }",
          "346: {",
          "361: }",
          "365: {",
          "393: }",
          "438: }",
          "507: }",
          "511: {",
          "546: }",
          "550: {",
          "577: }",
          "582: {",
          "620: }",
          "625: {",
          "650: }",
          "654: {",
          "676: }",
          "680: {",
          "704: }",
          "",
          "[Removed Lines]",
          "210: #define SRS_TIME_SIZE  2",
          "211: #define SRS_TIME_SLOTS  (1<<(SRS_TIME_BASEBITS<<(SRS_TIME_SIZE-1)))",
          "213: int",
          "214: srs_timestamp_create(srs_t *srs __attribute__((unused)), char *buf, time_t now)",
          "216:  now = now / SRS_TIME_PRECISION;",
          "217:  buf[1] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];",
          "218:  now = now >> SRS_TIME_BASEBITS;",
          "219:  buf[0] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];",
          "220:  buf[2] = '\\0';",
          "221:  return SRS_SUCCESS;",
          "224: int",
          "225: srs_timestamp_check(srs_t *srs, const char *stamp)",
          "227:  const char *sp;",
          "228:  char  *bp;",
          "229:  int    off;",
          "230:  time_t   now;",
          "231:  time_t   then;",
          "233:  if (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;",
          "235:  then = 0;",
          "236:  for (sp = stamp; *sp; sp++) {",
          "237:   bp = strchr(SRS_TIME_BASECHARS, toupper(*sp));",
          "238:   if (bp == NULL)",
          "239:    return SRS_EBADTIMESTAMPCHAR;",
          "240:   off = bp - SRS_TIME_BASECHARS;",
          "241:   then = (then << SRS_TIME_BASEBITS) | off;",
          "242:  }",
          "244:  time(&now);",
          "245:  now = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;",
          "246:  while (now < then)",
          "247:   now = now + SRS_TIME_SLOTS;",
          "249:  if (now <= then + srs->maxage)",
          "250:   return SRS_SUCCESS;",
          "251:  return SRS_ETIMESTAMPOUTOFDATE;",
          "254: const char *SRS_HASH_BASECHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
          "255:          \"abcdefghijklmnopqrstuvwxyz\"",
          "256:          \"0123456789+/\";",
          "258: static void",
          "259: srs_hash_create_v(srs_t *srs, int idx, char *buf, int nargs, va_list ap)",
          "262:  HMAC_CTX   ctx;",
          "263:  int     srshashlen;",
          "264:  char    srshash[EVP_MAX_MD_SIZE + 1];",
          "266:  srs_hmac_ctx_t  ctx;",
          "267:  char    srshash[SHA_DIGESTSIZE + 1];",
          "269:  char   *secret;",
          "270:  char   *data;",
          "271:  int     len;",
          "272:  char   *lcdata;",
          "273:  unsigned char *hp;",
          "274:  char   *bp;",
          "275:  int     i;",
          "276:  int     j;",
          "278:  secret = srs->secrets[idx];",
          "281:  HMAC_CTX_init(&ctx);",
          "282:  HMAC_Init(&ctx, secret, strlen(secret), EVP_sha1());",
          "284:  srs_hmac_init(&ctx, secret, strlen(secret));",
          "287:  for (i = 0; i < nargs; i++) {",
          "288:   data = va_arg(ap, char *);",
          "289:   len = strlen(data);",
          "290:   lcdata = alloca(len + 1);",
          "291:   for (j = 0; j < len; j++) {",
          "292:    if (isupper(data[j]))",
          "293:     lcdata[j] = tolower(data[j]);",
          "294:    else",
          "295:     lcdata[j] = data[j];",
          "296:   }",
          "298:   HMAC_Update(&ctx, lcdata, len);",
          "300:   srs_hmac_update(&ctx, lcdata, len);",
          "302:  }",
          "305:  HMAC_Final(&ctx, srshash, &srshashlen);",
          "306:  HMAC_CTX_cleanup(&ctx);",
          "307:  srshash[EVP_MAX_MD_SIZE] = '\\0';",
          "309:  srs_hmac_fini(&ctx, srshash);",
          "310:  srshash[SHA_DIGESTSIZE] = '\\0';",
          "315:  hp = (unsigned char *)srshash;",
          "316:  bp = buf;",
          "317:  for (i = 0; i < srs->hashlength; i++) {",
          "318:   switch (i & 0x03) {",
          "320:    case 0:",
          "321:     j = (*hp >> 2);",
          "322:     break;",
          "323:    case 1:",
          "324:     j = ((*hp & 0x03) << 4) |",
          "325:       ((*(hp + 1) & 0xF0) >> 4);",
          "326:     hp++;",
          "327:     break;",
          "328:    case 2:",
          "329:     j = ((*hp & 0x0F) << 2) |",
          "330:       ((*(hp + 1) & 0xC0) >> 6);",
          "331:     hp++;",
          "332:     break;",
          "333:    case 3:",
          "334:     j = (*hp++ & 0x3F);",
          "335:     break;",
          "336:   }",
          "338:  }",
          "341:  buf[srs->hashlength] = '\\0';",
          "344: int",
          "345: srs_hash_create(srs_t *srs, char *buf, int nargs, ...)",
          "347:  va_list  ap;",
          "349:  if (srs->numsecrets == 0)",
          "350:   return SRS_ENOSECRETS;",
          "351:  if (srs->secrets == NULL)",
          "352:   return SRS_ENOSECRETS;",
          "353:  if (srs->secrets[0] == NULL)",
          "354:   return SRS_ENOSECRETS;",
          "356:  va_start(ap, nargs);",
          "357:  srs_hash_create_v(srs, 0, buf, nargs, ap);",
          "358:  va_end(ap);",
          "360:  return SRS_SUCCESS;",
          "363: int",
          "364: srs_hash_check(srs_t *srs, char *hash, int nargs, ...)",
          "366:  va_list ap;",
          "367:  char *srshash;",
          "368:  char *tmp;",
          "369:  int   len;",
          "370:  int   i;",
          "372:  len = strlen(hash);",
          "373:  if (len < srs->hashmin)",
          "374:   return SRS_EHASHTOOSHORT;",
          "375:  if (len > srs->hashlength) {",
          "376:   tmp = alloca(srs->hashlength + 1);",
          "377:   strncpy(tmp, hash, srs->hashlength);",
          "378:   tmp[srs->hashlength] = '\\0';",
          "379:   hash = tmp;",
          "380:   len = srs->hashlength;",
          "381:  }",
          "383:  for (i = 0; i < srs->numsecrets; i++) {",
          "384:   va_start(ap, nargs);",
          "385:   srshash = alloca(srs->hashlength + 1);",
          "386:   srs_hash_create_v(srs, i, srshash, nargs, ap);",
          "387:   va_end(ap);",
          "388:   if (strncasecmp(hash, srshash, len) == 0)",
          "389:    return SRS_SUCCESS;",
          "390:  }",
          "392:  return SRS_EHASHINVALID;",
          "395: int",
          "396: srs_compile_shortcut(srs_t *srs,",
          "397:     char *buf, int buflen,",
          "398:     char *sendhost, char *senduser,",
          "399:     const char *aliashost) {",
          "400:  char *srshash;",
          "401:  char  srsstamp[SRS_TIME_SIZE + 1];",
          "402:  int   len;",
          "403:  int   ret;",
          "406:  if ((strncasecmp(senduser, SRS0TAG, 4) == 0) &&",
          "407:   (strchr(srs_separators, senduser[4]) != NULL)) {",
          "408:   sendhost = senduser + 5;",
          "409:   if (*sendhost == '\\0')",
          "410:    return SRS_ENOSRS0HOST;",
          "411:   senduser = strchr(sendhost, SRSSEP);",
          "412:   if ((senduser == NULL) || (*senduser == '\\0'))",
          "413:    return SRS_ENOSRS0USER;",
          "414:  }",
          "416:  len = strlen(SRS0TAG) + 1 +",
          "417:   srs->hashlength + 1 +",
          "418:    SRS_TIME_SIZE + 1 +",
          "419:     strlen(sendhost) + 1 + strlen(senduser)",
          "420:    + 1 + strlen(aliashost);",
          "421:  if (len >= buflen)",
          "422:   return SRS_EBUFTOOSMALL;",
          "424:  ret = srs_timestamp_create(srs, srsstamp, time(NULL));",
          "425:  if (ret != SRS_SUCCESS)",
          "426:   return ret;",
          "427:  srshash = alloca(srs->hashlength + 1);",
          "428:  ret = srs_hash_create(srs, srshash,3, srsstamp, sendhost, senduser);",
          "429:  if (ret != SRS_SUCCESS)",
          "430:   return ret;",
          "432:  sprintf(buf, SRS0TAG \"%c%s%c%s%c%s%c%s@%s\", srs->separator,",
          "433:      srshash, SRSSEP, srsstamp, SRSSEP,",
          "434:       sendhost, SRSSEP, senduser,",
          "435:        aliashost);",
          "437:  return SRS_SUCCESS;",
          "440: int",
          "441: srs_compile_guarded(srs_t *srs,",
          "442:     char *buf, int buflen,",
          "443:     char *sendhost, char *senduser,",
          "444:     const char *aliashost) {",
          "445:  char *srshost;",
          "446:  char *srsuser;",
          "447:  char *srshash;",
          "448:  int   len;",
          "449:  int   ret;",
          "451:  if ((strncasecmp(senduser, SRS1TAG, 4) == 0) &&",
          "452:   (strchr(srs_separators, senduser[4]) != NULL)) {",
          "454:   srshash = senduser + 5;",
          "455:   if (*srshash == '\\0')",
          "456:    return SRS_ENOSRS1HASH;",
          "458:   srshost = strchr(srshash, SRSSEP);",
          "459:   if (!STRINGP(srshost))",
          "460:    return SRS_ENOSRS1HOST;",
          "462:   srsuser = strchr(srshost, SRSSEP);",
          "463:   if (!STRINGP(srsuser))",
          "464:    return SRS_ENOSRS1USER;",
          "466:   srshash = alloca(srs->hashlength + 1);",
          "467:   ret = srs_hash_create(srs, srshash, 2, srshost, srsuser);",
          "468:   if (ret != SRS_SUCCESS)",
          "469:    return ret;",
          "470:   len = strlen(SRS1TAG) + 1 +",
          "471:    srs->hashlength + 1 +",
          "472:     strlen(srshost) + 1 + strlen(srsuser)",
          "473:    + 1 + strlen(aliashost);",
          "474:   if (len >= buflen)",
          "475:    return SRS_EBUFTOOSMALL;",
          "476:   sprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator,",
          "477:       srshash, SRSSEP,",
          "478:        srshost, SRSSEP, srsuser,",
          "479:         aliashost);",
          "480:   return SRS_SUCCESS;",
          "481:  }",
          "482:  else if ((strncasecmp(senduser, SRS0TAG, 4) == 0) &&",
          "483:   (strchr(srs_separators, senduser[4]) != NULL)) {",
          "484:   srsuser = senduser + 4;",
          "485:   srshost = sendhost;",
          "486:   srshash = alloca(srs->hashlength + 1);",
          "487:   ret = srs_hash_create(srs, srshash, 2, srshost, srsuser);",
          "488:   if (ret != SRS_SUCCESS)",
          "489:    return ret;",
          "490:   len = strlen(SRS1TAG) + 1 +",
          "491:    srs->hashlength + 1 +",
          "492:     strlen(srshost) + 1 + strlen(srsuser)",
          "493:    + 1 + strlen(aliashost);",
          "494:   if (len >= buflen)",
          "495:    return SRS_EBUFTOOSMALL;",
          "496:   sprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator,",
          "497:       srshash, SRSSEP,",
          "498:        srshost, SRSSEP, srsuser,",
          "499:         aliashost);",
          "500:  }",
          "501:  else {",
          "502:   return srs_compile_shortcut(srs, buf, buflen,",
          "503:       sendhost, senduser, aliashost);",
          "504:  }",
          "506:  return SRS_SUCCESS;",
          "509: int",
          "510: srs_parse_shortcut(srs_t *srs, char *buf, unsigned buflen, char *senduser)",
          "512:  char *srshash;",
          "513:  char *srsstamp;",
          "514:  char *srshost;",
          "515:  char *srsuser;",
          "516:  int   ret;",
          "518:  if (strncasecmp(senduser, SRS0TAG, 4) == 0) {",
          "519:   srshash = senduser + 5;",
          "520:   if (!STRINGP(srshash))",
          "521:    return SRS_ENOSRS0HASH;",
          "522:   srsstamp = strchr(srshash, SRSSEP);",
          "523:   if (!STRINGP(srsstamp))",
          "524:    return SRS_ENOSRS0STAMP;",
          "526:   srshost = strchr(srsstamp, SRSSEP);",
          "527:   if (!STRINGP(srshost))",
          "528:    return SRS_ENOSRS0HOST;",
          "530:   srsuser = strchr(srshost, SRSSEP);",
          "531:   if (!STRINGP(srsuser))",
          "532:    return SRS_ENOSRS0USER;",
          "534:   ret = srs_timestamp_check(srs, srsstamp);",
          "535:   if (ret != SRS_SUCCESS)",
          "536:    return ret;",
          "537:   ret = srs_hash_check(srs, srshash, 3, srsstamp,",
          "538:       srshost, srsuser);",
          "539:   if (ret != SRS_SUCCESS)",
          "540:    return ret;",
          "541:   snprintf(buf, buflen, \"%s@%s\", srsuser, srshost);",
          "542:   return SRS_SUCCESS;",
          "543:  }",
          "545:  return SRS_ENOTSRSADDRESS;",
          "548: int",
          "549: srs_parse_guarded(srs_t *srs, char *buf, int buflen, char *senduser)",
          "551:  char *srshash;",
          "552:  char *srshost;",
          "553:  char *srsuser;",
          "554:  int   ret;",
          "556:  if (strncasecmp(senduser, SRS1TAG, 4) == 0) {",
          "557:   srshash = senduser + 5;",
          "558:   if (!STRINGP(srshash))",
          "559:    return SRS_ENOSRS1HASH;",
          "560:   srshost = strchr(srshash, SRSSEP);",
          "561:   if (!STRINGP(srshost))",
          "562:    return SRS_ENOSRS1HOST;",
          "564:   srsuser = strchr(srshost, SRSSEP);",
          "565:   if (!STRINGP(srsuser))",
          "566:    return SRS_ENOSRS1USER;",
          "568:   ret = srs_hash_check(srs, srshash, 2, srshost, srsuser);",
          "569:   if (ret != SRS_SUCCESS)",
          "570:    return ret;",
          "571:   sprintf(buf, SRS0TAG \"%s@%s\", srsuser, srshost);",
          "572:   return SRS_SUCCESS;",
          "573:  }",
          "574:  else {",
          "575:   return srs_parse_shortcut(srs, buf, buflen, senduser);",
          "576:  }",
          "579: int",
          "580: srs_forward(srs_t *srs, char *buf, unsigned buflen,",
          "581:     const char *sender, const char *alias)",
          "583:  char *senduser;",
          "584:  char *sendhost;",
          "585:  char *tmp;",
          "586:  unsigned   len;",
          "588:  if (srs->noforward)",
          "589:   return SRS_ENOTREWRITTEN;",
          "592:  while ((tmp = strchr(alias, '@')) != NULL)",
          "593:   alias = tmp + 1;",
          "595:  tmp = strchr(sender, '@');",
          "596:  if (tmp == NULL)",
          "597:   return SRS_ENOSENDERATSIGN;",
          "598:  sendhost = tmp + 1;",
          "600:  len = strlen(sender);",
          "602:  if (! srs->alwaysrewrite) {",
          "603:   if (strcasecmp(sendhost, alias) == 0) {",
          "604:    if (strlen(sender) >= buflen)",
          "605:     return SRS_EBUFTOOSMALL;",
          "606:    strcpy(buf, sender);",
          "607:    return SRS_SUCCESS;",
          "608:   }",
          "609:  }",
          "612:  senduser = alloca(len + 1);",
          "613:  strcpy(senduser, sender);",
          "614:  tmp = (senduser + (tmp - sender));",
          "615:  sendhost = tmp + 1;",
          "618:  return srs_compile_guarded(srs, buf, buflen,",
          "619:      sendhost, senduser, alias);",
          "622: int",
          "623: srs_forward_alloc(srs_t *srs, char **sptr,",
          "624:     const char *sender, const char *alias)",
          "626:  char *buf;",
          "627:  int   slen;",
          "628:  int   alen;",
          "629:  int   len;",
          "630:  int   ret;",
          "632:  if (srs->noforward)",
          "633:   return SRS_ENOTREWRITTEN;",
          "635:  slen = strlen(sender);",
          "636:  alen = strlen(alias);",
          "639:  len = slen + alen + srs->hashlength + SRS_TIME_SIZE + 64;",
          "640:  buf = (char *)srs_f_malloc(len);",
          "642:  ret = srs_forward(srs, buf, len, sender, alias);",
          "644:  if (ret == SRS_SUCCESS)",
          "646:  else",
          "647:   srs_f_free(buf);",
          "649:  return ret;",
          "652: int",
          "653: srs_reverse(srs_t *srs, char *buf, unsigned buflen, const char *sender)",
          "655:  char *senduser;",
          "656:  char *tmp;",
          "657:  unsigned   len;",
          "659:  if (!SRS_IS_SRS_ADDRESS(sender))",
          "660:   return SRS_ENOTSRSADDRESS;",
          "662:  if (srs->noreverse)",
          "663:   return SRS_ENOTREWRITTEN;",
          "665:  len = strlen(sender);",
          "666:  if (len >= buflen)",
          "667:   return SRS_EBUFTOOSMALL;",
          "668:  senduser = alloca(len + 1);",
          "669:  strcpy(senduser, sender);",
          "672:  tmp = strchr(senduser, '@');",
          "673:  if (tmp != NULL)",
          "675:  return srs_parse_guarded(srs, buf, buflen, senduser);",
          "678: int",
          "679: srs_reverse_alloc(srs_t *srs, char **sptr, const char *sender)",
          "681:  char *buf;",
          "682:  int   len;",
          "683:  int   ret;",
          "687:  if (!SRS_IS_SRS_ADDRESS(sender))",
          "688:   return SRS_ENOTSRSADDRESS;",
          "690:  if (srs->noreverse)",
          "691:   return SRS_ENOTREWRITTEN;",
          "693:  len = strlen(sender) + 1;",
          "694:  buf = (char *)srs_f_malloc(len);",
          "696:  ret = srs_reverse(srs, buf, len, sender);",
          "698:  if (ret == SRS_SUCCESS)",
          "700:  else",
          "701:   srs_f_free(buf);",
          "703:  return ret;",
          "",
          "[Added Lines]",
          "201: #define SRS_TIME_SIZE  2",
          "202: #define SRS_TIME_SLOTS (1 << (SRS_TIME_BASEBITS << (SRS_TIME_SIZE - 1)))",
          "204: int srs_timestamp_create(srs_t *srs __attribute__((unused)), char *buf,",
          "205:                          time_t now)",
          "207:     now = now / SRS_TIME_PRECISION;",
          "208:     buf[1] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];",
          "209:     now = now >> SRS_TIME_BASEBITS;",
          "210:     buf[0] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];",
          "211:     buf[2] = '\\0';",
          "212:     return SRS_SUCCESS;",
          "215: int srs_timestamp_check(srs_t *srs, const char *stamp)",
          "217:     const char *sp;",
          "218:     char *bp;",
          "219:     int off;",
          "220:     time_t now;",
          "221:     time_t then;",
          "223:     if (strlen(stamp) != 2)",
          "224:         return SRS_ETIMESTAMPOUTOFDATE;",
          "226:     then = 0;",
          "227:     for (sp = stamp; *sp; sp++)",
          "228:     {",
          "229:         bp = strchr(SRS_TIME_BASECHARS, toupper(*sp));",
          "230:         if (bp == NULL)",
          "231:             return SRS_EBADTIMESTAMPCHAR;",
          "232:         off = bp - SRS_TIME_BASECHARS;",
          "233:         then = (then << SRS_TIME_BASEBITS) | off;",
          "234:     }",
          "236:     time(&now);",
          "237:     now = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;",
          "238:     while (now < then)",
          "239:         now = now + SRS_TIME_SLOTS;",
          "241:     if (now <= then + srs->maxage)",
          "242:         return SRS_SUCCESS;",
          "243:     return SRS_ETIMESTAMPOUTOFDATE;",
          "246: const char *SRS_HASH_BASECHARS =",
          "247:     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
          "248:     \"abcdefghijklmnopqrstuvwxyz\"",
          "249:     \"0123456789+/\";",
          "251: static void srs_hash_create_v(srs_t *srs, int idx, char *buf, int nargs,",
          "252:                               va_list ap)",
          "255:     HMAC_CTX ctx;",
          "256:     int srshashlen;",
          "257:     char srshash[EVP_MAX_MD_SIZE + 1];",
          "259:     srs_hmac_ctx_t ctx;",
          "260:     char srshash[SHA_DIGESTSIZE + 1];",
          "262:     char *secret;",
          "263:     char *data;",
          "264:     int len;",
          "265:     char *lcdata;",
          "266:     unsigned char *hp;",
          "267:     char *bp;",
          "268:     int i;",
          "269:     int j;",
          "271:     secret = srs->secrets[idx];",
          "274:     HMAC_CTX_init(&ctx);",
          "275:     HMAC_Init(&ctx, secret, strlen(secret), EVP_sha1());",
          "277:     srs_hmac_init(&ctx, secret, strlen(secret));",
          "280:     for (i = 0; i < nargs; i++)",
          "281:     {",
          "282:         data = va_arg(ap, char *);",
          "283:         len = strlen(data);",
          "284:         lcdata = alloca(len + 1);",
          "285:         for (j = 0; j < len; j++)",
          "286:         {",
          "287:             if (isupper(data[j]))",
          "288:                 lcdata[j] = tolower(data[j]);",
          "289:             else",
          "290:                 lcdata[j] = data[j];",
          "291:         }",
          "293:         HMAC_Update(&ctx, lcdata, len);",
          "295:         srs_hmac_update(&ctx, lcdata, len);",
          "297:     }",
          "300:     HMAC_Final(&ctx, srshash, &srshashlen);",
          "301:     HMAC_CTX_cleanup(&ctx);",
          "302:     srshash[EVP_MAX_MD_SIZE] = '\\0';",
          "304:     srs_hmac_fini(&ctx, srshash);",
          "305:     srshash[SHA_DIGESTSIZE] = '\\0';",
          "309:     hp = (unsigned char *)srshash;",
          "310:     bp = buf;",
          "311:     for (i = 0; i < srs->hashlength; i++)",
          "312:     {",
          "313:         switch (i & 0x03)",
          "314:         {",
          "316:             case 0:",
          "317:                 j = (*hp >> 2);",
          "318:                 break;",
          "319:             case 1:",
          "320:                 j = ((*hp & 0x03) << 4) | ((*(hp + 1) & 0xF0) >> 4);",
          "321:                 hp++;",
          "322:                 break;",
          "323:             case 2:",
          "324:                 j = ((*hp & 0x0F) << 2) | ((*(hp + 1) & 0xC0) >> 6);",
          "325:                 hp++;",
          "326:                 break;",
          "327:             case 3:",
          "328:                 j = (*hp++ & 0x3F);",
          "329:                 break;",
          "330:         }",
          "332:     }",
          "335:     buf[srs->hashlength] = '\\0';",
          "338: int srs_hash_create(srs_t *srs, char *buf, int nargs, ...)",
          "340:     va_list ap;",
          "342:     if (srs->numsecrets == 0)",
          "343:         return SRS_ENOSECRETS;",
          "344:     if (srs->secrets == NULL)",
          "345:         return SRS_ENOSECRETS;",
          "346:     if (srs->secrets[0] == NULL)",
          "347:         return SRS_ENOSECRETS;",
          "349:     va_start(ap, nargs);",
          "350:     srs_hash_create_v(srs, 0, buf, nargs, ap);",
          "351:     va_end(ap);",
          "353:     return SRS_SUCCESS;",
          "356: int srs_hash_check(srs_t *srs, char *hash, int nargs, ...)",
          "358:     va_list ap;",
          "359:     char *srshash;",
          "360:     char *tmp;",
          "361:     int len;",
          "362:     int i;",
          "364:     len = strlen(hash);",
          "365:     if (len < srs->hashmin)",
          "366:         return SRS_EHASHTOOSHORT;",
          "367:     if (len > srs->hashlength)",
          "368:     {",
          "369:         tmp = alloca(srs->hashlength + 1);",
          "370:         strncpy(tmp, hash, srs->hashlength);",
          "371:         tmp[srs->hashlength] = '\\0';",
          "372:         hash = tmp;",
          "373:         len = srs->hashlength;",
          "374:     }",
          "376:     for (i = 0; i < srs->numsecrets; i++)",
          "377:     {",
          "378:         va_start(ap, nargs);",
          "379:         srshash = alloca(srs->hashlength + 1);",
          "380:         srs_hash_create_v(srs, i, srshash, nargs, ap);",
          "381:         va_end(ap);",
          "382:         if (strncasecmp(hash, srshash, len) == 0)",
          "383:             return SRS_SUCCESS;",
          "384:     }",
          "386:     return SRS_EHASHINVALID;",
          "389: int srs_compile_shortcut(srs_t *srs, char *buf, int buflen, char *sendhost,",
          "390:                          char *senduser, const char *aliashost)",
          "391: {",
          "392:     char *srshash;",
          "393:     char srsstamp[SRS_TIME_SIZE + 1];",
          "394:     int len;",
          "395:     int ret;",
          "398:     if ((strncasecmp(senduser, SRS0TAG, 4) == 0)",
          "399:         && (strchr(srs_separators, senduser[4]) != NULL))",
          "400:     {",
          "401:         sendhost = senduser + 5;",
          "402:         if (*sendhost == '\\0')",
          "403:             return SRS_ENOSRS0HOST;",
          "404:         senduser = strchr(sendhost, SRSSEP);",
          "405:         if ((senduser == NULL) || (*senduser == '\\0'))",
          "406:             return SRS_ENOSRS0USER;",
          "407:     }",
          "409:     len = strlen(SRS0TAG) + 1 + srs->hashlength + 1 + SRS_TIME_SIZE + 1",
          "410:           + strlen(sendhost) + 1 + strlen(senduser) + 1 + strlen(aliashost);",
          "411:     if (len >= buflen)",
          "412:         return SRS_EBUFTOOSMALL;",
          "414:     ret = srs_timestamp_create(srs, srsstamp, time(NULL));",
          "415:     if (ret != SRS_SUCCESS)",
          "416:         return ret;",
          "417:     srshash = alloca(srs->hashlength + 1);",
          "418:     ret = srs_hash_create(srs, srshash, 3, srsstamp, sendhost, senduser);",
          "419:     if (ret != SRS_SUCCESS)",
          "420:         return ret;",
          "422:     sprintf(buf, SRS0TAG \"%c%s%c%s%c%s%c%s@%s\", srs->separator, srshash, SRSSEP,",
          "423:             srsstamp, SRSSEP, sendhost, SRSSEP, senduser, aliashost);",
          "425:     return SRS_SUCCESS;",
          "428: int srs_compile_guarded(srs_t *srs, char *buf, int buflen, char *sendhost,",
          "429:                         char *senduser, const char *aliashost)",
          "430: {",
          "431:     char *srshost;",
          "432:     char *srsuser;",
          "433:     char *srshash;",
          "434:     int len;",
          "435:     int ret;",
          "437:     if ((strncasecmp(senduser, SRS1TAG, 4) == 0)",
          "438:         && (strchr(srs_separators, senduser[4]) != NULL))",
          "439:     {",
          "441:         srshash = senduser + 5;",
          "442:         if (*srshash == '\\0')",
          "443:             return SRS_ENOSRS1HASH;",
          "445:         srshost = strchr(srshash, SRSSEP);",
          "446:         if (!STRINGP(srshost))",
          "447:             return SRS_ENOSRS1HOST;",
          "449:         srsuser = strchr(srshost, SRSSEP);",
          "450:         if (!STRINGP(srsuser))",
          "451:             return SRS_ENOSRS1USER;",
          "453:         srshash = alloca(srs->hashlength + 1);",
          "454:         ret = srs_hash_create(srs, srshash, 2, srshost, srsuser);",
          "455:         if (ret != SRS_SUCCESS)",
          "456:             return ret;",
          "457:         len = strlen(SRS1TAG) + 1 + srs->hashlength + 1 + strlen(srshost) + 1",
          "458:               + strlen(srsuser) + 1 + strlen(aliashost);",
          "459:         if (len >= buflen)",
          "460:             return SRS_EBUFTOOSMALL;",
          "461:         sprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator, srshash, SRSSEP,",
          "462:                 srshost, SRSSEP, srsuser, aliashost);",
          "463:         return SRS_SUCCESS;",
          "464:     }",
          "465:     else if ((strncasecmp(senduser, SRS0TAG, 4) == 0)",
          "466:              && (strchr(srs_separators, senduser[4]) != NULL))",
          "467:     {",
          "468:         srsuser = senduser + 4;",
          "469:         srshost = sendhost;",
          "470:         srshash = alloca(srs->hashlength + 1);",
          "471:         ret = srs_hash_create(srs, srshash, 2, srshost, srsuser);",
          "472:         if (ret != SRS_SUCCESS)",
          "473:             return ret;",
          "474:         len = strlen(SRS1TAG) + 1 + srs->hashlength + 1 + strlen(srshost) + 1",
          "475:               + strlen(srsuser) + 1 + strlen(aliashost);",
          "476:         if (len >= buflen)",
          "477:             return SRS_EBUFTOOSMALL;",
          "478:         sprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator, srshash, SRSSEP,",
          "479:                 srshost, SRSSEP, srsuser, aliashost);",
          "480:     }",
          "481:     else",
          "482:     {",
          "483:         return srs_compile_shortcut(srs, buf, buflen, sendhost, senduser,",
          "484:                                     aliashost);",
          "485:     }",
          "487:     return SRS_SUCCESS;",
          "490: int srs_parse_shortcut(srs_t *srs, char *buf, unsigned buflen, char *senduser)",
          "492:     char *srshash;",
          "493:     char *srsstamp;",
          "494:     char *srshost;",
          "495:     char *srsuser;",
          "496:     int ret;",
          "498:     if (strncasecmp(senduser, SRS0TAG, 4) == 0)",
          "499:     {",
          "500:         srshash = senduser + 5;",
          "501:         if (!STRINGP(srshash))",
          "502:             return SRS_ENOSRS0HASH;",
          "503:         srsstamp = strchr(srshash, SRSSEP);",
          "504:         if (!STRINGP(srsstamp))",
          "505:             return SRS_ENOSRS0STAMP;",
          "507:         srshost = strchr(srsstamp, SRSSEP);",
          "508:         if (!STRINGP(srshost))",
          "509:             return SRS_ENOSRS0HOST;",
          "511:         srsuser = strchr(srshost, SRSSEP);",
          "512:         if (!STRINGP(srsuser))",
          "513:             return SRS_ENOSRS0USER;",
          "515:         ret = srs_timestamp_check(srs, srsstamp);",
          "516:         if (ret != SRS_SUCCESS)",
          "517:             return ret;",
          "518:         ret = srs_hash_check(srs, srshash, 3, srsstamp, srshost, srsuser);",
          "519:         if (ret != SRS_SUCCESS)",
          "520:             return ret;",
          "521:         snprintf(buf, buflen, \"%s@%s\", srsuser, srshost);",
          "522:         return SRS_SUCCESS;",
          "523:     }",
          "525:     return SRS_ENOTSRSADDRESS;",
          "528: int srs_parse_guarded(srs_t *srs, char *buf, int buflen, char *senduser)",
          "530:     char *srshash;",
          "531:     char *srshost;",
          "532:     char *srsuser;",
          "533:     int ret;",
          "535:     if (strncasecmp(senduser, SRS1TAG, 4) == 0)",
          "536:     {",
          "537:         srshash = senduser + 5;",
          "538:         if (!STRINGP(srshash))",
          "539:             return SRS_ENOSRS1HASH;",
          "540:         srshost = strchr(srshash, SRSSEP);",
          "541:         if (!STRINGP(srshost))",
          "542:             return SRS_ENOSRS1HOST;",
          "544:         srsuser = strchr(srshost, SRSSEP);",
          "545:         if (!STRINGP(srsuser))",
          "546:             return SRS_ENOSRS1USER;",
          "548:         ret = srs_hash_check(srs, srshash, 2, srshost, srsuser);",
          "549:         if (ret != SRS_SUCCESS)",
          "550:             return ret;",
          "551:         sprintf(buf, SRS0TAG \"%s@%s\", srsuser, srshost);",
          "552:         return SRS_SUCCESS;",
          "553:     }",
          "554:     else",
          "555:     {",
          "556:         return srs_parse_shortcut(srs, buf, buflen, senduser);",
          "557:     }",
          "560: int srs_forward(srs_t *srs, char *buf, unsigned buflen, const char *sender,",
          "561:                 const char *alias)",
          "563:     char *senduser;",
          "564:     char *sendhost;",
          "565:     char *tmp;",
          "566:     unsigned len;",
          "568:     if (srs->noforward)",
          "569:         return SRS_ENOTREWRITTEN;",
          "572:     while ((tmp = strchr(alias, '@')) != NULL)",
          "573:         alias = tmp + 1;",
          "575:     tmp = strchr(sender, '@');",
          "576:     if (tmp == NULL)",
          "577:         return SRS_ENOSENDERATSIGN;",
          "578:     sendhost = tmp + 1;",
          "580:     len = strlen(sender);",
          "582:     if (!srs->alwaysrewrite)",
          "583:     {",
          "584:         if (strcasecmp(sendhost, alias) == 0)",
          "585:         {",
          "586:             if (strlen(sender) >= buflen)",
          "587:                 return SRS_EBUFTOOSMALL;",
          "588:             strcpy(buf, sender);",
          "589:             return SRS_SUCCESS;",
          "590:         }",
          "591:     }",
          "594:     senduser = alloca(len + 1);",
          "595:     strcpy(senduser, sender);",
          "596:     tmp = (senduser + (tmp - sender));",
          "597:     sendhost = tmp + 1;",
          "600:     return srs_compile_guarded(srs, buf, buflen, sendhost, senduser, alias);",
          "603: int srs_forward_alloc(srs_t *srs, char **sptr, const char *sender,",
          "604:                       const char *alias)",
          "606:     char *buf;",
          "607:     int slen;",
          "608:     int alen;",
          "609:     int len;",
          "610:     int ret;",
          "612:     if (srs->noforward)",
          "613:         return SRS_ENOTREWRITTEN;",
          "615:     slen = strlen(sender);",
          "616:     alen = strlen(alias);",
          "619:     len = slen + alen + srs->hashlength + SRS_TIME_SIZE + 64;",
          "620:     buf = (char *)srs_f_malloc(len);",
          "622:     ret = srs_forward(srs, buf, len, sender, alias);",
          "624:     if (ret == SRS_SUCCESS)",
          "626:     else",
          "627:         srs_f_free(buf);",
          "629:     return ret;",
          "632: int srs_reverse(srs_t *srs, char *buf, unsigned buflen, const char *sender)",
          "634:     char *senduser;",
          "635:     char *tmp;",
          "636:     unsigned len;",
          "638:     if (!SRS_IS_SRS_ADDRESS(sender))",
          "639:         return SRS_ENOTSRSADDRESS;",
          "641:     if (srs->noreverse)",
          "642:         return SRS_ENOTREWRITTEN;",
          "644:     len = strlen(sender);",
          "645:     if (len >= buflen)",
          "646:         return SRS_EBUFTOOSMALL;",
          "647:     senduser = alloca(len + 1);",
          "648:     strcpy(senduser, sender);",
          "651:     tmp = strchr(senduser, '@');",
          "652:     if (tmp != NULL)",
          "654:     return srs_parse_guarded(srs, buf, buflen, senduser);",
          "657: int srs_reverse_alloc(srs_t *srs, char **sptr, const char *sender)",
          "659:     char *buf;",
          "660:     int len;",
          "661:     int ret;",
          "665:     if (!SRS_IS_SRS_ADDRESS(sender))",
          "666:         return SRS_ENOTSRSADDRESS;",
          "668:     if (srs->noreverse)",
          "669:         return SRS_ENOTREWRITTEN;",
          "671:     len = strlen(sender) + 1;",
          "672:     buf = (char *)srs_f_malloc(len);",
          "674:     ret = srs_reverse(srs, buf, len, sender);",
          "676:     if (ret == SRS_SUCCESS)",
          "678:     else",
          "679:         srs_f_free(buf);",
          "681:     return ret;",
          "",
          "---------------"
        ],
        "srs2.h||srs2.h": [
          "File: srs2.h -> srs2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #ifndef __SRS2_H__",
          "18: #define __SRS2_H__",
          "20: #include <stdio.h>",
          "21: #include <stdlib.h>",
          "23: #ifdef HAVE_SYS_TYPES_H",
          "25: #endif",
          "26: #ifdef HAVE_SYS_TIME_H",
          "28: #endif",
          "29: #ifdef HAVE_TIME_H",
          "31: #endif",
          "33: #ifndef __BEGIN_DECLS",
          "36: #endif",
          "38: __BEGIN_DECLS",
          "49: #undef TRUE",
          "",
          "[Removed Lines]",
          "22: #include <ctype.h>",
          "24: #include <sys/types.h>",
          "27: #include <sys/time.h>",
          "30: #include <time.h>",
          "34: #define __BEGIN_DECLS",
          "35: #define __END_DECLS",
          "40: #define SRS_VERSION_MAJOR   1",
          "41: #define SRS_VERSION_MINOR   0",
          "42: #define SRS_VERSION_PATCHLEVEL  14",
          "43: #define SRS_VERSION_FROM(m, n, p) (((m) << 16) + ((n) << 8) + (p))",
          "44: #define SRS_VERSION  SRS_VERSION_FROM(SRS_VERSION_MAJOR, \\",
          "45:           SRS_VERSION_MINOR, \\",
          "46:           SRS_VERSION_PATCHLEVEL)",
          "",
          "[Added Lines]",
          "20: #include <ctype.h>",
          "24: #    include <sys/types.h>",
          "27: #    include <sys/time.h>",
          "30: #    include <time.h>",
          "34: #    define __BEGIN_DECLS",
          "35: #    define __END_DECLS",
          "40: #define SRS_VERSION_MAJOR         1",
          "41: #define SRS_VERSION_MINOR         0",
          "42: #define SRS_VERSION_PATCHLEVEL    14",
          "43: #define SRS_VERSION_FROM(m, n, p) (((m) << 16) + ((n) << 8) + (p))",
          "44: #define SRS_VERSION                                        \\",
          "45:     SRS_VERSION_FROM(SRS_VERSION_MAJOR, SRS_VERSION_MINOR, \\",
          "46:                      SRS_VERSION_PATCHLEVEL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51: #undef FALSE",
          "52: #define FALSE 0",
          "100: typedef void *(*srs_malloc_t)(size_t);",
          "101: typedef void *(*srs_realloc_t)(void *, size_t);",
          "",
          "[Removed Lines]",
          "54: #define SRSSEP '='",
          "55: #define SRS0TAG \"SRS0\"",
          "56: #define SRS1TAG \"SRS1\"",
          "60: #define SRS_ERRTYPE_MASK  0xF000",
          "61: #define SRS_ERRTYPE_NONE  0x0000",
          "62: #define SRS_ERRTYPE_CONFIG  0x1000",
          "63: #define SRS_ERRTYPE_INPUT  0x2000",
          "64: #define SRS_ERRTYPE_SYNTAX  0x4000",
          "65: #define SRS_ERRTYPE_SRS   0x8000",
          "67: #define SRS_SUCCESS    (0)",
          "68: #define SRS_ENOTSRSADDRESS  (1)",
          "69: #define SRS_ENOTREWRITTEN  (2)",
          "71: #define SRS_ENOSECRETS   (SRS_ERRTYPE_CONFIG | 1)",
          "72: #define SRS_ESEPARATORINVALID (SRS_ERRTYPE_CONFIG | 2)",
          "74: #define SRS_ENOSENDERATSIGN  (SRS_ERRTYPE_INPUT | 1)",
          "75: #define SRS_EBUFTOOSMALL  (SRS_ERRTYPE_INPUT | 2)",
          "77: #define SRS_ENOSRS0HOST   (SRS_ERRTYPE_SYNTAX | 1)",
          "78: #define SRS_ENOSRS0USER   (SRS_ERRTYPE_SYNTAX | 2)",
          "79: #define SRS_ENOSRS0HASH   (SRS_ERRTYPE_SYNTAX | 3)",
          "80: #define SRS_ENOSRS0STAMP  (SRS_ERRTYPE_SYNTAX | 4)",
          "81: #define SRS_ENOSRS1HOST   (SRS_ERRTYPE_SYNTAX | 5)",
          "82: #define SRS_ENOSRS1USER   (SRS_ERRTYPE_SYNTAX | 6)",
          "83: #define SRS_ENOSRS1HASH   (SRS_ERRTYPE_SYNTAX | 7)",
          "84: #define SRS_EBADTIMESTAMPCHAR (SRS_ERRTYPE_SYNTAX | 8)",
          "85: #define SRS_EHASHTOOSHORT  (SRS_ERRTYPE_SYNTAX | 9)",
          "87: #define SRS_ETIMESTAMPOUTOFDATE (SRS_ERRTYPE_SRS | 1)",
          "88: #define SRS_EHASHINVALID  (SRS_ERRTYPE_SRS | 2)",
          "90: #define SRS_ERROR_TYPE(x) ((x) & SRS_ERRTYPE_MASK)",
          "94: #define SRS_IS_SRS_ADDRESS(x) ( \\",
          "95:     (strncasecmp((x), \"SRS\", 3) == 0) && \\",
          "96:     (strchr(\"01\", (x)[3]) != NULL) && \\",
          "97:     (strchr(\"-+=\", (x)[4]) != NULL) \\",
          "98:    )",
          "",
          "[Added Lines]",
          "54: #define SRSSEP  '='",
          "55: #define SRS0TAG \"SRS0\"",
          "56: #define SRS1TAG \"SRS1\"",
          "60: #define SRS_ERRTYPE_MASK   0xF000",
          "61: #define SRS_ERRTYPE_NONE   0x0000",
          "62: #define SRS_ERRTYPE_CONFIG 0x1000",
          "63: #define SRS_ERRTYPE_INPUT  0x2000",
          "64: #define SRS_ERRTYPE_SYNTAX 0x4000",
          "65: #define SRS_ERRTYPE_SRS    0x8000",
          "67: #define SRS_SUCCESS        (0)",
          "68: #define SRS_ENOTSRSADDRESS (1)",
          "69: #define SRS_ENOTREWRITTEN  (2)",
          "71: #define SRS_ENOSECRETS        (SRS_ERRTYPE_CONFIG | 1)",
          "72: #define SRS_ESEPARATORINVALID (SRS_ERRTYPE_CONFIG | 2)",
          "74: #define SRS_ENOSENDERATSIGN (SRS_ERRTYPE_INPUT | 1)",
          "75: #define SRS_EBUFTOOSMALL    (SRS_ERRTYPE_INPUT | 2)",
          "77: #define SRS_ENOSRS0HOST       (SRS_ERRTYPE_SYNTAX | 1)",
          "78: #define SRS_ENOSRS0USER       (SRS_ERRTYPE_SYNTAX | 2)",
          "79: #define SRS_ENOSRS0HASH       (SRS_ERRTYPE_SYNTAX | 3)",
          "80: #define SRS_ENOSRS0STAMP      (SRS_ERRTYPE_SYNTAX | 4)",
          "81: #define SRS_ENOSRS1HOST       (SRS_ERRTYPE_SYNTAX | 5)",
          "82: #define SRS_ENOSRS1USER       (SRS_ERRTYPE_SYNTAX | 6)",
          "83: #define SRS_ENOSRS1HASH       (SRS_ERRTYPE_SYNTAX | 7)",
          "84: #define SRS_EBADTIMESTAMPCHAR (SRS_ERRTYPE_SYNTAX | 8)",
          "85: #define SRS_EHASHTOOSHORT     (SRS_ERRTYPE_SYNTAX | 9)",
          "87: #define SRS_ETIMESTAMPOUTOFDATE (SRS_ERRTYPE_SRS | 1)",
          "88: #define SRS_EHASHINVALID        (SRS_ERRTYPE_SRS | 2)",
          "90: #define SRS_ERROR_TYPE(x) ((x)&SRS_ERRTYPE_MASK)",
          "94: #define SRS_IS_SRS_ADDRESS(x)                                            \\",
          "95:     ((strncasecmp((x), \"SRS\", 3) == 0) && (strchr(\"01\", (x)[3]) != NULL) \\",
          "96:      && (strchr(\"-+=\", (x)[4]) != NULL))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "104: typedef int srs_bool;",
          "123: } srs_t;",
          "150: SRS_PARAM_DECLARE(alwaysrewrite, srs_bool)",
          "151: SRS_PARAM_DECLARE(separator, char)",
          "",
          "[Removed Lines]",
          "106: typedef",
          "107: struct _srs_t {",
          "109:  char **secrets;",
          "110:  int    numsecrets;",
          "111:  char   separator;",
          "115:  int    hashlength;",
          "116:  int    hashmin;",
          "126: int   srs_set_malloc(srs_malloc_t m, srs_realloc_t r, srs_free_t f);",
          "127: srs_t *srs_new();",
          "128: void  srs_init(srs_t *srs);",
          "129: void  srs_free(srs_t *srs);",
          "130: int   srs_forward(srs_t *srs, char *buf, unsigned buflen,",
          "131:     const char *sender, const char *alias);",
          "132: int   srs_forward_alloc(srs_t *srs, char **sptr,",
          "133:     const char *sender, const char *alias);",
          "134: int   srs_reverse(srs_t *srs, char *buf, unsigned buflen,",
          "135:     const char *sender);",
          "136: int   srs_reverse_alloc(srs_t *srs, char **sptr, const char *sender);",
          "137: const char *",
          "138:    srs_strerror(int code);",
          "139: int   srs_add_secret(srs_t *srs, const char *secret);",
          "140: const char *",
          "141:    srs_get_secret(srs_t *srs, int idx);",
          "143: int   srs_timestamp_create(srs_t *srs, char *buf, time_t now);",
          "144: int   srs_timestamp_check(srs_t *srs, const char *stamp);",
          "146: #define SRS_PARAM_DECLARE(n, t) \\",
          "147:  int srs_set_ ## n (srs_t *srs, t value); \\",
          "148:  t srs_get_ ## n (srs_t *srs);",
          "",
          "[Added Lines]",
          "104: typedef struct _srs_t",
          "105: {",
          "107:     char **secrets;",
          "108:     int numsecrets;",
          "109:     char separator;",
          "113:     int hashlength;",
          "114:     int hashmin;",
          "124: int srs_set_malloc(srs_malloc_t m, srs_realloc_t r, srs_free_t f);",
          "125: srs_t *srs_new();",
          "126: void srs_init(srs_t *srs);",
          "127: void srs_free(srs_t *srs);",
          "128: int srs_forward(srs_t *srs, char *buf, unsigned buflen, const char *sender,",
          "129:                 const char *alias);",
          "130: int srs_forward_alloc(srs_t *srs, char **sptr, const char *sender,",
          "131:                       const char *alias);",
          "132: int srs_reverse(srs_t *srs, char *buf, unsigned buflen, const char *sender);",
          "133: int srs_reverse_alloc(srs_t *srs, char **sptr, const char *sender);",
          "134: const char *srs_strerror(int code);",
          "135: int srs_add_secret(srs_t *srs, const char *secret);",
          "136: const char *srs_get_secret(srs_t *srs, int idx);",
          "138: int srs_timestamp_create(srs_t *srs, char *buf, time_t now);",
          "139: int srs_timestamp_check(srs_t *srs, const char *stamp);",
          "141: #define SRS_PARAM_DECLARE(n, t)           \\",
          "142:     int srs_set_##n(srs_t *srs, t value); \\",
          "143:     t srs_get_##n(srs_t *srs);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "171: } SHA_INFO;",
          "178: } srs_hmac_ctx_t;",
          "185: __END_DECLS",
          "",
          "[Removed Lines]",
          "161: typedef unsigned char sha_byte;",
          "163: #define SHA_BLOCKSIZE    64",
          "164: #define SHA_DIGESTSIZE    20",
          "166: typedef struct {",
          "173: typedef",
          "174: struct _srs_hmac_ctx_t {",
          "175:  SHA_INFO sctx;",
          "176:  char  ipad[SHA_BLOCKSIZE + 1];",
          "177:  char  opad[SHA_BLOCKSIZE + 1];",
          "180: void  srs_hmac_init(srs_hmac_ctx_t *ctx, char *secret, unsigned len);",
          "181: void  srs_hmac_update(srs_hmac_ctx_t *ctx, char *data, unsigned len);",
          "182: void  srs_hmac_fini(srs_hmac_ctx_t *ctx, char *out);",
          "",
          "[Added Lines]",
          "156: typedef unsigned char sha_byte;",
          "158: #define SHA_BLOCKSIZE  64",
          "159: #define SHA_DIGESTSIZE 20",
          "161: typedef struct",
          "162: {",
          "169: typedef struct _srs_hmac_ctx_t",
          "170: {",
          "171:     SHA_INFO sctx;",
          "172:     char ipad[SHA_BLOCKSIZE + 1];",
          "173:     char opad[SHA_BLOCKSIZE + 1];",
          "176: void srs_hmac_init(srs_hmac_ctx_t *ctx, char *secret, unsigned len);",
          "177: void srs_hmac_update(srs_hmac_ctx_t *ctx, char *data, unsigned len);",
          "178: void srs_hmac_fini(srs_hmac_ctx_t *ctx, char *out);",
          "",
          "---------------"
        ],
        "tests.c||tests.c": [
          "File: tests.c -> tests.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include \"srs2.h\"",
          "21: #include <string.h>",
          "24: {",
          "52:     result = srs_reverse(srs, buf2, sizeof(buf2), buf1);",
          "56:     }",
          "60: }",
          "63: {",
          "80: }",
          "85: {",
          "98:     {",
          "101:     }",
          "104: }",
          "107: {",
          "111: }",
          "",
          "[Removed Lines]",
          "23: static int run_srs(srs_t* srs, const char* address, const char* domain)",
          "25:   int result, i;",
          "26:   char buf1[1024];",
          "27:   char buf2[1024];",
          "29:   result = srs_forward(srs, buf1, sizeof(buf1), address, domain);",
          "30:   if (result != SRS_SUCCESS)",
          "31:   {",
          "32:     printf(\"srs_forward(\\\"%s\\\", \\\"%s\\\") = %d (EXPECTED: 0)\\n\", address, domain, result);",
          "33:     return 0;",
          "34:   }",
          "35:   result = srs_reverse(srs, buf2, sizeof(buf2), buf1);",
          "36:   if (result != SRS_SUCCESS)",
          "37:   {",
          "38:     printf(\"srs_reverse(\\\"%s\\\") = %d\\n (EXPECTED: 0)\", buf1, result);",
          "39:     return 0;",
          "40:   }",
          "41:   if (strcasecmp(address, buf2))",
          "42:   {",
          "43:     printf(\"SRS not idempotent: \\\"%s\\\" != \\\"%s\\\"\\n\", address, buf2);",
          "44:     return 0;",
          "45:   }",
          "47:   i = strchr(buf1, '@') - buf1;",
          "48:   while (i > 0)",
          "49:   {",
          "50:     --i;",
          "51:     buf1[i]++;",
          "53:     if (result == SRS_SUCCESS) {",
          "54:       printf(\"srs_reverse(\\\"%s\\\") = %d\\n (EXPECTED: != 0)\", buf1, result);",
          "55:       return 0;",
          "57:     buf1[i]--;",
          "58:   }",
          "59:   return 1;",
          "62: static void generate_random_address(char* buf, size_t len1, size_t len2)",
          "64:   static const char chars[] = \"abcdefghijklmnopqrstuvwxyz0123456789-+=\";",
          "65:   size_t i = 0, l1 = len1, l2 = len2;",
          "66:   while (l1 > 0)",
          "67:   {",
          "68:     buf[i++] = chars[random() % 39];",
          "69:     if (l1 < len1 && l1 > 1 && buf[i - 1] != '.' && (random() % 16 == 0)) buf[i - 1] = '.';",
          "70:     --l1;",
          "71:   }",
          "72:   buf[i++] = '@';",
          "73:   while (l2 > 0)",
          "74:   {",
          "75:     buf[i++] = 'a' + random() % 26;",
          "76:     if (l2 < len2 && l2 > 1 && buf[i - 1] != '.' && (random() % 16 == 0)) buf[i - 1] = '.';",
          "77:     --l2;",
          "78:   }",
          "79:   buf[i++] = 0;",
          "82: #define ASSERT_SRS_OK(...) if (!run_srs(srs, __VA_ARGS__)) exit(EXIT_FAILURE);",
          "84: static void run_tests_with_secret(const char* secret)",
          "86:   srs_t* srs;",
          "87:   size_t l1, l2;",
          "88:   char addr[128];",
          "90:   srs = srs_new();",
          "91:   printf(\"Testing with secret '%s'\\n\", secret);",
          "92:   srs_add_secret (srs, secret);",
          "93:   srs_set_hashlength(srs, 16);",
          "95:   for (l1 = 1; l1 <= 63; ++l1)",
          "96:   {",
          "97:     for (l2 = 1; l2 <= 63; ++l2)",
          "99:       generate_random_address(addr, l1, l2);",
          "100:       ASSERT_SRS_OK(addr, \"example.com\");",
          "102:   }",
          "103:   srs_free(srs);",
          "106: int main (int argc, char** argv)",
          "108:   run_tests_with_secret(\"tops3cr3t\");",
          "109:   run_tests_with_secret(\"string that has 119 bytes, which is excessively long from an operational point of view but should still work regardless\");",
          "110:   return EXIT_SUCCESS;",
          "",
          "[Added Lines]",
          "24: static int run_srs(srs_t *srs, const char *address, const char *domain)",
          "26:     int result, i;",
          "27:     char buf1[1024];",
          "28:     char buf2[1024];",
          "30:     result = srs_forward(srs, buf1, sizeof(buf1), address, domain);",
          "31:     if (result != SRS_SUCCESS)",
          "32:     {",
          "33:         printf(\"srs_forward(\\\"%s\\\", \\\"%s\\\") = %d (EXPECTED: 0)\\n\", address,",
          "34:                domain, result);",
          "35:         return 0;",
          "36:     }",
          "38:     if (result != SRS_SUCCESS)",
          "39:     {",
          "40:         printf(\"srs_reverse(\\\"%s\\\") = %d\\n (EXPECTED: 0)\", buf1, result);",
          "41:         return 0;",
          "42:     }",
          "43:     if (strcasecmp(address, buf2))",
          "44:     {",
          "45:         printf(\"SRS not idempotent: \\\"%s\\\" != \\\"%s\\\"\\n\", address, buf2);",
          "46:         return 0;",
          "49:     i = strchr(buf1, '@') - buf1;",
          "50:     while (i > 0)",
          "51:     {",
          "52:         --i;",
          "53:         buf1[i]++;",
          "54:         result = srs_reverse(srs, buf2, sizeof(buf2), buf1);",
          "55:         if (result == SRS_SUCCESS)",
          "56:         {",
          "57:             printf(\"srs_reverse(\\\"%s\\\") = %d\\n (EXPECTED: != 0)\", buf1, result);",
          "58:             return 0;",
          "59:         }",
          "60:         buf1[i]--;",
          "61:     }",
          "62:     return 1;",
          "65: static void generate_random_address(char *buf, size_t len1, size_t len2)",
          "67:     static const char chars[] = \"abcdefghijklmnopqrstuvwxyz0123456789-+=\";",
          "68:     size_t i = 0, l1 = len1, l2 = len2;",
          "69:     while (l1 > 0)",
          "70:     {",
          "71:         buf[i++] = chars[random() % 39];",
          "72:         if (l1 < len1 && l1 > 1 && buf[i - 1] != '.' && (random() % 16 == 0))",
          "73:             buf[i - 1] = '.';",
          "74:         --l1;",
          "75:     }",
          "76:     buf[i++] = '@';",
          "77:     while (l2 > 0)",
          "78:     {",
          "79:         buf[i++] = 'a' + random() % 26;",
          "80:         if (l2 < len2 && l2 > 1 && buf[i - 1] != '.' && (random() % 16 == 0))",
          "81:             buf[i - 1] = '.';",
          "82:         --l2;",
          "83:     }",
          "84:     buf[i++] = 0;",
          "87: #define ASSERT_SRS_OK(...)          \\",
          "88:     if (!run_srs(srs, __VA_ARGS__)) \\",
          "89:         exit(EXIT_FAILURE);",
          "91: static void run_tests_with_secret(const char *secret)",
          "93:     srs_t *srs;",
          "94:     size_t l1, l2;",
          "95:     char addr[128];",
          "97:     srs = srs_new();",
          "98:     printf(\"Testing with secret '%s'\\n\", secret);",
          "99:     srs_add_secret(srs, secret);",
          "100:     srs_set_hashlength(srs, 16);",
          "102:     for (l1 = 1; l1 <= 63; ++l1)",
          "104:         for (l2 = 1; l2 <= 63; ++l2)",
          "105:         {",
          "106:             generate_random_address(addr, l1, l2);",
          "107:             ASSERT_SRS_OK(addr, \"example.com\");",
          "108:         }",
          "110:     srs_free(srs);",
          "113: int main(int argc, char **argv)",
          "115:     run_tests_with_secret(\"tops3cr3t\");",
          "116:     run_tests_with_secret(",
          "117:         \"string that has 119 bytes, which is excessively long from an \"",
          "118:         \"operational point of view but should still work regardless\");",
          "119:     return EXIT_SUCCESS;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "805dfc8ae823648694459d4d2f9605655ff4d6dc",
      "candidate_info": {
        "commit_hash": "805dfc8ae823648694459d4d2f9605655ff4d6dc",
        "repo": "roehling/postsrsd",
        "commit_url": "https://github.com/roehling/postsrsd/commit/805dfc8ae823648694459d4d2f9605655ff4d6dc",
        "files": [
          "postsrsd.c"
        ],
        "message": "Fix a few messages for consistency",
        "before_after_code_files": [
          "postsrsd.c||postsrsd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "postsrsd.c||postsrsd.c"
          ],
          "candidate": [
            "postsrsd.c||postsrsd.c"
          ]
        }
      },
      "candidate_diff": {
        "postsrsd.c||postsrsd.c": [
          "File: postsrsd.c -> postsrsd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:     len = strlen(*excludes);",
          "169:     if (len >= addrlen) continue;",
          "170:     if (strcasecmp(*excludes, &address[addrlen - len]) == 0 && (**excludes == '.' || address[addrlen - len - 1] == '@')) {",
          "172:       fflush (fp);",
          "173:       return;",
          "174:     }",
          "175:   }",
          "176:   if (srs_reverse(srs, value, sizeof(value), address) == SRS_SUCCESS)",
          "177:   {",
          "179:     fflush (fp);",
          "181:     return;",
          "182:   }",
          "183:   result = srs_forward(srs, value, sizeof(value), address, domain);",
          "",
          "[Removed Lines]",
          "171:       fputs (\"500 Domain excluded from SRS\\n\", fp);",
          "178:     fprintf (fp, \"500 already rewritten\\n\");",
          "180:     syslog (LOG_MAIL | LOG_NOTICE, \"srs_forward: not rewriting <%s> again (original address: <%s>)\", address, value);",
          "",
          "[Added Lines]",
          "171:       syslog (LOG_MAIL | LOG_INFO, \"srs_forward: <%s> not rewritten: Domain excluded by policy\", address);",
          "172:       fputs (\"500 Domain excluded py policy\\n\", fp);",
          "179:     fprintf (fp, \"500 Already rewritten\\n\");",
          "181:     syslog (LOG_MAIL | LOG_NOTICE, \"srs_forward: <%s> not rewritten: Valid SRS address for <%s>\", address, value);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "562:               return EXIT_FAILURE;",
          "563:             }",
          "564:             key = url_decode(keybuf, sizeof(keybuf), token);",
          "566:             handler[sc](srs, fp, key, domain, excludes);",
          "567:             fflush (fp);",
          "568:             if (poll(fds, 1, timeout * 1000) <= 0) break;",
          "",
          "[Removed Lines]",
          "565:             if (!key) break;",
          "",
          "[Added Lines]",
          "566:             if (!key) {",
          "567:               fprintf (fp, \"500 Invalid request\\n\");",
          "568:               fflush(fp);",
          "569:               return EXIT_FAILURE;",
          "570:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
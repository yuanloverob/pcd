{
  "cve_id": "CVE-2019-20218",
  "cve_desc": "selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.",
  "repo": "sqlite/sqlite",
  "patch_hash": "a6c1a71cde082e09750465d5675699062922e387",
  "patch_info": {
    "commit_hash": "a6c1a71cde082e09750465d5675699062922e387",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/a6c1a71cde082e09750465d5675699062922e387",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/altertab3.test"
    ],
    "message": "Do not attempt to unwind the WITH stack in the Parse object following an error. This fixes a separate case to [de6e6d68].\n\nFossilOrigin-Name: d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/altertab3.test||test/altertab3.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 597896ed0ae9e2960a8f39576bd7f77a11dccc1da84b6a44ebb5c38d90ebc330",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4982:     return WRC_Abort;",
      "4983:   }",
      "",
      "[Removed Lines]",
      "4981:   if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "[Added Lines]",
      "4981:   if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "---------------"
    ],
    "test/altertab3.test||test/altertab3.test": [
      "File: test/altertab3.test -> test/altertab3.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "531:   ALTER TABLE t1 RENAME TO t1x;",
      "532: } {1 {error in trigger r1: no such table: main.t2}}",
      "534: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "534: #------------------------------------------------------------------------",
      "535: #",
      "536: reset_db",
      "537: do_execsql_test 23.1 {",
      "538:   CREATE TABLE v0 (a);",
      "539:   CREATE VIEW v2 (v3) AS",
      "540:     WITH x1 AS (SELECT * FROM v2)",
      "541:     SELECT v3 AS x, v3 AS y FROM v2;",
      "542: }",
      "544: do_catchsql_test 23.2 {",
      "545:   SELECT * FROM v2",
      "546: } {1 {view v2 is circularly defined}}",
      "548: db close",
      "549: sqlite3 db test.db",
      "551: do_catchsql_test 23.3 {",
      "552:   ALTER TABLE v0 RENAME TO t3 ;",
      "553: } {1 {error in view v2: view v2 is circularly defined}}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7ec796d00228854511e3e19772a477e19c99aaac",
      "candidate_info": {
        "commit_hash": "7ec796d00228854511e3e19772a477e19c99aaac",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/7ec796d00228854511e3e19772a477e19c99aaac",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "test/in.test"
        ],
        "message": "Add ALWAYS() to an always true conditional that results from the previous check-in.  Add a test case for ticket [dbaf8a6820be1ece] to supplement those already checked into TH3.\n\nFossilOrigin-Name: aff209804722ac902c7abfde80ad2677e0f51beb2c7f28f65d51105d984a1640",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "test/in.test||test/in.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7f5168a76a400fc2e1e40c6950470b1bfb38a0be54fc5518c17c29fdae7d8f1f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "802:         idxCols |= cMask;",
          "803:         pIdx->aiColumn[n] = pTerm->u.leftColumn;",
          "804:         pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);",
          "806:         n++;",
          "807:       }",
          "808:     }",
          "",
          "[Removed Lines]",
          "805:         pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;",
          "",
          "[Added Lines]",
          "805:         pIdx->azColl[n] = ALWAYS(pColl) ? pColl->zName : sqlite3StrBINARY;",
          "",
          "---------------"
        ],
        "test/in.test||test/in.test": [
          "File: test/in.test -> test/in.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "750:   SELECT 1 IN (CAST('1' AS text) COLLATE nocase);",
          "751: } 0",
          "753: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753: # 2019-08-27 ticket https://sqlite.org/src/info/dbaf8a6820be1ece",
          "754: #",
          "755: do_execsql_test in-18.1 {",
          "756:   DROP TABLE IF EXISTS t0;",
          "757:   CREATE TABLE t0(c0 INT UNIQUE);",
          "758:   INSERT INTO t0(c0) VALUES (1);",
          "759:   SELECT * FROM t0 WHERE '1' IN (t0.c0);",
          "760: } {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "42ebb01e9fd94c94d4f90b0a59b46194aea28400",
      "candidate_info": {
        "commit_hash": "42ebb01e9fd94c94d4f90b0a59b46194aea28400",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/42ebb01e9fd94c94d4f90b0a59b46194aea28400",
        "files": [
          "ext/misc/dbdata.c",
          "manifest",
          "manifest.uuid",
          "src/shell.c.in",
          "test/recover.test"
        ],
        "message": "Add the \"--lost-and-found\" option to the \".recover\" command. For setting the name of the orphaned rows table.\n\nFossilOrigin-Name: 67bb88e24c74d02ae0c4ac6ff2f873f6b0035ccefe5cccfc71c5686cbc76b4c3",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in",
          "test/recover.test||test/recover.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112: };",
          "114: #define DBDATA_COLUMN_PGNO        0",
          "115: #define DBDATA_COLUMN_CELL        1",
          "116: #define DBDATA_COLUMN_FIELD       2",
          "117: #define DBDATA_COLUMN_VALUE       3",
          "118: #define DBDATA_COLUMN_SCHEMA      4",
          "124: #define DBDATA_SCHEMA             \\",
          "125:       \"CREATE TABLE x(\"           \\",
          "126:       \"  pgno INTEGER,\"           \\",
          "",
          "[Removed Lines]",
          "120: #define DBPTR_COLUMN_PGNO         0",
          "121: #define DBPTR_COLUMN_CHILD        1",
          "122: #define DBPTR_COLUMN_SCHEMA       2",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:       \"  schema TEXT HIDDEN\"      \\",
          "131:       \")\"",
          "133: #define DBPTR_SCHEMA              \\",
          "134:       \"CREATE TABLE x(\"           \\",
          "135:       \"  pgno INTEGER,\"           \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: #define DBPTR_COLUMN_PGNO         0",
          "138: #define DBPTR_COLUMN_CHILD        1",
          "139: #define DBPTR_COLUMN_SCHEMA       2",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "289:   return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|a[3];",
          "290: }",
          "292: static int dbdataLoadPage(",
          "297: ){",
          "298:   int rc2;",
          "299:   int rc = SQLITE_OK;",
          "",
          "[Removed Lines]",
          "293:   DbdataCursor *pCsr,",
          "294:   u32 pgno,",
          "295:   u8 **ppPage,",
          "296:   int *pnPage",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 91df4b8e0386105d01614921e8410994b621404a3d46ec4af8687b8743c52d52",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "3577:   \".prompt MAIN CONTINUE    Replace the standard prompts\",",
          "3578:   \".quit                    Exit this program\",",
          "3579:   \".read FILE               Read input from FILE\",",
          "3580:   \".restore ?DB? FILE       Restore content of DB (default \\\"main\\\") from FILE\",",
          "3581:   \".save FILE               Write in-memory database into FILE\",",
          "3582:   \".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3579:   \".recover                 Recover as much data as possible from corrupt db.\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6208:   return z;",
          "6209: }",
          "6211: typedef struct RecoverTable RecoverTable;",
          "6212: struct RecoverTable {",
          "6218: };",
          "6223: static void recoverFreeTable(RecoverTable *pTab){",
          "6224:   if( pTab ){",
          "6226:     sqlite3_free(pTab->zQuoted);",
          "6227:     if( pTab->azlCol ){",
          "6228:       int i;",
          "",
          "[Removed Lines]",
          "6217:   int iPk;",
          "6225:     sqlite3_free(pTab->zName);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6235:   }",
          "6236: }",
          "",
          "[Removed Lines]",
          "6238: static RecoverTable *recoverOldTable(",
          "",
          "[Added Lines]",
          "6275: static RecoverTable *recoverNewTable(",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6309:         }",
          "6310:       }",
          "6314:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * (nSqlCol+1));",
          "6315:       pTab->nCol = nSqlCol;",
          "",
          "[Removed Lines]",
          "6312:       pTab->zName = shellMPrintf(&rc, \"%s\", zName);",
          "6313:       pTab->zQuoted = shellMPrintf(&rc, \"%Q\", pTab->zName);",
          "",
          "[Added Lines]",
          "6349:       pTab->zQuoted = shellMPrintf(&rc, \"%Q\", zName);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6349:   return pTab;",
          "6350: }",
          "6353:   ShellState *pState,",
          "6354:   int *pRc,",
          "6355:   int iRoot,",
          "",
          "[Removed Lines]",
          "6352: static RecoverTable *recoverNewTable(",
          "",
          "[Added Lines]",
          "6388: static RecoverTable *recoverFindTable(",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6377:     if( sqlite3_stricmp(zType, \"table\")==0 ){",
          "6378:       zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6379:       zSql = (const char*)sqlite3_column_text(pStmt, 2);",
          "6381:       break;",
          "6382:     }",
          "6383:   }",
          "",
          "[Removed Lines]",
          "6380:       pRet = recoverOldTable(pRc, zName, zSql, bIntkey, nCol);",
          "",
          "[Added Lines]",
          "6415:       pRet = recoverNewTable(pRc, zName, zSql, bIntkey, nCol);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6390: static RecoverTable *recoverOrphanTable(",
          "6391:   ShellState *pState,",
          "6392:   int *pRc,",
          "6393:   int nCol",
          "6394: ){",
          "6395:   RecoverTable *pTab = 0;",
          "6396:   if( nCol>=0 && *pRc==SQLITE_OK ){",
          "6397:     int i;",
          "6401:     );",
          "6404:     }",
          "6407:     pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6408:     if( pTab ){",
          "6411:       pTab->nCol = nCol;",
          "6412:       pTab->iPk = -2;",
          "6413:       if( nCol>0 ){",
          "",
          "[Removed Lines]",
          "6398:     raw_printf(pState->out,",
          "6399:         \"CREATE TABLE recover_orphan(rootpgno INTEGER, \"",
          "6400:         \"pgno INTEGER, nfield INTEGER, id INTEGER\"",
          "6402:     for(i=0; i<nCol; i++){",
          "6403:       raw_printf(pState->out, \", c%d\", i);",
          "6405:     raw_printf(pState->out, \");\\n\");",
          "6409:       pTab->zName = shellMPrintf(pRc, \"%s\", \"recover_orphan\");",
          "6410:       pTab->zQuoted = shellMPrintf(pRc, \"%Q\", pTab->zName);",
          "",
          "[Added Lines]",
          "6428:   const char *zLostAndFound,",
          "6439:     int iTab = 0;",
          "6440:     char *zTab = shellMPrintf(pRc, \"%s\", zLostAndFound);",
          "6441:     sqlite3_stmt *pTest = 0;",
          "6442:     shellPrepare(pState->db, pRc,",
          "6443:         \"SELECT 1 FROM recovery.schema WHERE name=?\", &pTest",
          "6445:     if( pTest ) sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6446:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pTest) ){",
          "6447:       shellReset(pRc, pTest);",
          "6448:       sqlite3_free(zTab);",
          "6449:       zTab = shellMPrintf(pRc, \"%s_%d\", zLostAndFound, iTab++);",
          "6450:       sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6452:     shellFinalize(pRc, pTest);",
          "6456:       pTab->zQuoted = shellMPrintf(pRc, \"%Q\", zTab);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6419:           }",
          "6420:         }",
          "6421:       }",
          "6427:     }",
          "6428:   }",
          "6429:   return pTab;",
          "6430: }",
          "",
          "[Removed Lines]",
          "6422:     }",
          "6424:     if( *pRc!=SQLITE_OK ){",
          "6425:       recoverFreeTable(pTab);",
          "6426:       pTab = 0;",
          "",
          "[Added Lines]",
          "6469:       if( *pRc!=SQLITE_OK ){",
          "6470:         recoverFreeTable(pTab);",
          "6471:         pTab = 0;",
          "6472:       }else{",
          "6473:         raw_printf(pState->out,",
          "6474:             \"CREATE TABLE %s(rootpgno INTEGER, \"",
          "6475:             \"pgno INTEGER, nfield INTEGER, id INTEGER\", pTab->zQuoted",
          "6476:         );",
          "6477:         for(i=0; i<nCol; i++){",
          "6478:           raw_printf(pState->out, \", c%d\", i);",
          "6479:         }",
          "6480:         raw_printf(pState->out, \");\\n\");",
          "6481:       }",
          "6483:     sqlite3_free(zTab);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6443:   int i;",
          "6444:   int nOrphan = -1;",
          "6445:   RecoverTable *pOrphan = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6499:   const char *zLostAndFound = \"lost_and_found\";",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6452:     n = strlen(z);",
          "6453:     if( n<=17 && memcmp(\"-freelist-corrupt\", z, n)==0 ){",
          "6454:       bFreelist = 0;",
          "6456:     if( n<=12 && memcmp(\"-recovery-db\", z, n)==0 && i<(nArg-1) ){",
          "6457:       i++;",
          "6458:       zRecoveryDb = azArg[i];",
          "6459:     }",
          "6460:     else{",
          "6461:       raw_printf(stderr, \"unexpected option: %s\\n\", azArg[i]);",
          "6462:       raw_printf(stderr, \"options are:\\n\");",
          "6463:       raw_printf(stderr, \"    --freelist-corrupt\\n\");",
          "6464:       raw_printf(stderr, \"    --recovery-db DATABASE\\n\");",
          "6465:       return 1;",
          "6466:     }",
          "6467:   }",
          "",
          "[Removed Lines]",
          "6455:     }",
          "",
          "[Added Lines]",
          "6512:     }else",
          "6516:     }else",
          "6517:     if( n<=15 && memcmp(\"-lost-and-found\", z, n)==0 && i<(nArg-1) ){",
          "6518:       i++;",
          "6519:       zLostAndFound = azArg[i];",
          "6526:       raw_printf(stderr, \"    --lost-and-found TABLE-NAME\\n\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6599:   }",
          "6600:   shellFinalize(&rc, pLoop);",
          "6601:   pLoop = 0;",
          "6604:   shellPrepare(pState->db, &rc,",
          "6605:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "",
          "[Removed Lines]",
          "6602:   pOrphan = recoverOrphanTable(pState, &rc, nOrphan);",
          "",
          "[Added Lines]",
          "6664:   pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "6624:     int bNoop = 0;",
          "6625:     RecoverTable *pTab;",
          "6628:     if( bNoop || rc ) continue;",
          "6629:     if( pTab==0 ) pTab = pOrphan;",
          "6632:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6633:     }",
          "6634:     sqlite3_bind_int(pPages, 1, iRoot);",
          "",
          "[Removed Lines]",
          "6627:     pTab = recoverNewTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6631:     if( 0==sqlite3_stricmp(pTab->zName, \"sqlite_sequence\") ){",
          "",
          "[Added Lines]",
          "6689:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6693:     if( 0==sqlite3_stricmp(pTab->zQuoted, \"'sqlite_sequence'\") ){",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7042:     p->nErr = 0;",
          "7043:     if( zLike==0 ){",
          "7044:       run_schema_dump_query(p,",
          "7048:       run_schema_dump_query(p,",
          "7052:       run_table_dump_query(p,",
          "7056:     }else{",
          "7057:       char *zSql;",
          "7058:       zSql = sqlite3_mprintf(",
          "7062:       run_schema_dump_query(p,zSql);",
          "7063:       sqlite3_free(zSql);",
          "7064:       zSql = sqlite3_mprintf(",
          "7069:       run_table_dump_query(p, zSql, 0);",
          "7070:       sqlite3_free(zSql);",
          "7071:     }",
          "",
          "[Removed Lines]",
          "7045:           \"SELECT name, type, sql FROM sqlite_master \"",
          "7046:           \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "7047:           );",
          "7049:           \"SELECT name, type, sql FROM sqlite_master \"",
          "7050:           \"WHERE name=='sqlite_sequence'\"",
          "7051:           );",
          "7053:           \"SELECT sql FROM sqlite_master \"",
          "7054:           \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "7055:           );",
          "7059:           \"SELECT name, type, sql FROM sqlite_master \"",
          "7060:           \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "7061:           \"  AND sql NOT NULL\", zLike);",
          "7065:           \"SELECT sql FROM sqlite_master \"",
          "7066:           \"WHERE sql NOT NULL\"",
          "7067:           \"  AND type IN ('index','trigger','view')\"",
          "7068:           \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "[Added Lines]",
          "7107:         \"SELECT name, type, sql FROM sqlite_master \"",
          "7108:         \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "7109:       );",
          "7111:         \"SELECT name, type, sql FROM sqlite_master \"",
          "7112:         \"WHERE name=='sqlite_sequence'\"",
          "7113:       );",
          "7115:         \"SELECT sql FROM sqlite_master \"",
          "7116:         \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "7117:       );",
          "7121:         \"SELECT name, type, sql FROM sqlite_master \"",
          "7122:         \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "7123:         \"  AND sql NOT NULL\", zLike);",
          "7127:         \"SELECT sql FROM sqlite_master \"",
          "7128:         \"WHERE sql NOT NULL\"",
          "7129:         \"  AND type IN ('index','trigger','view')\"",
          "7130:         \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "---------------"
        ],
        "test/recover.test||test/recover.test": [
          "File: test/recover.test -> test/recover.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:   }",
          "40: }",
          "43:   set fd [open \"|$::CLI test.db .recover\"]",
          "44:   fconfigure $fd -encoding binary",
          "45:   fconfigure $fd -translation binary",
          "",
          "[Removed Lines]",
          "42: proc do_recover_test {tn} {",
          "",
          "[Added Lines]",
          "42: proc do_recover_test {tn {tsql {}} {res {}}} {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:   forcedelete test.db2",
          "50:   sqlite3 db2 test.db2",
          "52:   execsql $sql db2",
          "54:   db2 close",
          "55: }",
          "",
          "[Removed Lines]",
          "51:   breakpoint",
          "53:   uplevel [list do_test $tn [list compare_dbs db db2] {}]",
          "",
          "[Added Lines]",
          "52:   if {$tsql==\"\"} {",
          "53:     uplevel [list do_test $tn [list compare_dbs db db2] {}]",
          "54:   } else {",
          "55:     uplevel [list do_execsql_test -db db2 $tn $tsql $res]",
          "56:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97: do_recover_test 2.1.1",
          "99: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: do_execsql_test 2.2.0 {",
          "103:   PRAGMA writable_schema = 1;",
          "104:   DELETE FROM sqlite_master WHERE name='t1';",
          "105: }",
          "106: do_recover_test 2.2.1 {",
          "107:   SELECT name FROM sqlite_master",
          "108: } {lost_and_found}",
          "110: do_execsql_test 2.3.0 {",
          "111:   CREATE TABLE lost_and_found(a, b, c);",
          "112: }",
          "113: do_recover_test 2.3.1 {",
          "114:   SELECT name FROM sqlite_master",
          "115: } {lost_and_found lost_and_found_0}",
          "117: do_execsql_test 2.4.0 {",
          "118:   CREATE TABLE lost_and_found_0(a, b, c);",
          "119: }",
          "120: do_recover_test 2.4.1 {",
          "121:   SELECT name FROM sqlite_master;",
          "122:   SELECT * FROM lost_and_found_1;",
          "123: } {lost_and_found lost_and_found_0 lost_and_found_1",
          "124:   2 2 3 {} 2 3 1",
          "125:   2 2 3 {} 5 6 4",
          "126:   2 2 3 {} 8 9 7",
          "127: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "14c865e8592ff73e1e1ca2070ff660771ba20e78",
      "candidate_info": {
        "commit_hash": "14c865e8592ff73e1e1ca2070ff660771ba20e78",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/14c865e8592ff73e1e1ca2070ff660771ba20e78",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "test/indexexpr1.test"
        ],
        "message": "Fix the sqliteExprImpliesExpr() routine so that it recognizes that \"(NULL IS FALSE) IS FALSE\" doe not implie \"NULL NOT NULL\". Ticket [9080b6227fabb466]\n\nFossilOrigin-Name: da01ba4fa47c6508b31533ccd769e637af04bd37f51463372fbc6c848d892a4d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "test/indexexpr1.test||test/indexexpr1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3c690b2b05b7338f3325c50a0750c6023e1173afa4388e836ecb2cc49f19a0ac",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4938: ){",
          "4939:   assert( p );",
          "4940:   assert( pNN );",
          "4942:   switch( p->op ){",
          "4943:     case TK_IN: {",
          "4944:       if( seenNot && ExprHasProperty(p, EP_xIsSelect) ) return 0;",
          "",
          "[Removed Lines]",
          "4941:   if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ) return 1;",
          "",
          "[Added Lines]",
          "4941:   if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){",
          "4942:     return pNN->op!=TK_NULL;",
          "4943:   }",
          "",
          "---------------"
        ],
        "test/indexexpr1.test||test/indexexpr1.test": [
          "File: test/indexexpr1.test -> test/indexexpr1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "445:   SELECT b FROM t1 WHERE lower(a)='01234' ORDER BY +b;",
          "446: } {}",
          "449: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "448: # 2019-08-09 https://www.sqlite.org/src/info/9080b6227fabb466",
          "449: # ExprImpliesExpr theorem prover bug:",
          "450: # \"(NULL IS FALSE) IS FALSE\" does not imply \"NULL IS NULL\"",
          "451: #",
          "452: do_execsql_test indexexpr-1700 {",
          "453:   DROP TABLE IF EXISTS t0;",
          "454:   CREATE TABLE t0(c0);",
          "455:   INSERT INTO t0(c0) VALUES (0);",
          "456:   CREATE INDEX i0 ON t0(NULL > c0) WHERE (NULL NOT NULL);",
          "457:   SELECT * FROM t0 WHERE ((NULL IS FALSE) IS FALSE);",
          "458: } {0}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8451e1fa27815a1f63ad90aca751469db120973f",
      "candidate_info": {
        "commit_hash": "8451e1fa27815a1f63ad90aca751469db120973f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/8451e1fa27815a1f63ad90aca751469db120973f",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/corruptL.test"
        ],
        "message": "Add a test case for the assert() fix in the previous commit.\n\nFossilOrigin-Name: 32fba11ab72f6300391267eaad64e92fa767c289029e668e4bd6c9165acf1487",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/corruptL.test||test/corruptL.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 69a26eade2f92029e722a5a654214b1e2a3fc7ed497ce9aa5a7dce944f90e502",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/corruptL.test||test/corruptL.test": [
          "File: test/corruptL.test -> test/corruptL.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1071:   DELETE FROM t3 WHERE x IN (SELECT x FROM t4);",
          "1072: } {1 {database disk image is malformed}}",
          "1074: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1074: #-------------------------------------------------------------------------",
          "1075: reset_db",
          "1076: do_test 12.0 {",
          "1077:   sqlite3 db {}",
          "1078:   db deserialize [decode_hexdb {",
          "1079: | size 12288 pagesize 4096 filename crash-e6d070858a3a85.db",
          "1080: | page 1 offset 0",
          "1081: |      0: 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00   SQLite format 3.",
          "1082: |     16: 10 00 01 01 00 40 20 20 00 00 00 00 00 00 00 00   .....@  ........",
          "1083: |     96: 00 00 00 00 0d 00 00 00 02 0f 8f 00 0f bf 0f 8f   ................",
          "1084: |   3968: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2e   ................",
          "1085: |   3984: 02 06 17 15 11 01 45 69 6e 64 65 78 74 31 63 62   ......Eindext1cb",
          "1086: |   4000: 74 31 03 43 52 45 41 54 45 20 49 4e 44 45 58 20   t1.CREATE INDEX",
          "1087: |   4016: 74 31 63 62 20 4f 4e 20 74 31 28 63 2c 62 29 3f   t1cb ON t1(c,b)?",
          "1088: |   4032: 01 06 17 11 11 01 6b 74 61 62 6c 65 74 31 74 31   ......ktablet1t1",
          "1089: |   4048: 02 43 52 45 41 54 45 20 54 41 42 4c 45 20 74 31   .CREATE TABLE t1",
          "1090: |   4064: 28 61 20 49 4e 54 2c 20 62 20 49 4e 54 2c 20 43   (a INT, b INT, C",
          "1091: |   4080: 20 49 4e 54 20 44 45 46 41 55 4c 54 20 31 36 29    INT DEFAULT 16)",
          "1092: | page 2 offset 4096",
          "1093: |      0: 0d 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................",
          "1094: |   4000: 00 00 00 00 00 00 00 00 07 0b 04 01 01 01 63 63   ..............cc",
          "1095: |   4016: 11 05 0a 04 00 00 01 11 05 09 04 08 08 01 0f 05   ................",
          "1096: |   4032: 08 04 00 00 01 01 56 07 04 01 08 01 07 10 07 06   ......V.........",
          "1097: |   4048: 14 01 01 01 06 08 10 06 05 04 f5 00 01 05 10 07   ................",
          "1098: |   4064: 04 04 01 01 01 04 03 10 06 03 04 01 09 01 03 10   ................",
          "1099: |   4080: 06 02 04 01 00 01 02 10 06 01 04 09 01 01 02 10   ................",
          "1100: | page 3 offset 8192",
          "1101: |      0: 0a 00 00 00 0b 0f b0 00 0f f9 0f f2 0f eb 0f e4   ................",
          "1102: |     16: 0f dd 0f d6 0f 9f 0f c7 0f be 00 00 00 00 00 00   ................",
          "1103: |   4016: 07 04 01 01 01 11 e2 0b 06 04 91 00 01 11 0a 07   ................",
          "1104: |   4032: 04 01 01 01 10 08 06 07 04 01 01 01 10 04 04 06   ................",
          "1105: |   4048: 04 01 01 09 10 02 06 04 01 0a 01 10 00 00 00 00   ................",
          "1106: | end crash-e6d070858a3a85.db",
          "1107: }]} {}",
          "1109: do_catchsql_test 12.1 {",
          "1110:   SELECT CAST((SELECT b FROM t1 WHERE 16=c) AS int) FROM t1 WHERE 16=c;",
          "1111: } {1 {database disk image is malformed}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a0536ab0faa89601c2bf14bc192746fc23d09d1",
      "candidate_info": {
        "commit_hash": "0a0536ab0faa89601c2bf14bc192746fc23d09d1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/0a0536ab0faa89601c2bf14bc192746fc23d09d1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Make the \".schema\" command in the CLI resistant to corrupt database files.\n\nFossilOrigin-Name: f22c7e229ea4626c5268d61de3964521cf6a2735290cbd1518d68731ba6cca90",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3eae4e301e3e4bcf14e96066f77be1434c5d4b3daadb10153cd36382589ac128",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "1683: static void printSchemaLine(FILE *out, const char *z, const char *zTail){",
          "1684:   if( sqlite3_strglob(\"CREATE TABLE ['\\\"]*\", z)==0 ){",
          "1685:     utf8_printf(out, \"CREATE TABLE IF NOT EXISTS %s%s\", z+13, zTail);",
          "1686:   }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1684:   if( z==0 ) return;",
          "1685:   if( zTail==0 ) return;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-6621",
  "cve_desc": "The decode_frame function in libavcodec/utvideodec.c in FFmpeg through 3.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "118e1b0b3370dd1c0da442901b486689efd1654b",
  "patch_info": {
    "commit_hash": "118e1b0b3370dd1c0da442901b486689efd1654b",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/118e1b0b3370dd1c0da442901b486689efd1654b",
    "files": [
      "libavcodec/utvideodec.c"
    ],
    "message": "avcodec/utvideodec: Fix bytes left check in decode_frame()\n\nFixes: out of array read\nFixes: poc-2017.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
      "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "676:             for (j = 0; j < c->slices; j++) {",
      "677:                 slice_end   = bytestream2_get_le32u(&gb);",
      "678:                 if (slice_end < 0 || slice_end < slice_start ||",
      "680:                     av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");",
      "681:                     return AVERROR_INVALIDDATA;",
      "682:                 }",
      "",
      "[Removed Lines]",
      "679:                     bytestream2_get_bytes_left(&gb) < slice_end) {",
      "",
      "[Added Lines]",
      "679:                     bytestream2_get_bytes_left(&gb) < slice_end + 1024LL) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "342f1da13489de6650349fff2206a81442d6c668",
      "candidate_info": {
        "commit_hash": "342f1da13489de6650349fff2206a81442d6c668",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/342f1da13489de6650349fff2206a81442d6c668",
        "files": [
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideodec: Fix bytes left check in decode_frame()\n\nFixes: out of array read\nFixes: poc-2017.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 118e1b0b3370dd1c0da442901b486689efd1654b)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "561:             for (j = 0; j < c->slices; j++) {",
          "562:                 slice_end   = bytestream2_get_le32u(&gb);",
          "563:                 if (slice_end < 0 || slice_end < slice_start ||",
          "565:                     av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");",
          "566:                     return AVERROR_INVALIDDATA;",
          "567:                 }",
          "",
          "[Removed Lines]",
          "564:                     bytestream2_get_bytes_left(&gb) < slice_end) {",
          "",
          "[Added Lines]",
          "564:                     bytestream2_get_bytes_left(&gb) < slice_end + 1024LL) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "22aa37c0fedf14531783189a197542a055959b6c",
      "candidate_info": {
        "commit_hash": "22aa37c0fedf14531783189a197542a055959b6c",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/22aa37c0fedf14531783189a197542a055959b6c",
        "files": [
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideodec: Fix bytes left check in decode_frame()\n\nFixes: out of array read\nFixes: poc-2017.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 118e1b0b3370dd1c0da442901b486689efd1654b)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "534:             for (j = 0; j < c->slices; j++) {",
          "535:                 slice_end   = bytestream2_get_le32u(&gb);",
          "536:                 if (slice_end < 0 || slice_end < slice_start ||",
          "538:                     av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");",
          "539:                     return AVERROR_INVALIDDATA;",
          "540:                 }",
          "",
          "[Removed Lines]",
          "537:                     bytestream2_get_bytes_left(&gb) < slice_end) {",
          "",
          "[Added Lines]",
          "537:                     bytestream2_get_bytes_left(&gb) < slice_end + 1024LL) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0322f781777d4413bd57815ee9b5a7d6a0cfe716",
      "candidate_info": {
        "commit_hash": "0322f781777d4413bd57815ee9b5a7d6a0cfe716",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/0322f781777d4413bd57815ee9b5a7d6a0cfe716",
        "files": [
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideodec: Fix bytes left check in decode_frame()\n\nFixes: out of array read\nFixes: poc-2017.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 118e1b0b3370dd1c0da442901b486689efd1654b)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "638:             for (j = 0; j < c->slices; j++) {",
          "639:                 slice_end   = bytestream2_get_le32u(&gb);",
          "640:                 if (slice_end < 0 || slice_end < slice_start ||",
          "642:                     av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");",
          "643:                     return AVERROR_INVALIDDATA;",
          "644:                 }",
          "",
          "[Removed Lines]",
          "641:                     bytestream2_get_bytes_left(&gb) < slice_end) {",
          "",
          "[Added Lines]",
          "641:                     bytestream2_get_bytes_left(&gb) < slice_end + 1024LL) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "115e63c8d6791ebdc921caf40c3def024690af2e",
      "candidate_info": {
        "commit_hash": "115e63c8d6791ebdc921caf40c3def024690af2e",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/115e63c8d6791ebdc921caf40c3def024690af2e",
        "files": [
          "libavcodec/utvideo.c",
          "libavcodec/utvideo.h",
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideo: add support for UQY2\n\nSigned-off-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavcodec/utvideo.c||libavcodec/utvideo.c",
          "libavcodec/utvideo.h||libavcodec/utvideo.h",
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideo.c||libavcodec/utvideo.c": [
          "File: libavcodec/utvideo.c -> libavcodec/utvideo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:     const HuffEntry *aa = a, *bb = b;",
          "40:     return (aa->len - bb->len)*256 + aa->sym - bb->sym;",
          "41: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: int ff_ut10_huff_cmp_len(const void *a, const void *b)",
          "44: {",
          "45:     const HuffEntry *aa = a, *bb = b;",
          "46:     return (aa->len - bb->len)*1024 + aa->sym - bb->sym;",
          "47: }",
          "",
          "---------------"
        ],
        "libavcodec/utvideo.h||libavcodec/utvideo.h": [
          "File: libavcodec/utvideo.h -> libavcodec/utvideo.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:     int      compression;",
          "77:     int      interlaced;",
          "78:     int      frame_pred;",
          "80:     int      slice_stride;",
          "81:     uint8_t *slice_bits, *slice_buffer[4];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79:     int      pro;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83: } UtvideoContext;",
          "85: typedef struct HuffEntry {",
          "87:     uint8_t  len;",
          "88:     uint32_t code;",
          "89: } HuffEntry;",
          "92: int ff_ut_huff_cmp_len(const void *a, const void *b);",
          "",
          "[Removed Lines]",
          "86:     uint8_t  sym;",
          "",
          "[Added Lines]",
          "87:     uint16_t sym;",
          "94: int ff_ut10_huff_cmp_len(const void *a, const void *b);",
          "",
          "---------------"
        ],
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #include \"thread.h\"",
          "36: #include \"utvideo.h\"",
          "38: static int build_huff(const uint8_t *src, VLC *vlc, int *fsym)",
          "39: {",
          "40:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: static int build_huff10(const uint8_t *src, VLC *vlc, int *fsym)",
          "39: {",
          "40:     int i;",
          "41:     HuffEntry he[1024];",
          "42:     int last;",
          "43:     uint32_t codes[1024];",
          "44:     uint8_t bits[1024];",
          "45:     uint16_t syms[1024];",
          "46:     uint32_t code;",
          "49:     for (i = 0; i < 1024; i++) {",
          "50:         he[i].sym = i;",
          "51:         he[i].len = *src++;",
          "52:     }",
          "53:     qsort(he, 1024, sizeof(*he), ff_ut10_huff_cmp_len);",
          "55:     if (!he[0].len) {",
          "57:         return 0;",
          "58:     }",
          "60:     last = 1023;",
          "61:     while (he[last].len == 255 && last)",
          "62:         last--;",
          "64:     if (he[last].len > 32) {",
          "65:         return -1;",
          "66:     }",
          "68:     code = 1;",
          "69:     for (i = last; i >= 0; i--) {",
          "70:         codes[i] = code >> (32 - he[i].len);",
          "71:         bits[i]  = he[i].len;",
          "72:         syms[i]  = he[i].sym;",
          "73:         code += 0x80000000u >> (he[i].len - 1);",
          "74:     }",
          "76:     return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,",
          "77:                               bits,  sizeof(*bits),  sizeof(*bits),",
          "78:                               codes, sizeof(*codes), sizeof(*codes),",
          "79:                               syms,  sizeof(*syms),  sizeof(*syms), 0);",
          "80: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:                               syms,  sizeof(*syms),  sizeof(*syms), 0);",
          "79: }",
          "81: static int decode_plane(UtvideoContext *c, int plane_no,",
          "82:                         uint8_t *dst, int step, int stride,",
          "83:                         int width, int height,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125: static int decode_plane10(UtvideoContext *c, int plane_no,",
          "126:                           uint16_t *dst, int step, int stride,",
          "127:                           int width, int height,",
          "128:                           const uint8_t *src, const uint8_t *huff,",
          "129:                           int use_pred)",
          "130: {",
          "131:     int i, j, slice, pix, ret;",
          "132:     int sstart, send;",
          "133:     VLC vlc;",
          "134:     GetBitContext gb;",
          "135:     int prev, fsym;",
          "137:     if ((ret = build_huff10(huff, &vlc, &fsym)) < 0) {",
          "138:         av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");",
          "139:         return ret;",
          "140:     }",
          "141:     if (fsym >= 0) { // build_huff reported a symbol to fill slices with",
          "142:         send = 0;",
          "143:         for (slice = 0; slice < c->slices; slice++) {",
          "144:             uint16_t *dest;",
          "146:             sstart = send;",
          "147:             send   = (height * (slice + 1) / c->slices);",
          "148:             dest   = dst + sstart * stride;",
          "150:             prev = 0x200;",
          "151:             for (j = sstart; j < send; j++) {",
          "152:                 for (i = 0; i < width * step; i += step) {",
          "153:                     pix = fsym;",
          "154:                     if (use_pred) {",
          "155:                         prev += pix;",
          "156:                         pix   = prev;",
          "157:                     }",
          "158:                     dest[i] = pix;",
          "159:                 }",
          "160:                 dest += stride;",
          "161:             }",
          "162:         }",
          "163:         return 0;",
          "164:     }",
          "166:     send = 0;",
          "167:     for (slice = 0; slice < c->slices; slice++) {",
          "168:         uint16_t *dest;",
          "169:         int slice_data_start, slice_data_end, slice_size;",
          "171:         sstart = send;",
          "172:         send   = (height * (slice + 1) / c->slices);",
          "173:         dest   = dst + sstart * stride;",
          "176:         slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;",
          "177:         slice_data_end   = AV_RL32(src + slice * 4);",
          "178:         slice_size       = slice_data_end - slice_data_start;",
          "180:         if (!slice_size) {",
          "181:             av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"",
          "182:                    \"yet a slice has a length of zero.\\n\");",
          "183:             goto fail;",
          "184:         }",
          "186:         memcpy(c->slice_bits, src + slice_data_start + c->slices * 4,",
          "187:                slice_size);",
          "188:         memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);",
          "189:         c->bdsp.bswap_buf((uint32_t *) c->slice_bits,",
          "190:                           (uint32_t *) c->slice_bits,",
          "191:                           (slice_data_end - slice_data_start + 3) >> 2);",
          "192:         init_get_bits(&gb, c->slice_bits, slice_size * 8);",
          "194:         prev = 0x200;",
          "195:         for (j = sstart; j < send; j++) {",
          "196:             for (i = 0; i < width * step; i += step) {",
          "197:                 if (get_bits_left(&gb) <= 0) {",
          "198:                     av_log(c->avctx, AV_LOG_ERROR,",
          "199:                            \"Slice decoding ran out of bits\\n\");",
          "200:                     goto fail;",
          "201:                 }",
          "202:                 pix = get_vlc2(&gb, vlc.table, vlc.bits, 3);",
          "203:                 if (pix < 0) {",
          "204:                     av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");",
          "205:                     goto fail;",
          "206:                 }",
          "207:                 if (use_pred) {",
          "208:                     prev += pix;",
          "209:                     prev &= 0x3FF;",
          "210:                     pix   = prev;",
          "211:                 }",
          "212:                 dest[i] = pix;",
          "213:             }",
          "214:             dest += stride;",
          "215:         }",
          "216:         if (get_bits_left(&gb) > 32)",
          "217:             av_log(c->avctx, AV_LOG_WARNING,",
          "218:                    \"%d bits left after decoding slice\\n\", get_bits_left(&gb));",
          "219:     }",
          "221:     ff_free_vlc(&vlc);",
          "223:     return 0;",
          "224: fail:",
          "225:     ff_free_vlc(&vlc);",
          "226:     return AVERROR_INVALIDDATA;",
          "227: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "347:     bytestream2_init(&gb, buf, buf_size);",
          "352:             return AVERROR_INVALIDDATA;",
          "353:         }",
          "362:                 return AVERROR_INVALIDDATA;",
          "363:             }",
          "367:         }",
          "375:     }",
          "377:     av_log(avctx, AV_LOG_DEBUG, \"frame information flags %\"PRIX32\"\\n\",",
          "378:            c->frame_info);",
          "",
          "[Removed Lines]",
          "348:     for (i = 0; i < c->planes; i++) {",
          "349:         plane_start[i] = gb.buffer;",
          "350:         if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {",
          "351:             av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");",
          "354:         bytestream2_skipu(&gb, 256);",
          "355:         slice_start = 0;",
          "356:         slice_end   = 0;",
          "357:         for (j = 0; j < c->slices; j++) {",
          "358:             slice_end   = bytestream2_get_le32u(&gb);",
          "359:             if (slice_end < 0 || slice_end < slice_start ||",
          "360:                 bytestream2_get_bytes_left(&gb) < slice_end) {",
          "361:                 av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");",
          "364:             slice_size  = slice_end - slice_start;",
          "365:             slice_start = slice_end;",
          "366:             max_slice_size = FFMAX(max_slice_size, slice_size);",
          "368:         plane_size = slice_end;",
          "369:         bytestream2_skipu(&gb, plane_size);",
          "370:     }",
          "371:     plane_start[c->planes] = gb.buffer;",
          "372:     if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {",
          "373:         av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");",
          "374:         return AVERROR_INVALIDDATA;",
          "376:     c->frame_info = bytestream2_get_le32u(&gb);",
          "",
          "[Added Lines]",
          "496:     if (c->pro) {",
          "497:         c->frame_info = bytestream2_get_le32u(&gb);",
          "498:         c->slices = ((c->frame_info >> 24) & 0xff) + 1;",
          "499:         for (i = 0; i < c->planes; i++) {",
          "500:             plane_size = 0;",
          "501:             plane_start[i] = gb.buffer;",
          "502:             if (bytestream2_get_bytes_left(&gb) < 1024 + 4 * c->slices) {",
          "503:                 av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");",
          "504:                 return AVERROR_INVALIDDATA;",
          "505:             }",
          "506:             for (j = 0; j < c->slices; j++) {",
          "507:                 slice_size     = bytestream2_get_le32u(&gb);",
          "508:                 max_slice_size = FFMAX(max_slice_size, slice_size);",
          "509:                 plane_size    += slice_size;",
          "510:             }",
          "511:             bytestream2_skipu(&gb, 1024);",
          "512:             bytestream2_skipu(&gb, plane_size);",
          "513:         }",
          "514:         plane_start[c->planes] = gb.buffer;",
          "515:         if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {",
          "516:             av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");",
          "519:     } else {",
          "520:         for (i = 0; i < c->planes; i++) {",
          "521:             plane_start[i] = gb.buffer;",
          "522:             if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {",
          "523:                 av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");",
          "526:             bytestream2_skipu(&gb, 256);",
          "527:             slice_start = 0;",
          "528:             slice_end   = 0;",
          "529:             for (j = 0; j < c->slices; j++) {",
          "530:                 slice_end   = bytestream2_get_le32u(&gb);",
          "531:                 if (slice_end < 0 || slice_end < slice_start ||",
          "532:                     bytestream2_get_bytes_left(&gb) < slice_end) {",
          "533:                     av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");",
          "534:                     return AVERROR_INVALIDDATA;",
          "535:                 }",
          "536:                 slice_size  = slice_end - slice_start;",
          "537:                 slice_start = slice_end;",
          "538:                 max_slice_size = FFMAX(max_slice_size, slice_size);",
          "539:             }",
          "540:             plane_size = slice_end;",
          "541:             bytestream2_skipu(&gb, plane_size);",
          "543:         plane_start[c->planes] = gb.buffer;",
          "544:         if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {",
          "545:             av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");",
          "546:             return AVERROR_INVALIDDATA;",
          "547:         }",
          "548:         c->frame_info = bytestream2_get_le32u(&gb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "459:             }",
          "460:         }",
          "461:         break;",
          "462:     }",
          "464:     frame.f->key_frame = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "635:     case AV_PIX_FMT_YUV422P10:",
          "636:         for (i = 0; i < 3; i++) {",
          "637:             ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], 1, frame.f->linesize[i] / 2,",
          "638:                                  avctx->width >> !!i, avctx->height,",
          "639:                                  plane_start[i], plane_start[i + 1] - 1024, c->frame_pred == PRED_LEFT);",
          "640:             if (ret)",
          "641:                 return ret;",
          "642:         }",
          "643:         break;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "480:     ff_bswapdsp_init(&c->bdsp);",
          "483:         av_log(avctx, AV_LOG_ERROR,",
          "484:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "485:                avctx->extradata_size);",
          "486:         return AVERROR_INVALIDDATA;",
          "487:     }",
          "504:     c->slice_bits_size = 0;",
          "506:     switch (avctx->codec_tag) {",
          "",
          "[Removed Lines]",
          "482:     if (avctx->extradata_size < 16) {",
          "489:     av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "490:            avctx->extradata[3], avctx->extradata[2],",
          "491:            avctx->extradata[1], avctx->extradata[0]);",
          "492:     av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "493:            AV_RB32(avctx->extradata + 4));",
          "494:     c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "495:     c->flags           = AV_RL32(avctx->extradata + 12);",
          "497:     if (c->frame_info_size != 4)",
          "498:         avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "499:     av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "500:     c->slices      = (c->flags >> 24) + 1;",
          "501:     c->compression = c->flags & 1;",
          "502:     c->interlaced  = c->flags & 0x800;",
          "",
          "[Added Lines]",
          "664:     if (avctx->extradata_size >= 16) {",
          "665:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "666:                avctx->extradata[3], avctx->extradata[2],",
          "667:                avctx->extradata[1], avctx->extradata[0]);",
          "668:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "669:                AV_RB32(avctx->extradata + 4));",
          "670:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "671:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "673:         if (c->frame_info_size != 4)",
          "674:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "675:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "676:         c->slices      = (c->flags >> 24) + 1;",
          "677:         c->compression = c->flags & 1;",
          "678:         c->interlaced  = c->flags & 0x800;",
          "679:     } else if (avctx->extradata_size == 8) {",
          "680:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "681:                avctx->extradata[3], avctx->extradata[2],",
          "682:                avctx->extradata[1], avctx->extradata[0]);",
          "683:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "684:                AV_RB32(avctx->extradata + 4));",
          "685:         c->interlaced  = 0;",
          "686:         c->pro         = 1;",
          "687:     } else {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "522:         avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "523:         avctx->colorspace = AVCOL_SPC_BT470BG;",
          "524:         break;",
          "525:     case MKTAG('U', 'L', 'H', '0'):",
          "526:         c->planes      = 3;",
          "527:         avctx->pix_fmt = AV_PIX_FMT_YUV420P;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "715:     case MKTAG('U', 'Q', 'Y', '2'):",
          "716:         c->planes      = 3;",
          "717:         avctx->pix_fmt = AV_PIX_FMT_YUV422P10;",
          "718:         break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ecc59bc35412d0cc2299668dd1f79fff090eb3f",
      "candidate_info": {
        "commit_hash": "3ecc59bc35412d0cc2299668dd1f79fff090eb3f",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3ecc59bc35412d0cc2299668dd1f79fff090eb3f",
        "files": [
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideodec: fix multiple slices for UQY2 and other issues\n\nSigned-off-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "495:     bytestream2_init(&gb, buf, buf_size);",
          "496:     if (c->pro) {",
          "497:         c->frame_info = bytestream2_get_le32u(&gb);",
          "499:         for (i = 0; i < c->planes; i++) {",
          "501:             plane_start[i] = gb.buffer;",
          "502:             if (bytestream2_get_bytes_left(&gb) < 1024 + 4 * c->slices) {",
          "503:                 av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");",
          "504:                 return AVERROR_INVALIDDATA;",
          "505:             }",
          "506:             for (j = 0; j < c->slices; j++) {",
          "508:                 max_slice_size = FFMAX(max_slice_size, slice_size);",
          "510:             }",
          "512:             bytestream2_skipu(&gb, plane_size);",
          "513:         }",
          "514:         plane_start[c->planes] = gb.buffer;",
          "519:     } else {",
          "520:         for (i = 0; i < c->planes; i++) {",
          "521:             plane_start[i] = gb.buffer;",
          "",
          "[Removed Lines]",
          "498:         c->slices = ((c->frame_info >> 24) & 0xff) + 1;",
          "500:             plane_size = 0;",
          "507:                 slice_size     = bytestream2_get_le32u(&gb);",
          "509:                 plane_size    += slice_size;",
          "511:             bytestream2_skipu(&gb, 1024);",
          "515:         if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {",
          "516:             av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");",
          "517:             return AVERROR_INVALIDDATA;",
          "518:         }",
          "",
          "[Added Lines]",
          "497:         if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {",
          "498:             av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");",
          "499:             return AVERROR_INVALIDDATA;",
          "500:         }",
          "502:         c->slices = ((c->frame_info >> 16) & 0xff) + 1;",
          "509:             slice_start = 0;",
          "510:             slice_end   = 0;",
          "512:                 slice_end   = bytestream2_get_le32u(&gb);",
          "513:                 if (slice_end < 0 || slice_end < slice_start ||",
          "514:                     bytestream2_get_bytes_left(&gb) < slice_end) {",
          "515:                     av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");",
          "516:                     return AVERROR_INVALIDDATA;",
          "517:                 }",
          "518:                 slice_size  = slice_end - slice_start;",
          "519:                 slice_start = slice_end;",
          "522:             plane_size = slice_end;",
          "524:             bytestream2_skipu(&gb, 1024);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "684:                AV_RB32(avctx->extradata + 4));",
          "685:         c->interlaced  = 0;",
          "686:         c->pro         = 1;",
          "687:     } else {",
          "688:         av_log(avctx, AV_LOG_ERROR,",
          "689:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "695:         c->frame_info_size = 4;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-43826",
  "cve_desc": "Envoy is an open source edge and service proxy, designed for cloud-native applications. In affected versions of Envoy a crash occurs when configured for :ref:`upstream tunneling <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection disconnects while the the upstream connection or http/2 stream is still being established. There are no workarounds for this issue. Users are advised to upgrade.",
  "repo": "envoyproxy/envoy",
  "patch_hash": "ce0ae309057a216aba031aff81c445c90c6ef145",
  "patch_info": {
    "commit_hash": "ce0ae309057a216aba031aff81c445c90c6ef145",
    "repo": "envoyproxy/envoy",
    "commit_url": "https://github.com/envoyproxy/envoy/commit/ce0ae309057a216aba031aff81c445c90c6ef145",
    "files": [
      "docs/root/version_history/current.rst",
      "source/common/tcp_proxy/tcp_proxy.cc",
      "source/common/tcp_proxy/tcp_proxy.h",
      "test/integration/tcp_tunneling_integration_test.cc"
    ],
    "message": "CVE-2021-43826\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>",
    "before_after_code_files": [
      "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
      "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
      "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
    ]
  },
  "patch_diff": {
    "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc": [
      "File: source/common/tcp_proxy/tcp_proxy.cc -> source/common/tcp_proxy/tcp_proxy.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "520: }",
      "522: void Filter::onDownstreamEvent(Network::ConnectionEvent event) {",
      "523:   ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),",
      "524:                  static_cast<int>(event), upstream_ == nullptr);",
      "525:   if (upstream_) {",
      "526:     Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));",
      "527:     if (conn_data != nullptr &&",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "523:   if (event == Network::ConnectionEvent::LocalClose ||",
      "524:       event == Network::ConnectionEvent::RemoteClose) {",
      "525:     downstream_closed_ = true;",
      "526:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "570:             Upstream::Outlier::Result::LocalOriginConnectFailed);",
      "571:       }",
      "574:     } else {",
      "575:       if (read_callbacks_->connection().state() == Network::Connection::State::Open) {",
      "576:         read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);",
      "",
      "[Removed Lines]",
      "573:       initializeUpstreamConnection();",
      "",
      "[Added Lines]",
      "579:       if (!downstream_closed_) {",
      "580:         initializeUpstreamConnection();",
      "581:       }",
      "",
      "---------------"
    ],
    "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h": [
      "File: source/common/tcp_proxy/tcp_proxy.h -> source/common/tcp_proxy/tcp_proxy.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "401:   Network::Socket::OptionsSharedPtr upstream_options_;",
      "402:   uint32_t connect_attempts_{};",
      "403:   bool connecting_{};",
      "404: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "404:   bool downstream_closed_{};",
      "",
      "---------------"
    ],
    "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc": [
      "File: test/integration/tcp_tunneling_integration_test.cc -> test/integration/tcp_tunneling_integration_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "816:   tcp_client_->waitForDisconnect();",
      "817: }",
      "819: TEST_P(TcpTunnelingIntegrationTest, TestIdletimeoutWithLargeOutstandingData) {",
      "820:   enableHalfClose(false);",
      "821:   config_helper_.setBufferLimits(1024, 1024);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "819: TEST_P(TcpTunnelingIntegrationTest, UpstreamConnectingDownstreamDisconnect) {",
      "820:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
      "821:     return;",
      "822:   }",
      "824: #if defined(WIN32)",
      "830:   return;",
      "831: #endif",
      "833:   config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {",
      "834:     envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
      "835:     proxy_config.set_stat_prefix(\"tcp_stats\");",
      "836:     proxy_config.set_cluster(\"cluster_0\");",
      "837:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
      "841:     proxy_config.mutable_max_connect_attempts()->set_value(2);",
      "843:     auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();",
      "844:     for (auto& listener : *listeners) {",
      "845:       if (listener.name() != \"tcp_proxy\") {",
      "846:         continue;",
      "847:       }",
      "848:       auto* filter_chain = listener.mutable_filter_chains(0);",
      "849:       auto* filter = filter_chain->mutable_filters(0);",
      "850:       filter->mutable_typed_config()->PackFrom(proxy_config);",
      "854:       envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;",
      "855:       ConfigHelper::initializeTls({}, *tls_context.mutable_common_tls_context());",
      "856:       filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");",
      "857:       filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);",
      "859:       break;",
      "860:     }",
      "861:   });",
      "863:   enableHalfClose(false);",
      "864:   initialize();",
      "866:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
      "870:   ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));",
      "871:   ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));",
      "872:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
      "876:   tcp_client->close();",
      "878:   ASSERT_TRUE(upstream_request_->waitForReset());",
      "879:   ASSERT_TRUE(fake_upstream_connection_->close());",
      "880: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0a587f23b21ab34b28d9c53428af259b3f7b0970",
      "candidate_info": {
        "commit_hash": "0a587f23b21ab34b28d9c53428af259b3f7b0970",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/0a587f23b21ab34b28d9c53428af259b3f7b0970",
        "files": [
          "api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto",
          "docs/root/configuration/listeners/network_filters/tcp_proxy_filter.rst",
          "docs/root/version_history/current.rst",
          "source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h",
          "source/common/tcp_proxy/upstream.cc",
          "test/common/tcp_proxy/tcp_proxy_test.cc",
          "test/integration/BUILD",
          "test/integration/fake_upstream.cc",
          "test/integration/fake_upstream.h",
          "test/integration/tcp_proxy_odcds_integration_test.cc"
        ],
        "message": "Tcpproxy: implement on_demand  (#20409)\n\nAdd an extra async cluster look up. The continuation of the cluster look up is establishUpstreamConnection().\nTo establishConnection() is also the callback of upstream connection failure.\n\nAdditional Description:\nRisk Level: LOW if odcds is disabled, the code path remains the same.\nTesting: Added integration tests and existing unit test is untouched.\nDocs Changes: n/a\nRelease Notes: inline\n\nSigned-off-by: Yuchen Dai <silentdai@gmail.com>",
        "before_after_code_files": [
          "api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto||api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto",
          "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
          "source/common/tcp_proxy/upstream.cc||source/common/tcp_proxy/upstream.cc",
          "test/common/tcp_proxy/tcp_proxy_test.cc||test/common/tcp_proxy/tcp_proxy_test.cc",
          "test/integration/fake_upstream.cc||test/integration/fake_upstream.cc",
          "test/integration/fake_upstream.h||test/integration/fake_upstream.h",
          "test/integration/tcp_proxy_odcds_integration_test.cc||test/integration/tcp_proxy_odcds_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h"
          ],
          "candidate": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h"
          ]
        }
      },
      "candidate_diff": {
        "api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto||api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto": [
          "File: api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto -> api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto"
        ],
        "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc": [
          "File: source/common/tcp_proxy/tcp_proxy.cc -> source/common/tcp_proxy/tcp_proxy.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:   }",
          "60: }",
          "62: Config::SharedConfig::SharedConfig(",
          "63:     const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& config,",
          "64:     Server::Configuration::FactoryContext& context)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: OnDemandStats OnDemandConfig::generateStats(Stats::Scope& scope) {",
          "63:   return {ON_DEMAND_TCP_PROXY_STATS(POOL_COUNTER(scope))};",
          "64: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:         DurationUtil::durationToMilliseconds(config.max_downstream_connection_duration());",
          "82:     max_downstream_connection_duration_ = std::chrono::milliseconds(connection_duration);",
          "83:   }",
          "84: }",
          "86: Config::Config(const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& config,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89:   if (config.has_on_demand() && config.on_demand().has_odcds_config()) {",
          "90:     on_demand_config_ =",
          "91:         std::make_unique<OnDemandConfig>(config.on_demand(), context, *stats_scope_);",
          "92:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "329:   parent_ = nullptr;",
          "330: }",
          "337:   const std::string& cluster_name = route_ ? route_->clusterName() : EMPTY_STRING;",
          "339:   Upstream::ThreadLocalCluster* thread_local_cluster =",
          "340:       cluster_manager_.getThreadLocalCluster(cluster_name);",
          "350:     return Network::FilterStatus::StopIteration;",
          "351:   }",
          "354:   getStreamInfo().setUpstreamClusterInfo(cluster);",
          "",
          "[Removed Lines]",
          "332: Network::FilterStatus Filter::initializeUpstreamConnection() {",
          "333:   ASSERT(upstream_ == nullptr);",
          "335:   route_ = pickRoute();",
          "342:   if (thread_local_cluster) {",
          "343:     ENVOY_CONN_LOG(debug, \"Creating connection to cluster {}\", read_callbacks_->connection(),",
          "344:                    cluster_name);",
          "345:   } else {",
          "346:     ENVOY_CONN_LOG(debug, \"Cluster not found {}\", read_callbacks_->connection(), cluster_name);",
          "347:     config_->stats().downstream_cx_no_route_.inc();",
          "348:     getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound);",
          "349:     onInitFailure(UpstreamFailureReason::NoRoute);",
          "353:   Upstream::ClusterInfoConstSharedPtr cluster = thread_local_cluster->info();",
          "",
          "[Added Lines]",
          "341: Network::FilterStatus Filter::establishUpstreamConnection() {",
          "346:   if (!thread_local_cluster) {",
          "347:     auto odcds = config_->onDemandCds();",
          "348:     if (!odcds.has_value()) {",
          "350:       ENVOY_CONN_LOG(debug, \"Cluster not found {} and no on demand cluster set.\",",
          "351:                      read_callbacks_->connection(), cluster_name);",
          "352:       config_->stats().downstream_cx_no_route_.inc();",
          "353:       getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound);",
          "354:       onInitFailure(UpstreamFailureReason::NoRoute);",
          "355:     } else {",
          "356:       ASSERT(!cluster_discovery_handle_);",
          "357:       auto callback = std::make_unique<Upstream::ClusterDiscoveryCallback>(",
          "358:           [this](Upstream::ClusterDiscoveryStatus cluster_status) {",
          "359:             onClusterDiscoveryCompletion(cluster_status);",
          "360:           });",
          "361:       config_->onDemandStats().on_demand_cluster_attempt_.inc();",
          "362:       cluster_discovery_handle_ = odcds->requestOnDemandClusterDiscovery(",
          "363:           cluster_name, std::move(callback), config_->odcdsTimeout());",
          "364:     }",
          "368:   ENVOY_CONN_LOG(debug, \"Creating connection to cluster {}\", read_callbacks_->connection(),",
          "369:                  cluster_name);",
          "371:   const Upstream::ClusterInfoConstSharedPtr& cluster = thread_local_cluster->info();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "403:   return Network::FilterStatus::StopIteration;",
          "404: }",
          "406: bool Filter::maybeTunnel(Upstream::ThreadLocalCluster& cluster) {",
          "407:   GenericConnPoolFactory* factory = nullptr;",
          "408:   if (cluster.info()->upstreamConfig().has_value()) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "424: void Filter::onClusterDiscoveryCompletion(Upstream::ClusterDiscoveryStatus cluster_status) {",
          "427:   cluster_discovery_handle_.reset();",
          "428:   const std::string& cluster_name = route_ ? route_->clusterName() : EMPTY_STRING;",
          "429:   switch (cluster_status) {",
          "430:   case Upstream::ClusterDiscoveryStatus::Missing:",
          "431:     ENVOY_CONN_LOG(debug, \"On demand cluster {} is missing\", read_callbacks_->connection(),",
          "432:                    cluster_name);",
          "433:     config_->onDemandStats().on_demand_cluster_missing_.inc();",
          "434:     break;",
          "435:   case Upstream::ClusterDiscoveryStatus::Timeout:",
          "436:     ENVOY_CONN_LOG(debug, \"On demand cluster {} was not found before timeout.\",",
          "437:                    read_callbacks_->connection(), cluster_name);",
          "438:     config_->onDemandStats().on_demand_cluster_timeout_.inc();",
          "439:     break;",
          "440:   case Upstream::ClusterDiscoveryStatus::Available:",
          "442:     ASSERT(!downstream_closed_);",
          "443:     ENVOY_CONN_LOG(debug, \"On demand cluster {} is found. Establishing connection.\",",
          "444:                    read_callbacks_->connection(), cluster_name);",
          "445:     config_->onDemandStats().on_demand_cluster_success_.inc();",
          "446:     establishUpstreamConnection();",
          "447:     return;",
          "448:   }",
          "450:   config_->stats().downstream_cx_no_route_.inc();",
          "451:   getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound);",
          "452:   onInitFailure(UpstreamFailureReason::NoRoute);",
          "453: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "520:         [this]() -> void { onMaxDownstreamConnectionDuration(); });",
          "521:     connection_duration_timer_->enableTimer(config_->maxDownstreamConnectionDuration().value());",
          "522:   }",
          "524: }",
          "526: void Filter::onDownstreamEvent(Network::ConnectionEvent event) {",
          "527:   if (event == Network::ConnectionEvent::LocalClose ||",
          "528:       event == Network::ConnectionEvent::RemoteClose) {",
          "529:     downstream_closed_ = true;",
          "530:   }",
          "532:   ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),",
          "",
          "[Removed Lines]",
          "523:   return initializeUpstreamConnection();",
          "",
          "[Added Lines]",
          "573:   ASSERT(upstream_ == nullptr);",
          "574:   route_ = pickRoute();",
          "575:   return establishUpstreamConnection();",
          "583:     cluster_discovery_handle_ = nullptr;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "585:         read_callbacks_->upstreamHost()->outlierDetector().putResult(",
          "586:             Upstream::Outlier::Result::LocalOriginConnectFailed);",
          "587:       }",
          "589:       if (!downstream_closed_) {",
          "591:       }",
          "592:     } else {",
          "593:       if (read_callbacks_->connection().state() == Network::Connection::State::Open) {",
          "",
          "[Removed Lines]",
          "590:         initializeUpstreamConnection();",
          "",
          "[Added Lines]",
          "643:         route_ = pickRoute();",
          "644:         establishUpstreamConnection();",
          "",
          "---------------"
        ],
        "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h": [
          "File: source/common/tcp_proxy/tcp_proxy.h -> source/common/tcp_proxy/tcp_proxy.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:   GAUGE(downstream_cx_tx_bytes_buffered, Accumulate)                                               \\",
          "53:   GAUGE(upstream_flush_active, Accumulate)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58: #define ON_DEMAND_TCP_PROXY_STATS(COUNTER)                                                         \\",
          "59:   COUNTER(on_demand_cluster_attempt)                                                               \\",
          "60:   COUNTER(on_demand_cluster_missing)                                                               \\",
          "61:   COUNTER(on_demand_cluster_timeout)                                                               \\",
          "62:   COUNTER(on_demand_cluster_success)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:   ALL_TCP_PROXY_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT)",
          "60: };",
          "62: class Drainer;",
          "63: class UpstreamDrainManager;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76: struct OnDemandStats {",
          "77:   ON_DEMAND_TCP_PROXY_STATS(GENERATE_COUNTER_STRUCT)",
          "78: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "109:   std::unique_ptr<Envoy::Router::HeaderParser> header_parser_;",
          "110: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: class OnDemandConfig {",
          "134: public:",
          "135:   OnDemandConfig(const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy_OnDemand&",
          "136:                      on_demand_message,",
          "137:                  Server::Configuration::FactoryContext& context, Stats::Scope& scope)",
          "138:       : odcds_(context.clusterManager().allocateOdCdsApi(on_demand_message.odcds_config(),",
          "139:                                                          OptRef<xds::core::v3::ResourceLocator>(),",
          "140:                                                          context.messageValidationVisitor())),",
          "141:         lookup_timeout_(std::chrono::milliseconds(",
          "142:             PROTOBUF_GET_MS_OR_DEFAULT(on_demand_message, timeout, 60000))),",
          "143:         stats_(generateStats(scope)) {}",
          "144:   Upstream::OdCdsApiHandle& onDemandCds() const { return *odcds_; }",
          "145:   std::chrono::milliseconds timeout() const { return lookup_timeout_; }",
          "146:   const OnDemandStats& stats() const { return stats_; }",
          "148: private:",
          "149:   static OnDemandStats generateStats(Stats::Scope& scope);",
          "150:   Upstream::OdCdsApiHandlePtr odcds_;",
          "152:   std::chrono::milliseconds lookup_timeout_;",
          "154:   OnDemandStats stats_;",
          "155: };",
          "156: using OnDemandConfigOptConstRef = OptRef<const OnDemandConfig>;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "136:         return TunnelingConfigHelperOptConstRef();",
          "137:       }",
          "138:     }",
          "140:   private:",
          "141:     static TcpProxyStats generateStats(Stats::Scope& scope);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "185:     OnDemandConfigOptConstRef onDemandConfig() {",
          "186:       if (on_demand_config_) {",
          "187:         return OnDemandConfigOptConstRef(*on_demand_config_);",
          "188:       } else {",
          "189:         return OnDemandConfigOptConstRef();",
          "190:       }",
          "191:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "148:     absl::optional<std::chrono::milliseconds> idle_timeout_;",
          "149:     absl::optional<std::chrono::milliseconds> max_downstream_connection_duration_;",
          "150:     std::unique_ptr<TunnelingConfigHelper> tunneling_config_helper_;",
          "151:   };",
          "153:   using SharedConfigSharedPtr = std::shared_ptr<SharedConfig>;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "204:     std::unique_ptr<OnDemandConfig> on_demand_config_;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "185:     return cluster_metadata_match_criteria_.get();",
          "186:   }",
          "187:   const Network::HashPolicy* hashPolicy() { return hash_policy_.get(); }",
          "189: private:",
          "190:   struct SimpleRouteImpl : public Route {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242:   OptRef<Upstream::OdCdsApiHandle> onDemandCds() const {",
          "243:     auto on_demand_config = shared_config_->onDemandConfig();",
          "244:     return on_demand_config.has_value() ? makeOptRef(on_demand_config->onDemandCds())",
          "245:                                         : OptRef<Upstream::OdCdsApiHandle>();",
          "246:   }",
          "248:   std::chrono::milliseconds odcdsTimeout() const {",
          "249:     return shared_config_->onDemandConfig()->timeout();",
          "250:   }",
          "252:   const OnDemandStats& onDemandStats() const { return shared_config_->onDemandConfig()->stats(); }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "366:   }",
          "368:   void initialize(Network::ReadFilterCallbacks& callbacks, bool set_connection_stats);",
          "370:   bool maybeTunnel(Upstream::ThreadLocalCluster& cluster);",
          "371:   void onConnectTimeout();",
          "372:   void onDownstreamEvent(Network::ConnectionEvent event);",
          "",
          "[Removed Lines]",
          "369:   Network::FilterStatus initializeUpstreamConnection();",
          "",
          "[Added Lines]",
          "437:   Network::FilterStatus establishUpstreamConnection();",
          "440:   void onClusterDiscoveryCompletion(Upstream::ClusterDiscoveryStatus cluster_status);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "386:   Event::TimerPtr idle_timer_;",
          "387:   Event::TimerPtr connection_duration_timer_;",
          "389:   std::shared_ptr<UpstreamCallbacks> upstream_callbacks_; // shared_ptr required for passing as a",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "462:   Upstream::ClusterDiscoveryCallbackHandlePtr cluster_discovery_handle_;",
          "",
          "---------------"
        ],
        "source/common/tcp_proxy/upstream.cc||source/common/tcp_proxy/upstream.cc": [
          "File: source/common/tcp_proxy/upstream.cc -> source/common/tcp_proxy/upstream.cc"
        ],
        "test/common/tcp_proxy/tcp_proxy_test.cc||test/common/tcp_proxy/tcp_proxy_test.cc": [
          "File: test/common/tcp_proxy/tcp_proxy_test.cc -> test/common/tcp_proxy/tcp_proxy_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"test/mocks/ssl/mocks.h\"",
          "35: #include \"test/mocks/stream_info/mocks.h\"",
          "36: #include \"test/mocks/tcp/mocks.h\"",
          "37: #include \"test/mocks/upstream/host.h\"",
          "38: #include \"test/test_common/test_runtime.h\"",
          "39: #include \"test/test_common/utility.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"test/mocks/upstream/cluster_discovery_callback_handle.h\"",
          "39: #include \"test/mocks/upstream/od_cds_api_handle.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:   using TcpProxyTestBase::setup;",
          "62:   void setup(uint32_t connections, bool set_redirect_records,",
          "63:              const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& config) override {",
          "64:     configure(config);",
          "65:     upstream_local_address_ = Network::Utility::resolveUrl(\"tcp://2.2.2.2:50000\");",
          "66:     upstream_remote_address_ = Network::Utility::resolveUrl(\"tcp://127.0.0.1:80\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:     if (config.has_on_demand()) {",
          "67:       EXPECT_CALL(factory_context_.cluster_manager_, allocateOdCdsApi(_, _, _))",
          "68:           .WillOnce(",
          "69:               Invoke([this]() { return Upstream::MockOdCdsApiHandlePtr(mock_odcds_api_handle_); }));",
          "70:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "130:     if (connections > 0) {",
          "131:       EXPECT_EQ(Network::FilterStatus::StopIteration, filter_->onNewConnection());",
          "133:       EXPECT_EQ(absl::optional<uint64_t>(), filter_->computeHashKey());",
          "134:       EXPECT_EQ(&filter_callbacks_.connection_, filter_->downstreamConnection());",
          "135:       EXPECT_EQ(nullptr, filter_->metadataMatchCriteria());",
          "136:     }",
          "137:   }",
          "138: };",
          "140: TEST_F(TcpProxyTest, ExplicitCluster) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:   void set2Cluster(envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& config) {",
          "146:     auto* new_cluster = config.mutable_weighted_clusters()->add_clusters();",
          "148:     new_cluster->set_weight(1);",
          "149:     new_cluster = config.mutable_weighted_clusters()->add_clusters();",
          "151:     new_cluster->set_weight(1);",
          "152:   }",
          "154:   envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy onDemandConfig() {",
          "155:     auto config = defaultConfig();",
          "156:     config.mutable_on_demand()->mutable_odcds_config();",
          "157:     return config;",
          "158:   }",
          "162:   Upstream::MockOdCdsApiHandle* mock_odcds_api_handle_{};",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1108:   EXPECT_EQ(filter_callbacks_.connection().streamInfo().upstreamInfo()->upstreamSslConnection(),",
          "1109:             upstream_connections_.at(0)->streamInfo().downstreamAddressProvider().sslConnection());",
          "1110: }",
          "1111: } // namespace",
          "1112: } // namespace TcpProxy",
          "1113: } // namespace Envoy",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1137: TEST_F(TcpProxyTest, PickClusterOnUpstreamFailure) {",
          "1138:   auto config = defaultConfig();",
          "1139:   set2Cluster(config);",
          "1140:   config.mutable_max_connect_attempts()->set_value(2);",
          "1143:   EXPECT_CALL(factory_context_.api_.random_, random()).WillOnce(Return(0));",
          "1144:   EXPECT_CALL(factory_context_.cluster_manager_, getThreadLocalCluster(\"fake_cluster_0\"))",
          "1145:       .WillOnce(Return(&factory_context_.cluster_manager_.thread_local_cluster_));",
          "1147:   setup(1, config);",
          "1150:   EXPECT_CALL(factory_context_.api_.random_, random()).WillOnce(Return(1));",
          "1152:   EXPECT_CALL(factory_context_.cluster_manager_, getThreadLocalCluster(\"fake_cluster_1\"))",
          "1153:       .WillOnce(Return(&factory_context_.cluster_manager_.thread_local_cluster_));",
          "1155:   raiseEventUpstreamConnectFailed(0, ConnectionPool::PoolFailureReason::LocalConnectionFailure);",
          "1156:   EXPECT_EQ(0U, factory_context_.cluster_manager_.thread_local_cluster_.cluster_.info_->stats_store_",
          "1157:                     .counter(\"upstream_cx_connect_attempts_exceeded\")",
          "1158:                     .value());",
          "1159: }",
          "1162: TEST_F(TcpProxyTest, OnDemandCallbackStickToTheSelectedCluster) {",
          "1163:   auto config = onDemandConfig();",
          "1164:   set2Cluster(config);",
          "1165:   config.mutable_max_connect_attempts()->set_value(2);",
          "1166:   mock_odcds_api_handle_ = Upstream::MockOdCdsApiHandle::create().release();",
          "1169:   EXPECT_CALL(factory_context_.api_.random_, random()).WillOnce(Return(0));",
          "1172:   EXPECT_CALL(factory_context_.cluster_manager_, getThreadLocalCluster(\"fake_cluster_0\"))",
          "1174:       .WillOnce(Return(nullptr))",
          "1176:       .WillOnce(Return(&factory_context_.cluster_manager_.thread_local_cluster_))",
          "1177:       .RetiresOnSaturation();",
          "1179:   Upstream::ClusterDiscoveryCallbackPtr cluster_discovery_callback;",
          "1180:   EXPECT_CALL(*mock_odcds_api_handle_, requestOnDemandClusterDiscovery(\"fake_cluster_0\", _, _))",
          "1181:       .WillOnce(Invoke([&](auto&&, auto&& cb, auto&&) {",
          "1182:         cluster_discovery_callback = std::move(cb);",
          "1183:         return std::make_unique<Upstream::MockClusterDiscoveryCallbackHandle>();",
          "1184:       }));",
          "1186:   setup(1, config);",
          "1190:   EXPECT_CALL(factory_context_.api_.random_, random()).Times(0);",
          "1191:   std::invoke(*cluster_discovery_callback, Upstream::ClusterDiscoveryStatus::Available);",
          "1196:   EXPECT_CALL(factory_context_.api_.random_, random()).WillOnce(Return(1));",
          "1198:   EXPECT_CALL(factory_context_.cluster_manager_, getThreadLocalCluster(\"fake_cluster_1\"))",
          "1200:       .WillOnce(Return(nullptr))",
          "1201:       .RetiresOnSaturation();",
          "1203:   EXPECT_CALL(*mock_odcds_api_handle_, requestOnDemandClusterDiscovery(\"fake_cluster_1\", _, _))",
          "1204:       .WillOnce(Invoke([&](auto&&, auto&&, auto&&) {",
          "1205:         return std::make_unique<Upstream::MockClusterDiscoveryCallbackHandle>();",
          "1206:       }));",
          "1208:   raiseEventUpstreamConnectFailed(0, ConnectionPool::PoolFailureReason::LocalConnectionFailure);",
          "1209:   EXPECT_EQ(0U, factory_context_.cluster_manager_.thread_local_cluster_.cluster_.info_->stats_store_",
          "1210:                     .counter(\"upstream_cx_connect_attempts_exceeded\")",
          "1211:                     .value());",
          "1213:   EXPECT_CALL(filter_callbacks_.connection_, close(_));",
          "1214:   std::invoke(*cluster_discovery_callback, Upstream::ClusterDiscoveryStatus::Missing);",
          "1215: }",
          "1218: TEST_F(TcpProxyTest, OdcdsIsIgnoredIfClusterExists) {",
          "1219:   auto config = onDemandConfig();",
          "1221:   setup(1, config);",
          "1222:   raiseEventUpstreamConnected(0);",
          "1224:   Buffer::OwnedImpl buffer(\"hello\");",
          "1225:   EXPECT_CALL(*upstream_connections_.at(0), write(BufferEqual(&buffer), false));",
          "1226:   filter_->onData(buffer, false);",
          "1228:   Buffer::OwnedImpl response(\"world\");",
          "1229:   EXPECT_CALL(filter_callbacks_.connection_, write(BufferEqual(&response), _));",
          "1230:   upstream_callbacks_->onUpstreamData(response, false);",
          "1232:   EXPECT_CALL(filter_callbacks_.connection_, close(Network::ConnectionCloseType::FlushWrite));",
          "1233:   upstream_callbacks_->onEvent(Network::ConnectionEvent::RemoteClose);",
          "1234: }",
          "1237: TEST_F(TcpProxyTest, OdcdsCancelIfConnectionClose) {",
          "1238:   auto config = onDemandConfig();",
          "1239:   mock_odcds_api_handle_ = Upstream::MockOdCdsApiHandle::create().release();",
          "1243:   EXPECT_CALL(factory_context_.cluster_manager_, getThreadLocalCluster(\"fake_cluster\"))",
          "1244:       .WillOnce(Return(nullptr))",
          "1245:       .RetiresOnSaturation();",
          "1247:   EXPECT_CALL(*mock_odcds_api_handle_, requestOnDemandClusterDiscovery(\"fake_cluster\", _, _))",
          "1248:       .WillOnce(Invoke([&](auto&&, auto&&, auto&&) {",
          "1249:         return std::make_unique<Upstream::MockClusterDiscoveryCallbackHandle>();",
          "1250:       }));",
          "1251:   setup(0, config);",
          "1252:   EXPECT_EQ(Network::FilterStatus::StopIteration, filter_->onNewConnection());",
          "1254:   filter_callbacks_.connection_.raiseEvent(Network::ConnectionEvent::LocalClose);",
          "1255: }",
          "1258: TEST_F(TcpProxyTest, OdcdsBasicDownstreamLocalClose) {",
          "1259:   auto config = onDemandConfig();",
          "1260:   mock_odcds_api_handle_ = Upstream::MockOdCdsApiHandle::create().release();",
          "1264:   EXPECT_CALL(factory_context_.cluster_manager_, getThreadLocalCluster(\"fake_cluster\"))",
          "1265:       .WillOnce(Return(nullptr))",
          "1266:       .WillOnce(Return(&factory_context_.cluster_manager_.thread_local_cluster_))",
          "1267:       .RetiresOnSaturation();",
          "1269:   Upstream::ClusterDiscoveryCallbackPtr cluster_discovery_callback;",
          "1270:   EXPECT_CALL(*mock_odcds_api_handle_, requestOnDemandClusterDiscovery(\"fake_cluster\", _, _))",
          "1271:       .WillOnce(Invoke([&](auto&&, auto&& cb, auto&&) {",
          "1272:         cluster_discovery_callback = std::move(cb);",
          "1273:         return std::make_unique<Upstream::MockClusterDiscoveryCallbackHandle>();",
          "1274:       }));",
          "1276:   setup(1, config);",
          "1277:   std::invoke(*cluster_discovery_callback, Upstream::ClusterDiscoveryStatus::Available);",
          "1278:   raiseEventUpstreamConnected(0);",
          "1280:   Buffer::OwnedImpl buffer(\"hello\");",
          "1281:   EXPECT_CALL(*upstream_connections_.at(0), write(BufferEqual(&buffer), _));",
          "1282:   filter_->onData(buffer, false);",
          "1284:   Buffer::OwnedImpl response(\"world\");",
          "1285:   EXPECT_CALL(filter_callbacks_.connection_, write(BufferEqual(&response), _));",
          "1286:   upstream_callbacks_->onUpstreamData(response, false);",
          "1288:   EXPECT_CALL(*upstream_connections_.at(0), close(Network::ConnectionCloseType::NoFlush));",
          "1289:   filter_callbacks_.connection_.raiseEvent(Network::ConnectionEvent::LocalClose);",
          "1290: }",
          "1293: TEST_F(TcpProxyTest, OdcdsClusterMissingCauseConnectionClose) {",
          "1294:   auto config = onDemandConfig();",
          "1295:   mock_odcds_api_handle_ = Upstream::MockOdCdsApiHandle::create().release();",
          "1297:   EXPECT_CALL(factory_context_.cluster_manager_, getThreadLocalCluster(\"fake_cluster\"))",
          "1298:       .WillOnce(Return(nullptr))",
          "1299:       .RetiresOnSaturation();",
          "1301:   Upstream::ClusterDiscoveryCallbackPtr cluster_discovery_callback;",
          "1302:   EXPECT_CALL(*mock_odcds_api_handle_, requestOnDemandClusterDiscovery(\"fake_cluster\", _, _))",
          "1303:       .WillOnce(Invoke([&](auto&&, auto&& cb, auto&&) {",
          "1304:         cluster_discovery_callback = std::move(cb);",
          "1305:         return std::make_unique<Upstream::MockClusterDiscoveryCallbackHandle>();",
          "1306:       }));",
          "1308:   setup(0, config);",
          "1309:   EXPECT_EQ(Network::FilterStatus::StopIteration, filter_->onNewConnection());",
          "1311:   EXPECT_CALL(filter_callbacks_.connection_, close(_));",
          "1312:   std::invoke(*cluster_discovery_callback, Upstream::ClusterDiscoveryStatus::Missing);",
          "1313: }",
          "",
          "---------------"
        ],
        "test/integration/fake_upstream.cc||test/integration/fake_upstream.cc": [
          "File: test/integration/fake_upstream.cc -> test/integration/fake_upstream.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "718:   return AssertionFailure() << \"Timed out waiting for HTTP connection.\";",
          "719: }",
          "721: AssertionResult FakeUpstream::waitForRawConnection(FakeRawConnectionPtr& connection,",
          "722:                                                    milliseconds timeout) {",
          "723:   {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "721: ABSL_MUST_USE_RESULT",
          "722: testing::AssertionResult FakeUpstream::assertPendingConnectionsEmpty() {",
          "723:   return runOnDispatcherThreadAndWait([&]() {",
          "724:     absl::MutexLock lock(&lock_);",
          "725:     return new_connections_.empty() ? AssertionSuccess() : AssertionFailure();",
          "726:   });",
          "727: }",
          "",
          "---------------"
        ],
        "test/integration/fake_upstream.h||test/integration/fake_upstream.h": [
          "File: test/integration/fake_upstream.h -> test/integration/fake_upstream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "628:   waitForHttpConnection(Event::Dispatcher& client_dispatcher, FakeHttpConnectionPtr& connection,",
          "629:                         std::chrono::milliseconds timeout = TestUtility::DefaultTimeout);",
          "631:   ABSL_MUST_USE_RESULT",
          "632:   testing::AssertionResult",
          "633:   waitForRawConnection(FakeRawConnectionPtr& connection,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "631:   ABSL_MUST_USE_RESULT",
          "632:   testing::AssertionResult assertPendingConnectionsEmpty();",
          "",
          "---------------"
        ],
        "test/integration/tcp_proxy_odcds_integration_test.cc||test/integration/tcp_proxy_odcds_integration_test.cc": [
          "File: test/integration/tcp_proxy_odcds_integration_test.cc -> test/integration/tcp_proxy_odcds_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <string>",
          "3: #include \"envoy/common/platform.h\"",
          "4: #include \"envoy/config/cluster/v3/cluster.pb.h\"",
          "6: #include \"source/common/common/macros.h\"",
          "7: #include \"source/common/tcp_proxy/tcp_proxy.h\"",
          "9: #include \"test/common/grpc/grpc_client_integration.h\"",
          "10: #include \"test/integration/ads_integration.h\"",
          "11: #include \"test/integration/fake_upstream.h\"",
          "12: #include \"test/integration/integration.h\"",
          "13: #include \"test/test_common/resources.h\"",
          "14: #include \"test/test_common/utility.h\"",
          "16: #include \"gtest/gtest.h\"",
          "18: namespace Envoy {",
          "19: namespace {",
          "21: class TcpProxyOdcdsIntegrationTest : public Grpc::GrpcClientIntegrationParamTest,",
          "22:                                      public BaseIntegrationTest {",
          "23: public:",
          "24:   TcpProxyOdcdsIntegrationTest()",
          "25:       : BaseIntegrationTest(std::get<0>(GetParam()), ConfigHelper::tcpProxyConfig()) {",
          "30:     use_lds_ = false;",
          "31:     enableHalfClose(true);",
          "32:   }",
          "33:   void TearDown() override { cleanUpXdsConnection(); }",
          "35:   void initialize() override {",
          "36:     config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {",
          "38:       auto* static_resources = bootstrap.mutable_static_resources();",
          "39:       ASSERT(static_resources->clusters_size() == 1);",
          "40:       auto& cluster_protocol_options =",
          "42:       envoy::extensions::upstreams::http::v3::HttpProtocolOptions h2_options;",
          "43:       h2_options.mutable_explicit_http_config()->mutable_http2_protocol_options();",
          "44:       cluster_protocol_options[\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"].PackFrom(",
          "45:           h2_options);",
          "48:       ASSERT(static_resources->listeners_size() == 1);",
          "49:       auto* config_blob = static_resources->mutable_listeners(0)",
          "50:                               ->mutable_filter_chains(0)",
          "51:                               ->mutable_filters(0)",
          "52:                               ->mutable_typed_config();",
          "54:       ASSERT_TRUE(config_blob->Is<envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy>());",
          "55:       auto tcp_proxy_config =",
          "56:           MessageUtil::anyConvert<envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy>(",
          "58:       tcp_proxy_config.set_cluster(\"new_cluster\");",
          "59:       tcp_proxy_config.mutable_on_demand()->CopyFrom(",
          "60:           TestUtility::parseYaml<",
          "61:               envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy_OnDemand>(R\"EOF(",
          "62:           odcds_config:",
          "63:             resource_api_version: V3",
          "64:             api_config_source:",
          "65:               api_type: DELTA_GRPC",
          "66:               transport_api_version: V3",
          "67:               grpc_services:",
          "68:                 envoy_grpc:",
          "69:                   cluster_name: cluster_0",
          "70:       )EOF\"));",
          "71:       tcp_proxy_config.mutable_on_demand()->mutable_timeout()->set_seconds(",
          "72:           std::chrono::duration_cast<std::chrono::seconds>(odcds_timeout_).count());",
          "73:       config_blob->PackFrom(tcp_proxy_config);",
          "74:     });",
          "77:     setUpstreamCount(1);",
          "78:     setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);",
          "80:     BaseIntegrationTest::initialize();",
          "83:     addFakeUpstream(FakeHttpConnection::Type::HTTP2);",
          "85:     new_cluster_ = ConfigHelper::buildStaticCluster(",
          "86:         \"new_cluster\", fake_upstreams_.back()->localAddress()->ip()->port(),",
          "87:         Network::Test::getLoopbackAddressString(ipVersion()));",
          "89:     test_server_->waitUntilListenersReady();",
          "90:     registerTestServerPorts({\"tcp_proxy\"});",
          "91:   }",
          "92:   void setUpShortTimeout() { odcds_timeout_ = std::chrono::milliseconds(1000); }",
          "94:   ::testing::AssertionResult assertOnDemandCounters(uint64_t success, uint64_t missing,",
          "95:                                                     uint64_t timeout) {",
          "96:     auto success_counter = test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_success\");",
          "97:     auto missing_counter = test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_missing\");",
          "98:     auto timeout_counter = test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_timeout\");",
          "99:     if (success_counter && success_counter->value() == success && missing_counter &&",
          "100:         missing_counter->value() == missing && timeout_counter &&",
          "101:         timeout_counter->value() == timeout) {",
          "102:       return ::testing::AssertionSuccess();",
          "103:     } else {",
          "104:       auto to_string = [](Stats::CounterSharedPtr& counter) {",
          "105:         if (counter == nullptr) {",
          "106:           return absl::StrCat(\"not exist\");",
          "107:         } else {",
          "108:           return absl::StrCat(counter->value());",
          "109:         }",
          "110:       };",
          "111:       return ::testing::AssertionFailure()",
          "112:              << fmt::format(\"success {} vs {}, missing {} vs {}, timeout {} vs {}\", success,",
          "113:                             to_string(success_counter), missing, to_string(missing_counter),",
          "114:                             timeout, to_string(timeout_counter));",
          "115:     }",
          "116:   }",
          "119:   FakeStreamPtr odcds_stream_;",
          "120:   std::chrono::milliseconds odcds_timeout_{60000};",
          "122:   envoy::config::cluster::v3::Cluster new_cluster_;",
          "123:   std::vector<FakeRawConnectionPtr> fake_upstream_connections_;",
          "124:   std::vector<IntegrationTcpClientPtr> tcp_clients_;",
          "125: };",
          "127: INSTANTIATE_TEST_SUITE_P(IpVersionsClientType, TcpProxyOdcdsIntegrationTest,",
          "128:                          GRPC_CLIENT_INTEGRATION_PARAMS);",
          "130: TEST_P(TcpProxyOdcdsIntegrationTest, SingleTcpClient) {",
          "131:   initialize();",
          "134:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "137:   auto result = fake_upstreams_.front()->waitForHttpConnection(*dispatcher_, xds_connection_);",
          "138:   RELEASE_ASSERT(result, result.message());",
          "139:   result = xds_connection_->waitForNewStream(*dispatcher_, odcds_stream_);",
          "140:   RELEASE_ASSERT(result, result.message());",
          "141:   odcds_stream_->startGrpcStream();",
          "142:   test_server_->waitForCounterEq(\"tcp.tcp_stats.on_demand_cluster_attempt\", 1);",
          "144:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {\"new_cluster\"}, {},",
          "145:                                            odcds_stream_));",
          "147:   ASSERT_TRUE(fake_upstreams_.back()->assertPendingConnectionsEmpty());",
          "149:   sendDeltaDiscoveryResponse<envoy::config::cluster::v3::Cluster>(",
          "150:       Config::TypeUrl::get().Cluster, {new_cluster_}, {}, \"1\", odcds_stream_);",
          "151:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {}, {}, odcds_stream_));",
          "154:   FakeRawConnectionPtr fake_upstream_connection;",
          "155:   ASSERT_TRUE(fake_upstreams_.back()->waitForRawConnection(fake_upstream_connection));",
          "157:   ASSERT_TRUE(fake_upstream_connection->write(\"hello\"));",
          "158:   tcp_client->waitForData(\"hello\");",
          "160:   ASSERT_TRUE(tcp_client->write(\"world\"));",
          "161:   ASSERT_TRUE(fake_upstream_connection->waitForData(5));",
          "163:   ASSERT_TRUE(fake_upstream_connection->close());",
          "164:   ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());",
          "165:   tcp_client->waitForHalfClose();",
          "166:   tcp_client->close();",
          "167:   assertOnDemandCounters(1, 0, 0);",
          "168: }",
          "171: TEST_P(TcpProxyOdcdsIntegrationTest, RepeatedRequest) {",
          "172:   uint32_t expected_upstream_connections = 10;",
          "173:   initialize();",
          "176:   for (auto n = expected_upstream_connections; n != 0; n--) {",
          "177:     tcp_clients_.push_back(makeTcpConnection(lookupPort(\"tcp_proxy\")));",
          "178:   }",
          "181:   auto result = fake_upstreams_.front()->waitForHttpConnection(*dispatcher_, xds_connection_);",
          "182:   RELEASE_ASSERT(result, result.message());",
          "183:   result = xds_connection_->waitForNewStream(*dispatcher_, odcds_stream_);",
          "184:   RELEASE_ASSERT(result, result.message());",
          "185:   odcds_stream_->startGrpcStream();",
          "188:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {\"new_cluster\"}, {},",
          "189:                                            odcds_stream_));",
          "190:   sendDeltaDiscoveryResponse<envoy::config::cluster::v3::Cluster>(",
          "191:       Config::TypeUrl::get().Cluster, {new_cluster_}, {}, \"1\", odcds_stream_);",
          "192:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {}, {}, odcds_stream_));",
          "194:   test_server_->waitForCounterEq(\"tcp.tcp_stats.on_demand_cluster_attempt\",",
          "195:                                  expected_upstream_connections);",
          "198:   for (auto n = expected_upstream_connections; n != 0; n--) {",
          "199:     fake_upstream_connections_.push_back(nullptr);",
          "200:     auto& fake_upstream_connection = fake_upstream_connections_.back();",
          "201:     ASSERT_TRUE(fake_upstreams_.back()->waitForRawConnection(fake_upstream_connection));",
          "202:     ASSERT_TRUE(fake_upstream_connection->write(\"hello\"));",
          "203:   }",
          "205:   for (auto& tcp_client : tcp_clients_) {",
          "206:     tcp_client->waitForData(\"hello\");",
          "207:     ASSERT_TRUE(tcp_client->write(\"world\"));",
          "208:   }",
          "210:   for (auto& fake_upstream_connection : fake_upstream_connections_) {",
          "211:     ASSERT_TRUE(fake_upstream_connection->waitForData(5));",
          "212:     ASSERT_TRUE(fake_upstream_connection->close());",
          "213:     ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());",
          "214:   }",
          "216:   for (auto& tcp_client : tcp_clients_) {",
          "217:     tcp_client->waitForHalfClose();",
          "218:     tcp_client->close();",
          "219:   }",
          "221:   auto success_value = test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_success\")->value();",
          "223:   EXPECT_GE(expected_upstream_connections, success_value);",
          "224:   EXPECT_LE(1, success_value);",
          "225:   EXPECT_EQ(0, test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_missing\")->value());",
          "226:   EXPECT_EQ(0, test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_timeout\")->value());",
          "227: }",
          "229: TEST_P(TcpProxyOdcdsIntegrationTest, ShutdownConnectionOnTimeout) {",
          "230:   setUpShortTimeout();",
          "231:   initialize();",
          "234:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "237:   auto result = fake_upstreams_.front()->waitForHttpConnection(*dispatcher_, xds_connection_);",
          "238:   RELEASE_ASSERT(result, result.message());",
          "239:   result = xds_connection_->waitForNewStream(*dispatcher_, odcds_stream_);",
          "240:   RELEASE_ASSERT(result, result.message());",
          "241:   odcds_stream_->startGrpcStream();",
          "244:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {\"new_cluster\"}, {},",
          "245:                                            odcds_stream_));",
          "246:   EXPECT_EQ(1, test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_attempt\")->value());",
          "248:   tcp_client->waitForHalfClose();",
          "249:   tcp_client->close();",
          "250:   assertOnDemandCounters(0, 0, 1);",
          "251: }",
          "253: TEST_P(TcpProxyOdcdsIntegrationTest, ShutdownConnectionOnClusterMissing) {",
          "254:   initialize();",
          "257:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "260:   auto result = fake_upstreams_.front()->waitForHttpConnection(*dispatcher_, xds_connection_);",
          "261:   RELEASE_ASSERT(result, result.message());",
          "262:   result = xds_connection_->waitForNewStream(*dispatcher_, odcds_stream_);",
          "263:   RELEASE_ASSERT(result, result.message());",
          "264:   odcds_stream_->startGrpcStream();",
          "267:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {\"new_cluster\"}, {},",
          "268:                                            odcds_stream_));",
          "269:   sendDeltaDiscoveryResponse<envoy::config::cluster::v3::Cluster>(",
          "270:       Config::TypeUrl::get().Cluster, {}, {\"new_cluster\"}, \"1\", odcds_stream_);",
          "271:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {}, {}, odcds_stream_));",
          "273:   EXPECT_EQ(1, test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_attempt\")->value());",
          "275:   tcp_client->waitForHalfClose();",
          "276:   tcp_client->close();",
          "277:   assertOnDemandCounters(0, 1, 0);",
          "278: }",
          "280: TEST_P(TcpProxyOdcdsIntegrationTest, ShutdownAllConnectionsOnClusterLookupTimeout) {",
          "281:   setUpShortTimeout();",
          "282:   initialize();",
          "285:   IntegrationTcpClientPtr tcp_client_1 = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "288:   auto result = fake_upstreams_.front()->waitForHttpConnection(*dispatcher_, xds_connection_);",
          "289:   RELEASE_ASSERT(result, result.message());",
          "290:   result = xds_connection_->waitForNewStream(*dispatcher_, odcds_stream_);",
          "291:   RELEASE_ASSERT(result, result.message());",
          "292:   odcds_stream_->startGrpcStream();",
          "295:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {\"new_cluster\"}, {},",
          "296:                                            odcds_stream_));",
          "298:   EXPECT_EQ(1, test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_attempt\")->value());",
          "301:   IntegrationTcpClientPtr tcp_client_2 = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "302:   test_server_->waitForCounterEq(\"tcp.tcp_stats.on_demand_cluster_attempt\", 2);",
          "304:   tcp_client_1->waitForHalfClose();",
          "305:   tcp_client_2->waitForHalfClose();",
          "306:   assertOnDemandCounters(0, 0, 2);",
          "307:   tcp_client_1->close();",
          "308:   tcp_client_2->close();",
          "309: }",
          "312: TEST_P(TcpProxyOdcdsIntegrationTest, ShutdownTcpClientBeforeOdcdsResponse) {",
          "313:   initialize();",
          "316:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "319:   auto result = fake_upstreams_.front()->waitForHttpConnection(*dispatcher_, xds_connection_);",
          "320:   RELEASE_ASSERT(result, result.message());",
          "321:   result = xds_connection_->waitForNewStream(*dispatcher_, odcds_stream_);",
          "322:   RELEASE_ASSERT(result, result.message());",
          "323:   odcds_stream_->startGrpcStream();",
          "326:   EXPECT_TRUE(compareDeltaDiscoveryRequest(Config::TypeUrl::get().Cluster, {\"new_cluster\"}, {},",
          "327:                                            odcds_stream_));",
          "328:   EXPECT_EQ(1, test_server_->counter(\"tcp.tcp_stats.on_demand_cluster_attempt\")->value());",
          "330:   tcp_client->close();",
          "331:   assertOnDemandCounters(0, 0, 0);",
          "332: }",
          "334: } // namespace",
          "335: } // namespace Envoy",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ac02715d687b72b901e870f3b1e9b005289365e4",
      "candidate_info": {
        "commit_hash": "ac02715d687b72b901e870f3b1e9b005289365e4",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/ac02715d687b72b901e870f3b1e9b005289365e4",
        "files": [
          "changelogs/current.yaml",
          "source/common/http/http2/codec_impl.cc",
          "source/common/quic/envoy_quic_client_stream.cc",
          "source/common/runtime/runtime_features.cc",
          "source/common/tcp_proxy/upstream.cc",
          "test/common/http/http2/codec_impl_test.cc",
          "test/common/tcp_proxy/BUILD",
          "test/common/tcp_proxy/upstream_test.cc",
          "test/extensions/filters/http/compressor/compressor_integration_tests.cc",
          "test/extensions/filters/http/jwt_authn/filter_integration_test.cc",
          "test/integration/BUILD",
          "test/integration/protocol_integration_test.cc",
          "test/integration/tcp_tunneling_integration_test.cc"
        ],
        "message": "http: fixing up CONNECT to be RFC compliant (#21440)\n\nRisk Level: Medium (data plane changes)\nTesting: updated tests\nDocs Changes: n/a\nRelease Notes: inline\nRuntime guard: envoy.reloadable_features.use_rfc_connect\nFixes #20378\n\nSigned-off-by: Alyssa Wilk <alyssar@chromium.org>",
        "before_after_code_files": [
          "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc",
          "source/common/quic/envoy_quic_client_stream.cc||source/common/quic/envoy_quic_client_stream.cc",
          "source/common/runtime/runtime_features.cc||source/common/runtime/runtime_features.cc",
          "source/common/tcp_proxy/upstream.cc||source/common/tcp_proxy/upstream.cc",
          "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc",
          "test/common/tcp_proxy/upstream_test.cc||test/common/tcp_proxy/upstream_test.cc",
          "test/extensions/filters/http/compressor/compressor_integration_tests.cc||test/extensions/filters/http/compressor/compressor_integration_tests.cc",
          "test/extensions/filters/http/jwt_authn/filter_integration_test.cc||test/extensions/filters/http/jwt_authn/filter_integration_test.cc",
          "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc",
          "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ],
          "candidate": [
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc": [
          "File: source/common/http/http2/codec_impl.cc -> source/common/http/http2/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "302:     modified_headers = createHeaderMap<RequestHeaderMapImpl>(headers);",
          "306:     }",
          "307:     encodeHeadersBase(*modified_headers, end_stream);",
          "308:   } else {",
          "",
          "[Removed Lines]",
          "303:     modified_headers->setProtocol(Headers::get().ProtocolValues.Bytestream);",
          "304:     if (!headers.Path()) {",
          "305:       modified_headers->setPath(\"/\");",
          "",
          "[Added Lines]",
          "303:     if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.use_rfc_connect\")) {",
          "304:       modified_headers->removeScheme();",
          "305:       modified_headers->removePath();",
          "306:       modified_headers->removeProtocol();",
          "307:     } else {",
          "308:       modified_headers->setProtocol(Headers::get().ProtocolValues.Bytestream);",
          "309:       if (!headers.Path()) {",
          "310:         modified_headers->setPath(\"/\");",
          "311:       }",
          "",
          "---------------"
        ],
        "source/common/quic/envoy_quic_client_stream.cc||source/common/quic/envoy_quic_client_stream.cc": [
          "File: source/common/quic/envoy_quic_client_stream.cc -> source/common/quic/envoy_quic_client_stream.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:   auto spdy_headers = envoyHeadersToSpdyHeaderBlock(headers);",
          "45:   if (headers.Method()) {",
          "46:     if (headers.Method()->value() == \"CONNECT\") {",
          "55:       }",
          "56:     } else if (headers.Method()->value() == \"HEAD\") {",
          "57:       sent_head_request_ = true;",
          "",
          "[Removed Lines]",
          "52:       spdy_headers[\":protocol\"] = Http::Headers::get().ProtocolValues.Bytestream;",
          "53:       if (!headers.Path()) {",
          "54:         spdy_headers[\":path\"] = \"/\";",
          "",
          "[Added Lines]",
          "47:       if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.use_rfc_connect\")) {",
          "48:         spdy_headers.erase(\":scheme\");",
          "49:         spdy_headers.erase(\":path\");",
          "50:         spdy_headers.erase(\":protocol\");",
          "51:       } else {",
          "54:         spdy_headers[\":protocol\"] = Http::Headers::get().ProtocolValues.Bytestream;",
          "55:         if (!headers.Path()) {",
          "56:           spdy_headers[\":path\"] = \"/\";",
          "57:         }",
          "",
          "---------------"
        ],
        "source/common/runtime/runtime_features.cc||source/common/runtime/runtime_features.cc": [
          "File: source/common/runtime/runtime_features.cc -> source/common/runtime/runtime_features.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "71: RUNTIME_GUARD(envoy_reloadable_features_udp_listener_updates_filter_chain_in_place);",
          "72: RUNTIME_GUARD(envoy_reloadable_features_update_expected_rq_timeout_on_retry);",
          "73: RUNTIME_GUARD(envoy_reloadable_features_update_grpc_response_error_tag);",
          "74: RUNTIME_GUARD(envoy_reloadable_features_validate_connect);",
          "75: RUNTIME_GUARD(envoy_restart_features_explicit_wildcard_resource);",
          "76: RUNTIME_GUARD(envoy_restart_features_remove_runtime_singleton);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: RUNTIME_GUARD(envoy_reloadable_features_use_rfc_connect);",
          "",
          "---------------"
        ],
        "source/common/tcp_proxy/upstream.cc||source/common/tcp_proxy/upstream.cc": [
          "File: source/common/tcp_proxy/upstream.cc -> source/common/tcp_proxy/upstream.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "278:   auto headers = Http::createHeaderMap<Http::RequestHeaderMapImpl>({",
          "279:       {Http::Headers::get().Method, config_.usePost() ? \"POST\" : \"CONNECT\"},",
          "280:       {Http::Headers::get().Host, config_.hostname()},",
          "283:   });",
          "286:     headers->addReference(Http::Headers::get().Protocol,",
          "287:                           Http::Headers::get().ProtocolValues.Bytestream);",
          "288:   }",
          "",
          "[Removed Lines]",
          "281:       {Http::Headers::get().Path, \"/\"},",
          "282:       {Http::Headers::get().Scheme, scheme},",
          "285:   if (!config_.usePost()) {",
          "",
          "[Added Lines]",
          "283:   if (config_.usePost()) {",
          "284:     headers->addReference(Http::Headers::get().Path, \"/\");",
          "285:     headers->addReference(Http::Headers::get().Scheme, scheme);",
          "286:   } else if (!Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.use_rfc_connect\")) {",
          "287:     headers->addReference(Http::Headers::get().Path, \"/\");",
          "288:     headers->addReference(Http::Headers::get().Scheme, scheme);",
          "",
          "---------------"
        ],
        "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc": [
          "File: test/common/http/http2/codec_impl_test.cc -> test/common/http/http2/codec_impl_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "3613: }",
          "3617:   client_http2_options_.set_allow_connect(true);",
          "3618:   server_http2_options_.set_allow_connect(true);",
          "3619:   initialize();",
          "",
          "[Removed Lines]",
          "3616: TEST_P(Http2CodecImplTest, ConnectTest) {",
          "",
          "[Added Lines]",
          "3616: TEST_P(Http2CodecImplTest, ConnectTestOld) {",
          "3617:   scoped_runtime_.mergeValues({{\"envoy.reloadable_features.use_rfc_connect\", \"false\"}});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3639:   driveToCompletion();",
          "3640: }",
          "3642: TEST_P(Http2CodecImplTest, ShouldWaitForDeferredBodyToProcessBeforeProcessingTrailers) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3643: TEST_P(Http2CodecImplTest, ConnectTest) {",
          "3644:   client_http2_options_.set_allow_connect(true);",
          "3645:   server_http2_options_.set_allow_connect(true);",
          "3646:   initialize();",
          "3647:   MockStreamCallbacks callbacks;",
          "3648:   request_encoder_->getStream().addCallbacks(callbacks);",
          "3650:   TestRequestHeaderMapImpl request_headers;",
          "3651:   HttpTestUtility::addDefaultHeaders(request_headers);",
          "3652:   request_headers.setReferenceKey(Headers::get().Method, Http::Headers::get().MethodValues.Connect);",
          "3653:   request_headers.setReferenceKey(Headers::get().Protocol, \"bytestream\");",
          "3654:   TestRequestHeaderMapImpl expected_headers;",
          "3655:   expected_headers.setReferenceKey(Headers::get().Host, \"host\");",
          "3656:   expected_headers.setReferenceKey(Headers::get().Method,",
          "3657:                                    Http::Headers::get().MethodValues.Connect);",
          "3658:   EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), false));",
          "3659:   EXPECT_TRUE(request_encoder_->encodeHeaders(request_headers, false).ok());",
          "3660:   driveToCompletion();",
          "3662:   EXPECT_CALL(callbacks, onResetStream(StreamResetReason::ConnectError, _));",
          "3663:   EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::ConnectError, _));",
          "3664:   response_encoder_->getStream().resetStream(StreamResetReason::ConnectError);",
          "3665:   driveToCompletion();",
          "3666: }",
          "",
          "---------------"
        ],
        "test/common/tcp_proxy/upstream_test.cc||test/common/tcp_proxy/upstream_test.cc": [
          "File: test/common/tcp_proxy/upstream_test.cc -> test/common/tcp_proxy/upstream_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"test/mocks/tcp/mocks.h\"",
          "10: #include \"test/test_common/environment.h\"",
          "11: #include \"test/test_common/network_utility.h\"",
          "13: #include \"gmock/gmock.h\"",
          "14: #include \"gtest/gtest.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"test/test_common/test_runtime.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224: TYPED_TEST_SUITE(HttpUpstreamRequestEncoderTest, Implementations);",
          "227:   this->setupUpstream();",
          "228:   std::unique_ptr<Http::RequestHeaderMapImpl> expected_headers;",
          "229:   expected_headers = Http::createHeaderMap<Http::RequestHeaderMapImpl>({",
          "",
          "[Removed Lines]",
          "226: TYPED_TEST(HttpUpstreamRequestEncoderTest, RequestEncoder) {",
          "",
          "[Added Lines]",
          "227: TYPED_TEST(HttpUpstreamRequestEncoderTest, RequestEncoderOld) {",
          "228:   TestScopedRuntime scoped_runtime;",
          "229:   scoped_runtime.mergeValues({{\"envoy.reloadable_features.use_rfc_connect\", \"false\"}});",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "243:   this->upstream_->setRequestEncoder(this->encoder_, false);",
          "244: }",
          "246: TYPED_TEST(HttpUpstreamRequestEncoderTest, RequestEncoderUsePost) {",
          "247:   this->config_message_.set_use_post(true);",
          "248:   this->setupUpstream();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "250: TYPED_TEST(HttpUpstreamRequestEncoderTest, RequestEncoder) {",
          "251:   this->setupUpstream();",
          "252:   std::unique_ptr<Http::RequestHeaderMapImpl> expected_headers;",
          "253:   expected_headers = Http::createHeaderMap<Http::RequestHeaderMapImpl>({",
          "254:       {Http::Headers::get().Method, \"CONNECT\"},",
          "255:       {Http::Headers::get().Host, this->config_->hostname()},",
          "256:   });",
          "258:   EXPECT_CALL(this->encoder_, encodeHeaders(HeaderMapEqualRef(expected_headers.get()), false));",
          "259:   this->upstream_->setRequestEncoder(this->encoder_, false);",
          "260: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "287:       {Http::Headers::get().Host, this->config_->hostname()},",
          "288:   });",
          "298:   expected_headers->setCopy(Http::LowerCaseString(\"header0\"), \"value0\");",
          "299:   expected_headers->addCopy(Http::LowerCaseString(\"header1\"), \"value1\");",
          "300:   expected_headers->addCopy(Http::LowerCaseString(\"header1\"), \"value2\");",
          "",
          "[Removed Lines]",
          "290:   if (this->is_http2_) {",
          "291:     expected_headers->setReferenceKey(Http::Headers::get().Path, \"/\");",
          "292:     expected_headers->setReferenceKey(Http::Headers::get().Scheme,",
          "293:                                       Http::Headers::get().SchemeValues.Http);",
          "294:     expected_headers->setReferenceKey(Http::Headers::get().Protocol,",
          "295:                                       Http::Headers::get().ProtocolValues.Bytestream);",
          "296:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "323:       {Http::Headers::get().Host, this->config_->hostname()},",
          "324:   });",
          "334:   expected_headers->setCopy(Http::LowerCaseString(\"key\"), \"value1\");",
          "335:   expected_headers->addCopy(Http::LowerCaseString(\"key\"), \"value2\");",
          "345:   expected_headers->setCopy(Http::LowerCaseString(\"key\"), \"value1\");",
          "346:   expected_headers->addCopy(Http::LowerCaseString(\"key\"), \"value2\");",
          "",
          "[Removed Lines]",
          "326:   if (this->is_http2_) {",
          "327:     expected_headers->setReferenceKey(Http::Headers::get().Path, \"/\");",
          "328:     expected_headers->setReferenceKey(Http::Headers::get().Scheme,",
          "329:                                       Http::Headers::get().SchemeValues.Http);",
          "330:     expected_headers->setReferenceKey(Http::Headers::get().Protocol,",
          "331:                                       Http::Headers::get().ProtocolValues.Bytestream);",
          "332:   }",
          "337:   if (this->is_http2_) {",
          "338:     expected_headers->setReferenceKey(Http::Headers::get().Path, \"/\");",
          "339:     expected_headers->setReferenceKey(Http::Headers::get().Scheme,",
          "340:                                       Http::Headers::get().SchemeValues.Http);",
          "341:     expected_headers->setReferenceKey(Http::Headers::get().Protocol,",
          "342:                                       Http::Headers::get().ProtocolValues.Bytestream);",
          "343:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "382:       {Http::Headers::get().Host, this->config_->hostname()},",
          "383:   });",
          "393:   expected_headers->setCopy(Http::LowerCaseString(\"header0\"), \"value0\");",
          "394:   expected_headers->addCopy(Http::LowerCaseString(\"downstream_local_port\"), \"80\");",
          "395:   auto ip_versions = TestEnvironment::getIpVersionsForTest();",
          "",
          "[Removed Lines]",
          "385:   if (this->is_http2_) {",
          "386:     expected_headers->setReferenceKey(Http::Headers::get().Path, \"/\");",
          "387:     expected_headers->setReferenceKey(Http::Headers::get().Scheme,",
          "388:                                       Http::Headers::get().SchemeValues.Http);",
          "389:     expected_headers->setReferenceKey(Http::Headers::get().Protocol,",
          "390:                                       Http::Headers::get().ProtocolValues.Bytestream);",
          "391:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/extensions/filters/http/compressor/compressor_integration_tests.cc||test/extensions/filters/http/compressor/compressor_integration_tests.cc": [
          "File: test/extensions/filters/http/compressor/compressor_integration_tests.cc -> test/extensions/filters/http/compressor/compressor_integration_tests.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "268:   RELEASE_ASSERT(result, result.message());",
          "269:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
          "270:   EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Method)[0]->value(), \"CONNECT\");",
          "279:   upstream_request_->encodeHeaders(default_response_headers_, false);",
          "",
          "[Removed Lines]",
          "271:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
          "272:     EXPECT_TRUE(upstream_request_->headers().get(Http::Headers::get().Protocol).empty());",
          "273:   } else {",
          "274:     EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Protocol)[0]->value(),",
          "275:               \"bytestream\");",
          "276:   }",
          "",
          "[Added Lines]",
          "271:   EXPECT_TRUE(upstream_request_->headers().get(Http::Headers::get().Protocol).empty());",
          "",
          "---------------"
        ],
        "test/extensions/filters/http/jwt_authn/filter_integration_test.cc||test/extensions/filters/http/jwt_authn/filter_integration_test.cc": [
          "File: test/extensions/filters/http/jwt_authn/filter_integration_test.cc -> test/extensions/filters/http/jwt_authn/filter_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "303:   request_encoder_ = &encoder_decoder.first;",
          "304:   auto response = std::move(encoder_decoder.second);",
          "316: }",
          "",
          "[Removed Lines]",
          "306:   if (downstreamProtocol() == Http::CodecType::HTTP1) {",
          "309:     ASSERT_TRUE(response->waitForEndStream());",
          "310:     ASSERT_TRUE(response->complete());",
          "311:     EXPECT_EQ(\"404\", response->headers().getStatusValue());",
          "312:   } else {",
          "313:     ASSERT_TRUE(response->waitForReset());",
          "314:     ASSERT_TRUE(codec_client_->waitForDisconnect());",
          "315:   }",
          "",
          "[Added Lines]",
          "308:   ASSERT_TRUE(response->waitForEndStream());",
          "309:   ASSERT_TRUE(response->complete());",
          "310:   EXPECT_EQ(\"404\", response->headers().getStatusValue());",
          "",
          "---------------"
        ],
        "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc": [
          "File: test/integration/protocol_integration_test.cc -> test/integration/protocol_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2733:   request_encoder_ = &encoder_decoder.first;",
          "2734:   auto response = std::move(encoder_decoder.second);",
          "2746: }",
          "2748: TEST_P(DownstreamProtocolIntegrationTest, ExtendedConnectIsBlocked) {",
          "2749:   if (downstreamProtocol() == Http::CodecType::HTTP1) {",
          "2750:     return;",
          "2751:   }",
          "",
          "[Removed Lines]",
          "2736:   if (downstreamProtocol() == Http::CodecType::HTTP1) {",
          "2739:     ASSERT_TRUE(response->waitForEndStream());",
          "2740:     EXPECT_EQ(\"404\", response->headers().getStatusValue());",
          "2741:     EXPECT_TRUE(response->complete());",
          "2742:   } else {",
          "2743:     ASSERT_TRUE(response->waitForReset());",
          "2744:     ASSERT_TRUE(codec_client_->waitForDisconnect());",
          "2745:   }",
          "",
          "[Added Lines]",
          "2738:   ASSERT_TRUE(response->waitForEndStream());",
          "2739:   EXPECT_EQ(\"404\", response->headers().getStatusValue());",
          "2740:   EXPECT_TRUE(response->complete());",
          "2744:   config_helper_.addRuntimeOverride(\"envoy.reloadable_features.use_rfc_connect\", \"false\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2785:   auto response = codec_client_->makeHeaderOnlyRequest(",
          "2786:       Http::TestRequestHeaderMapImpl{{\":method\", \"CONNECT\"}, {\":authority\", \"sni.lyft.com\"}});",
          "2789:   EXPECT_FALSE(codec_client_->disconnected());",
          "2790: }",
          "",
          "[Removed Lines]",
          "2788:   ASSERT_TRUE(response->waitForReset());",
          "",
          "[Added Lines]",
          "2784:   ASSERT_TRUE(response->waitForEndStream());",
          "2785:   EXPECT_EQ(\"404\", response->headers().getStatusValue());",
          "",
          "---------------"
        ],
        "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc": [
          "File: test/integration/tcp_tunneling_integration_test.cc -> test/integration/tcp_tunneling_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:             auto* route_config = hcm.mutable_route_config();",
          "34:             ASSERT_EQ(1, route_config->virtual_hosts_size());",
          "35:             route_config->mutable_virtual_hosts(0)->clear_domains();",
          "37:           }",
          "38:         });",
          "39:     HttpIntegrationTest::initialize();",
          "",
          "[Removed Lines]",
          "36:             route_config->mutable_virtual_hosts(0)->add_domains(\"host:80\");",
          "",
          "[Added Lines]",
          "36:             route_config->mutable_virtual_hosts(0)->add_domains(\"foo.lyft.com:80\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:                                                   {\":path\", \"/\"},",
          "68:                                                   {\":protocol\", \"bytestream\"},",
          "69:                                                   {\":scheme\", \"https\"},",
          "71:   void clearExtendedConnectHeaders() {",
          "72:     connect_headers_.removeProtocol();",
          "73:     connect_headers_.removePath();",
          "",
          "[Removed Lines]",
          "70:                                                   {\":authority\", \"host:80\"}};",
          "",
          "[Added Lines]",
          "70:                                                   {\":authority\", \"foo.lyft.com:80\"}};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "227:                                      {\":path\", \"/\"},",
          "228:                                      {\":protocol\", \"bytestream\"},",
          "229:                                      {\":scheme\", \"https\"},",
          "233:   if (fake_upstreams_[0]->waitForRawConnection(fake_raw_upstream_connection_) &&",
          "",
          "[Removed Lines]",
          "230:                                      {\":authority\", \"host:80\"}});",
          "",
          "[Added Lines]",
          "230:                                      {\":authority\", \"foo.lyft.com:80\"}});",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "300:   }",
          "302:   Http::TestRequestHeaderMapImpl connect_headers_{{\":method\", \"CONNECT\"},",
          "307:   IntegrationStreamDecoderPtr response_;",
          "308: };",
          "317: TEST_P(ProxyingConnectIntegrationTest, ProxyConnect) {",
          "318:   initialize();",
          "",
          "[Removed Lines]",
          "303:                                                   {\":path\", \"/\"},",
          "304:                                                   {\":protocol\", \"bytestream\"},",
          "305:                                                   {\":scheme\", \"https\"},",
          "306:                                                   {\":authority\", \"host:80\"}};",
          "310: INSTANTIATE_TEST_SUITE_P(Protocols, ProxyingConnectIntegrationTest,",
          "311:                          testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(",
          "312:                              {Http::CodecType::HTTP1, Http::CodecType::HTTP2,",
          "313:                               Http::CodecType::HTTP3},",
          "314:                              {Http::CodecType::HTTP1})),",
          "315:                          HttpProtocolIntegrationTest::protocolTestParamsToString);",
          "",
          "[Added Lines]",
          "303:                                                   {\":authority\", \"foo.lyft.com:80\"}};",
          "307: INSTANTIATE_TEST_SUITE_P(",
          "308:     Protocols, ProxyingConnectIntegrationTest,",
          "309:     testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(",
          "310:         {Http::CodecType::HTTP1, Http::CodecType::HTTP2, Http::CodecType::HTTP3},",
          "311:         {Http::CodecType::HTTP1, Http::CodecType::HTTP2, Http::CodecType::HTTP3})),",
          "312:     HttpProtocolIntegrationTest::protocolTestParamsToString);",
          "314: TEST_P(ProxyingConnectIntegrationTest, ProxyConnectLegacy) {",
          "315:   config_helper_.addRuntimeOverride(\"envoy.reloadable_features.use_rfc_connect\", \"false\");",
          "317:   initialize();",
          "319:   Http::TestRequestHeaderMapImpl legacy_connect_headers{{\":method\", \"CONNECT\"},",
          "320:                                                         {\":path\", \"/\"},",
          "321:                                                         {\":protocol\", \"bytestream\"},",
          "322:                                                         {\":scheme\", \"https\"},",
          "323:                                                         {\":authority\", \"foo.lyft.com:80\"}};",
          "325:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "326:   auto encoder_decoder = codec_client_->startRequest(legacy_connect_headers);",
          "327:   request_encoder_ = &encoder_decoder.first;",
          "328:   response_ = std::move(encoder_decoder.second);",
          "331:   AssertionResult result =",
          "332:       fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_);",
          "333:   RELEASE_ASSERT(result, result.message());",
          "334:   result = fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_);",
          "335:   RELEASE_ASSERT(result, result.message());",
          "336:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
          "337:   EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Method)[0]->value(), \"CONNECT\");",
          "338:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
          "339:     EXPECT_TRUE(upstream_request_->headers().get(Http::Headers::get().Protocol).empty());",
          "340:   } else {",
          "341:     EXPECT_EQ(upstream_request_->headers().getProtocolValue(), \"bytestream\");",
          "342:   }",
          "345:   upstream_request_->encodeHeaders(default_response_headers_, false);",
          "348:   response_->waitForHeaders();",
          "349:   EXPECT_EQ(\"200\", response_->headers().getStatusValue());",
          "352:   codec_client_->sendData(*request_encoder_, \"hello\", false);",
          "353:   ASSERT_TRUE(upstream_request_->waitForData(*dispatcher_, 5));",
          "356:   upstream_request_->encodeData(12, false);",
          "357:   response_->waitForBodyData(12);",
          "359:   cleanupUpstreamAndDownstream();",
          "360: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "334:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
          "335:     EXPECT_TRUE(upstream_request_->headers().get(Http::Headers::get().Protocol).empty());",
          "336:   } else {",
          "339:   }",
          "",
          "[Removed Lines]",
          "337:     EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Protocol)[0]->value(),",
          "338:               \"bytestream\");",
          "",
          "[Added Lines]",
          "382:     EXPECT_EQ(\"\", upstream_request_->headers().getSchemeValue());",
          "383:     EXPECT_EQ(\"\", upstream_request_->headers().getProtocolValue());",
          "384:     EXPECT_EQ(\"\", upstream_request_->headers().getSchemeValue());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "384:   RELEASE_ASSERT(result, result.message());",
          "385:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
          "386:   EXPECT_EQ(upstream_request_->headers().getMethodValue(), \"CONNECT\");",
          "393:   auto stripped_host = upstream_request_->headers().get(Http::LowerCaseString(\"host-in-envoy\"));",
          "394:   ASSERT_EQ(stripped_host.size(), 1);",
          "398:   upstream_request_->encodeHeaders(default_response_headers_, false);",
          "",
          "[Removed Lines]",
          "387:   EXPECT_EQ(upstream_request_->headers().getHostValue(), \"host:80\");",
          "388:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
          "389:     EXPECT_TRUE(upstream_request_->headers().getProtocolValue().empty());",
          "390:   } else {",
          "391:     EXPECT_EQ(upstream_request_->headers().getProtocolValue(), \"bytestream\");",
          "392:   }",
          "395:   EXPECT_EQ(stripped_host[0]->value(), \"host\");",
          "",
          "[Added Lines]",
          "433:   EXPECT_EQ(upstream_request_->headers().getHostValue(), \"foo.lyft.com:80\");",
          "436:   EXPECT_EQ(stripped_host[0]->value(), \"foo.lyft.com\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "430:   RELEASE_ASSERT(result, result.message());",
          "431:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
          "432:   EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Method)[0]->value(), \"CONNECT\");",
          "441:   upstream_request_->encodeHeaders(default_response_headers_, false);",
          "",
          "[Removed Lines]",
          "433:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
          "434:     EXPECT_TRUE(upstream_request_->headers().get(Http::Headers::get().Protocol).empty());",
          "435:   } else {",
          "436:     EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Protocol)[0]->value(),",
          "437:               \"bytestream\");",
          "438:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "467:           envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
          "468:           proxy_config.set_stat_prefix(\"tcp_stats\");",
          "469:           proxy_config.set_cluster(\"cluster_0\");",
          "472:           auto* listener = bootstrap.mutable_static_resources()->add_listeners();",
          "473:           listener->set_name(\"tcp_proxy\");",
          "",
          "[Removed Lines]",
          "470:           proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "",
          "[Added Lines]",
          "505:           proxy_config.mutable_tunneling_config()->set_hostname(\"foo.lyft.com:80\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "568:     envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
          "569:     proxy_config.set_stat_prefix(\"tcp_stats\");",
          "570:     proxy_config.set_cluster(\"cluster_0\");",
          "572:     proxy_config.mutable_tunneling_config()->set_use_post(true);",
          "574:     auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();",
          "",
          "[Removed Lines]",
          "571:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "",
          "[Added Lines]",
          "606:     proxy_config.mutable_tunneling_config()->set_hostname(\"foo.lyft.com:80\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "605:     envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
          "606:     proxy_config.set_stat_prefix(\"tcp_stats\");",
          "607:     proxy_config.set_cluster(\"cluster_0\");",
          "609:     auto new_header = proxy_config.mutable_tunneling_config()->mutable_headers_to_add()->Add();",
          "610:     new_header->mutable_header()->set_key(\"downstream-local-ip\");",
          "611:     new_header->mutable_header()->set_value(\"%DOWNSTREAM_LOCAL_ADDRESS_WITHOUT_PORT%\");",
          "",
          "[Removed Lines]",
          "608:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "",
          "[Added Lines]",
          "643:     proxy_config.mutable_tunneling_config()->set_hostname(\"foo.lyft.com:80\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "657:   config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {",
          "658:     proxy_config.set_stat_prefix(\"tcp_stats\");",
          "659:     proxy_config.set_cluster(\"cluster_0\");",
          "661:     auto address_header = proxy_config.mutable_tunneling_config()->mutable_headers_to_add()->Add();",
          "662:     address_header->mutable_header()->set_key(\"config-version\");",
          "663:     address_header->mutable_header()->set_value(\"1\");",
          "",
          "[Removed Lines]",
          "660:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "",
          "[Added Lines]",
          "695:     proxy_config.mutable_tunneling_config()->set_hostname(\"foo.lyft.com:80\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "858:     envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
          "859:     proxy_config.set_stat_prefix(\"tcp_stats\");",
          "860:     proxy_config.set_cluster(\"cluster_0\");",
          "",
          "[Removed Lines]",
          "861:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "",
          "[Added Lines]",
          "896:     proxy_config.mutable_tunneling_config()->set_hostname(\"foo.lyft.com:80\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1206:   std::string data;",
          "1207:   ASSERT_TRUE(fake_upstream_connection->waitForData(",
          "1208:       FakeRawConnection::waitForInexactMatch(\"\\r\\n\\r\\n\"), &data));",
          "1212:   ASSERT_TRUE(",
          "",
          "[Removed Lines]",
          "1209:   ASSERT_THAT(data, testing::HasSubstr(\"CONNECT host.com:80 HTTP/1.1\"));",
          "",
          "[Added Lines]",
          "1244:   ASSERT_THAT(data, testing::HasSubstr(\"CONNECT foo.lyft.com:80 HTTP/1.1\"));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1295:   tcp_client_->close();",
          "1296: }",
          "1304: } // namespace",
          "1305: } // namespace Envoy",
          "",
          "[Removed Lines]",
          "1298: INSTANTIATE_TEST_SUITE_P(IpAndHttpVersions, TcpTunnelingIntegrationTest,",
          "1299:                          testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(",
          "1300:                              {Http::CodecType::HTTP1},",
          "1301:                              {Http::CodecType::HTTP1, Http::CodecType::HTTP2,",
          "1302:                               Http::CodecType::HTTP3})),",
          "1303:                          HttpProtocolIntegrationTest::protocolTestParamsToString);",
          "",
          "[Added Lines]",
          "1333: INSTANTIATE_TEST_SUITE_P(",
          "1334:     IpAndHttpVersions, TcpTunnelingIntegrationTest,",
          "1335:     testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(",
          "1336:         {Http::CodecType::HTTP1, Http::CodecType::HTTP2, Http::CodecType::HTTP3},",
          "1337:         {Http::CodecType::HTTP1, Http::CodecType::HTTP2, Http::CodecType::HTTP3})),",
          "1338:     HttpProtocolIntegrationTest::protocolTestParamsToString);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ab57bddf3570f34a03e1ba8870338210a5fc299d",
      "candidate_info": {
        "commit_hash": "ab57bddf3570f34a03e1ba8870338210a5fc299d",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/ab57bddf3570f34a03e1ba8870338210a5fc299d",
        "files": [
          "docs/root/version_history/current.rst",
          "source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h",
          "test/integration/tcp_tunneling_integration_test.cc"
        ],
        "message": "[1.20] CVE-2021-43826\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>",
        "before_after_code_files": [
          "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
          "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ],
          "candidate": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc": [
          "File: source/common/tcp_proxy/tcp_proxy.cc -> source/common/tcp_proxy/tcp_proxy.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "531: }",
          "533: void Filter::onDownstreamEvent(Network::ConnectionEvent event) {",
          "534:   if (upstream_) {",
          "535:     Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));",
          "536:     if (conn_data != nullptr &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:   if (event == Network::ConnectionEvent::LocalClose ||",
          "535:       event == Network::ConnectionEvent::RemoteClose) {",
          "536:     downstream_closed_ = true;",
          "537:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "579:             Upstream::Outlier::Result::LocalOriginConnectFailed);",
          "580:       }",
          "583:     } else {",
          "584:       if (read_callbacks_->connection().state() == Network::Connection::State::Open) {",
          "585:         read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);",
          "",
          "[Removed Lines]",
          "582:       initializeUpstreamConnection();",
          "",
          "[Added Lines]",
          "587:       if (!downstream_closed_) {",
          "588:         initializeUpstreamConnection();",
          "589:       }",
          "",
          "---------------"
        ],
        "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h": [
          "File: source/common/tcp_proxy/tcp_proxy.h -> source/common/tcp_proxy/tcp_proxy.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "377:   Network::Socket::OptionsSharedPtr upstream_options_;",
          "378:   uint32_t connect_attempts_{};",
          "379:   bool connecting_{};",
          "380: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "380:   bool downstream_closed_{};",
          "",
          "---------------"
        ],
        "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc": [
          "File: test/integration/tcp_tunneling_integration_test.cc -> test/integration/tcp_tunneling_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "661:   tcp_client->waitForDisconnect();",
          "662: }",
          "664: TEST_P(TcpTunnelingIntegrationTest, TestIdletimeoutWithLargeOutstandingData) {",
          "665:   enableHalfClose(false);",
          "666:   config_helper_.setBufferLimits(1024, 1024);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "664: TEST_P(TcpTunnelingIntegrationTest, UpstreamConnectingDownstreamDisconnect) {",
          "665:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
          "666:     return;",
          "667:   }",
          "669: #if defined(WIN32)",
          "675:   return;",
          "676: #endif",
          "678:   config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {",
          "679:     envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
          "680:     proxy_config.set_stat_prefix(\"tcp_stats\");",
          "681:     proxy_config.set_cluster(\"cluster_0\");",
          "682:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "686:     proxy_config.mutable_max_connect_attempts()->set_value(2);",
          "688:     auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();",
          "689:     for (auto& listener : *listeners) {",
          "690:       if (listener.name() != \"tcp_proxy\") {",
          "691:         continue;",
          "692:       }",
          "693:       auto* filter_chain = listener.mutable_filter_chains(0);",
          "694:       auto* filter = filter_chain->mutable_filters(0);",
          "695:       filter->mutable_typed_config()->PackFrom(proxy_config);",
          "699:       envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;",
          "700:       ConfigHelper::initializeTls({}, *tls_context.mutable_common_tls_context());",
          "701:       filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");",
          "702:       filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);",
          "704:       break;",
          "705:     }",
          "706:   });",
          "708:   enableHalfClose(false);",
          "709:   initialize();",
          "711:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "715:   ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));",
          "716:   ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));",
          "717:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
          "721:   tcp_client->close();",
          "723:   ASSERT_TRUE(upstream_request_->waitForReset());",
          "724:   ASSERT_TRUE(fake_upstream_connection_->close());",
          "725: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a79ca225f1ed924b855dff8a26bd7f7cdb84e694",
      "candidate_info": {
        "commit_hash": "a79ca225f1ed924b855dff8a26bd7f7cdb84e694",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/a79ca225f1ed924b855dff8a26bd7f7cdb84e694",
        "files": [
          "docs/root/version_history/current.rst",
          "source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h",
          "test/integration/tcp_tunneling_integration_test.cc"
        ],
        "message": "[1.18] CVE-2021-43826\n\ntcp_proxy: Fix crash when using upstream tunneling if client disconnects\nwhile connecting to the upstream\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>",
        "before_after_code_files": [
          "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
          "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ],
          "candidate": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc": [
          "File: source/common/tcp_proxy/tcp_proxy.cc -> source/common/tcp_proxy/tcp_proxy.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "589: }",
          "591: void Filter::onDownstreamEvent(Network::ConnectionEvent event) {",
          "592:   if (upstream_) {",
          "593:     Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));",
          "594:     if (conn_data != nullptr &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "592:   if (event == Network::ConnectionEvent::LocalClose ||",
          "593:       event == Network::ConnectionEvent::RemoteClose) {",
          "594:     downstream_closed_ = true;",
          "595:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "637:             Upstream::Outlier::Result::LocalOriginConnectFailed);",
          "638:       }",
          "641:     } else {",
          "642:       if (read_callbacks_->connection().state() == Network::Connection::State::Open) {",
          "643:         read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);",
          "",
          "[Removed Lines]",
          "640:       initializeUpstreamConnection();",
          "",
          "[Added Lines]",
          "645:       if (!downstream_closed_) {",
          "646:         initializeUpstreamConnection();",
          "647:       }",
          "",
          "---------------"
        ],
        "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h": [
          "File: source/common/tcp_proxy/tcp_proxy.h -> source/common/tcp_proxy/tcp_proxy.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "384:   Network::Socket::OptionsSharedPtr upstream_options_;",
          "385:   uint32_t connect_attempts_{};",
          "386:   bool connecting_{};",
          "387: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "387:   bool downstream_closed_{};",
          "",
          "---------------"
        ],
        "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc": [
          "File: test/integration/tcp_tunneling_integration_test.cc -> test/integration/tcp_tunneling_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "561:   tcp_client->waitForDisconnect();",
          "562: }",
          "564: TEST_P(TcpTunnelingIntegrationTest, TestIdletimeoutWithLargeOutstandingData) {",
          "565:   enableHalfClose(false);",
          "566:   config_helper_.setBufferLimits(1024, 1024);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "564: TEST_P(TcpTunnelingIntegrationTest, UpstreamConnectingDownstreamDisconnect) {",
          "565:   if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {",
          "566:     return;",
          "567:   }",
          "569: #if defined(WIN32)",
          "575:   return;",
          "576: #endif",
          "578:   config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {",
          "579:     envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
          "580:     proxy_config.set_stat_prefix(\"tcp_stats\");",
          "581:     proxy_config.set_cluster(\"cluster_0\");",
          "582:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "586:     proxy_config.mutable_max_connect_attempts()->set_value(2);",
          "588:     auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();",
          "589:     for (auto& listener : *listeners) {",
          "590:       if (listener.name() != \"tcp_proxy\") {",
          "591:         continue;",
          "592:       }",
          "593:       auto* filter_chain = listener.mutable_filter_chains(0);",
          "594:       auto* filter = filter_chain->mutable_filters(0);",
          "595:       filter->mutable_typed_config()->PackFrom(proxy_config);",
          "599:       envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;",
          "600:       ConfigHelper::initializeTls({}, *tls_context.mutable_common_tls_context());",
          "601:       filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");",
          "602:       filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);",
          "604:       break;",
          "605:     }",
          "606:   });",
          "608:   enableHalfClose(false);",
          "609:   initialize();",
          "611:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "615:   ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));",
          "616:   ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));",
          "617:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
          "621:   tcp_client->close();",
          "623:   ASSERT_TRUE(upstream_request_->waitForReset());",
          "624:   ASSERT_TRUE(fake_upstream_connection_->close());",
          "625: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af50070ee60866874b0a9383daf9364e884ded22",
      "candidate_info": {
        "commit_hash": "af50070ee60866874b0a9383daf9364e884ded22",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/af50070ee60866874b0a9383daf9364e884ded22",
        "files": [
          "docs/root/version_history/current.rst",
          "source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h",
          "test/integration/tcp_tunneling_integration_test.cc"
        ],
        "message": "[1.21] CVE-2021-43826\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>",
        "before_after_code_files": [
          "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
          "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
          "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ],
          "candidate": [
            "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc",
            "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h",
            "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/tcp_proxy/tcp_proxy.cc||source/common/tcp_proxy/tcp_proxy.cc": [
          "File: source/common/tcp_proxy/tcp_proxy.cc -> source/common/tcp_proxy/tcp_proxy.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "526: }",
          "528: void Filter::onDownstreamEvent(Network::ConnectionEvent event) {",
          "529:   ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),",
          "530:                  static_cast<int>(event), upstream_ == nullptr);",
          "531:   if (upstream_) {",
          "532:     Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));",
          "533:     if (conn_data != nullptr &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "529:   if (event == Network::ConnectionEvent::LocalClose ||",
          "530:       event == Network::ConnectionEvent::RemoteClose) {",
          "531:     downstream_closed_ = true;",
          "532:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "576:             Upstream::Outlier::Result::LocalOriginConnectFailed);",
          "577:       }",
          "580:     } else {",
          "581:       if (read_callbacks_->connection().state() == Network::Connection::State::Open) {",
          "582:         read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);",
          "",
          "[Removed Lines]",
          "579:       initializeUpstreamConnection();",
          "",
          "[Added Lines]",
          "585:       if (!downstream_closed_) {",
          "586:         initializeUpstreamConnection();",
          "587:       }",
          "",
          "---------------"
        ],
        "source/common/tcp_proxy/tcp_proxy.h||source/common/tcp_proxy/tcp_proxy.h": [
          "File: source/common/tcp_proxy/tcp_proxy.h -> source/common/tcp_proxy/tcp_proxy.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "375:   Network::Socket::OptionsSharedPtr upstream_options_;",
          "376:   uint32_t connect_attempts_{};",
          "377:   bool connecting_{};",
          "378: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "378:   bool downstream_closed_{};",
          "",
          "---------------"
        ],
        "test/integration/tcp_tunneling_integration_test.cc||test/integration/tcp_tunneling_integration_test.cc": [
          "File: test/integration/tcp_tunneling_integration_test.cc -> test/integration/tcp_tunneling_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "747:   tcp_client_->waitForDisconnect();",
          "748: }",
          "750: TEST_P(TcpTunnelingIntegrationTest, TestIdletimeoutWithLargeOutstandingData) {",
          "751:   enableHalfClose(false);",
          "752:   config_helper_.setBufferLimits(1024, 1024);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "750: TEST_P(TcpTunnelingIntegrationTest, UpstreamConnectingDownstreamDisconnect) {",
          "751:   if (upstreamProtocol() == Http::CodecType::HTTP1) {",
          "752:     return;",
          "753:   }",
          "755: #if defined(WIN32)",
          "761:   return;",
          "762: #endif",
          "764:   config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {",
          "765:     envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;",
          "766:     proxy_config.set_stat_prefix(\"tcp_stats\");",
          "767:     proxy_config.set_cluster(\"cluster_0\");",
          "768:     proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");",
          "772:     proxy_config.mutable_max_connect_attempts()->set_value(2);",
          "774:     auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();",
          "775:     for (auto& listener : *listeners) {",
          "776:       if (listener.name() != \"tcp_proxy\") {",
          "777:         continue;",
          "778:       }",
          "779:       auto* filter_chain = listener.mutable_filter_chains(0);",
          "780:       auto* filter = filter_chain->mutable_filters(0);",
          "781:       filter->mutable_typed_config()->PackFrom(proxy_config);",
          "785:       envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;",
          "786:       ConfigHelper::initializeTls({}, *tls_context.mutable_common_tls_context());",
          "787:       filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");",
          "788:       filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);",
          "790:       break;",
          "791:     }",
          "792:   });",
          "794:   enableHalfClose(false);",
          "795:   initialize();",
          "797:   IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));",
          "801:   ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));",
          "802:   ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));",
          "803:   ASSERT_TRUE(upstream_request_->waitForHeadersComplete());",
          "807:   tcp_client->close();",
          "809:   ASSERT_TRUE(upstream_request_->waitForReset());",
          "810:   ASSERT_TRUE(fake_upstream_connection_->close());",
          "811: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-7798",
  "cve_desc": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",
  "repo": "ruby/openssl",
  "patch_hash": "8108e0a6db133f3375608303fdd2083eb5115062",
  "patch_info": {
    "commit_hash": "8108e0a6db133f3375608303fdd2083eb5115062",
    "repo": "ruby/openssl",
    "commit_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
    "files": [
      "ext/openssl/ossl_cipher.c",
      "test/test_cipher.rb"
    ],
    "message": "cipher: don't set dummy encryption key in Cipher#initialize\n\nRemove the encryption key initialization from Cipher#initialize. This\nis effectively a revert of r32723 (\"Avoid possible SEGV from AES\nencryption/decryption\", 2011-07-28).\n\nr32723, which added the key initialization, was a workaround for\nRuby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()\nbefore setting an encryption key caused segfault. It was not a problem\nuntil OpenSSL implemented GCM mode - the encryption key could be\noverridden by repeated calls of EVP_CipherInit_ex(). But, it is not the\ncase for AES-GCM ciphers. Setting a key, an IV, a key, in this order\ncauses the IV to be reset to an all-zero IV.\n\nThe problem of Bug #2768 persists on the current versions of OpenSSL.\nSo, make Cipher#update raise an exception if a key is not yet set by the\nuser. Since encrypting or decrypting without key does not make any\nsense, this should not break existing applications.\n\nUsers can still call Cipher#key= and Cipher#iv= multiple times with\ntheir own responsibility.\n\nReference: https://bugs.ruby-lang.org/issues/2768\nReference: https://bugs.ruby-lang.org/issues/8221\nReference: https://github.com/ruby/openssl/issues/49",
    "before_after_code_files": [
      "ext/openssl/ossl_cipher.c||ext/openssl/ossl_cipher.c",
      "test/test_cipher.rb||test/test_cipher.rb"
    ]
  },
  "patch_diff": {
    "ext/openssl/ossl_cipher.c||ext/openssl/ossl_cipher.c": [
      "File: ext/openssl/ossl_cipher.c -> ext/openssl/ossl_cipher.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "37: VALUE cCipher;",
      "38: VALUE eCipherError;",
      "41: static VALUE ossl_cipher_alloc(VALUE klass);",
      "42: static void ossl_cipher_free(void *ptr);",
      "",
      "[Removed Lines]",
      "39: static ID id_auth_tag_len;",
      "",
      "[Added Lines]",
      "39: static ID id_auth_tag_len, id_key_set;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "118:     EVP_CIPHER_CTX *ctx;",
      "119:     const EVP_CIPHER *cipher;",
      "120:     char *name;",
      "123:     name = StringValueCStr(str);",
      "124:     GetCipherInit(self, ctx);",
      "",
      "[Removed Lines]",
      "121:     unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "129:     if (!(cipher = EVP_get_cipherbyname(name))) {",
      "130:  ossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);",
      "131:     }",
      "142:  ossl_raise(eCipherError, NULL);",
      "144:     return self;",
      "",
      "[Removed Lines]",
      "141:     if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)",
      "",
      "[Added Lines]",
      "131:     if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "251:  ossl_raise(eCipherError, NULL);",
      "252:     }",
      "254:     return self;",
      "255: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "244:     if (p_key)",
      "245:  rb_ivar_set(self, id_key_set, Qtrue);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "337:     OPENSSL_cleanse(key, sizeof key);",
      "338:     OPENSSL_cleanse(iv, sizeof iv);",
      "340:     return Qnil;",
      "341: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:     rb_ivar_set(self, id_key_set, Qtrue);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "388:     rb_scan_args(argc, argv, \"11\", &data, &str);",
      "390:     StringValue(data);",
      "391:     in = (unsigned char *)RSTRING_PTR(data);",
      "392:     if ((in_len = RSTRING_LEN(data)) == 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "385:     if (!RTEST(rb_attr_get(self, id_key_set)))",
      "386:  ossl_raise(eCipherError, \"key not set\");",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "488:     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)",
      "489:  ossl_raise(eCipherError, NULL);",
      "491:     return key;",
      "492: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "489:     rb_ivar_set(self, id_key_set, Qtrue);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1082:     rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);",
      "1084:     id_auth_tag_len = rb_intern_const(\"auth_tag_len\");",
      "1085: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1085:     id_key_set = rb_intern_const(\"key_set\");",
      "",
      "---------------"
    ],
    "test/test_cipher.rb||test/test_cipher.rb": [
      "File: test/test_cipher.rb -> test/test_cipher.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "91:   def test_empty_data",
      "92:     @c1.encrypt",
      "93:     assert_raise(ArgumentError){ @c1.update(\"\") }",
      "94:   end",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "93:     @c1.random_key",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "136:     }",
      "137:   end",
      "145:     end",
      "146:   end",
      "",
      "[Removed Lines]",
      "139:   def test_AES_crush",
      "140:     500.times do",
      "141:       assert_nothing_raised(\"[Bug #2768]\") do",
      "142:         # it caused OpenSSL SEGV by uninitialized key",
      "143:         OpenSSL::Cipher::AES128.new(\"ECB\").update \".\" * 17",
      "144:       end",
      "",
      "[Added Lines]",
      "140:   def test_update_raise_if_key_not_set",
      "141:     assert_raise(OpenSSL::Cipher::CipherError) do",
      "142:       # it caused OpenSSL SEGV by uninitialized key [Bug #2768]",
      "143:       OpenSSL::Cipher::AES128.new(\"ECB\").update \".\" * 17",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "317:     }",
      "318:   end if has_cipher?(\"aes-128-ocb\")",
      "320:   private",
      "322:   def new_encryptor(algo)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "319:   def test_aes_gcm_key_iv_order_issue",
      "320:     pt = \"[ruby/openssl#49]\"",
      "321:     cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt",
      "322:     cipher.key = \"x\" * 16",
      "323:     cipher.iv = \"a\" * 12",
      "324:     ct1 = cipher.update(pt) << cipher.final",
      "325:     tag1 = cipher.auth_tag",
      "327:     cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt",
      "328:     cipher.iv = \"a\" * 12",
      "329:     cipher.key = \"x\" * 16",
      "330:     ct2 = cipher.update(pt) << cipher.final",
      "331:     tag2 = cipher.auth_tag",
      "333:     assert_equal ct1, ct2",
      "334:     assert_equal tag1, tag2",
      "335:   end if has_cipher?(\"aes-128-gcm\")",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2690e055675bcb58ca2fccbe9fe826160c2377a8",
      "candidate_info": {
        "commit_hash": "2690e055675bcb58ca2fccbe9fe826160c2377a8",
        "repo": "ruby/openssl",
        "commit_url": "https://github.com/ruby/openssl/commit/2690e055675bcb58ca2fccbe9fe826160c2377a8",
        "files": [
          "test/test_cipher.rb"
        ],
        "message": "test/test_cipher: use static test vectors\n\nCompare the result with static test vectors rather than just testing\nthat the encryption result can be decrypted. The current test cases\nwouldn't catch failure if both the encryption and decryption routines\nare broken.\n\nTest vectors are taken from external sources as noted in the comments.",
        "before_after_code_files": [
          "test/test_cipher.rb||test/test_cipher.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/test_cipher.rb||test/test_cipher.rb"
          ],
          "candidate": [
            "test/test_cipher.rb||test/test_cipher.rb"
          ]
        }
      },
      "candidate_diff": {
        "test/test_cipher.rb||test/test_cipher.rb": [
          "File: test/test_cipher.rb -> test/test_cipher.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:       @ciphers ||= OpenSSL::Cipher.ciphers",
          "10:       @ciphers.include?(name)",
          "11:     end",
          "16:   end",
          "17:   include Helper",
          "18:   extend Helper",
          "33:   end",
          "46:   end",
          "48:   def test_info",
          "53:   end",
          "55:   def test_dup",
          "64:     assert_equal(s1, s2, \"encrypt dup\")",
          "65:   end",
          "67:   def test_reset",
          "74:     assert_equal(s1, s2, \"encrypt reset\")",
          "75:   end",
          "77:   def test_key_iv_set",
          "87:   end",
          "89:   def test_empty_data",
          "93:   end",
          "95:   def test_initialize",
          "98:   end",
          "100:   def test_ctr_if_exists",
          "110:   end if has_cipher?('aes-128-ctr')",
          "112:   def test_ciphers",
          "",
          "[Removed Lines]",
          "13:     def has_ciphers?(list)",
          "14:       list.all? { |name| has_cipher?(name) }",
          "15:     end",
          "20:   def setup",
          "21:     @c1 = OpenSSL::Cipher.new(\"DES-EDE3-CBC\")",
          "22:     @c2 = OpenSSL::Cipher::DES.new(:EDE3, \"CBC\")",
          "23:     @key = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"",
          "24:     @iv = \"\\0\\0\\0\\0\\0\\0\\0\\0\"",
          "25:     @hexkey = \"0000000000000000000000000000000000000000000000\"",
          "26:     @hexiv = \"0000000000000000\"",
          "27:     @data = \"DATA\"",
          "28:   end",
          "30:   def teardown",
          "31:     super",
          "32:     @c1 = @c2 = nil",
          "35:   def test_crypt",
          "36:     @c1.encrypt.pkcs5_keyivgen(@key, @iv)",
          "37:     @c2.encrypt.pkcs5_keyivgen(@key, @iv)",
          "38:     s1 = @c1.update(@data) + @c1.final",
          "39:     s2 = @c2.update(@data) + @c2.final",
          "40:     assert_equal(s1, s2, \"encrypt\")",
          "42:     @c1.decrypt.pkcs5_keyivgen(@key, @iv)",
          "43:     @c2.decrypt.pkcs5_keyivgen(@key, @iv)",
          "44:     assert_equal(@data, @c1.update(s1)+@c1.final, \"decrypt\")",
          "45:     assert_equal(@data, @c2.update(s2)+@c2.final, \"decrypt\")",
          "49:     assert_equal(\"DES-EDE3-CBC\", @c1.name, \"name\")",
          "50:     assert_equal(\"DES-EDE3-CBC\", @c2.name, \"name\")",
          "51:     assert_kind_of(Integer, @c1.key_len, \"key_len\")",
          "52:     assert_kind_of(Integer, @c1.iv_len, \"iv_len\")",
          "56:     assert_equal(@c1.name, @c1.dup.name, \"dup\")",
          "57:     assert_equal(@c1.name, @c1.clone.name, \"clone\")",
          "58:     @c1.encrypt",
          "59:     @c1.key = @key",
          "60:     @c1.iv = @iv",
          "61:     tmpc = @c1.dup",
          "62:     s1 = @c1.update(@data) + @c1.final",
          "63:     s2 = tmpc.update(@data) + tmpc.final",
          "68:     @c1.encrypt",
          "69:     @c1.key = @key",
          "70:     @c1.iv = @iv",
          "71:     s1 = @c1.update(@data) + @c1.final",
          "72:     @c1.reset",
          "73:     s2 = @c1.update(@data) + @c1.final",
          "78:     # default value for DES-EDE3-CBC",
          "79:     assert_equal(24, @c1.key_len)",
          "80:     assert_equal(8, @c1.iv_len)",
          "81:     assert_raise(ArgumentError) { @c1.key = \"\\x01\" * 23 }",
          "82:     @c1.key = \"\\x01\" * 24",
          "83:     assert_raise(ArgumentError) { @c1.key = \"\\x01\" * 25 }",
          "84:     assert_raise(ArgumentError) { @c1.iv = \"\\x01\" * 7 }",
          "85:     @c1.iv = \"\\x01\" * 8",
          "86:     assert_raise(ArgumentError) { @c1.iv = \"\\x01\" * 9 }",
          "90:     @c1.encrypt",
          "91:     @c1.random_key",
          "92:     assert_raise(ArgumentError){ @c1.update(\"\") }",
          "96:     assert_raise(RuntimeError) {@c1.__send__(:initialize, \"DES-EDE3-CBC\")}",
          "97:     assert_raise(RuntimeError) {OpenSSL::Cipher.allocate.final}",
          "101:     begin",
          "102:       cipher = OpenSSL::Cipher.new('aes-128-ctr')",
          "103:       cipher.encrypt",
          "104:       cipher.pkcs5_keyivgen('password')",
          "105:       c = cipher.update('hello,world') + cipher.final",
          "106:       cipher.decrypt",
          "107:       cipher.pkcs5_keyivgen('password')",
          "108:       assert_equal('hello,world', cipher.update(c) + cipher.final)",
          "109:     end",
          "",
          "[Added Lines]",
          "16:   def test_encrypt_decrypt",
          "17:     # NIST SP 800-38A F.2.1",
          "18:     key = [\"2b7e151628aed2a6abf7158809cf4f3c\"].pack(\"H*\")",
          "19:     iv =  [\"000102030405060708090a0b0c0d0e0f\"].pack(\"H*\")",
          "20:     pt =  [\"6bc1bee22e409f96e93d7e117393172a\" \\",
          "21:            \"ae2d8a571e03ac9c9eb76fac45af8e51\"].pack(\"H*\")",
          "22:     ct =  [\"7649abac8119b246cee98e9b12e9197d\" \\",
          "23:            \"5086cb9b507219ee95db113a917678b2\"].pack(\"H*\")",
          "24:     cipher = new_encryptor(\"aes-128-cbc\", key: key, iv: iv, padding: 0)",
          "25:     assert_equal ct, cipher.update(pt) << cipher.final",
          "26:     cipher = new_decryptor(\"aes-128-cbc\", key: key, iv: iv, padding: 0)",
          "27:     assert_equal pt, cipher.update(ct) << cipher.final",
          "30:   def test_pkcs5_keyivgen",
          "31:     pass = \"\\x00\" * 8",
          "32:     salt = \"\\x01\" * 8",
          "33:     num = 2048",
          "34:     pt = \"data to be encrypted\"",
          "35:     cipher = OpenSSL::Cipher.new(\"DES-EDE3-CBC\").encrypt",
          "36:     cipher.pkcs5_keyivgen(pass, salt, num, \"MD5\")",
          "37:     s1 = cipher.update(pt) << cipher.final",
          "39:     d1 = num.times.inject(pass + salt) {|out, _| OpenSSL::Digest::MD5.digest(out) }",
          "40:     d2 = num.times.inject(d1 + pass + salt) {|out, _| OpenSSL::Digest::MD5.digest(out) }",
          "41:     key = (d1 + d2)[0, 24]",
          "42:     iv = (d1 + d2)[24, 8]",
          "43:     cipher = new_encryptor(\"DES-EDE3-CBC\", key: key, iv: iv)",
          "44:     s2 = cipher.update(pt) << cipher.final",
          "46:     assert_equal s1, s2",
          "50:     cipher = OpenSSL::Cipher.new(\"DES-EDE3-CBC\").encrypt",
          "51:     assert_equal \"DES-EDE3-CBC\", cipher.name",
          "52:     assert_equal 24, cipher.key_len",
          "53:     assert_equal 8, cipher.iv_len",
          "57:     cipher = OpenSSL::Cipher.new(\"aes-128-cbc\").encrypt",
          "58:     assert_equal cipher.name, cipher.dup.name",
          "59:     cipher.encrypt",
          "60:     cipher.random_key",
          "61:     cipher.random_iv",
          "62:     tmpc = cipher.dup",
          "63:     s1 = cipher.update(\"data\") + cipher.final",
          "64:     s2 = tmpc.update(\"data\") + tmpc.final",
          "69:     cipher = OpenSSL::Cipher.new(\"aes-128-cbc\").encrypt",
          "70:     cipher.encrypt",
          "71:     cipher.random_key",
          "72:     cipher.random_iv",
          "73:     s1 = cipher.update(\"data\") + cipher.final",
          "74:     cipher.reset",
          "75:     s2 = cipher.update(\"data\") + cipher.final",
          "80:     cipher = OpenSSL::Cipher.new(\"DES-EDE3-CBC\").encrypt",
          "81:     assert_raise(ArgumentError) { cipher.key = \"\\x01\" * 23 }",
          "82:     assert_nothing_raised { cipher.key = \"\\x01\" * 24 }",
          "83:     assert_raise(ArgumentError) { cipher.key = \"\\x01\" * 25 }",
          "84:     assert_raise(ArgumentError) { cipher.iv = \"\\x01\" * 7 }",
          "85:     assert_nothing_raised { cipher.iv = \"\\x01\" * 8 }",
          "86:     assert_raise(ArgumentError) { cipher.iv = \"\\x01\" * 9 }",
          "87:   end",
          "89:   def test_random_key_iv",
          "90:     data = \"data\"",
          "91:     s1, s2 = 2.times.map do",
          "92:       cipher = OpenSSL::Cipher.new(\"aes-128-cbc\").encrypt",
          "93:       cipher.random_key",
          "94:       cipher.iv = \"\\x01\" * 16",
          "95:       cipher.update(data) << cipher.final",
          "96:     end",
          "97:     assert_not_equal s1, s2",
          "99:     s1, s2 = 2.times.map do",
          "100:       cipher = OpenSSL::Cipher.new(\"aes-128-cbc\").encrypt",
          "101:       cipher.key = \"\\x01\" * 16",
          "102:       cipher.random_iv",
          "103:       cipher.update(data) << cipher.final",
          "104:     end",
          "105:     assert_not_equal s1, s2",
          "109:     cipher = OpenSSL::Cipher.new(\"DES-EDE3-CBC\").encrypt",
          "110:     cipher.random_key",
          "111:     assert_raise(ArgumentError) { cipher.update(\"\") }",
          "115:     cipher = OpenSSL::Cipher.new(\"DES-EDE3-CBC\")",
          "116:     assert_raise(RuntimeError) { cipher.__send__(:initialize, \"DES-EDE3-CBC\") }",
          "117:     assert_raise(RuntimeError) { OpenSSL::Cipher.allocate.final }",
          "121:     # NIST SP 800-38A F.5.1",
          "122:     key = [\"2b7e151628aed2a6abf7158809cf4f3c\"].pack(\"H*\")",
          "123:     iv =  [\"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"].pack(\"H*\")",
          "124:     pt =  [\"6bc1bee22e409f96e93d7e117393172a\" \\",
          "125:            \"ae2d8a571e03ac9c9eb76fac45af8e51\"].pack(\"H*\")",
          "126:     ct =  [\"874d6191b620e3261bef6864990db6ce\" \\",
          "127:            \"9806f66b7970fdff8617187bb9fffdff\"].pack(\"H*\")",
          "128:     cipher = new_encryptor(\"aes-128-ctr\", key: key, iv: iv, padding: 0)",
          "129:     assert_equal ct, cipher.update(pt) << cipher.final",
          "130:     cipher = new_decryptor(\"aes-128-ctr\", key: key, iv: iv, padding: 0)",
          "131:     assert_equal pt, cipher.update(ct) << cipher.final",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:     assert_not_predicate(cipher, :authenticated?)",
          "152:   end",
          "286:   def test_aes_ocb_tag_len",
          "317:   end if has_cipher?(\"aes-128-ocb\")",
          "319:   def test_aes_gcm_key_iv_order_issue",
          "",
          "[Removed Lines]",
          "154:   if has_ciphers?(['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'])",
          "156:     def test_aes_gcm",
          "157:       ['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'].each do |algo|",
          "158:         pt = \"You should all use Authenticated Encryption!\"",
          "159:         cipher, key, iv = new_encryptor(algo)",
          "161:         cipher.auth_data = \"aad\"",
          "162:         ct  = cipher.update(pt) + cipher.final",
          "163:         tag = cipher.auth_tag",
          "164:         assert_equal(16, tag.size)",
          "166:         decipher = new_decryptor(algo, key, iv)",
          "167:         decipher.auth_tag = tag",
          "168:         decipher.auth_data = \"aad\"",
          "170:         assert_equal(pt, decipher.update(ct) + decipher.final)",
          "171:       end",
          "172:     end",
          "174:     def test_aes_gcm_short_tag",
          "175:       ['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'].each do |algo|",
          "176:         pt = \"You should all use Authenticated Encryption!\"",
          "177:         cipher, key, iv = new_encryptor(algo)",
          "179:         cipher.auth_data = \"aad\"",
          "180:         ct  = cipher.update(pt) + cipher.final",
          "181:         tag = cipher.auth_tag(8)",
          "182:         assert_equal(8, tag.size)",
          "184:         decipher = new_decryptor(algo, key, iv)",
          "185:         decipher.auth_tag = tag",
          "186:         decipher.auth_data = \"aad\"",
          "188:         assert_equal(pt, decipher.update(ct) + decipher.final)",
          "189:       end",
          "190:     end",
          "192:     def test_aes_gcm_wrong_tag",
          "193:       pt = \"You should all use Authenticated Encryption!\"",
          "194:       cipher, key, iv = new_encryptor('aes-128-gcm')",
          "196:       cipher.auth_data = \"aad\"",
          "197:       ct  = cipher.update(pt) + cipher.final",
          "198:       tag = cipher.auth_tag",
          "200:       decipher = new_decryptor('aes-128-gcm', key, iv)",
          "201:       tag.setbyte(-1, (tag.getbyte(-1) + 1) & 0xff)",
          "202:       decipher.auth_tag = tag",
          "203:       decipher.auth_data = \"aad\"",
          "205:       assert_raise OpenSSL::Cipher::CipherError do",
          "206:         decipher.update(ct) + decipher.final",
          "207:       end",
          "208:     end",
          "210:     def test_aes_gcm_wrong_auth_data",
          "211:       pt = \"You should all use Authenticated Encryption!\"",
          "212:       cipher, key, iv = new_encryptor('aes-128-gcm')",
          "214:       cipher.auth_data = \"aad\"",
          "215:       ct  = cipher.update(pt) + cipher.final",
          "216:       tag = cipher.auth_tag",
          "218:       decipher = new_decryptor('aes-128-gcm', key, iv)",
          "219:       decipher.auth_tag = tag",
          "220:       decipher.auth_data = \"daa\"",
          "222:       assert_raise OpenSSL::Cipher::CipherError do",
          "223:         decipher.update(ct) + decipher.final",
          "224:       end",
          "225:     end",
          "227:     def test_aes_gcm_wrong_ciphertext",
          "228:       pt = \"You should all use Authenticated Encryption!\"",
          "229:       cipher, key, iv = new_encryptor('aes-128-gcm')",
          "231:       cipher.auth_data = \"aad\"",
          "232:       ct  = cipher.update(pt) + cipher.final",
          "233:       tag = cipher.auth_tag",
          "235:       decipher = new_decryptor('aes-128-gcm', key, iv)",
          "236:       decipher.auth_tag = tag",
          "237:       decipher.auth_data = \"aad\"",
          "239:       assert_raise OpenSSL::Cipher::CipherError do",
          "240:         decipher.update(ct[0..-2] << ct[-1].succ) + decipher.final",
          "241:       end",
          "242:     end",
          "244:     def test_aes_gcm_variable_iv_len",
          "245:       pt = \"You should all use Authenticated Encryption!\"",
          "246:       cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt",
          "247:       cipher.key = \"x\" * 16",
          "248:       assert_equal(12, cipher.iv_len)",
          "249:       cipher.iv = \"a\" * 12",
          "250:       ct1 = cipher.update(pt) << cipher.final",
          "251:       tag1 = cipher.auth_tag",
          "253:       cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt",
          "254:       cipher.key = \"x\" * 16",
          "255:       cipher.iv_len = 10",
          "256:       assert_equal(10, cipher.iv_len)",
          "257:       cipher.iv = \"a\" * 10",
          "258:       ct2 = cipher.update(pt) << cipher.final",
          "259:       tag2 = cipher.auth_tag",
          "261:       assert_not_equal ct1, ct2",
          "262:       assert_not_equal tag1, tag2",
          "264:       decipher = OpenSSL::Cipher.new(\"aes-128-gcm\").decrypt",
          "265:       decipher.auth_tag = tag1",
          "266:       decipher.key = \"x\" * 16",
          "267:       decipher.iv_len = 12",
          "268:       decipher.iv = \"a\" * 12",
          "269:       assert_equal(pt, decipher.update(ct1) << decipher.final)",
          "271:       decipher.reset",
          "272:       decipher.auth_tag = tag2",
          "273:       assert_raise(OpenSSL::Cipher::CipherError) {",
          "274:         decipher.update(ct2) << decipher.final",
          "275:       }",
          "277:       decipher.reset",
          "278:       decipher.auth_tag = tag2",
          "279:       decipher.iv_len = 10",
          "280:       decipher.iv = \"a\" * 10",
          "281:       assert_equal(pt, decipher.update(ct2) << decipher.final)",
          "282:     end",
          "284:   end",
          "287:     pt = \"You should all use Authenticated Encryption!\"",
          "288:     cipher = OpenSSL::Cipher.new(\"aes-128-ocb\").encrypt",
          "289:     cipher.auth_tag_len = 14",
          "290:     cipher.iv_len = 8",
          "291:     key = cipher.random_key",
          "292:     iv = cipher.random_iv",
          "293:     cipher.auth_data = \"aad\"",
          "294:     ct  = cipher.update(pt) + cipher.final",
          "295:     tag = cipher.auth_tag",
          "296:     assert_equal(14, tag.size)",
          "298:     decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt",
          "299:     decipher.auth_tag_len = 14",
          "300:     decipher.auth_tag = tag",
          "301:     decipher.iv_len = 8",
          "302:     decipher.key = key",
          "303:     decipher.iv = iv",
          "304:     decipher.auth_data = \"aad\"",
          "305:     assert_equal(pt, decipher.update(ct) + decipher.final)",
          "307:     decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt",
          "308:     decipher.auth_tag_len = 9",
          "309:     decipher.auth_tag = tag[0, 9]",
          "310:     decipher.iv_len = 8",
          "311:     decipher.key = key",
          "312:     decipher.iv = iv",
          "313:     decipher.auth_data = \"aad\"",
          "314:     assert_raise(OpenSSL::Cipher::CipherError) {",
          "315:       decipher.update(ct) + decipher.final",
          "316:     }",
          "",
          "[Added Lines]",
          "176:   def test_aes_gcm",
          "177:     # GCM spec Appendix B Test Case 4",
          "178:     key = [\"feffe9928665731c6d6a8f9467308308\"].pack(\"H*\")",
          "179:     iv =  [\"cafebabefacedbaddecaf888\"].pack(\"H*\")",
          "180:     aad = [\"feedfacedeadbeeffeedfacedeadbeef\" \\",
          "181:            \"abaddad2\"].pack(\"H*\")",
          "182:     pt =  [\"d9313225f88406e5a55909c5aff5269a\" \\",
          "183:            \"86a7a9531534f7da2e4c303d8a318a72\" \\",
          "184:            \"1c3c0c95956809532fcf0e2449a6b525\" \\",
          "185:            \"b16aedf5aa0de657ba637b39\"].pack(\"H*\")",
          "186:     ct =  [\"42831ec2217774244b7221b784d0d49c\" \\",
          "187:            \"e3aa212f2c02a4e035c17e2329aca12e\" \\",
          "188:            \"21d514b25466931c7d8f6a5aac84aa05\" \\",
          "189:            \"1ba30b396a0aac973d58e091\"].pack(\"H*\")",
          "190:     tag = [\"5bc94fbc3221a5db94fae95ae7121a47\"].pack(\"H*\")",
          "192:     cipher = new_encryptor(\"aes-128-gcm\", key: key, iv: iv, auth_data: aad)",
          "193:     assert_equal ct, cipher.update(pt) << cipher.final",
          "194:     assert_equal tag, cipher.auth_tag",
          "195:     cipher = new_decryptor(\"aes-128-gcm\", key: key, iv: iv, auth_data: aad, auth_tag: tag)",
          "196:     assert_equal pt, cipher.update(ct) << cipher.final",
          "198:     # truncated tag is accepted",
          "199:     cipher = new_encryptor(\"aes-128-gcm\", key: key, iv: iv, auth_data: aad)",
          "200:     assert_equal ct, cipher.update(pt) << cipher.final",
          "201:     assert_equal tag[0, 8], cipher.auth_tag(8)",
          "202:     cipher = new_decryptor(\"aes-128-gcm\", key: key, iv: iv, auth_data: aad, auth_tag: tag[0, 8])",
          "203:     assert_equal pt, cipher.update(ct) << cipher.final",
          "205:     # wrong tag is rejected",
          "206:     tag2 = tag.dup",
          "207:     tag2.setbyte(-1, (tag2.getbyte(-1) + 1) & 0xff)",
          "208:     cipher = new_decryptor(\"aes-128-gcm\", key: key, iv: iv, auth_data: aad, auth_tag: tag2)",
          "209:     cipher.update(ct)",
          "210:     assert_raise(OpenSSL::Cipher::CipherError) { cipher.final }",
          "212:     # wrong aad is rejected",
          "213:     aad2 = aad[0..-2] << aad[-1].succ",
          "214:     cipher = new_decryptor(\"aes-128-gcm\", key: key, iv: iv, auth_data: aad2, auth_tag: tag)",
          "215:     cipher.update(ct)",
          "216:     assert_raise(OpenSSL::Cipher::CipherError) { cipher.final }",
          "218:     # wrong ciphertext is rejected",
          "219:     ct2 = ct[0..-2] << ct[-1].succ",
          "220:     cipher = new_decryptor(\"aes-128-gcm\", key: key, iv: iv, auth_data: aad, auth_tag: tag)",
          "221:     cipher.update(ct2)",
          "222:     assert_raise(OpenSSL::Cipher::CipherError) { cipher.final }",
          "223:   end if has_cipher?(\"aes-128-gcm\")",
          "225:   def test_aes_gcm_variable_iv_len",
          "226:     # GCM spec Appendix B Test Case 5",
          "227:     key = [\"feffe9928665731c6d6a8f9467308308\"].pack(\"H*\")",
          "228:     iv  = [\"cafebabefacedbad\"].pack(\"H*\")",
          "229:     aad = [\"feedfacedeadbeeffeedfacedeadbeef\" \\",
          "230:            \"abaddad2\"].pack(\"H*\")",
          "231:     pt =  [\"d9313225f88406e5a55909c5aff5269a\" \\",
          "232:            \"86a7a9531534f7da2e4c303d8a318a72\" \\",
          "233:            \"1c3c0c95956809532fcf0e2449a6b525\" \\",
          "234:            \"b16aedf5aa0de657ba637b39\"].pack(\"H*\")",
          "235:     ct =  [\"61353b4c2806934a777ff51fa22a4755\" \\",
          "236:            \"699b2a714fcdc6f83766e5f97b6c7423\" \\",
          "237:            \"73806900e49f24b22b097544d4896b42\" \\",
          "238:            \"4989b5e1ebac0f07c23f4598\"].pack(\"H*\")",
          "239:     tag = [\"3612d2e79e3b0785561be14aaca2fccb\"].pack(\"H*\")",
          "241:     cipher = new_encryptor(\"aes-128-gcm\", key: key, iv_len: 8, iv: iv, auth_data: aad)",
          "242:     assert_equal ct, cipher.update(pt) << cipher.final",
          "243:     assert_equal tag, cipher.auth_tag",
          "244:     cipher = new_decryptor(\"aes-128-gcm\", key: key, iv_len: 8, iv: iv, auth_data: aad, auth_tag: tag)",
          "245:     assert_equal pt, cipher.update(ct) << cipher.final",
          "246:   end if has_cipher?(\"aes-128-gcm\")",
          "249:     # RFC 7253 Appendix A; the second sample",
          "250:     key = [\"000102030405060708090A0B0C0D0E0F\"].pack(\"H*\")",
          "251:     iv  = [\"BBAA99887766554433221101\"].pack(\"H*\")",
          "252:     aad = [\"0001020304050607\"].pack(\"H*\")",
          "253:     pt =  [\"0001020304050607\"].pack(\"H*\")",
          "254:     ct =  [\"6820B3657B6F615A\"].pack(\"H*\")",
          "255:     tag = [\"5725BDA0D3B4EB3A257C9AF1F8F03009\"].pack(\"H*\")",
          "257:     cipher = new_encryptor(\"aes-128-ocb\", key: key, iv: iv, auth_data: aad)",
          "258:     assert_equal ct, cipher.update(pt) << cipher.final",
          "259:     assert_equal tag, cipher.auth_tag",
          "260:     cipher = new_decryptor(\"aes-128-ocb\", key: key, iv: iv, auth_data: aad, auth_tag: tag)",
          "261:     assert_equal pt, cipher.update(ct) << cipher.final",
          "263:     # RFC 7253 Appendix A; with 96 bits tag length",
          "264:     key = [\"0F0E0D0C0B0A09080706050403020100\"].pack(\"H*\")",
          "265:     iv  = [\"BBAA9988776655443322110D\"].pack(\"H*\")",
          "266:     aad = [\"000102030405060708090A0B0C0D0E0F1011121314151617\" \\",
          "267:            \"18191A1B1C1D1E1F2021222324252627\"].pack(\"H*\")",
          "268:     pt =  [\"000102030405060708090A0B0C0D0E0F1011121314151617\" \\",
          "269:            \"18191A1B1C1D1E1F2021222324252627\"].pack(\"H*\")",
          "270:     ct =  [\"1792A4E31E0755FB03E31B22116E6C2DDF9EFD6E33D536F1\" \\",
          "271:            \"A0124B0A55BAE884ED93481529C76B6A\"].pack(\"H*\")",
          "272:     tag = [\"D0C515F4D1CDD4FDAC4F02AA\"].pack(\"H*\")",
          "274:     cipher = new_encryptor(\"aes-128-ocb\", auth_tag_len: 12, key: key, iv: iv, auth_data: aad)",
          "275:     assert_equal ct, cipher.update(pt) << cipher.final",
          "276:     assert_equal tag, cipher.auth_tag",
          "277:     cipher = new_decryptor(\"aes-128-ocb\", auth_tag_len: 12, key: key, iv: iv, auth_data: aad, auth_tag: tag)",
          "278:     assert_equal pt, cipher.update(ct) << cipher.final",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "337:   private",
          "345:   end",
          "348:     OpenSSL::Cipher.new(algo).tap do |cipher|",
          "349:       cipher.decrypt",
          "352:     end",
          "353:   end",
          "",
          "[Removed Lines]",
          "339:   def new_encryptor(algo)",
          "340:     cipher = OpenSSL::Cipher.new(algo)",
          "341:     cipher.encrypt",
          "342:     key = cipher.random_key",
          "343:     iv = cipher.random_iv",
          "344:     [cipher, key, iv]",
          "347:   def new_decryptor(algo, key, iv)",
          "350:       cipher.key = key",
          "351:       cipher.iv = iv",
          "",
          "[Added Lines]",
          "302:   def new_encryptor(algo, **kwargs)",
          "303:     OpenSSL::Cipher.new(algo).tap do |cipher|",
          "304:       cipher.encrypt",
          "305:       kwargs.each {|k, v| cipher.send(:\"#{k}=\", v) }",
          "306:     end",
          "309:   def new_decryptor(algo, **kwargs)",
          "312:       kwargs.each {|k, v| cipher.send(:\"#{k}=\", v) }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6bc097049b4581a90ad59986fce57141b7e571f3",
      "candidate_info": {
        "commit_hash": "6bc097049b4581a90ad59986fce57141b7e571f3",
        "repo": "ruby/openssl",
        "commit_url": "https://github.com/ruby/openssl/commit/6bc097049b4581a90ad59986fce57141b7e571f3",
        "files": [
          "NEWS",
          "ext/openssl/ossl_cipher.c",
          "test/test_cipher.rb"
        ],
        "message": "cipher: add Cipher#auth_tag_len=\n\nAdd a method to set the authentication tag length to be generate by an\nAEAD ciphers. In particular, OCB mode which is implemented in OpenSSL\n1.1.0 requires this.",
        "before_after_code_files": [
          "ext/openssl/ossl_cipher.c||ext/openssl/ossl_cipher.c",
          "test/test_cipher.rb||test/test_cipher.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ext/openssl/ossl_cipher.c||ext/openssl/ossl_cipher.c",
            "test/test_cipher.rb||test/test_cipher.rb"
          ],
          "candidate": [
            "ext/openssl/ossl_cipher.c||ext/openssl/ossl_cipher.c",
            "test/test_cipher.rb||test/test_cipher.rb"
          ]
        }
      },
      "candidate_diff": {
        "ext/openssl/ossl_cipher.c||ext/openssl/ossl_cipher.c": [
          "File: ext/openssl/ossl_cipher.c -> ext/openssl/ossl_cipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: VALUE cCipher;",
          "38: VALUE eCipherError;",
          "40: static VALUE ossl_cipher_alloc(VALUE klass);",
          "41: static void ossl_cipher_free(void *ptr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: static ID id_auth_tag_len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "577:     EVP_CIPHER_CTX *ctx;",
          "578:     int tag_len = 16;",
          "581:  tag_len = NUM2INT(vtag_len);",
          "583:     GetCipher(self, ctx);",
          "",
          "[Removed Lines]",
          "580:     if (rb_scan_args(argc, argv, \"01\", &vtag_len) == 1)",
          "",
          "[Added Lines]",
          "582:     rb_scan_args(argc, argv, \"01\", &vtag_len);",
          "583:     if (NIL_P(vtag_len))",
          "584:  vtag_len = rb_attr_get(self, id_auth_tag_len);",
          "585:     if (!NIL_P(vtag_len))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "625:     return vtag;",
          "626: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "647: static VALUE",
          "648: ossl_cipher_set_auth_tag_len(VALUE self, VALUE vlen)",
          "649: {",
          "650:     int tag_len = NUM2INT(vlen);",
          "651:     EVP_CIPHER_CTX *ctx;",
          "653:     GetCipher(self, ctx);",
          "654:     if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))",
          "655:  ossl_raise(eCipherError, \"AEAD not supported by this cipher\");",
          "657:     if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len, NULL))",
          "658:  ossl_raise(eCipherError, \"unable to set authentication tag length\");",
          "661:     rb_ivar_set(self, id_auth_tag_len, INT2NUM(tag_len));",
          "663:     return vlen;",
          "664: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "675: #define ossl_cipher_set_auth_data rb_f_notimplement",
          "676: #define ossl_cipher_get_auth_tag rb_f_notimplement",
          "677: #define ossl_cipher_set_auth_tag rb_f_notimplement",
          "678: #define ossl_cipher_is_authenticated rb_f_notimplement",
          "679: #define ossl_cipher_set_iv_length rb_f_notimplement",
          "680: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "716: #define ossl_cipher_set_auth_tag_len rb_f_notimplement",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1000:     rb_define_method(cCipher, \"auth_data=\", ossl_cipher_set_auth_data, 1);",
          "1001:     rb_define_method(cCipher, \"auth_tag=\", ossl_cipher_set_auth_tag, 1);",
          "1002:     rb_define_method(cCipher, \"auth_tag\", ossl_cipher_get_auth_tag, -1);",
          "1003:     rb_define_method(cCipher, \"authenticated?\", ossl_cipher_is_authenticated, 0);",
          "1004:     rb_define_method(cCipher, \"key_len=\", ossl_cipher_set_key_length, 1);",
          "1005:     rb_define_method(cCipher, \"key_len\", ossl_cipher_key_length, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1042:     rb_define_method(cCipher, \"auth_tag_len=\", ossl_cipher_set_auth_tag_len, 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1008:     rb_define_method(cCipher, \"iv_len\", ossl_cipher_iv_length, 0);",
          "1009:     rb_define_method(cCipher, \"block_size\", ossl_cipher_block_size, 0);",
          "1010:     rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);",
          "1011: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1052:     id_auth_tag_len = rb_intern_const(\"auth_tag_len\");",
          "",
          "---------------"
        ],
        "test/test_cipher.rb||test/test_cipher.rb": [
          "File: test/test_cipher.rb -> test/test_cipher.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "285:   end",
          "287:   private",
          "289:   def new_encryptor(algo)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "287:   def test_aes_ocb_tag_len",
          "288:     pt = \"You should all use Authenticated Encryption!\"",
          "289:     cipher = OpenSSL::Cipher.new(\"aes-128-ocb\").encrypt",
          "290:     cipher.auth_tag_len = 14",
          "291:     cipher.iv_len = 8",
          "292:     key = cipher.random_key",
          "293:     iv = cipher.random_iv",
          "294:     cipher.auth_data = \"aad\"",
          "295:     ct  = cipher.update(pt) + cipher.final",
          "296:     tag = cipher.auth_tag",
          "297:     assert_equal(14, tag.size)",
          "299:     decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt",
          "300:     decipher.auth_tag_len = 14",
          "301:     decipher.auth_tag = tag",
          "302:     decipher.iv_len = 8",
          "303:     decipher.key = key",
          "304:     decipher.iv = iv",
          "305:     decipher.auth_data = \"aad\"",
          "306:     assert_equal(pt, decipher.update(ct) + decipher.final)",
          "308:     decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt",
          "309:     decipher.auth_tag_len = 9",
          "310:     decipher.auth_tag = tag[0, 9]",
          "311:     decipher.iv_len = 8",
          "312:     decipher.key = key",
          "313:     decipher.iv = iv",
          "314:     decipher.auth_data = \"aad\"",
          "315:     assert_raise(OpenSSL::Cipher::CipherError) {",
          "316:       decipher.update(ct) + decipher.final",
          "317:     }",
          "318:   end if has_cipher?(\"aes-128-ocb\")",
          "",
          "---------------"
        ]
      }
    }
  ]
}
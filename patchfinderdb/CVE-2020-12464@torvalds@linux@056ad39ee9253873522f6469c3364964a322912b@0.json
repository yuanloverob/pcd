{
  "cve_id": "CVE-2020-12464",
  "cve_desc": "usb_sg_cancel in drivers/usb/core/message.c in the Linux kernel before 5.6.8 has a use-after-free because a transfer occurs without a reference, aka CID-056ad39ee925.",
  "repo": "torvalds/linux",
  "patch_hash": "056ad39ee9253873522f6469c3364964a322912b",
  "patch_info": {
    "commit_hash": "056ad39ee9253873522f6469c3364964a322912b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b",
    "files": [
      "drivers/usb/core/message.c"
    ],
    "message": "USB: core: Fix free-while-in-use bug in the USB S-Glibrary\n\nFuzzUSB (a variant of syzkaller) found a free-while-still-in-use bug\nin the USB scatter-gather library:\n\nBUG: KASAN: use-after-free in atomic_read\ninclude/asm-generic/atomic-instrumented.h:26 [inline]\nBUG: KASAN: use-after-free in usb_hcd_unlink_urb+0x5f/0x170\ndrivers/usb/core/hcd.c:1607\nRead of size 4 at addr ffff888065379610 by task kworker/u4:1/27\n\nCPU: 1 PID: 27 Comm: kworker/u4:1 Not tainted 5.5.11 #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.10.2-1ubuntu1 04/01/2014\nWorkqueue: scsi_tmf_2 scmd_eh_abort_handler\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xce/0x128 lib/dump_stack.c:118\n print_address_description.constprop.4+0x21/0x3c0 mm/kasan/report.c:374\n __kasan_report+0x153/0x1cb mm/kasan/report.c:506\n kasan_report+0x12/0x20 mm/kasan/common.c:639\n check_memory_region_inline mm/kasan/generic.c:185 [inline]\n check_memory_region+0x152/0x1b0 mm/kasan/generic.c:192\n __kasan_check_read+0x11/0x20 mm/kasan/common.c:95\n atomic_read include/asm-generic/atomic-instrumented.h:26 [inline]\n usb_hcd_unlink_urb+0x5f/0x170 drivers/usb/core/hcd.c:1607\n usb_unlink_urb+0x72/0xb0 drivers/usb/core/urb.c:657\n usb_sg_cancel+0x14e/0x290 drivers/usb/core/message.c:602\n usb_stor_stop_transport+0x5e/0xa0 drivers/usb/storage/transport.c:937\n\nThis bug occurs when cancellation of the S-G transfer races with\ntransfer completion.  When that happens, usb_sg_cancel() may continue\nto access the transfer's URBs after usb_sg_wait() has freed them.\n\nThe bug is caused by the fact that usb_sg_cancel() does not take any\nsort of reference to the transfer, and so there is nothing to prevent\nthe URBs from being deallocated while the routine is trying to use\nthem.  The fix is to take such a reference by incrementing the\ntransfer's io->count field while the cancellation is in progres and\ndecrementing it afterward.  The transfer's URBs are not deallocated\nuntil io->complete is triggered, which happens when io->count reaches\nzero.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nReported-and-tested-by: Kyungtae Kim <kt0755@gmail.com>\nCC: <stable@vger.kernel.org>\n\nLink: https://lore.kernel.org/r/Pine.LNX.4.44L0.2003281615140.14837-100000@netrider.rowland.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/usb/core/message.c||drivers/usb/core/message.c"
    ]
  },
  "patch_diff": {
    "drivers/usb/core/message.c||drivers/usb/core/message.c": [
      "File: drivers/usb/core/message.c -> drivers/usb/core/message.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "589:  int i, retval;",
      "591:  spin_lock_irqsave(&io->lock, flags);",
      "593:   spin_unlock_irqrestore(&io->lock, flags);",
      "594:   return;",
      "595:  }",
      "597:  io->status = -ECONNRESET;",
      "598:  spin_unlock_irqrestore(&io->lock, flags);",
      "600:  for (i = io->entries - 1; i >= 0; --i) {",
      "",
      "[Removed Lines]",
      "592:  if (io->status) {",
      "",
      "[Added Lines]",
      "592:  if (io->status || io->count == 0) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "608:    dev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",",
      "609:      __func__, retval);",
      "610:  }",
      "611: }",
      "612: EXPORT_SYMBOL_GPL(usb_sg_cancel);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "613:  spin_lock_irqsave(&io->lock, flags);",
      "614:  io->count--;",
      "615:  if (!io->count)",
      "616:   complete(&io->complete);",
      "617:  spin_unlock_irqrestore(&io->lock, flags);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a57eb14ebb00270ac0e679e93ea69110f33697a2",
      "candidate_info": {
        "commit_hash": "a57eb14ebb00270ac0e679e93ea69110f33697a2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a57eb14ebb00270ac0e679e93ea69110f33697a2",
        "files": [
          "drivers/video/fbdev/controlfb.c"
        ],
        "message": "video: fbdev: controlfb: remove function prototypes part #2\n\nReorder code a bit and then remove no longer needed function\nprototypes.\n\nAcked-by: Sam Ravnborg <sam@ravnborg.org>\nSigned-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20200324134508.25120-6-b.zolnierkie@samsung.com",
        "before_after_code_files": [
          "drivers/video/fbdev/controlfb.c||drivers/video/fbdev/controlfb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/video/fbdev/controlfb.c||drivers/video/fbdev/controlfb.c": [
          "File: drivers/video/fbdev/controlfb.c -> drivers/video/fbdev/controlfb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "148: static void control_set_hardware(struct fb_info_control *p,",
          "149:  struct fb_par_control *par);",
          "154: static int control_var_to_par(struct fb_var_screeninfo *var,",
          "155:  struct fb_par_control *par, const struct fb_info *fb_info);",
          "156: static void control_par_to_var(struct fb_par_control *par,",
          "157:  struct fb_var_screeninfo *var);",
          "",
          "[Removed Lines]",
          "146: static void set_control_clock(unsigned char *params);",
          "147: static int init_control(struct fb_info_control *p);",
          "150: static int control_of_init(struct device_node *dp);",
          "151: static void find_vram_size(struct fb_info_control *p);",
          "152: static int read_control_sense(struct fb_info_control *p);",
          "153: static int calc_clock_params(unsigned long clk, unsigned char *param);",
          "158: static void control_init_info(struct fb_info *info, struct fb_info_control *p);",
          "159: static void control_cleanup(void);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "370: #endif",
          "371: }",
          "444: #define RADACAL_WRITE(a,d) \\",
          "445:  out_8(&p->cmap_regs->addr, (a)); \\",
          "446:  out_8(&p->cmap_regs->dat,   (d))",
          "",
          "[Removed Lines]",
          "377: static int __init init_control(struct fb_info_control *p)",
          "378: {",
          "379:  int full, sense, vmode, cmode, vyres;",
          "380:  struct fb_var_screeninfo var;",
          "381:  int rc;",
          "383:  printk(KERN_INFO \"controlfb: \");",
          "385:  full = p->total_vram == 0x400000;",
          "388:  cmode = default_cmode;",
          "389:  if (IS_REACHABLE(CONFIG_NVRAM) && cmode == CMODE_NVRAM)",
          "390:   cmode = nvram_read_byte(NV_CMODE);",
          "391:  if (cmode < CMODE_8 || cmode > CMODE_32)",
          "392:   cmode = CMODE_8;",
          "394:  vmode = default_vmode;",
          "395:  if (IS_REACHABLE(CONFIG_NVRAM) && vmode == VMODE_NVRAM)",
          "396:   vmode = nvram_read_byte(NV_VMODE);",
          "397:  if (vmode < 1 || vmode > VMODE_MAX ||",
          "398:      control_mac_modes[vmode - 1].m[full] < cmode) {",
          "399:   sense = read_control_sense(p);",
          "400:   printk(KERN_CONT \"Monitor sense value = 0x%x, \", sense);",
          "401:   vmode = mac_map_monitor_sense(sense);",
          "402:   if (control_mac_modes[vmode - 1].m[full] < 0)",
          "403:    vmode = VMODE_640_480_60;",
          "404:   cmode = min(cmode, control_mac_modes[vmode - 1].m[full]);",
          "405:  }",
          "408:  control_init_info(&p->info, p);",
          "411:  if (mac_vmode_to_var(vmode, cmode, &var) < 0) {",
          "413:   printk(\"mac_vmode_to_var(%d, %d,) failed\\n\", vmode, cmode);",
          "414: try_again:",
          "415:   vmode = VMODE_640_480_60;",
          "416:   cmode = CMODE_8;",
          "417:   if (mac_vmode_to_var(vmode, cmode, &var) < 0) {",
          "418:    printk(KERN_ERR \"controlfb: mac_vmode_to_var() failed\\n\");",
          "419:    return -ENXIO;",
          "420:   }",
          "421:   printk(KERN_INFO \"controlfb: \");",
          "422:  }",
          "423:  printk(\"using video mode %d and color mode %d.\\n\", vmode, cmode);",
          "425:  vyres = (p->total_vram - CTRLFB_OFF) / (var.xres << cmode);",
          "426:  if (vyres > var.yres)",
          "427:   var.yres_virtual = vyres;",
          "430:  var.activate = FB_ACTIVATE_NOW;",
          "431:  rc = fb_set_var(&p->info, &var);",
          "432:  if (rc && (vmode != VMODE_640_480_60 || cmode != CMODE_8))",
          "433:   goto try_again;",
          "436:  if (register_framebuffer(&p->info) < 0)",
          "437:   return -ENXIO;",
          "439:  fb_info(&p->info, \"control display adapter\\n\");",
          "441:  return 0;",
          "442: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "503: }",
          "",
          "[Removed Lines]",
          "509: static void __init control_setup(char *options)",
          "510: {",
          "511:  char *this_opt;",
          "513:  if (!options || !*options)",
          "514:   return;",
          "516:  while ((this_opt = strsep(&options, \",\")) != NULL) {",
          "517:   if (!strncmp(this_opt, \"vmode:\", 6)) {",
          "518:    int vmode = simple_strtoul(this_opt+6, NULL, 0);",
          "519:    if (vmode > 0 && vmode <= VMODE_MAX &&",
          "520:        control_mac_modes[vmode - 1].m[1] >= 0)",
          "521:     default_vmode = vmode;",
          "522:   } else if (!strncmp(this_opt, \"cmode:\", 6)) {",
          "523:    int depth = simple_strtoul(this_opt+6, NULL, 0);",
          "524:    switch (depth) {",
          "525:     case CMODE_8:",
          "526:     case CMODE_16:",
          "527:     case CMODE_32:",
          "528:      default_cmode = depth;",
          "529:      break;",
          "530:     case 8:",
          "531:     default_cmode = CMODE_8;",
          "532:     break;",
          "533:     case 15:",
          "534:     case 16:",
          "535:     default_cmode = CMODE_16;",
          "536:     break;",
          "537:     case 24:",
          "538:     case 32:",
          "539:     default_cmode = CMODE_32;",
          "540:     break;",
          "541:    }",
          "542:   }",
          "543:  }",
          "544: }",
          "546: static int __init control_init(void)",
          "547: {",
          "548:  struct device_node *dp;",
          "549:  char *option = NULL;",
          "550:  int ret = -ENXIO;",
          "552:  if (fb_get_options(\"controlfb\", &option))",
          "553:   return -ENODEV;",
          "554:  control_setup(option);",
          "556:  dp = of_find_node_by_name(NULL, \"control\");",
          "557:  if (dp && !control_of_init(dp))",
          "558:   ret = 0;",
          "559:  of_node_put(dp);",
          "561:  return ret;",
          "562: }",
          "564: device_initcall(control_init);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "627:    (bank1 + bank2) << 1, bank1 << 1, bank2 << 1);",
          "628: }",
          "",
          "[Removed Lines]",
          "634: static int __init control_of_init(struct device_node *dp)",
          "635: {",
          "636:  struct fb_info_control *p;",
          "637:  struct resource  fb_res, reg_res;",
          "639:  if (control_fb) {",
          "640:   printk(KERN_ERR \"controlfb: only one control is supported\\n\");",
          "641:   return -ENXIO;",
          "642:  }",
          "644:  if (of_pci_address_to_resource(dp, 2, &fb_res) ||",
          "645:      of_pci_address_to_resource(dp, 1, &reg_res)) {",
          "646:   printk(KERN_ERR \"can't get 2 addresses for control\\n\");",
          "647:   return -ENXIO;",
          "648:  }",
          "649:  p = kzalloc(sizeof(*p), GFP_KERNEL);",
          "650:  if (!p)",
          "651:   return -ENOMEM;",
          "655:  p->fb_orig_base = fb_res.start;",
          "656:  p->fb_orig_size = resource_size(&fb_res);",
          "658:  p->frame_buffer_phys = fb_res.start + 0x800000;",
          "659:  p->control_regs_phys = reg_res.start;",
          "660:  p->control_regs_size = resource_size(&reg_res);",
          "662:  if (!p->fb_orig_base ||",
          "663:      !request_mem_region(p->fb_orig_base,p->fb_orig_size,\"controlfb\")) {",
          "664:   p->fb_orig_base = 0;",
          "665:   goto error_out;",
          "666:  }",
          "668:  p->frame_buffer = ioremap_wt(p->frame_buffer_phys, 0x800000);",
          "670:  if (!p->control_regs_phys ||",
          "671:      !request_mem_region(p->control_regs_phys, p->control_regs_size,",
          "672:      \"controlfb regs\")) {",
          "673:   p->control_regs_phys = 0;",
          "674:   goto error_out;",
          "675:  }",
          "676:  p->control_regs = ioremap(p->control_regs_phys, p->control_regs_size);",
          "679:  if (!request_mem_region(p->cmap_regs_phys, 0x1000, \"controlfb cmap\")) {",
          "680:   p->cmap_regs_phys = 0;",
          "681:   goto error_out;",
          "682:  }",
          "683:  p->cmap_regs = ioremap(p->cmap_regs_phys, 0x1000);",
          "685:  if (!p->cmap_regs || !p->control_regs || !p->frame_buffer)",
          "686:   goto error_out;",
          "688:  find_vram_size(p);",
          "689:  if (!p->total_vram)",
          "690:   goto error_out;",
          "692:  if (init_control(p) < 0)",
          "693:   goto error_out;",
          "695:  return 0;",
          "697: error_out:",
          "698:  control_cleanup();",
          "699:  return -ENXIO;",
          "700: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1022:         info->fix.accel = FB_ACCEL_NONE;",
          "1023: }",
          "1026: static void control_cleanup(void)",
          "1027: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "816: static void __init control_setup(char *options)",
          "817: {",
          "818:  char *this_opt;",
          "820:  if (!options || !*options)",
          "821:   return;",
          "823:  while ((this_opt = strsep(&options, \",\")) != NULL) {",
          "824:   if (!strncmp(this_opt, \"vmode:\", 6)) {",
          "825:    int vmode = simple_strtoul(this_opt+6, NULL, 0);",
          "826:    if (vmode > 0 && vmode <= VMODE_MAX &&",
          "827:        control_mac_modes[vmode - 1].m[1] >= 0)",
          "828:     default_vmode = vmode;",
          "829:   } else if (!strncmp(this_opt, \"cmode:\", 6)) {",
          "830:    int depth = simple_strtoul(this_opt+6, NULL, 0);",
          "831:    switch (depth) {",
          "832:     case CMODE_8:",
          "833:     case CMODE_16:",
          "834:     case CMODE_32:",
          "835:      default_cmode = depth;",
          "836:      break;",
          "837:     case 8:",
          "838:     default_cmode = CMODE_8;",
          "839:     break;",
          "840:     case 15:",
          "841:     case 16:",
          "842:     default_cmode = CMODE_16;",
          "843:     break;",
          "844:     case 24:",
          "845:     case 32:",
          "846:     default_cmode = CMODE_32;",
          "847:     break;",
          "848:    }",
          "849:   }",
          "850:  }",
          "851: }",
          "856: static int __init init_control(struct fb_info_control *p)",
          "857: {",
          "858:  int full, sense, vmode, cmode, vyres;",
          "859:  struct fb_var_screeninfo var;",
          "860:  int rc;",
          "862:  printk(KERN_INFO \"controlfb: \");",
          "864:  full = p->total_vram == 0x400000;",
          "867:  cmode = default_cmode;",
          "868:  if (IS_REACHABLE(CONFIG_NVRAM) && cmode == CMODE_NVRAM)",
          "869:   cmode = nvram_read_byte(NV_CMODE);",
          "870:  if (cmode < CMODE_8 || cmode > CMODE_32)",
          "871:   cmode = CMODE_8;",
          "873:  vmode = default_vmode;",
          "874:  if (IS_REACHABLE(CONFIG_NVRAM) && vmode == VMODE_NVRAM)",
          "875:   vmode = nvram_read_byte(NV_VMODE);",
          "876:  if (vmode < 1 || vmode > VMODE_MAX ||",
          "877:      control_mac_modes[vmode - 1].m[full] < cmode) {",
          "878:   sense = read_control_sense(p);",
          "879:   printk(KERN_CONT \"Monitor sense value = 0x%x, \", sense);",
          "880:   vmode = mac_map_monitor_sense(sense);",
          "881:   if (control_mac_modes[vmode - 1].m[full] < 0)",
          "882:    vmode = VMODE_640_480_60;",
          "883:   cmode = min(cmode, control_mac_modes[vmode - 1].m[full]);",
          "884:  }",
          "887:  control_init_info(&p->info, p);",
          "890:  if (mac_vmode_to_var(vmode, cmode, &var) < 0) {",
          "892:   printk(\"mac_vmode_to_var(%d, %d,) failed\\n\", vmode, cmode);",
          "893: try_again:",
          "894:   vmode = VMODE_640_480_60;",
          "895:   cmode = CMODE_8;",
          "896:   if (mac_vmode_to_var(vmode, cmode, &var) < 0) {",
          "897:    printk(KERN_ERR \"controlfb: mac_vmode_to_var() failed\\n\");",
          "898:    return -ENXIO;",
          "899:   }",
          "900:   printk(KERN_INFO \"controlfb: \");",
          "901:  }",
          "902:  printk(\"using video mode %d and color mode %d.\\n\", vmode, cmode);",
          "904:  vyres = (p->total_vram - CTRLFB_OFF) / (var.xres << cmode);",
          "905:  if (vyres > var.yres)",
          "906:   var.yres_virtual = vyres;",
          "909:  var.activate = FB_ACTIVATE_NOW;",
          "910:  rc = fb_set_var(&p->info, &var);",
          "911:  if (rc && (vmode != VMODE_640_480_60 || cmode != CMODE_8))",
          "912:   goto try_again;",
          "915:  if (register_framebuffer(&p->info) < 0)",
          "916:   return -ENXIO;",
          "918:  fb_info(&p->info, \"control display adapter\\n\");",
          "920:  return 0;",
          "921: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1048:  kfree(p);",
          "1049: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951: static int __init control_of_init(struct device_node *dp)",
          "952: {",
          "953:  struct fb_info_control *p;",
          "954:  struct resource  fb_res, reg_res;",
          "956:  if (control_fb) {",
          "957:   printk(KERN_ERR \"controlfb: only one control is supported\\n\");",
          "958:   return -ENXIO;",
          "959:  }",
          "961:  if (of_pci_address_to_resource(dp, 2, &fb_res) ||",
          "962:      of_pci_address_to_resource(dp, 1, &reg_res)) {",
          "963:   printk(KERN_ERR \"can't get 2 addresses for control\\n\");",
          "964:   return -ENXIO;",
          "965:  }",
          "966:  p = kzalloc(sizeof(*p), GFP_KERNEL);",
          "967:  if (!p)",
          "968:   return -ENOMEM;",
          "972:  p->fb_orig_base = fb_res.start;",
          "973:  p->fb_orig_size = resource_size(&fb_res);",
          "975:  p->frame_buffer_phys = fb_res.start + 0x800000;",
          "976:  p->control_regs_phys = reg_res.start;",
          "977:  p->control_regs_size = resource_size(&reg_res);",
          "979:  if (!p->fb_orig_base ||",
          "980:      !request_mem_region(p->fb_orig_base,p->fb_orig_size,\"controlfb\")) {",
          "981:   p->fb_orig_base = 0;",
          "982:   goto error_out;",
          "983:  }",
          "985:  p->frame_buffer = ioremap_wt(p->frame_buffer_phys, 0x800000);",
          "987:  if (!p->control_regs_phys ||",
          "988:      !request_mem_region(p->control_regs_phys, p->control_regs_size,",
          "989:      \"controlfb regs\")) {",
          "990:   p->control_regs_phys = 0;",
          "991:   goto error_out;",
          "992:  }",
          "993:  p->control_regs = ioremap(p->control_regs_phys, p->control_regs_size);",
          "996:  if (!request_mem_region(p->cmap_regs_phys, 0x1000, \"controlfb cmap\")) {",
          "997:   p->cmap_regs_phys = 0;",
          "998:   goto error_out;",
          "999:  }",
          "1000:  p->cmap_regs = ioremap(p->cmap_regs_phys, 0x1000);",
          "1002:  if (!p->cmap_regs || !p->control_regs || !p->frame_buffer)",
          "1003:   goto error_out;",
          "1005:  find_vram_size(p);",
          "1006:  if (!p->total_vram)",
          "1007:   goto error_out;",
          "1009:  if (init_control(p) < 0)",
          "1010:   goto error_out;",
          "1012:  return 0;",
          "1014: error_out:",
          "1015:  control_cleanup();",
          "1016:  return -ENXIO;",
          "1017: }",
          "1019: static int __init control_init(void)",
          "1020: {",
          "1021:  struct device_node *dp;",
          "1022:  char *option = NULL;",
          "1023:  int ret = -ENXIO;",
          "1025:  if (fb_get_options(\"controlfb\", &option))",
          "1026:   return -ENODEV;",
          "1027:  control_setup(option);",
          "1029:  dp = of_find_node_by_name(NULL, \"control\");",
          "1030:  if (dp && !control_of_init(dp))",
          "1031:   ret = 0;",
          "1032:  of_node_put(dp);",
          "1034:  return ret;",
          "1035: }",
          "1037: device_initcall(control_init);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
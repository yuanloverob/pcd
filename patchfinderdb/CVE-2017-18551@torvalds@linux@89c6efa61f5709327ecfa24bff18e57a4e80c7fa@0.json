{
  "cve_id": "CVE-2017-18551",
  "cve_desc": "An issue was discovered in drivers/i2c/i2c-core-smbus.c in the Linux kernel before 4.14.15. There is an out of bounds write in the function i2c_smbus_xfer_emulated.",
  "repo": "torvalds/linux",
  "patch_hash": "89c6efa61f5709327ecfa24bff18e57a4e80c7fa",
  "patch_info": {
    "commit_hash": "89c6efa61f5709327ecfa24bff18e57a4e80c7fa",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/89c6efa61f5709327ecfa24bff18e57a4e80c7fa",
    "files": [
      "drivers/i2c/i2c-core-smbus.c"
    ],
    "message": "i2c: core-smbus: prevent stack corruption on read I2C_BLOCK_DATA\n\nOn a I2C_SMBUS_I2C_BLOCK_DATA read request, if data->block[0] is\ngreater than I2C_SMBUS_BLOCK_MAX + 1, the underlying I2C driver writes\ndata out of the msgbuf1 array boundary.\n\nIt is possible from a user application to run into that issue by\ncalling the I2C_SMBUS ioctl with data.block[0] greater than\nI2C_SMBUS_BLOCK_MAX + 1.\n\nThis patch makes the code compliant with\nDocumentation/i2c/dev-interface by raising an error when the requested\nsize is larger than 32 bytes.\n\nCall Trace:\n [<ffffffff8139f695>] dump_stack+0x67/0x92\n [<ffffffff811802a4>] panic+0xc5/0x1eb\n [<ffffffff810ecb5f>] ? vprintk_default+0x1f/0x30\n [<ffffffff817456d3>] ? i2cdev_ioctl_smbus+0x303/0x320\n [<ffffffff8109a68b>] __stack_chk_fail+0x1b/0x20\n [<ffffffff817456d3>] i2cdev_ioctl_smbus+0x303/0x320\n [<ffffffff81745aed>] i2cdev_ioctl+0x4d/0x1e0\n [<ffffffff811f761a>] do_vfs_ioctl+0x2ba/0x490\n [<ffffffff81336e43>] ? security_file_ioctl+0x43/0x60\n [<ffffffff811f7869>] SyS_ioctl+0x79/0x90\n [<ffffffff81a22e97>] entry_SYSCALL_64_fastpath+0x12/0x6a\n\nSigned-off-by: Jeremy Compostella <jeremy.compostella@intel.com>\nSigned-off-by: Wolfram Sang <wsa@the-dreams.de>\nCc: stable@kernel.org",
    "before_after_code_files": [
      "drivers/i2c/i2c-core-smbus.c||drivers/i2c/i2c-core-smbus.c"
    ]
  },
  "patch_diff": {
    "drivers/i2c/i2c-core-smbus.c||drivers/i2c/i2c-core-smbus.c": [
      "File: drivers/i2c/i2c-core-smbus.c -> drivers/i2c/i2c-core-smbus.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "398:   break;",
      "399:  case I2C_SMBUS_I2C_BLOCK_DATA:",
      "400:   if (read_write == I2C_SMBUS_READ) {",
      "401:    msg[1].len = data->block[0];",
      "402:   } else {",
      "403:    msg[0].len = data->block[0] + 1;",
      "410:    for (i = 1; i <= data->block[0]; i++)",
      "411:     msgbuf0[i] = data->block[i];",
      "412:   }",
      "",
      "[Removed Lines]",
      "404:    if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {",
      "405:     dev_err(&adapter->dev,",
      "406:      \"Invalid block write size %d\\n\",",
      "407:      data->block[0]);",
      "408:     return -EINVAL;",
      "409:    }",
      "",
      "[Added Lines]",
      "400:   if (data->block[0] > I2C_SMBUS_BLOCK_MAX) {",
      "401:    dev_err(&adapter->dev, \"Invalid block %s size %d\\n\",",
      "402:     read_write == I2C_SMBUS_READ ? \"read\" : \"write\",",
      "403:     data->block[0]);",
      "404:    return -EINVAL;",
      "405:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "22c78d1cce104072747023d2ae0351bf3f97d725",
      "candidate_info": {
        "commit_hash": "22c78d1cce104072747023d2ae0351bf3f97d725",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/22c78d1cce104072747023d2ae0351bf3f97d725",
        "files": [
          "Documentation/driver-api/i2c.rst",
          "drivers/i2c/Makefile",
          "drivers/i2c/i2c-core-base.c",
          "drivers/i2c/i2c-core-smbus.c",
          "include/trace/events/i2c.h",
          "include/trace/events/smbus.h"
        ],
        "message": "i2c: break out smbus support into separate file\n\nBreak out the exported SMBus functions and the emulation layer into a\nseparate file. This also involved splitting up the tracing header into\nan I2C and an SMBus part.\n\nReviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>\nSigned-off-by: Wolfram Sang <wsa@the-dreams.de>",
        "before_after_code_files": [
          "drivers/i2c/i2c-core-base.c||drivers/i2c/i2c-core-base.c",
          "drivers/i2c/i2c-core-smbus.c||drivers/i2c/i2c-core-smbus.c",
          "include/trace/events/i2c.h||include/trace/events/i2c.h",
          "include/trace/events/smbus.h||include/trace/events/smbus.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/i2c/i2c-core-smbus.c||drivers/i2c/i2c-core-smbus.c"
          ],
          "candidate": [
            "drivers/i2c/i2c-core-smbus.c||drivers/i2c/i2c-core-smbus.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/i2c/i2c-core-base.c||drivers/i2c/i2c-core-base.c": [
          "File: drivers/i2c/i2c-core-base.c -> drivers/i2c/i2c-core-base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:    Mux support by Rodolfo Giometti <giometti@enneenne.com> and",
          "21:    Michael Lawnick <michael.lawnick.ext@nsn.com>",
          "22:    OF support is copyright (c) 2008 Jochen Friedrich <jochen@scram.de>",
          "",
          "[Removed Lines]",
          "17:    All SMBus-related things are written by Frodo Looijaard <frodol@dds.nl>",
          "18:    SMBus 2.0 support by Mark Studebaker <mdsxyz123@yahoo.com> and",
          "19:    Jean Delvare <jdelvare@suse.de>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3155: }",
          "3156: EXPORT_SYMBOL(i2c_put_adapter);",
          "3729: MODULE_AUTHOR(\"Simon G. Vogl <simon@tk.uni-linz.ac.at>\");",
          "3730: MODULE_DESCRIPTION(\"I2C-Bus main module\");",
          "3731: MODULE_LICENSE(\"GPL\");",
          "",
          "[Removed Lines]",
          "3160: #define POLY    (0x1070U << 3)",
          "3161: static u8 crc8(u16 data)",
          "3162: {",
          "3163:  int i;",
          "3165:  for (i = 0; i < 8; i++) {",
          "3166:   if (data & 0x8000)",
          "3167:    data = data ^ POLY;",
          "3168:   data = data << 1;",
          "3169:  }",
          "3170:  return (u8)(data >> 8);",
          "3171: }",
          "3174: static u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)",
          "3175: {",
          "3176:  int i;",
          "3178:  for (i = 0; i < count; i++)",
          "3179:   crc = crc8((crc ^ p[i]) << 8);",
          "3180:  return crc;",
          "3181: }",
          "3184: static u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)",
          "3185: {",
          "3187:  u8 addr = i2c_8bit_addr_from_msg(msg);",
          "3188:  pec = i2c_smbus_pec(pec, &addr, 1);",
          "3191:  return i2c_smbus_pec(pec, msg->buf, msg->len);",
          "3192: }",
          "3195: static inline void i2c_smbus_add_pec(struct i2c_msg *msg)",
          "3196: {",
          "3197:  msg->buf[msg->len] = i2c_smbus_msg_pec(0, msg);",
          "3198:  msg->len++;",
          "3199: }",
          "3202:    If there was a write before this read (most cases) we need to take the",
          "3203:    partial CRC from the write part into account.",
          "3204:    Note that this function does modify the message (we need to decrease the",
          "3206: static int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg)",
          "3207: {",
          "3208:  u8 rpec = msg->buf[--msg->len];",
          "3209:  cpec = i2c_smbus_msg_pec(cpec, msg);",
          "3211:  if (rpec != cpec) {",
          "3212:   pr_debug(\"Bad PEC 0x%02x vs. 0x%02x\\n\",",
          "3213:    rpec, cpec);",
          "3214:   return -EBADMSG;",
          "3215:  }",
          "3216:  return 0;",
          "3217: }",
          "3226: s32 i2c_smbus_read_byte(const struct i2c_client *client)",
          "3227: {",
          "3228:  union i2c_smbus_data data;",
          "3229:  int status;",
          "3231:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3232:     I2C_SMBUS_READ, 0,",
          "3233:     I2C_SMBUS_BYTE, &data);",
          "3234:  return (status < 0) ? status : data.byte;",
          "3235: }",
          "3236: EXPORT_SYMBOL(i2c_smbus_read_byte);",
          "3246: s32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value)",
          "3247: {",
          "3248:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3249:                        I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);",
          "3250: }",
          "3251: EXPORT_SYMBOL(i2c_smbus_write_byte);",
          "3261: s32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)",
          "3262: {",
          "3263:  union i2c_smbus_data data;",
          "3264:  int status;",
          "3266:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3267:     I2C_SMBUS_READ, command,",
          "3268:     I2C_SMBUS_BYTE_DATA, &data);",
          "3269:  return (status < 0) ? status : data.byte;",
          "3270: }",
          "3271: EXPORT_SYMBOL(i2c_smbus_read_byte_data);",
          "3282: s32 i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command,",
          "3283:          u8 value)",
          "3284: {",
          "3285:  union i2c_smbus_data data;",
          "3286:  data.byte = value;",
          "3287:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3288:          I2C_SMBUS_WRITE, command,",
          "3289:          I2C_SMBUS_BYTE_DATA, &data);",
          "3290: }",
          "3291: EXPORT_SYMBOL(i2c_smbus_write_byte_data);",
          "3301: s32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command)",
          "3302: {",
          "3303:  union i2c_smbus_data data;",
          "3304:  int status;",
          "3306:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3307:     I2C_SMBUS_READ, command,",
          "3308:     I2C_SMBUS_WORD_DATA, &data);",
          "3309:  return (status < 0) ? status : data.word;",
          "3310: }",
          "3311: EXPORT_SYMBOL(i2c_smbus_read_word_data);",
          "3322: s32 i2c_smbus_write_word_data(const struct i2c_client *client, u8 command,",
          "3323:          u16 value)",
          "3324: {",
          "3325:  union i2c_smbus_data data;",
          "3326:  data.word = value;",
          "3327:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3328:          I2C_SMBUS_WRITE, command,",
          "3329:          I2C_SMBUS_WORD_DATA, &data);",
          "3330: }",
          "3331: EXPORT_SYMBOL(i2c_smbus_write_word_data);",
          "3348: s32 i2c_smbus_read_block_data(const struct i2c_client *client, u8 command,",
          "3349:          u8 *values)",
          "3350: {",
          "3351:  union i2c_smbus_data data;",
          "3352:  int status;",
          "3354:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3355:     I2C_SMBUS_READ, command,",
          "3356:     I2C_SMBUS_BLOCK_DATA, &data);",
          "3357:  if (status)",
          "3358:   return status;",
          "3360:  memcpy(values, &data.block[1], data.block[0]);",
          "3361:  return data.block[0];",
          "3362: }",
          "3363: EXPORT_SYMBOL(i2c_smbus_read_block_data);",
          "3375: s32 i2c_smbus_write_block_data(const struct i2c_client *client, u8 command,",
          "3376:           u8 length, const u8 *values)",
          "3377: {",
          "3378:  union i2c_smbus_data data;",
          "3380:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "3381:   length = I2C_SMBUS_BLOCK_MAX;",
          "3382:  data.block[0] = length;",
          "3383:  memcpy(&data.block[1], values, length);",
          "3384:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3385:          I2C_SMBUS_WRITE, command,",
          "3386:          I2C_SMBUS_BLOCK_DATA, &data);",
          "3387: }",
          "3388: EXPORT_SYMBOL(i2c_smbus_write_block_data);",
          "3391: s32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client, u8 command,",
          "3392:       u8 length, u8 *values)",
          "3393: {",
          "3394:  union i2c_smbus_data data;",
          "3395:  int status;",
          "3397:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "3398:   length = I2C_SMBUS_BLOCK_MAX;",
          "3399:  data.block[0] = length;",
          "3400:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3401:     I2C_SMBUS_READ, command,",
          "3402:     I2C_SMBUS_I2C_BLOCK_DATA, &data);",
          "3403:  if (status < 0)",
          "3404:   return status;",
          "3406:  memcpy(values, &data.block[1], data.block[0]);",
          "3407:  return data.block[0];",
          "3408: }",
          "3409: EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data);",
          "3411: s32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,",
          "3412:        u8 length, const u8 *values)",
          "3413: {",
          "3414:  union i2c_smbus_data data;",
          "3416:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "3417:   length = I2C_SMBUS_BLOCK_MAX;",
          "3418:  data.block[0] = length;",
          "3419:  memcpy(data.block + 1, values, length);",
          "3420:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "3421:          I2C_SMBUS_WRITE, command,",
          "3422:          I2C_SMBUS_I2C_BLOCK_DATA, &data);",
          "3423: }",
          "3424: EXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);",
          "3428: static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,",
          "3429:        unsigned short flags,",
          "3430:        char read_write, u8 command, int size,",
          "3431:        union i2c_smbus_data *data)",
          "3432: {",
          "3434:    need to use only one message; when reading, we need two. We initialize",
          "3435:    most things with sane defaults, to keep the code below somewhat",
          "3437:  unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];",
          "3438:  unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];",
          "3439:  int num = read_write == I2C_SMBUS_READ ? 2 : 1;",
          "3440:  int i;",
          "3441:  u8 partial_pec = 0;",
          "3442:  int status;",
          "3443:  struct i2c_msg msg[2] = {",
          "3444:   {",
          "3445:    .addr = addr,",
          "3446:    .flags = flags,",
          "3447:    .len = 1,",
          "3448:    .buf = msgbuf0,",
          "3449:   }, {",
          "3450:    .addr = addr,",
          "3451:    .flags = flags | I2C_M_RD,",
          "3452:    .len = 0,",
          "3453:    .buf = msgbuf1,",
          "3454:   },",
          "3455:  };",
          "3457:  msgbuf0[0] = command;",
          "3458:  switch (size) {",
          "3459:  case I2C_SMBUS_QUICK:",
          "3460:   msg[0].len = 0;",
          "3462:   msg[0].flags = flags | (read_write == I2C_SMBUS_READ ?",
          "3463:      I2C_M_RD : 0);",
          "3464:   num = 1;",
          "3465:   break;",
          "3466:  case I2C_SMBUS_BYTE:",
          "3467:   if (read_write == I2C_SMBUS_READ) {",
          "3469:    msg[0].flags = I2C_M_RD | flags;",
          "3470:    num = 1;",
          "3471:   }",
          "3472:   break;",
          "3473:  case I2C_SMBUS_BYTE_DATA:",
          "3474:   if (read_write == I2C_SMBUS_READ)",
          "3475:    msg[1].len = 1;",
          "3476:   else {",
          "3477:    msg[0].len = 2;",
          "3478:    msgbuf0[1] = data->byte;",
          "3479:   }",
          "3480:   break;",
          "3481:  case I2C_SMBUS_WORD_DATA:",
          "3482:   if (read_write == I2C_SMBUS_READ)",
          "3483:    msg[1].len = 2;",
          "3484:   else {",
          "3485:    msg[0].len = 3;",
          "3486:    msgbuf0[1] = data->word & 0xff;",
          "3487:    msgbuf0[2] = data->word >> 8;",
          "3488:   }",
          "3489:   break;",
          "3490:  case I2C_SMBUS_PROC_CALL:",
          "3492:   read_write = I2C_SMBUS_READ;",
          "3493:   msg[0].len = 3;",
          "3494:   msg[1].len = 2;",
          "3495:   msgbuf0[1] = data->word & 0xff;",
          "3496:   msgbuf0[2] = data->word >> 8;",
          "3497:   break;",
          "3498:  case I2C_SMBUS_BLOCK_DATA:",
          "3499:   if (read_write == I2C_SMBUS_READ) {",
          "3500:    msg[1].flags |= I2C_M_RECV_LEN;",
          "3501:    msg[1].len = 1; /* block length will be added by",
          "3503:   } else {",
          "3504:    msg[0].len = data->block[0] + 2;",
          "3505:    if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {",
          "3506:     dev_err(&adapter->dev,",
          "3507:      \"Invalid block write size %d\\n\",",
          "3508:      data->block[0]);",
          "3509:     return -EINVAL;",
          "3510:    }",
          "3511:    for (i = 1; i < msg[0].len; i++)",
          "3512:     msgbuf0[i] = data->block[i-1];",
          "3513:   }",
          "3514:   break;",
          "3515:  case I2C_SMBUS_BLOCK_PROC_CALL:",
          "3517:   read_write = I2C_SMBUS_READ;",
          "3518:   if (data->block[0] > I2C_SMBUS_BLOCK_MAX) {",
          "3519:    dev_err(&adapter->dev,",
          "3520:     \"Invalid block write size %d\\n\",",
          "3521:     data->block[0]);",
          "3522:    return -EINVAL;",
          "3523:   }",
          "3524:   msg[0].len = data->block[0] + 2;",
          "3525:   for (i = 1; i < msg[0].len; i++)",
          "3526:    msgbuf0[i] = data->block[i-1];",
          "3527:   msg[1].flags |= I2C_M_RECV_LEN;",
          "3528:   msg[1].len = 1; /* block length will be added by",
          "3530:   break;",
          "3531:  case I2C_SMBUS_I2C_BLOCK_DATA:",
          "3532:   if (read_write == I2C_SMBUS_READ) {",
          "3533:    msg[1].len = data->block[0];",
          "3534:   } else {",
          "3535:    msg[0].len = data->block[0] + 1;",
          "3536:    if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {",
          "3537:     dev_err(&adapter->dev,",
          "3538:      \"Invalid block write size %d\\n\",",
          "3539:      data->block[0]);",
          "3540:     return -EINVAL;",
          "3541:    }",
          "3542:    for (i = 1; i <= data->block[0]; i++)",
          "3543:     msgbuf0[i] = data->block[i];",
          "3544:   }",
          "3545:   break;",
          "3546:  default:",
          "3547:   dev_err(&adapter->dev, \"Unsupported transaction %d\\n\", size);",
          "3548:   return -EOPNOTSUPP;",
          "3549:  }",
          "3551:  i = ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK",
          "3552:           && size != I2C_SMBUS_I2C_BLOCK_DATA);",
          "3553:  if (i) {",
          "3555:   if (!(msg[0].flags & I2C_M_RD)) {",
          "3557:     i2c_smbus_add_pec(&msg[0]);",
          "3559:     partial_pec = i2c_smbus_msg_pec(0, &msg[0]);",
          "3560:   }",
          "3562:   if (msg[num-1].flags & I2C_M_RD)",
          "3563:    msg[num-1].len++;",
          "3564:  }",
          "3566:  status = i2c_transfer(adapter, msg, num);",
          "3567:  if (status < 0)",
          "3568:   return status;",
          "3571:  if (i && (msg[num-1].flags & I2C_M_RD)) {",
          "3572:   status = i2c_smbus_check_pec(partial_pec, &msg[num-1]);",
          "3573:   if (status < 0)",
          "3574:    return status;",
          "3575:  }",
          "3577:  if (read_write == I2C_SMBUS_READ)",
          "3578:   switch (size) {",
          "3579:   case I2C_SMBUS_BYTE:",
          "3580:    data->byte = msgbuf0[0];",
          "3581:    break;",
          "3582:   case I2C_SMBUS_BYTE_DATA:",
          "3583:    data->byte = msgbuf1[0];",
          "3584:    break;",
          "3585:   case I2C_SMBUS_WORD_DATA:",
          "3586:   case I2C_SMBUS_PROC_CALL:",
          "3587:    data->word = msgbuf1[0] | (msgbuf1[1] << 8);",
          "3588:    break;",
          "3589:   case I2C_SMBUS_I2C_BLOCK_DATA:",
          "3590:    for (i = 0; i < data->block[0]; i++)",
          "3591:     data->block[i+1] = msgbuf1[i];",
          "3592:    break;",
          "3593:   case I2C_SMBUS_BLOCK_DATA:",
          "3594:   case I2C_SMBUS_BLOCK_PROC_CALL:",
          "3595:    for (i = 0; i < msgbuf1[0] + 1; i++)",
          "3596:     data->block[i] = msgbuf1[i];",
          "3597:    break;",
          "3598:   }",
          "3599:  return 0;",
          "3600: }",
          "3615: s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,",
          "3616:      char read_write, u8 command, int protocol,",
          "3617:      union i2c_smbus_data *data)",
          "3618: {",
          "3619:  unsigned long orig_jiffies;",
          "3620:  int try;",
          "3621:  s32 res;",
          "3626:  trace_smbus_write(adapter, addr, flags, read_write,",
          "3627:      command, protocol, data);",
          "3628:  trace_smbus_read(adapter, addr, flags, read_write,",
          "3629:     command, protocol);",
          "3631:  flags &= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB;",
          "3633:  if (adapter->algo->smbus_xfer) {",
          "3634:   i2c_lock_bus(adapter, I2C_LOCK_SEGMENT);",
          "3637:   orig_jiffies = jiffies;",
          "3638:   for (res = 0, try = 0; try <= adapter->retries; try++) {",
          "3639:    res = adapter->algo->smbus_xfer(adapter, addr, flags,",
          "3640:        read_write, command,",
          "3641:        protocol, data);",
          "3642:    if (res != -EAGAIN)",
          "3643:     break;",
          "3644:    if (time_after(jiffies,",
          "3645:            orig_jiffies + adapter->timeout))",
          "3646:     break;",
          "3647:   }",
          "3648:   i2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);",
          "3650:   if (res != -EOPNOTSUPP || !adapter->algo->master_xfer)",
          "3651:    goto trace;",
          "3656:  }",
          "3658:  res = i2c_smbus_xfer_emulated(adapter, addr, flags, read_write,",
          "3659:           command, protocol, data);",
          "3661: trace:",
          "3663:  trace_smbus_reply(adapter, addr, flags, read_write,",
          "3664:      command, protocol, data);",
          "3665:  trace_smbus_result(adapter, addr, flags, read_write,",
          "3666:       command, protocol, res);",
          "3668:  return res;",
          "3669: }",
          "3670: EXPORT_SYMBOL(i2c_smbus_xfer);",
          "3691: s32 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,",
          "3692:            u8 command, u8 length, u8 *values)",
          "3693: {",
          "3694:  u8 i = 0;",
          "3695:  int status;",
          "3697:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "3698:   length = I2C_SMBUS_BLOCK_MAX;",
          "3700:  if (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK))",
          "3701:   return i2c_smbus_read_i2c_block_data(client, command, length, values);",
          "3703:  if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_BYTE_DATA))",
          "3704:   return -EOPNOTSUPP;",
          "3706:  if (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)) {",
          "3707:   while ((i + 2) <= length) {",
          "3708:    status = i2c_smbus_read_word_data(client, command + i);",
          "3709:    if (status < 0)",
          "3710:     return status;",
          "3711:    values[i] = status & 0xff;",
          "3712:    values[i + 1] = status >> 8;",
          "3713:    i += 2;",
          "3714:   }",
          "3715:  }",
          "3717:  while (i < length) {",
          "3718:   status = i2c_smbus_read_byte_data(client, command + i);",
          "3719:   if (status < 0)",
          "3720:    return status;",
          "3721:   values[i] = status;",
          "3722:   i++;",
          "3723:  }",
          "3725:  return i;",
          "3726: }",
          "3727: EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data_or_emulated);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/i2c/i2c-core-smbus.c||drivers/i2c/i2c-core-smbus.c": [
          "File: drivers/i2c/i2c-core-smbus.c -> drivers/i2c/i2c-core-smbus.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #include <linux/device.h>",
          "18: #include <linux/err.h>",
          "19: #include <linux/i2c.h>",
          "21: #define CREATE_TRACE_POINTS",
          "22: #include <trace/events/smbus.h>",
          "27: #define POLY    (0x1070U << 3)",
          "28: static u8 crc8(u16 data)",
          "29: {",
          "30:  int i;",
          "32:  for (i = 0; i < 8; i++) {",
          "33:   if (data & 0x8000)",
          "34:    data = data ^ POLY;",
          "35:   data = data << 1;",
          "36:  }",
          "37:  return (u8)(data >> 8);",
          "38: }",
          "41: static u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)",
          "42: {",
          "43:  int i;",
          "45:  for (i = 0; i < count; i++)",
          "46:   crc = crc8((crc ^ p[i]) << 8);",
          "47:  return crc;",
          "48: }",
          "51: static u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)",
          "52: {",
          "54:  u8 addr = i2c_8bit_addr_from_msg(msg);",
          "55:  pec = i2c_smbus_pec(pec, &addr, 1);",
          "58:  return i2c_smbus_pec(pec, msg->buf, msg->len);",
          "59: }",
          "62: static inline void i2c_smbus_add_pec(struct i2c_msg *msg)",
          "63: {",
          "64:  msg->buf[msg->len] = i2c_smbus_msg_pec(0, msg);",
          "65:  msg->len++;",
          "66: }",
          "69:    If there was a write before this read (most cases) we need to take the",
          "70:    partial CRC from the write part into account.",
          "71:    Note that this function does modify the message (we need to decrease the",
          "73: static int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg)",
          "74: {",
          "75:  u8 rpec = msg->buf[--msg->len];",
          "76:  cpec = i2c_smbus_msg_pec(cpec, msg);",
          "78:  if (rpec != cpec) {",
          "79:   pr_debug(\"Bad PEC 0x%02x vs. 0x%02x\\n\",",
          "80:    rpec, cpec);",
          "81:   return -EBADMSG;",
          "82:  }",
          "83:  return 0;",
          "84: }",
          "93: s32 i2c_smbus_read_byte(const struct i2c_client *client)",
          "94: {",
          "95:  union i2c_smbus_data data;",
          "96:  int status;",
          "98:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "99:     I2C_SMBUS_READ, 0,",
          "100:     I2C_SMBUS_BYTE, &data);",
          "101:  return (status < 0) ? status : data.byte;",
          "102: }",
          "103: EXPORT_SYMBOL(i2c_smbus_read_byte);",
          "113: s32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value)",
          "114: {",
          "115:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "116:                        I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);",
          "117: }",
          "118: EXPORT_SYMBOL(i2c_smbus_write_byte);",
          "128: s32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)",
          "129: {",
          "130:  union i2c_smbus_data data;",
          "131:  int status;",
          "133:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "134:     I2C_SMBUS_READ, command,",
          "135:     I2C_SMBUS_BYTE_DATA, &data);",
          "136:  return (status < 0) ? status : data.byte;",
          "137: }",
          "138: EXPORT_SYMBOL(i2c_smbus_read_byte_data);",
          "149: s32 i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command,",
          "150:          u8 value)",
          "151: {",
          "152:  union i2c_smbus_data data;",
          "153:  data.byte = value;",
          "154:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "155:          I2C_SMBUS_WRITE, command,",
          "156:          I2C_SMBUS_BYTE_DATA, &data);",
          "157: }",
          "158: EXPORT_SYMBOL(i2c_smbus_write_byte_data);",
          "168: s32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command)",
          "169: {",
          "170:  union i2c_smbus_data data;",
          "171:  int status;",
          "173:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "174:     I2C_SMBUS_READ, command,",
          "175:     I2C_SMBUS_WORD_DATA, &data);",
          "176:  return (status < 0) ? status : data.word;",
          "177: }",
          "178: EXPORT_SYMBOL(i2c_smbus_read_word_data);",
          "189: s32 i2c_smbus_write_word_data(const struct i2c_client *client, u8 command,",
          "190:          u16 value)",
          "191: {",
          "192:  union i2c_smbus_data data;",
          "193:  data.word = value;",
          "194:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "195:          I2C_SMBUS_WRITE, command,",
          "196:          I2C_SMBUS_WORD_DATA, &data);",
          "197: }",
          "198: EXPORT_SYMBOL(i2c_smbus_write_word_data);",
          "215: s32 i2c_smbus_read_block_data(const struct i2c_client *client, u8 command,",
          "216:          u8 *values)",
          "217: {",
          "218:  union i2c_smbus_data data;",
          "219:  int status;",
          "221:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "222:     I2C_SMBUS_READ, command,",
          "223:     I2C_SMBUS_BLOCK_DATA, &data);",
          "224:  if (status)",
          "225:   return status;",
          "227:  memcpy(values, &data.block[1], data.block[0]);",
          "228:  return data.block[0];",
          "229: }",
          "230: EXPORT_SYMBOL(i2c_smbus_read_block_data);",
          "242: s32 i2c_smbus_write_block_data(const struct i2c_client *client, u8 command,",
          "243:           u8 length, const u8 *values)",
          "244: {",
          "245:  union i2c_smbus_data data;",
          "247:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "248:   length = I2C_SMBUS_BLOCK_MAX;",
          "249:  data.block[0] = length;",
          "250:  memcpy(&data.block[1], values, length);",
          "251:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "252:          I2C_SMBUS_WRITE, command,",
          "253:          I2C_SMBUS_BLOCK_DATA, &data);",
          "254: }",
          "255: EXPORT_SYMBOL(i2c_smbus_write_block_data);",
          "258: s32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client, u8 command,",
          "259:       u8 length, u8 *values)",
          "260: {",
          "261:  union i2c_smbus_data data;",
          "262:  int status;",
          "264:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "265:   length = I2C_SMBUS_BLOCK_MAX;",
          "266:  data.block[0] = length;",
          "267:  status = i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "268:     I2C_SMBUS_READ, command,",
          "269:     I2C_SMBUS_I2C_BLOCK_DATA, &data);",
          "270:  if (status < 0)",
          "271:   return status;",
          "273:  memcpy(values, &data.block[1], data.block[0]);",
          "274:  return data.block[0];",
          "275: }",
          "276: EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data);",
          "278: s32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,",
          "279:        u8 length, const u8 *values)",
          "280: {",
          "281:  union i2c_smbus_data data;",
          "283:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "284:   length = I2C_SMBUS_BLOCK_MAX;",
          "285:  data.block[0] = length;",
          "286:  memcpy(data.block + 1, values, length);",
          "287:  return i2c_smbus_xfer(client->adapter, client->addr, client->flags,",
          "288:          I2C_SMBUS_WRITE, command,",
          "289:          I2C_SMBUS_I2C_BLOCK_DATA, &data);",
          "290: }",
          "291: EXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);",
          "295: static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,",
          "296:        unsigned short flags,",
          "297:        char read_write, u8 command, int size,",
          "298:        union i2c_smbus_data *data)",
          "299: {",
          "301:    need to use only one message; when reading, we need two. We initialize",
          "302:    most things with sane defaults, to keep the code below somewhat",
          "304:  unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];",
          "305:  unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];",
          "306:  int num = read_write == I2C_SMBUS_READ ? 2 : 1;",
          "307:  int i;",
          "308:  u8 partial_pec = 0;",
          "309:  int status;",
          "310:  struct i2c_msg msg[2] = {",
          "311:   {",
          "312:    .addr = addr,",
          "313:    .flags = flags,",
          "314:    .len = 1,",
          "315:    .buf = msgbuf0,",
          "316:   }, {",
          "317:    .addr = addr,",
          "318:    .flags = flags | I2C_M_RD,",
          "319:    .len = 0,",
          "320:    .buf = msgbuf1,",
          "321:   },",
          "322:  };",
          "324:  msgbuf0[0] = command;",
          "325:  switch (size) {",
          "326:  case I2C_SMBUS_QUICK:",
          "327:   msg[0].len = 0;",
          "329:   msg[0].flags = flags | (read_write == I2C_SMBUS_READ ?",
          "330:      I2C_M_RD : 0);",
          "331:   num = 1;",
          "332:   break;",
          "333:  case I2C_SMBUS_BYTE:",
          "334:   if (read_write == I2C_SMBUS_READ) {",
          "336:    msg[0].flags = I2C_M_RD | flags;",
          "337:    num = 1;",
          "338:   }",
          "339:   break;",
          "340:  case I2C_SMBUS_BYTE_DATA:",
          "341:   if (read_write == I2C_SMBUS_READ)",
          "342:    msg[1].len = 1;",
          "343:   else {",
          "344:    msg[0].len = 2;",
          "345:    msgbuf0[1] = data->byte;",
          "346:   }",
          "347:   break;",
          "348:  case I2C_SMBUS_WORD_DATA:",
          "349:   if (read_write == I2C_SMBUS_READ)",
          "350:    msg[1].len = 2;",
          "351:   else {",
          "352:    msg[0].len = 3;",
          "353:    msgbuf0[1] = data->word & 0xff;",
          "354:    msgbuf0[2] = data->word >> 8;",
          "355:   }",
          "356:   break;",
          "357:  case I2C_SMBUS_PROC_CALL:",
          "359:   read_write = I2C_SMBUS_READ;",
          "360:   msg[0].len = 3;",
          "361:   msg[1].len = 2;",
          "362:   msgbuf0[1] = data->word & 0xff;",
          "363:   msgbuf0[2] = data->word >> 8;",
          "364:   break;",
          "365:  case I2C_SMBUS_BLOCK_DATA:",
          "366:   if (read_write == I2C_SMBUS_READ) {",
          "367:    msg[1].flags |= I2C_M_RECV_LEN;",
          "368:    msg[1].len = 1; /* block length will be added by",
          "370:   } else {",
          "371:    msg[0].len = data->block[0] + 2;",
          "372:    if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {",
          "373:     dev_err(&adapter->dev,",
          "374:      \"Invalid block write size %d\\n\",",
          "375:      data->block[0]);",
          "376:     return -EINVAL;",
          "377:    }",
          "378:    for (i = 1; i < msg[0].len; i++)",
          "379:     msgbuf0[i] = data->block[i-1];",
          "380:   }",
          "381:   break;",
          "382:  case I2C_SMBUS_BLOCK_PROC_CALL:",
          "384:   read_write = I2C_SMBUS_READ;",
          "385:   if (data->block[0] > I2C_SMBUS_BLOCK_MAX) {",
          "386:    dev_err(&adapter->dev,",
          "387:     \"Invalid block write size %d\\n\",",
          "388:     data->block[0]);",
          "389:    return -EINVAL;",
          "390:   }",
          "391:   msg[0].len = data->block[0] + 2;",
          "392:   for (i = 1; i < msg[0].len; i++)",
          "393:    msgbuf0[i] = data->block[i-1];",
          "394:   msg[1].flags |= I2C_M_RECV_LEN;",
          "395:   msg[1].len = 1; /* block length will be added by",
          "397:   break;",
          "398:  case I2C_SMBUS_I2C_BLOCK_DATA:",
          "399:   if (read_write == I2C_SMBUS_READ) {",
          "400:    msg[1].len = data->block[0];",
          "401:   } else {",
          "402:    msg[0].len = data->block[0] + 1;",
          "403:    if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {",
          "404:     dev_err(&adapter->dev,",
          "405:      \"Invalid block write size %d\\n\",",
          "406:      data->block[0]);",
          "407:     return -EINVAL;",
          "408:    }",
          "409:    for (i = 1; i <= data->block[0]; i++)",
          "410:     msgbuf0[i] = data->block[i];",
          "411:   }",
          "412:   break;",
          "413:  default:",
          "414:   dev_err(&adapter->dev, \"Unsupported transaction %d\\n\", size);",
          "415:   return -EOPNOTSUPP;",
          "416:  }",
          "418:  i = ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK",
          "419:           && size != I2C_SMBUS_I2C_BLOCK_DATA);",
          "420:  if (i) {",
          "422:   if (!(msg[0].flags & I2C_M_RD)) {",
          "424:     i2c_smbus_add_pec(&msg[0]);",
          "426:     partial_pec = i2c_smbus_msg_pec(0, &msg[0]);",
          "427:   }",
          "429:   if (msg[num-1].flags & I2C_M_RD)",
          "430:    msg[num-1].len++;",
          "431:  }",
          "433:  status = i2c_transfer(adapter, msg, num);",
          "434:  if (status < 0)",
          "435:   return status;",
          "438:  if (i && (msg[num-1].flags & I2C_M_RD)) {",
          "439:   status = i2c_smbus_check_pec(partial_pec, &msg[num-1]);",
          "440:   if (status < 0)",
          "441:    return status;",
          "442:  }",
          "444:  if (read_write == I2C_SMBUS_READ)",
          "445:   switch (size) {",
          "446:   case I2C_SMBUS_BYTE:",
          "447:    data->byte = msgbuf0[0];",
          "448:    break;",
          "449:   case I2C_SMBUS_BYTE_DATA:",
          "450:    data->byte = msgbuf1[0];",
          "451:    break;",
          "452:   case I2C_SMBUS_WORD_DATA:",
          "453:   case I2C_SMBUS_PROC_CALL:",
          "454:    data->word = msgbuf1[0] | (msgbuf1[1] << 8);",
          "455:    break;",
          "456:   case I2C_SMBUS_I2C_BLOCK_DATA:",
          "457:    for (i = 0; i < data->block[0]; i++)",
          "458:     data->block[i+1] = msgbuf1[i];",
          "459:    break;",
          "460:   case I2C_SMBUS_BLOCK_DATA:",
          "461:   case I2C_SMBUS_BLOCK_PROC_CALL:",
          "462:    for (i = 0; i < msgbuf1[0] + 1; i++)",
          "463:     data->block[i] = msgbuf1[i];",
          "464:    break;",
          "465:   }",
          "466:  return 0;",
          "467: }",
          "482: s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,",
          "483:      char read_write, u8 command, int protocol,",
          "484:      union i2c_smbus_data *data)",
          "485: {",
          "486:  unsigned long orig_jiffies;",
          "487:  int try;",
          "488:  s32 res;",
          "493:  trace_smbus_write(adapter, addr, flags, read_write,",
          "494:      command, protocol, data);",
          "495:  trace_smbus_read(adapter, addr, flags, read_write,",
          "496:     command, protocol);",
          "498:  flags &= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB;",
          "500:  if (adapter->algo->smbus_xfer) {",
          "501:   i2c_lock_bus(adapter, I2C_LOCK_SEGMENT);",
          "504:   orig_jiffies = jiffies;",
          "505:   for (res = 0, try = 0; try <= adapter->retries; try++) {",
          "506:    res = adapter->algo->smbus_xfer(adapter, addr, flags,",
          "507:        read_write, command,",
          "508:        protocol, data);",
          "509:    if (res != -EAGAIN)",
          "510:     break;",
          "511:    if (time_after(jiffies,",
          "512:            orig_jiffies + adapter->timeout))",
          "513:     break;",
          "514:   }",
          "515:   i2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);",
          "517:   if (res != -EOPNOTSUPP || !adapter->algo->master_xfer)",
          "518:    goto trace;",
          "523:  }",
          "525:  res = i2c_smbus_xfer_emulated(adapter, addr, flags, read_write,",
          "526:           command, protocol, data);",
          "528: trace:",
          "530:  trace_smbus_reply(adapter, addr, flags, read_write,",
          "531:      command, protocol, data);",
          "532:  trace_smbus_result(adapter, addr, flags, read_write,",
          "533:       command, protocol, res);",
          "535:  return res;",
          "536: }",
          "537: EXPORT_SYMBOL(i2c_smbus_xfer);",
          "558: s32 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,",
          "559:            u8 command, u8 length, u8 *values)",
          "560: {",
          "561:  u8 i = 0;",
          "562:  int status;",
          "564:  if (length > I2C_SMBUS_BLOCK_MAX)",
          "565:   length = I2C_SMBUS_BLOCK_MAX;",
          "567:  if (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK))",
          "568:   return i2c_smbus_read_i2c_block_data(client, command, length, values);",
          "570:  if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_BYTE_DATA))",
          "571:   return -EOPNOTSUPP;",
          "573:  if (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)) {",
          "574:   while ((i + 2) <= length) {",
          "575:    status = i2c_smbus_read_word_data(client, command + i);",
          "576:    if (status < 0)",
          "577:     return status;",
          "578:    values[i] = status & 0xff;",
          "579:    values[i + 1] = status >> 8;",
          "580:    i += 2;",
          "581:   }",
          "582:  }",
          "584:  while (i < length) {",
          "585:   status = i2c_smbus_read_byte_data(client, command + i);",
          "586:   if (status < 0)",
          "587:    return status;",
          "588:   values[i] = status;",
          "589:   i++;",
          "590:  }",
          "592:  return i;",
          "593: }",
          "594: EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data_or_emulated);",
          "",
          "---------------"
        ],
        "include/trace/events/i2c.h||include/trace/events/i2c.h": [
          "File: include/trace/events/i2c.h -> include/trace/events/i2c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "144:         i2c_transfer_trace_reg,",
          "145:         i2c_transfer_trace_unreg);",
          "",
          "[Removed Lines]",
          "150: TRACE_EVENT_CONDITION(smbus_write,",
          "151:  TP_PROTO(const struct i2c_adapter *adap,",
          "152:    u16 addr, unsigned short flags,",
          "153:    char read_write, u8 command, int protocol,",
          "154:    const union i2c_smbus_data *data),",
          "155:  TP_ARGS(adap, addr, flags, read_write, command, protocol, data),",
          "156:  TP_CONDITION(read_write == I2C_SMBUS_WRITE ||",
          "157:        protocol == I2C_SMBUS_PROC_CALL ||",
          "158:        protocol == I2C_SMBUS_BLOCK_PROC_CALL),",
          "159:  TP_STRUCT__entry(",
          "160:   __field(int, adapter_nr  )",
          "161:   __field(__u16, addr   )",
          "162:   __field(__u16, flags   )",
          "163:   __field(__u8, command   )",
          "164:   __field(__u8, len   )",
          "165:   __field(__u32, protocol  )",
          "166:   __array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2) ),",
          "167:  TP_fast_assign(",
          "168:   __entry->adapter_nr = adap->nr;",
          "169:   __entry->addr = addr;",
          "170:   __entry->flags = flags;",
          "171:   __entry->command = command;",
          "172:   __entry->protocol = protocol;",
          "174:   switch (protocol) {",
          "175:   case I2C_SMBUS_BYTE_DATA:",
          "176:    __entry->len = 1;",
          "177:    goto copy;",
          "178:   case I2C_SMBUS_WORD_DATA:",
          "179:   case I2C_SMBUS_PROC_CALL:",
          "180:    __entry->len = 2;",
          "181:    goto copy;",
          "182:   case I2C_SMBUS_BLOCK_DATA:",
          "183:   case I2C_SMBUS_BLOCK_PROC_CALL:",
          "184:   case I2C_SMBUS_I2C_BLOCK_DATA:",
          "185:    __entry->len = data->block[0] + 1;",
          "186:   copy:",
          "187:    memcpy(__entry->buf, data->block, __entry->len);",
          "188:    break;",
          "189:   case I2C_SMBUS_QUICK:",
          "190:   case I2C_SMBUS_BYTE:",
          "191:   case I2C_SMBUS_I2C_BLOCK_BROKEN:",
          "192:   default:",
          "193:    __entry->len = 0;",
          "194:   }",
          "195:          ),",
          "196:  TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s l=%u [%*phD]\",",
          "197:     __entry->adapter_nr,",
          "198:     __entry->addr,",
          "199:     __entry->flags,",
          "200:     __entry->command,",
          "201:     __print_symbolic(__entry->protocol,",
          "202:        { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "203:        { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "204:        { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "205:        { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "206:        { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "207:        { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "208:        { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "209:        { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "210:        { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" }),",
          "211:     __entry->len,",
          "212:     __entry->len, __entry->buf",
          "213:     ));",
          "218: TRACE_EVENT_CONDITION(smbus_read,",
          "219:  TP_PROTO(const struct i2c_adapter *adap,",
          "220:    u16 addr, unsigned short flags,",
          "221:    char read_write, u8 command, int protocol),",
          "222:  TP_ARGS(adap, addr, flags, read_write, command, protocol),",
          "223:  TP_CONDITION(!(read_write == I2C_SMBUS_WRITE ||",
          "224:          protocol == I2C_SMBUS_PROC_CALL ||",
          "225:          protocol == I2C_SMBUS_BLOCK_PROC_CALL)),",
          "226:  TP_STRUCT__entry(",
          "227:   __field(int, adapter_nr  )",
          "228:   __field(__u16, flags   )",
          "229:   __field(__u16, addr   )",
          "230:   __field(__u8, command   )",
          "231:   __field(__u32, protocol  )",
          "232:   __array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2) ),",
          "233:  TP_fast_assign(",
          "234:   __entry->adapter_nr = adap->nr;",
          "235:   __entry->addr = addr;",
          "236:   __entry->flags = flags;",
          "237:   __entry->command = command;",
          "238:   __entry->protocol = protocol;",
          "239:          ),",
          "240:  TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s\",",
          "241:     __entry->adapter_nr,",
          "242:     __entry->addr,",
          "243:     __entry->flags,",
          "244:     __entry->command,",
          "245:     __print_symbolic(__entry->protocol,",
          "246:        { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "247:        { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "248:        { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "249:        { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "250:        { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "251:        { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "252:        { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "253:        { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "254:        { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" })",
          "255:     ));",
          "260: TRACE_EVENT_CONDITION(smbus_reply,",
          "261:  TP_PROTO(const struct i2c_adapter *adap,",
          "262:    u16 addr, unsigned short flags,",
          "263:    char read_write, u8 command, int protocol,",
          "264:    const union i2c_smbus_data *data),",
          "265:  TP_ARGS(adap, addr, flags, read_write, command, protocol, data),",
          "266:  TP_CONDITION(read_write == I2C_SMBUS_READ),",
          "267:  TP_STRUCT__entry(",
          "268:   __field(int, adapter_nr  )",
          "269:   __field(__u16, addr   )",
          "270:   __field(__u16, flags   )",
          "271:   __field(__u8, command   )",
          "272:   __field(__u8, len   )",
          "273:   __field(__u32, protocol  )",
          "274:   __array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2) ),",
          "275:  TP_fast_assign(",
          "276:   __entry->adapter_nr = adap->nr;",
          "277:   __entry->addr = addr;",
          "278:   __entry->flags = flags;",
          "279:   __entry->command = command;",
          "280:   __entry->protocol = protocol;",
          "282:   switch (protocol) {",
          "283:   case I2C_SMBUS_BYTE:",
          "284:   case I2C_SMBUS_BYTE_DATA:",
          "285:    __entry->len = 1;",
          "286:    goto copy;",
          "287:   case I2C_SMBUS_WORD_DATA:",
          "288:   case I2C_SMBUS_PROC_CALL:",
          "289:    __entry->len = 2;",
          "290:    goto copy;",
          "291:   case I2C_SMBUS_BLOCK_DATA:",
          "292:   case I2C_SMBUS_BLOCK_PROC_CALL:",
          "293:   case I2C_SMBUS_I2C_BLOCK_DATA:",
          "294:    __entry->len = data->block[0] + 1;",
          "295:   copy:",
          "296:    memcpy(__entry->buf, data->block, __entry->len);",
          "297:    break;",
          "298:   case I2C_SMBUS_QUICK:",
          "299:   case I2C_SMBUS_I2C_BLOCK_BROKEN:",
          "300:   default:",
          "301:    __entry->len = 0;",
          "302:   }",
          "303:          ),",
          "304:  TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s l=%u [%*phD]\",",
          "305:     __entry->adapter_nr,",
          "306:     __entry->addr,",
          "307:     __entry->flags,",
          "308:     __entry->command,",
          "309:     __print_symbolic(__entry->protocol,",
          "310:        { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "311:        { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "312:        { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "313:        { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "314:        { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "315:        { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "316:        { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "317:        { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "318:        { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" }),",
          "319:     __entry->len,",
          "320:     __entry->len, __entry->buf",
          "321:     ));",
          "326: TRACE_EVENT(smbus_result,",
          "327:      TP_PROTO(const struct i2c_adapter *adap,",
          "328:        u16 addr, unsigned short flags,",
          "329:        char read_write, u8 command, int protocol,",
          "330:        int res),",
          "331:      TP_ARGS(adap, addr, flags, read_write, command, protocol, res),",
          "332:      TP_STRUCT__entry(",
          "333:       __field(int, adapter_nr  )",
          "334:       __field(__u16, addr   )",
          "335:       __field(__u16, flags   )",
          "336:       __field(__u8, read_write  )",
          "337:       __field(__u8, command   )",
          "338:       __field(__s16, res   )",
          "339:       __field(__u32, protocol  )",
          "340:         ),",
          "341:      TP_fast_assign(",
          "342:       __entry->adapter_nr = adap->nr;",
          "343:       __entry->addr = addr;",
          "344:       __entry->flags = flags;",
          "345:       __entry->read_write = read_write;",
          "346:       __entry->command = command;",
          "347:       __entry->protocol = protocol;",
          "348:       __entry->res = res;",
          "349:       ),",
          "350:      TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s %s res=%d\",",
          "351:         __entry->adapter_nr,",
          "352:         __entry->addr,",
          "353:         __entry->flags,",
          "354:         __entry->command,",
          "355:         __print_symbolic(__entry->protocol,",
          "356:            { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "357:            { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "358:            { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "359:            { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "360:            { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "361:            { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "362:            { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "363:            { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "364:            { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" }),",
          "365:         __entry->read_write == I2C_SMBUS_WRITE ? \"wr\" : \"rd\",",
          "366:         __entry->res",
          "367:         ));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/trace/events/smbus.h||include/trace/events/smbus.h": [
          "File: include/trace/events/smbus.h -> include/trace/events/smbus.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #undef TRACE_SYSTEM",
          "12: #define TRACE_SYSTEM smbus",
          "14: #if !defined(_TRACE_SMBUS_H) || defined(TRACE_HEADER_MULTI_READ)",
          "15: #define _TRACE_SMBUS_H",
          "17: #include <linux/i2c.h>",
          "18: #include <linux/tracepoint.h>",
          "27: TRACE_EVENT_CONDITION(smbus_write,",
          "28:  TP_PROTO(const struct i2c_adapter *adap,",
          "29:    u16 addr, unsigned short flags,",
          "30:    char read_write, u8 command, int protocol,",
          "31:    const union i2c_smbus_data *data),",
          "32:  TP_ARGS(adap, addr, flags, read_write, command, protocol, data),",
          "33:  TP_CONDITION(read_write == I2C_SMBUS_WRITE ||",
          "34:        protocol == I2C_SMBUS_PROC_CALL ||",
          "35:        protocol == I2C_SMBUS_BLOCK_PROC_CALL),",
          "36:  TP_STRUCT__entry(",
          "37:   __field(int, adapter_nr  )",
          "38:   __field(__u16, addr   )",
          "39:   __field(__u16, flags   )",
          "40:   __field(__u8, command   )",
          "41:   __field(__u8, len   )",
          "42:   __field(__u32, protocol  )",
          "43:   __array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2) ),",
          "44:  TP_fast_assign(",
          "45:   __entry->adapter_nr = adap->nr;",
          "46:   __entry->addr = addr;",
          "47:   __entry->flags = flags;",
          "48:   __entry->command = command;",
          "49:   __entry->protocol = protocol;",
          "51:   switch (protocol) {",
          "52:   case I2C_SMBUS_BYTE_DATA:",
          "53:    __entry->len = 1;",
          "54:    goto copy;",
          "55:   case I2C_SMBUS_WORD_DATA:",
          "56:   case I2C_SMBUS_PROC_CALL:",
          "57:    __entry->len = 2;",
          "58:    goto copy;",
          "59:   case I2C_SMBUS_BLOCK_DATA:",
          "60:   case I2C_SMBUS_BLOCK_PROC_CALL:",
          "61:   case I2C_SMBUS_I2C_BLOCK_DATA:",
          "62:    __entry->len = data->block[0] + 1;",
          "63:   copy:",
          "64:    memcpy(__entry->buf, data->block, __entry->len);",
          "65:    break;",
          "66:   case I2C_SMBUS_QUICK:",
          "67:   case I2C_SMBUS_BYTE:",
          "68:   case I2C_SMBUS_I2C_BLOCK_BROKEN:",
          "69:   default:",
          "70:    __entry->len = 0;",
          "71:   }",
          "72:          ),",
          "73:  TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s l=%u [%*phD]\",",
          "74:     __entry->adapter_nr,",
          "75:     __entry->addr,",
          "76:     __entry->flags,",
          "77:     __entry->command,",
          "78:     __print_symbolic(__entry->protocol,",
          "79:        { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "80:        { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "81:        { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "82:        { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "83:        { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "84:        { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "85:        { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "86:        { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "87:        { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" }),",
          "88:     __entry->len,",
          "89:     __entry->len, __entry->buf",
          "90:     ));",
          "95: TRACE_EVENT_CONDITION(smbus_read,",
          "96:  TP_PROTO(const struct i2c_adapter *adap,",
          "97:    u16 addr, unsigned short flags,",
          "98:    char read_write, u8 command, int protocol),",
          "99:  TP_ARGS(adap, addr, flags, read_write, command, protocol),",
          "100:  TP_CONDITION(!(read_write == I2C_SMBUS_WRITE ||",
          "101:          protocol == I2C_SMBUS_PROC_CALL ||",
          "102:          protocol == I2C_SMBUS_BLOCK_PROC_CALL)),",
          "103:  TP_STRUCT__entry(",
          "104:   __field(int, adapter_nr  )",
          "105:   __field(__u16, flags   )",
          "106:   __field(__u16, addr   )",
          "107:   __field(__u8, command   )",
          "108:   __field(__u32, protocol  )",
          "109:   __array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2) ),",
          "110:  TP_fast_assign(",
          "111:   __entry->adapter_nr = adap->nr;",
          "112:   __entry->addr = addr;",
          "113:   __entry->flags = flags;",
          "114:   __entry->command = command;",
          "115:   __entry->protocol = protocol;",
          "116:          ),",
          "117:  TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s\",",
          "118:     __entry->adapter_nr,",
          "119:     __entry->addr,",
          "120:     __entry->flags,",
          "121:     __entry->command,",
          "122:     __print_symbolic(__entry->protocol,",
          "123:        { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "124:        { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "125:        { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "126:        { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "127:        { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "128:        { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "129:        { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "130:        { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "131:        { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" })",
          "132:     ));",
          "137: TRACE_EVENT_CONDITION(smbus_reply,",
          "138:  TP_PROTO(const struct i2c_adapter *adap,",
          "139:    u16 addr, unsigned short flags,",
          "140:    char read_write, u8 command, int protocol,",
          "141:    const union i2c_smbus_data *data),",
          "142:  TP_ARGS(adap, addr, flags, read_write, command, protocol, data),",
          "143:  TP_CONDITION(read_write == I2C_SMBUS_READ),",
          "144:  TP_STRUCT__entry(",
          "145:   __field(int, adapter_nr  )",
          "146:   __field(__u16, addr   )",
          "147:   __field(__u16, flags   )",
          "148:   __field(__u8, command   )",
          "149:   __field(__u8, len   )",
          "150:   __field(__u32, protocol  )",
          "151:   __array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2) ),",
          "152:  TP_fast_assign(",
          "153:   __entry->adapter_nr = adap->nr;",
          "154:   __entry->addr = addr;",
          "155:   __entry->flags = flags;",
          "156:   __entry->command = command;",
          "157:   __entry->protocol = protocol;",
          "159:   switch (protocol) {",
          "160:   case I2C_SMBUS_BYTE:",
          "161:   case I2C_SMBUS_BYTE_DATA:",
          "162:    __entry->len = 1;",
          "163:    goto copy;",
          "164:   case I2C_SMBUS_WORD_DATA:",
          "165:   case I2C_SMBUS_PROC_CALL:",
          "166:    __entry->len = 2;",
          "167:    goto copy;",
          "168:   case I2C_SMBUS_BLOCK_DATA:",
          "169:   case I2C_SMBUS_BLOCK_PROC_CALL:",
          "170:   case I2C_SMBUS_I2C_BLOCK_DATA:",
          "171:    __entry->len = data->block[0] + 1;",
          "172:   copy:",
          "173:    memcpy(__entry->buf, data->block, __entry->len);",
          "174:    break;",
          "175:   case I2C_SMBUS_QUICK:",
          "176:   case I2C_SMBUS_I2C_BLOCK_BROKEN:",
          "177:   default:",
          "178:    __entry->len = 0;",
          "179:   }",
          "180:          ),",
          "181:  TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s l=%u [%*phD]\",",
          "182:     __entry->adapter_nr,",
          "183:     __entry->addr,",
          "184:     __entry->flags,",
          "185:     __entry->command,",
          "186:     __print_symbolic(__entry->protocol,",
          "187:        { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "188:        { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "189:        { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "190:        { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "191:        { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "192:        { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "193:        { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "194:        { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "195:        { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" }),",
          "196:     __entry->len,",
          "197:     __entry->len, __entry->buf",
          "198:     ));",
          "203: TRACE_EVENT(smbus_result,",
          "204:      TP_PROTO(const struct i2c_adapter *adap,",
          "205:        u16 addr, unsigned short flags,",
          "206:        char read_write, u8 command, int protocol,",
          "207:        int res),",
          "208:      TP_ARGS(adap, addr, flags, read_write, command, protocol, res),",
          "209:      TP_STRUCT__entry(",
          "210:       __field(int, adapter_nr  )",
          "211:       __field(__u16, addr   )",
          "212:       __field(__u16, flags   )",
          "213:       __field(__u8, read_write  )",
          "214:       __field(__u8, command   )",
          "215:       __field(__s16, res   )",
          "216:       __field(__u32, protocol  )",
          "217:         ),",
          "218:      TP_fast_assign(",
          "219:       __entry->adapter_nr = adap->nr;",
          "220:       __entry->addr = addr;",
          "221:       __entry->flags = flags;",
          "222:       __entry->read_write = read_write;",
          "223:       __entry->command = command;",
          "224:       __entry->protocol = protocol;",
          "225:       __entry->res = res;",
          "226:       ),",
          "227:      TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s %s res=%d\",",
          "228:         __entry->adapter_nr,",
          "229:         __entry->addr,",
          "230:         __entry->flags,",
          "231:         __entry->command,",
          "232:         __print_symbolic(__entry->protocol,",
          "233:            { I2C_SMBUS_QUICK,  \"QUICK\" },",
          "234:            { I2C_SMBUS_BYTE,  \"BYTE\" },",
          "235:            { I2C_SMBUS_BYTE_DATA,  \"BYTE_DATA\" },",
          "236:            { I2C_SMBUS_WORD_DATA,  \"WORD_DATA\" },",
          "237:            { I2C_SMBUS_PROC_CALL,  \"PROC_CALL\" },",
          "238:            { I2C_SMBUS_BLOCK_DATA,  \"BLOCK_DATA\" },",
          "239:            { I2C_SMBUS_I2C_BLOCK_BROKEN, \"I2C_BLOCK_BROKEN\" },",
          "240:            { I2C_SMBUS_BLOCK_PROC_CALL, \"BLOCK_PROC_CALL\" },",
          "241:            { I2C_SMBUS_I2C_BLOCK_DATA, \"I2C_BLOCK_DATA\" }),",
          "242:         __entry->read_write == I2C_SMBUS_WRITE ? \"wr\" : \"rd\",",
          "243:         __entry->res",
          "244:         ));",
          "249: #include <trace/define_trace.h>",
          "",
          "---------------"
        ]
      }
    }
  ]
}
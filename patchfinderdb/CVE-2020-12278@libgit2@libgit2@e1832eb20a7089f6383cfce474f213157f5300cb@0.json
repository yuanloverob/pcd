{
  "cve_id": "CVE-2020-12278",
  "cve_desc": "An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. path.c mishandles equivalent filenames that exist because of NTFS Alternate Data Streams. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1352.",
  "repo": "libgit2/libgit2",
  "patch_hash": "e1832eb20a7089f6383cfce474f213157f5300cb",
  "patch_info": {
    "commit_hash": "e1832eb20a7089f6383cfce474f213157f5300cb",
    "repo": "libgit2/libgit2",
    "commit_url": "https://github.com/libgit2/libgit2/commit/e1832eb20a7089f6383cfce474f213157f5300cb",
    "files": [
      "src/path.c",
      "tests/path/dotgit.c"
    ],
    "message": "path: also guard `.gitmodules` against NTFS Alternate Data Streams\n\nWe just safe-guarded `.git` against NTFS Alternate Data Stream-related\nattack vectors, and now it is time to do the same for `.gitmodules`.\n\nNote: In the added regression test, we refrain from verifying all kinds\nof variations between short names and NTFS Alternate Data Streams: as\nthe new code disallows _all_ Alternate Data Streams of `.gitmodules`, it\nis enough to test one in order to know that all of them are guarded\nagainst.\n\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>",
    "before_after_code_files": [
      "src/path.c||src/path.c",
      "tests/path/dotgit.c||tests/path/dotgit.c"
    ]
  },
  "patch_diff": {
    "src/path.c||src/path.c": [
      "File: src/path.c -> src/path.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1646:  const char *c = path;",
      "1648:  for (;; c++) {",
      "1650:    return true;",
      "1651:   if (*c != ' ' && *c != '.')",
      "1652:    return false;",
      "",
      "[Removed Lines]",
      "1649:   if (*c == '\\0')",
      "",
      "[Added Lines]",
      "1649:   if (*c == '\\0' || *c == ':')",
      "",
      "---------------"
    ],
    "tests/path/dotgit.c||tests/path/dotgit.c": [
      "File: tests/path/dotgit.c -> tests/path/dotgit.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "116:  cl_assert_equal_b(true, git_path_isvalid(NULL, \".gitmodules\", 0, GIT_PATH_REJECT_DOT_GIT_HFS|GIT_PATH_REJECT_DOT_GIT_NTFS));",
      "117:  cl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_HFS));",
      "118:  cl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));",
      "119: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "119:  cl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules . .::$DATA\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d9c0c9cf6827ba51458c54082f96f0bb1259425e",
      "candidate_info": {
        "commit_hash": "d9c0c9cf6827ba51458c54082f96f0bb1259425e",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/d9c0c9cf6827ba51458c54082f96f0bb1259425e",
        "files": [
          "tests/index/tests.c"
        ],
        "message": "test: ensure we can't add a protected path\n\nTest that when we enable core.protectNTFS that we cannot add\nplatform-specific invalid paths to the index.",
        "before_after_code_files": [
          "tests/index/tests.c||tests/index/tests.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/5331"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/index/tests.c||tests/index/tests.c": [
          "File: tests/index/tests.c -> tests/index/tests.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "590:  cl_fixture_cleanup(\"invalid\");",
          "591: }",
          "593: static void replace_char(char *str, char in, char out)",
          "594: {",
          "595:  char *c = str;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "593: static void assert_add_fails(git_repository *repo, const char *fn)",
          "594: {",
          "595:  git_index *index;",
          "596:  git_buf path = GIT_BUF_INIT;",
          "597:  git_index_entry entry = {{0}};",
          "599:  cl_git_pass(git_repository_index(&index, repo));",
          "600:  cl_assert(git_index_entrycount(index) == 0);",
          "602:  entry.path = fn;",
          "603:  entry.mode = GIT_FILEMODE_BLOB;",
          "604:  cl_git_pass(git_oid_fromstr(&entry.id, \"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391\"));",
          "606:  cl_git_fail(git_index_add(index, &entry));",
          "608:  cl_assert(git_index_entrycount(index) == 0);",
          "610:  git_buf_dispose(&path);",
          "611:  git_index_free(index);",
          "612: }",
          "618: void test_index_tests__cannot_add_protected_invalid_filename(void)",
          "619: {",
          "620:  git_repository *repo;",
          "621:  git_index *index;",
          "623:  cl_must_pass(p_mkdir(\"invalid\", 0700));",
          "625:  cl_git_pass(git_repository_init(&repo, \"./invalid\", 0));",
          "628:  cl_git_pass(git_repository_index(&index, repo));",
          "629:  cl_git_mkfile(\"invalid/dummy.txt\", \"\");",
          "630:  cl_git_pass(git_index_add_bypath(index, \"dummy.txt\"));",
          "631:  cl_must_pass(p_unlink(\"invalid/dummy.txt\"));",
          "632:  cl_git_pass(git_index_remove_bypath(index, \"dummy.txt\"));",
          "633:  git_index_free(index);",
          "635:  cl_repo_set_bool(repo, \"core.protectHFS\", true);",
          "636:  cl_repo_set_bool(repo, \"core.protectNTFS\", true);",
          "638:  assert_add_fails(repo, \".git./hello\");",
          "639:  assert_add_fails(repo, \".git\\xe2\\x80\\xad/hello\");",
          "640:  assert_add_fails(repo, \"git~1/hello\");",
          "641:  assert_add_fails(repo, \".git\\xe2\\x81\\xaf/hello\");",
          "642:  assert_add_fails(repo, \".git::$INDEX_ALLOCATION/dummy-file\");",
          "644:  git_repository_free(repo);",
          "646:  cl_fixture_cleanup(\"invalid\");",
          "647: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ba4c769b13d646664d7db8589e605f5923614347",
      "candidate_info": {
        "commit_hash": "ba4c769b13d646664d7db8589e605f5923614347",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/ba4c769b13d646664d7db8589e605f5923614347",
        "files": [
          "tests/object/tree/write.c"
        ],
        "message": "tree: ensure we protect NTFS paths everywhere",
        "before_after_code_files": [
          "tests/object/tree/write.c||tests/object/tree/write.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/5331"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/object/tree/write.c||tests/object/tree/write.c": [
          "File: tests/object/tree/write.c -> tests/object/tree/write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:  cl_git_pass(git_treebuilder_new(&builder, g_repo, NULL));",
          "143:  for (i = 0; i < ARRAY_SIZE(entries); ++i) {",
          "146:   cl_git_pass(git_treebuilder_insert(NULL,",
          "147:    builder, entries[i].filename, id, entries[i].attr));",
          "",
          "[Removed Lines]",
          "144:   git_oid *id = entries[i].attr == GIT_FILEMODE_TREE ?  &tid : &bid;",
          "",
          "[Added Lines]",
          "144:   git_oid *id = entries[i].attr == GIT_FILEMODE_TREE ?  &tid : &bid;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "419:  cl_git_pass(git_treebuilder_new(&builder, g_repo, NULL));",
          "426: #ifndef __APPLE__",
          "427:  cl_git_pass(git_treebuilder_insert(NULL, builder, \".git\\xef\\xbb\\xbf\", &bid, GIT_FILEMODE_BLOB));",
          "",
          "[Removed Lines]",
          "421: #ifndef GIT_WIN32",
          "422:  cl_git_pass(git_treebuilder_insert(NULL, builder, \".git.\", &bid, GIT_FILEMODE_BLOB));",
          "423:  cl_git_pass(git_treebuilder_insert(NULL, builder, \"git~1\", &bid, GIT_FILEMODE_BLOB));",
          "424: #endif",
          "",
          "[Added Lines]",
          "421:  cl_git_fail(git_treebuilder_insert(NULL, builder, \".git.\", &bid, GIT_FILEMODE_BLOB));",
          "422:  cl_git_fail(git_treebuilder_insert(NULL, builder, \"git~1\", &bid, GIT_FILEMODE_BLOB));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "72df1cd84885294aa6961d3710e658969313f902",
      "candidate_info": {
        "commit_hash": "72df1cd84885294aa6961d3710e658969313f902",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/72df1cd84885294aa6961d3710e658969313f902",
        "files": [
          "tests/index/tests.c"
        ],
        "message": "test: improve badname verification test\n\nThe name of the `add_invalid_filename` function suggests that we\n_want_ to add an invalid filename.  Rename the function to show that\nwe expect to _fail_ to add the invalid filename.",
        "before_after_code_files": [
          "tests/index/tests.c||tests/index/tests.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/5331"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/index/tests.c||tests/index/tests.c": [
          "File: tests/index/tests.c -> tests/index/tests.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "541:  git_repository_free(bare_repo);",
          "542: }",
          "545: {",
          "546:  git_index *index;",
          "547:  git_buf path = GIT_BUF_INIT;",
          "",
          "[Removed Lines]",
          "544: static void add_invalid_filename(git_repository *repo, const char *fn)",
          "",
          "[Added Lines]",
          "544: static void assert_add_bypath_fails(git_repository *repo, const char *fn)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "562: }",
          "566: {",
          "567:  git_repository *repo;",
          "",
          "[Removed Lines]",
          "565: void test_index_tests__add_invalid_filename(void)",
          "",
          "[Added Lines]",
          "565: void test_index_tests__cannot_add_invalid_filename(void)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "577:  if (!git_path_exists(\"./invalid/.GiT\"))",
          "578:   cl_must_pass(p_mkdir(\"./invalid/.GiT\", 0777));",
          "588:  git_repository_free(repo);",
          "",
          "[Removed Lines]",
          "580:  add_invalid_filename(repo, \".git/hello\");",
          "581:  add_invalid_filename(repo, \".GIT/hello\");",
          "582:  add_invalid_filename(repo, \".GiT/hello\");",
          "583:  add_invalid_filename(repo, \"./.git/hello\");",
          "584:  add_invalid_filename(repo, \"./foo\");",
          "585:  add_invalid_filename(repo, \"./bar\");",
          "586:  add_invalid_filename(repo, \"subdir/../bar\");",
          "",
          "[Added Lines]",
          "580:  assert_add_bypath_fails(repo, \".git/hello\");",
          "581:  assert_add_bypath_fails(repo, \".GIT/hello\");",
          "582:  assert_add_bypath_fails(repo, \".GiT/hello\");",
          "583:  assert_add_bypath_fails(repo, \"./.git/hello\");",
          "584:  assert_add_bypath_fails(repo, \"./foo\");",
          "585:  assert_add_bypath_fails(repo, \"./bar\");",
          "586:  assert_add_bypath_fails(repo, \"subdir/../bar\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b8464342f3605917b238a111e3c1ce14b254da8a",
      "candidate_info": {
        "commit_hash": "b8464342f3605917b238a111e3c1ce14b254da8a",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/b8464342f3605917b238a111e3c1ce14b254da8a",
        "files": [
          "src/path.c"
        ],
        "message": "path: rename function that detects end of filename\n\nThe function `only_spaces_and_dots` used to detect the end of the\nfilename on win32.  Now we look at spaces and dots _before_ the end of\nthe string _or_ a `:` character, which would signify a win32 alternate\ndata stream.\n\nThus, rename the function `ntfs_end_of_filename` to indicate that it\ndetects the (virtual) end of a filename, that any further characters\nwould be elided to the given path.",
        "before_after_code_files": [
          "src/path.c||src/path.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/5331"
        ],
        "olp_code_files": {
          "patch": [
            "src/path.c||src/path.c"
          ],
          "candidate": [
            "src/path.c||src/path.c"
          ]
        }
      },
      "candidate_diff": {
        "src/path.c||src/path.c": [
          "File: src/path.c -> src/path.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1641:  return false;",
          "1642: }",
          "1645: {",
          "1646:  const char *c = path;",
          "",
          "[Removed Lines]",
          "1644: GIT_INLINE(bool) only_spaces_and_dots(const char *path)",
          "",
          "[Added Lines]",
          "1653: GIT_INLINE(bool) ntfs_end_of_filename(const char *path)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1662:  if (name[0] == '.' && len >= dotgit_len &&",
          "1663:      !strncasecmp(name + 1, dotgit_name, dotgit_len)) {",
          "1665:  }",
          "1668:  if (!strncasecmp(name, dotgit_name, 6) && name[6] == '~' &&",
          "1669:      name[7] >= '1' && name[7] <= '4')",
          "1673:  for (i = 0, saw_tilde = 0; i < 8; i++) {",
          "",
          "[Removed Lines]",
          "1664:   return !only_spaces_and_dots(name + dotgit_len + 1);",
          "1670:   return !only_spaces_and_dots(name + 8);",
          "",
          "[Added Lines]",
          "1673:   return !ntfs_end_of_filename(name + dotgit_len + 1);",
          "1679:   return !ntfs_end_of_filename(name + 8);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1689:   }",
          "1690:  }",
          "1693: }",
          "1695: GIT_INLINE(bool) verify_char(unsigned char c, unsigned int flags)",
          "",
          "[Removed Lines]",
          "1692:  return !only_spaces_and_dots(name + i);",
          "",
          "[Added Lines]",
          "1701:  return !ntfs_end_of_filename(name + i);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64c612cc3e25eff5fb02c59ef5a66ba7a14751e4",
      "candidate_info": {
        "commit_hash": "64c612cc3e25eff5fb02c59ef5a66ba7a14751e4",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4",
        "files": [
          "src/checkout.c",
          "tests/checkout/nasty.c"
        ],
        "message": "Protect against 8.3 \"short name\" attacks also on Linux/macOS\n\nThe Windows Subsystem for Linux (WSL) is getting increasingly popular,\nin particular because it makes it _so_ easy to run Linux software on\nWindows' files, via the auto-mounted Windows drives (`C:\\` is mapped to\n`/mnt/c/`, no need to set that up manually).\n\nUnfortunately, files/directories on the Windows drives can be accessed\nvia their _short names_, if that feature is enabled (which it is on the\n`C:` drive by default).\n\nWhich means that we have to safeguard even our Linux users against the\nshort name attacks.\n\nFurther, while the default options of CIFS/SMB-mounts seem to disallow\naccessing files on network shares via their short names on Linux/macOS,\nit _is_ possible to do so with the right options.\n\nSo let's just safe-guard against short name attacks _everywhere_.\n\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>",
        "before_after_code_files": [
          "src/checkout.c||src/checkout.c",
          "tests/checkout/nasty.c||tests/checkout/nasty.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/5331"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/checkout.c||src/checkout.c": [
          "File: src/checkout.c -> src/checkout.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1271:  int action,",
          "1272:  git_diff_delta *delta)",
          "1273: {",
          "1276:  if (action & CHECKOUT_ACTION__REMOVE) {",
          "1277:   if (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {",
          "",
          "[Removed Lines]",
          "1274:  unsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;",
          "",
          "[Added Lines]",
          "1274:  unsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;",
          "",
          "---------------"
        ],
        "tests/checkout/nasty.c||tests/checkout/nasty.c": [
          "File: tests/checkout/nasty.c -> tests/checkout/nasty.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "207: void test_checkout_nasty__git_tilde1(void)",
          "208: {",
          "210:  test_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");",
          "212: }",
          "",
          "[Removed Lines]",
          "209: #ifdef GIT_WIN32",
          "211: #endif",
          "",
          "[Added Lines]",
          "210:  test_checkout_fails(\"refs/heads/git_tilde1\", \"git~1/foobar\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
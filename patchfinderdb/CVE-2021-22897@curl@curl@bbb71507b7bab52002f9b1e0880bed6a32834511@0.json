{
  "cve_id": "CVE-2021-22897",
  "cve_desc": "curl 7.61.0 through 7.76.1 suffers from exposure of data element to wrong session due to a mistake in the code for CURLOPT_SSL_CIPHER_LIST when libcurl is built to use the Schannel TLS library. The selected cipher set was stored in a single \"static\" variable in the library, which has the surprising side-effect that if an application sets up multiple concurrent transfers, the last one that sets the ciphers will accidentally control the set used by all transfers. In a worst-case scenario, this weakens transport security significantly.",
  "repo": "curl/curl",
  "patch_hash": "bbb71507b7bab52002f9b1e0880bed6a32834511",
  "patch_info": {
    "commit_hash": "bbb71507b7bab52002f9b1e0880bed6a32834511",
    "repo": "curl/curl",
    "commit_url": "https://github.com/curl/curl/commit/bbb71507b7bab52002f9b1e0880bed6a32834511",
    "files": [
      "lib/vtls/schannel.c",
      "lib/vtls/schannel.h"
    ],
    "message": "schannel: don't use static to store selected ciphers\n\nCVE-2021-22897\n\nBug: https://curl.se/docs/CVE-2021-22897.html",
    "before_after_code_files": [
      "lib/vtls/schannel.c||lib/vtls/schannel.c",
      "lib/vtls/schannel.h||lib/vtls/schannel.h"
    ]
  },
  "patch_diff": {
    "lib/vtls/schannel.c||lib/vtls/schannel.c": [
      "File: lib/vtls/schannel.c -> lib/vtls/schannel.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "328: }",
      "330: static CURLcode",
      "332: {",
      "333:   char *startCur = ciphers;",
      "334:   int algCount = 0;",
      "337:     long alg = strtol(startCur, 0, 0);",
      "338:     if(!alg)",
      "339:       alg = get_alg_id_by_name(startCur);",
      "",
      "[Removed Lines]",
      "331: set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers)",
      "336:   while(startCur && (0 != *startCur) && (algCount < 45)) {",
      "",
      "[Added Lines]",
      "331: set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,",
      "332:                 int *algIds)",
      "336:   while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "593:     }",
      "595:     if(SSL_CONN_CONFIG(cipher_list)) {",
      "597:       if(CURLE_OK != result) {",
      "598:         failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");",
      "599:         return result;",
      "",
      "[Removed Lines]",
      "596:       result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));",
      "",
      "[Added Lines]",
      "596:       result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),",
      "597:                                BACKEND->algIds);",
      "",
      "---------------"
    ],
    "lib/vtls/schannel.h||lib/vtls/schannel.h": [
      "File: lib/vtls/schannel.h -> lib/vtls/schannel.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "102: #ifdef HAS_MANUAL_VERIFY_API",
      "104: #endif",
      "105: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "107:   ALG_ID algIds[NUMOF_CIPHERS];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "68d388061cffe1d670d5a90d3cfd22ec2c92cebd",
      "candidate_info": {
        "commit_hash": "68d388061cffe1d670d5a90d3cfd22ec2c92cebd",
        "repo": "curl/curl",
        "commit_url": "https://github.com/curl/curl/commit/68d388061cffe1d670d5a90d3cfd22ec2c92cebd",
        "files": [
          "lib/vtls/schannel.c"
        ],
        "message": "schannel: move code out of SChannel_connect_step1\n\nReviewed-by: Marc Hoersken\nCloses #7168",
        "before_after_code_files": [
          "lib/vtls/schannel.c||lib/vtls/schannel.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/vtls/schannel.c||lib/vtls/schannel.c"
          ],
          "candidate": [
            "lib/vtls/schannel.c||lib/vtls/schannel.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/vtls/schannel.c||lib/vtls/schannel.c": [
          "File: lib/vtls/schannel.c -> lib/vtls/schannel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "413:   return CURLE_OK;",
          "414: }",
          "415: #endif",
          "417: static CURLcode",
          "418: schannel_connect_step1(struct Curl_easy *data, struct connectdata *conn,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "416: static CURLcode",
          "417: schannel_acquire_credential_handle(struct Curl_easy *data,",
          "418:                                    struct connectdata *conn,",
          "419:                                    int sockindex)",
          "420: {",
          "421:   struct ssl_connect_data *connssl = &conn->ssl[sockindex];",
          "422:   SCHANNEL_CRED schannel_cred;",
          "423:   PCCERT_CONTEXT client_certs[1] = { NULL };",
          "424:   SECURITY_STATUS sspi_status = SEC_E_OK;",
          "425:   CURLcode result;",
          "428:   memset(&schannel_cred, 0, sizeof(schannel_cred));",
          "429:   schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;",
          "431:   if(conn->ssl_config.verifypeer) {",
          "432: #ifdef HAS_MANUAL_VERIFY_API",
          "433:     if(BACKEND->use_manual_cred_validation)",
          "434:       schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;",
          "435:     else",
          "436: #endif",
          "437:       schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;",
          "439:     if(SSL_SET_OPTION(no_revoke)) {",
          "440:       schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |",
          "441:         SCH_CRED_IGNORE_REVOCATION_OFFLINE;",
          "443:       DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"",
          "444:                    \"checks\\n\"));",
          "445:     }",
          "446:     else if(SSL_SET_OPTION(revoke_best_effort)) {",
          "447:       schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |",
          "448:         SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;",
          "450:       DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));",
          "451:     }",
          "452:     else {",
          "453:       schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;",
          "455:       DEBUGF(infof(data,",
          "456:                    \"schannel: checking server certificate revocation\\n\"));",
          "457:     }",
          "458:   }",
          "459:   else {",
          "460:     schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |",
          "461:       SCH_CRED_IGNORE_NO_REVOCATION_CHECK |",
          "462:       SCH_CRED_IGNORE_REVOCATION_OFFLINE;",
          "463:     DEBUGF(infof(data,",
          "464:                  \"schannel: disabled server cert revocation checks\\n\"));",
          "465:   }",
          "467:   if(!conn->ssl_config.verifyhost) {",
          "468:     schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;",
          "469:     DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"",
          "470:                  \"comparing the supplied target name with the subject \"",
          "471:                  \"names in server certificates.\\n\"));",
          "472:   }",
          "474:   if(!SSL_SET_OPTION(auto_client_cert)) {",
          "475:     schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;",
          "476:     schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;",
          "477:     infof(data, \"schannel: disabled automatic use of client certificate\\n\");",
          "478:   }",
          "479:   else",
          "480:     infof(data, \"schannel: enabled automatic use of client certificate\\n\");",
          "482:   switch(conn->ssl_config.version) {",
          "483:   case CURL_SSLVERSION_DEFAULT:",
          "484:   case CURL_SSLVERSION_TLSv1:",
          "485:   case CURL_SSLVERSION_TLSv1_0:",
          "486:   case CURL_SSLVERSION_TLSv1_1:",
          "487:   case CURL_SSLVERSION_TLSv1_2:",
          "488:   case CURL_SSLVERSION_TLSv1_3:",
          "489:   {",
          "490:     result = set_ssl_version_min_max(&schannel_cred, data, conn);",
          "491:     if(result != CURLE_OK)",
          "492:       return result;",
          "493:     break;",
          "494:   }",
          "495:   case CURL_SSLVERSION_SSLv3:",
          "496:   case CURL_SSLVERSION_SSLv2:",
          "497:     failf(data, \"SSL versions not supported\");",
          "498:     return CURLE_NOT_BUILT_IN;",
          "499:   default:",
          "500:     failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");",
          "501:     return CURLE_SSL_CONNECT_ERROR;",
          "502:   }",
          "504:   if(SSL_CONN_CONFIG(cipher_list)) {",
          "505:     result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),",
          "506:                              BACKEND->algIds);",
          "507:     if(CURLE_OK != result) {",
          "508:       failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");",
          "509:       return result;",
          "510:     }",
          "511:   }",
          "514: #ifdef HAS_CLIENT_CERT_PATH",
          "516:   if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {",
          "517:     DWORD cert_store_name = 0;",
          "518:     TCHAR *cert_store_path = NULL;",
          "519:     TCHAR *cert_thumbprint_str = NULL;",
          "520:     CRYPT_HASH_BLOB cert_thumbprint;",
          "521:     BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];",
          "522:     HCERTSTORE cert_store = NULL;",
          "523:     FILE *fInCert = NULL;",
          "524:     void *certdata = NULL;",
          "525:     size_t certsize = 0;",
          "526:     bool blob = data->set.ssl.primary.cert_blob != NULL;",
          "527:     TCHAR *cert_path = NULL;",
          "528:     if(blob) {",
          "529:       certdata = data->set.ssl.primary.cert_blob->data;",
          "530:       certsize = data->set.ssl.primary.cert_blob->len;",
          "531:     }",
          "532:     else {",
          "533:       cert_path = curlx_convert_UTF8_to_tchar(",
          "534:         data->set.ssl.primary.clientcert);",
          "535:       if(!cert_path)",
          "536:         return CURLE_OUT_OF_MEMORY;",
          "538:       result = get_cert_location(cert_path, &cert_store_name,",
          "539:         &cert_store_path, &cert_thumbprint_str);",
          "541:       if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))",
          "542:         fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");",
          "544:       if(result && !fInCert) {",
          "545:         failf(data, \"schannel: Failed to get certificate location\"",
          "546:               \" or file for %s\",",
          "547:               data->set.ssl.primary.clientcert);",
          "548:         curlx_unicodefree(cert_path);",
          "549:         return result;",
          "550:       }",
          "551:     }",
          "553:     if((fInCert || blob) && (data->set.ssl.cert_type) &&",
          "554:         (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {",
          "555:       failf(data, \"schannel: certificate format compatibility error \"",
          "556:               \" for %s\",",
          "557:               blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);",
          "558:       curlx_unicodefree(cert_path);",
          "559:       return CURLE_SSL_CERTPROBLEM;",
          "560:     }",
          "562:     if(fInCert || blob) {",
          "564:            https://social.msdn.microsoft.com/Forums/windowsdesktop/",
          "565:                           en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5",
          "567:       CRYPT_DATA_BLOB datablob;",
          "568:       WCHAR* pszPassword;",
          "569:       size_t pwd_len = 0;",
          "570:       int str_w_len = 0;",
          "571:       const char *cert_showfilename_error = blob ?",
          "572:         \"(memory blob)\" : data->set.ssl.primary.clientcert;",
          "573:       curlx_unicodefree(cert_path);",
          "574:       if(fInCert) {",
          "575:         long cert_tell = 0;",
          "576:         bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;",
          "577:         if(continue_reading)",
          "578:           cert_tell = ftell(fInCert);",
          "579:         if(cert_tell < 0)",
          "580:           continue_reading = FALSE;",
          "581:         else",
          "582:           certsize = (size_t)cert_tell;",
          "583:         if(continue_reading)",
          "584:           continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;",
          "585:         if(continue_reading)",
          "586:           certdata = malloc(certsize + 1);",
          "587:         if((!certdata) ||",
          "588:            ((int) fread(certdata, certsize, 1, fInCert) != 1))",
          "589:           continue_reading = FALSE;",
          "590:         fclose(fInCert);",
          "591:         if(!continue_reading) {",
          "592:           failf(data, \"schannel: Failed to read cert file %s\",",
          "593:               data->set.ssl.primary.clientcert);",
          "594:           free(certdata);",
          "595:           return CURLE_SSL_CERTPROBLEM;",
          "596:         }",
          "597:       }",
          "600:       datablob.pbData = (BYTE*)certdata;",
          "601:       datablob.cbData = (DWORD)certsize;",
          "603:       if(data->set.ssl.key_passwd != NULL)",
          "604:         pwd_len = strlen(data->set.ssl.key_passwd);",
          "605:       pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));",
          "606:       if(pszPassword) {",
          "607:         if(pwd_len > 0)",
          "608:           str_w_len = MultiByteToWideChar(CP_UTF8,",
          "609:              MB_ERR_INVALID_CHARS,",
          "610:              data->set.ssl.key_passwd, (int)pwd_len,",
          "611:              pszPassword, (int)(pwd_len + 1));",
          "613:         if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))",
          "614:           pszPassword[str_w_len] = 0;",
          "615:         else",
          "616:           pszPassword[0] = 0;",
          "618:         cert_store = PFXImportCertStore(&datablob, pszPassword, 0);",
          "619:         free(pszPassword);",
          "620:       }",
          "621:       if(!blob)",
          "622:         free(certdata);",
          "623:       if(!cert_store) {",
          "624:         DWORD errorcode = GetLastError();",
          "625:         if(errorcode == ERROR_INVALID_PASSWORD)",
          "626:           failf(data, \"schannel: Failed to import cert file %s, \"",
          "627:                 \"password is bad\",",
          "628:                 cert_showfilename_error);",
          "629:         else",
          "630:           failf(data, \"schannel: Failed to import cert file %s, \"",
          "631:                 \"last error is 0x%x\",",
          "632:                 cert_showfilename_error, errorcode);",
          "633:         return CURLE_SSL_CERTPROBLEM;",
          "634:       }",
          "636:       client_certs[0] = CertFindCertificateInStore(",
          "637:         cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,",
          "638:         CERT_FIND_ANY, NULL, NULL);",
          "640:       if(!client_certs[0]) {",
          "641:         failf(data, \"schannel: Failed to get certificate from file %s\"",
          "642:               \", last error is 0x%x\",",
          "643:               cert_showfilename_error, GetLastError());",
          "644:         CertCloseStore(cert_store, 0);",
          "645:         return CURLE_SSL_CERTPROBLEM;",
          "646:       }",
          "648:       schannel_cred.cCreds = 1;",
          "649:       schannel_cred.paCred = client_certs;",
          "650:     }",
          "651:     else {",
          "652:       cert_store =",
          "653:         CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,",
          "654:                       (HCRYPTPROV)NULL,",
          "655:                       CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,",
          "656:                       cert_store_path);",
          "657:       if(!cert_store) {",
          "658:         failf(data, \"schannel: Failed to open cert store %x %s, \"",
          "659:               \"last error is 0x%x\",",
          "660:               cert_store_name, cert_store_path, GetLastError());",
          "661:         free(cert_store_path);",
          "662:         curlx_unicodefree(cert_path);",
          "663:         return CURLE_SSL_CERTPROBLEM;",
          "664:       }",
          "665:       free(cert_store_path);",
          "667:       cert_thumbprint.pbData = cert_thumbprint_data;",
          "668:       cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;",
          "670:       if(!CryptStringToBinary(cert_thumbprint_str,",
          "671:                               CERT_THUMBPRINT_STR_LEN,",
          "672:                               CRYPT_STRING_HEX,",
          "673:                               cert_thumbprint_data,",
          "674:                               &cert_thumbprint.cbData,",
          "675:                               NULL, NULL)) {",
          "676:         curlx_unicodefree(cert_path);",
          "677:         CertCloseStore(cert_store, 0);",
          "678:         return CURLE_SSL_CERTPROBLEM;",
          "679:       }",
          "681:       client_certs[0] = CertFindCertificateInStore(",
          "682:         cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,",
          "683:         CERT_FIND_HASH, &cert_thumbprint, NULL);",
          "685:       curlx_unicodefree(cert_path);",
          "687:       if(client_certs[0]) {",
          "688:         schannel_cred.cCreds = 1;",
          "689:         schannel_cred.paCred = client_certs;",
          "690:       }",
          "691:       else {",
          "693:         CertCloseStore(cert_store, 0);",
          "694:         return CURLE_SSL_CERTPROBLEM;",
          "695:       }",
          "696:     }",
          "697:     CertCloseStore(cert_store, 0);",
          "698:   }",
          "699: #else",
          "700:   if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {",
          "701:     failf(data, \"schannel: client cert support not built in\");",
          "702:     return CURLE_NOT_BUILT_IN;",
          "703:   }",
          "704: #endif",
          "707:   BACKEND->cred = (struct Curl_schannel_cred *)",
          "708:     calloc(1, sizeof(struct Curl_schannel_cred));",
          "709:   if(!BACKEND->cred) {",
          "710:     failf(data, \"schannel: unable to allocate memory\");",
          "712:     if(client_certs[0])",
          "713:       CertFreeCertificateContext(client_certs[0]);",
          "715:     return CURLE_OUT_OF_MEMORY;",
          "716:   }",
          "717:   BACKEND->cred->refcount = 1;",
          "721:   sspi_status =",
          "722:     s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,",
          "723:                                        SECPKG_CRED_OUTBOUND, NULL,",
          "724:                                        &schannel_cred, NULL, NULL,",
          "725:                                        &BACKEND->cred->cred_handle,",
          "726:                                        &BACKEND->cred->time_stamp);",
          "728:   if(client_certs[0])",
          "729:     CertFreeCertificateContext(client_certs[0]);",
          "731:   if(sspi_status != SEC_E_OK) {",
          "732:     char buffer[STRERROR_LEN];",
          "733:     failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",",
          "734:           Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));",
          "735:     Curl_safefree(BACKEND->cred);",
          "736:     switch(sspi_status) {",
          "737:     case SEC_E_INSUFFICIENT_MEMORY:",
          "738:       return CURLE_OUT_OF_MEMORY;",
          "739:     case SEC_E_NO_CREDENTIALS:",
          "740:     case SEC_E_SECPKG_NOT_FOUND:",
          "741:     case SEC_E_NOT_OWNER:",
          "742:     case SEC_E_UNKNOWN_CREDENTIALS:",
          "743:     case SEC_E_INTERNAL_ERROR:",
          "744:     default:",
          "745:       return CURLE_SSL_CONNECT_ERROR;",
          "746:     }",
          "747:   }",
          "749:   return CURLE_OK;",
          "750: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "427: #ifdef HAS_ALPN",
          "428:   unsigned char alpn_buffer[128];",
          "429: #endif",
          "432:   SECURITY_STATUS sspi_status = SEC_E_OK;",
          "433:   struct Curl_schannel_cred *old_cred = NULL;",
          "434:   struct in_addr addr;",
          "",
          "[Removed Lines]",
          "430:   SCHANNEL_CRED schannel_cred;",
          "431:   PCCERT_CONTEXT client_certs[1] = { NULL };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "515:   }",
          "517:   if(!BACKEND->cred) {",
          "838:     }",
          "839:   }",
          "",
          "[Removed Lines]",
          "519:     memset(&schannel_cred, 0, sizeof(schannel_cred));",
          "520:     schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;",
          "522:     if(conn->ssl_config.verifypeer) {",
          "523: #ifdef HAS_MANUAL_VERIFY_API",
          "524:       if(BACKEND->use_manual_cred_validation)",
          "525:         schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;",
          "526:       else",
          "527: #endif",
          "528:         schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;",
          "530:       if(SSL_SET_OPTION(no_revoke)) {",
          "531:         schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |",
          "532:           SCH_CRED_IGNORE_REVOCATION_OFFLINE;",
          "534:         DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"",
          "535:                      \"checks\\n\"));",
          "536:       }",
          "537:       else if(SSL_SET_OPTION(revoke_best_effort)) {",
          "538:         schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |",
          "539:           SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;",
          "541:         DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));",
          "542:       }",
          "543:       else {",
          "544:         schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;",
          "546:         DEBUGF(infof(data,",
          "547:                      \"schannel: checking server certificate revocation\\n\"));",
          "548:       }",
          "549:     }",
          "550:     else {",
          "551:       schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |",
          "552:         SCH_CRED_IGNORE_NO_REVOCATION_CHECK |",
          "553:         SCH_CRED_IGNORE_REVOCATION_OFFLINE;",
          "554:       DEBUGF(infof(data,",
          "555:                    \"schannel: disabled server cert revocation checks\\n\"));",
          "556:     }",
          "558:     if(!conn->ssl_config.verifyhost) {",
          "559:       schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;",
          "560:       DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"",
          "561:                    \"comparing the supplied target name with the subject \"",
          "562:                    \"names in server certificates.\\n\"));",
          "563:     }",
          "565:     if(!SSL_SET_OPTION(auto_client_cert)) {",
          "566:       schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;",
          "567:       schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;",
          "568:       infof(data, \"schannel: disabled automatic use of client certificate\\n\");",
          "569:     }",
          "570:     else",
          "571:       infof(data, \"schannel: enabled automatic use of client certificate\\n\");",
          "573:     switch(conn->ssl_config.version) {",
          "574:     case CURL_SSLVERSION_DEFAULT:",
          "575:     case CURL_SSLVERSION_TLSv1:",
          "576:     case CURL_SSLVERSION_TLSv1_0:",
          "577:     case CURL_SSLVERSION_TLSv1_1:",
          "578:     case CURL_SSLVERSION_TLSv1_2:",
          "579:     case CURL_SSLVERSION_TLSv1_3:",
          "580:     {",
          "581:       result = set_ssl_version_min_max(&schannel_cred, data, conn);",
          "582:       if(result != CURLE_OK)",
          "583:         return result;",
          "584:       break;",
          "585:     }",
          "586:     case CURL_SSLVERSION_SSLv3:",
          "587:     case CURL_SSLVERSION_SSLv2:",
          "588:       failf(data, \"SSL versions not supported\");",
          "589:       return CURLE_NOT_BUILT_IN;",
          "590:     default:",
          "591:       failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");",
          "592:       return CURLE_SSL_CONNECT_ERROR;",
          "593:     }",
          "595:     if(SSL_CONN_CONFIG(cipher_list)) {",
          "596:       result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),",
          "597:                                BACKEND->algIds);",
          "598:       if(CURLE_OK != result) {",
          "599:         failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");",
          "600:         return result;",
          "601:       }",
          "602:     }",
          "605: #ifdef HAS_CLIENT_CERT_PATH",
          "607:     if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {",
          "608:       DWORD cert_store_name = 0;",
          "609:       TCHAR *cert_store_path = NULL;",
          "610:       TCHAR *cert_thumbprint_str = NULL;",
          "611:       CRYPT_HASH_BLOB cert_thumbprint;",
          "612:       BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];",
          "613:       HCERTSTORE cert_store = NULL;",
          "614:       FILE *fInCert = NULL;",
          "615:       void *certdata = NULL;",
          "616:       size_t certsize = 0;",
          "617:       bool blob = data->set.ssl.primary.cert_blob != NULL;",
          "618:       TCHAR *cert_path = NULL;",
          "619:       if(blob) {",
          "620:         certdata = data->set.ssl.primary.cert_blob->data;",
          "621:         certsize = data->set.ssl.primary.cert_blob->len;",
          "622:       }",
          "623:       else {",
          "624:         cert_path = curlx_convert_UTF8_to_tchar(",
          "625:           data->set.ssl.primary.clientcert);",
          "626:         if(!cert_path)",
          "627:           return CURLE_OUT_OF_MEMORY;",
          "629:         result = get_cert_location(cert_path, &cert_store_name,",
          "630:           &cert_store_path, &cert_thumbprint_str);",
          "632:         if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))",
          "633:           fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");",
          "635:         if(result && !fInCert) {",
          "636:           failf(data, \"schannel: Failed to get certificate location\"",
          "637:                 \" or file for %s\",",
          "638:                 data->set.ssl.primary.clientcert);",
          "639:           curlx_unicodefree(cert_path);",
          "640:           return result;",
          "641:         }",
          "642:       }",
          "644:       if((fInCert || blob) && (data->set.ssl.cert_type) &&",
          "645:           (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {",
          "646:         failf(data, \"schannel: certificate format compatibility error \"",
          "647:                 \" for %s\",",
          "648:                 blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);",
          "649:         curlx_unicodefree(cert_path);",
          "650:         return CURLE_SSL_CERTPROBLEM;",
          "651:       }",
          "653:       if(fInCert || blob) {",
          "655:              https://social.msdn.microsoft.com/Forums/windowsdesktop/",
          "656:                             en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5",
          "658:         CRYPT_DATA_BLOB datablob;",
          "659:         WCHAR* pszPassword;",
          "660:         size_t pwd_len = 0;",
          "661:         int str_w_len = 0;",
          "662:         const char *cert_showfilename_error = blob ?",
          "663:           \"(memory blob)\" : data->set.ssl.primary.clientcert;",
          "664:         curlx_unicodefree(cert_path);",
          "665:         if(fInCert) {",
          "666:           long cert_tell = 0;",
          "667:           bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;",
          "668:           if(continue_reading)",
          "669:             cert_tell = ftell(fInCert);",
          "670:           if(cert_tell < 0)",
          "671:             continue_reading = FALSE;",
          "672:           else",
          "673:             certsize = (size_t)cert_tell;",
          "674:           if(continue_reading)",
          "675:             continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;",
          "676:           if(continue_reading)",
          "677:             certdata = malloc(certsize + 1);",
          "678:           if((!certdata) ||",
          "679:              ((int) fread(certdata, certsize, 1, fInCert) != 1))",
          "680:             continue_reading = FALSE;",
          "681:           fclose(fInCert);",
          "682:           if(!continue_reading) {",
          "683:             failf(data, \"schannel: Failed to read cert file %s\",",
          "684:                 data->set.ssl.primary.clientcert);",
          "685:             free(certdata);",
          "686:             return CURLE_SSL_CERTPROBLEM;",
          "687:           }",
          "688:         }",
          "691:         datablob.pbData = (BYTE*)certdata;",
          "692:         datablob.cbData = (DWORD)certsize;",
          "694:         if(data->set.ssl.key_passwd != NULL)",
          "695:           pwd_len = strlen(data->set.ssl.key_passwd);",
          "696:         pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));",
          "697:         if(pszPassword) {",
          "698:           if(pwd_len > 0)",
          "699:             str_w_len = MultiByteToWideChar(CP_UTF8,",
          "700:                MB_ERR_INVALID_CHARS,",
          "701:                data->set.ssl.key_passwd, (int)pwd_len,",
          "702:                pszPassword, (int)(pwd_len + 1));",
          "704:           if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))",
          "705:             pszPassword[str_w_len] = 0;",
          "706:           else",
          "707:             pszPassword[0] = 0;",
          "709:           cert_store = PFXImportCertStore(&datablob, pszPassword, 0);",
          "710:           free(pszPassword);",
          "711:         }",
          "712:         if(!blob)",
          "713:           free(certdata);",
          "714:         if(!cert_store) {",
          "715:           DWORD errorcode = GetLastError();",
          "716:           if(errorcode == ERROR_INVALID_PASSWORD)",
          "717:             failf(data, \"schannel: Failed to import cert file %s, \"",
          "718:                   \"password is bad\",",
          "719:                   cert_showfilename_error);",
          "720:           else",
          "721:             failf(data, \"schannel: Failed to import cert file %s, \"",
          "722:                   \"last error is 0x%x\",",
          "723:                   cert_showfilename_error, errorcode);",
          "724:           return CURLE_SSL_CERTPROBLEM;",
          "725:         }",
          "727:         client_certs[0] = CertFindCertificateInStore(",
          "728:           cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,",
          "729:           CERT_FIND_ANY, NULL, NULL);",
          "731:         if(!client_certs[0]) {",
          "732:           failf(data, \"schannel: Failed to get certificate from file %s\"",
          "733:                 \", last error is 0x%x\",",
          "734:                 cert_showfilename_error, GetLastError());",
          "735:           CertCloseStore(cert_store, 0);",
          "736:           return CURLE_SSL_CERTPROBLEM;",
          "737:         }",
          "739:         schannel_cred.cCreds = 1;",
          "740:         schannel_cred.paCred = client_certs;",
          "741:       }",
          "742:       else {",
          "743:         cert_store =",
          "744:           CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,",
          "745:                         (HCRYPTPROV)NULL,",
          "746:                         CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,",
          "747:                         cert_store_path);",
          "748:         if(!cert_store) {",
          "749:           failf(data, \"schannel: Failed to open cert store %x %s, \"",
          "750:                 \"last error is 0x%x\",",
          "751:                 cert_store_name, cert_store_path, GetLastError());",
          "752:           free(cert_store_path);",
          "753:           curlx_unicodefree(cert_path);",
          "754:           return CURLE_SSL_CERTPROBLEM;",
          "755:         }",
          "756:         free(cert_store_path);",
          "758:         cert_thumbprint.pbData = cert_thumbprint_data;",
          "759:         cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;",
          "761:         if(!CryptStringToBinary(cert_thumbprint_str,",
          "762:                                 CERT_THUMBPRINT_STR_LEN,",
          "763:                                 CRYPT_STRING_HEX,",
          "764:                                 cert_thumbprint_data,",
          "765:                                 &cert_thumbprint.cbData,",
          "766:                                 NULL, NULL)) {",
          "767:           curlx_unicodefree(cert_path);",
          "768:           CertCloseStore(cert_store, 0);",
          "769:           return CURLE_SSL_CERTPROBLEM;",
          "770:         }",
          "772:         client_certs[0] = CertFindCertificateInStore(",
          "773:           cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,",
          "774:           CERT_FIND_HASH, &cert_thumbprint, NULL);",
          "776:         curlx_unicodefree(cert_path);",
          "778:         if(client_certs[0]) {",
          "779:           schannel_cred.cCreds = 1;",
          "780:           schannel_cred.paCred = client_certs;",
          "781:         }",
          "782:         else {",
          "784:           CertCloseStore(cert_store, 0);",
          "785:           return CURLE_SSL_CERTPROBLEM;",
          "786:         }",
          "787:       }",
          "788:       CertCloseStore(cert_store, 0);",
          "789:     }",
          "790: #else",
          "791:     if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {",
          "792:       failf(data, \"schannel: client cert support not built in\");",
          "793:       return CURLE_NOT_BUILT_IN;",
          "794:     }",
          "795: #endif",
          "798:     BACKEND->cred = (struct Curl_schannel_cred *)",
          "799:       calloc(1, sizeof(struct Curl_schannel_cred));",
          "800:     if(!BACKEND->cred) {",
          "801:       failf(data, \"schannel: unable to allocate memory\");",
          "803:       if(client_certs[0])",
          "804:         CertFreeCertificateContext(client_certs[0]);",
          "806:       return CURLE_OUT_OF_MEMORY;",
          "807:     }",
          "808:     BACKEND->cred->refcount = 1;",
          "812:     sspi_status =",
          "813:       s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,",
          "814:                                          SECPKG_CRED_OUTBOUND, NULL,",
          "815:                                          &schannel_cred, NULL, NULL,",
          "816:                                          &BACKEND->cred->cred_handle,",
          "817:                                          &BACKEND->cred->time_stamp);",
          "819:     if(client_certs[0])",
          "820:       CertFreeCertificateContext(client_certs[0]);",
          "822:     if(sspi_status != SEC_E_OK) {",
          "823:       char buffer[STRERROR_LEN];",
          "824:       failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",",
          "825:             Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));",
          "826:       Curl_safefree(BACKEND->cred);",
          "827:       switch(sspi_status) {",
          "828:       case SEC_E_INSUFFICIENT_MEMORY:",
          "829:         return CURLE_OUT_OF_MEMORY;",
          "830:       case SEC_E_NO_CREDENTIALS:",
          "831:       case SEC_E_SECPKG_NOT_FOUND:",
          "832:       case SEC_E_NOT_OWNER:",
          "833:       case SEC_E_UNKNOWN_CREDENTIALS:",
          "834:       case SEC_E_INTERNAL_ERROR:",
          "835:       default:",
          "836:         return CURLE_SSL_CONNECT_ERROR;",
          "837:       }",
          "",
          "[Added Lines]",
          "851:     result = schannel_acquire_credential_handle(data, conn, sockindex);",
          "852:     if(result != CURLE_OK) {",
          "853:       return result;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df957e1003da9af9244b563a05bcca8892d6b29c",
      "candidate_info": {
        "commit_hash": "df957e1003da9af9244b563a05bcca8892d6b29c",
        "repo": "curl/curl",
        "commit_url": "https://github.com/curl/curl/commit/df957e1003da9af9244b563a05bcca8892d6b29c",
        "files": [
          "lib/vtls/schannel.c",
          "lib/vtls/schannel.h"
        ],
        "message": "schannel: move the algIds array out of schannel.h\n\nThis array is only used by the SCHANNEL_CRED struct in the\nschannel_acquire_credential_handle function. It can therefore be kept as\na local variable. This is a minor update to\nbbb71507b7bab52002f9b1e0880bed6a32834511.\n\nThis change also updates the NUM_CIPHERS value to accurately count the\nnumber of ciphers options listed in schannel.c, which is 47 instead of\n45. It is unlikely that anyone tries to set all 47 values, but if they\nhad tried, the last two would not have been set.\n\nCloses #8469",
        "before_after_code_files": [
          "lib/vtls/schannel.c||lib/vtls/schannel.c",
          "lib/vtls/schannel.h||lib/vtls/schannel.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/vtls/schannel.c||lib/vtls/schannel.c",
            "lib/vtls/schannel.h||lib/vtls/schannel.h"
          ],
          "candidate": [
            "lib/vtls/schannel.c||lib/vtls/schannel.c",
            "lib/vtls/schannel.h||lib/vtls/schannel.h"
          ]
        }
      },
      "candidate_diff": {
        "lib/vtls/schannel.c||lib/vtls/schannel.c": [
          "File: lib/vtls/schannel.c -> lib/vtls/schannel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "325:   return 0;",
          "326: }",
          "328: static CURLcode",
          "329: set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,",
          "330:                 ALG_ID *algIds)",
          "331: {",
          "332:   char *startCur = ciphers;",
          "333:   int algCount = 0;",
          "335:     long alg = strtol(startCur, 0, 0);",
          "336:     if(!alg)",
          "337:       alg = get_alg_id_by_name(startCur);",
          "",
          "[Removed Lines]",
          "334:   while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {",
          "",
          "[Added Lines]",
          "336:   while(startCur && (0 != *startCur) && (algCount < NUM_CIPHERS)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "418: {",
          "419:   struct ssl_connect_data *connssl = &conn->ssl[sockindex];",
          "420:   SCHANNEL_CRED schannel_cred;",
          "421:   PCCERT_CONTEXT client_certs[1] = { NULL };",
          "422:   SECURITY_STATUS sspi_status = SEC_E_OK;",
          "423:   CURLcode result;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "423:   ALG_ID algIds[NUM_CIPHERS];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "503:   if(SSL_CONN_CONFIG(cipher_list)) {",
          "504:     result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),",
          "506:     if(CURLE_OK != result) {",
          "507:       failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");",
          "508:       return result;",
          "",
          "[Removed Lines]",
          "505:                              backend->algIds);",
          "",
          "[Added Lines]",
          "508:                              algIds);",
          "",
          "---------------"
        ],
        "lib/vtls/schannel.h||lib/vtls/schannel.h": [
          "File: lib/vtls/schannel.h -> lib/vtls/schannel.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "105: #ifdef HAS_MANUAL_VERIFY_API",
          "107: #endif",
          "109: };",
          "",
          "[Removed Lines]",
          "108:   ALG_ID algIds[NUMOF_CIPHERS];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f4a9a9b2a49547eae24d2e19bc5c346e9026479",
      "candidate_info": {
        "commit_hash": "7f4a9a9b2a49547eae24d2e19bc5c346e9026479",
        "repo": "curl/curl",
        "commit_url": "https://github.com/curl/curl/commit/7f4a9a9b2a49547eae24d2e19bc5c346e9026479",
        "files": [
          "lib/multi.c",
          "lib/vtls/gskit.c",
          "lib/vtls/gtls.c",
          "lib/vtls/mbedtls.c",
          "lib/vtls/mesalink.c",
          "lib/vtls/nss.c",
          "lib/vtls/openssl.c",
          "lib/vtls/rustls.c",
          "lib/vtls/schannel.c",
          "lib/vtls/sectransp.c",
          "lib/vtls/vtls.c",
          "lib/vtls/vtls.h",
          "lib/vtls/wolfssl.c"
        ],
        "message": "openssl: associate/detach the transfer from connection\n\nCVE-2021-22901\n\nBug: https://curl.se/docs/CVE-2021-22901.html",
        "before_after_code_files": [
          "lib/multi.c||lib/multi.c",
          "lib/vtls/gskit.c||lib/vtls/gskit.c",
          "lib/vtls/gtls.c||lib/vtls/gtls.c",
          "lib/vtls/mbedtls.c||lib/vtls/mbedtls.c",
          "lib/vtls/mesalink.c||lib/vtls/mesalink.c",
          "lib/vtls/nss.c||lib/vtls/nss.c",
          "lib/vtls/openssl.c||lib/vtls/openssl.c",
          "lib/vtls/rustls.c||lib/vtls/rustls.c",
          "lib/vtls/schannel.c||lib/vtls/schannel.c",
          "lib/vtls/sectransp.c||lib/vtls/sectransp.c",
          "lib/vtls/vtls.c||lib/vtls/vtls.c",
          "lib/vtls/vtls.h||lib/vtls/vtls.h",
          "lib/vtls/wolfssl.c||lib/vtls/wolfssl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/vtls/schannel.c||lib/vtls/schannel.c"
          ],
          "candidate": [
            "lib/vtls/schannel.c||lib/vtls/schannel.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/multi.c||lib/multi.c": [
          "File: lib/multi.c -> lib/multi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "878: void Curl_detach_connnection(struct Curl_easy *data)",
          "879: {",
          "880:   struct connectdata *conn = data->conn;",
          "882:     Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);",
          "883:   data->conn = NULL;",
          "884: }",
          "",
          "[Removed Lines]",
          "881:   if(conn)",
          "",
          "[Added Lines]",
          "881:   if(conn) {",
          "883:     Curl_ssl_detach_conn(data, conn);",
          "884:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "898:                          &data->conn_queue);",
          "899:   if(conn->handler->attach)",
          "900:     conn->handler->attach(data, conn);",
          "901: }",
          "903: static int waitconnect_getsock(struct connectdata *conn,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "903:   Curl_ssl_associate_conn(data, conn);",
          "",
          "---------------"
        ],
        "lib/vtls/gskit.c||lib/vtls/gskit.c": [
          "File: lib/vtls/gskit.c -> lib/vtls/gskit.c"
        ],
        "lib/vtls/gtls.c||lib/vtls/gtls.c": [
          "File: lib/vtls/gtls.c -> lib/vtls/gtls.c"
        ],
        "lib/vtls/mbedtls.c||lib/vtls/mbedtls.c": [
          "File: lib/vtls/mbedtls.c -> lib/vtls/mbedtls.c"
        ],
        "lib/vtls/mesalink.c||lib/vtls/mesalink.c": [
          "File: lib/vtls/mesalink.c -> lib/vtls/mesalink.c"
        ],
        "lib/vtls/nss.c||lib/vtls/nss.c": [
          "File: lib/vtls/nss.c -> lib/vtls/nss.c"
        ],
        "lib/vtls/openssl.c||lib/vtls/openssl.c": [
          "File: lib/vtls/openssl.c -> lib/vtls/openssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "240: #endif",
          "241: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243: static void ossl_associate_connection(struct Curl_easy *data,",
          "244:                                       struct connectdata *conn,",
          "245:                                       int sockindex);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2581:   curl_socket_t sockfd = conn->sock[sockindex];",
          "2582:   struct ssl_connect_data *connssl = &conn->ssl[sockindex];",
          "2583:   ctx_option_t ctx_options = 0;",
          "2585: #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME",
          "2586:   bool sni;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2588:   void *ssl_sessionid = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3225:   }",
          "3226: #endif",
          "3265:     }",
          "3267:   }",
          "3269: #ifndef CURL_DISABLE_PROXY",
          "3270:   if(conn->proxy_ssl[sockindex].use) {",
          "",
          "[Removed Lines]",
          "3229:   if(SSL_SET_OPTION(primary.sessionid)) {",
          "3230:     void *ssl_sessionid = NULL;",
          "3231:     int data_idx = ossl_get_ssl_data_index();",
          "3232:     int connectdata_idx = ossl_get_ssl_conn_index();",
          "3233:     int sockindex_idx = ossl_get_ssl_sockindex_index();",
          "3234:     int proxy_idx = ossl_get_proxy_index();",
          "3236:     if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&",
          "3237:        proxy_idx >= 0) {",
          "3240:       SSL_set_ex_data(backend->handle, data_idx, data);",
          "3241:       SSL_set_ex_data(backend->handle, connectdata_idx, conn);",
          "3242:       SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);",
          "3243: #ifndef CURL_DISABLE_PROXY",
          "3244:       SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:",
          "3245:                       NULL);",
          "3246: #else",
          "3247:       SSL_set_ex_data(backend->handle, proxy_idx, NULL);",
          "3248: #endif",
          "3250:     }",
          "3252:     Curl_ssl_sessionid_lock(data);",
          "3253:     if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,",
          "3254:                               &ssl_sessionid, NULL, sockindex)) {",
          "3256:       if(!SSL_set_session(backend->handle, ssl_sessionid)) {",
          "3257:         Curl_ssl_sessionid_unlock(data);",
          "3258:         failf(data, \"SSL: SSL_set_session failed: %s\",",
          "3259:               ossl_strerror(ERR_get_error(), error_buffer,",
          "3260:                             sizeof(error_buffer)));",
          "3261:         return CURLE_SSL_CONNECT_ERROR;",
          "3262:       }",
          "3264:       infof(data, \"SSL re-using session ID\\n\");",
          "3266:     Curl_ssl_sessionid_unlock(data);",
          "",
          "[Added Lines]",
          "3233:   ossl_associate_connection(data, conn, sockindex);",
          "3235:   Curl_ssl_sessionid_lock(data);",
          "3236:   if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,",
          "3237:                             &ssl_sessionid, NULL, sockindex)) {",
          "3239:     if(!SSL_set_session(backend->handle, ssl_sessionid)) {",
          "3240:       Curl_ssl_sessionid_unlock(data);",
          "3241:       failf(data, \"SSL: SSL_set_session failed: %s\",",
          "3242:             ossl_strerror(ERR_get_error(), error_buffer,",
          "3243:                           sizeof(error_buffer)));",
          "3244:       return CURLE_SSL_CONNECT_ERROR;",
          "3247:     infof(data, \"SSL re-using session ID\\n\");",
          "3249:   Curl_ssl_sessionid_unlock(data);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4498:          (void *)backend->ctx : (void *)backend->handle;",
          "4499: }",
          "4501: const struct Curl_ssl Curl_ssl_openssl = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4483: static void ossl_associate_connection(struct Curl_easy *data,",
          "4484:                                       struct connectdata *conn,",
          "4485:                                       int sockindex)",
          "4486: {",
          "4487:   struct ssl_connect_data *connssl = &conn->ssl[sockindex];",
          "4488:   struct ssl_backend_data *backend = connssl->backend;",
          "4491:   if(!backend->handle)",
          "4492:     return;",
          "4494:   if(SSL_SET_OPTION(primary.sessionid)) {",
          "4495:     int data_idx = ossl_get_ssl_data_index();",
          "4496:     int connectdata_idx = ossl_get_ssl_conn_index();",
          "4497:     int sockindex_idx = ossl_get_ssl_sockindex_index();",
          "4498:     int proxy_idx = ossl_get_proxy_index();",
          "4500:     if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&",
          "4501:        proxy_idx >= 0) {",
          "4504:       SSL_set_ex_data(backend->handle, data_idx, data);",
          "4505:       SSL_set_ex_data(backend->handle, connectdata_idx, conn);",
          "4506:       SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);",
          "4507: #ifndef CURL_DISABLE_PROXY",
          "4508:       SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:",
          "4509:                       NULL);",
          "4510: #else",
          "4511:       SSL_set_ex_data(backend->handle, proxy_idx, NULL);",
          "4512: #endif",
          "4513:     }",
          "4514:   }",
          "4515: }",
          "4525: static void ossl_disassociate_connection(struct Curl_easy *data,",
          "4526:                                          int sockindex)",
          "4527: {",
          "4528:   struct connectdata *conn = data->conn;",
          "4529:   struct ssl_connect_data *connssl = &conn->ssl[sockindex];",
          "4530:   struct ssl_backend_data *backend = connssl->backend;",
          "4533:   if(!backend->handle)",
          "4534:     return;",
          "4536:   if(SSL_SET_OPTION(primary.sessionid)) {",
          "4537:     bool isproxy = FALSE;",
          "4538:     bool incache;",
          "4539:     void *old_ssl_sessionid = NULL;",
          "4540:     int data_idx = ossl_get_ssl_data_index();",
          "4541:     int connectdata_idx = ossl_get_ssl_conn_index();",
          "4542:     int sockindex_idx = ossl_get_ssl_sockindex_index();",
          "4543:     int proxy_idx = ossl_get_proxy_index();",
          "4545:     if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&",
          "4546:        proxy_idx >= 0) {",
          "4548:       isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;",
          "4552:       SSL_set_ex_data(backend->handle, data_idx, NULL);",
          "4553:       SSL_set_ex_data(backend->handle, connectdata_idx, NULL);",
          "4554:       SSL_set_ex_data(backend->handle, sockindex_idx, NULL);",
          "4555:       SSL_set_ex_data(backend->handle, proxy_idx, NULL);",
          "4556:     }",
          "4558:     Curl_ssl_sessionid_lock(data);",
          "4559:     incache = !(Curl_ssl_getsessionid(data, conn, isproxy,",
          "4560:                                       &old_ssl_sessionid, NULL, sockindex));",
          "4561:     if(incache)",
          "4562:       Curl_ssl_delsessionid(data, old_ssl_sessionid);",
          "4563:     Curl_ssl_sessionid_unlock(data);",
          "4564:   }",
          "4565: }",
          "",
          "---------------"
        ],
        "lib/vtls/rustls.c||lib/vtls/rustls.c": [
          "File: lib/vtls/rustls.c -> lib/vtls/rustls.c"
        ],
        "lib/vtls/schannel.c||lib/vtls/schannel.c": [
          "File: lib/vtls/schannel.c -> lib/vtls/schannel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "330: static CURLcode",
          "331: set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,",
          "333: {",
          "334:   char *startCur = ciphers;",
          "335:   int algCount = 0;",
          "",
          "[Removed Lines]",
          "332:                 int *algIds)",
          "",
          "[Added Lines]",
          "332:                 ALG_ID *algIds)",
          "",
          "---------------"
        ],
        "lib/vtls/sectransp.c||lib/vtls/sectransp.c": [
          "File: lib/vtls/sectransp.c -> lib/vtls/sectransp.c"
        ],
        "lib/vtls/vtls.c||lib/vtls/vtls.c": [
          "File: lib/vtls/vtls.c -> lib/vtls/vtls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "586:   return CURLE_OK;",
          "587: }",
          "590: void Curl_ssl_close_all(struct Curl_easy *data)",
          "591: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "589: void Curl_ssl_associate_conn(struct Curl_easy *data,",
          "590:                              struct connectdata *conn)",
          "591: {",
          "592:   if(Curl_ssl->associate_connection) {",
          "593:     Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);",
          "594:     if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)",
          "595:       Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);",
          "596:   }",
          "597: }",
          "599: void Curl_ssl_detach_conn(struct Curl_easy *data,",
          "600:                           struct connectdata *conn)",
          "601: {",
          "602:   if(Curl_ssl->disassociate_connection) {",
          "603:     Curl_ssl->disassociate_connection(data, FIRSTSOCKET);",
          "604:     if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)",
          "605:       Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);",
          "606:   }",
          "607: }",
          "",
          "---------------"
        ],
        "lib/vtls/vtls.h||lib/vtls/vtls.h": [
          "File: lib/vtls/vtls.h -> lib/vtls/vtls.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "84:   bool (*false_start)(void);",
          "85:   CURLcode (*sha256sum)(const unsigned char *input, size_t inputlen,",
          "86:                     unsigned char *sha256sum, size_t sha256sumlen);",
          "87: };",
          "89: #ifdef USE_SSL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88:   void (*associate_connection)(struct Curl_easy *data,",
          "89:                                struct connectdata *conn,",
          "90:                                int sockindex);",
          "91:   void (*disassociate_connection)(struct Curl_easy *data, int sockindex);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "284: bool Curl_ssl_false_start(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291: void Curl_ssl_associate_conn(struct Curl_easy *data,",
          "292:                              struct connectdata *conn);",
          "293: void Curl_ssl_detach_conn(struct Curl_easy *data,",
          "294:                           struct connectdata *conn);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "309: #define Curl_ssl_cert_status_request() FALSE",
          "310: #define Curl_ssl_false_start() FALSE",
          "311: #define Curl_ssl_tls13_ciphersuites() FALSE",
          "312: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "322: #define Curl_ssl_associate_conn(a,b) Curl_nop_stmt",
          "323: #define Curl_ssl_detach_conn(a,b) Curl_nop_stmt",
          "",
          "---------------"
        ],
        "lib/vtls/wolfssl.c||lib/vtls/wolfssl.c": [
          "File: lib/vtls/wolfssl.c -> lib/vtls/wolfssl.c"
        ]
      }
    }
  ]
}
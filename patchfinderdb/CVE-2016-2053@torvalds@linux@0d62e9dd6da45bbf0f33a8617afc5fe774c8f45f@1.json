{
  "cve_id": "CVE-2016-2053",
  "cve_desc": "The asn1_ber_decoder function in lib/asn1_decoder.c in the Linux kernel before 4.3 allows attackers to cause a denial of service (panic) via an ASN.1 BER file that lacks a public key, leading to mishandling by the public_key_verify_signature function in crypto/asymmetric_keys/public_key.c.",
  "repo": "torvalds/linux",
  "patch_hash": "0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
  "patch_info": {
    "commit_hash": "0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
    "files": [
      "lib/asn1_decoder.c"
    ],
    "message": "ASN.1: Fix non-match detection failure on data overrun\n\nIf the ASN.1 decoder is asked to parse a sequence of objects, non-optional\nmatches get skipped if there's no more data to be had rather than a\ndata-overrun error being reported.\n\nThis is due to the code segment that decides whether to skip optional\nmatches (ie. matches that could get ignored because an element is marked\nOPTIONAL in the grammar) due to a lack of data also skips non-optional\nelements if the data pointer has reached the end of the buffer.\n\nThis can be tested with the data decoder for the new RSA akcipher algorithm\nthat takes three non-optional integers.  Currently, it skips the last\ninteger if there is insufficient data.\n\nWithout the fix, #defining DEBUG in asn1_decoder.c will show something\nlike:\n\n\tnext_op: pc=0/13 dp=0/270 C=0 J=0\n\t- match? 30 30 00\n\t- TAG: 30 266 CONS\n\tnext_op: pc=2/13 dp=4/270 C=1 J=0\n\t- match? 02 02 00\n\t- TAG: 02 257\n\t- LEAF: 257\n\tnext_op: pc=5/13 dp=265/270 C=1 J=0\n\t- match? 02 02 00\n\t- TAG: 02 3\n\t- LEAF: 3\n\tnext_op: pc=8/13 dp=270/270 C=1 J=0\n\tnext_op: pc=11/13 dp=270/270 C=1 J=0\n\t- end cons t=4 dp=270 l=270/270\n\nThe next_op line for pc=8/13 should be followed by a match line.\n\nThis is not exploitable for X.509 certificates by means of shortening the\nmessage and fixing up the ASN.1 CONS tags because:\n\n (1) The relevant records being built up are cleared before use.\n\n (2) If the message is shortened sufficiently to remove the public key, the\n     ASN.1 parse of the RSA key will fail quickly due to a lack of data.\n\n (3) Extracted signature data is either turned into MPIs (which cope with a\n     0 length) or is simpler integers specifying algoritms and suchlike\n     (which can validly be 0); and\n\n (4) The AKID and SKID extensions are optional and their removal is handled\n     without risking passing a NULL to asymmetric_key_generate_id().\n\n (5) If the certificate is truncated sufficiently to remove the subject,\n     issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons\n     stack underflow' return.\n\nThis is not exploitable for PKCS#7 messages by means of removal of elements\nfrom such a message from the tail end of a sequence:\n\n (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable\n     as detailed above.\n\n (2) The message digest content isn't used if it shows a NULL pointer,\n     similarly, the authattrs aren't used if that shows a NULL pointer.\n\n (3) A missing signature results in a NULL MPI - which the MPI routines deal\n     with.\n\n (4) If data is NULL, it is expected that the message has detached content and\n     that is handled appropriately.\n\n (5) If the serialNumber is excised, the unconditional action associated\n     with it will pick up the containing SEQUENCE instead, so no NULL\n     pointer will be seen here.\n\n     If both the issuer and the serialNumber are excised, the ASN.1 decode\n     will fail with an 'Unexpected tag' return.\n\n     In either case, there's no way to get to asymmetric_key_generate_id()\n     with a NULL pointer.\n\n (6) Other fields are decoded to simple integers.  Shortening the message\n     to omit an algorithm ID field will cause checks on this to fail early\n     in the verification process.\n\n\nThis can also be tested by snipping objects off of the end of the ASN.1 stream\nsuch that mandatory tags are removed - or even from the end of internal\nSEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be\nproduced.  Without this patch ERANGE or ENOPKG might be produced or the parse\nmay apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced\nlater, depending on what gets snipped.\n\nJust snipping off the final BIT_STRING or OCTET_STRING from either sample\nshould be a start since both are mandatory and neither will cause an EBADMSG\nwithout the patches\n\nReported-by: Marcel Holtmann <marcel@holtmann.org>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Marcel Holtmann <marcel@holtmann.org>\nReviewed-by: David Woodhouse <David.Woodhouse@intel.com>",
    "before_after_code_files": [
      "lib/asn1_decoder.c||lib/asn1_decoder.c"
    ]
  },
  "patch_diff": {
    "lib/asn1_decoder.c||lib/asn1_decoder.c": [
      "File: lib/asn1_decoder.c -> lib/asn1_decoder.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "210:   unsigned char tmp;",
      "216:    flags &= ~FLAG_LAST_MATCHED;",
      "217:    pc += asn1_op_lengths[op];",
      "218:    goto next_op;",
      "",
      "[Removed Lines]",
      "213:   if ((op & ASN1_OP_MATCH__COND &&",
      "214:        flags & FLAG_MATCHED) ||",
      "215:       dp == datalen) {",
      "",
      "[Added Lines]",
      "213:   if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||",
      "214:       (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "23dfbbabbb3a62104b040b422121c84800312ad0",
      "candidate_info": {
        "commit_hash": "23dfbbabbb3a62104b040b422121c84800312ad0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/23dfbbabbb3a62104b040b422121c84800312ad0",
        "files": [
          "scripts/sign-file.c"
        ],
        "message": "sign-file: Add option to only create signature file\n\nMake the -d option (which currently isn't actually wired to anything) write\nout the PKCS#7 message as per the -p option and then exit without either\nmodifying the source or writing out a compound file of the source, signature\nand metadata.\n\nThis will be useful when firmware signature support is added\nupstream as firmware will be left intact, and we'll only require\nthe signature file. The descriptor is implicit by file extension\nand the file's own size.\n\nSigned-off-by: Luis R. Rodriguez <mcgrof@suse.com>\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "scripts/sign-file.c||scripts/sign-file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "scripts/sign-file.c||scripts/sign-file.c": [
          "File: scripts/sign-file.c -> scripts/sign-file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:  char *hash_algo = NULL;",
          "87:  char *private_key_name, *x509_name, *module_name, *dest_name;",
          "88:  bool save_pkcs7 = false, replace_orig;",
          "89:  unsigned char buf[4096];",
          "90:  unsigned long module_size, pkcs7_size;",
          "91:  const EVP_MD *digest_algo;",
          "92:  EVP_PKEY *private_key;",
          "93:  PKCS7 *pkcs7;",
          "94:  X509 *x509;",
          "96:  int opt, n;",
          "98:  ERR_load_crypto_strings();",
          "",
          "[Removed Lines]",
          "95:  BIO *b, *bd, *bm;",
          "",
          "[Added Lines]",
          "89:  bool sign_only = false;",
          "96:  BIO *b, *bd = NULL, *bm;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:   opt = getopt(argc, argv, \"dp\");",
          "103:   switch (opt) {",
          "104:   case 'p': save_pkcs7 = true; break;",
          "105:   case -1: break;",
          "106:   default: format();",
          "107:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:   case 'd': sign_only = true; save_pkcs7 = true; break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "155:  OpenSSL_add_all_digests();",
          "",
          "[Removed Lines]",
          "151:  bd = BIO_new_file(dest_name, \"wb\");",
          "152:  ERR(!bd, \"%s\", dest_name);",
          "",
          "[Added Lines]",
          "153:  if (!sign_only) {",
          "154:   bd = BIO_new_file(dest_name, \"wb\");",
          "155:   ERR(!bd, \"%s\", dest_name);",
          "156:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "180:   BIO_free(b);",
          "181:  }",
          "184:  ERR(BIO_reset(bm) < 0, \"%s\", module_name);",
          "185:  while ((n = BIO_read(bm, buf, sizeof(buf))),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187:  if (sign_only)",
          "188:   return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "091f6e26eb326adbd718f406e440c838bed8ebb6",
      "candidate_info": {
        "commit_hash": "091f6e26eb326adbd718f406e440c838bed8ebb6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/091f6e26eb326adbd718f406e440c838bed8ebb6",
        "files": [
          "include/keys/system_keyring.h",
          "init/Kconfig",
          "kernel/module_signing.c",
          "kernel/system_keyring.c"
        ],
        "message": "MODSIGN: Extract the blob PKCS#7 signature verifier from module signing\n\nExtract the function that drives the PKCS#7 signature verification given a\ndata blob and a PKCS#7 blob out from the module signing code and lump it with\nthe system keyring code as it's generic.  This makes it independent of module\nconfig options and opens it to use by the firmware loader.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nCc: Luis R. Rodriguez <mcgrof@suse.com>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nCc: Ming Lei <ming.lei@canonical.com>\nCc: Seth Forshee <seth.forshee@canonical.com>\nCc: Kyle McMartin <kyle@kernel.org>",
        "before_after_code_files": [
          "include/keys/system_keyring.h||include/keys/system_keyring.h",
          "kernel/module_signing.c||kernel/module_signing.c",
          "kernel/system_keyring.c||kernel/system_keyring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/keys/system_keyring.h||include/keys/system_keyring.h": [
          "File: include/keys/system_keyring.h -> include/keys/system_keyring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: }",
          "29: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #ifdef CONFIG_SYSTEM_DATA_VERIFICATION",
          "32: extern int system_verify_data(const void *data, unsigned long len,",
          "33:          const void *raw_pkcs7, size_t pkcs7_len);",
          "34: #endif",
          "",
          "---------------"
        ],
        "kernel/module_signing.c||kernel/module_signing.c": [
          "File: kernel/module_signing.c -> kernel/module_signing.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <linux/kernel.h>",
          "14: #include <keys/system_keyring.h>",
          "15: #include <crypto/public_key.h>",
          "17: #include \"module-internal.h\"",
          "",
          "[Removed Lines]",
          "13: #include <linux/err.h>",
          "16: #include <crypto/pkcs7.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: };",
          "",
          "[Removed Lines]",
          "42: static int mod_verify_pkcs7(const void *mod, unsigned long modlen,",
          "43:        const void *raw_pkcs7, size_t pkcs7_len)",
          "44: {",
          "45:  struct pkcs7_message *pkcs7;",
          "46:  bool trusted;",
          "47:  int ret;",
          "49:  pkcs7 = pkcs7_parse_message(raw_pkcs7, pkcs7_len);",
          "50:  if (IS_ERR(pkcs7))",
          "51:   return PTR_ERR(pkcs7);",
          "54:  if (pkcs7_supply_detached_data(pkcs7, mod, modlen) < 0) {",
          "55:   pr_err(\"PKCS#7 signature with non-detached data\\n\");",
          "56:   ret = -EBADMSG;",
          "57:   goto error;",
          "58:  }",
          "60:  ret = pkcs7_verify(pkcs7);",
          "61:  if (ret < 0)",
          "62:   goto error;",
          "64:  ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);",
          "65:  if (ret < 0)",
          "66:   goto error;",
          "68:  if (!trusted) {",
          "69:   pr_err(\"PKCS#7 signature not signed with a trusted key\\n\");",
          "70:   ret = -ENOKEY;",
          "71:  }",
          "73: error:",
          "74:  pkcs7_free_message(pkcs7);",
          "75:  pr_devel(\"<==%s() = %d\\n\", __func__, ret);",
          "76:  return ret;",
          "77: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "114:   return -EBADMSG;",
          "115:  }",
          "118: }",
          "",
          "[Removed Lines]",
          "117:  return mod_verify_pkcs7(mod, modlen, mod + modlen, sig_len);",
          "",
          "[Added Lines]",
          "75:  return system_verify_data(mod, modlen, mod + modlen, sig_len);",
          "",
          "---------------"
        ],
        "kernel/system_keyring.c||kernel/system_keyring.c": [
          "File: kernel/system_keyring.c -> kernel/system_keyring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include <linux/err.h>",
          "17: #include <keys/asymmetric-type.h>",
          "18: #include <keys/system_keyring.h>",
          "20: struct key *system_trusted_keyring;",
          "21: EXPORT_SYMBOL_GPL(system_trusted_keyring);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <crypto/pkcs7.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "103:  return 0;",
          "104: }",
          "105: late_initcall(load_system_certificate_list);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108: #ifdef CONFIG_SYSTEM_DATA_VERIFICATION",
          "117: int system_verify_data(const void *data, unsigned long len,",
          "118:          const void *raw_pkcs7, size_t pkcs7_len)",
          "119: {",
          "120:  struct pkcs7_message *pkcs7;",
          "121:  bool trusted;",
          "122:  int ret;",
          "124:  pkcs7 = pkcs7_parse_message(raw_pkcs7, pkcs7_len);",
          "125:  if (IS_ERR(pkcs7))",
          "126:   return PTR_ERR(pkcs7);",
          "129:  if (pkcs7_supply_detached_data(pkcs7, data, len) < 0) {",
          "130:   pr_err(\"PKCS#7 signature with non-detached data\\n\");",
          "131:   ret = -EBADMSG;",
          "132:   goto error;",
          "133:  }",
          "135:  ret = pkcs7_verify(pkcs7);",
          "136:  if (ret < 0)",
          "137:   goto error;",
          "139:  ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);",
          "140:  if (ret < 0)",
          "141:   goto error;",
          "143:  if (!trusted) {",
          "144:   pr_err(\"PKCS#7 signature not signed with a trusted key\\n\");",
          "145:   ret = -ENOKEY;",
          "146:  }",
          "148: error:",
          "149:  pkcs7_free_message(pkcs7);",
          "150:  pr_devel(\"<==%s() = %d\\n\", __func__, ret);",
          "151:  return ret;",
          "152: }",
          "153: EXPORT_SYMBOL_GPL(system_verify_data);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3f3af97d8225a58ecdcde7217c030b17e5198226",
      "candidate_info": {
        "commit_hash": "3f3af97d8225a58ecdcde7217c030b17e5198226",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3f3af97d8225a58ecdcde7217c030b17e5198226",
        "files": [
          "include/linux/asn1_ber_bytecode.h",
          "lib/asn1_decoder.c",
          "scripts/asn1_compiler.c"
        ],
        "message": "ASN.1: Fix actions on CHOICE elements with IMPLICIT tags\n\nIn an ASN.1 description where there is a CHOICE construct that contains\nelements with IMPLICIT tags that refer to constructed types, actions to be\ntaken on those elements should be conditional on the corresponding element\nactually being matched.  Currently, however, such actions are performed\nunconditionally in the middle of processing the CHOICE.\n\nFor example, look at elements 'b' and 'e' here:\n\n\tA ::= SEQUENCE {\n\t\t\tCHOICE {\n\t\t\tb [0] IMPLICIT B ({ do_XXXXXXXXXXXX_b }),\n\t\t\tc [1] EXPLICIT C ({ do_XXXXXXXXXXXX_c }),\n\t\t\td [2] EXPLICIT B ({ do_XXXXXXXXXXXX_d }),\n\t\t\te [3] IMPLICIT C ({ do_XXXXXXXXXXXX_e }),\n\t\t\tf [4] IMPLICIT INTEGER ({ do_XXXXXXXXXXXX_f })\n\t\t\t}\n\t\t} ({ do_XXXXXXXXXXXX_A })\n\n\tB ::= SET OF OBJECT IDENTIFIER ({ do_XXXXXXXXXXXX_oid })\n\n\tC ::= SET OF INTEGER ({ do_XXXXXXXXXXXX_int })\n\nThey each have an action (do_XXXXXXXXXXXX_b and do_XXXXXXXXXXXX_e) that\nshould only be processed if that element is matched.\n\nThe problem is that there's no easy place to hang the action off in the\nsubclause (type B for element 'b' and type C for element 'e') because\nsubclause opcode sequences can be shared.\n\nTo fix this, introduce a conditional action opcode(ASN1_OP_MAYBE_ACT) that\nthe decoder only processes if the preceding match was successful.  This can\nbe seen in an excerpt from the output of the fixed ASN.1 compiler for the\nabove ASN.1 description:\n\n\t[  13] =  ASN1_OP_COND_MATCH_JUMP_OR_SKIP,\t\t// e\n\t[  14] =  _tagn(CONT, CONS,  3),\n\t[  15] =  _jump_target(45),\t\t// --> C\n\t[  16] =  ASN1_OP_MAYBE_ACT,\n\t[  17] =  _action(ACT_do_XXXXXXXXXXXX_e),\n\nIn this, if the op at [13] is matched (ie. element 'e' above) then the\naction at [16] will be performed.  However, if the op at [13] doesn't match\nor is skipped because it is conditional and some previous op matched, then\nthe action at [16] will be ignored.\n\nNote that to make this work in the decoder, the ASN1_OP_RETURN op must set\nthe flag to indicate that a match happened.  This is necessary because the\n_jump_target() seen above introduces a subclause (in this case an object of\ntype 'C') which is likely to alter the flag.  Setting the flag here is okay\nbecause to process a subclause, a match must have happened and caused a\njump.\n\nThis cannot be tested with the code as it stands, but rather affects future\ncode.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nReviewed-by: David Woodhouse <David.Woodhouse@intel.com>",
        "before_after_code_files": [
          "include/linux/asn1_ber_bytecode.h||include/linux/asn1_ber_bytecode.h",
          "lib/asn1_decoder.c||lib/asn1_decoder.c",
          "scripts/asn1_compiler.c||scripts/asn1_compiler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/asn1_decoder.c||lib/asn1_decoder.c"
          ],
          "candidate": [
            "lib/asn1_decoder.c||lib/asn1_decoder.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/asn1_ber_bytecode.h||include/linux/asn1_ber_bytecode.h": [
          "File: include/linux/asn1_ber_bytecode.h -> include/linux/asn1_ber_bytecode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  ASN1_OP_COND_FAIL  = 0x1b,",
          "62:  ASN1_OP_COMPLETE  = 0x1c,",
          "63:  ASN1_OP_ACT   = 0x1d,",
          "67:  ASN1_OP_END_SEQ   = 0x20,",
          "",
          "[Removed Lines]",
          "64:  ASN1_OP_RETURN   = 0x1e,",
          "",
          "[Added Lines]",
          "64:  ASN1_OP_MAYBE_ACT  = 0x1e,",
          "65:  ASN1_OP_RETURN   = 0x1f,",
          "",
          "---------------"
        ],
        "lib/asn1_decoder.c||lib/asn1_decoder.c": [
          "File: lib/asn1_decoder.c -> lib/asn1_decoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  [ASN1_OP_COND_FAIL]   = 1,",
          "34:  [ASN1_OP_COMPLETE]   = 1,",
          "35:  [ASN1_OP_ACT]    = 1         + 1,",
          "36:  [ASN1_OP_RETURN]   = 1,",
          "37:  [ASN1_OP_END_SEQ]   = 1,",
          "38:  [ASN1_OP_END_SEQ_OF]   = 1     + 1,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:  [ASN1_OP_MAYBE_ACT]   = 1         + 1,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "211:   if ((op & ASN1_OP_MATCH__COND &&",
          "212:        flags & FLAG_MATCHED) ||",
          "213:       dp == datalen) {",
          "214:    pc += asn1_op_lengths[op];",
          "215:    goto next_op;",
          "216:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216:    flags &= ~FLAG_LAST_MATCHED;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "422:   pc += asn1_op_lengths[op];",
          "423:   goto next_op;",
          "425:  case ASN1_OP_ACT:",
          "426:   ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);",
          "427:   pc += asn1_op_lengths[op];",
          "428:   goto next_op;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "428:  case ASN1_OP_MAYBE_ACT:",
          "429:   if (!(flags & FLAG_LAST_MATCHED)) {",
          "430:    pc += asn1_op_lengths[op];",
          "431:    goto next_op;",
          "432:   }",
          "435:   if (ret < 0)",
          "436:    return ret;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "431:   if (unlikely(jsp <= 0))",
          "432:    goto jump_stack_underflow;",
          "433:   pc = jump_stack[--jsp];",
          "434:   goto next_op;",
          "436:  default:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "444:   flags |= FLAG_MATCHED | FLAG_LAST_MATCHED;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "438:  }",
          "442:  return -EBADMSG;",
          "444: data_overrun_error:",
          "",
          "[Removed Lines]",
          "441:  pr_err(\"ASN.1 decoder error: Found reserved opcode (%u)\\n\", op);",
          "",
          "[Added Lines]",
          "452:  pr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",",
          "453:         op, pc);",
          "",
          "---------------"
        ],
        "scripts/asn1_compiler.c||scripts/asn1_compiler.c": [
          "File: scripts/asn1_compiler.c -> scripts/asn1_compiler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1468:  case TYPE_REF:",
          "1469:   render_element(out, e->type->type->element, tag);",
          "1470:   if (e->action)",
          "1472:   break;",
          "1474:  case SEQUENCE:",
          "",
          "[Removed Lines]",
          "1471:    render_opcode(out, \"ASN1_OP_ACT,\\n\");",
          "",
          "[Added Lines]",
          "1471:    render_opcode(out, \"ASN1_OP_%sACT,\\n\",",
          "1472:           skippable ? \"MAYBE_\" : \"\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
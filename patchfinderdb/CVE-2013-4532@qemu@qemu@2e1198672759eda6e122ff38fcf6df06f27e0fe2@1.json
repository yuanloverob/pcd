{
  "cve_id": "CVE-2013-4532",
  "cve_desc": "Qemu 1.1.2+dfsg to 2.1+dfsg suffers from a buffer overrun which could potentially result in arbitrary code execution on the host with the privileges of the QEMU process.",
  "repo": "qemu/qemu",
  "patch_hash": "2e1198672759eda6e122ff38fcf6df06f27e0fe2",
  "patch_info": {
    "commit_hash": "2e1198672759eda6e122ff38fcf6df06f27e0fe2",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2",
    "files": [
      "hw/net/stellaris_enet.c"
    ],
    "message": "hw/net/stellaris_enet: Convert to vmstate\n\nConvert this device to use vmstate for its save/load, including\nproviding a post_load function that sanitizes inbound data to\navoid possible buffer overflows if it is malicious.\n\nThe sanitizing fixes CVE-2013-4532 (though nobody should be\nrelying on the security properties of most of the unmaintained\nARM board models anyway, and migration doesn't actually\nwork on this board due to issues in other device models).\n\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>",
    "before_after_code_files": [
      "hw/net/stellaris_enet.c||hw/net/stellaris_enet.c"
    ]
  },
  "patch_diff": {
    "hw/net/stellaris_enet.c||hw/net/stellaris_enet.c": [
      "File: hw/net/stellaris_enet.c -> hw/net/stellaris_enet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "46: #define STELLARIS_ENET(obj) \\",
      "47:     OBJECT_CHECK(stellaris_enet_state, (obj), TYPE_STELLARIS_ENET)",
      "49: typedef struct {",
      "50:     SysBusDevice parent_obj;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "49: typedef struct {",
      "50:     uint8_t data[2048];",
      "51:     uint32_t len;",
      "52: } StellarisEnetRxFrame;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "59:     uint32_t mtxd;",
      "60:     uint32_t mrxd;",
      "61:     uint32_t np;",
      "63:     uint8_t tx_fifo[2048];",
      "72:     NICState *nic;",
      "73:     NICConf conf;",
      "74:     qemu_irq irq;",
      "75:     MemoryRegion mmio;",
      "76: } stellaris_enet_state;",
      "78: static void stellaris_enet_update(stellaris_enet_state *s)",
      "79: {",
      "80:     qemu_set_irq(s->irq, (s->ris & s->im) != 0);",
      "",
      "[Removed Lines]",
      "62:     int tx_fifo_len;",
      "66:     struct {",
      "67:         uint8_t data[2048];",
      "68:         int len;",
      "69:     } rx[31];",
      "70:     int rx_fifo_offset;",
      "71:     int next_packet;",
      "",
      "[Added Lines]",
      "67:     uint32_t tx_fifo_len;",
      "71:     StellarisEnetRxFrame rx[31];",
      "72:     uint32_t rx_fifo_offset;",
      "73:     uint32_t next_packet;",
      "80: static const VMStateDescription vmstate_rx_frame = {",
      "81:     .name = \"stellaris_enet/rx_frame\",",
      "82:     .version_id = 1,",
      "83:     .minimum_version_id = 1,",
      "84:     .fields = (VMStateField[]) {",
      "85:         VMSTATE_UINT8_ARRAY(data, StellarisEnetRxFrame, 2048),",
      "86:         VMSTATE_UINT32(len, StellarisEnetRxFrame),",
      "87:         VMSTATE_END_OF_LIST()",
      "88:     }",
      "89: };",
      "91: static int stellaris_enet_post_load(void *opaque, int version_id)",
      "92: {",
      "93:     stellaris_enet_state *s = opaque;",
      "94:     int i;",
      "99:     if (s->next_packet >= ARRAY_SIZE(s->rx)) {",
      "100:         return -1;",
      "101:     }",
      "103:     if (s->np > ARRAY_SIZE(s->rx)) {",
      "104:         return -1;",
      "105:     }",
      "107:     for (i = 0; i < ARRAY_SIZE(s->rx); i++) {",
      "108:         if (s->rx[i].len > ARRAY_SIZE(s->rx[i].data)) {",
      "109:             return -1;",
      "110:         }",
      "111:     }",
      "113:     if (s->rx_fifo_offset > ARRAY_SIZE(s->rx[0].data) - 4) {",
      "114:         return -1;",
      "115:     }",
      "117:     if (s->tx_fifo_len > ARRAY_SIZE(s->tx_fifo)) {",
      "118:         return -1;",
      "119:     }",
      "121:     return 0;",
      "122: }",
      "124: static const VMStateDescription vmstate_stellaris_enet = {",
      "125:     .name = \"stellaris_enet\",",
      "126:     .version_id = 2,",
      "127:     .minimum_version_id = 2,",
      "128:     .post_load = stellaris_enet_post_load,",
      "129:     .fields = (VMStateField[]) {",
      "130:         VMSTATE_UINT32(ris, stellaris_enet_state),",
      "131:         VMSTATE_UINT32(im, stellaris_enet_state),",
      "132:         VMSTATE_UINT32(rctl, stellaris_enet_state),",
      "133:         VMSTATE_UINT32(tctl, stellaris_enet_state),",
      "134:         VMSTATE_UINT32(thr, stellaris_enet_state),",
      "135:         VMSTATE_UINT32(mctl, stellaris_enet_state),",
      "136:         VMSTATE_UINT32(mdv, stellaris_enet_state),",
      "137:         VMSTATE_UINT32(mtxd, stellaris_enet_state),",
      "138:         VMSTATE_UINT32(mrxd, stellaris_enet_state),",
      "139:         VMSTATE_UINT32(np, stellaris_enet_state),",
      "140:         VMSTATE_UINT32(tx_fifo_len, stellaris_enet_state),",
      "141:         VMSTATE_UINT8_ARRAY(tx_fifo, stellaris_enet_state, 2048),",
      "142:         VMSTATE_STRUCT_ARRAY(rx, stellaris_enet_state, 31, 1,",
      "143:                              vmstate_rx_frame, StellarisEnetRxFrame),",
      "144:         VMSTATE_UINT32(rx_fifo_offset, stellaris_enet_state),",
      "145:         VMSTATE_UINT32(next_packet, stellaris_enet_state),",
      "146:         VMSTATE_END_OF_LIST()",
      "147:     }",
      "148: };",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "379:     s->tx_fifo_len = 0;",
      "380: }",
      "439: static void stellaris_enet_cleanup(NetClientState *nc)",
      "440: {",
      "441:     stellaris_enet_state *s = qemu_get_nic_opaque(nc);",
      "",
      "[Removed Lines]",
      "382: static void stellaris_enet_save(QEMUFile *f, void *opaque)",
      "383: {",
      "384:     stellaris_enet_state *s = (stellaris_enet_state *)opaque;",
      "385:     int i;",
      "387:     qemu_put_be32(f, s->ris);",
      "388:     qemu_put_be32(f, s->im);",
      "389:     qemu_put_be32(f, s->rctl);",
      "390:     qemu_put_be32(f, s->tctl);",
      "391:     qemu_put_be32(f, s->thr);",
      "392:     qemu_put_be32(f, s->mctl);",
      "393:     qemu_put_be32(f, s->mdv);",
      "394:     qemu_put_be32(f, s->mtxd);",
      "395:     qemu_put_be32(f, s->mrxd);",
      "396:     qemu_put_be32(f, s->np);",
      "397:     qemu_put_be32(f, s->tx_fifo_len);",
      "398:     qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));",
      "399:     for (i = 0; i < 31; i++) {",
      "400:         qemu_put_be32(f, s->rx[i].len);",
      "401:         qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));",
      "403:     }",
      "404:     qemu_put_be32(f, s->next_packet);",
      "405:     qemu_put_be32(f, s->rx_fifo_offset);",
      "406: }",
      "408: static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)",
      "409: {",
      "410:     stellaris_enet_state *s = (stellaris_enet_state *)opaque;",
      "411:     int i;",
      "413:     if (version_id != 1)",
      "414:         return -EINVAL;",
      "416:     s->ris = qemu_get_be32(f);",
      "417:     s->im = qemu_get_be32(f);",
      "418:     s->rctl = qemu_get_be32(f);",
      "419:     s->tctl = qemu_get_be32(f);",
      "420:     s->thr = qemu_get_be32(f);",
      "421:     s->mctl = qemu_get_be32(f);",
      "422:     s->mdv = qemu_get_be32(f);",
      "423:     s->mtxd = qemu_get_be32(f);",
      "424:     s->mrxd = qemu_get_be32(f);",
      "425:     s->np = qemu_get_be32(f);",
      "426:     s->tx_fifo_len = qemu_get_be32(f);",
      "427:     qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));",
      "428:     for (i = 0; i < 31; i++) {",
      "429:         s->rx[i].len = qemu_get_be32(f);",
      "430:         qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));",
      "432:     }",
      "433:     s->next_packet = qemu_get_be32(f);",
      "434:     s->rx_fifo_offset = qemu_get_be32(f);",
      "436:     return 0;",
      "437: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "467:     qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);",
      "469:     stellaris_enet_reset(s);",
      "472:     return 0;",
      "473: }",
      "",
      "[Removed Lines]",
      "470:     register_savevm(dev, \"stellaris_enet\", -1, 1,",
      "471:                     stellaris_enet_save, stellaris_enet_load, s);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "476: {",
      "477:     stellaris_enet_state *s = STELLARIS_ENET(dev);",
      "481:     memory_region_destroy(&s->mmio);",
      "482: }",
      "",
      "[Removed Lines]",
      "479:     unregister_savevm(DEVICE(s), \"stellaris_enet\", s);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "494:     k->init = stellaris_enet_init;",
      "495:     dc->unrealize = stellaris_enet_unrealize;",
      "496:     dc->props = stellaris_enet_properties;",
      "497: }",
      "499: static const TypeInfo stellaris_enet_info = {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "508:     dc->vmsd = &vmstate_stellaris_enet;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7fd5f064d1c1a827a95ffe678418b3d5b8d2f108",
      "candidate_info": {
        "commit_hash": "7fd5f064d1c1a827a95ffe678418b3d5b8d2f108",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/7fd5f064d1c1a827a95ffe678418b3d5b8d2f108",
        "files": [
          "hw/net/stellaris_enet.c"
        ],
        "message": "hw/net/stellaris_enet: Correct handling of packet padding\n\nThe PADEN bit in the transmit control register enables padding of short\ndata packets out to the required minimum length. However a typo here\nmeant we were adjusting tx_fifo_len rather than tx_frame_len, so the\npadding didn't actually happen. Fix this bug.\n\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nCc: qemu-stable@nongnu.org",
        "before_after_code_files": [
          "hw/net/stellaris_enet.c||hw/net/stellaris_enet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/net/stellaris_enet.c||hw/net/stellaris_enet.c"
          ],
          "candidate": [
            "hw/net/stellaris_enet.c||hw/net/stellaris_enet.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/net/stellaris_enet.c||hw/net/stellaris_enet.c": [
          "File: hw/net/stellaris_enet.c -> hw/net/stellaris_enet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:                     s->tx_frame_len -= 4;",
          "266:                 if ((s->tctl & SE_TCTL_PADEN) && s->tx_frame_len < 60) {",
          "267:                     memset(&s->tx_fifo[s->tx_frame_len], 0, 60 - s->tx_frame_len);",
          "269:                 }",
          "270:                 qemu_send_packet(qemu_get_queue(s->nic), s->tx_fifo,",
          "271:                                  s->tx_frame_len);",
          "",
          "[Removed Lines]",
          "268:                     s->tx_fifo_len = 60;",
          "",
          "[Added Lines]",
          "268:                     s->tx_frame_len = 60;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
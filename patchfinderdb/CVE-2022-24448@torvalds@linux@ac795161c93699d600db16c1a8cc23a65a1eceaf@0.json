{
  "cve_id": "CVE-2022-24448",
  "cve_desc": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.",
  "repo": "torvalds/linux",
  "patch_hash": "ac795161c93699d600db16c1a8cc23a65a1eceaf",
  "patch_info": {
    "commit_hash": "ac795161c93699d600db16c1a8cc23a65a1eceaf",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ac795161c93699d600db16c1a8cc23a65a1eceaf",
    "files": [
      "fs/nfs/dir.c"
    ],
    "message": "NFSv4: Handle case where the lookup of a directory fails\n\nIf the application sets the O_DIRECTORY flag, and tries to open a\nregular file, nfs_atomic_open() will punt to doing a regular lookup.\nIf the server then returns a regular file, we will happily return a\nfile descriptor with uninitialised open state.\n\nThe fix is to return the expected ENOTDIR error in these cases.\n\nReported-by: Lyu Tao <tao.lyu@epfl.ch>\nFixes: 0dd2b474d0b6 (\"nfs: implement i_op->atomic_open()\")\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>\nSigned-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>",
    "before_after_code_files": [
      "fs/nfs/dir.c||fs/nfs/dir.c"
    ]
  },
  "patch_diff": {
    "fs/nfs/dir.c||fs/nfs/dir.c": [
      "File: fs/nfs/dir.c -> fs/nfs/dir.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1995: no_open:",
      "1996:  res = nfs_lookup(dir, dentry, lookup_flags);",
      "1997:  if (switched) {",
      "1998:   d_lookup_done(dentry);",
      "1999:   if (!res)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1997:  if (!res) {",
      "1998:   inode = d_inode(dentry);",
      "1999:   if ((lookup_flags & LOOKUP_DIRECTORY) && inode &&",
      "2000:       !S_ISDIR(inode->i_mode))",
      "2001:    res = ERR_PTR(-ENOTDIR);",
      "2002:  } else if (!IS_ERR(res)) {",
      "2003:   inode = d_inode(res);",
      "2004:   if ((lookup_flags & LOOKUP_DIRECTORY) && inode &&",
      "2005:       !S_ISDIR(inode->i_mode)) {",
      "2006:    dput(res);",
      "2007:    res = ERR_PTR(-ENOTDIR);",
      "2008:   }",
      "2009:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e0caaf75d443e02e55e146fd75fe2efc8aed5540",
      "candidate_info": {
        "commit_hash": "e0caaf75d443e02e55e146fd75fe2efc8aed5540",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e0caaf75d443e02e55e146fd75fe2efc8aed5540",
        "files": [
          "fs/nfs/dir.c"
        ],
        "message": "NFS: LOOKUP_DIRECTORY is also ok with symlinks\n\nCommit ac795161c936 (NFSv4: Handle case where the lookup of a directory\nfails) [1], part of Linux since 5.17-rc2, introduced a regression, where\na symbolic link on an NFS mount to a directory on another NFS does not\nresolve(?) the first time it is accessed:\n\nReported-by: Paul Menzel <pmenzel@molgen.mpg.de>\nFixes: ac795161c936 (\"NFSv4: Handle case where the lookup of a directory fails\")\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>\nTested-by: Donald Buczek <buczek@molgen.mpg.de>\nSigned-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>",
        "before_after_code_files": [
          "fs/nfs/dir.c||fs/nfs/dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/dir.c||fs/nfs/dir.c"
          ],
          "candidate": [
            "fs/nfs/dir.c||fs/nfs/dir.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/dir.c||fs/nfs/dir.c": [
          "File: fs/nfs/dir.c -> fs/nfs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2010:  if (!res) {",
          "2011:   inode = d_inode(dentry);",
          "2012:   if ((lookup_flags & LOOKUP_DIRECTORY) && inode &&",
          "2014:    res = ERR_PTR(-ENOTDIR);",
          "2015:   else if (inode && S_ISREG(inode->i_mode))",
          "2016:    res = ERR_PTR(-EOPENSTALE);",
          "2017:  } else if (!IS_ERR(res)) {",
          "2018:   inode = d_inode(res);",
          "2019:   if ((lookup_flags & LOOKUP_DIRECTORY) && inode &&",
          "2021:    dput(res);",
          "2022:    res = ERR_PTR(-ENOTDIR);",
          "2023:   } else if (inode && S_ISREG(inode->i_mode)) {",
          "",
          "[Removed Lines]",
          "2013:       !S_ISDIR(inode->i_mode))",
          "2020:       !S_ISDIR(inode->i_mode)) {",
          "",
          "[Added Lines]",
          "2013:       !(S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))",
          "2020:       !(S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-8172",
  "cve_desc": "The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",
  "repo": "torvalds/linux",
  "patch_hash": "eee5cc2702929fd41cce28058dc6d6717f723f87",
  "patch_info": {
    "commit_hash": "eee5cc2702929fd41cce28058dc6d6717f723f87",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87",
    "files": [
      "fs/file_table.c",
      "fs/internal.h",
      "fs/open.c",
      "fs/super.c",
      "include/linux/fs.h"
    ],
    "message": "get rid of s_files and files_lock\n\nThe only thing we need it for is alt-sysrq-r (emergency remount r/o)\nand these days we can do just as well without going through the\nlist of files.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "fs/file_table.c||fs/file_table.c",
      "fs/internal.h||fs/internal.h",
      "fs/open.c||fs/open.c",
      "fs/super.c||fs/super.c",
      "include/linux/fs.h||include/linux/fs.h"
    ]
  },
  "patch_diff": {
    "fs/file_table.c||fs/file_table.c": [
      "File: fs/file_table.c -> fs/file_table.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "36:  .max_files = NR_FILE",
      "37: };",
      "42: static struct kmem_cache *filp_cachep __read_mostly;",
      "",
      "[Removed Lines]",
      "39: DEFINE_STATIC_LGLOCK(files_lglock);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "134:   return ERR_PTR(error);",
      "135:  }",
      "138:  atomic_long_set(&f->f_count, 1);",
      "139:  rwlock_init(&f->f_owner.lock);",
      "140:  spin_lock_init(&f->f_lock);",
      "",
      "[Removed Lines]",
      "137:  INIT_LIST_HEAD(&f->f_u.fu_list);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "304:  if (atomic_long_dec_and_test(&file->f_count)) {",
      "305:   struct task_struct *task = current;",
      "308:   if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {",
      "309:    init_task_work(&file->f_u.fu_rcuhead, ____fput);",
      "310:    if (!task_work_add(task, &file->f_u.fu_rcuhead, true))",
      "",
      "[Removed Lines]",
      "307:   file_sb_list_del(file);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "333: {",
      "334:  if (atomic_long_dec_and_test(&file->f_count)) {",
      "335:   struct task_struct *task = current;",
      "337:   BUG_ON(!(task->flags & PF_KTHREAD));",
      "338:   __fput(file);",
      "339:  }",
      "",
      "[Removed Lines]",
      "336:   file_sb_list_del(file);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "345: {",
      "346:  if (atomic_long_dec_and_test(&file->f_count)) {",
      "347:   security_file_free(file);",
      "349:   file_free(file);",
      "350:  }",
      "351: }",
      "471: void __init files_init(unsigned long mempages)",
      "472: {",
      "473:  unsigned long n;",
      "",
      "[Removed Lines]",
      "348:   file_sb_list_del(file);",
      "353: static inline int file_list_cpu(struct file *file)",
      "354: {",
      "355: #ifdef CONFIG_SMP",
      "356:  return file->f_sb_list_cpu;",
      "357: #else",
      "358:  return smp_processor_id();",
      "359: #endif",
      "360: }",
      "363: static inline void __file_sb_list_add(struct file *file, struct super_block *sb)",
      "364: {",
      "365:  struct list_head *list;",
      "366: #ifdef CONFIG_SMP",
      "367:  int cpu;",
      "368:  cpu = smp_processor_id();",
      "369:  file->f_sb_list_cpu = cpu;",
      "370:  list = per_cpu_ptr(sb->s_files, cpu);",
      "371: #else",
      "372:  list = &sb->s_files;",
      "373: #endif",
      "374:  list_add(&file->f_u.fu_list, list);",
      "375: }",
      "385: void file_sb_list_add(struct file *file, struct super_block *sb)",
      "386: {",
      "387:  if (likely(!(file->f_mode & FMODE_WRITE)))",
      "388:   return;",
      "389:  if (!S_ISREG(file_inode(file)->i_mode))",
      "390:   return;",
      "391:  lg_local_lock(&files_lglock);",
      "392:  __file_sb_list_add(file, sb);",
      "393:  lg_local_unlock(&files_lglock);",
      "394: }",
      "403: void file_sb_list_del(struct file *file)",
      "404: {",
      "405:  if (!list_empty(&file->f_u.fu_list)) {",
      "406:   lg_local_lock_cpu(&files_lglock, file_list_cpu(file));",
      "407:   list_del_init(&file->f_u.fu_list);",
      "408:   lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));",
      "409:  }",
      "410: }",
      "412: #ifdef CONFIG_SMP",
      "418: #define do_file_list_for_each_entry(__sb, __file)  \\",
      "419: {        \\",
      "420:  int i;       \\",
      "421:  for_each_possible_cpu(i) {    \\",
      "422:   struct list_head *list;    \\",
      "423:   list = per_cpu_ptr((__sb)->s_files, i);  \\",
      "424:   list_for_each_entry((__file), list, f_u.fu_list)",
      "426: #define while_file_list_for_each_entry    \\",
      "427:  }       \\",
      "428: }",
      "430: #else",
      "432: #define do_file_list_for_each_entry(__sb, __file)  \\",
      "433: {        \\",
      "434:  struct list_head *list;     \\",
      "435:  list = &(sb)->s_files;     \\",
      "436:  list_for_each_entry((__file), list, f_u.fu_list)",
      "438: #define while_file_list_for_each_entry    \\",
      "439: }",
      "441: #endif",
      "450: void mark_files_ro(struct super_block *sb)",
      "451: {",
      "452:  struct file *f;",
      "454:  lg_global_lock(&files_lglock);",
      "455:  do_file_list_for_each_entry(sb, f) {",
      "456:   if (!file_count(f))",
      "457:    continue;",
      "458:   if (!(f->f_mode & FMODE_WRITE))",
      "459:    continue;",
      "460:   spin_lock(&f->f_lock);",
      "461:   f->f_mode &= ~FMODE_WRITE;",
      "462:   spin_unlock(&f->f_lock);",
      "463:   if (file_check_writeable(f) != 0)",
      "464:    continue;",
      "465:   __mnt_drop_write(f->f_path.mnt);",
      "466:   file_release_write(f);",
      "467:  } while_file_list_for_each_entry;",
      "468:  lg_global_unlock(&files_lglock);",
      "469: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "483:  n = (mempages * (PAGE_SIZE / 1024)) / 10;",
      "484:  files_stat.max_files = max_t(unsigned long, n, NR_FILE);",
      "485:  files_defer_init();",
      "487:  percpu_counter_init(&nr_files, 0);",
      "488: }",
      "",
      "[Removed Lines]",
      "486:  lg_lock_init(&files_lglock, \"files_lglock\");",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/internal.h||fs/internal.h": [
      "File: fs/internal.h -> fs/internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "79: extern struct file *get_empty_filp(void);",
      "",
      "[Removed Lines]",
      "76: extern void file_sb_list_add(struct file *f, struct super_block *sb);",
      "77: extern void file_sb_list_del(struct file *f);",
      "78: extern void mark_files_ro(struct super_block *);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/open.c||fs/open.c": [
      "File: fs/open.c -> fs/open.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "685:  }",
      "687:  f->f_mapping = inode->i_mapping;",
      "690:  if (unlikely(f->f_mode & FMODE_PATH)) {",
      "691:   f->f_op = &empty_fops;",
      "",
      "[Removed Lines]",
      "688:  file_sb_list_add(f, inode->i_sb);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "725: cleanup_all:",
      "726:  fops_put(f->f_op);",
      "728:  if (f->f_mode & FMODE_WRITE) {",
      "729:   put_write_access(inode);",
      "730:   if (!special_file(inode->i_mode)) {",
      "",
      "[Removed Lines]",
      "727:  file_sb_list_del(f);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/super.c||fs/super.c": [
      "File: fs/super.c -> fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "140:  int i;",
      "141:  list_lru_destroy(&s->s_dentry_lru);",
      "142:  list_lru_destroy(&s->s_inode_lru);",
      "146:  for (i = 0; i < SB_FREEZE_LEVELS; i++)",
      "147:   percpu_counter_destroy(&s->s_writers.counter[i]);",
      "148:  security_sb_free(s);",
      "",
      "[Removed Lines]",
      "143: #ifdef CONFIG_SMP",
      "144:  free_percpu(s->s_files);",
      "145: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "172:  if (security_sb_alloc(s))",
      "173:   goto fail;",
      "184:  for (i = 0; i < SB_FREEZE_LEVELS; i++) {",
      "185:   if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)",
      "186:    goto fail;",
      "",
      "[Removed Lines]",
      "175: #ifdef CONFIG_SMP",
      "176:  s->s_files = alloc_percpu(struct list_head);",
      "177:  if (!s->s_files)",
      "178:   goto fail;",
      "179:  for_each_possible_cpu(i)",
      "180:   INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));",
      "181: #else",
      "182:  INIT_LIST_HEAD(&s->s_files);",
      "183: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "723:  if (remount_ro) {",
      "724:   if (force) {",
      "726:   } else {",
      "727:    retval = sb_prepare_remount_readonly(sb);",
      "728:    if (retval)",
      "",
      "[Removed Lines]",
      "725:    mark_files_ro(sb);",
      "",
      "[Added Lines]",
      "713:    sb->s_readonly_remount = 1;",
      "714:    smp_wmb();",
      "",
      "---------------"
    ],
    "include/linux/fs.h||include/linux/fs.h": [
      "File: include/linux/fs.h -> include/linux/fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "764: #define FILE_MNT_WRITE_RELEASED 2",
      "766: struct file {",
      "771:  union {",
      "773:   struct llist_node fu_llist;",
      "774:   struct rcu_head  fu_rcuhead;",
      "775:  } f_u;",
      "",
      "[Removed Lines]",
      "772:   struct list_head fu_list;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "785:  spinlock_t  f_lock;",
      "789:  atomic_long_t  f_count;",
      "790:  unsigned int   f_flags;",
      "791:  fmode_t   f_mode;",
      "",
      "[Removed Lines]",
      "786: #ifdef CONFIG_SMP",
      "787:  int   f_sb_list_cpu;",
      "788: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1273:  struct block_device *s_bdev;",
      "1274:  struct backing_dev_info *s_bdi;",
      "",
      "[Removed Lines]",
      "1267: #ifdef CONFIG_SMP",
      "1268:  struct list_head __percpu *s_files;",
      "1269: #else",
      "1270:  struct list_head s_files;",
      "1271: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7eb5e8826911f2792179f99e77e75fbb7ef53a4a",
      "candidate_info": {
        "commit_hash": "7eb5e8826911f2792179f99e77e75fbb7ef53a4a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7eb5e8826911f2792179f99e77e75fbb7ef53a4a",
        "files": [
          "fs/super.c"
        ],
        "message": "uninline destroy_super(), consolidate alloc_super()\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/super.c||fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/super.c||fs/super.c"
          ],
          "candidate": [
            "fs/super.c||fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/super.c||fs/super.c": [
          "File: fs/super.c -> fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:  return total_objects;",
          "130: }",
          "154: {",
          "155:  int i;",
          "157:  for (i = 0; i < SB_FREEZE_LEVELS; i++)",
          "158:   percpu_counter_destroy(&s->s_writers.counter[i]);",
          "159: }",
          "",
          "[Removed Lines]",
          "132: static int init_sb_writers(struct super_block *s, struct file_system_type *type)",
          "133: {",
          "134:  int err;",
          "135:  int i;",
          "137:  for (i = 0; i < SB_FREEZE_LEVELS; i++) {",
          "138:   err = percpu_counter_init(&s->s_writers.counter[i], 0);",
          "139:   if (err < 0)",
          "140:    goto err_out;",
          "141:   lockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],",
          "142:      &type->s_writers_key[i], 0);",
          "143:  }",
          "144:  init_waitqueue_head(&s->s_writers.wait);",
          "145:  init_waitqueue_head(&s->s_writers.wait_unfrozen);",
          "146:  return 0;",
          "147: err_out:",
          "148:  while (--i >= 0)",
          "149:   percpu_counter_destroy(&s->s_writers.counter[i]);",
          "150:  return err;",
          "151: }",
          "153: static void destroy_sb_writers(struct super_block *s)",
          "",
          "[Added Lines]",
          "138: static void destroy_super(struct super_block *s)",
          "141:  list_lru_destroy(&s->s_dentry_lru);",
          "142:  list_lru_destroy(&s->s_inode_lru);",
          "143: #ifdef CONFIG_SMP",
          "144:  free_percpu(s->s_files);",
          "145: #endif",
          "148:  security_sb_free(s);",
          "149:  WARN_ON(!list_empty(&s->s_mounts));",
          "150:  kfree(s->s_subtype);",
          "151:  kfree(s->s_options);",
          "152:  kfree(s);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170: {",
          "171:  struct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);",
          "172:  static const struct super_operations default_op;",
          "178: #ifdef CONFIG_SMP",
          "188: #else",
          "190: #endif",
          "240:  }",
          "242:  return s;",
          "278: }",
          "",
          "[Removed Lines]",
          "174:  if (s) {",
          "175:   if (security_sb_alloc(s))",
          "176:    goto out_free_sb;",
          "179:   s->s_files = alloc_percpu(struct list_head);",
          "180:   if (!s->s_files)",
          "181:    goto err_out;",
          "182:   else {",
          "183:    int i;",
          "185:    for_each_possible_cpu(i)",
          "186:     INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));",
          "187:   }",
          "189:   INIT_LIST_HEAD(&s->s_files);",
          "191:   if (init_sb_writers(s, type))",
          "192:    goto err_out;",
          "193:   s->s_flags = flags;",
          "194:   s->s_bdi = &default_backing_dev_info;",
          "195:   INIT_HLIST_NODE(&s->s_instances);",
          "196:   INIT_HLIST_BL_HEAD(&s->s_anon);",
          "197:   INIT_LIST_HEAD(&s->s_inodes);",
          "199:   if (list_lru_init(&s->s_dentry_lru))",
          "200:    goto err_out;",
          "201:   if (list_lru_init(&s->s_inode_lru))",
          "202:    goto err_out_dentry_lru;",
          "204:   INIT_LIST_HEAD(&s->s_mounts);",
          "205:   init_rwsem(&s->s_umount);",
          "206:   lockdep_set_class(&s->s_umount, &type->s_umount_key);",
          "222:   down_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);",
          "223:   s->s_count = 1;",
          "224:   atomic_set(&s->s_active, 1);",
          "225:   mutex_init(&s->s_vfs_rename_mutex);",
          "226:   lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);",
          "227:   mutex_init(&s->s_dquot.dqio_mutex);",
          "228:   mutex_init(&s->s_dquot.dqonoff_mutex);",
          "229:   init_rwsem(&s->s_dquot.dqptr_sem);",
          "230:   s->s_maxbytes = MAX_NON_LFS;",
          "231:   s->s_op = &default_op;",
          "232:   s->s_time_gran = 1000000000;",
          "233:   s->cleancache_poolid = -1;",
          "235:   s->s_shrink.seeks = DEFAULT_SEEKS;",
          "236:   s->s_shrink.scan_objects = super_cache_scan;",
          "237:   s->s_shrink.count_objects = super_cache_count;",
          "238:   s->s_shrink.batch = 1024;",
          "239:   s->s_shrink.flags = SHRINKER_NUMA_AWARE;",
          "241: out:",
          "244: err_out_dentry_lru:",
          "245:  list_lru_destroy(&s->s_dentry_lru);",
          "246: err_out:",
          "247:  security_sb_free(s);",
          "248: #ifdef CONFIG_SMP",
          "249:  if (s->s_files)",
          "250:   free_percpu(s->s_files);",
          "251: #endif",
          "252:  destroy_sb_writers(s);",
          "253: out_free_sb:",
          "254:  kfree(s);",
          "255:  s = NULL;",
          "256:  goto out;",
          "257: }",
          "265: static inline void destroy_super(struct super_block *s)",
          "266: {",
          "267:  list_lru_destroy(&s->s_dentry_lru);",
          "268:  list_lru_destroy(&s->s_inode_lru);",
          "269: #ifdef CONFIG_SMP",
          "270:  free_percpu(s->s_files);",
          "271: #endif",
          "272:  destroy_sb_writers(s);",
          "273:  security_sb_free(s);",
          "274:  WARN_ON(!list_empty(&s->s_mounts));",
          "275:  kfree(s->s_subtype);",
          "276:  kfree(s->s_options);",
          "277:  kfree(s);",
          "",
          "[Added Lines]",
          "167:  int i;",
          "169:  if (!s)",
          "170:   return NULL;",
          "172:  if (security_sb_alloc(s))",
          "173:   goto fail;",
          "176:  s->s_files = alloc_percpu(struct list_head);",
          "177:  if (!s->s_files)",
          "178:   goto fail;",
          "179:  for_each_possible_cpu(i)",
          "180:   INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));",
          "182:  INIT_LIST_HEAD(&s->s_files);",
          "184:  for (i = 0; i < SB_FREEZE_LEVELS; i++) {",
          "185:   if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)",
          "186:    goto fail;",
          "187:   lockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],",
          "188:      &type->s_writers_key[i], 0);",
          "190:  init_waitqueue_head(&s->s_writers.wait);",
          "191:  init_waitqueue_head(&s->s_writers.wait_unfrozen);",
          "192:  s->s_flags = flags;",
          "193:  s->s_bdi = &default_backing_dev_info;",
          "194:  INIT_HLIST_NODE(&s->s_instances);",
          "195:  INIT_HLIST_BL_HEAD(&s->s_anon);",
          "196:  INIT_LIST_HEAD(&s->s_inodes);",
          "198:  if (list_lru_init(&s->s_dentry_lru))",
          "199:   goto fail;",
          "200:  if (list_lru_init(&s->s_inode_lru))",
          "201:   goto fail;",
          "203:  INIT_LIST_HEAD(&s->s_mounts);",
          "204:  init_rwsem(&s->s_umount);",
          "205:  lockdep_set_class(&s->s_umount, &type->s_umount_key);",
          "221:  down_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);",
          "222:  s->s_count = 1;",
          "223:  atomic_set(&s->s_active, 1);",
          "224:  mutex_init(&s->s_vfs_rename_mutex);",
          "225:  lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);",
          "226:  mutex_init(&s->s_dquot.dqio_mutex);",
          "227:  mutex_init(&s->s_dquot.dqonoff_mutex);",
          "228:  init_rwsem(&s->s_dquot.dqptr_sem);",
          "229:  s->s_maxbytes = MAX_NON_LFS;",
          "230:  s->s_op = &default_op;",
          "231:  s->s_time_gran = 1000000000;",
          "232:  s->cleancache_poolid = -1;",
          "234:  s->s_shrink.seeks = DEFAULT_SEEKS;",
          "235:  s->s_shrink.scan_objects = super_cache_scan;",
          "236:  s->s_shrink.count_objects = super_cache_count;",
          "237:  s->s_shrink.batch = 1024;",
          "238:  s->s_shrink.flags = SHRINKER_NUMA_AWARE;",
          "241: fail:",
          "242:  destroy_super(s);",
          "243:  return NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "19156840e33a23eeb1a749c0f991dab6588b077d",
      "candidate_info": {
        "commit_hash": "19156840e33a23eeb1a749c0f991dab6588b077d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/19156840e33a23eeb1a749c0f991dab6588b077d",
        "files": [
          "fs/dcache.c",
          "fs/super.c",
          "include/linux/fs.h"
        ],
        "message": "dentry: move to per-sb LRU locks\n\nWith the dentry LRUs being per-sb structures, there is no real need for\na global dentry_lru_lock. The locking can be made more fine-grained by\nmoving to a per-sb LRU lock, isolating the LRU operations of different\nfilesytsems completely from each other. The need for this is independent\nof any performance consideration that may arise: in the interest of\nabstracting the lru operations away, it is mandatory that each lru works\naround its own lock instead of a global lock for all of them.\n\n[glommer@openvz.org: updated changelog ]\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nSigned-off-by: Glauber Costa <glommer@openvz.org>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nAcked-by: Mel Gorman <mgorman@suse.de>\nCc: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>\nCc: Arve Hj\u00f8nnev\u00e5g <arve@android.com>\nCc: Carlos Maiolino <cmaiolino@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Chuck Lever <chuck.lever@oracle.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: David Rientjes <rientjes@google.com>\nCc: Gleb Natapov <gleb@redhat.com>\nCc: Greg Thelen <gthelen@google.com>\nCc: J. Bruce Fields <bfields@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Jerome Glisse <jglisse@redhat.com>\nCc: John Stultz <john.stultz@linaro.org>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Kent Overstreet <koverstreet@google.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Marcelo Tosatti <mtosatti@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Steven Whitehouse <swhiteho@redhat.com>\nCc: Thomas Hellstrom <thellstrom@vmware.com>\nCc: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/dcache.c||fs/dcache.c",
          "fs/super.c||fs/super.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ],
          "candidate": [
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/dcache.c||fs/dcache.c": [
          "File: fs/dcache.c -> fs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: int sysctl_vfs_cache_pressure __read_mostly = 100;",
          "82: EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure);",
          "85: __cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);",
          "87: EXPORT_SYMBOL(rename_lock);",
          "",
          "[Removed Lines]",
          "84: static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dcache_lru_lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "362: static void dentry_lru_add(struct dentry *dentry)",
          "363: {",
          "364:  if (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST))) {",
          "366:   dentry->d_flags |= DCACHE_LRU_LIST;",
          "367:   list_add(&dentry->d_lru, &dentry->d_sb->s_dentry_lru);",
          "368:   dentry->d_sb->s_nr_dentry_unused++;",
          "369:   this_cpu_inc(nr_dentry_unused);",
          "371:  }",
          "372: }",
          "",
          "[Removed Lines]",
          "365:   spin_lock(&dcache_lru_lock);",
          "370:   spin_unlock(&dcache_lru_lock);",
          "",
          "[Added Lines]",
          "364:   spin_lock(&dentry->d_sb->s_dentry_lru_lock);",
          "369:   spin_unlock(&dentry->d_sb->s_dentry_lru_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "385: static void dentry_lru_del(struct dentry *dentry)",
          "386: {",
          "387:  if (!list_empty(&dentry->d_lru)) {",
          "389:   __dentry_lru_del(dentry);",
          "391:  }",
          "392: }",
          "394: static void dentry_lru_move_list(struct dentry *dentry, struct list_head *list)",
          "395: {",
          "397:  if (list_empty(&dentry->d_lru)) {",
          "398:   dentry->d_flags |= DCACHE_LRU_LIST;",
          "399:   list_add_tail(&dentry->d_lru, list);",
          "",
          "[Removed Lines]",
          "388:   spin_lock(&dcache_lru_lock);",
          "390:   spin_unlock(&dcache_lru_lock);",
          "396:  spin_lock(&dcache_lru_lock);",
          "",
          "[Added Lines]",
          "387:   spin_lock(&dentry->d_sb->s_dentry_lru_lock);",
          "389:   spin_unlock(&dentry->d_sb->s_dentry_lru_lock);",
          "395:  spin_lock(&dentry->d_sb->s_dentry_lru_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "402:  } else {",
          "403:   list_move_tail(&dentry->d_lru, list);",
          "404:  }",
          "406: }",
          "",
          "[Removed Lines]",
          "405:  spin_unlock(&dcache_lru_lock);",
          "",
          "[Added Lines]",
          "404:  spin_unlock(&dentry->d_sb->s_dentry_lru_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "895:  LIST_HEAD(tmp);",
          "897: relock:",
          "899:  while (!list_empty(&sb->s_dentry_lru)) {",
          "900:   dentry = list_entry(sb->s_dentry_lru.prev,",
          "901:     struct dentry, d_lru);",
          "902:   BUG_ON(dentry->d_sb != sb);",
          "904:   if (!spin_trylock(&dentry->d_lock)) {",
          "906:    cpu_relax();",
          "907:    goto relock;",
          "908:   }",
          "",
          "[Removed Lines]",
          "898:  spin_lock(&dcache_lru_lock);",
          "905:    spin_unlock(&dcache_lru_lock);",
          "",
          "[Added Lines]",
          "897:  spin_lock(&sb->s_dentry_lru_lock);",
          "904:    spin_unlock(&sb->s_dentry_lru_lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "918:    if (!--count)",
          "919:     break;",
          "920:   }",
          "922:  }",
          "923:  if (!list_empty(&referenced))",
          "924:   list_splice(&referenced, &sb->s_dentry_lru);",
          "927:  shrink_dentry_list(&tmp);",
          "928: }",
          "",
          "[Removed Lines]",
          "921:   cond_resched_lock(&dcache_lru_lock);",
          "925:  spin_unlock(&dcache_lru_lock);",
          "",
          "[Added Lines]",
          "920:   cond_resched_lock(&sb->s_dentry_lru_lock);",
          "924:  spin_unlock(&sb->s_dentry_lru_lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "938: {",
          "939:  LIST_HEAD(tmp);",
          "942:  while (!list_empty(&sb->s_dentry_lru)) {",
          "943:   list_splice_init(&sb->s_dentry_lru, &tmp);",
          "945:   shrink_dentry_list(&tmp);",
          "947:  }",
          "949: }",
          "950: EXPORT_SYMBOL(shrink_dcache_sb);",
          "",
          "[Removed Lines]",
          "941:  spin_lock(&dcache_lru_lock);",
          "944:   spin_unlock(&dcache_lru_lock);",
          "946:   spin_lock(&dcache_lru_lock);",
          "948:  spin_unlock(&dcache_lru_lock);",
          "",
          "[Added Lines]",
          "940:  spin_lock(&sb->s_dentry_lru_lock);",
          "943:   spin_unlock(&sb->s_dentry_lru_lock);",
          "945:   spin_lock(&sb->s_dentry_lru_lock);",
          "947:  spin_unlock(&sb->s_dentry_lru_lock);",
          "",
          "---------------"
        ],
        "fs/super.c||fs/super.c": [
          "File: fs/super.c -> fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "176:   INIT_HLIST_BL_HEAD(&s->s_anon);",
          "177:   INIT_LIST_HEAD(&s->s_inodes);",
          "178:   INIT_LIST_HEAD(&s->s_dentry_lru);",
          "179:   INIT_LIST_HEAD(&s->s_inode_lru);",
          "180:   spin_lock_init(&s->s_inode_lru_lock);",
          "181:   INIT_LIST_HEAD(&s->s_mounts);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "179:   spin_lock_init(&s->s_dentry_lru_lock);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1269:  struct list_head s_files;",
          "1270: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1274:  spinlock_t  s_dentry_lru_lock ____cacheline_aligned_in_smp;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9b17c62382dd2e7507984b9890bf44e070cdd8bb",
      "candidate_info": {
        "commit_hash": "9b17c62382dd2e7507984b9890bf44e070cdd8bb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9b17c62382dd2e7507984b9890bf44e070cdd8bb",
        "files": [
          "fs/dcache.c",
          "fs/inode.c",
          "fs/internal.h",
          "fs/super.c",
          "fs/xfs/xfs_super.c",
          "include/linux/fs.h"
        ],
        "message": "fs: convert inode and dentry shrinking to be node aware\n\nNow that the shrinker is passing a node in the scan control structure, we\ncan pass this to the the generic LRU list code to isolate reclaim to the\nlists on matching nodes.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nSigned-off-by: Glauber Costa <glommer@parallels.com>\nAcked-by: Mel Gorman <mgorman@suse.de>\nCc: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>\nCc: Arve Hj\u00f8nnev\u00e5g <arve@android.com>\nCc: Carlos Maiolino <cmaiolino@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Chuck Lever <chuck.lever@oracle.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: David Rientjes <rientjes@google.com>\nCc: Gleb Natapov <gleb@redhat.com>\nCc: Greg Thelen <gthelen@google.com>\nCc: J. Bruce Fields <bfields@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Jerome Glisse <jglisse@redhat.com>\nCc: John Stultz <john.stultz@linaro.org>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Kent Overstreet <koverstreet@google.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Marcelo Tosatti <mtosatti@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Steven Whitehouse <swhiteho@redhat.com>\nCc: Thomas Hellstrom <thellstrom@vmware.com>\nCc: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/dcache.c||fs/dcache.c",
          "fs/inode.c||fs/inode.c",
          "fs/internal.h||fs/internal.h",
          "fs/super.c||fs/super.c",
          "fs/xfs/xfs_super.c||fs/xfs/xfs_super.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/internal.h||fs/internal.h",
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ],
          "candidate": [
            "fs/internal.h||fs/internal.h",
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/dcache.c||fs/dcache.c": [
          "File: fs/dcache.c -> fs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "949: {",
          "950:  LIST_HEAD(dispose);",
          "951:  long freed;",
          "955:  shrink_dentry_list(&dispose);",
          "956:  return freed;",
          "957: }",
          "",
          "[Removed Lines]",
          "948: long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan)",
          "953:  freed = list_lru_walk(&sb->s_dentry_lru, dentry_lru_isolate,",
          "954:          &dispose, nr_to_scan);",
          "",
          "[Added Lines]",
          "949: long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan,",
          "950:        int nid)",
          "955:  freed = list_lru_walk_node(&sb->s_dentry_lru, nid, dentry_lru_isolate,",
          "956:            &dispose, &nr_to_scan);",
          "",
          "---------------"
        ],
        "fs/inode.c||fs/inode.c": [
          "File: fs/inode.c -> fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "752: {",
          "753:  LIST_HEAD(freeable);",
          "754:  long freed;",
          "758:  dispose_list(&freeable);",
          "759:  return freed;",
          "760: }",
          "",
          "[Removed Lines]",
          "751: long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan)",
          "756:  freed = list_lru_walk(&sb->s_inode_lru, inode_lru_isolate,",
          "757:       &freeable, nr_to_scan);",
          "",
          "[Added Lines]",
          "751: long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan,",
          "752:        int nid)",
          "757:  freed = list_lru_walk_node(&sb->s_inode_lru, nid, inode_lru_isolate,",
          "758:            &freeable, &nr_to_scan);",
          "",
          "---------------"
        ],
        "fs/internal.h||fs/internal.h": [
          "File: fs/internal.h -> fs/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "116: extern spinlock_t inode_sb_list_lock;",
          "118: extern void inode_add_lru(struct inode *inode);",
          "",
          "[Removed Lines]",
          "117: extern long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan);",
          "",
          "[Added Lines]",
          "117: extern long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan,",
          "118:        int nid);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "132: extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);",
          "133: extern int d_set_mounted(struct dentry *dentry);",
          "",
          "[Removed Lines]",
          "134: extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan);",
          "",
          "[Added Lines]",
          "135: extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan,",
          "136:        int nid);",
          "",
          "---------------"
        ],
        "fs/super.c||fs/super.c": [
          "File: fs/super.c -> fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:   return SHRINK_STOP;",
          "78:  if (sb->s_op->nr_cached_objects)",
          "83:  total_objects = dentries + inodes + fs_objects + 1;",
          "",
          "[Removed Lines]",
          "79:   fs_objects = sb->s_op->nr_cached_objects(sb);",
          "81:  inodes = list_lru_count(&sb->s_inode_lru);",
          "82:  dentries = list_lru_count(&sb->s_dentry_lru);",
          "",
          "[Added Lines]",
          "79:   fs_objects = sb->s_op->nr_cached_objects(sb, sc->nid);",
          "81:  inodes = list_lru_count_node(&sb->s_inode_lru, sc->nid);",
          "82:  dentries = list_lru_count_node(&sb->s_dentry_lru, sc->nid);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96:  if (fs_objects) {",
          "97:   fs_objects = mult_frac(sc->nr_to_scan, fs_objects,",
          "98:         total_objects);",
          "100:  }",
          "102:  drop_super(sb);",
          "",
          "[Removed Lines]",
          "93:  freed = prune_dcache_sb(sb, dentries);",
          "94:  freed += prune_icache_sb(sb, inodes);",
          "99:   freed += sb->s_op->free_cached_objects(sb, fs_objects);",
          "",
          "[Added Lines]",
          "93:  freed = prune_dcache_sb(sb, dentries, sc->nid);",
          "94:  freed += prune_icache_sb(sb, inodes, sc->nid);",
          "99:   freed += sb->s_op->free_cached_objects(sb, fs_objects,",
          "100:              sc->nid);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "115:   return 0;",
          "117:  if (sb->s_op && sb->s_op->nr_cached_objects)",
          "123:  total_objects = vfs_pressure_ratio(total_objects);",
          "124:  drop_super(sb);",
          "",
          "[Removed Lines]",
          "118:   total_objects = sb->s_op->nr_cached_objects(sb);",
          "120:  total_objects += list_lru_count(&sb->s_dentry_lru);",
          "121:  total_objects += list_lru_count(&sb->s_inode_lru);",
          "",
          "[Added Lines]",
          "119:   total_objects = sb->s_op->nr_cached_objects(sb,",
          "120:        sc->nid);",
          "122:  total_objects += list_lru_count_node(&sb->s_dentry_lru,",
          "123:        sc->nid);",
          "124:  total_objects += list_lru_count_node(&sb->s_inode_lru,",
          "125:        sc->nid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:   s->s_shrink.scan_objects = super_cache_scan;",
          "229:   s->s_shrink.count_objects = super_cache_count;",
          "230:   s->s_shrink.batch = 1024;",
          "231:  }",
          "232: out:",
          "233:  return s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "235:   s->s_shrink.flags = SHRINKER_NUMA_AWARE;",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_super.c||fs/xfs/xfs_super.c": [
          "File: fs/xfs/xfs_super.c -> fs/xfs/xfs_super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1538: static long",
          "1539: xfs_fs_nr_cached_objects(",
          "1541: {",
          "1542:  return xfs_reclaim_inodes_count(XFS_M(sb));",
          "1543: }",
          "",
          "[Removed Lines]",
          "1540:  struct super_block *sb)",
          "",
          "[Added Lines]",
          "1540:  struct super_block *sb,",
          "1541:  int   nid)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1545: static long",
          "1546: xfs_fs_free_cached_objects(",
          "1547:  struct super_block *sb,",
          "1549: {",
          "1550:  return xfs_reclaim_inodes_nr(XFS_M(sb), nr_to_scan);",
          "1551: }",
          "",
          "[Removed Lines]",
          "1548:  long   nr_to_scan)",
          "",
          "[Added Lines]",
          "1549:  long   nr_to_scan,",
          "1550:  int   nid)",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1624:  ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);",
          "1625: #endif",
          "1626:  int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);",
          "1629: };",
          "",
          "[Removed Lines]",
          "1627:  long (*nr_cached_objects)(struct super_block *);",
          "1628:  long (*free_cached_objects)(struct super_block *, long);",
          "",
          "[Added Lines]",
          "1627:  long (*nr_cached_objects)(struct super_block *, int);",
          "1628:  long (*free_cached_objects)(struct super_block *, long, int);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19923",
  "cve_desc": "flattenSubquery in select.c in SQLite 3.30.1 mishandles certain uses of SELECT DISTINCT involving a LEFT JOIN in which the right-hand side is a view. This can cause a NULL pointer dereference (or incorrect results).",
  "repo": "sqlite/sqlite",
  "patch_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
  "patch_info": {
    "commit_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/join.test"
    ],
    "message": "Continue to back away from the LEFT JOIN optimization of check-in [41c27bc0ff1d3135] by disallowing query flattening if the outer query is DISTINCT.  Without this fix, if an index scan is run on the table within the view on the right-hand side of the LEFT JOIN, stale result registers might be accessed yielding incorrect results, and/or an OP_IfNullRow opcode might be invoked on the un-opened table, resulting in a NULL-pointer dereference.  This problem was found by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: 862974312edf00e9d1068115d1a39b7235b7db68b6d86b81d38a12f025a4748e",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/join.test||test/join.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 289158aa24b066c453d2bce4bc2dead1c56fb0b23c3f7c4810b34b13627cef34",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3797:   if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){",
      "3798:     isLeftJoin = 1;",
      "3801:       return 0;",
      "3802:     }",
      "3803:   }",
      "",
      "[Removed Lines]",
      "3799:     if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){",
      "",
      "[Added Lines]",
      "3804:     ){",
      "",
      "---------------"
    ],
    "test/join.test||test/join.test": [
      "File: test/join.test -> test/join.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "975:   SELECT 24, * FROM t1 LEFT JOIN t0 ON +aa ISNULL;",
      "976: } {13 1 {} 14 1 {} 23 1 {} 24 1 {}}",
      "978: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "978: # 2019-12-18 problem with a LEFT JOIN where the RHS is a view.",
      "979: # Detected by Yongheng and Rui.",
      "980: # Follows from the optimization attempt of check-in 41c27bc0ff1d3135",
      "981: # on 2017-04-18",
      "982: #",
      "983: reset_db",
      "984: do_execsql_test join-22.10 {",
      "985:   CREATE TABLE t0(a, b);",
      "986:   CREATE INDEX t0a ON t0(a);",
      "987:   INSERT INTO t0 VALUES(10,10),(10,11),(10,12);",
      "988:   SELECT DISTINCT c FROM t0 LEFT JOIN (SELECT a+1 AS c FROM t0) ORDER BY c ;",
      "989: } {11}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fe03dac236fb191c03bef60c30abbfa35e648e4c",
      "candidate_info": {
        "commit_hash": "fe03dac236fb191c03bef60c30abbfa35e648e4c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/fe03dac236fb191c03bef60c30abbfa35e648e4c",
        "files": [
          "Makefile.in",
          "Makefile.msc",
          "manifest",
          "manifest.uuid",
          "tool/lemon.c"
        ],
        "message": "Add the new -S option to the lemon parser generator to cause it to output SQL that describes the input grammar.\n\nFossilOrigin-Name: 4dbd398d640852d4a696d68c72ee039968023d402a8053b5e6b4ef1d75e982a8",
        "before_after_code_files": [
          "Makefile.in||Makefile.in",
          "Makefile.msc||Makefile.msc",
          "manifest.uuid||manifest.uuid",
          "tool/lemon.c||tool/lemon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.in||Makefile.in": [
          "File: Makefile.in -> Makefile.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "1053: parse.c: $(TOP)/src/parse.y lemon$(BEXE)",
          "1054:  cp $(TOP)/src/parse.y .",
          "1057: sqlite3.h: $(TOP)/src/sqlite.h.in $(TOP)/manifest mksourceid$(BEXE) $(TOP)/VERSION",
          "1058:  $(TCLSH_CMD) $(TOP)/tool/mksqlite3h.tcl $(TOP) >sqlite3.h",
          "",
          "[Removed Lines]",
          "1055:  ./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) parse.y",
          "",
          "[Added Lines]",
          "1055:  ./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) -S parse.y",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1180: fts5parse.c: $(TOP)/ext/fts5/fts5parse.y lemon",
          "1181:  cp $(TOP)/ext/fts5/fts5parse.y .",
          "1182:  rm -f fts5parse.h",
          "1185: fts5parse.h: fts5parse.c",
          "",
          "[Removed Lines]",
          "1183:  ./lemon$(BEXE) $(OPTS) fts5parse.y",
          "",
          "[Added Lines]",
          "1183:  ./lemon$(BEXE) $(OPTS) -S fts5parse.y",
          "",
          "---------------"
        ],
        "Makefile.msc||Makefile.msc": [
          "File: Makefile.msc -> Makefile.msc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2141: parse.c: $(TOP)\\src\\parse.y lemon.exe",
          "2142:  del /Q parse.y parse.h parse.h.temp 2>NUL",
          "2143:  copy $(TOP)\\src\\parse.y .",
          "2146: $(SQLITE3H): $(TOP)\\src\\sqlite.h.in $(TOP)\\manifest mksourceid.exe $(TOP)\\VERSION",
          "2147:  $(TCLSH_CMD) $(TOP)\\tool\\mksqlite3h.tcl $(TOP:\\=/) > $(SQLITE3H) $(MKSQLITE3H_ARGS)",
          "",
          "[Removed Lines]",
          "2144:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) parse.y",
          "",
          "[Added Lines]",
          "2144:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) -S parse.y",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2301: fts5parse.c: $(TOP)\\ext\\fts5\\fts5parse.y lemon.exe",
          "2302:  copy $(TOP)\\ext\\fts5\\fts5parse.y .",
          "2303:  del /Q fts5parse.h 2>NUL",
          "2306: fts5parse.h: fts5parse.c",
          "",
          "[Removed Lines]",
          "2304:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) fts5parse.y",
          "",
          "[Added Lines]",
          "2304:  .\\lemon.exe $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) -S fts5parse.y",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 5d9a369301a65f320a0696fcf1f062ca5976ef34350590c07aecf5335c66d872",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "219: void Reprint(struct lemon *);",
          "220: void ReportOutput(struct lemon *);",
          "222: void ReportHeader(struct lemon *);",
          "223: void CompressTables(struct lemon *);",
          "224: void ResortStates(struct lemon *);",
          "",
          "[Removed Lines]",
          "221: void ReportTable(struct lemon *, int);",
          "",
          "[Added Lines]",
          "221: void ReportTable(struct lemon *, int, int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1632:   static int mhflag = 0;",
          "1633:   static int nolinenosflag = 0;",
          "1634:   static int noResort = 0;",
          "1636:   static struct s_options options[] = {",
          "1637:     {OPT_FLAG, \"b\", (char*)&basisflag, \"Print only the basis in report.\"},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1635:   static int sqlFlag = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1650:     {OPT_FLAG, \"r\", (char*)&noResort, \"Do not sort or renumber states\"},",
          "1651:     {OPT_FLAG, \"s\", (char*)&statistics,",
          "1652:                                    \"Print parser stats to standard output.\"},",
          "1653:     {OPT_FLAG, \"x\", (char*)&version, \"Print the version number.\"},",
          "1654:     {OPT_FSTR, \"T\", (char*)handle_T_option, \"Specify a template file.\"},",
          "1655:     {OPT_FSTR, \"W\", 0, \"Ignored.  (Placeholder for '-W' compiler options.)\"},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1654:     {OPT_FLAG, \"S\", (char*)&sqlFlag,",
          "1655:                     \"Generate the *.sql file describing the parser tables.\"},",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1758:     if( !quiet ) ReportOutput(&lem);",
          "",
          "[Removed Lines]",
          "1761:     ReportTable(&lem, mhflag);",
          "",
          "[Added Lines]",
          "1764:     ReportTable(&lem, mhflag, sqlFlag);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4144: void ReportTable(",
          "4145:   struct lemon *lemp,",
          "4147: ){",
          "4149:   char line[LINESIZE];",
          "4150:   int  lineno;",
          "4151:   struct state *stp;",
          "",
          "[Removed Lines]",
          "4148:   FILE *out, *in;",
          "",
          "[Added Lines]",
          "4152:   FILE *out, *in, *sql;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4175:     fclose(in);",
          "4176:     return;",
          "4177:   }",
          "4178:   lineno = 1;",
          "4179:   tplt_xfer(lemp->name,in,out,&lineno);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4182:   if( sqlFlag==0 ){",
          "4183:     sql = 0;",
          "4184:   }else{",
          "4185:     sql = file_open(lemp, \".sql\", \"wb\");",
          "4186:     if( sql==0 ){",
          "4187:       fclose(in);",
          "4188:       fclose(out);",
          "4189:       return;",
          "4190:     }",
          "4191:     fprintf(sql,",
          "4192:        \"CREATE TABLE symbol(\\n\"",
          "4193:        \"  id INTEGER PRIMARY KEY,\\n\"",
          "4194:        \"  name TEXT NOT NULL,\\n\"",
          "4195:        \"  isTerminal BOOLEAN NOT NULL,\\n\"",
          "4196:        \"  fallback INTEGER REFERENCES symbol\\n\"",
          "4197:        \");\\n\"",
          "4198:     );",
          "4199:     for(i=0; i<lemp->nsymbol; i++){",
          "4200:       fprintf(sql,",
          "4201:          \"INSERT INTO symbol(id,name,isTerminal,fallback)\"",
          "4202:          \"VALUES(%d,'%s',%s\",",
          "4203:          i, lemp->symbols[i]->name,",
          "4204:          i<lemp->nterminal ? \"TRUE\" : \"FALSE\"",
          "4205:       );",
          "4206:       if( lemp->symbols[i]->fallback ){",
          "4207:         fprintf(sql, \",%d);\\n\", lemp->symbols[i]->fallback->index);",
          "4208:       }else{",
          "4209:         fprintf(sql, \",NULL);\\n\");",
          "4210:       }",
          "4211:     }",
          "4212:     fprintf(sql,",
          "4213:       \"CREATE TABLE rule(\\n\"",
          "4214:       \"  ruleid INTEGER PRIMARY KEY,\\n\"",
          "4215:       \"  lhs INTEGER REFERENCES symbol(id)\\n\"",
          "4216:       \");\\n\"",
          "4217:       \"CREATE TABLE rulerhs(\\n\"",
          "4218:       \"  ruleid INTEGER REFERENCES rule(ruleid),\\n\"",
          "4219:       \"  pos INTEGER,\\n\"",
          "4220:       \"  sym INTEGER REFERENCES symbol(id)\\n\"",
          "4221:       \");\\n\"",
          "4222:     );",
          "4223:     for(i=0, rp=lemp->rule; rp; rp=rp->next, i++){",
          "4224:       assert( i==rp->iRule );",
          "4225:       fprintf(sql,",
          "4226:         \"INSERT INTO rule(ruleid,lhs)VALUES(%d,%d);\\n\",",
          "4227:         rp->iRule, rp->lhs->index",
          "4228:       );",
          "4229:       for(j=0; j<rp->nrhs; j++){",
          "4230:         struct symbol *sp = rp->rhs[j];",
          "4231:         if( sp->type!=MULTITERMINAL ){",
          "4232:           fprintf(sql,",
          "4233:             \"INSERT INTO rulerhs(ruleid,pos,sym)VALUES(%d,%d,%d);\\n\",",
          "4234:             i,j,sp->index",
          "4235:           );",
          "4236:         }else{",
          "4237:           int k;",
          "4238:           for(k=0; k<sp->nsubsym; k++){",
          "4239:             fprintf(sql,",
          "4240:               \"INSERT INTO rulerhs(ruleid,pos,sym)VALUES(%d,%d,%d);\\n\",",
          "4241:               i,j,sp->subsym[k]->index",
          "4242:             );",
          "4243:           }",
          "4244:         }",
          "4245:       }",
          "4246:     }",
          "4247:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4697:   acttab_free(pActtab);",
          "4698:   fclose(in);",
          "4699:   fclose(out);",
          "4700:   return;",
          "4701: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4770:   if( sql ) fclose(sql);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68cb86ef23e3bc9e6362fec4937968a65ec025b5",
      "candidate_info": {
        "commit_hash": "68cb86ef23e3bc9e6362fec4937968a65ec025b5",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/68cb86ef23e3bc9e6362fec4937968a65ec025b5",
        "files": [
          "ext/misc/dbdata.c",
          "main.mk",
          "manifest",
          "manifest.uuid",
          "src/shell.c.in",
          "tool/mkshellc.tcl"
        ],
        "message": "Add the \".recovery\" command to the shell tool. For recovering the maximum amount data from corrupt databases. Still needs work.\n\nFossilOrigin-Name: 7461d2e120f2149315ddac2676d51d7445bcdb8e97543effd9c30603517ef9da",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "main.mk||main.mk",
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in",
          "tool/mkshellc.tcl||tool/mkshellc.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: #include \"sqlite3ext.h\"",
          "69: typedef unsigned char u8;",
          "72: #endif",
          "73: SQLITE_EXTENSION_INIT1",
          "",
          "[Removed Lines]",
          "66: #if !defined(SQLITEINT_H)",
          "70: typedef unsigned int u32;",
          "",
          "[Added Lines]",
          "66: #if !defined(SQLITEINT_H)",
          "70: typedef unsigned long u32;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:   u8 *pHdrPtr;",
          "100:   u8 *pPtr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "306:   return 9;",
          "307: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312: static int dbdataValueBytes(int eType){",
          "313:   switch( eType ){",
          "314:     case 0: case 8: case 9:",
          "315:     case 10: case 11:",
          "316:       return 0;",
          "317:     case 1:",
          "318:       return 1;",
          "319:     case 2:",
          "320:       return 2;",
          "321:     case 3:",
          "322:       return 3;",
          "323:     case 4:",
          "324:       return 4;",
          "325:     case 5:",
          "326:       return 6;",
          "327:     case 6:",
          "328:     case 7:",
          "329:       return 8;",
          "330:     default:",
          "331:       return ((eType-12) / 2);",
          "332:   }",
          "333: }",
          "335: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "336:   switch( eType ){",
          "337:     case 0:",
          "338:     case 10:",
          "339:     case 11:",
          "340:       sqlite3_result_null(pCtx);",
          "341:       break;",
          "343:     case 8:",
          "344:       sqlite3_result_int(pCtx, 0);",
          "345:       break;",
          "346:     case 9:",
          "347:       sqlite3_result_int(pCtx, 1);",
          "348:       break;",
          "350:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "351:       sqlite3_uint64 v = (signed char)pData[0];",
          "352:       pData++;",
          "353:       switch( eType ){",
          "354:         case 7:",
          "355:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "356:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "357:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "358:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "359:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "360:       }",
          "362:       if( eType==7 ){",
          "363:         double r;",
          "364:         memcpy(&r, &v, sizeof(r));",
          "365:         sqlite3_result_double(pCtx, r);",
          "366:       }else{",
          "367:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "368:       }",
          "369:       break;",
          "370:     }",
          "372:     default: {",
          "373:       int n = ((eType-12) / 2);",
          "374:       if( eType % 2 ){",
          "375:         sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "376:       }else{",
          "377:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "378:       }",
          "379:     }",
          "380:   }",
          "381: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "435:           }",
          "436:         }",
          "440:         iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);",
          "445:         }",
          "448:       }",
          "",
          "[Removed Lines]",
          "439:         pCsr->nField = 0;",
          "441:         while( iHdr<nHdr ){",
          "442:           sqlite3_int64 iDummy;",
          "443:           iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iDummy);",
          "444:           pCsr->nField++;",
          "447:         pCsr->iField = (bHasRowid ? -2 : -1);",
          "450:       pCsr->iField++;",
          "451:       if( pCsr->iField<pCsr->nField ) return SQLITE_OK;",
          "",
          "[Added Lines]",
          "514:         pCsr->nHdr = nHdr;",
          "515:         pCsr->pHdrPtr = &pCsr->pRec[iHdr];",
          "516:         pCsr->pPtr = &pCsr->pRec[pCsr->nHdr];",
          "517:         pCsr->iField = (bHasRowid ? -1 : 0);",
          "518:       }else{",
          "519:         pCsr->iField++;",
          "520:         if( pCsr->iField>0 ){",
          "521:           sqlite3_int64 iType;",
          "522:           pCsr->pHdrPtr += dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "523:           pCsr->pPtr += dbdataValueBytes(iType);",
          "527:       if( pCsr->iField<0 || pCsr->pHdrPtr<&pCsr->pRec[pCsr->nHdr] ){",
          "528:         return SQLITE_OK;",
          "529:       }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "485:   dbdataResetCursor(pCsr);",
          "486:   assert( pCsr->iPgno==1 );",
          "487:   if( idxNum & 0x01 ){",
          "489:   }",
          "490:   if( idxNum & 0x02 ){",
          "491:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);",
          "",
          "[Removed Lines]",
          "488:     zSchema = sqlite3_value_text(argv[0]);",
          "",
          "[Added Lines]",
          "566:     zSchema = (const char*)sqlite3_value_text(argv[0]);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "498:   );",
          "499:   if( rc==SQLITE_OK ){",
          "500:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);",
          "501:   }",
          "502:   if( rc==SQLITE_OK ){",
          "503:     rc = dbdataNext(pCursor);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "579:   }else{",
          "580:     pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(pTab->db));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "505:   return rc;",
          "506: }",
          "580: static int dbdataColumn(",
          "581:   sqlite3_vtab_cursor *pCursor,",
          "",
          "[Removed Lines]",
          "508: static int dbdataValueBytes(int eType){",
          "509:   switch( eType ){",
          "510:     case 0: case 8: case 9:",
          "511:     case 10: case 11:",
          "512:       return 0;",
          "513:     case 1:",
          "514:       return 1;",
          "515:     case 2:",
          "516:       return 2;",
          "517:     case 3:",
          "518:       return 3;",
          "519:     case 4:",
          "520:       return 4;",
          "521:     case 5:",
          "522:       return 6;",
          "523:     case 6:",
          "524:     case 7:",
          "525:       return 8;",
          "526:     default:",
          "527:       return ((eType-12) / 2);",
          "528:   }",
          "529: }",
          "531: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "532:   switch( eType ){",
          "533:     case 0:",
          "534:     case 10:",
          "535:     case 11:",
          "536:       sqlite3_result_null(pCtx);",
          "537:       break;",
          "539:     case 8:",
          "540:       sqlite3_result_int(pCtx, 0);",
          "541:       break;",
          "542:     case 9:",
          "543:       sqlite3_result_int(pCtx, 1);",
          "544:       break;",
          "546:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "547:       sqlite3_uint64 v = (signed char)pData[0];",
          "548:       pData++;",
          "549:       switch( eType ){",
          "550:         case 7:",
          "551:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "552:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "553:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "554:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "555:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "556:       }",
          "558:       if( eType==7 ){",
          "559:         double r;",
          "560:         memcpy(&r, &v, sizeof(r));",
          "561:         sqlite3_result_double(pCtx, r);",
          "562:       }else{",
          "563:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "564:       }",
          "565:       break;",
          "566:     }",
          "568:     default: {",
          "569:       int n = ((eType-12) / 2);",
          "570:       if( eType % 2 ){",
          "571:         sqlite3_result_text(pCtx, pData, n, SQLITE_TRANSIENT);",
          "572:       }else{",
          "573:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "574:       }",
          "575:     }",
          "576:   }",
          "577: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "616:         if( pCsr->iField<0 ){",
          "617:           sqlite3_result_int64(ctx, pCsr->iIntkey);",
          "618:         }else{",
          "620:           sqlite3_int64 iType;",
          "631:         }",
          "632:         break;",
          "633:       }",
          "",
          "[Removed Lines]",
          "619:           int iHdr;",
          "621:           sqlite3_int64 iOff;",
          "622:           int i;",
          "623:           iHdr = dbdataGetVarint(pCsr->pRec, &iOff);",
          "624:           for(i=0; i<pCsr->iField; i++){",
          "625:             iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "626:             iOff += dbdataValueBytes(iType);",
          "627:           }",
          "628:           dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "630:           dbdataValue(ctx, iType, &pCsr->pRec[iOff]);",
          "",
          "[Added Lines]",
          "629:           dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "630:           dbdataValue(ctx, iType, pCsr->pPtr);",
          "",
          "---------------"
        ],
        "main.mk||main.mk": [
          "File: main.mk -> main.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:  $(TOP)/ext/expert/sqlite3expert.h \\",
          "739:  $(TOP)/ext/misc/zipfile.c \\",
          "740:  $(TOP)/ext/misc/memtrace.c \\",
          "741:         $(TOP)/src/test_windirent.c",
          "743: shell.c: $(SHELL_SRC) $(TOP)/tool/mkshellc.tcl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741:  $(TOP)/ext/misc/dbdata.c \\",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3213a15f2133afbb0a4fec3b8f6e0eeca8c0befafd6658c41074e84f589d5d32",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "948: INCLUDE ../ext/expert/sqlite3expert.h",
          "949: INCLUDE ../ext/expert/sqlite3expert.c",
          "951: #if defined(SQLITE_ENABLE_SESSION)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951: INCLUDE ../ext/misc/dbdata.c",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3999:     sqlite3_fileio_init(p->db, 0, 0);",
          "4000:     sqlite3_shathree_init(p->db, 0, 0);",
          "4001:     sqlite3_completion_init(p->db, 0, 0);",
          "4002: #ifdef SQLITE_HAVE_ZLIB",
          "4003:     sqlite3_zipfile_init(p->db, 0, 0);",
          "4004:     sqlite3_sqlar_init(p->db, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4005:     sqlite3_dbdata_init(p->db, 0, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6033: static void shellExec(sqlite3 *db, int *pRc, const char *zSql){",
          "6034:   int rc = *pRc;",
          "6035:   if( rc==SQLITE_OK ){",
          "6036:     char *zErr = 0;",
          "6037:     rc = sqlite3_exec(db, zSql, 0, 0, &zErr);",
          "6038:     if( rc!=SQLITE_OK ){",
          "6039:       raw_printf(stderr, \"SQL error: %s\\n\", zErr);",
          "6040:     }",
          "6042:   }",
          "6043: }",
          "6045: static void *shellMalloc(int *pRc, sqlite3_int64 nByte){",
          "6046:   void *pRet = 0;",
          "6047:   if( *pRc==SQLITE_OK ){",
          "6048:     pRet = sqlite3_malloc64(nByte);",
          "6049:     if( pRet==0 ){",
          "6051:     }else{",
          "6052:       memset(pRet, 0, nByte);",
          "6053:     }",
          "6054:   }",
          "6055:   return pRet;",
          "6056: }",
          "6058: static char *shellMPrintf(int *pRc, const char *zFmt, ...){",
          "6059:   char *z = 0;",
          "6060:   if( *pRc==SQLITE_OK ){",
          "6061:     va_list ap;",
          "6062:     va_start(ap, zFmt);",
          "6063:     z = sqlite3_vmprintf(zFmt, ap);",
          "6064:     va_end(ap);",
          "6065:     if( z==0 ){",
          "6067:     }",
          "6068:   }",
          "6069:   return z;",
          "6070: }",
          "6072: typedef struct RecoverTable RecoverTable;",
          "6073: struct RecoverTable {",
          "6079: };",
          "6084: static void recoverFreeTable(RecoverTable *pTab){",
          "6085:   if( pTab ){",
          "6086:     sqlite3_free(pTab->zName);",
          "6087:     sqlite3_free(pTab->zQuoted);",
          "6088:     sqlite3_free(pTab->zCreate);",
          "6089:     if( pTab->azlCol ){",
          "6090:       int i;",
          "6091:       for(i=0; i<pTab->nCol; i++){",
          "6092:         sqlite3_free(pTab->azlCol[i]);",
          "6093:       }",
          "6094:       sqlite3_free(pTab->azlCol);",
          "6095:     }",
          "6096:     sqlite3_free(pTab);",
          "6097:   }",
          "6098: }",
          "6100: static RecoverTable *recoverNewTable(",
          "6101:   ShellState *pState,",
          "6102:   int *pRc,",
          "6103:   int iRoot,",
          "6104:   int nCol",
          "6105: ){",
          "6106:   RecoverTable *pRet = 0;",
          "6108:   pRet = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6109:   if( pRet ){",
          "6110:     sqlite3_stmt *pStmt = 0;",
          "6111:     pRet->zName = shellMPrintf(pRc, \"orphan_%d_%d\", nCol, iRoot);",
          "6112:     pRet->zQuoted = shellMPrintf(pRc, \"%Q\", pRet->zName);",
          "6113:     pRet->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * nCol);",
          "6114:     pRet->nCol = nCol;",
          "6116:     shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6117:       \"WITH s(i) AS (\"",
          "6118:       \"  SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<%d\"",
          "6119:       \")\"",
          "6120:       \"SELECT i-1, group_concat('c' || i, ', ') OVER (ORDER BY i) FROM s\",",
          "6121:       nCol",
          "6122:     );",
          "6123:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6124:       int idx = sqlite3_column_int(pStmt, 0);",
          "6125:       const char *zText = (const char*)sqlite3_column_text(pStmt, 1);",
          "6126:       pRet->azlCol[idx] = shellMPrintf(pRc, \"%s\", zText);",
          "6127:     }",
          "6128:     shellFinalize(pRc, pStmt);",
          "6130:     pRet->zCreate = shellMPrintf(pRc, \"CREATE TABLE %Q (id, %s)\",",
          "6131:         pRet->zName, pRet->azlCol[nCol-1]",
          "6132:     );",
          "6133:   }",
          "6135:   if( *pRc!=SQLITE_OK ){",
          "6136:     recoverFreeTable(pRet);",
          "6137:     pRet = 0;",
          "6138:   }",
          "6140:   return pRet;",
          "6141: }",
          "6148: static int recoverDatabaseCmd(ShellState *pState){",
          "6149:   const char *zSql;",
          "6150:   int rc = SQLITE_OK;",
          "6153:   shellExec(pState->db, &rc,",
          "6156:     \"ATTACH '' AS recovery;\"",
          "6157:     \"CREATE TABLE recovery.dbptr(\"",
          "6158:     \"      pgno, child, PRIMARY KEY(child, pgno)\"",
          "6159:     \") WITHOUT ROWID;\"",
          "6160:     \"INSERT OR IGNORE INTO dbptr(pgno, child) SELECT * FROM sqlite_dbptr;\"",
          "6164:     \"DELETE FROM recovery.dbptr WHERE child = 1;\"",
          "6169:     \"DELETE FROM recovery.dbptr WHERE child IN (\"",
          "6170:     \"  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1\"",
          "6171:     \");\"",
          "6176:     \"CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, maxlen INT, root INT);\"",
          "6181:     \"WITH pages(i, maxlen) AS (\"",
          "6182:     \"  SELECT page_count, max(field+1) \"",
          "6183:     \"      FROM pragma_page_count, sqlite_dbdata WHERE pgno=page_count\"",
          "6184:     \"    UNION ALL\"",
          "6185:     \"  SELECT * FROM (SELECT i-1, max(field+1)\"",
          "6186:     \"      FROM pages, sqlite_dbdata WHERE pgno=i-1 AND i>=2)\"",
          "6187:     \")\"",
          "6188:     \"INSERT INTO recovery.map(pgno, maxlen, root) SELECT i, maxlen, (\"",
          "6189:     \"    WITH p(orig, pgno, parent) AS (\"",
          "6190:     \"      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)\"",
          "6191:     \"        UNION ALL\"",
          "6192:     \"      SELECT i, p.parent, \"",
          "6193:     \"        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p\"",
          "6194:     \"    )\"",
          "6195:     \"    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)\"",
          "6196:     \") \"",
          "6197:     \"FROM pages WHERE maxlen > 0;\"",
          "6201:     \"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\"",
          "6202:     \"INSERT INTO recovery.schema SELECT \"",
          "6203:     \"  max(CASE WHEN field=0 THEN value ELSE NULL END),\"",
          "6204:     \"  max(CASE WHEN field=1 THEN value ELSE NULL END),\"",
          "6205:     \"  max(CASE WHEN field=2 THEN value ELSE NULL END),\"",
          "6206:     \"  max(CASE WHEN field=3 THEN value ELSE NULL END),\"",
          "6207:     \"  max(CASE WHEN field=4 THEN value ELSE NULL END)\"",
          "6208:     \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6209:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6210:     \")\"",
          "6211:     \"GROUP BY pgno, cell;\"",
          "6212:   );",
          "6214: #if 0",
          "6215:   zSql = \"SELECT type ||','|| name ||','|| tbl_name ||','|| rootpage ||','|| sql FROM recovery.schema;\";",
          "6216:   shellPrepare(pState->db, &rc, zSql, &pLoop);",
          "6217:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6218:     raw_printf(pState->out, \"%s\\n\", (const char*)sqlite3_column_text(pLoop, 0));",
          "6219:   }",
          "6220:   shellFinalize(&rc, pLoop);",
          "6221:   return rc;",
          "6222: #endif",
          "6225:   zSql = \"SELECT root,max(maxlen) FROM recovery.map WHERE root>1 GROUP BY root\";",
          "6226:   shellPrepare(pState->db, &rc, zSql, &pLoop);",
          "6227:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6228:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6229:     int nCol = sqlite3_column_int(pLoop, 1);",
          "6230:     RecoverTable *pTab;",
          "6232:     pTab = recoverNewTable(pState, &rc, iRoot, nCol);",
          "6233:     if( pTab ){",
          "6234:       sqlite3_stmt *pData = 0;",
          "6235:       raw_printf(pState->out, \"%s;\\n\", pTab->zCreate);",
          "6236:       shellPreparePrintf(pState->db, &rc, &pData,",
          "6237:         \"SELECT max(field), group_concat(quote(value), ', ') \"",
          "6238:         \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6239:         \"  SELECT pgno FROM recovery.map WHERE root=%d\"",
          "6240:         \")\"",
          "6241:         \"GROUP BY pgno, cell;\", iRoot",
          "6242:       );",
          "6243:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pData) ){",
          "6244:         int iMax = sqlite3_column_int(pData, 0);",
          "6245:         const char *zVal = (const char*)sqlite3_column_text(pData, 1);",
          "6246:         if( iMax+1==pTab->nCol ){",
          "6247:           raw_printf(pState->out, \"INSERT INTO %s VALUES( %s );\\n\",",
          "6248:               pTab->zQuoted, zVal);",
          "6249:         }else{",
          "6250:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6251:               pTab->zQuoted, pTab->azlCol[iMax], zVal",
          "6252:           );",
          "6253:         }",
          "6254:       }",
          "6255:       shellFinalize(&rc, pData);",
          "6256:     }",
          "6257:     recoverFreeTable(pTab);",
          "6258:   }",
          "6259:   shellFinalize(&rc, pLoop);",
          "6261:   sqlite3_exec(pState->db, \"DETACH recovery\", 0, 0, 0);",
          "6262:   return rc;",
          "6263: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6313:     rc = shell_dbinfo_command(p, nArg, azArg);",
          "6314:   }else",
          "6316:   if( c=='d' && strncmp(azArg[0], \"dump\", n)==0 ){",
          "6317:     const char *zLike = 0;",
          "6318:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6552:   if( c=='r' && strncmp(azArg[0], \"recover\", n)==0 ){",
          "6553:     open_db(p, 0);",
          "6554:     rc = recoverDatabaseCmd(p);",
          "6555:   }else",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6365:     p->nErr = 0;",
          "6366:     if( zLike==0 ){",
          "6367:       run_schema_dump_query(p,",
          "6371:       run_schema_dump_query(p,",
          "6375:       run_table_dump_query(p,",
          "6379:     }else{",
          "6380:       char *zSql;",
          "6381:       zSql = sqlite3_mprintf(",
          "6385:       run_schema_dump_query(p,zSql);",
          "6386:       sqlite3_free(zSql);",
          "6387:       zSql = sqlite3_mprintf(",
          "6392:       run_table_dump_query(p, zSql, 0);",
          "6393:       sqlite3_free(zSql);",
          "6394:     }",
          "",
          "[Removed Lines]",
          "6368:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6369:         \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "6370:       );",
          "6372:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6373:         \"WHERE name=='sqlite_sequence'\"",
          "6374:       );",
          "6376:         \"SELECT sql FROM sqlite_master \"",
          "6377:         \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "6378:       );",
          "6382:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6383:         \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "6384:         \"  AND sql NOT NULL\", zLike);",
          "6388:         \"SELECT sql FROM sqlite_master \"",
          "6389:         \"WHERE sql NOT NULL\"",
          "6390:         \"  AND type IN ('index','trigger','view')\"",
          "6391:         \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "[Added Lines]",
          "6611:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6612:           \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "6613:           );",
          "6615:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6616:           \"WHERE name=='sqlite_sequence'\"",
          "6617:           );",
          "6619:           \"SELECT sql FROM sqlite_master \"",
          "6620:           \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "6621:           );",
          "6625:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6626:           \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "6627:           \"  AND sql NOT NULL\", zLike);",
          "6631:           \"SELECT sql FROM sqlite_master \"",
          "6632:           \"WHERE sql NOT NULL\"",
          "6633:           \"  AND type IN ('index','trigger','view')\"",
          "6634:           \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6398:     }",
          "6399:     sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);",
          "6400:     sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);",
          "6402:     p->showHeader = savedShowHeader;",
          "6403:     p->shellFlgs = savedShellFlags;",
          "6404:   }else",
          "",
          "[Removed Lines]",
          "6401:     raw_printf(p->out, p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");",
          "",
          "[Added Lines]",
          "6644:     raw_printf(p->out, p->nErr?\"ROLLBACK; -- due to errors\\n\":\"COMMIT;\\n\");",
          "",
          "---------------"
        ],
        "tool/mkshellc.tcl||tool/mkshellc.tcl": [
          "File: tool/mkshellc.tcl -> tool/mkshellc.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   }",
          "41:   return $line",
          "42: }",
          "43: while {1} {",
          "44:   set lx [omit_redundant_typedefs [gets $in]]",
          "45:   if {[eof $in]} break;",
          "46:   if {[regexp {^INCLUDE } $lx]} {",
          "47:     set cfile [lindex $lx 1]",
          "48:     puts $out \"/************************* Begin $cfile ******************/\"",
          "49:     set in2 [open $topdir/src/$cfile rb]",
          "50:     while {![eof $in2]} {",
          "51:       set lx [omit_redundant_typedefs [gets $in2]]",
          "53:       if {[regexp {^# *include \"test_windirent.h\"} $lx]} {",
          "54:         set lx \"/* $lx */\"",
          "55:       }",
          "",
          "[Removed Lines]",
          "52:       if {[regexp {^#include \"sqlite} $lx]} continue",
          "",
          "[Added Lines]",
          "43: set iLine 0",
          "47:   incr iLine",
          "51:     puts $out \"#line 1 \\\"$cfile\\\"\"",
          "55:       if {[regexp {^#include \"sqlite} $lx]} {",
          "56:         set lx \"/* $lx */\"",
          "57:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     }",
          "59:     close $in2",
          "60:     puts $out \"/************************* End $cfile ********************/\"",
          "61:     continue",
          "62:   }",
          "63:   puts $out $lx",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:     puts $out \"#line [expr $iLine+1] \\\"shell.c.in\\\"\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bf00f6d7ece6a1e207e096a9a94e039594fb6d77",
      "candidate_info": {
        "commit_hash": "bf00f6d7ece6a1e207e096a9a94e039594fb6d77",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/bf00f6d7ece6a1e207e096a9a94e039594fb6d77",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/window.c"
        ],
        "message": "Enhanced VdbeCoverage() macros in the new windows function code.\n\nFossilOrigin-Name: f24066f8dd847dfb656f26c4a8142e7fb6a412ffe325aea6254cb122cfbb3e1c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: bb643bac535ac7d5fb4c13edb8782cd13540bbc7d2b2deb689f4ca8d1914f422",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1835:   sqlite3VdbeJumpHere(v, addrGe);",
          "1836:   sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1);",
          "1837:   sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);",
          "1840:   sqlite3ReleaseTempReg(pParse, reg1);",
          "1841:   sqlite3ReleaseTempReg(pParse, reg2);",
          "",
          "[Removed Lines]",
          "1838:   VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "1838:   assert( op==OP_Ge || op==OP_Gt || op==OP_Le );",
          "1839:   VdbeCoverageIf(v, op==OP_Ge);",
          "1840:   VdbeCoverageIf(v, op==OP_Gt);",
          "1841:   VdbeCoverageIf(v, op==OP_Le);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2533:   if( pMWin->eStart==pMWin->eEnd && regStart ){",
          "2534:     int op = ((pMWin->eStart==TK_FOLLOWING) ? OP_Ge : OP_Le);",
          "2535:     int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);",
          "2537:     windowAggFinal(&s, 0);",
          "2538:     sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);",
          "2539:     VdbeCoverageNeverTaken(v);",
          "",
          "[Removed Lines]",
          "2536:     VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "2539:     VdbeCoverageIf(v, op==OP_Ge);",
          "2540:     VdbeCoverageIf(v, op==OP_Le);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "012b15e2d7dfc7cc443a00e2d977c17d90160745",
      "candidate_info": {
        "commit_hash": "012b15e2d7dfc7cc443a00e2d977c17d90160745",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/012b15e2d7dfc7cc443a00e2d977c17d90160745",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/dbstat.c",
          "test/stat.test"
        ],
        "message": "Get the aggregate=TRUE feature working on the DBSTAT virtual  table.\n\nFossilOrigin-Name: 16fef3db063830884de46d53a289f637a7204fe84fcdee7ea81dbb8bca578952",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/dbstat.c||src/dbstat.c",
          "test/stat.test||test/stat.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9b5722f0fe666b99677e5f333dd8413aefb9ace7a461d74f6558f0ac53768719",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/dbstat.c||src/dbstat.c": [
          "File: src/dbstat.c -> src/dbstat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: typedef struct StatTable StatTable;",
          "",
          "[Removed Lines]",
          "59: #define VTAB_SCHEMA                                                          \\",
          "60:   \"CREATE TABLE xx( \"                                                        \\",
          "61:   \"  name       TEXT,\"          /*  0 Name of table or index */              \\",
          "62:   \"  path       TEXT,\"          /*  1 Path to page from root */              \\",
          "63:   \"  pageno     INTEGER,\"       /*  2 Page number */                         \\",
          "64:   \"  pagetype   TEXT,\"          /*  3 'internal', 'leaf' or 'overflow' */    \\",
          "65:   \"  ncell      INTEGER,\"       /*  4 Cells on page (0 for overflow) */      \\",
          "66:   \"  payload    INTEGER,\"       /*  5 Bytes of payload on this page */       \\",
          "67:   \"  unused     INTEGER,\"       /*  6 Bytes of unused space on this page */  \\",
          "68:   \"  mx_payload INTEGER,\"       /*  7 Largest payload size of all cells */   \\",
          "69:   \"  pgoffset   INTEGER,\"       /*  8 Offset of page in file */              \\",
          "70:   \"  pgsize     INTEGER,\"       /*  9 Size of the page */                    \\",
          "71:   \"  schema     TEXT HIDDEN,\"   /* 10 Database schema being analyzed */      \\",
          "72:   \"  aggregate  BOOLEAN HIDDEN\" /* 11 aggregate info for each table */       \\",
          "73:   \");\"",
          "",
          "[Added Lines]",
          "59: static const char zDbstatSchema[] =",
          "60:   \"CREATE TABLE x(\"",
          "73:   \")\"",
          "74: ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "165:   }else{",
          "166:     iDb = 0;",
          "167:   }",
          "169:   if( rc==SQLITE_OK ){",
          "170:     pTab = (StatTable *)sqlite3_malloc64(sizeof(StatTable));",
          "171:     if( pTab==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Removed Lines]",
          "168:   rc = sqlite3_declare_vtab(db, VTAB_SCHEMA);",
          "",
          "[Added Lines]",
          "170:   rc = sqlite3_declare_vtab(db, zDbstatSchema);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "323:   pCsr->isEof = 0;",
          "324: }",
          "329: static int statClose(sqlite3_vtab_cursor *pCursor){",
          "330:   StatCursor *pCsr = (StatCursor *)pCursor;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329: static void statResetCounts(StatCursor *pCsr){",
          "330:   pCsr->nCell = 0;",
          "331:   pCsr->nMxPayload = 0;",
          "332:   pCsr->nUnused = 0;",
          "333:   pCsr->nPayload = 0;",
          "334:   pCsr->szPage = 0;",
          "335:   pCsr->nPage = 0;",
          "336: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "481:   sqlite3_file *fd;",
          "482:   sqlite3_int64 x[2];",
          "491:   fd = sqlite3PagerFile(pPager);",
          "492:   x[0] = pCsr->iPageno;",
          "493:   if( sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){",
          "494:     pCsr->iOffset = x[0];",
          "496:   }",
          "497: }",
          "502: static int statNext(sqlite3_vtab_cursor *pCursor){",
          "503:   int rc;",
          "",
          "[Removed Lines]",
          "485:   pCsr->szPage = sqlite3BtreeGetPageSize(pBt);",
          "486:   pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "495:     pCsr->szPage = (int)x[1];",
          "",
          "[Added Lines]",
          "506:     pCsr->szPage += x[1];",
          "507:   }else{",
          "509:     pCsr->szPage += sqlite3BtreeGetPageSize(pBt);",
          "510:     pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "514: statNextRestart:",
          "515:   if( pCsr->aPage[0].pPg==0 ){",
          "516:     rc = sqlite3_step(pCsr->pStmt);",
          "517:     if( rc==SQLITE_ROW ){",
          "518:       int nPage;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:     statResetCounts(pCsr);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "525:       rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg, 0);",
          "526:       pCsr->aPage[0].iPgno = iRoot;",
          "527:       pCsr->aPage[0].iCell = 0;",
          "529:       pCsr->iPage = 0;",
          "531:     }else{",
          "532:       pCsr->isEof = 1;",
          "533:       return sqlite3_reset(pCsr->pStmt);",
          "534:     }",
          "535:   }else{",
          "538:     StatPage *p = &pCsr->aPage[pCsr->iPage];",
          "540:     while( p->iCell<p->nCell ){",
          "541:       StatCell *pCell = &p->aCell[p->iCell];",
          "544:         sqlite3BtreeEnter(pBt);",
          "545:         nUsable = sqlite3BtreeGetPageSize(pBt) -",
          "546:                         sqlite3BtreeGetReserveNoMutex(pBt);",
          "547:         sqlite3BtreeLeave(pBt);",
          "556:         if( pCell->iOvfl<pCell->nOvfl-1 ){",
          "559:         }else{",
          "562:         }",
          "563:         pCell->iOvfl++;",
          "566:       }",
          "567:       if( p->iRightChildPg ) break;",
          "568:       p->iCell++;",
          "",
          "[Removed Lines]",
          "528:       pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "530:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "542:       if( pCell->iOvfl<pCell->nOvfl ){",
          "543:         int nUsable;",
          "548:         pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "549:         pCsr->iPageno = pCell->aOvfl[pCell->iOvfl];",
          "550:         pCsr->zPagetype = \"overflow\";",
          "551:         pCsr->nCell = 0;",
          "552:         pCsr->nMxPayload = 0;",
          "553:         pCsr->zPath = z = sqlite3_mprintf(",
          "554:             \"%s%.3x+%.6x\", p->zPath, p->iCell, pCell->iOvfl",
          "555:         );",
          "557:           pCsr->nUnused = 0;",
          "558:           pCsr->nPayload = nUsable - 4;",
          "560:           pCsr->nPayload = pCell->nLastOvfl;",
          "561:           pCsr->nUnused = nUsable - 4 - pCsr->nPayload;",
          "564:         statSizeAndOffset(pCsr);",
          "565:         return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "",
          "[Added Lines]",
          "547:       if( !pCsr->isAgg ){",
          "548:         pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "549:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "550:       }",
          "552:       pCsr->nPage = 1;",
          "560:     if( !pCsr->isAgg ) statResetCounts(pCsr);",
          "563:       while( pCell->iOvfl<pCell->nOvfl ){",
          "564:         int nUsable, iOvfl;",
          "569:         pCsr->nPage++;",
          "570:         statSizeAndOffset(pCsr);",
          "572:           pCsr->nPayload += nUsable - 4;",
          "574:           pCsr->nPayload += pCell->nLastOvfl;",
          "575:           pCsr->nUnused += nUsable - 4 - pCell->nLastOvfl;",
          "577:         iOvfl = pCell->iOvfl;",
          "579:         if( !pCsr->isAgg ){",
          "580:           pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "581:           pCsr->iPageno = pCell->aOvfl[iOvfl];",
          "582:           pCsr->zPagetype = \"overflow\";",
          "583:           pCsr->zPath = z = sqlite3_mprintf(",
          "584:               \"%s%.3x+%.6x\", p->zPath, p->iCell, iOvfl",
          "585:           );",
          "586:           return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "587:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "571:     if( !p->iRightChildPg || p->iCell>p->nCell ){",
          "572:       statClearPage(p);",
          "576:     }",
          "577:     pCsr->iPage++;",
          "",
          "[Removed Lines]",
          "573:       if( pCsr->iPage==0 ) return statNext(pCursor);",
          "574:       pCsr->iPage--;",
          "",
          "[Added Lines]",
          "595:       if( pCsr->iPage>0 ){",
          "596:         pCsr->iPage--;",
          "597:       }else if( pCsr->isAgg ){",
          "600:         return SQLITE_OK;",
          "601:       }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "587:       p[1].iPgno = p->aCell[p->iCell].iChildPg;",
          "588:     }",
          "589:     rc = sqlite3PagerGet(pPager, p[1].iPgno, &p[1].pPg, 0);",
          "590:     p[1].iCell = 0;",
          "592:     p->iCell++;",
          "594:   }",
          "",
          "[Removed Lines]",
          "591:     p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "593:     if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Added Lines]",
          "617:     pCsr->nPage++;",
          "619:     if( !pCsr->isAgg ){",
          "620:       p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "621:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "622:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "620:           pCsr->zPagetype = \"corrupted\";",
          "621:           break;",
          "622:       }",
          "628:       nPayload = 0;",
          "629:       for(i=0; i<p->nCell; i++){",
          "630:         nPayload += p->aCell[i].nLocal;",
          "631:       }",
          "633:     }",
          "634:   }",
          "",
          "[Removed Lines]",
          "623:       pCsr->nCell = p->nCell;",
          "624:       pCsr->nUnused = p->nUnused;",
          "625:       pCsr->nMxPayload = p->nMxPayload;",
          "626:       pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "627:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "632:       pCsr->nPayload = nPayload;",
          "",
          "[Added Lines]",
          "653:       pCsr->nCell += p->nCell;",
          "654:       pCsr->nUnused += p->nUnused;",
          "655:       if( p->nMxPayload>pCsr->nMxPayload ) pCsr->nMxPayload = p->nMxPayload;",
          "656:       if( !pCsr->isAgg ){",
          "657:         pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "658:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "659:       }",
          "664:       pCsr->nPayload += nPayload;",
          "669:       if( pCsr->isAgg ) goto statNextRestart;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "722:       sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_TRANSIENT);",
          "723:       break;",
          "726:       break;",
          "729:       break;",
          "732:       break;",
          "734:       sqlite3_result_int(ctx, pCsr->nCell);",
          "",
          "[Removed Lines]",
          "725:       sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "728:       sqlite3_result_int64(ctx, pCsr->iPageno);",
          "731:       sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "",
          "[Added Lines]",
          "762:       if( !pCsr->isAgg ){",
          "763:         sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "764:       }",
          "767:       if( pCsr->isAgg ){",
          "768:         sqlite3_result_int64(ctx, pCsr->nPage);",
          "769:       }else{",
          "770:         sqlite3_result_int64(ctx, pCsr->iPageno);",
          "771:       }",
          "774:       if( !pCsr->isAgg ){",
          "775:         sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "776:       }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "743:       sqlite3_result_int(ctx, pCsr->nMxPayload);",
          "744:       break;",
          "747:       break;",
          "749:       sqlite3_result_int(ctx, pCsr->szPage);",
          "",
          "[Removed Lines]",
          "746:       sqlite3_result_int64(ctx, pCsr->iOffset);",
          "",
          "[Added Lines]",
          "791:       if( !pCsr->isAgg ){",
          "792:         sqlite3_result_int64(ctx, pCsr->iOffset);",
          "793:       }",
          "",
          "---------------"
        ],
        "test/stat.test||test/stat.test": [
          "File: test/stat.test -> test/stat.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:   t3 /00f/ 23 leaf 2 738 268 370                         \\",
          "135: ]",
          "137: # With every index entry overflowing, make sure no pages are missed",
          "138: # (other than the locking page which is 64 in this test build.)",
          "139: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: do_execsql_test stat-2.1agg {",
          "138:   SELECT * FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "139: } [list \\",
          "140:   sqlite_autoindex_t3_1 {}  5 {} 32  3898 1065 132 {}  5120 \\",
          "141:   sqlite_master         {}  1 {}  2    84  824  49 {}  1024 \\",
          "142:   t3                    {} 17 {} 47 11188 5815 370 {} 17408 \\",
          "143: ]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171:   t4 /000+000006 18 overflow 0 1020 0 0      \\",
          "172: ]",
          "174: do_execsql_test stat-4.1 {",
          "175:   CREATE TABLE t5(x);",
          "176:   CREATE INDEX i5 ON t5(x);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: do_execsql_test stat-3.2 {",
          "183:   SELECT *, '|' FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "184: } [list \\",
          "185:   i4            {} 9 {} 1 7782 1386 7782 {} 9216 | \\",
          "186:   sqlite_master {} 1 {} 2   74  834   40 {} 1024 | \\",
          "187:   t4            {} 8 {} 1 7780  367 7780 {} 8192 | \\",
          "188: ]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "201:   t1 /001+000000 4 overflow 0 1020 0 0    \\",
          "202: ]",
          "204: do_catchsql_test stat-6.1 {",
          "205:   CREATE VIRTUAL TABLE temp.s2 USING dbstat(mainx);",
          "206: } {1 {no such database: mainx}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221: do_execsql_test stat-5.20 {",
          "222:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "223:          unused, mx_payload, '|' FROM dbstat('main',1);",
          "224: } {sqlite_master NULL 1 NULL 1 34 878 34 | tx NULL 1 NULL 0 0 1016 0 |}",
          "225: do_execsql_test stat-5.21 {",
          "226:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "227:          unused, mx_payload, '|' FROM dbstat('aux1',1);",
          "228: } {sqlite_master NULL 1 NULL 1 34 878 34 | t1 NULL 3 NULL 2 3033 5 1517 |}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ed26483346dc9b6925330e45786bf589735ddbf0",
      "candidate_info": {
        "commit_hash": "ed26483346dc9b6925330e45786bf589735ddbf0",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ed26483346dc9b6925330e45786bf589735ddbf0",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test_fs.c"
        ],
        "message": "We learn that readdir_r() is deprecated in favor of plain old readdir(), which is now suppose to be threadsafe using thread-local storage.  So remove the use of readdir_r() from the test code.  (SQLite itself never calls readdir() or readdir_r()).\n\nFossilOrigin-Name: 7a0a26ed380dd0bdda50b0204b30b53bbbbc70f278eba02f91541ac6c691aef2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test_fs.c||src/test_fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b99f8512c06b9d47e48b028781265512ce8b812ae4e6af0a7139a093cf9a8f74",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_fs.c||src/test_fs.c": [
          "File: src/test_fs.c -> src/test_fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:   if( pCsr->pDir ){",
          "239:     struct DIRENT *pRes = 0;",
          "241:     pRes = readdir(pCsr->pDir);",
          "242:     if( pRes!=0 ){",
          "243:       memcpy(&pCsr->entry, pRes, sizeof(struct DIRENT));",
          "244:     }",
          "248:     if( pRes==0 ){",
          "249:       closedir(pCsr->pDir);",
          "250:       pCsr->pDir = 0;",
          "",
          "[Removed Lines]",
          "240: #if defined(__MINGW_H)",
          "245: #else",
          "246:     readdir_r(pCsr->pDir, &pCsr->entry, &pRes);",
          "247: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
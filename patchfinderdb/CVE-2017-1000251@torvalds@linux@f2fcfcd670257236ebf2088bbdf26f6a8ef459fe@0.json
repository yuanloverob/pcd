{
  "cve_id": "CVE-2017-1000251",
  "cve_desc": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.",
  "repo": "torvalds/linux",
  "patch_hash": "f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
  "patch_info": {
    "commit_hash": "f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
    "files": [
      "include/net/bluetooth/l2cap.h",
      "net/bluetooth/l2cap.c"
    ],
    "message": "Bluetooth: Add configuration support for ERTM and Streaming mode\n\nAdd support to config_req and config_rsp to configure ERTM and Streaming\nmode. If the remote device specifies ERTM or Streaming mode, then the\nsame mode is proposed. Otherwise ERTM or Basic mode is used. And in case\nof a state 2 device, the remote device should propose the same mode. If\nnot, then the channel gets disconnected.\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
    "before_after_code_files": [
      "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
      "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
    ]
  },
  "patch_diff": {
    "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
      "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #define L2CAP_DEFAULT_MTU  672",
      "30: #define L2CAP_DEFAULT_FLUSH_TO  0xffff",
      "32: #define L2CAP_DEFAULT_MAX_RECEIVE 1",
      "",
      "[Removed Lines]",
      "31: #define L2CAP_DEFAULT_RX_WINDOW  1",
      "",
      "[Added Lines]",
      "30: #define L2CAP_DEFAULT_MIN_MTU  48",
      "32: #define L2CAP_DEFAULT_TX_WINDOW  1",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "272:  __u16  omtu;",
      "273:  __u16  flush_to;",
      "274:  __u8  mode;",
      "275:  __u8  fcs;",
      "276:  __u8  sec_level;",
      "277:  __u8  role_switch;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "276:  __u8  num_conf_req;",
      "277:  __u8  num_conf_rsp;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "280:  __u8  conf_req[64];",
      "281:  __u8  conf_len;",
      "282:  __u8  conf_state;",
      "285:  __u8  ident;",
      "287:  __le16  sport;",
      "289:  struct l2cap_conn *conn;",
      "",
      "[Removed Lines]",
      "283:  __u8  conf_retry;",
      "",
      "[Added Lines]",
      "290:  __u8  remote_tx_win;",
      "291:  __u8  remote_max_tx;",
      "292:  __u16  retrans_timeout;",
      "293:  __u16  monitor_timeout;",
      "294:  __u16  max_pdu_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "291:  struct sock  *prev_c;",
      "292: };",
      "301: void l2cap_load(void);",
      "",
      "[Removed Lines]",
      "294: #define L2CAP_CONF_REQ_SENT 0x01",
      "295: #define L2CAP_CONF_INPUT_DONE 0x02",
      "296: #define L2CAP_CONF_OUTPUT_DONE 0x04",
      "297: #define L2CAP_CONF_CONNECT_PEND 0x80",
      "299: #define L2CAP_CONF_MAX_RETRIES 2",
      "",
      "[Added Lines]",
      "303: #define L2CAP_CONF_REQ_SENT       0x01",
      "304: #define L2CAP_CONF_INPUT_DONE     0x02",
      "305: #define L2CAP_CONF_OUTPUT_DONE    0x04",
      "306: #define L2CAP_CONF_MTU_DONE       0x08",
      "307: #define L2CAP_CONF_MODE_DONE      0x10",
      "308: #define L2CAP_CONF_CONNECT_PEND   0x20",
      "309: #define L2CAP_CONF_STATE2_DEVICE  0x80",
      "311: #define L2CAP_CONF_MAX_CONF_REQ 2",
      "312: #define L2CAP_CONF_MAX_CONF_RSP 2",
      "",
      "---------------"
    ],
    "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
      "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "966:  case L2CAP_MODE_BASIC:",
      "967:   break;",
      "968:  case L2CAP_MODE_ERTM:",
      "969:   if (enable_ertm)",
      "970:    break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "969:  case L2CAP_MODE_STREAMING:",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1029:  case L2CAP_MODE_BASIC:",
      "1030:   break;",
      "1031:  case L2CAP_MODE_ERTM:",
      "1032:   if (enable_ertm)",
      "1033:    break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1033:  case L2CAP_MODE_STREAMING:",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1740: }",
      "1742: static int l2cap_build_conf_req(struct sock *sk, void *data)",
      "1743: {",
      "1744:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
      "1745:  struct l2cap_conf_req *req = data;",
      "1747:  void *ptr = req->data;",
      "1749:  BT_DBG(\"sk %p\", sk);",
      "1751:  switch (pi->mode) {",
      "1752:  case L2CAP_MODE_BASIC:",
      "1753:   if (pi->imtu != L2CAP_DEFAULT_MTU)",
      "",
      "[Removed Lines]",
      "1746:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };",
      "",
      "[Added Lines]",
      "1744: static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)",
      "1745: {",
      "1746:  u32 local_feat_mask = l2cap_feat_mask;",
      "1747:  if (enable_ertm)",
      "1748:   local_feat_mask |= L2CAP_FEAT_ERTM;",
      "1750:  switch (mode) {",
      "1751:  case L2CAP_MODE_ERTM:",
      "1752:   return L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;",
      "1753:  case L2CAP_MODE_STREAMING:",
      "1754:   return L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;",
      "1755:  default:",
      "1756:   return 0x00;",
      "1757:  }",
      "1758: }",
      "1760: static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)",
      "1761: {",
      "1762:  switch (mode) {",
      "1763:  case L2CAP_MODE_STREAMING:",
      "1764:  case L2CAP_MODE_ERTM:",
      "1765:   if (l2cap_mode_supported(mode, remote_feat_mask))",
      "1766:    return mode;",
      "1768:  default:",
      "1769:   return L2CAP_MODE_BASIC;",
      "1770:  }",
      "1771: }",
      "1777:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_ERTM };",
      "1782:  if (pi->num_conf_req || pi->num_conf_rsp)",
      "1783:   goto done;",
      "1785:  switch (pi->mode) {",
      "1786:  case L2CAP_MODE_STREAMING:",
      "1787:  case L2CAP_MODE_ERTM:",
      "1788:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
      "1789:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) {",
      "1790:    struct l2cap_disconn_req req;",
      "1791:    req.dcid = cpu_to_le16(pi->dcid);",
      "1792:    req.scid = cpu_to_le16(pi->scid);",
      "1793:    l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn),",
      "1794:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "1795:   }",
      "1796:   break;",
      "1797:  default:",
      "1798:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
      "1799:   break;",
      "1800:  }",
      "1802: done:",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1757:  case L2CAP_MODE_ERTM:",
      "1758:   rfc.mode            = L2CAP_MODE_ERTM;",
      "1760:   rfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;",
      "1763:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
      "1765:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "",
      "[Removed Lines]",
      "1759:   rfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;",
      "1761:   rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);",
      "1762:   rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);",
      "",
      "[Added Lines]",
      "1811:   rfc.txwin_size      = L2CAP_DEFAULT_TX_WINDOW;",
      "1813:   rfc.retrans_timeout = 0;",
      "1814:   rfc.monitor_timeout = 0;",
      "1815:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
      "1817:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1818:      sizeof(rfc), (unsigned long) &rfc);",
      "1819:   break;",
      "1821:  case L2CAP_MODE_STREAMING:",
      "1822:   rfc.mode            = L2CAP_MODE_STREAMING;",
      "1823:   rfc.txwin_size      = 0;",
      "1824:   rfc.max_transmit    = 0;",
      "1825:   rfc.retrans_timeout = 0;",
      "1826:   rfc.monitor_timeout = 0;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1825:   }",
      "1826:  }",
      "1828:  if (result == L2CAP_CONF_SUCCESS) {",
      "1842:    result = L2CAP_CONF_UNACCEPT;",
      "1844:    memset(&rfc, 0, sizeof(rfc));",
      "1848:      sizeof(rfc), (unsigned long) &rfc);",
      "1852:  rsp->scid   = cpu_to_le16(pi->dcid);",
      "1853:  rsp->result = cpu_to_le16(result);",
      "1854:  rsp->flags  = cpu_to_le16(0x0000);",
      "",
      "[Removed Lines]",
      "1832:   if (rfc.mode == L2CAP_MODE_BASIC) {",
      "1833:    if (mtu < pi->omtu)",
      "1834:     result = L2CAP_CONF_UNACCEPT;",
      "1835:    else {",
      "1836:     pi->omtu = mtu;",
      "1837:     pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;",
      "1838:    }",
      "1840:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1841:   } else {",
      "1845:    rfc.mode = L2CAP_MODE_BASIC;",
      "1847:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1849:   }",
      "1850:  }",
      "",
      "[Added Lines]",
      "1892:  if (pi->num_conf_rsp || pi->num_conf_req)",
      "1893:   goto done;",
      "1895:  switch (pi->mode) {",
      "1896:  case L2CAP_MODE_STREAMING:",
      "1897:  case L2CAP_MODE_ERTM:",
      "1898:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
      "1899:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
      "1900:    return -ECONNREFUSED;",
      "1901:   break;",
      "1902:  default:",
      "1903:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
      "1904:   break;",
      "1905:  }",
      "1907: done:",
      "1908:  if (pi->mode != rfc.mode) {",
      "1909:   result = L2CAP_CONF_UNACCEPT;",
      "1910:   rfc.mode = pi->mode;",
      "1912:   if (pi->num_conf_rsp == 1)",
      "1913:    return -ECONNREFUSED;",
      "1915:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1916:      sizeof(rfc), (unsigned long) &rfc);",
      "1917:  }",
      "1924:   if (mtu < L2CAP_DEFAULT_MIN_MTU)",
      "1925:    result = L2CAP_CONF_UNACCEPT;",
      "1926:   else {",
      "1927:    pi->omtu = mtu;",
      "1928:    pi->conf_state |= L2CAP_CONF_MTU_DONE;",
      "1929:   }",
      "1930:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1932:   switch (rfc.mode) {",
      "1933:   case L2CAP_MODE_BASIC:",
      "1934:    pi->fcs = L2CAP_FCS_NONE;",
      "1935:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1936:    break;",
      "1938:   case L2CAP_MODE_ERTM:",
      "1939:    pi->remote_tx_win = rfc.txwin_size;",
      "1940:    pi->remote_max_tx = rfc.max_transmit;",
      "1941:    pi->max_pdu_size = rfc.max_pdu_size;",
      "1943:    rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;",
      "1944:    rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;",
      "1946:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1947:    break;",
      "1949:   case L2CAP_MODE_STREAMING:",
      "1950:    pi->remote_tx_win = rfc.txwin_size;",
      "1951:    pi->max_pdu_size = rfc.max_pdu_size;",
      "1953:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1954:    break;",
      "1956:   default:",
      "1960:    rfc.mode = pi->mode;",
      "1961:   }",
      "1963:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1966:   if (result == L2CAP_CONF_SUCCESS)",
      "1967:    pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;",
      "1968:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1856:  return ptr - data;",
      "1857: }",
      "1859: static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)",
      "1860: {",
      "1861:  struct l2cap_conf_rsp *rsp = data;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1976: static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)",
      "1977: {",
      "1978:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
      "1979:  struct l2cap_conf_req *req = data;",
      "1980:  void *ptr = req->data;",
      "1981:  int type, olen;",
      "1982:  unsigned long val;",
      "1983:  struct l2cap_conf_rfc rfc;",
      "1985:  BT_DBG(\"sk %p, rsp %p, len %d, req %p\", sk, rsp, len, data);",
      "1987:  while (len >= L2CAP_CONF_OPT_SIZE) {",
      "1988:   len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);",
      "1990:   switch (type) {",
      "1991:   case L2CAP_CONF_MTU:",
      "1992:    if (val < L2CAP_DEFAULT_MIN_MTU) {",
      "1994:     pi->omtu = L2CAP_DEFAULT_MIN_MTU;",
      "1995:    } else",
      "1996:     pi->omtu = val;",
      "1997:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1998:    break;",
      "2000:   case L2CAP_CONF_FLUSH_TO:",
      "2001:    pi->flush_to = val;",
      "2002:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,",
      "2003:        2, pi->flush_to);",
      "2004:    break;",
      "2006:   case L2CAP_CONF_RFC:",
      "2007:    if (olen == sizeof(rfc))",
      "2008:     memcpy(&rfc, (void *)val, olen);",
      "2010:    if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&",
      "2011:        rfc.mode != pi->mode)",
      "2012:     return -ECONNREFUSED;",
      "2014:    pi->mode = rfc.mode;",
      "2015:    pi->fcs = 0;",
      "2017:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "2018:      sizeof(rfc), (unsigned long) &rfc);",
      "2019:    break;",
      "2020:   }",
      "2021:  }",
      "2023:  if (*result == L2CAP_CONF_SUCCESS) {",
      "2024:   switch (rfc.mode) {",
      "2025:   case L2CAP_MODE_ERTM:",
      "2026:    pi->remote_tx_win   = rfc.txwin_size;",
      "2027:    pi->retrans_timeout = rfc.retrans_timeout;",
      "2028:    pi->monitor_timeout = rfc.monitor_timeout;",
      "2029:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
      "2030:    break;",
      "2031:   case L2CAP_MODE_STREAMING:",
      "2032:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
      "2033:    break;",
      "2034:   }",
      "2035:  }",
      "2037:  req->dcid   = cpu_to_le16(pi->dcid);",
      "2038:  req->flags  = cpu_to_le16(0x0000);",
      "2040:  return ptr - data;",
      "2041: }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2043:   l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2044:      l2cap_build_conf_req(sk, req), req);",
      "2045:   break;",
      "2047:  case L2CAP_CR_PEND:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2229:   l2cap_pi(sk)->num_conf_req++;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2102:  len = l2cap_parse_conf_req(sk, rsp);",
      "2104:   goto unlock;",
      "2106:  l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);",
      "2109:  l2cap_pi(sk)->conf_len = 0;",
      "",
      "[Removed Lines]",
      "2103:  if (len < 0)",
      "",
      "[Added Lines]",
      "2288:  if (len < 0) {",
      "2289:   struct l2cap_disconn_req req;",
      "2290:   req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
      "2291:   req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
      "2292:   l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2293:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "2295:  }",
      "2298:  l2cap_pi(sk)->num_conf_rsp++;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2121:   u8 buf[64];",
      "2122:   l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2123:      l2cap_build_conf_req(sk, buf), buf);",
      "2124:  }",
      "2126: unlock:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2316:   l2cap_pi(sk)->num_conf_req++;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2150:   break;",
      "2152:  case L2CAP_CONF_UNACCEPT:",
      "2163:   }",
      "2165:  default:",
      "",
      "[Removed Lines]",
      "2153:   if (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {",
      "2154:    char req[128];",
      "2160:    l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2161:       l2cap_build_conf_req(sk, req), req);",
      "2162:    goto done;",
      "",
      "[Added Lines]",
      "2346:   if (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {",
      "2347:    int len = cmd->len - sizeof(*rsp);",
      "2348:    char req[64];",
      "2351:    result = L2CAP_CONF_SUCCESS;",
      "2352:    len = l2cap_parse_conf_rsp(sk, rsp->data,",
      "2353:        len, req, &result);",
      "2354:    if (len < 0) {",
      "2355:     struct l2cap_disconn_req req;",
      "2356:     req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
      "2357:     req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
      "2358:     l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2359:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "2360:     goto done;",
      "2361:    }",
      "2363:    l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2364:       L2CAP_CONF_REQ, len, req);",
      "2365:    l2cap_pi(sk)->num_conf_req++;",
      "2366:    if (result != L2CAP_CONF_SUCCESS)",
      "2367:     goto done;",
      "2368:    break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f66dc81f44d918ee1aa1a9d821bb2f25c7592bc0",
      "candidate_info": {
        "commit_hash": "f66dc81f44d918ee1aa1a9d821bb2f25c7592bc0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f66dc81f44d918ee1aa1a9d821bb2f25c7592bc0",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Add support for deferring L2CAP connection setup\n\nIn order to decide if listening L2CAP sockets should be accept()ed\nthe BD_ADDR of the remote device needs to be known. This patch adds\na socket option which defines a timeout for deferring the actual\nconnection setup.\n\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "372:    rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);",
          "374:    if (l2cap_check_link_mode(sk)) {",
          "378:    } else {",
          "379:     rsp.result = cpu_to_le16(L2CAP_CR_PEND);",
          "380:     rsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);",
          "",
          "[Removed Lines]",
          "375:     sk->sk_state = BT_CONFIG;",
          "376:     rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);",
          "377:     rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);",
          "",
          "[Added Lines]",
          "375:     if (bt_sk(sk)->defer_setup) {",
          "376:      struct sock *parent = bt_sk(sk)->parent;",
          "377:      rsp.result = cpu_to_le16(L2CAP_CR_PEND);",
          "378:      rsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);",
          "379:      parent->sk_data_ready(parent, 0);",
          "381:     } else {",
          "382:      sk->sk_state = BT_CONFIG;",
          "383:      rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);",
          "384:      rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);",
          "385:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "609:  case BT_CONNECTED:",
          "610:  case BT_CONFIG:",
          "612:   if (sk->sk_type == SOCK_SEQPACKET) {",
          "613:    struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "614:    struct l2cap_disconn_req req;",
          "",
          "[Removed Lines]",
          "611:  case BT_CONNECT2:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "624:    l2cap_chan_del(sk, reason);",
          "625:   break;",
          "627:  case BT_CONNECT:",
          "628:  case BT_DISCONN:",
          "629:   l2cap_chan_del(sk, reason);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "634:  case BT_CONNECT2:",
          "635:   if (sk->sk_type == SOCK_SEQPACKET) {",
          "636:    struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "637:    struct l2cap_conn_rsp rsp;",
          "638:    __u16 result;",
          "640:    if (bt_sk(sk)->defer_setup)",
          "641:     result = L2CAP_CR_SEC_BLOCK;",
          "642:    else",
          "643:     result = L2CAP_CR_BAD_PSM;",
          "645:    rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "646:    rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);",
          "647:    rsp.result = cpu_to_le16(result);",
          "648:    rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);",
          "649:    l2cap_send_cmd(conn, l2cap_pi(sk)->ident,",
          "650:      L2CAP_CONN_RSP, sizeof(rsp), &rsp);",
          "651:   } else",
          "652:    l2cap_chan_del(sk, reason);",
          "653:   break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "654:  if (parent) {",
          "655:   sk->sk_type = parent->sk_type;",
          "656:   pi->imtu = l2cap_pi(parent)->imtu;",
          "657:   pi->omtu = l2cap_pi(parent)->omtu;",
          "658:   pi->link_mode = l2cap_pi(parent)->link_mode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "684:   bt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1106:  return err;",
          "1107: }",
          "1109: static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, int optlen)",
          "1110: {",
          "1111:  struct sock *sk = sock->sk;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1139: static int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)",
          "1140: {",
          "1141:  struct sock *sk = sock->sk;",
          "1143:  lock_sock(sk);",
          "1145:  if (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {",
          "1146:   struct l2cap_conn_rsp rsp;",
          "1148:   sk->sk_state = BT_CONFIG;",
          "1150:   rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "1151:   rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);",
          "1152:   rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);",
          "1153:   rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);",
          "1154:   l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,",
          "1155:      L2CAP_CONN_RSP, sizeof(rsp), &rsp);",
          "1157:   release_sock(sk);",
          "1158:   return 0;",
          "1159:  }",
          "1161:  release_sock(sk);",
          "1163:  return bt_sock_recvmsg(iocb, sock, msg, len, flags);",
          "1164: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1156: {",
          "1157:  struct sock *sk = sock->sk;",
          "1158:  int err = 0;",
          "1160:  BT_DBG(\"sk %p\", sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1216:  u32 opt;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1165:  lock_sock(sk);",
          "1167:  switch (optname) {",
          "1168:  default:",
          "1169:   err = -ENOPROTOOPT;",
          "1170:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1226:  case BT_DEFER_SETUP:",
          "1227:   if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {",
          "1228:    err = -EINVAL;",
          "1229:    break;",
          "1230:   }",
          "1232:   if (get_user(opt, (u32 __user *) optval)) {",
          "1233:    err = -EFAULT;",
          "1234:    break;",
          "1235:   }",
          "1237:   bt_sk(sk)->defer_setup = opt;",
          "1238:   break;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1207:   break;",
          "1209:  case L2CAP_CONNINFO:",
          "1211:    err = -ENOTCONN;",
          "1212:    break;",
          "1213:   }",
          "",
          "[Removed Lines]",
          "1210:   if (sk->sk_state != BT_CONNECTED) {",
          "",
          "[Added Lines]",
          "1282:   if (sk->sk_state != BT_CONNECTED &&",
          "1283:      !(sk->sk_state == BT_CONNECT2 &&",
          "1284:       bt_sk(sk)->defer_setup)) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1246:  lock_sock(sk);",
          "1248:  switch (optname) {",
          "1249:  default:",
          "1250:   err = -ENOPROTOOPT;",
          "1251:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1323:  case BT_DEFER_SETUP:",
          "1324:   if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {",
          "1325:    err = -EINVAL;",
          "1326:    break;",
          "1327:   }",
          "1329:   if (put_user(bt_sk(sk)->defer_setup, (u32 __user *) optval))",
          "1330:    err = -EFAULT;",
          "1332:   break;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1671:  if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {",
          "1672:   if (l2cap_check_link_mode(sk)) {",
          "1676:   } else {",
          "1677:    sk->sk_state = BT_CONNECT2;",
          "1678:    result = L2CAP_CR_PEND;",
          "",
          "[Removed Lines]",
          "1673:    sk->sk_state = BT_CONFIG;",
          "1674:    result = L2CAP_CR_SUCCESS;",
          "1675:    status = L2CAP_CS_NO_INFO;",
          "",
          "[Added Lines]",
          "1758:    if (bt_sk(sk)->defer_setup) {",
          "1759:     sk->sk_state = BT_CONNECT2;",
          "1760:     result = L2CAP_CR_PEND;",
          "1761:     status = L2CAP_CS_AUTHOR_PEND;",
          "1762:     parent->sk_data_ready(parent, 0);",
          "1763:    } else {",
          "1764:     sk->sk_state = BT_CONFIG;",
          "1765:     result = L2CAP_CR_SUCCESS;",
          "1766:     status = L2CAP_CS_NO_INFO;",
          "1767:    }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2494:  .accept  = l2cap_sock_accept,",
          "2495:  .getname = l2cap_sock_getname,",
          "2496:  .sendmsg = l2cap_sock_sendmsg,",
          "2498:  .poll  = bt_sock_poll,",
          "2499:  .ioctl  = bt_sock_ioctl,",
          "2500:  .mmap  = sock_no_mmap,",
          "",
          "[Removed Lines]",
          "2497:  .recvmsg = bt_sock_recvmsg,",
          "",
          "[Added Lines]",
          "2589:  .recvmsg = l2cap_sock_recvmsg,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "47ec1dcd696d56a7c396e5838516a566ecd4b03d",
      "candidate_info": {
        "commit_hash": "47ec1dcd696d56a7c396e5838516a566ecd4b03d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/47ec1dcd696d56a7c396e5838516a566ecd4b03d",
        "files": [
          "include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Add basic constants for L2CAP ERTM support and use them\n\nThis adds the basic constants required to add support for L2CAP Enhanced\nRetransmission feature.\n\nBased on a patch from Nathan Holstein <nathan@lampreynetworks.com>\n\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
          "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #define __L2CAP_H",
          "",
          "[Removed Lines]",
          "29: #define L2CAP_DEFAULT_MTU 672",
          "30: #define L2CAP_DEFAULT_FLUSH_TO 0xFFFF",
          "",
          "[Added Lines]",
          "29: #define L2CAP_DEFAULT_MTU  672",
          "30: #define L2CAP_DEFAULT_FLUSH_TO  0xffff",
          "31: #define L2CAP_DEFAULT_RX_WINDOW  1",
          "32: #define L2CAP_DEFAULT_MAX_RECEIVE 1",
          "35: #define L2CAP_DEFAULT_MAX_RX_APDU 0xfff7",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64: #define L2CAP_LM_SECURE  0x0020",
          "80: struct l2cap_hdr {",
          "",
          "[Removed Lines]",
          "67: #define L2CAP_COMMAND_REJ 0x01",
          "68: #define L2CAP_CONN_REQ    0x02",
          "69: #define L2CAP_CONN_RSP    0x03",
          "70: #define L2CAP_CONF_REQ    0x04",
          "71: #define L2CAP_CONF_RSP    0x05",
          "72: #define L2CAP_DISCONN_REQ 0x06",
          "73: #define L2CAP_DISCONN_RSP 0x07",
          "74: #define L2CAP_ECHO_REQ    0x08",
          "75: #define L2CAP_ECHO_RSP    0x09",
          "76: #define L2CAP_INFO_REQ    0x0a",
          "77: #define L2CAP_INFO_RSP    0x0b",
          "",
          "[Added Lines]",
          "72: #define L2CAP_COMMAND_REJ 0x01",
          "73: #define L2CAP_CONN_REQ  0x02",
          "74: #define L2CAP_CONN_RSP  0x03",
          "75: #define L2CAP_CONF_REQ  0x04",
          "76: #define L2CAP_CONF_RSP  0x05",
          "77: #define L2CAP_DISCONN_REQ 0x06",
          "78: #define L2CAP_DISCONN_RSP 0x07",
          "79: #define L2CAP_ECHO_REQ  0x08",
          "80: #define L2CAP_ECHO_RSP  0x09",
          "81: #define L2CAP_INFO_REQ  0x0a",
          "82: #define L2CAP_INFO_RSP  0x0b",
          "85: #define L2CAP_FEAT_FLOWCTL 0x00000001",
          "86: #define L2CAP_FEAT_RETRANS 0x00000002",
          "87: #define L2CAP_FEAT_ERTM  0x00000008",
          "88: #define L2CAP_FEAT_STREAMING 0x00000010",
          "89: #define L2CAP_FEAT_FCS  0x00000020",
          "90: #define L2CAP_FEAT_FIXED_CHAN 0x00000080",
          "93: #define L2CAP_FCS_NONE  0x00",
          "94: #define L2CAP_FCS_CRC16  0x01",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113: #define L2CAP_CID_DYN_END 0xffff",
          "127: struct l2cap_conf_req {",
          "128:  __le16     dcid;",
          "",
          "[Removed Lines]",
          "116: #define L2CAP_CR_SUCCESS    0x0000",
          "117: #define L2CAP_CR_PEND       0x0001",
          "118: #define L2CAP_CR_BAD_PSM    0x0002",
          "119: #define L2CAP_CR_SEC_BLOCK  0x0003",
          "120: #define L2CAP_CR_NO_MEM     0x0004",
          "123: #define L2CAP_CS_NO_INFO      0x0000",
          "124: #define L2CAP_CS_AUTHEN_PEND  0x0001",
          "125: #define L2CAP_CS_AUTHOR_PEND  0x0002",
          "",
          "[Added Lines]",
          "133: #define L2CAP_CR_SUCCESS 0x0000",
          "134: #define L2CAP_CR_PEND  0x0001",
          "135: #define L2CAP_CR_BAD_PSM 0x0002",
          "136: #define L2CAP_CR_SEC_BLOCK 0x0003",
          "137: #define L2CAP_CR_NO_MEM  0x0004",
          "140: #define L2CAP_CS_NO_INFO 0x0000",
          "141: #define L2CAP_CS_AUTHEN_PEND 0x0001",
          "142: #define L2CAP_CS_AUTHOR_PEND 0x0002",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150: #define L2CAP_CONF_OPT_SIZE 2",
          "152: #define L2CAP_CONF_HINT  0x80",
          "154: #define L2CAP_CONF_MTU  0x01",
          "155: #define L2CAP_CONF_FLUSH_TO 0x02",
          "156: #define L2CAP_CONF_QOS  0x03",
          "157: #define L2CAP_CONF_RFC  0x04",
          "159: #define L2CAP_CONF_MAX_SIZE 22",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170: #define L2CAP_CONF_MASK  0x7f",
          "176: #define L2CAP_CONF_FCS  0x05",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "170: #define L2CAP_MODE_BASIC 0x00",
          "171: #define L2CAP_MODE_RETRANS 0x01",
          "172: #define L2CAP_MODE_FLOWCTL 0x02",
          "174: struct l2cap_disconn_req {",
          "175:  __le16     dcid;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192: #define L2CAP_MODE_ERTM  0x03",
          "193: #define L2CAP_MODE_STREAM 0x04",
          "",
          "---------------"
        ],
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: #define VERSION \"2.13\"",
          "56: static u8 l2cap_fixed_chan[8] = { 0x02, };",
          "58: static const struct proto_ops l2cap_sock_ops;",
          "",
          "[Removed Lines]",
          "55: static u32 l2cap_feat_mask = 0x0080;",
          "",
          "[Added Lines]",
          "55: static u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1747:   len -= l2cap_get_conf_opt(&req, &type, &olen, &val);",
          "1749:   hint  = type & L2CAP_CONF_HINT;",
          "1752:   switch (type) {",
          "1753:   case L2CAP_CONF_MTU:",
          "",
          "[Removed Lines]",
          "1750:   type &= 0x7f;",
          "",
          "[Added Lines]",
          "1750:   type &= L2CAP_CONF_MASK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2244:  if (type == L2CAP_IT_FEAT_MASK) {",
          "2245:   conn->feat_mask = get_unaligned_le32(rsp->data);",
          "2248:    struct l2cap_info_req req;",
          "2249:    req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);",
          "",
          "[Removed Lines]",
          "2247:   if (conn->feat_mask & 0x0080) {",
          "",
          "[Added Lines]",
          "2247:   if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ba13ed678775195e8255b4e503c59d48b615bd8",
      "candidate_info": {
        "commit_hash": "2ba13ed678775195e8255b4e503c59d48b615bd8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2ba13ed678775195e8255b4e503c59d48b615bd8",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Remove check for supported mode\n\nSince now we have checks for the supported mode before on\nl2cap_info_rsp we can remove the check for it here.\n\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2473:  switch (pi->mode) {",
          "2474:  case L2CAP_MODE_STREAMING:",
          "2475:  case L2CAP_MODE_ERTM:",
          "2479:    break;",
          "2485:  default:",
          "2486:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
          "2487:   break;",
          "",
          "[Removed Lines]",
          "2476:   if (!(pi->conf_state & L2CAP_CONF_STATE2_DEVICE)) {",
          "2477:    pi->mode = l2cap_select_mode(rfc.mode,",
          "2478:      pi->conn->feat_mask);",
          "2480:   }",
          "2482:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
          "2483:    l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);",
          "2484:   break;",
          "",
          "[Added Lines]",
          "2476:   if (pi->conf_state & L2CAP_CONF_STATE2_DEVICE)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "65c7c4918450f8c4545ccb02a9c7a3d77e073535",
      "candidate_info": {
        "commit_hash": "65c7c4918450f8c4545ccb02a9c7a3d77e073535",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/65c7c4918450f8c4545ccb02a9c7a3d77e073535",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Add L2CAP RFC option if ERTM is enabled\n\nWhen trying to establish a connection with Enhanced Retransmission mode\nenabled, the RFC option needs to be added to the configuration.\n\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1743: {",
          "1744:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "1745:  struct l2cap_conf_req *req = data;",
          "1746:  void *ptr = req->data;",
          "1748:  BT_DBG(\"sk %p\", sk);",
          "",
          "[Removed Lines]",
          "1750:  if (pi->imtu != L2CAP_DEFAULT_MTU)",
          "1751:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);",
          "",
          "[Added Lines]",
          "1746:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };",
          "1751:  switch (pi->mode) {",
          "1752:  case L2CAP_MODE_BASIC:",
          "1753:   if (pi->imtu != L2CAP_DEFAULT_MTU)",
          "1754:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);",
          "1755:   break;",
          "1757:  case L2CAP_MODE_ERTM:",
          "1758:   rfc.mode            = L2CAP_MODE_ERTM;",
          "1759:   rfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;",
          "1760:   rfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;",
          "1761:   rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);",
          "1762:   rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);",
          "1763:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
          "1765:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
          "1766:      sizeof(rfc), (unsigned long) &rfc);",
          "1767:   break;",
          "1768:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1828:    rfc.mode = L2CAP_MODE_BASIC;",
          "1830:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
          "1832:   }",
          "1833:  }",
          "",
          "[Removed Lines]",
          "1831:       sizeof(rfc), (unsigned long) &rfc);",
          "",
          "[Added Lines]",
          "1848:      sizeof(rfc), (unsigned long) &rfc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "85eb53c6f719523dde9e0658823dffd2664d4d1c",
      "candidate_info": {
        "commit_hash": "85eb53c6f719523dde9e0658823dffd2664d4d1c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/85eb53c6f719523dde9e0658823dffd2664d4d1c",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Change the way we set ERTM mode as mandatory\n\nIf the socket type is SOCK_STREAM we set Enhanced Retransmisson Mode or\nStreaming Mode as mandatory. That means that we will close the channel\nif the other side doesn't support or request the the mandatory mode.\nBasic mode can't be set as mandatory.\n\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\nReviewed-by: Jo\u00e3o Paulo Rechi Vita <jprvita@profusion.mobi>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "832:   pi->imtu = l2cap_pi(parent)->imtu;",
          "833:   pi->omtu = l2cap_pi(parent)->omtu;",
          "834:   pi->mode = l2cap_pi(parent)->mode;",
          "835:   pi->fcs  = l2cap_pi(parent)->fcs;",
          "836:   pi->max_tx = l2cap_pi(parent)->max_tx;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "834:   pi->conf_state = l2cap_pi(parent)->conf_state;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "841:  } else {",
          "842:   pi->imtu = L2CAP_DEFAULT_MTU;",
          "843:   pi->omtu = 0;",
          "845:    pi->mode = L2CAP_MODE_ERTM;",
          "847:    pi->mode = L2CAP_MODE_BASIC;",
          "848:   pi->max_tx = L2CAP_DEFAULT_MAX_TX;",
          "849:   pi->fcs  = L2CAP_FCS_CRC16;",
          "850:   pi->tx_win = L2CAP_DEFAULT_TX_WINDOW;",
          "",
          "[Removed Lines]",
          "844:   if (enable_ertm && sk->sk_type == SOCK_STREAM)",
          "846:   else",
          "",
          "[Added Lines]",
          "845:   if (enable_ertm && sk->sk_type == SOCK_STREAM) {",
          "847:    pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
          "848:   } else {",
          "850:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1925:   l2cap_pi(sk)->mode = opts.mode;",
          "1926:   switch (l2cap_pi(sk)->mode) {",
          "1927:   case L2CAP_MODE_BASIC:",
          "1928:    break;",
          "1929:   case L2CAP_MODE_ERTM:",
          "1930:   case L2CAP_MODE_STREAMING:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1931:    l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_STATE2_DEVICE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2469:  switch (pi->mode) {",
          "2470:  case L2CAP_MODE_STREAMING:",
          "2471:  case L2CAP_MODE_ERTM:",
          "2473:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
          "2474:    l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);",
          "2475:   break;",
          "",
          "[Removed Lines]",
          "2472:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
          "",
          "[Added Lines]",
          "2476:   if (!(pi->conf_state & L2CAP_CONF_STATE2_DEVICE)) {",
          "2477:    pi->mode = l2cap_select_mode(rfc.mode,",
          "2478:      pi->conn->feat_mask);",
          "2479:    break;",
          "2480:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2602:  switch (pi->mode) {",
          "2603:  case L2CAP_MODE_STREAMING:",
          "2604:  case L2CAP_MODE_ERTM:",
          "2606:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
          "2607:    return -ECONNREFUSED;",
          "2608:   break;",
          "",
          "[Removed Lines]",
          "2605:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
          "",
          "[Added Lines]",
          "2614:   if (!(pi->conf_state & L2CAP_CONF_STATE2_DEVICE)) {",
          "2615:    pi->mode = l2cap_select_mode(rfc.mode,",
          "2616:      pi->conn->feat_mask);",
          "2617:    break;",
          "2618:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2011-4621",
  "cve_desc": "The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop.",
  "repo": "torvalds/linux",
  "patch_hash": "f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
  "patch_info": {
    "commit_hash": "f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
    "files": [
      "kernel/fork.c",
      "kernel/sched.c"
    ],
    "message": "Sched: fix skip_clock_update optimization\n\nidle_balance() drops/retakes rq->lock, leaving the previous task\nvulnerable to set_tsk_need_resched().  Clear it after we return\nfrom balancing instead, and in setup_thread_stack() as well, so\nno successfully descheduled or never scheduled task has it set.\n\nNeed resched confused the skip_clock_update logic, which assumes\nthat the next call to update_rq_clock() will come nearly immediately\nafter being set.  Make the optimization robust against the waking\na sleeper before it sucessfully deschedules case by checking that\nthe current task has not been dequeued before setting the flag,\nsince it is that useless clock update we're trying to save, and\nclear unconditionally in schedule() proper instead of conditionally\nin put_prev_task().\n\nSigned-off-by: Mike Galbraith <efault@gmx.de>\nReported-by: Bjoern B. Brandenburg <bbb.lst@gmail.com>\nTested-by: Yong Zhang <yong.zhang0@gmail.com>\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: stable@kernel.org\nLKML-Reference: <1291802742.1417.9.camel@marge.simson.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>",
    "before_after_code_files": [
      "kernel/fork.c||kernel/fork.c",
      "kernel/sched.c||kernel/sched.c"
    ]
  },
  "patch_diff": {
    "kernel/fork.c||kernel/fork.c": [
      "File: kernel/fork.c -> kernel/fork.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "274:  setup_thread_stack(tsk, orig);",
      "275:  clear_user_return_notifier(tsk);",
      "276:  stackend = end_of_stack(tsk);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "276:  clear_tsk_need_resched(tsk);",
      "",
      "---------------"
    ],
    "kernel/sched.c||kernel/sched.c": [
      "File: kernel/sched.c -> kernel/sched.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "642: inline void update_rq_clock(struct rq *rq)",
      "643: {",
      "655: }",
      "",
      "[Removed Lines]",
      "644:  if (!rq->skip_clock_update) {",
      "645:   int cpu = cpu_of(rq);",
      "646:   u64 irq_time;",
      "648:   rq->clock = sched_clock_cpu(cpu);",
      "649:   irq_time = irq_time_cpu(cpu);",
      "650:   if (rq->clock - irq_time > rq->clock_task)",
      "651:    rq->clock_task = rq->clock - irq_time;",
      "653:   sched_irq_time_avg_update(rq, irq_time);",
      "654:  }",
      "",
      "[Added Lines]",
      "644:  int cpu = cpu_of(rq);",
      "645:  u64 irq_time;",
      "647:  if (rq->skip_clock_update)",
      "648:   return;",
      "650:  rq->clock = sched_clock_cpu(cpu);",
      "651:  irq_time = irq_time_cpu(cpu);",
      "652:  if (rq->clock - irq_time > rq->clock_task)",
      "653:   rq->clock_task = rq->clock - irq_time;",
      "655:  sched_irq_time_avg_update(rq, irq_time);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2133:   rq->skip_clock_update = 1;",
      "2134: }",
      "",
      "[Removed Lines]",
      "2132:  if (test_tsk_need_resched(rq->curr))",
      "",
      "[Added Lines]",
      "2133:  if (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3973: {",
      "3974:  if (prev->se.on_rq)",
      "3975:   update_rq_clock(rq);",
      "3977:  prev->sched_class->put_prev_task(rq, prev);",
      "3978: }",
      "",
      "[Removed Lines]",
      "3976:  rq->skip_clock_update = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4031:   hrtick_clear(rq);",
      "4033:  raw_spin_lock_irq(&rq->lock);",
      "4036:  switch_count = &prev->nivcsw;",
      "4037:  if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {",
      "",
      "[Removed Lines]",
      "4034:  clear_tsk_need_resched(prev);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4064:  put_prev_task(rq, prev);",
      "4065:  next = pick_next_task(rq);",
      "4067:  if (likely(prev != next)) {",
      "4068:   sched_info_switch(prev, next);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4065:  clear_tsk_need_resched(prev);",
      "4066:  rq->skip_clock_update = 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "4071:   rq->nr_switches++;",
      "4072:   rq->curr = next;",
      "4073:   ++*switch_count;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4075:   WARN_ON_ONCE(test_tsk_need_resched(next));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a64692a3afd85fe048551ab89142fd5ca99a0dbd",
      "candidate_info": {
        "commit_hash": "a64692a3afd85fe048551ab89142fd5ca99a0dbd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a64692a3afd85fe048551ab89142fd5ca99a0dbd",
        "files": [
          "kernel/sched.c",
          "kernel/sched_fair.c"
        ],
        "message": "sched: Cleanup/optimize clock updates\n\nNow that we no longer depend on the clock being updated prior to enqueueing\non migratory wakeup, we can clean up a bit, placing calls to update_rq_clock()\nexactly where they are needed, ie on enqueue, dequeue and schedule events.\n\nIn the case of a freshly enqueued task immediately preempting, we can skip the\nupdate during preemption, as the clock was just updated by the enqueue event.\nWe also save an unneeded call during a migratory wakeup by not updating the\nprevious runqueue, where update_curr() won't be invoked.\n\nSigned-off-by: Mike Galbraith <efault@gmx.de>\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nLKML-Reference: <1268301199.6785.32.camel@marge.simson.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>",
        "before_after_code_files": [
          "kernel/sched.c||kernel/sched.c",
          "kernel/sched_fair.c||kernel/sched_fair.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched.c||kernel/sched.c"
          ],
          "candidate": [
            "kernel/sched.c||kernel/sched.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched.c||kernel/sched.c": [
          "File: kernel/sched.c -> kernel/sched.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "495:  u64 nohz_stamp;",
          "496:  unsigned char in_nohz_recently;",
          "497: #endif",
          "499:  struct load_weight load;",
          "500:  unsigned long nr_load_updates;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "498:  unsigned int skip_clock_update;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "592: void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)",
          "593: {",
          "594:  rq->curr->sched_class->check_preempt_curr(rq, p, flags);",
          "595: }",
          "597: static inline int cpu_of(struct rq *rq)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602:  if (test_tsk_need_resched(p))",
          "603:   rq->skip_clock_update = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "627: inline void update_rq_clock(struct rq *rq)",
          "628: {",
          "630: }",
          "",
          "[Removed Lines]",
          "629:  rq->clock = sched_clock_cpu(cpu_of(rq));",
          "",
          "[Added Lines]",
          "638:  if (!rq->skip_clock_update)",
          "639:   rq->clock = sched_clock_cpu(cpu_of(rq));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1782:    raw_spin_lock_nested(&rq1->lock, SINGLE_DEPTH_NESTING);",
          "1783:   }",
          "1784:  }",
          "1787: }",
          "",
          "[Removed Lines]",
          "1785:  update_rq_clock(rq1);",
          "1786:  update_rq_clock(rq2);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1880: static void",
          "1881: enqueue_task(struct rq *rq, struct task_struct *p, int wakeup, bool head)",
          "1882: {",
          "1883:  sched_info_queued(p);",
          "1884:  p->sched_class->enqueue_task(rq, p, wakeup, head);",
          "1885:  p->se.on_rq = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1891:  update_rq_clock(rq);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1888: static void dequeue_task(struct rq *rq, struct task_struct *p, int sleep)",
          "1889: {",
          "1890:  sched_info_dequeued(p);",
          "1891:  p->sched_class->dequeue_task(rq, p, sleep);",
          "1892:  p->se.on_rq = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1899:  update_rq_clock(rq);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2367:  smp_wmb();",
          "2368:  rq = task_rq_lock(p, &flags);",
          "2370:  if (!(p->state & state))",
          "2371:   goto out;",
          "",
          "[Removed Lines]",
          "2369:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2408:  rq = cpu_rq(cpu);",
          "2409:  raw_spin_lock(&rq->lock);",
          "",
          "[Removed Lines]",
          "2410:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2625:  BUG_ON(p->state != TASK_WAKING);",
          "2626:  p->state = TASK_RUNNING;",
          "2628:  activate_task(rq, p, 0);",
          "2629:  trace_sched_wakeup_new(rq, p, 1);",
          "2630:  check_preempt_curr(rq, p, WF_FORK);",
          "",
          "[Removed Lines]",
          "2627:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3579: static void put_prev_task(struct rq *rq, struct task_struct *prev)",
          "3580: {",
          "3581:  prev->sched_class->put_prev_task(rq, prev);",
          "3582: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3588:  if (prev->se.on_rq)",
          "3589:   update_rq_clock(rq);",
          "3590:  rq->skip_clock_update = 0;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3640:   hrtick_clear(rq);",
          "3642:  raw_spin_lock_irq(&rq->lock);",
          "3644:  clear_tsk_need_resched(prev);",
          "3646:  if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {",
          "",
          "[Removed Lines]",
          "3643:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4197:  BUG_ON(prio < 0 || prio > MAX_PRIO);",
          "4199:  rq = task_rq_lock(p, &flags);",
          "4202:  oldprio = p->prio;",
          "4203:  prev_class = p->sched_class;",
          "",
          "[Removed Lines]",
          "4200:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4242:  rq = task_rq_lock(p, &flags);",
          "",
          "[Removed Lines]",
          "4243:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4523:   raw_spin_unlock_irqrestore(&p->pi_lock, flags);",
          "4524:   goto recheck;",
          "4525:  }",
          "4527:  on_rq = p->se.on_rq;",
          "4528:  running = task_current(rq, p);",
          "4529:  if (on_rq)",
          "",
          "[Removed Lines]",
          "4526:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5531:  __setscheduler(rq, p, SCHED_FIFO, MAX_RT_PRIO-1);",
          "5534:  activate_task(rq, p, 0);",
          "5536:  raw_spin_unlock_irqrestore(&rq->lock, flags);",
          "",
          "[Removed Lines]",
          "5533:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "5585:  for ( ; ; ) {",
          "5586:   if (!rq->nr_running)",
          "5587:    break;",
          "5589:   next = pick_next_task(rq);",
          "5590:   if (!next)",
          "5591:    break;",
          "",
          "[Removed Lines]",
          "5588:   update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "5869:   rq->migration_thread = NULL;",
          "5871:   raw_spin_lock_irq(&rq->lock);",
          "5873:   deactivate_task(rq, rq->idle, 0);",
          "5874:   __setscheduler(rq, rq->idle, SCHED_NORMAL, 0);",
          "5875:   rq->idle->sched_class = &idle_sched_class;",
          "",
          "[Removed Lines]",
          "5872:   update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "7815: {",
          "7816:  int on_rq;",
          "7819:  on_rq = p->se.on_rq;",
          "7820:  if (on_rq)",
          "7821:   deactivate_task(rq, p, 0);",
          "",
          "[Removed Lines]",
          "7818:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "8178:  rq = task_rq_lock(tsk, &flags);",
          "8182:  running = task_current(rq, tsk);",
          "8183:  on_rq = tsk->se.on_rq;",
          "",
          "[Removed Lines]",
          "8180:  update_rq_clock(rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/sched_fair.c||kernel/sched_fair.c": [
          "File: kernel/sched_fair.c -> kernel/sched_fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3066:  double_lock_balance(busiest_rq, target_rq);",
          "3071:  for_each_domain(target_cpu, sd) {",
          "",
          "[Removed Lines]",
          "3067:  update_rq_clock(busiest_rq);",
          "3068:  update_rq_clock(target_rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fd2f4419b4cbe8fe90796df9617c355762afd6a4",
      "candidate_info": {
        "commit_hash": "fd2f4419b4cbe8fe90796df9617c355762afd6a4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fd2f4419b4cbe8fe90796df9617c355762afd6a4",
        "files": [
          "include/linux/sched.h",
          "kernel/sched.c",
          "kernel/sched_debug.c",
          "kernel/sched_rt.c",
          "kernel/sched_stoptask.c"
        ],
        "message": "sched: Provide p->on_rq\n\nProvide a generic p->on_rq because the p->se.on_rq semantics are\nunfavourable for lockless wakeups but needed for sched_fair.\n\nIn particular, p->on_rq is only cleared when we actually dequeue the\ntask in schedule() and not on any random dequeue as done by things\nlike __migrate_task() and __sched_setscheduler().\n\nThis also allows us to remove p->se usage from !sched_fair code.\n\nReviewed-by: Frank Rowand <frank.rowand@am.sony.com>\nCc: Mike Galbraith <efault@gmx.de>\nCc: Nick Piggin <npiggin@kernel.dk>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nLink: http://lkml.kernel.org/r/20110405152728.949545047@chello.nl",
        "before_after_code_files": [
          "include/linux/sched.h||include/linux/sched.h",
          "kernel/sched.c||kernel/sched.c",
          "kernel/sched_debug.c||kernel/sched_debug.c",
          "kernel/sched_rt.c||kernel/sched_rt.c",
          "kernel/sched_stoptask.c||kernel/sched_stoptask.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched.c||kernel/sched.c"
          ],
          "candidate": [
            "kernel/sched.c||kernel/sched.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/sched.h||include/linux/sched.h": [
          "File: include/linux/sched.h -> include/linux/sched.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1202: #ifdef CONFIG_SMP",
          "1203:  int on_cpu;",
          "1204: #endif",
          "1206:  int prio, static_prio, normal_prio;",
          "1207:  unsigned int rt_priority;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1205:  int on_rq;",
          "",
          "---------------"
        ],
        "kernel/sched.c||kernel/sched.c": [
          "File: kernel/sched.c -> kernel/sched.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1785:  update_rq_clock(rq);",
          "1786:  sched_info_queued(p);",
          "1787:  p->sched_class->enqueue_task(rq, p, flags);",
          "1789: }",
          "1791: static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)",
          "",
          "[Removed Lines]",
          "1788:  p->se.on_rq = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1793:  update_rq_clock(rq);",
          "1794:  sched_info_dequeued(p);",
          "1795:  p->sched_class->dequeue_task(rq, p, flags);",
          "1797: }",
          "",
          "[Removed Lines]",
          "1796:  p->se.on_rq = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2132:   rq->skip_clock_update = 1;",
          "2133: }",
          "",
          "[Removed Lines]",
          "2131:  if (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))",
          "",
          "[Added Lines]",
          "2129:  if (rq->curr->on_rq && test_tsk_need_resched(rq->curr))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2207: }",
          "",
          "[Removed Lines]",
          "2206:  return p->se.on_rq || task_running(rq, p);",
          "",
          "[Added Lines]",
          "2204:  return p->on_rq || task_running(rq, p);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2263:   rq = task_rq_lock(p, &flags);",
          "2264:   trace_sched_wait_task(p);",
          "2265:   running = task_running(rq, p);",
          "2267:   ncsw = 0;",
          "2268:   if (!match_state || p->state == match_state)",
          "",
          "[Removed Lines]",
          "2266:   on_rq = p->se.on_rq;",
          "",
          "[Added Lines]",
          "2264:   on_rq = p->on_rq;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2444: static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)",
          "2445: {",
          "2446:  activate_task(rq, p, en_flags);",
          "2449:  if (p->flags & PF_WQ_WORKER)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2445:  p->on_rq = 1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2507:  cpu = task_cpu(p);",
          "2510:   goto out_running;",
          "2512:  orig_cpu = cpu;",
          "",
          "[Removed Lines]",
          "2509:  if (p->se.on_rq)",
          "",
          "[Added Lines]",
          "2508:  if (p->on_rq)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2583:  if (!(p->state & TASK_NORMAL))",
          "2584:   return;",
          "2587:   ttwu_activate(rq, p, ENQUEUE_WAKEUP);",
          "2589:  ttwu_post_activation(p, rq, 0);",
          "",
          "[Removed Lines]",
          "2586:  if (!p->se.on_rq)",
          "",
          "[Added Lines]",
          "2585:  if (!p->on_rq)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2621: static void __sched_fork(struct task_struct *p)",
          "2622: {",
          "2623:  p->se.exec_start  = 0;",
          "2624:  p->se.sum_exec_runtime  = 0;",
          "2625:  p->se.prev_sum_exec_runtime = 0;",
          "2626:  p->se.nr_migrations  = 0;",
          "2627:  p->se.vruntime   = 0;",
          "2629: #ifdef CONFIG_SCHEDSTATS",
          "2630:  memset(&p->se.statistics, 0, sizeof(p->se.statistics));",
          "2631: #endif",
          "2633:  INIT_LIST_HEAD(&p->rt.run_list);",
          "2637: #ifdef CONFIG_PREEMPT_NOTIFIERS",
          "2638:  INIT_HLIST_HEAD(&p->preempt_notifiers);",
          "",
          "[Removed Lines]",
          "2634:  p->se.on_rq = 0;",
          "2635:  INIT_LIST_HEAD(&p->se.group_node);",
          "",
          "[Added Lines]",
          "2622:  p->on_rq   = 0;",
          "2624:  p->se.on_rq   = 0;",
          "2630:  INIT_LIST_HEAD(&p->se.group_node);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2751:  rq = task_rq_lock(p, &flags);",
          "2752:  activate_task(rq, p, 0);",
          "2753:  trace_sched_wakeup_new(p, true);",
          "2754:  check_preempt_curr(rq, p, WF_FORK);",
          "2755: #ifdef CONFIG_SMP",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2754:  p->on_rq = 1;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4052: static void put_prev_task(struct rq *rq, struct task_struct *prev)",
          "4053: {",
          "4055:   update_rq_clock(rq);",
          "4056:  prev->sched_class->put_prev_task(rq, prev);",
          "4057: }",
          "",
          "[Removed Lines]",
          "4054:  if (prev->se.on_rq)",
          "",
          "[Added Lines]",
          "4056:  if (prev->on_rq)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4126:     if (to_wakeup)",
          "4127:      try_to_wake_up_local(to_wakeup);",
          "4128:    }",
          "4129:    deactivate_task(rq, prev, DEQUEUE_SLEEP);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4133:    prev->on_rq = 0;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4695:  trace_sched_pi_setprio(p, prio);",
          "4696:  oldprio = p->prio;",
          "4697:  prev_class = p->sched_class;",
          "4699:  running = task_current(rq, p);",
          "4700:  if (on_rq)",
          "4701:   dequeue_task(rq, p, 0);",
          "",
          "[Removed Lines]",
          "4698:  on_rq = p->se.on_rq;",
          "",
          "[Added Lines]",
          "4702:  on_rq = p->on_rq;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4743:   p->static_prio = NICE_TO_PRIO(nice);",
          "4744:   goto out_unlock;",
          "4745:  }",
          "4747:  if (on_rq)",
          "4748:   dequeue_task(rq, p, 0);",
          "",
          "[Removed Lines]",
          "4746:  on_rq = p->se.on_rq;",
          "",
          "[Added Lines]",
          "4750:  on_rq = p->on_rq;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4877: static void",
          "4878: __setscheduler(struct rq *rq, struct task_struct *p, int policy, int prio)",
          "4879: {",
          "4882:  p->policy = policy;",
          "4883:  p->rt_priority = prio;",
          "4884:  p->normal_prio = normal_prio(p);",
          "",
          "[Removed Lines]",
          "4880:  BUG_ON(p->se.on_rq);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "5044:   raw_spin_unlock_irqrestore(&p->pi_lock, flags);",
          "5045:   goto recheck;",
          "5046:  }",
          "5048:  running = task_current(rq, p);",
          "5049:  if (on_rq)",
          "5050:   deactivate_task(rq, p, 0);",
          "",
          "[Removed Lines]",
          "5047:  on_rq = p->se.on_rq;",
          "",
          "[Added Lines]",
          "5049:  on_rq = p->on_rq;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "5969:   deactivate_task(rq_src, p, 0);",
          "5970:   set_task_cpu(p, dest_cpu);",
          "5971:   activate_task(rq_dest, p, 0);",
          "",
          "[Removed Lines]",
          "5968:  if (p->se.on_rq) {",
          "",
          "[Added Lines]",
          "5970:  if (p->on_rq) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "8339:  int old_prio = p->prio;",
          "8340:  int on_rq;",
          "8343:  if (on_rq)",
          "8344:   deactivate_task(rq, p, 0);",
          "8345:  __setscheduler(rq, p, SCHED_NORMAL, 0);",
          "",
          "[Removed Lines]",
          "8342:  on_rq = p->se.on_rq;",
          "",
          "[Added Lines]",
          "8344:  on_rq = p->on_rq;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "8682:  rq = task_rq_lock(tsk, &flags);",
          "8684:  running = task_current(rq, tsk);",
          "8687:  if (on_rq)",
          "8688:   dequeue_task(rq, tsk, 0);",
          "",
          "[Removed Lines]",
          "8685:  on_rq = tsk->se.on_rq;",
          "",
          "[Added Lines]",
          "8687:  on_rq = tsk->on_rq;",
          "",
          "---------------"
        ],
        "kernel/sched_debug.c||kernel/sched_debug.c": [
          "File: kernel/sched_debug.c -> kernel/sched_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:  read_lock_irqsave(&tasklist_lock, flags);",
          "154:  do_each_thread(g, p) {",
          "156:    continue;",
          "158:   print_task(m, rq, p);",
          "",
          "[Removed Lines]",
          "155:   if (!p->se.on_rq || task_cpu(p) != rq_cpu)",
          "",
          "[Added Lines]",
          "155:   if (!p->on_rq || task_cpu(p) != rq_cpu)",
          "",
          "---------------"
        ],
        "kernel/sched_rt.c||kernel/sched_rt.c": [
          "File: kernel/sched_rt.c -> kernel/sched_rt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1140:   enqueue_pushable_task(rq, p);",
          "1141: }",
          "",
          "[Removed Lines]",
          "1139:  if (p->se.on_rq && p->rt.nr_cpus_allowed > 1)",
          "",
          "[Added Lines]",
          "1139:  if (on_rt_rq(&p->rt) && p->rt.nr_cpus_allowed > 1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1287:          !cpumask_test_cpu(lowest_rq->cpu,",
          "1288:              &task->cpus_allowed) ||",
          "1289:          task_running(rq, task) ||",
          "1292:     raw_spin_unlock(&lowest_rq->lock);",
          "1293:     lowest_rq = NULL;",
          "",
          "[Removed Lines]",
          "1290:          !task->se.on_rq)) {",
          "",
          "[Added Lines]",
          "1290:          !task->on_rq)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1321:  BUG_ON(task_current(rq, p));",
          "1322:  BUG_ON(p->rt.nr_cpus_allowed <= 1);",
          "1325:  BUG_ON(!rt_task(p));",
          "1327:  return p;",
          "",
          "[Removed Lines]",
          "1324:  BUG_ON(!p->se.on_rq);",
          "",
          "[Added Lines]",
          "1324:  BUG_ON(!p->on_rq);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1468:   if (p && (p->prio < this_rq->rt.highest_prio.curr)) {",
          "1469:    WARN_ON(p == src_rq->curr);",
          "",
          "[Removed Lines]",
          "1470:    WARN_ON(!p->se.on_rq);",
          "",
          "[Added Lines]",
          "1470:    WARN_ON(!p->on_rq);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1542:   struct rq *rq = task_rq(p);",
          "1544:   if (!task_current(rq, p)) {",
          "",
          "[Removed Lines]",
          "1541:  if (p->se.on_rq && (weight != p->rt.nr_cpus_allowed)) {",
          "",
          "[Added Lines]",
          "1541:  if (p->on_rq && (weight != p->rt.nr_cpus_allowed)) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1612:   pull_rt_task(rq);",
          "1613: }",
          "",
          "[Removed Lines]",
          "1611:  if (p->se.on_rq && !rq->rt.rt_nr_running)",
          "",
          "[Added Lines]",
          "1611:  if (p->on_rq && !rq->rt.rt_nr_running)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1642: #ifdef CONFIG_SMP",
          "1643:   if (rq->rt.overloaded && push_rt_task(rq) &&",
          "",
          "[Removed Lines]",
          "1641:  if (p->se.on_rq && rq->curr != p) {",
          "",
          "[Added Lines]",
          "1641:  if (p->on_rq && rq->curr != p) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1657: static void",
          "1658: prio_changed_rt(struct rq *rq, struct task_struct *p, int oldprio)",
          "1659: {",
          "1661:   return;",
          "1663:  if (rq->curr == p) {",
          "",
          "[Removed Lines]",
          "1660:  if (!p->se.on_rq)",
          "",
          "[Added Lines]",
          "1660:  if (!p->on_rq)",
          "",
          "---------------"
        ],
        "kernel/sched_stoptask.c||kernel/sched_stoptask.c": [
          "File: kernel/sched_stoptask.c -> kernel/sched_stoptask.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: {",
          "27:  struct task_struct *stop = rq->stop;",
          "30:   return stop;",
          "32:  return NULL;",
          "",
          "[Removed Lines]",
          "29:  if (stop && stop->se.on_rq)",
          "",
          "[Added Lines]",
          "29:  if (stop && stop->on_rq)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
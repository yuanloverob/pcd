{
  "cve_id": "CVE-2014-9717",
  "cve_desc": "fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",
  "repo": "torvalds/linux",
  "patch_hash": "ce07d891a0891d3c0d0c2d73d577490486b809e1",
  "patch_info": {
    "commit_hash": "ce07d891a0891d3c0d0c2d73d577490486b809e1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1",
    "files": [
      "fs/namespace.c",
      "fs/pnode.h"
    ],
    "message": "mnt: Honor MNT_LOCKED when detaching mounts\n\nModify umount(MNT_DETACH) to keep mounts in the hash table that are\nlocked to their parent mounts, when the parent is lazily unmounted.\n\nIn mntput_no_expire detach the children from the hash table, depending\non mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.\n\nIn __detach_mounts if there are any mounts that have been unmounted\nbut still are on the list of mounts of a mountpoint, remove their\nchildren from the mount hash table and those children to the unmounted\nlist so they won't linger potentially indefinitely waiting for their\nfinal mntput, now that the mounts serve no purpose.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "fs/namespace.c||fs/namespace.c",
      "fs/pnode.h||fs/pnode.h"
    ]
  },
  "patch_diff": {
    "fs/namespace.c||fs/namespace.c": [
      "File: fs/namespace.c -> fs/namespace.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1099:  rcu_read_unlock();",
      "1101:  list_del(&mnt->mnt_instance);",
      "1102:  unlock_mount_hash();",
      "1104:  if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1103:  if (unlikely(!list_empty(&mnt->mnt_mounts))) {",
      "1104:   struct mount *p, *tmp;",
      "1105:   list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
      "1106:    umount_mnt(p);",
      "1107:   }",
      "1108:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1370:   propagate_umount(&tmp_list);",
      "1372:  while (!list_empty(&tmp_list)) {",
      "1373:   p = list_first_entry(&tmp_list, struct mount, mnt_list);",
      "1374:   list_del_init(&p->mnt_expire);",
      "1375:   list_del_init(&p->mnt_list);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1380:   bool disconnect;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1378:   if (how & UMOUNT_SYNC)",
      "1379:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
      "1382:   if (mnt_has_parent(p)) {",
      "1383:    mnt_add_count(p->mnt_parent, -1);",
      "1385:   }",
      "1386:   change_mnt_propagation(p, MS_PRIVATE);",
      "1387:  }",
      "",
      "[Removed Lines]",
      "1381:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
      "1384:    umount_mnt(p);",
      "",
      "[Added Lines]",
      "1389:   disconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
      "1391:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
      "1392:      disconnect ? &unmounted : NULL);",
      "1395:    if (!disconnect) {",
      "1397:     list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);",
      "1398:    } else {",
      "1399:     umount_mnt(p);",
      "1400:    }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1506:  lock_mount_hash();",
      "1507:  while (!hlist_empty(&mp->m_list)) {",
      "1508:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
      "1510:  }",
      "1511:  unlock_mount_hash();",
      "1512:  put_mountpoint(mp);",
      "",
      "[Removed Lines]",
      "1509:   umount_tree(mnt, 0);",
      "",
      "[Added Lines]",
      "1525:   if (mnt->mnt.mnt_flags & MNT_UMOUNT) {",
      "1526:    struct mount *p, *tmp;",
      "1527:    list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
      "1528:     hlist_add_head(&p->mnt_umount.s_list, &unmounted);",
      "1529:     umount_mnt(p);",
      "1530:    }",
      "1531:   }",
      "1532:   else umount_tree(mnt, 0);",
      "",
      "---------------"
    ],
    "fs/pnode.h||fs/pnode.h": [
      "File: fs/pnode.h -> fs/pnode.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "20: #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)",
      "21: #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)",
      "22: #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)",
      "24: #define CL_EXPIRE      0x01",
      "25: #define CL_SLAVE       0x02",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "23: #define IS_MNT_LOCKED_AND_LAZY(m) \\",
      "24:  (((m)->mnt.mnt_flags & (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b",
      "candidate_info": {
        "commit_hash": "f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b",
        "files": [
          "fs/namespace.c",
          "fs/pnode.h"
        ],
        "message": "mnt: Clarify and correct the disconnect logic in umount_tree\n\nrmdir mntpoint will result in an infinite loop when there is\na mount locked on the mountpoint in another mount namespace.\n\nThis is because the logic to test to see if a mount should\nbe disconnected in umount_tree is buggy.\n\nMove the logic to decide if a mount should remain connected to\nit's mountpoint into it's own function disconnect_mount so that\nclarity of expression instead of terseness of expression becomes\na virtue.\n\nWhen the conditions where it is invalid to leave a mount connected\nare first ruled out, the logic for deciding if a mount should\nbe disconnected becomes much clearer and simpler.\n\nFixes: e0c9c0afd2fc958ffa34b697972721d81df8a56f mnt: Update detach_mounts to leave mounts connected\nFixes: ce07d891a0891d3c0d0c2d73d577490486b809e1 mnt: Honor MNT_LOCKED when detaching mounts\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c",
          "fs/pnode.h||fs/pnode.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c",
            "fs/pnode.h||fs/pnode.h"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c",
            "fs/pnode.h||fs/pnode.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1361:  UMOUNT_PROPAGATE = 2,",
          "1362:  UMOUNT_CONNECTED = 4,",
          "1363: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1365: static bool disconnect_mount(struct mount *mnt, enum umount_tree_flags how)",
          "1366: {",
          "1368:  if (how & UMOUNT_SYNC)",
          "1369:   return true;",
          "1372:  if (!mnt_has_parent(mnt))",
          "1373:   return true;",
          "1379:  if (!(mnt->mnt_parent->mnt.mnt_flags & MNT_UMOUNT))",
          "1380:   return true;",
          "1383:  if (how & UMOUNT_CONNECTED)",
          "1384:   return false;",
          "1387:  if (IS_MNT_LOCKED(mnt))",
          "1388:   return false;",
          "1391:  return true;",
          "1392: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1398:   if (how & UMOUNT_SYNC)",
          "1399:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
          "1406:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
          "1407:      disconnect ? &unmounted : NULL);",
          "",
          "[Removed Lines]",
          "1401:   disconnect = !(((how & UMOUNT_CONNECTED) &&",
          "1402:     mnt_has_parent(p) &&",
          "1403:     (p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||",
          "1404:           IS_MNT_LOCKED_AND_LAZY(p));",
          "",
          "[Added Lines]",
          "1431:   disconnect = disconnect_mount(p, how);",
          "",
          "---------------"
        ],
        "fs/pnode.h||fs/pnode.h": [
          "File: fs/pnode.h -> fs/pnode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)",
          "21: #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)",
          "22: #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)",
          "26: #define CL_EXPIRE      0x01",
          "27: #define CL_SLAVE       0x02",
          "",
          "[Removed Lines]",
          "23: #define IS_MNT_LOCKED_AND_LAZY(m) \\",
          "24:  (((m)->mnt.mnt_flags & (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-2706",
  "cve_desc": "Race condition in the mac80211 subsystem in the Linux kernel before 3.13.7 allows remote attackers to cause a denial of service (system crash) via network traffic that improperly interacts with the WLAN_STA_PS_STA state (aka power-save mode), related to sta_info.c and tx.c.",
  "repo": "torvalds/linux",
  "patch_hash": "1d147bfa64293b2723c4fec50922168658e613ba",
  "patch_info": {
    "commit_hash": "1d147bfa64293b2723c4fec50922168658e613ba",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba",
    "files": [
      "net/mac80211/sta_info.c",
      "net/mac80211/sta_info.h",
      "net/mac80211/tx.c"
    ],
    "message": "mac80211: fix AP powersave TX vs. wakeup race\n\nThere is a race between the TX path and the STA wakeup: while\na station is sleeping, mac80211 buffers frames until it wakes\nup, then the frames are transmitted. However, the RX and TX\npath are concurrent, so the packet indicating wakeup can be\nprocessed while a packet is being transmitted.\n\nThis can lead to a situation where the buffered frames list\nis emptied on the one side, while a frame is being added on\nthe other side, as the station is still seen as sleeping in\nthe TX path.\n\nAs a result, the newly added frame will not be send anytime\nsoon. It might be sent much later (and out of order) when the\nstation goes to sleep and wakes up the next time.\n\nAdditionally, it can lead to the crash below.\n\nFix all this by synchronising both paths with a new lock.\nBoth path are not fastpath since they handle PS situations.\n\nIn a later patch we'll remove the extra skb queue locks to\nreduce locking overhead.\n\nBUG: unable to handle kernel\nNULL pointer dereference at 000000b0\nIP: [<ff6f1791>] ieee80211_report_used_skb+0x11/0x3e0 [mac80211]\n*pde = 00000000\nOops: 0000 [#1] SMP DEBUG_PAGEALLOC\nEIP: 0060:[<ff6f1791>] EFLAGS: 00210282 CPU: 1\nEIP is at ieee80211_report_used_skb+0x11/0x3e0 [mac80211]\nEAX: e5900da0 EBX: 00000000 ECX: 00000001 EDX: 00000000\nESI: e41d00c0 EDI: e5900da0 EBP: ebe458e4 ESP: ebe458b0\n DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068\nCR0: 8005003b CR2: 000000b0 CR3: 25a78000 CR4: 000407d0\nDR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\nDR6: ffff0ff0 DR7: 00000400\nProcess iperf (pid: 3934, ti=ebe44000 task=e757c0b0 task.ti=ebe44000)\niwlwifi 0000:02:00.0: I iwl_pcie_enqueue_hcmd Sending command LQ_CMD (#4e), seq: 0x0903, 92 bytes at 3[3]:9\nStack:\n e403b32c ebe458c4 00200002 00200286 e403b338 ebe458cc c10960bb e5900da0\n ff76a6ec ebe458d8 00000000 e41d00c0 e5900da0 ebe458f0 ff6f1b75 e403b210\n ebe4598c ff723dc1 00000000 ff76a6ec e597c978 e403b758 00000002 00000002\nCall Trace:\n [<ff6f1b75>] ieee80211_free_txskb+0x15/0x20 [mac80211]\n [<ff723dc1>] invoke_tx_handlers+0x1661/0x1780 [mac80211]\n [<ff7248a5>] ieee80211_tx+0x75/0x100 [mac80211]\n [<ff7249bf>] ieee80211_xmit+0x8f/0xc0 [mac80211]\n [<ff72550e>] ieee80211_subif_start_xmit+0x4fe/0xe20 [mac80211]\n [<c149ef70>] dev_hard_start_xmit+0x450/0x950\n [<c14b9aa9>] sch_direct_xmit+0xa9/0x250\n [<c14b9c9b>] __qdisc_run+0x4b/0x150\n [<c149f732>] dev_queue_xmit+0x2c2/0xca0\n\nCc: stable@vger.kernel.org\nReported-by: Yaara Rozenblum <yaara.rozenblum@intel.com>\nSigned-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>\nReviewed-by: Stanislaw Gruszka <sgruszka@redhat.com>\n[reword commit log, use a separate lock]\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
    "before_after_code_files": [
      "net/mac80211/sta_info.c||net/mac80211/sta_info.c",
      "net/mac80211/sta_info.h||net/mac80211/sta_info.h",
      "net/mac80211/tx.c||net/mac80211/tx.c"
    ]
  },
  "patch_diff": {
    "net/mac80211/sta_info.c||net/mac80211/sta_info.c": [
      "File: net/mac80211/sta_info.c -> net/mac80211/sta_info.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:  rcu_read_unlock();",
      "332:  spin_lock_init(&sta->lock);",
      "333:  INIT_WORK(&sta->drv_unblock_wk, sta_unblock);",
      "334:  INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);",
      "335:  mutex_init(&sta->ampdu_mlme.mtx);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:  spin_lock_init(&sta->ps_lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1110:  skb_queue_head_init(&pending);",
      "1113:  for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {",
      "1114:   int count = skb_queue_len(&pending), tmp;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1114:  spin_lock(&sta->ps_lock);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1128:  }",
      "1130:  ieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);",
      "1133:  if (!ieee80211_smps_is_restrictive(sta->known_smps_mode,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1134:  spin_unlock(&sta->ps_lock);",
      "",
      "---------------"
    ],
    "net/mac80211/sta_info.h||net/mac80211/sta_info.h": [
      "File: net/mac80211/sta_info.h -> net/mac80211/sta_info.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "357:  unsigned long _flags;",
      "363:  struct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];",
      "364:  struct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];",
      "365:  unsigned long driver_buffered_tids;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "361:  spinlock_t ps_lock;",
      "",
      "---------------"
    ],
    "net/mac80211/tx.c||net/mac80211/tx.c": [
      "File: net/mac80211/tx.c -> net/mac80211/tx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "478:          sta->sta.addr, sta->sta.aid, ac);",
      "479:   if (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)",
      "480:    purge_old_ps_buffers(tx->local);",
      "481:   if (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {",
      "482:    struct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);",
      "483:    ps_dbg(tx->sdata,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "483:   spin_lock(&sta->ps_lock);",
      "489:   if (!test_sta_flag(sta, WLAN_STA_PS_STA) &&",
      "490:       !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {",
      "491:    spin_unlock(&sta->ps_lock);",
      "492:    return TX_CONTINUE;",
      "493:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "492:   info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;",
      "493:   info->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;",
      "494:   skb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);",
      "496:   if (!timer_pending(&local->sta_cleanup))",
      "497:    mod_timer(&local->sta_cleanup,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "509:   spin_unlock(&sta->ps_lock);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ce5eaf023a231ebd313ecc7e0b33278513d8ad80",
      "candidate_info": {
        "commit_hash": "ce5eaf023a231ebd313ecc7e0b33278513d8ad80",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ce5eaf023a231ebd313ecc7e0b33278513d8ad80",
        "files": [
          "drivers/net/ethernet/freescale/fec_main.c"
        ],
        "message": "NET: fec: only enable napi if we are successful\n\nIf napi is left enabled after a failed attempt to bring the interface\nup, we BUG:\n\nfec 2188000.ethernet eth0: no PHY, assuming direct connection to switch\nlibphy: PHY fixed-0:00 not found\nfec 2188000.ethernet eth0: could not attach to PHY\n------------[ cut here ]------------\nkernel BUG at include/linux/netdevice.h:502!\nInternal error: Oops - BUG: 0 [#1] SMP ARM\n...\nPC is at fec_enet_open+0x4d0/0x500\nLR is at __dev_open+0xa4/0xfc\n\nOnly enable napi after we are past all the failure paths.\n\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/freescale/fec_main.c||drivers/net/ethernet/freescale/fec_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/freescale/fec_main.c||drivers/net/ethernet/freescale/fec_main.c": [
          "File: drivers/net/ethernet/freescale/fec_main.c -> drivers/net/ethernet/freescale/fec_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1778:  struct fec_enet_private *fep = netdev_priv(ndev);",
          "1779:  int ret;",
          "",
          "[Removed Lines]",
          "1781:  napi_enable(&fep->napi);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1794:   fec_enet_free_buffers(ndev);",
          "1795:   return ret;",
          "1796:  }",
          "1797:  phy_start(fep->phy_dev);",
          "1798:  netif_start_queue(ndev);",
          "1799:  fep->opened = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1796:  napi_enable(&fep->napi);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e98f60003df98026edd66916f282501eee075c4",
      "candidate_info": {
        "commit_hash": "7e98f60003df98026edd66916f282501eee075c4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7e98f60003df98026edd66916f282501eee075c4",
        "files": [
          "drivers/usb/gadget/printer.c"
        ],
        "message": "usb: gadget: printer: fix memory leak\n\nWhen read data from g_printer, we see a Segmentation fault. eg:\n\nUnable to handle kernel paging request at virtual address bf048000 pgd\n= cf038000 [bf048000] *pgd=8e8cf811, *pte=00000000, *ppte=00000000\nInternal error: Oops: 7 [#1] PREEMPT ARM Modules linked in: bluetooth\nrfcomm g_printer\nCPU: 0    Not tainted  (3.4.43-WR5.0.1.9_standard #1)\nPC is at __copy_to_user_std+0x310/0x3a8 LR is at 0x4c808010\npc : [<c036e990>]    lr : [<4c808010>]    psr: 20000013\nsp : cf883ea8  ip : 80801018  fp : cf883f24\nr10: bf04706c  r9 : 18a21205  r8 : 21953888\nr7 : 201588aa  r6 : 5109aa16  r5 : 0705aaa2  r4 : 5140aa8a\nr3 : 0000004c  r2 : 00000fdc  r1 : bf048000  r0 : bef5fc3c\nFlags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user\nControl: 10c5387d  Table: 8f038019  DAC: 00000015 Process\ng_printer_test. (pid: 661, stack limit = 0xcf8822e8)\nStack: (0xcf883ea8 to 0xcf884000)\n3ea0:                   bf047068 00001fff bef5ecb9 cf882000 00001fff bef5ecb9\n3ec0: 00001fff 00000000 cf2e8724 bf044d3c 80000013 80000013 00000001\nbf04706c\n3ee0: cf883f24 cf883ef0 c012e5ac c0324388 c007c8ac c0046298 00008180\ncf29b900\n3f00: 00002000 bef5ecb8 cf883f68 00000003 cf882000 cf29b900 cf883f54\ncf883f28\n3f20: c012ea08 bf044b0c c000eb88 00000000 cf883f7c 00000000 00000000\n00002000\n3f40: bef5ecb8 00000003 cf883fa4 cf883f58 c012eae8 c012e960 00000001\nbef60cb8\n3f60: 000000a8 c000eb88 00000000 00000000 cf883fa4 00000000 c014329c\n00000000\n3f80: 000000d4 41af63f0 00000003 c000eb88 cf882000 00000000 00000000\ncf883fa8\n3fa0: c000e920 c012eaa4 00000000 000000d4 00000003 bef5ecb8 00002000\nbef5ecb8\n3fc0: 00000000 000000d4 41af63f0 00000003 b6f534c0 00000000 419f9000\n00000000\n3fe0: 00000000 bef5ecac 000086d9 41a986bc 60000010 00000003 0109608a\n0088828a\nCode: f5d1f07c e8b100f0 e1a03c2e e2522020 (e8b15300) ---[ end trace\n97e2618e250e3377 ]--- Segmentation fault\n\nThe root cause is the dev->rx_buffers list has been broken.\nWhen we call printer_read(), the following call tree is triggered:\n\nprinter_read()\n\t|\n\t+---setup_rx_reqs(req)\n\t|\t|\n\t|\t+---usb_ep_queue(req)\n\t|\t|\t|\n\t|\t|\t+---...\n\t|\t|\t\t|\n\t|\t|\t\t+---rx_complete(req).\n\t|\t|\n\t|\t+---add the req to dev->rx_reqs_active\n\t|\n\t+---while(!list_empty(&dev->rx_buffers)))\n\nThe route happens when we don't use DMA or fail to start DMA in USB\ndriver. We can see: in the case, in rx_complete() it will add the req\nto dev->rx_buffers. meanwhile we see that we will also add the req to\ndev->rx_reqs_active after usb_ep_queue() return, so this adding will\nbreak the dev->rx_buffers out.\n\nAfter, when we call list_empty() to check dev->rx_buffers in while(),\ndue to can't check correctly dev->rx_buffers, so the Segmentation fault\noccurs when copy_to_user() is called.\n\nSigned-off-by: wenlin.kang <wenlin.kang@windriver.com>\nSigned-off-by: Felipe Balbi <balbi@ti.com>",
        "before_after_code_files": [
          "drivers/usb/gadget/printer.c||drivers/usgadget/printer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/gadget/printer.c||drivers/usgadget/printer.c": [
          "File: drivers/usb/gadget/printer.c -> drivers/usgadget/printer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "435:    DBG(dev, \"rx submit --> %d\\n\", error);",
          "436:    list_add(&req->list, &dev->rx_reqs);",
          "437:    break;",
          "439:    list_add(&req->list, &dev->rx_reqs_active);",
          "440:   }",
          "441:  }",
          "",
          "[Removed Lines]",
          "438:   } else {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "340fea3d7f6a2657ddd0b48413cd81e8513357ed",
      "candidate_info": {
        "commit_hash": "340fea3d7f6a2657ddd0b48413cd81e8513357ed",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/340fea3d7f6a2657ddd0b48413cd81e8513357ed",
        "files": [
          "drivers/net/ethernet/realtek/r8169.c"
        ],
        "message": "r8169: initialize rtl8169_stats seqlock\n\nBoris reports he's seeing:\n> [    9.195943] INFO: trying to register non-static key.\n> [    9.196031] the code is fine but needs lockdep annotation.\n> [    9.196031] turning off the locking correctness validator.\n> [    9.196031] CPU: 1 PID: 933 Comm: modprobe Not tainted 3.14.0-rc4+ #1\nwith the r8169 driver.\n\nThese are occuring because the seqcount embedded in u64_stats_sync on\n32-bit SMP is uninitialized which is making lockdep unhappy.\n\nSigned-off-by: Kyle McMartin <kyle@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/realtek/r8169.c||drivers/net/ethernet/realtek/r8169.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/realtek/r8169.c||drivers/net/ethernet/realtek/r8169.c": [
          "File: drivers/net/ethernet/realtek/r8169.c -> drivers/net/ethernet/realtek/r8169.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7118:  }",
          "7120:  mutex_init(&tp->wk.mutex);",
          "7123:  for (i = 0; i < ETH_ALEN; i++)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7121:  u64_stats_init(&tp->rx_stats.syncp);",
          "7122:  u64_stats_init(&tp->tx_stats.syncp);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5f0e030930d715920be4de638084aaf8653867e8",
      "candidate_info": {
        "commit_hash": "5f0e030930d715920be4de638084aaf8653867e8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5f0e030930d715920be4de638084aaf8653867e8",
        "files": [
          "arch/x86/include/asm/tsc.h",
          "arch/x86/kernel/tsc.c",
          "arch/x86/kernel/tsc_msr.c"
        ],
        "message": "x86, tsc: Fallback to normal calibration if fast MSR calibration fails\n\nIf we cannot calibrate TSC via MSR based calibration\ntry_msr_calibrate_tsc() stores zero to fast_calibrate and returns that\nto the caller. This value gets then propagated further to clockevents\ncode resulting division by zero oops like the one below:\n\n divide error: 0000 [#1] PREEMPT SMP\n Modules linked in:\n CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W    3.13.0+ #47\n task: ffff880075508000 ti: ffff880075506000 task.ti: ffff880075506000\n RIP: 0010:[<ffffffff810aec14>]  [<ffffffff810aec14>] clockevents_config.part.3+0x24/0xa0\n RSP: 0000:ffff880075507e58  EFLAGS: 00010246\n RAX: ffffffffffffffff RBX: ffff880079c0cd80 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffffffffff\n RBP: ffff880075507e70 R08: 0000000000000001 R09: 00000000000000be\n R10: 00000000000000bd R11: 0000000000000003 R12: 000000000000b008\n R13: 0000000000000008 R14: 000000000000b010 R15: 0000000000000000\n FS:  0000000000000000(0000) GS:ffff880079c00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n CR2: ffff880079fff000 CR3: 0000000001c0b000 CR4: 00000000001006f0\n Stack:\n  ffff880079c0cd80 000000000000b008 0000000000000008 ffff880075507e88\n  ffffffff810aecb0 ffff880079c0cd80 ffff880075507e98 ffffffff81030168\n  ffff880075507ed8 ffffffff81d1104f 00000000000000c3 0000000000000000\n Call Trace:\n  [<ffffffff810aecb0>] clockevents_config_and_register+0x20/0x30\n  [<ffffffff81030168>] setup_APIC_timer+0xc8/0xd0\n  [<ffffffff81d1104f>] setup_boot_APIC_clock+0x4cc/0x4d8\n  [<ffffffff81d0f5de>] native_smp_prepare_cpus+0x3dd/0x3f0\n  [<ffffffff81d02ee9>] kernel_init_freeable+0xc3/0x205\n  [<ffffffff8177c910>] ? rest_init+0x90/0x90\n  [<ffffffff8177c91e>] kernel_init+0xe/0x120\n  [<ffffffff8178deec>] ret_from_fork+0x7c/0xb0\n  [<ffffffff8177c910>] ? rest_init+0x90/0x90\n\nPrevent this from happening by:\n 1) Modifying try_msr_calibrate_tsc() to return calibration value or zero\n    if it fails.\n 2) Check this return value in native_calibrate_tsc() and in case of zero\n    fallback to use normal non-MSR based calibration.\n\n[mw: Added subject and changelog]\n\nReported-and-tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Bin Gao <bin.gao@linux.intel.com>\nCc: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>\nCc: Ingo Molnar <mingo@kernel.org>\nCc: H. Peter Anvin <hpa@zytor.com>\nLink: http://lkml.kernel.org/r/1392810750-18660-1-git-send-email-mika.westerberg@linux.intel.com\nSigned-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>",
        "before_after_code_files": [
          "arch/x86/include/asm/tsc.h||arch/x86/include/asm/tsc.h",
          "arch/x86/kernel/tsc.c||arch/x86/kernel/tsc.c",
          "arch/x86/kernel/tsc_msr.c||arch/x86/kernel/tsc_msr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/include/asm/tsc.h||arch/x86/include/asm/tsc.h": [
          "File: arch/x86/include/asm/tsc.h -> arch/x86/include/asm/tsc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: extern void tsc_restore_sched_clock_state(void);",
          "",
          "[Removed Lines]",
          "69: int try_msr_calibrate_tsc(unsigned long *fast_calibrate);",
          "",
          "[Added Lines]",
          "69: unsigned long try_msr_calibrate_tsc(void);",
          "",
          "---------------"
        ],
        "arch/x86/kernel/tsc.c||arch/x86/kernel/tsc.c": [
          "File: arch/x86/kernel/tsc.c -> arch/x86/kernel/tsc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "655:  local_irq_save(flags);",
          "657:  local_irq_restore(flags);",
          "661:   return fast_calibrate;",
          "664:  local_irq_save(flags);",
          "665:  fast_calibrate = quick_pit_calibrate();",
          "",
          "[Removed Lines]",
          "656:  i = try_msr_calibrate_tsc(&fast_calibrate);",
          "658:  if (i >= 0) {",
          "659:   if (i == 0)",
          "660:    pr_warn(\"Fast TSC calibration using MSR failed\\n\");",
          "662:  }",
          "",
          "[Added Lines]",
          "656:  fast_calibrate = try_msr_calibrate_tsc();",
          "658:  if (fast_calibrate)",
          "",
          "---------------"
        ],
        "arch/x86/kernel/tsc_msr.c||arch/x86/kernel/tsc_msr.c": [
          "File: arch/x86/kernel/tsc_msr.c -> arch/x86/kernel/tsc_msr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: {",
          "88:  u32 lo, hi, ratio, freq_id, freq;",
          "90:  cpu_index = match_cpu(boot_cpu_data.x86, boot_cpu_data.x86_model);",
          "91:  if (cpu_index < 0)",
          "96:  if (freq_desc_tables[cpu_index].msr_plat) {",
          "97:   rdmsr(MSR_PLATFORM_INFO, lo, hi);",
          "",
          "[Removed Lines]",
          "85: int try_msr_calibrate_tsc(unsigned long *fast_calibrate)",
          "87:  int cpu_index;",
          "92:   return -1;",
          "",
          "[Added Lines]",
          "83: unsigned long try_msr_calibrate_tsc(void)",
          "86:  unsigned long res;",
          "87:  int cpu_index;",
          "91:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "103:  pr_info(\"Maximum core-clock to bus-clock ratio: 0x%x\\n\", ratio);",
          "105:  if (!ratio)",
          "109:  rdmsr(MSR_FSB_FREQ, lo, hi);",
          "",
          "[Removed Lines]",
          "106:   return 0;",
          "",
          "[Added Lines]",
          "103:   goto fail;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "112:  pr_info(\"Resolved frequency ID: %u, frequency: %u KHz\\n\",",
          "113:     freq_id, freq);",
          "114:  if (!freq)",
          "121: #ifdef CONFIG_X86_LOCAL_APIC",
          "122:  lapic_timer_frequency = (freq * 1000) / HZ;",
          "123:  pr_info(\"lapic_timer_frequency = %d\\n\", lapic_timer_frequency);",
          "124: #endif",
          "127: }",
          "",
          "[Removed Lines]",
          "115:   return 0;",
          "119:  pr_info(\"TSC runs at %lu KHz\\n\", *fast_calibrate);",
          "126:  return 1;",
          "",
          "[Added Lines]",
          "112:   goto fail;",
          "115:  res = freq * ratio;",
          "116:  pr_info(\"TSC runs at %lu KHz\\n\", res);",
          "122:  return res;",
          "124: fail:",
          "125:  pr_warn(\"Fast TSC calibration using MSR failed\\n\");",
          "126:  return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0e5c93e0200e9759561377d51d5478134f50f7ee",
      "candidate_info": {
        "commit_hash": "0e5c93e0200e9759561377d51d5478134f50f7ee",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0e5c93e0200e9759561377d51d5478134f50f7ee",
        "files": [
          "drivers/mmc/host/omap.c"
        ],
        "message": "mmc: omap: Fix NULL pointer dereference due uninitialized cover_tasklet\n\nOmap MMC driver initialization can cause a NULL pointer dereference in\ntasklet_hi_action on Nokia N810 if its miniSD cover is open during driver\ninitialization.\n\n[    1.070000] Unable to handle kernel NULL pointer dereference at virtual address 00000000\n[    1.080000] pgd = c0004000\n[    1.080000] [00000000] *pgd=00000000\n[    1.080000] Internal error: Oops: 80000005 [#1] PREEMPT ARM\n[    1.080000] Modules linked in:\n[    1.080000] CPU: 0 PID: 24 Comm: kworker/0:1 Not tainted 3.13.0-rc2+ #95\n[    1.080000] Workqueue: events menelaus_work\n[    1.080000] task: c7863340 ti: c7878000 task.ti: c7878000\n[    1.080000] PC is at 0x0\n[    1.080000] LR is at tasklet_hi_action+0x68/0xa4\n...\n[    1.080000] [<c003543c>] (tasklet_hi_action+0x68/0xa4) from [<c0034dd0>] (__do_softirq+0xbc/0x208)\n[    1.080000] [<c0034dd0>] (__do_softirq+0xbc/0x208) from [<c003521c>] (irq_exit+0x84/0xac)\n[    1.080000] [<c003521c>] (irq_exit+0x84/0xac) from [<c00135cc>] (handle_IRQ+0x64/0x84)\n[    1.080000] [<c00135cc>] (handle_IRQ+0x64/0x84) from [<c000859c>] (omap2_intc_handle_irq+0x54/0x68)\n[    1.080000] [<c000859c>] (omap2_intc_handle_irq+0x54/0x68) from [<c0015be0>] (__irq_svc+0x40/0x74)\n[    1.080000] Exception stack(0xc7879d70 to 0xc7879db8)\n[    1.080000] 9d60:                                     000003f1 0000000a 00000009 0000001c\n[    1.080000] 9d80: c7879e70 c780bc10 c780bc10 00000000 00000001 00008603 c780bc78 c7879e4e\n[    1.080000] 9da0: 00000002 c7879db8 c00343b0 c0160c9c 20000113 ffffffff\n[    1.080000] [<c0015be0>] (__irq_svc+0x40/0x74) from [<c0160c9c>] (__aeabi_uidiv+0x20/0x9c)\n[    1.080000] [<c0160c9c>] (__aeabi_uidiv+0x20/0x9c) from [<c00343b0>] (msecs_to_jiffies+0x18/0x24)\n[    1.080000] [<c00343b0>] (msecs_to_jiffies+0x18/0x24) from [<c01ec3ec>] (omap_i2c_xfer+0x30c/0x458)\n[    1.080000] [<c01ec3ec>] (omap_i2c_xfer+0x30c/0x458) from [<c01e9724>] (__i2c_transfer+0x3c/0x74)\n[    1.080000] [<c01e9724>] (__i2c_transfer+0x3c/0x74) from [<c01eac4c>] (i2c_transfer+0x78/0x94)\n[    1.080000] [<c01eac4c>] (i2c_transfer+0x78/0x94) from [<c01eb0bc>] (i2c_smbus_xfer+0x3c0/0x4f8)\n[    1.080000] [<c01eb0bc>] (i2c_smbus_xfer+0x3c0/0x4f8) from [<c01eb414>] (i2c_smbus_write_byte_data+0x34/0x3c)\n[    1.080000] [<c01eb414>] (i2c_smbus_write_byte_data+0x34/0x3c) from [<c01bb308>] (menelaus_write_reg+0x1c/0x40)\n[    1.080000] [<c01bb308>] (menelaus_write_reg+0x1c/0x40) from [<c01bb904>] (menelaus_work+0xa0/0xc4)\n[    1.080000] [<c01bb904>] (menelaus_work+0xa0/0xc4) from [<c00439c4>] (process_one_work+0x1fc/0x334)\n[    1.080000] [<c00439c4>] (process_one_work+0x1fc/0x334) from [<c0043d6c>] (worker_thread+0x244/0x380)\n[    1.080000] [<c0043d6c>] (worker_thread+0x244/0x380) from [<c0049d04>] (kthread+0xc0/0xd4)\n[    1.080000] [<c0049d04>] (kthread+0xc0/0xd4) from [<c0012758>] (ret_from_fork+0x14/0x3c)\n[    1.080000] Code: bad PC value\n[    1.090000] ---[ end trace 7bc2fc7cd14f1d95 ]---\n[    1.100000] Kernel panic - not syncing: Fatal exception in interrupt\n\nReason for this is that omap_notify_cover_event which calls\ntasklet_hi_schedule gets called before struct cover_tasklet is initialized.\n\nCall to omap_notify_cover_event on Nokia N810 happens from menelaus.c PMIC\ndriver via board-n8x0.c during execution of mmc_add_host in case of open\nminiSD cover.\n\nFix this by moving cover_timer and cover_tasklet initialization before\nmmc_add_host call in mmc_omap_new_slot.\n\nSigned-off-by: Jarkko Nikula <jarkko.nikula@bitmer.com>\nAcked-by: Tony Lindgren <tony@atomide.com>\nTested-by: Aaro Koskinen <aaro.koskinen@iki.fi>\nSigned-off-by: Chris Ball <chris@printf.net>",
        "before_after_code_files": [
          "drivers/mmc/host/omap.c||drivers/mmc/host/omap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mmc/host/omap.c||drivers/mmc/host/omap.c": [
          "File: drivers/mmc/host/omap.c -> drivers/mmc/host/omap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1262:  mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;",
          "1263:  mmc->max_seg_size = mmc->max_req_size;",
          "1265:  r = mmc_add_host(mmc);",
          "1266:  if (r < 0)",
          "1267:   goto err_remove_host;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1265:  if (slot->pdata->get_cover_state != NULL) {",
          "1266:   setup_timer(&slot->cover_timer, mmc_omap_cover_timer,",
          "1267:        (unsigned long)slot);",
          "1268:   tasklet_init(&slot->cover_tasklet, mmc_omap_cover_handler,",
          "1269:         (unsigned long)slot);",
          "1270:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1278:      &dev_attr_cover_switch);",
          "1279:   if (r < 0)",
          "1280:    goto err_remove_slot_name;",
          "1286:   tasklet_schedule(&slot->cover_tasklet);",
          "1287:  }",
          "",
          "[Removed Lines]",
          "1282:   setup_timer(&slot->cover_timer, mmc_omap_cover_timer,",
          "1283:        (unsigned long)slot);",
          "1284:   tasklet_init(&slot->cover_tasklet, mmc_omap_cover_handler,",
          "1285:         (unsigned long)slot);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
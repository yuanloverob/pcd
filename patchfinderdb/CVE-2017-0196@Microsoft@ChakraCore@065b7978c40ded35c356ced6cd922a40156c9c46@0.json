{
  "cve_id": "CVE-2017-0196",
  "cve_desc": "An information disclosure vulnerability in Microsoft scripting engine allows remote attackers to obtain sensitive information from process memory via a crafted web site, aka \"Microsoft Browser Information Disclosure Vulnerability.\"",
  "repo": "Microsoft/ChakraCore",
  "patch_hash": "065b7978c40ded35c356ced6cd922a40156c9c46",
  "patch_info": {
    "commit_hash": "065b7978c40ded35c356ced6cd922a40156c9c46",
    "repo": "Microsoft/ChakraCore",
    "commit_url": "https://github.com/Microsoft/ChakraCore/commit/065b7978c40ded35c356ced6cd922a40156c9c46",
    "files": [
      "lib/Runtime/Library/JavascriptArray.cpp",
      "test/Array/Array_TypeConfusion_bugs.js"
    ],
    "message": "[CVE-2017-0196] Fixing an heap overread during slice.\n\nThe MissingItem check is happening on the array in a loop. It is possible that we get called into script and that mutates the array. So the Array's head is newly created with length.\nHowever the loop is still performing over the old length.\nFixed this by checking the length In IsMissingItem function.\nAdded a unittest.",
    "before_after_code_files": [
      "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp",
      "test/Array/Array_TypeConfusion_bugs.js||test/Array/Array_TypeConfusion_bugs.js"
    ]
  },
  "patch_diff": {
    "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
      "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "478:     bool JavascriptArray::IsMissingItem(uint32 index)",
      "479:     {",
      "480:         bool isIntArray = false, isFloatArray = false;",
      "481:         this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "480:         if (this->length <= index)",
      "481:         {",
      "482:             return false;",
      "483:         }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5768:         if (!pArr->HasNoMissingValues())",
      "5769:         {",
      "5771:             {",
      "",
      "[Removed Lines]",
      "5770:             for (uint32 i = 0; i < newLen; i++)",
      "",
      "[Added Lines]",
      "5775:             for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)",
      "",
      "---------------"
    ],
    "test/Array/Array_TypeConfusion_bugs.js||test/Array/Array_TypeConfusion_bugs.js": [
      "File: test/Array/Array_TypeConfusion_bugs.js -> test/Array/Array_TypeConfusion_bugs.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "593:             assert.areEqual(101, arr.length);",
      "594:         }",
      "595:     },",
      "596: ];",
      "597: testRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "596:     {",
      "597:         name: \"Heap overread when splice mutates the array when executing slice\",",
      "598:         body: function ()",
      "599:         {",
      "600:             var getterCalled = false;",
      "601:             var a = [1, 2];",
      "602:             for (var i = 0; i < 100 * 1024; i++) {",
      "603:                 a.push(i);",
      "604:             }",
      "605:             delete a[0]; // Make a missing item",
      "606:             var protoObj = [11];",
      "607:             Object.defineProperty(protoObj, '0', {",
      "608:                 get : function () {",
      "609:                     getterCalled = true;",
      "610:                     Object.setPrototypeOf(a, Array.prototype);",
      "611:                     a.splice(0); // head seg is now length=0",
      "612:                     return 42;",
      "613:                 },",
      "614:                 configurable : true",
      "615:             });",
      "616:             Object.setPrototypeOf(a, protoObj);",
      "617:             var b = a.slice();",
      "618:             assert.isTrue(getterCalled);",
      "619:             assert.areEqual(0, a.length, \"Getter will splice the array to zero length\");",
      "620:             assert.areEqual(100 * 1024 + 2, b.length, \"Validating that slice will return the full array even though splice is deleting the whole array\");",
      "621:         }",
      "622:     },",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e701fc77a1c867ffa90a039fc69cf0b82e401240",
      "candidate_info": {
        "commit_hash": "e701fc77a1c867ffa90a039fc69cf0b82e401240",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/e701fc77a1c867ffa90a039fc69cf0b82e401240",
        "files": [
          "lib/Backend/Lower.cpp"
        ],
        "message": "[CVE-2017-0151] fix issue with using wrong size reg when lowering bound check",
        "before_after_code_files": [
          "lib/Backend/Lower.cpp||lib/Backend/Lower.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Backend/Lower.cpp||lib/Backend/Lower.cpp": [
          "File: lib/Backend/Lower.cpp -> lib/Backend/Lower.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "12848:         Assert(!offsetOpnd || offsetOpnd->GetValue() == offset);",
          "12850:         autoReuseAddResultOpnd.Initialize(addResultOpnd, func);",
          "12851:         InsertAdd(",
          "12852:             true,",
          "12853:             addResultOpnd,",
          "12854:             rightOpnd,",
          "12856:             insertBeforeInstr);",
          "12857:         InsertBranch(LowererMD::MDOverflowBranchOpcode, bailOutLabel, insertBeforeInstr);",
          "",
          "[Removed Lines]",
          "12849:         IR::RegOpnd *const addResultOpnd = IR::RegOpnd::New(TyMachReg, func);",
          "12855:             offsetOpnd ? offsetOpnd->UseWithNewType(TyMachReg, func) : IR::IntConstOpnd::New(offset, TyMachReg, func, true),",
          "",
          "[Added Lines]",
          "12849:         IR::RegOpnd *const addResultOpnd = IR::RegOpnd::New(TyInt32, func);",
          "12855:             offsetOpnd ? offsetOpnd->UseWithNewType(TyInt32, func) : IR::IntConstOpnd::New(offset, TyInt32, func, true),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb08c4d98775977297c3c44e6b804fb770b41f4d",
      "candidate_info": {
        "commit_hash": "fb08c4d98775977297c3c44e6b804fb770b41f4d",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/fb08c4d98775977297c3c44e6b804fb770b41f4d",
        "files": [
          "lib/Runtime/Library/ArrayBuffer.cpp"
        ],
        "message": "ArrayBuffer.Transfer needs Detached ArrayBuffer check",
        "before_after_code_files": [
          "lib/Runtime/Library/ArrayBuffer.cpp||lib/Runtime/Library/ArrayBuffer.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Runtime/Library/ArrayBuffer.cpp||lib/Runtime/Library/ArrayBuffer.cpp": [
          "File: lib/Runtime/Library/ArrayBuffer.cpp -> lib/Runtime/Library/ArrayBuffer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "292:         if (args.Info.Count >= 3)",
          "293:         {",
          "294:             newBufferLength = ToIndex(args[2], JSERR_ArrayLengthConstructIncorrect, scriptContext, MaxArrayBufferLength);",
          "295:         }",
          "297:         return arrayBuffer->TransferInternal(newBufferLength);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "297:             if (arrayBuffer->IsDetached())",
          "298:             {",
          "299:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.transfer\"));",
          "300:             }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9da019424601325a6e95e6be0fa03d7d21d0b517",
      "candidate_info": {
        "commit_hash": "9da019424601325a6e95e6be0fa03d7d21d0b517",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517",
        "files": [
          "lib/Parser/Parse.cpp",
          "lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
          "test/es6/default-splitscope.js"
        ],
        "message": "[CVE-2017-0152] MSFT: 10592731 : Issue with Function name capturing in param scope\n\nIn a function expression with name, where the name is captured in one\nof the param scope functions, if there is a function or var declaration\nwith the same name as the function expression name we were marking the\nfunction expression name as shadowed. In non-eval case this causes\nissue because the name symbol won't get added to the body. This change is to\nfix it in such a way if the name is captured in the param scope then we\nsplit the param and body scope such that the name symbol is added to the\nparam scope not body scope.",
        "before_after_code_files": [
          "lib/Parser/Parse.cpp||lib/Parser/Parse.cpp",
          "lib/Runtime/ByteCode/ByteCodeEmitter.cpp||lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
          "test/es6/default-splitscope.js||test/es6/default-splitscope.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Parser/Parse.cpp||lib/Parser/Parse.cpp": [
          "File: lib/Parser/Parse.cpp -> lib/Parser/Parse.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "5198:                         paramScope->SetCannotMergeWithBodyScope();",
          "5199:                     }",
          "5200:                 }",
          "5201:             }",
          "5202:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5201:                 if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)",
          "5202:                 {",
          "5203:                     Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;",
          "5204:                     if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)",
          "5205:                     {",
          "5210:                         paramScope->SetCannotMergeWithBodyScope();",
          "5211:                     }",
          "5212:                 }",
          "",
          "---------------"
        ],
        "lib/Runtime/ByteCode/ByteCodeEmitter.cpp||lib/Runtime/ByteCode/ByteCodeEmitter.cpp": [
          "File: lib/Runtime/ByteCode/ByteCodeEmitter.cpp -> lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "3319:         {",
          "3322:             paramScope->ForEachSymbol([&](Symbol* param) {",
          "3323:                 Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());",
          "3324:                 Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3322:             Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3327:                 {",
          "3329:                 }",
          "3331:                 {",
          "",
          "[Removed Lines]",
          "3330:                 else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))",
          "",
          "[Added Lines]",
          "3331:                 else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol",
          "3333:                     && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))",
          "",
          "---------------"
        ],
        "test/es6/default-splitscope.js||test/es6/default-splitscope.js": [
          "File: test/es6/default-splitscope.js -> test/es6/default-splitscope.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:             return a;",
          "160:         }",
          "161:         assert.areEqual(10, f11()(), \"Recursive call to the function from the body scope returns the right value when eval is there in the body\");",
          "162:     }",
          "163:  },",
          "164:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:         function f13() {",
          "164:             var a = function jnvgfg(sfgnmj = function ccunlk() { jnvgfg(undefined, 1); }, b) {",
          "165:                 if (b) {",
          "166:                     assert.areEqual(undefined, jnvgfg, \"This refers to the instance in the body and the value of the function expression is not copied over\");",
          "167:                 }",
          "168:                 var jnvgfg = 10;",
          "169:                 if (!b) {",
          "170:                     sfgnmj();",
          "171:                     return 100;",
          "172:                 }",
          "173:             };",
          "174:             assert.areEqual(100, a(), \"After the recursion the right value is returned by the split scoped function\");",
          "175:         };",
          "176:         f13();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "05af363cd3ff6d5558615bff235356c316936d44",
      "candidate_info": {
        "commit_hash": "05af363cd3ff6d5558615bff235356c316936d44",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/05af363cd3ff6d5558615bff235356c316936d44",
        "files": [
          "lib/Runtime/Library/JavascriptArray.cpp"
        ],
        "message": "add few missing CopyOnAccessNativeIntArray conversions",
        "before_after_code_files": [
          "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ],
          "candidate": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
          "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "9841:                 if (JavascriptArray::Is(newObj))",
          "9842:                 {",
          "9843:                     newArr = JavascriptArray::FromVar(newObj);",
          "9844:                 }",
          "9845:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9843: #if ENABLE_COPYONACCESS_ARRAY",
          "9844:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9845: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9891:                 if (JavascriptArray::Is(newObj))",
          "9892:                 {",
          "9893:                     newArr = JavascriptArray::FromVar(newObj);",
          "9894:                 }",
          "9895:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9896: #if ENABLE_COPYONACCESS_ARRAY",
          "9897:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9898: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "10001:             if (JavascriptArray::Is(newObj))",
          "10002:             {",
          "10003:                 newArr = JavascriptArray::FromVar(newObj);",
          "10004:             }",
          "10005:             else if (TypedArrayBase::Is(newObj))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10009: #if ENABLE_COPYONACCESS_ARRAY",
          "10010:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "10011: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7854cdc7b54251868163ce33327de6158dd8bea",
      "candidate_info": {
        "commit_hash": "b7854cdc7b54251868163ce33327de6158dd8bea",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/b7854cdc7b54251868163ce33327de6158dd8bea",
        "files": [
          "lib/Runtime/Language/AsmJsModule.cpp"
        ],
        "message": "[CVE-2017-0035] Asm.Js: Assign function number in order using internal list instead of parse node index.",
        "before_after_code_files": [
          "lib/Runtime/Language/AsmJsModule.cpp||lib/Runtime/Language/AsmJsModule.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Runtime/Language/AsmJsModule.cpp||lib/Runtime/Language/AsmJsModule.cpp": [
          "File: lib/Runtime/Language/AsmJsModule.cpp -> lib/Runtime/Language/AsmJsModule.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1086:         {",
          "1087:             if( DefineIdentifier( name, func ) )",
          "1088:             {",
          "1092:                 return func;",
          "1093:             }",
          "",
          "[Removed Lines]",
          "1089:                 func->SetFunctionIndex( pnodeFnc->sxFnc.nestedIndex );",
          "1091:                 mFunctionArray.SetItem( func->GetFunctionIndex(), func );",
          "",
          "[Added Lines]",
          "1089:                 uint index = (uint)mFunctionArray.Count();",
          "1090:                 if (pnodeFnc->sxFnc.nestedIndex != index)",
          "1091:                 {",
          "1092:                     return nullptr;",
          "1093:                 }",
          "1094:                 func->SetFunctionIndex( (RegSlot)index );",
          "1095:                 mFunctionArray.Add( func );",
          "1096:                 Assert(index + 1 == (uint)mFunctionArray.Count());",
          "",
          "---------------"
        ]
      }
    }
  ]
}
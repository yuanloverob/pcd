{
  "cve_id": "CVE-2014-5336",
  "cve_desc": "Monkey HTTP Server before 1.5.3, when the File Descriptor Table (FDT) is enabled and custom error messages are set, allows remote attackers to cause a denial of service (file descriptor consumption) via an HTTP request that triggers an error message.",
  "repo": "monkey/monkey",
  "patch_hash": "b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd",
  "patch_info": {
    "commit_hash": "b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd",
    "repo": "monkey/monkey",
    "commit_url": "https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd",
    "files": [
      "include/monkey/mk_request.h",
      "src/mk_request.c",
      "src/mk_vhost.c"
    ],
    "message": "Request: new request session flag to mark those files opened by FDT\n\nThis patch aims to fix a potential DDoS problem that can be caused\nin the server quering repetitive non-existent resources.\n\nWhen serving a static file, the core use Vhost FDT mechanism, but if\nit sends a static error page it does a direct open(2). When closing\nthe resources for the same request it was just calling mk_vhost_close()\nwhich did not clear properly the file descriptor.\n\nThis patch adds a new field on the struct session_request called 'fd_is_fdt',\nwhich contains MK_TRUE or MK_FALSE depending of how fd_file was opened.\n\nThanks to Matthew Daley <mattd@bugfuzz.com> for report and troubleshoot this\nproblem.\n\nSigned-off-by: Eduardo Silva <eduardo@monkey.io>",
    "before_after_code_files": [
      "include/monkey/mk_request.h||include/monkey/mk_request.h",
      "src/mk_request.c||src/mk_request.c",
      "src/mk_vhost.c||src/mk_vhost.c"
    ]
  },
  "patch_diff": {
    "include/monkey/mk_request.h||include/monkey/mk_request.h": [
      "File: include/monkey/mk_request.h -> include/monkey/mk_request.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "159:     long port;",
      "163:     int fd_file;",
      "165:     int headers_len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "172:     int fd_is_fdt;",
      "",
      "---------------"
    ],
    "src/mk_request.c||src/mk_request.c": [
      "File: src/mk_request.c -> src/mk_request.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "99: void mk_request_free(struct session_request *sr)",
      "100: {",
      "101:     if (sr->fd_file > 0) {",
      "103:     }",
      "105:     if (sr->headers.location) {",
      "",
      "[Removed Lines]",
      "102:         mk_vhost_close(sr);",
      "",
      "[Added Lines]",
      "102:         if (sr->fd_is_fdt == MK_TRUE) {",
      "103:             mk_vhost_close(sr);",
      "104:         }",
      "105:         else {",
      "106:             close(sr->fd_file);",
      "107:         }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "841:                 break;",
      "842:             }",
      "845:             sr->bytes_to_send = finfo.size;",
      "846:             sr->headers.content_length = finfo.size;",
      "847:             sr->headers.real_length    = finfo.size;",
      "",
      "[Removed Lines]",
      "844:             sr->fd_file = fd;",
      "",
      "[Added Lines]",
      "849:             sr->fd_file   = fd;",
      "850:             sr->fd_is_fdt = MK_FALSE;",
      "",
      "---------------"
    ],
    "src/mk_vhost.c||src/mk_vhost.c": [
      "File: src/mk_vhost.c -> src/mk_vhost.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "221:             sr->vhost_fdt_id   = id;",
      "222:             sr->vhost_fdt_hash = hash;",
      "224:             return fd;",
      "225:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "223:             sr->fd_is_fdt      = MK_TRUE;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3397d97cfddcfc829511416e7095e295ebe192b0",
      "candidate_info": {
        "commit_hash": "3397d97cfddcfc829511416e7095e295ebe192b0",
        "repo": "monkey/monkey",
        "commit_url": "https://github.com/monkey/monkey/commit/3397d97cfddcfc829511416e7095e295ebe192b0",
        "files": [
          "include/monkey/mk_header.h",
          "include/monkey/mk_http.h",
          "include/monkey/mk_http_internal.h",
          "include/monkey/mk_iov.h",
          "include/monkey/mk_plugin.h",
          "include/monkey/mk_stream.h",
          "src/mk_header.c",
          "src/mk_http.c",
          "src/mk_plugin.c",
          "src/mk_scheduler.c",
          "src/mk_stream.c",
          "src/mk_vhost.c"
        ],
        "message": "Core: dispatch headers and static files using Streams\n\nSigned-off-by: Eduardo Silva <eduardo@monkey.io>",
        "before_after_code_files": [
          "include/monkey/mk_header.h||include/monkey/mk_header.h",
          "include/monkey/mk_http.h||include/monkey/mk_http.h",
          "include/monkey/mk_http_internal.h||include/monkey/mk_http_internal.h",
          "include/monkey/mk_iov.h||include/monkey/mk_iov.h",
          "include/monkey/mk_plugin.h||include/monkey/mk_plugin.h",
          "include/monkey/mk_stream.h||include/monkey/mk_stream.h",
          "src/mk_header.c||src/mk_header.c",
          "src/mk_http.c||src/mk_http.c",
          "src/mk_plugin.c||src/mk_plugin.c",
          "src/mk_scheduler.c||src/mk_scheduler.c",
          "src/mk_stream.c||src/mk_stream.c",
          "src/mk_vhost.c||src/mk_vhost.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/mk_vhost.c||src/mk_vhost.c"
          ],
          "candidate": [
            "src/mk_vhost.c||src/mk_vhost.c"
          ]
        }
      },
      "candidate_diff": {
        "include/monkey/mk_header.h||include/monkey/mk_header.h": [
          "File: include/monkey/mk_header.h -> include/monkey/mk_header.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "101: extern const mk_ptr_t mk_header_te_chunked;",
          "102: extern const mk_ptr_t mk_header_last_modified;",
          "105: void mk_header_response_reset(struct response_headers *header);",
          "106: void mk_header_set_http_status(struct mk_http_request *sr, int status);",
          "107: void mk_header_set_content_length(struct mk_http_request *sr, long len);",
          "",
          "[Removed Lines]",
          "104: int mk_header_send(int fd, struct mk_http_session *cs, struct mk_http_request *sr);",
          "",
          "[Added Lines]",
          "104: int mk_header_prepare(struct mk_http_session *cs, struct mk_http_request *sr);",
          "",
          "---------------"
        ],
        "include/monkey/mk_http.h||include/monkey/mk_http.h": [
          "File: include/monkey/mk_http.h -> include/monkey/mk_http.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:     unsigned int body_size;",
          "116:     unsigned int body_length;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:     mk_channel_t channel;",
          "",
          "---------------"
        ],
        "include/monkey/mk_http_internal.h||include/monkey/mk_http_internal.h": [
          "File: include/monkey/mk_http_internal.h -> include/monkey/mk_http_internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #ifndef MK_HTTP_INTERNAL_H",
          "21: #define MK_HTTP_INTERNAL_H",
          "23: struct response_headers",
          "24: {",
          "25:     int status;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include <monkey/mk_stream.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:     long port;",
          "95:     int headers_len;",
          "",
          "[Removed Lines]",
          "91:     int fd_file;",
          "92:     int fd_is_fdt;",
          "",
          "[Added Lines]",
          "85:     mk_stream_t headers_stream;",
          "86:     mk_stream_t headers_extra_stream;",
          "87:     mk_stream_t file_stream;",
          "88:     mk_stream_t page_stream;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "164:     int vhost_fdt_id;",
          "165:     unsigned int vhost_fdt_hash;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:     int vhost_fdt_enabled;",
          "",
          "---------------"
        ],
        "include/monkey/mk_iov.h||include/monkey/mk_iov.h": [
          "File: include/monkey/mk_iov.h -> include/monkey/mk_iov.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "96:         _mk_iov_set_free(mk_io, buf);",
          "97:     }",
          "99:     mk_bug(mk_io->iov_idx > mk_io->size);",
          "101:     return mk_io->iov_idx;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:     if (mk_io->iov_idx > mk_io->size) {",
          "100:         printf(\"iov idx=%i size=%i\\n\", mk_io->iov_idx, mk_io->size);",
          "101:     }",
          "",
          "---------------"
        ],
        "include/monkey/mk_plugin.h||include/monkey/mk_plugin.h": [
          "File: include/monkey/mk_plugin.h -> include/monkey/mk_plugin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:     int  (*file_get_info) (const char *, struct file_info *);",
          "142:     struct mk_http_header *(*header_get) (int, struct mk_http_request *,",
          "143:                                           const char *, unsigned int);",
          "144:     int  (*header_add) (struct mk_http_request *, char *row, int len);",
          "",
          "[Removed Lines]",
          "141:     int  (*header_send) (int, struct mk_http_session *, struct mk_http_request *);",
          "",
          "[Added Lines]",
          "141:     int  (*header_prepare) (struct mk_http_session *,",
          "142:                             struct mk_http_request *);",
          "",
          "---------------"
        ],
        "include/monkey/mk_stream.h||include/monkey/mk_stream.h": [
          "File: include/monkey/mk_stream.h -> include/monkey/mk_stream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:     stream->bytes_total -= bytes;",
          "163: }",
          "165: mk_stream_t *mk_stream_new(int type, mk_channel_t *channel,",
          "166:                            void *data, size_t size,",
          "167:                            void (*cb_finished) (mk_stream_t *),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165: static inline void mk_channel_debug(mk_channel_t *channel)",
          "166: {",
          "167:     int i;",
          "168:     struct mk_list *head;",
          "169:     mk_stream_t *stream;",
          "171:     mk_list_foreach(head, &channel->streams) {",
          "172:         stream = mk_list_entry(head, mk_stream_t, _head);",
          "173:         switch (stream->type) {",
          "174:         case MK_STREAM_RAW:",
          "175:             printf(\"%i) STREAM RAW\\n\", i);",
          "176:             break;",
          "177:         case MK_STREAM_IOV:",
          "178:             printf(\"%i) STREAM IOV\\n\", i);",
          "179:             break;",
          "180:         case MK_STREAM_PTR:",
          "181:             printf(\"%i) STREAM PTR\\n\", i);",
          "182:             break;",
          "183:         case MK_STREAM_FILE:",
          "184:             printf(\"%i) STREAM FILE\\n\", i);",
          "185:             break;",
          "186:         case MK_STREAM_SOCKET:",
          "187:             printf(\"%i) STREAM SOCKET\\n\", i);",
          "188:             break;",
          "189:         }",
          "190:         i++;",
          "191:     }",
          "192: }",
          "",
          "---------------"
        ],
        "src/mk_header.c||src/mk_header.c": [
          "File: src/mk_header.c -> src/mk_header.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "129: static const int status_response_len =",
          "130:     (sizeof(status_response)/(sizeof(status_response[0])));",
          "134: {",
          "135:     mk_iov_free_marked(iov);",
          "136: }",
          "141: {",
          "142:     int i=0;",
          "143:     unsigned long len = 0;",
          "",
          "[Removed Lines]",
          "133: static void mk_header_iov_free(struct mk_iov *iov)",
          "139: int mk_header_send(int fd, struct mk_http_session *cs,",
          "140:                    struct mk_http_request *sr)",
          "",
          "[Added Lines]",
          "132: static void cb_stream_iov_free(struct mk_stream *stream)",
          "133: {",
          "134:     struct mk_iov *iov = stream->data;",
          "135:     mk_iov_free_marked(iov);",
          "136: }",
          "138: static void cb_stream_iov_extended_free(struct mk_stream *stream)",
          "140:     struct mk_iov *iov = stream->data;",
          "145: int mk_header_prepare(struct mk_http_session *cs,",
          "146:                       struct mk_http_request *sr)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:         }",
          "341:     }",
          "345:     if (sh->cgi == SH_NOCGI || sh->breakline == MK_HEADER_BREAKLINE) {",
          "346:         if (!sr->headers._extra_rows) {",
          "",
          "[Removed Lines]",
          "343:     mk_server_cork_flag(fd, TCP_CORK_ON);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "353:         }",
          "354:     }",
          "357:     if (sr->headers._extra_rows) {",
          "361:     }",
          "364:     sh->sent = MK_TRUE;",
          "366:     return 0;",
          "367: }",
          "",
          "[Removed Lines]",
          "356:     mk_socket_sendv(fd, iov);",
          "358:         mk_socket_sendv(fd, sr->headers._extra_rows);",
          "359:         mk_iov_free(sr->headers._extra_rows);",
          "360:         sr->headers._extra_rows = NULL;",
          "363:     mk_header_iov_free(iov);",
          "",
          "[Added Lines]",
          "367:     mk_stream_set(&sr->headers_stream,",
          "368:                   MK_STREAM_IOV, &cs->channel,",
          "369:                   iov,",
          "370:                   -1,",
          "371:                   cb_stream_iov_free, NULL, NULL);",
          "372:     mk_channel_append_stream(&cs->channel, &sr->headers_stream);",
          "376:         mk_stream_set(&sr->headers_extra_stream,",
          "377:                       MK_STREAM_IOV, &cs->channel,",
          "378:                       sr->headers._extra_rows, -1,",
          "379:                       cb_stream_iov_extended_free, NULL, NULL);",
          "",
          "---------------"
        ],
        "src/mk_http.c||src/mk_http.c": [
          "File: src/mk_http.c -> src/mk_http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:     request->connection.len = -1;",
          "74:     request->file_info.size = -1;",
          "75:     request->bytes_offset  = 0;",
          "79:     request->host.data = NULL;",
          "80:     request->stage30_blocked = MK_FALSE;",
          "81:     request->session = session;",
          "",
          "[Removed Lines]",
          "76:     request->bytes_to_send = -1;",
          "77:     request->fd_file = -1;",
          "78:     request->fd_is_fdt = MK_FALSE;",
          "",
          "[Added Lines]",
          "76:     request->file_stream.bytes_total = -1;",
          "77:     request->file_stream.bytes_offset = 0;",
          "78:     request->vhost_fdt_enabled = MK_FALSE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "225:             mk_header_set_http_status(sr, MK_REDIR_MOVED);",
          "226:             sr->headers.location = mk_string_dup(sr->host_conf->header_redirect.data);",
          "227:             sr->headers.content_length = 0;",
          "229:             sr->headers.location = NULL;",
          "230:             mk_server_cork_flag(cs->socket, TCP_CORK_OFF);",
          "231:             return 0;",
          "232:         }",
          "",
          "[Removed Lines]",
          "228:             mk_header_send(cs->socket, cs, sr);",
          "",
          "[Added Lines]",
          "229:             mk_header_prepare(cs, sr);",
          "230:             mk_channel_write(&cs->channel);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "255:     status = mk_http_init(cs, sr);",
          "259:     return status;",
          "260: }",
          "",
          "[Removed Lines]",
          "257:     MK_TRACE(\"[FD %i] HTTP Init returning %i\", socket, status);",
          "",
          "[Added Lines]",
          "258:     MK_TRACE(\"[FD %i] HTTP Init returning %i\", cs->socket, status);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "399: int mk_http_handler_write(int socket, struct mk_http_session *cs)",
          "400: {",
          "401:     int final_status = 0;",
          "402:     struct mk_http_request *sr_node;",
          "403:     struct mk_list *sr_list;",
          "404:     struct mk_list *sr_head;",
          "405:     (void) socket;",
          "433:                     return -1;",
          "434:                 }",
          "438:             }",
          "439:         }",
          "440:     }",
          "445:     return 0;",
          "446: }",
          "",
          "[Removed Lines]",
          "407:     sr_list = &cs->request_list;",
          "408:     mk_list_foreach(sr_head, sr_list) {",
          "409:         sr_node = mk_list_entry_first(sr_list, struct mk_http_request, _head);",
          "411:         if (sr_node->bytes_to_send > 0) {",
          "413:             final_status = mk_http_send_file(cs, sr_node);",
          "414:         }",
          "415:         else if (sr_node->bytes_to_send <= 0) {",
          "416:             final_status = mk_http_request_prepare(cs, sr_node);",
          "417:         }",
          "423:         if (final_status > 0) {",
          "424:             return final_status;",
          "425:         }",
          "426:         else {",
          "428:             mk_plugin_stage_run_40(cs, sr_node);",
          "429:             switch (final_status) {",
          "430:             case EXIT_NORMAL:",
          "431:             case EXIT_ERROR:",
          "432:                 if (sr_node->close_now == MK_TRUE) {",
          "435:                 break;",
          "436:             case EXIT_ABORT:",
          "437:                 return -1;",
          "",
          "[Added Lines]",
          "402:     int ret;",
          "410:     ret = mk_channel_write(&cs->channel);",
          "411:     if (ret == MK_CHANNEL_ERROR) {",
          "412:         return -1;",
          "413:     }",
          "414:     else if (ret == MK_CHANNEL_EMPTY) {",
          "415:         sr_list = &cs->request_list;",
          "416:         mk_list_foreach(sr_head, sr_list) {",
          "417:             sr_node = mk_list_entry_first(sr_list,",
          "418:                                           struct mk_http_request, _head);",
          "420:             if (sr_node->bytes_to_send > 0) {",
          "422:                 final_status = mk_http_send_file(cs, sr_node);",
          "423:             }",
          "424:             else if (sr_node->bytes_to_send <= 0) {",
          "425:                 final_status = mk_http_request_prepare(cs, sr_node);",
          "426:             }",
          "432:             if (final_status > 0) {",
          "433:                 return final_status;",
          "434:             }",
          "435:             else {",
          "437:                 mk_plugin_stage_run_40(cs, sr_node);",
          "438:                 switch (final_status) {",
          "439:                 case EXIT_NORMAL:",
          "440:                 case EXIT_ERROR:",
          "441:                     if (sr_node->close_now == MK_TRUE) {",
          "442:                         return -1;",
          "443:                     }",
          "444:                     break;",
          "445:                 case EXIT_ABORT:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "520:     return mk_http_method_null_p;",
          "521: }",
          "524: {",
          "525:     struct response_headers *sh = &sr->headers;",
          "",
          "[Removed Lines]",
          "523: static int mk_http_range_set(struct mk_http_request *sr, long file_size)",
          "",
          "[Added Lines]",
          "534: static int mk_http_range_set(struct mk_http_request *sr, size_t file_size)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "530:     if (mk_config->resume == MK_TRUE && sr->range.data) {",
          "532:         if (sh->ranges[0] >= 0 && sh->ranges[1] == -1) {",
          "535:         }",
          "538:         if (sh->ranges[0] >= 0 && sh->ranges[1] >= 0) {",
          "541:         }",
          "544:         if (sh->ranges[0] == -1 && sh->ranges[1] > 0) {",
          "547:         }",
          "550:             return -1;",
          "551:         }",
          "554:     }",
          "555:     return 0;",
          "556: }",
          "",
          "[Removed Lines]",
          "533:             sr->bytes_offset = sh->ranges[0];",
          "534:             sr->bytes_to_send = file_size - sr->bytes_offset;",
          "539:             sr->bytes_offset = sh->ranges[0];",
          "540:             sr->bytes_to_send = labs(sh->ranges[1] - sh->ranges[0]) + 1;",
          "545:             sr->bytes_to_send = sh->ranges[1];",
          "546:             sr->bytes_offset = file_size - sh->ranges[1];",
          "549:         if (sr->bytes_offset >= file_size || sr->bytes_to_send > file_size) {",
          "553:         lseek(sr->fd_file, sr->bytes_offset, SEEK_SET);",
          "",
          "[Added Lines]",
          "544:             sr->file_stream.bytes_offset = sh->ranges[0];",
          "545:             sr->file_stream.bytes_total = file_size - sr->file_stream.bytes_offset;",
          "550:             sr->file_stream.bytes_offset = sh->ranges[0];",
          "551:             sr->file_stream.bytes_total = labs(sh->ranges[1] - sh->ranges[0]) + 1;",
          "556:             sr->file_stream.bytes_total = sh->ranges[1];",
          "557:             sr->file_stream.bytes_offset = file_size - sh->ranges[1];",
          "560:         if ((size_t) sr->file_stream.bytes_offset >= file_size ||",
          "561:             sr->file_stream.bytes_total > file_size) {",
          "565:         lseek(sr->file_stream.fd, sr->file_stream.bytes_offset, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "672: static int mk_http_directory_redirect_check(struct mk_http_session *cs,",
          "673:                                             struct mk_http_request *sr)",
          "674: {",
          "676:     int port_redirect = 0;",
          "677:     char *host;",
          "678:     char *location = 0;",
          "",
          "[Removed Lines]",
          "675:     int ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "726:     sr->headers.pconnections_left =",
          "727:         (mk_config->max_keep_alive_request - cs->counter_connections);",
          "",
          "[Removed Lines]",
          "729:     ret = mk_header_send(cs->socket, cs, sr);",
          "730:     if (ret >= 0) {",
          "731:         mk_server_cork_flag(cs->socket, TCP_CORK_OFF);",
          "732:     }",
          "",
          "[Added Lines]",
          "741:     mk_header_prepare(cs, sr);",
          "742:     mk_channel_write(&cs->channel);",
          "743:     mk_server_cork_flag(cs->socket, TCP_CORK_OFF);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "741: }",
          "745: {",
          "746:     unsigned long len;",
          "747:     mk_ptr_t f;",
          "",
          "[Removed Lines]",
          "744: mk_ptr_t mk_http_index_file(char *pathfile, char *file_aux, const unsigned int flen)",
          "",
          "[Added Lines]",
          "755: mk_ptr_t mk_http_index_file(char *pathfile, char *file_aux,",
          "756:                             const unsigned int flen)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "772: int mk_http_init(struct mk_http_session *cs, struct mk_http_request *sr)",
          "773: {",
          "774:     int ret;",
          "776:     struct mimetype *mime;",
          "778:     MK_TRACE(\"[FD %i] HTTP Protocol Init, session %p\", cs->socket, sr);",
          "",
          "[Removed Lines]",
          "775:     int bytes = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "958:         mk_ptr_reset(&sr->headers.content_type);",
          "960:         return EXIT_NORMAL;",
          "961:     }",
          "962:     else {",
          "",
          "[Removed Lines]",
          "959:         mk_header_send(cs->socket, cs, sr);",
          "",
          "[Added Lines]",
          "970:         mk_header_prepare(cs, sr);",
          "971:         mk_channel_write(&cs->channel);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "995:         if (date_file_server <= date_client &&",
          "996:             date_client > 0) {",
          "997:             mk_header_set_http_status(sr, MK_NOT_MODIFIED);",
          "999:             return EXIT_NORMAL;",
          "1000:         }",
          "1001:     }",
          "",
          "[Removed Lines]",
          "998:             mk_header_send(cs->socket, cs, sr);",
          "",
          "[Added Lines]",
          "1010:             mk_header_prepare(cs, sr);",
          "1011:             mk_channel_write(&cs->channel);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1008:     if (mk_likely(sr->file_info.size > 0)) {",
          "1011:             MK_TRACE(\"open() failed\");",
          "1012:             return mk_http_error(MK_CLIENT_FORBIDDEN, cs, sr);",
          "1013:         }",
          "1015:     }",
          "",
          "[Removed Lines]",
          "1009:         sr->fd_file = mk_vhost_open(sr);",
          "1010:         if (sr->fd_file == -1) {",
          "1014:         sr->bytes_to_send = sr->file_info.size;",
          "",
          "[Added Lines]",
          "1022:         sr->file_stream.fd = mk_vhost_open(sr);",
          "1023:         if (sr->file_stream.fd == -1) {",
          "1027:         sr->file_stream.bytes_total = sr->file_info.size;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1044:     }",
          "1049:     if (mk_unlikely(sr->headers.content_length == 0)) {",
          "1050:         return 0;",
          "1051:     }",
          "1054:     if (sr->method == MK_METHOD_GET || sr->method == MK_METHOD_POST) {",
          "1056:     }",
          "1059: }",
          "1061: int mk_http_send_file(struct mk_http_session *cs, struct mk_http_request *sr)",
          "",
          "[Removed Lines]",
          "1047:     mk_header_send(cs->socket, cs, sr);",
          "1055:         bytes = mk_http_send_file(cs, sr);",
          "1058:     return bytes;",
          "",
          "[Added Lines]",
          "1060:     mk_header_prepare(cs, sr);",
          "1068:         sr->file_stream.type = MK_STREAM_FILE;",
          "1069:         mk_channel_append_stream(&cs->channel, &sr->file_stream);",
          "1072:     return mk_channel_write(&cs->channel);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1085:         }",
          "1086: #endif",
          "1090:     if (nbytes > 0) {",
          "1091:         sr->bytes_to_send -= nbytes;",
          "",
          "[Removed Lines]",
          "1088:     nbytes = mk_socket_send_file(cs->socket, sr->fd_file,",
          "1089:                                  &sr->bytes_offset, sr->bytes_to_send);",
          "",
          "[Added Lines]",
          "1102:         nbytes = mk_socket_send_file(cs->socket,",
          "1103:                                      sr->file_stream.fd,",
          "1104:                                      &sr->file_stream.bytes_offset,",
          "1105:                                      sr->file_stream.bytes_total);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1224:     return -1;",
          "1225: }",
          "1228: int mk_http_error(int http_status, struct mk_http_session *cs,",
          "1229:                   struct mk_http_request *sr) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1243: void cb_stream_page_finished(mk_stream_t *stream)",
          "1244: {",
          "1245:     mk_ptr_t *page = stream->data;",
          "1247:     mk_ptr_free(page);",
          "1248:     mk_mem_free(page);",
          "1249: }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1262:                 break;",
          "1263:             }",
          "1268:             sr->headers.content_length = finfo.size;",
          "1269:             sr->headers.real_length    = finfo.size;",
          "1271:             memcpy(&sr->file_info, &finfo, sizeof(struct file_info));",
          "1275:         }",
          "1276:     }",
          "",
          "[Removed Lines]",
          "1265:             sr->fd_file   = fd;",
          "1266:             sr->fd_is_fdt = MK_FALSE;",
          "1267:             sr->bytes_to_send = finfo.size;",
          "1273:             mk_header_send(cs->socket, cs, sr);",
          "1274:             return mk_http_send_file(cs, sr);",
          "",
          "[Added Lines]",
          "1292:             mk_header_prepare(cs, sr);",
          "1296:             sr->file_stream.type         = MK_STREAM_FILE;",
          "1297:             sr->file_stream.fd           = fd;",
          "1298:             sr->file_stream.bytes_total  = finfo.size;",
          "1299:             sr->file_stream.bytes_offset = 0;",
          "1300:             mk_channel_append_stream(&cs->channel, &sr->file_stream);",
          "1302:             return mk_channel_write(&cs->channel);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1354:         mk_ptr_set(&sr->headers.content_type, \"text/html\\r\\n\");",
          "1355:     }",
          "1359:     if (page) {",
          "1365:     }",
          "",
          "[Removed Lines]",
          "1357:     mk_header_send(cs->socket, cs, sr);",
          "1360:         if (sr->method != MK_METHOD_HEAD)",
          "1361:             mk_socket_send(cs->socket, page->data, page->len);",
          "1363:         mk_ptr_free(page);",
          "1364:         mk_mem_free(page);",
          "",
          "[Added Lines]",
          "1385:     mk_header_prepare(cs, sr);",
          "1387:         if (sr->method != MK_METHOD_HEAD) {",
          "1388:             mk_stream_set(&sr->page_stream,",
          "1389:                           MK_STREAM_PTR,",
          "1390:                           &cs->channel,",
          "1391:                           page,",
          "1392:                           -1,",
          "1393:                           cb_stream_page_finished, NULL, NULL);",
          "1395:             mk_channel_append_stream(&cs->channel, &sr->page_stream);",
          "1396:             mk_channel_write(&cs->channel);",
          "1397:         }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1437:     cs->status = MK_REQUEST_STATUS_INCOMPLETE;",
          "1438:     mk_list_add(&cs->request_incomplete, cs_incomplete);",
          "1441:     cs->init_time = sc->arrive_time;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1474:     cs->channel.type = MK_CHANNEL_SOCKET;",
          "1475:     cs->channel.fd   = socket;",
          "1476:     mk_list_init(&cs->channel.streams);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1506: void mk_http_request_free(struct mk_http_request *sr)",
          "1507: {",
          "1515:     }",
          "1517:     if (sr->headers.location) {",
          "",
          "[Removed Lines]",
          "1508:     if (sr->fd_file > 0) {",
          "1509:         if (sr->fd_is_fdt == MK_TRUE) {",
          "1510:             mk_vhost_close(sr);",
          "1511:         }",
          "1512:         else {",
          "1513:             close(sr->fd_file);",
          "1514:         }",
          "",
          "[Added Lines]",
          "1546:     if (sr->vhost_fdt_enabled == MK_TRUE) {",
          "1547:         mk_vhost_close(sr);",
          "1548:     }",
          "1549:     else {",
          "1550:         close(sr->file_stream.fd);",
          "",
          "---------------"
        ],
        "src/mk_plugin.c||src/mk_plugin.c": [
          "File: src/mk_plugin.c -> src/mk_plugin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277:     api->file_get_info = mk_file_get_info;",
          "281:     api->header_add = mk_plugin_header_add;",
          "282:     api->header_get = mk_http_header_get;",
          "283:     api->header_set_http_status = mk_header_set_http_status;",
          "",
          "[Removed Lines]",
          "280:     api->header_send = mk_header_send;",
          "",
          "[Added Lines]",
          "280:     api->header_prepare = mk_header_prepare;",
          "",
          "---------------"
        ],
        "src/mk_scheduler.c||src/mk_scheduler.c": [
          "File: src/mk_scheduler.c -> src/mk_scheduler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:     if (mk_unlikely(cur >= mk_config->server_capacity)) {",
          "97:         return -1;",
          "",
          "[Removed Lines]",
          "94:         MK_TRACE(\"Too many clients: %i\", config->server_capacity);",
          "",
          "[Added Lines]",
          "94:         MK_TRACE(\"Too many clients: %i\", mk_config->server_capacity);",
          "",
          "---------------"
        ],
        "src/mk_stream.c||src/mk_stream.c": [
          "File: src/mk_stream.c -> src/mk_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:     return channel;",
          "56: }",
          "58: int mk_channel_write(mk_channel_t *channel)",
          "59: {",
          "60:     size_t bytes = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58: static inline size_t channel_write_stream_file(mk_channel_t *channel,",
          "59:                                                mk_stream_t *stream)",
          "60: {",
          "61:     long int bytes = 0;",
          "63:     MK_TRACE(\"[CH %i] STREAM_FILE %i, bytes=%lu\",",
          "64:              channel->fd, stream->fd, stream->bytes_total);",
          "67:     bytes = mk_socket_send_file(channel->fd,",
          "68:                                 stream->fd,",
          "69:                                 &stream->bytes_offset,",
          "70:                                 stream->bytes_total",
          "71:                                 );",
          "72:     return bytes;",
          "73: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:     if (channel->type == MK_CHANNEL_SOCKET) {",
          "80:         if (stream->type == MK_STREAM_FILE) {",
          "90:         }",
          "91:         else if (stream->type == MK_STREAM_IOV) {",
          "92:             MK_TRACE(\"[CH %i] STREAM_IOV, bytes=%lu\",",
          "",
          "[Removed Lines]",
          "81:             MK_TRACE(\"[CH %i] STREAM_FILE %i, bytes=%lu\",",
          "82:                      channel->fd, stream->fd, stream->bytes_total);",
          "85:             bytes = mk_socket_send_file(channel->fd,",
          "86:                                         stream->fd,",
          "87:                                         &stream->bytes_offset,",
          "88:                                         stream->bytes_total",
          "89:                                         );",
          "",
          "[Added Lines]",
          "98:             bytes = channel_write_stream_file(channel, stream);",
          "",
          "---------------"
        ],
        "src/mk_vhost.c||src/mk_vhost.c": [
          "File: src/mk_vhost.c -> src/mk_vhost.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:     if (hc) {",
          "192:         hc->readers++;",
          "193:         return hc->fd;",
          "194:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:         sr->vhost_fdt_enabled = MK_TRUE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "217:             hc->readers++;",
          "218:             ht->av_slots--;",
          "224:             return fd;",
          "225:         }",
          "",
          "[Removed Lines]",
          "220:             sr->vhost_fdt_id   = id;",
          "221:             sr->vhost_fdt_hash = hash;",
          "222:             sr->fd_is_fdt      = MK_TRUE;",
          "",
          "[Added Lines]",
          "221:             sr->vhost_fdt_id      = id;",
          "222:             sr->vhost_fdt_hash    = hash;",
          "223:             sr->vhost_fdt_enabled = MK_TRUE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "236:     struct vhost_fdt_hash_chain *hc;",
          "238:     if (mk_config->fdt == MK_FALSE) {",
          "240:     }",
          "242:     id   = sr->vhost_fdt_id;",
          "",
          "[Removed Lines]",
          "239:         return close(sr->fd_file);",
          "",
          "[Added Lines]",
          "240:         return close(sr->file_stream.fd);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "245:     ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);",
          "246:     if (mk_unlikely(!ht)) {",
          "248:     }",
          "",
          "[Removed Lines]",
          "247:         return close(sr->fd_file);",
          "",
          "[Added Lines]",
          "248:         return close(sr->file_stream.fd);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "256:             hc->fd   = -1;",
          "257:             hc->hash = 0;",
          "258:             ht->av_slots++;",
          "260:         }",
          "261:         else {",
          "262:             return 0;",
          "263:         }",
          "264:     }",
          "266: }",
          "",
          "[Removed Lines]",
          "259:             return close(sr->fd_file);",
          "265:     return close(sr->fd_file);",
          "",
          "[Added Lines]",
          "260:             return close(sr->file_stream.fd);",
          "266:     return close(sr->file_stream.fd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4efbc11bafeb56fbe2b4f0f6925671630ce84125",
      "candidate_info": {
        "commit_hash": "4efbc11bafeb56fbe2b4f0f6925671630ce84125",
        "repo": "monkey/monkey",
        "commit_url": "https://github.com/monkey/monkey/commit/4efbc11bafeb56fbe2b4f0f6925671630ce84125",
        "files": [
          "src/include/mk_request.h",
          "src/include/mk_utils.h",
          "src/include/mk_vhost.h",
          "src/mk_cache.c",
          "src/mk_http.c",
          "src/mk_request.c",
          "src/mk_utils.c",
          "src/mk_vhost.c"
        ],
        "message": "Virtual Host: File Descriptor Table (FDT).\n\nThe File Descriptor Table (FDT) aims to provide a mechanism to share\nopen file descriptors at Virtual Host level with the goal of to reduce the\nnumber of open file descriptors and reduce the calls to open(2) and close(2).\n\nThe FDT is implemented in the following way:\n\n - For each worker thread, maintain a list matching the global Virtual Host\n   list and for each entry create a Hash Table (HT) of 64 entries, and each\n   HT entry maintain a sub-array of 8 chains.\n\n - When a request for a static file arrives, use the new Virtual Host open/close\n   wrappers, from the given parsed and processed URI generate a hash value and\n   try to see if it exists in the HT, if it don't exist, just open the file\n   directly and register the data into the chain for a possible future reuse.\n\n   If the hash exists in some HT/Chain, obtain the opened file descriptor and\n   increment the readers counter.\n\n - When the Monkey core do not longer needs the file descriptor, instruct the\n   Virtual Host 'close' wrapper to perform the cleanup. If the resource/hash\n   exists in the HT/Chain, decrement the readers counter, if counter reach\n   zero, just perform an explicit close(2) as nobody is using it, if readers\n   is greater than zero just return as the file descriptor is in use.\n\n   If the resource do not exists in the HT, do a direct close(2).\n\nThe good thing of this implementation is that exists at worker level, so there\nis no race conditions and is lock-free. Also collisions are reduced to zero\nusing HashTable Chaining. The hashing algorithm in use MurmurHash 2.\n\nThis implementation reduce the overhead under high concurrency sharing the file\ndescriptor resources and making it more scalable.\n\nSigned-off-by: Eduardo Silva <edsiper@gmail.com>",
        "before_after_code_files": [
          "src/include/mk_request.h||src/include/mk_request.h",
          "src/include/mk_utils.h||src/include/mk_utils.h",
          "src/include/mk_vhost.h||src/include/mk_vhost.h",
          "src/mk_cache.c||src/mk_cache.c",
          "src/mk_http.c||src/mk_http.c",
          "src/mk_request.c||src/mk_request.c",
          "src/mk_utils.c||src/mk_utils.c",
          "src/mk_vhost.c||src/mk_vhost.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/mk_request.c||src/mk_request.c",
            "src/mk_vhost.c||src/mk_vhost.c"
          ],
          "candidate": [
            "src/mk_request.c||src/mk_request.c",
            "src/mk_vhost.c||src/mk_vhost.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/mk_request.h||src/include/mk_request.h": [
          "File: src/include/mk_request.h -> src/include/mk_request.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "236:     struct file_info file_info;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "239:     int vhost_fdt_id;",
          "240:     unsigned int vhost_fdt_hash;",
          "",
          "---------------"
        ],
        "src/include/mk_utils.h||src/include/mk_utils.h": [
          "File: src/include/mk_utils.h -> src/include/mk_utils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: pthread_t mk_utils_worker_spawn(void (*func) (void *), void *arg);",
          "87: int mk_utils_worker_rename(const char *title);",
          "88: void mk_utils_stacktrace(void);",
          "91: #define MK_UTILS_ERROR_SIZE          128",
          "92: pthread_key_t mk_utils_error_key;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89: unsigned int mk_utils_gen_hash(const void *key, int len);",
          "",
          "---------------"
        ],
        "src/include/mk_vhost.h||src/include/mk_vhost.h": [
          "File: src/include/mk_vhost.h -> src/include/mk_vhost.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include \"mk_list.h\"",
          "23: #include \"mk_config.h\"",
          "25: #ifndef MK_VHOST_H",
          "26: #define MK_VHOST_H",
          "30: struct error_page {",
          "31:     short int status;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include \"mk_request.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:     struct mk_list _head;",
          "63: };",
          "65: struct host *mk_vhost_read(char *path);",
          "66: int mk_vhost_get(mk_pointer host, struct host **vhost, struct host_alias **alias);",
          "67: void mk_vhost_init(char *path);",
          "69: #ifdef SAFE_FREE",
          "70: void mk_vhost_free_all();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: #define VHOST_FDT_HASHTABLE_SIZE   64",
          "67: #define VHOST_FDT_HASHTABLE_CHAINS  8",
          "69: struct vhost_fdt_hash_chain {",
          "70:     int fd;",
          "71:     int readers;",
          "72:     unsigned int hash;",
          "73: };",
          "75: struct vhost_fdt_hash_table {",
          "76:     int av_slots;",
          "77:     struct vhost_fdt_hash_chain chain[VHOST_FDT_HASHTABLE_CHAINS];",
          "78: };",
          "80: struct vhost_fdt_host {",
          "81:     struct host *host;",
          "82:     struct vhost_fdt_hash_table hash_table[VHOST_FDT_HASHTABLE_SIZE];",
          "83:     struct mk_list _head;",
          "84: };",
          "87: pthread_mutex_t mk_vhost_fdt_mutex;",
          "92: int mk_vhost_fdt_worker_init();",
          "93: int mk_vhost_open(struct session_request *sr);",
          "94: int mk_vhost_close(struct session_request *sr);",
          "",
          "---------------"
        ],
        "src/mk_cache.c||src/mk_cache.c": [
          "File: src/mk_cache.c -> src/mk_cache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"mk_config.h\"",
          "31: #include \"mk_macros.h\"",
          "32: #include \"mk_utils.h\"",
          "34: pthread_key_t mk_cache_iov_header;",
          "35: pthread_key_t mk_cache_header_lm;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: #include \"mk_vhost.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: pthread_key_t mk_cache_header_ka_max;",
          "39: pthread_key_t mk_cache_utils_gmtime;",
          "40: pthread_key_t mk_cache_utils_gmt_text;",
          "43: void mk_cache_thread_init()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: pthread_key_t mk_utils_error_key;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93:     cache_error = mk_mem_malloc(MK_UTILS_ERROR_SIZE);",
          "94:     pthread_setspecific(mk_utils_error_key, (void *) cache_error);",
          "95: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:     mk_vhost_fdt_worker_init();",
          "",
          "---------------"
        ],
        "src/mk_http.c||src/mk_http.c": [
          "File: src/mk_http.c -> src/mk_http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "561:     if (mk_likely(sr->file_info.size > 0)) {",
          "563:         if (sr->fd_file == -1) {",
          "564:             MK_TRACE(\"open() failed\");",
          "565:             return mk_request_error(MK_CLIENT_FORBIDDEN, cs, sr);",
          "",
          "[Removed Lines]",
          "562:         sr->fd_file = open(sr->real_path.data, sr->file_info.flags_read_only);",
          "",
          "[Added Lines]",
          "562:         sr->fd_file = mk_vhost_open(sr);",
          "",
          "---------------"
        ],
        "src/mk_request.c||src/mk_request.c": [
          "File: src/mk_request.c -> src/mk_request.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "102: static void mk_request_free(struct session_request *sr)",
          "103: {",
          "104:     if (sr->fd_file > 0) {",
          "106:     }",
          "108:     if (sr->headers.location) {",
          "",
          "[Removed Lines]",
          "105:         close(sr->fd_file);",
          "",
          "[Added Lines]",
          "105:         mk_vhost_close(sr);",
          "",
          "---------------"
        ],
        "src/mk_utils.c||src/mk_utils.c": [
          "File: src/mk_utils.c -> src/mk_utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "362:             color_function  = ANSI_BOLD_MAGENTA;",
          "363:             color_fileline  = ANSI_GREEN;",
          "364:             break;",
          "366:             color_component = ANSI_BOLD_GREEN;",
          "367:             color_function  = ANSI_BLUE;",
          "368:             color_fileline  = ANSI_GREEN;",
          "",
          "[Removed Lines]",
          "365:         case MK_TRACE_PLUGIN:",
          "",
          "[Added Lines]",
          "365:         case MK_TRACE_PLUGIN:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "662:     }",
          "663: }",
          "664: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "685: unsigned int mk_utils_gen_hash(const void *key, int len)",
          "686: {",
          "689:     uint32_t seed = 5381;",
          "690:     const uint32_t m = 0x5bd1e995;",
          "691:     const int r = 24;",
          "694:     uint32_t h = seed ^ len;",
          "697:     const unsigned char *data = (const unsigned char *)key;",
          "699:     while(len >= 4) {",
          "700:         uint32_t k = *(uint32_t*) data;",
          "702:         k *= m;",
          "703:         k ^= k >> r;",
          "704:         k *= m;",
          "706:         h *= m;",
          "707:         h ^= k;",
          "709:         data += 4;",
          "710:         len -= 4;",
          "711:     }",
          "714:     switch(len) {",
          "715:     case 3: h ^= data[2] << 16;",
          "716:     case 2: h ^= data[1] << 8;",
          "717:     case 1: h ^= data[0]; h *= m;",
          "718:     };",
          "722:     h ^= h >> 13;",
          "723:     h *= m;",
          "724:     h ^= h >> 15;",
          "726:     return (unsigned int) h;",
          "727: }",
          "",
          "---------------"
        ],
        "src/mk_vhost.c||src/mk_vhost.c": [
          "File: src/mk_vhost.c -> src/mk_vhost.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #include <dirent.h>",
          "26: #include <unistd.h>",
          "27: #include <pthread.h>",
          "29: #include \"mk_list.h\"",
          "30: #include \"mk_vhost.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <fcntl.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33: #include \"mk_config.h\"",
          "34: #include \"mk_string.h\"",
          "35: #include \"mk_http_status.h\"",
          "36: #include \"mk_info.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: #include \"mk_memory.h\"",
          "39: #include \"mk_request.h\"",
          "43: pthread_mutex_t mk_vhost_fdt_mutex = PTHREAD_MUTEX_INITIALIZER;",
          "45: static __thread struct mk_list *mk_vhost_fdt_key;",
          "51: int mk_vhost_fdt_worker_init()",
          "52: {",
          "53:     int i;",
          "54:     int j;",
          "55:     struct host *h;",
          "56:     struct mk_list *list;",
          "57:     struct mk_list *head;",
          "58:     struct vhost_fdt_host *fdt;",
          "59:     struct vhost_fdt_hash_table *ht;",
          "60:     struct vhost_fdt_hash_chain *hc;",
          "74:     pthread_mutex_lock(&mk_vhost_fdt_mutex);",
          "80:     list = mk_mem_malloc_z(sizeof(struct mk_list));",
          "81:     mk_list_init(list);",
          "83:     mk_list_foreach(head, &config->hosts) {",
          "84:         h = mk_list_entry(head, struct host, _head);",
          "86:         fdt = mk_mem_malloc(sizeof(struct vhost_fdt_host));",
          "87:         fdt->host = h;",
          "90:         for (i = 0; i < VHOST_FDT_HASHTABLE_SIZE; i++) {",
          "91:             ht = &fdt->hash_table[i];",
          "92:             ht->av_slots = VHOST_FDT_HASHTABLE_CHAINS;",
          "95:             for (j = 0; j < VHOST_FDT_HASHTABLE_CHAINS; j++) {",
          "96:                 hc = &ht->chain[j];",
          "97:                 hc->fd      = -1;",
          "98:                 hc->hash    =  0;",
          "99:                 hc->readers =  0;",
          "100:             }",
          "101:         }",
          "102:         mk_list_add(&fdt->_head, list);",
          "103:     }",
          "105:     mk_vhost_fdt_key = list;",
          "106:     pthread_mutex_unlock(&mk_vhost_fdt_mutex);",
          "108:     return 0;",
          "109: }",
          "111: static inline",
          "112: struct vhost_fdt_hash_table *mk_vhost_fdt_table_lookup(int id, struct host *host)",
          "113: {",
          "114:     struct mk_list *head;",
          "115:     struct mk_list *vhost_list;",
          "116:     struct vhost_fdt_host *fdt_host;",
          "117:     struct vhost_fdt_hash_table *ht = NULL;",
          "119:     vhost_list = mk_vhost_fdt_key;",
          "120:     mk_list_foreach(head, vhost_list) {",
          "121:         fdt_host = mk_list_entry(head, struct vhost_fdt_host, _head);",
          "122:         if (fdt_host->host == host) {",
          "123:             ht = &fdt_host->hash_table[id];",
          "124:             return ht;",
          "125:         }",
          "126:     }",
          "128:     return ht;",
          "129: }",
          "131: static inline",
          "132: struct vhost_fdt_hash_chain",
          "134: {",
          "135:     int i;",
          "136:     struct vhost_fdt_hash_chain *hc = NULL;",
          "138:     for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {",
          "139:         hc = &ht->chain[i];",
          "140:         if (hc->hash == hash) {",
          "141:             return hc;",
          "142:         }",
          "143:     }",
          "145:     return NULL;",
          "146: }",
          "149: static inline int mk_vhost_fdt_open(int id, unsigned int hash,",
          "150:                                     struct session_request *sr)",
          "151: {",
          "152:     int i;",
          "153:     int fd;",
          "154:     struct vhost_fdt_hash_table *ht = NULL;",
          "155:     struct vhost_fdt_hash_chain *hc;",
          "157:     ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);",
          "158:     if (mk_unlikely(!ht)) {",
          "159:         return open(sr->real_path.data, sr->file_info.flags_read_only);",
          "160:     }",
          "163:     hc = mk_vhost_fdt_chain_lookup(hash, ht);",
          "164:     if (hc) {",
          "166:         hc->readers++;",
          "167:         return hc->fd;",
          "168:     }",
          "175:     fd = open(sr->real_path.data, sr->file_info.flags_read_only);",
          "176:     if (fd == -1) {",
          "177:         return -1;",
          "178:     }",
          "181:     if (ht->av_slots <= 0) {",
          "182:         return fd;",
          "183:     }",
          "186:     for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {",
          "187:         hc = &ht->chain[i];",
          "188:         if (hc->fd == -1) {",
          "189:             hc->fd   = fd;",
          "190:             hc->hash = hash;",
          "191:             hc->readers++;",
          "192:             ht->av_slots--;",
          "194:             sr->vhost_fdt_id   = id;",
          "195:             sr->vhost_fdt_hash = hash;",
          "197:             return fd;",
          "198:         }",
          "199:     }",
          "201:     return -1;",
          "202: }",
          "204: static inline int mk_vhost_fdt_close(struct session_request *sr)",
          "205: {",
          "206:     int id;",
          "207:     unsigned int hash;",
          "208:     struct vhost_fdt_hash_table *ht = NULL;",
          "209:     struct vhost_fdt_hash_chain *hc;",
          "211:     id   = sr->vhost_fdt_id;",
          "212:     hash = sr->vhost_fdt_hash;",
          "214:     ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);",
          "215:     if (mk_unlikely(!ht)) {",
          "216:         return close(sr->fd_file);",
          "217:     }",
          "220:     hc = mk_vhost_fdt_chain_lookup(hash, ht);",
          "221:     if (hc) {",
          "223:         hc->readers--;",
          "224:         if (hc->readers == 0) {",
          "225:             hc->fd   = -1;",
          "226:             hc->hash = 0;",
          "227:             ht->av_slots++;",
          "228:             return close(sr->fd_file);",
          "229:         }",
          "230:         else {",
          "231:             return 0;",
          "232:         }",
          "233:     }",
          "235:     return close(sr->fd_file);",
          "236: }",
          "239: int mk_vhost_open(struct session_request *sr)",
          "240: {",
          "241:     int id;",
          "242:     unsigned int hash;",
          "246:     hash = mk_utils_gen_hash(sr->real_path.data, sr->real_path.len);",
          "247:     id   = (hash % VHOST_FDT_HASHTABLE_SIZE);",
          "249:     return mk_vhost_fdt_open(id, hash, sr);",
          "250: }",
          "252: int mk_vhost_close(struct session_request *sr)",
          "253: {",
          "256:     return mk_vhost_fdt_close(sr);",
          "257: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "edcbc522e3da28bd05280328736555c2c5e51202",
      "candidate_info": {
        "commit_hash": "edcbc522e3da28bd05280328736555c2c5e51202",
        "repo": "monkey/monkey",
        "commit_url": "https://github.com/monkey/monkey/commit/edcbc522e3da28bd05280328736555c2c5e51202",
        "files": [
          "src/include/mk_request.h",
          "src/mk_request.c",
          "src/mk_vhost.c"
        ],
        "message": "Request: new request session flag to mark those files opened by FDT\n\nThis patch aims to fix a potential DDoS problem that can be caused\nin the server quering repetitive non-existent resources.\n\nWhen serving a static file, the core use Vhost FDT mechanism, but if\nit sends a static error page it does a direct open(2). When closing\nthe resources for the same request it was just calling mk_vhost_close()\nwhich did not clear properly the file descriptor.\n\nThis patch adds a new field on the struct session_request called 'fd_is_fdt',\nwhich contains MK_TRUE or MK_FALSE depending of how fd_file was opened.\n\nThanks to Matthew Daley <mattd@bugfuzz.com> for report and troubleshoot this\nproblem.\n\nSigned-off-by: Eduardo Silva <eduardo@monkey.io>",
        "before_after_code_files": [
          "src/include/mk_request.h||src/include/mk_request.h",
          "src/mk_request.c||src/mk_request.c",
          "src/mk_vhost.c||src/mk_vhost.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/mk_request.c||src/mk_request.c",
            "src/mk_vhost.c||src/mk_vhost.c"
          ],
          "candidate": [
            "src/mk_request.c||src/mk_request.c",
            "src/mk_vhost.c||src/mk_vhost.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/mk_request.h||src/include/mk_request.h": [
          "File: src/include/mk_request.h -> src/include/mk_request.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "160:     long port;",
          "164:     int fd_file;",
          "166:     int headers_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173:     int fd_is_fdt;",
          "",
          "---------------"
        ],
        "src/mk_request.c||src/mk_request.c": [
          "File: src/mk_request.c -> src/mk_request.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: static inline void mk_request_free(struct session_request *sr)",
          "100: {",
          "101:     if (sr->fd_file > 0) {",
          "103:     }",
          "105:     if (sr->headers.location) {",
          "",
          "[Removed Lines]",
          "102:         mk_vhost_close(sr);",
          "",
          "[Added Lines]",
          "102:         if (sr->fd_is_fdt == MK_TRUE) {",
          "103:             mk_vhost_close(sr);",
          "104:         }",
          "105:         else {",
          "106:             close(sr->fd_file);",
          "107:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "818:                 break;",
          "819:             }",
          "822:             sr->bytes_to_send = finfo.size;",
          "823:             sr->headers.content_length = finfo.size;",
          "824:             sr->headers.real_length    = finfo.size;",
          "",
          "[Removed Lines]",
          "821:             sr->fd_file = fd;",
          "",
          "[Added Lines]",
          "826:             sr->fd_file   = fd;",
          "827:             sr->fd_is_fdt = MK_FALSE;",
          "",
          "---------------"
        ],
        "src/mk_vhost.c||src/mk_vhost.c": [
          "File: src/mk_vhost.c -> src/mk_vhost.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "201:             sr->vhost_fdt_id   = id;",
          "202:             sr->vhost_fdt_hash = hash;",
          "204:             return fd;",
          "205:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:             sr->fd_is_fdt      = MK_TRUE;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
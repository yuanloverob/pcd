{
  "cve_id": "CVE-2021-4173",
  "cve_desc": "vim is vulnerable to Use After Free",
  "repo": "vim/vim",
  "patch_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
  "patch_info": {
    "commit_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
    "files": [
      "src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim",
      "src/userfunc.c",
      "src/version.c",
      "src/vim9compile.c",
      "src/vim9execute.c"
    ],
    "message": "patch 8.2.3902: Vim9: double free with nested :def function\n\nProblem:    Vim9: double free with nested :def function.\nSolution:   Pass \"line_to_free\" from compile_def_function() and make sure\n            cmdlinep is valid.",
    "before_after_code_files": [
      "src/proto/userfunc.pro||src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
      "src/userfunc.c||src/userfunc.c",
      "src/version.c||src/version.c",
      "src/vim9compile.c||src/vim9compile.c",
      "src/vim9execute.c||src/vim9execute.c"
    ]
  },
  "patch_diff": {
    "src/proto/userfunc.pro||src/proto/userfunc.pro": [
      "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: char_u *get_scriptlocal_funcname(char_u *funcname);",
      "39: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
      "40: void list_functions(regmatch_T *regmatch);",
      "42: void ex_function(exarg_T *eap);",
      "43: void ex_defcompile(exarg_T *eap);",
      "44: int eval_fname_script(char_u *p);",
      "",
      "[Removed Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg);",
      "",
      "[Added Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);",
      "",
      "---------------"
    ],
    "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
      "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "1669:   assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')",
      "1670: enddef",
      "1672: def Test_return_type_wrong()",
      "1673:   CheckScriptFailure([",
      "1674:         'def Func(): number',",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1672: def Test_nested_functin_with_nextcmd()",
      "1673:   var lines =<< trim END",
      "1674:       vim9script",
      "1675:       # Define an outer function",
      "1676:       def FirstFunction()",
      "1677:         # Define an inner function",
      "1678:         def SecondFunction()",
      "1679:           # the function has a body, a double free is detected.",
      "1680:           AAAAA",
      "1682:          # enddef followed by | or } followed by # one or more characters",
      "1683:          enddef|BBBB",
      "1684:       enddef",
      "1686:       # Compile all functions",
      "1687:       defcompile",
      "1688:   END",
      "1689:   CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')",
      "1690: enddef",
      "",
      "---------------"
    ],
    "src/userfunc.c||src/userfunc.c": [
      "File: src/userfunc.c -> src/userfunc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "720:  }",
      "721:  else",
      "722:  {",
      "724:      if (eap->getline == NULL)",
      "725:   theline = getcmdline(':', 0L, indent, getline_options);",
      "726:      else",
      "727:   theline = eap->getline(':', eap->cookie, indent,",
      "728:              getline_options);",
      "730:  }",
      "731:  if (KeyTyped)",
      "",
      "[Removed Lines]",
      "723:      vim_free(*line_to_free);",
      "",
      "[Added Lines]",
      "728:      if (*eap->cmdlinep == *line_to_free)",
      "730:      vim_free(*line_to_free);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "839:    eap->nextcmd = nextcmd;",
      "841:    {",
      "842:        vim_free(*eap->cmdlinep);",
      "",
      "[Removed Lines]",
      "840:    if (*line_to_free != NULL)",
      "",
      "[Added Lines]",
      "842:    if (*line_to_free != NULL",
      "843:          && *eap->cmdlinep != *line_to_free)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1161:  }",
      "1162:  if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)",
      "1163:      goto erret;",
      "1166:      last = cmdline;",
      "1167:  else",
      "",
      "[Removed Lines]",
      "1164:  if (cmdline != NULL)",
      "",
      "[Added Lines]",
      "1167:  if (eap.nextcmd != NULL)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1175:  ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;",
      "1176:     }",
      "1179:     {",
      "1180:  garray_T *tfgap = &evalarg->eval_tofree_ga;",
      "",
      "[Removed Lines]",
      "1178:     if (cmdline != NULL)",
      "",
      "[Added Lines]",
      "1181:     if (eap.nextcmd != NULL)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1187:  {",
      "1188:      ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;",
      "1189:      evalarg->eval_using_cmdline = TRUE;",
      "1190:  }",
      "1191:     }",
      "1192:     else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1193:      if (cmdline == line_to_free)",
      "1194:   line_to_free = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "3990:     ufunc_T *",
      "3992: {",
      "3994:     int  j;",
      "3995:     int  c;",
      "3996:     int  saved_did_emsg;",
      "",
      "[Removed Lines]",
      "3991: define_function(exarg_T *eap, char_u *name_arg)",
      "3993:     char_u *line_to_free = NULL;",
      "",
      "[Added Lines]",
      "3996: define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "4258:     if (get_function_args(&p, ')', &newargs,",
      "4259:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
      "4260:     NULL, &varargs, &default_args, eap->skip,",
      "4262:  goto errret_2;",
      "4263:     whitep = p;",
      "",
      "[Removed Lines]",
      "4261:     eap, &line_to_free) == FAIL)",
      "",
      "[Added Lines]",
      "4265:     eap, line_to_free) == FAIL)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "4372:      || eap->skip)",
      "4373:  goto erret;",
      "",
      "[Removed Lines]",
      "4371:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL",
      "",
      "[Added Lines]",
      "4375:     if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "4660:     }",
      "4661: ret_free:",
      "4662:     ga_clear_strings(&argtypes);",
      "4664:     vim_free(fudi.fd_newkey);",
      "4665:     if (name != name_arg)",
      "4666:  vim_free(name);",
      "",
      "[Removed Lines]",
      "4663:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "4676:     void",
      "4677: ex_function(exarg_T *eap)",
      "4678: {",
      "4680: }",
      "",
      "[Removed Lines]",
      "4679:     (void)define_function(eap, NULL);",
      "",
      "[Added Lines]",
      "4682:     char_u *line_to_free = NULL;",
      "4684:     (void)define_function(eap, NULL, &line_to_free);",
      "4685:     vim_free(line_to_free);",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "750: static int included_patches[] =",
      "753:     3901,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "753:     3902,",
      "",
      "---------------"
    ],
    "src/vim9compile.c||src/vim9compile.c": [
      "File: src/vim9compile.c -> src/vim9compile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "814:     static char_u *",
      "816: {",
      "817:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
      "818:     char_u *name_start = eap->arg;",
      "819:     char_u *name_end = to_name_end(eap->arg, TRUE);",
      "820:     char_u *lambda_name;",
      "821:     ufunc_T *ufunc;",
      "822:     int  r = FAIL;",
      "",
      "[Removed Lines]",
      "815: compile_nested_function(exarg_T *eap, cctx_T *cctx)",
      "",
      "[Added Lines]",
      "815: compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)",
      "820:     int  off;",
      "821:     char_u *func_name;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "866:     lambda_name = vim_strsave(get_lambda_name());",
      "867:     if (lambda_name == NULL)",
      "868:  return NULL;",
      "871:     if (ufunc == NULL)",
      "872:     {",
      "",
      "[Removed Lines]",
      "869:     ufunc = define_function(eap, lambda_name);",
      "",
      "[Added Lines]",
      "873:     off = is_global ? 2 : 0;",
      "874:     func_name = vim_strnsave(name_start + off, name_end - name_start - off);",
      "875:     if (func_name == NULL)",
      "876:     {",
      "877:  r = FAIL;",
      "878:  goto theend;",
      "879:     }",
      "881:     ufunc = define_function(eap, lambda_name, line_to_free);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "912:     if (is_global)",
      "913:     {",
      "924:     }",
      "925:     else",
      "926:     {",
      "929:           TRUE, ufunc->uf_func_type);",
      "931:  if (lvar == NULL)",
      "",
      "[Removed Lines]",
      "914:  char_u *func_name = vim_strnsave(name_start + 2,",
      "915:           name_end - name_start - 2);",
      "917:  if (func_name == NULL)",
      "918:      r = FAIL;",
      "919:  else",
      "920:  {",
      "921:      r = generate_NEWFUNC(cctx, lambda_name, func_name);",
      "922:      lambda_name = NULL;",
      "923:  }",
      "928:  lvar_T *lvar = reserve_local(cctx, name_start, name_end - name_start,",
      "",
      "[Added Lines]",
      "926:  r = generate_NEWFUNC(cctx, lambda_name, func_name);",
      "927:  func_name = NULL;",
      "928:  lambda_name = NULL;",
      "933:  lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "938: theend:",
      "939:     vim_free(lambda_name);",
      "940:     return r == FAIL ? NULL : (char_u *)\"\";",
      "941: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "945:     vim_free(func_name);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2861:      case CMD_def:",
      "2862:      case CMD_function:",
      "2863:       ea.arg = p;",
      "2865:       break;",
      "2867:      case CMD_return:",
      "",
      "[Removed Lines]",
      "2864:       line = compile_nested_function(&ea, &cctx);",
      "",
      "[Added Lines]",
      "2870:       line = compile_nested_function(&ea, &cctx, &line_to_free);",
      "",
      "---------------"
    ],
    "src/vim9execute.c||src/vim9execute.c": [
      "File: src/vim9execute.c -> src/vim9execute.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3345:   else",
      "3346:   {",
      "3347:       exarg_T ea;",
      "3349:       CLEAR_FIELD(ea);",
      "3350:       ea.cmd = ea.arg = iptr->isn_arg.string;",
      "3352:   }",
      "3353:   break;",
      "",
      "[Removed Lines]",
      "3351:       define_function(&ea, NULL);",
      "",
      "[Added Lines]",
      "3348:       char_u  *line_to_free = NULL;",
      "3352:       define_function(&ea, NULL, &line_to_free);",
      "3353:       vim_free(line_to_free);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4bf1006cae7e87259ccd5219128c3dba75774441",
      "candidate_info": {
        "commit_hash": "4bf1006cae7e87259ccd5219128c3dba75774441",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/4bf1006cae7e87259ccd5219128c3dba75774441",
        "files": [
          "src/testdir/test_vim9_func.vim",
          "src/userfunc.c",
          "src/version.c"
        ],
        "message": "patch 8.2.3923: Vim9: double free with split argument list in nested function\n\nProblem:    Vim9: double free if a nested function has a line break in the\n            argument list.\nSolution:   Set cmdlinep when freeing the previous line.",
        "before_after_code_files": [
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1669:   assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')",
          "1670: enddef",
          "1673:   var lines =<< trim END",
          "1674:       vim9script",
          "1675:       # Define an outer function",
          "",
          "[Removed Lines]",
          "1672: def Test_nested_functin_with_nextcmd()",
          "",
          "[Added Lines]",
          "1672: def Test_nested_function_with_nextcmd()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1689:   CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')",
          "1690: enddef",
          "1692: def Test_return_type_wrong()",
          "1693:   CheckScriptFailure([",
          "1694:         'def Func(): number',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1692: def Test_nested_function_with_args_split()",
          "1693:   var lines =<< trim END",
          "1694:       vim9script",
          "1695:       def FirstFunction()",
          "1696:         def SecondFunction(",
          "1697:         )",
          "1698:         # had a double free if the right parenthesis of the nested function is",
          "1699:         # on the next line",
          "1701:         enddef|BBBB",
          "1702:       enddef",
          "1703:       # Compile all functions",
          "1704:       defcompile",
          "1705:   END",
          "1706:   # FIXME: this should fail on the BBBB",
          "1707:   CheckScriptSuccess(lines)",
          "1708: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:      if (theline == NULL)",
          "220:   break;",
          "221:      vim_free(*line_to_free);",
          "223:      whitep = (char_u *)\" \";",
          "224:      p = skipwhite(theline);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "222:      if (*eap->cmdlinep == *line_to_free)",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3922,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3923,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7a6eaa06f98cef61d2131c25b4b47b8262cb8f59",
      "candidate_info": {
        "commit_hash": "7a6eaa06f98cef61d2131c25b4b47b8262cb8f59",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/7a6eaa06f98cef61d2131c25b4b47b8262cb8f59",
        "files": [
          "src/errors.h",
          "src/misc2.c",
          "src/proto/vim9compile.pro",
          "src/testdir/test_vim9_expr.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c"
        ],
        "message": "patch 8.2.2635: Vim9: cannot define an inline function\n\nProblem:    Vim9: cannot define an inline function.\nSolution:   Make an inline function mostly work.",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/misc2.c||src/misc2.c",
          "src/proto/vim9compile.pro||src/proto/vim9compile.pro",
          "src/testdir/test_vim9_expr.vim||src/testdir/test_vim9_expr.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "377:  INIT(= N_(\"E1169: 'import * as {name}' not supported here\"));",
          "378: EXTERN char e_cannot_use_hash_curly_to_start_comment[]",
          "379:  INIT(= N_(\"E1170: Cannot use #{ to start a comment\"));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "380: EXTERN char e_missing_end_block[]",
          "381:  INIT(= N_(\"E1171: Missing } after inline function\"));",
          "382: EXTERN char e_cannot_use_default_values_in_lambda[]",
          "383:  INIT(= N_(\"E1172: Cannot use default values in a lambda\"));",
          "",
          "---------------"
        ],
        "src/misc2.c||src/misc2.c": [
          "File: src/misc2.c -> src/misc2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2026: {",
          "2027:     int  i;",
          "2031:     ga_clear(gap);",
          "2032: }",
          "",
          "[Removed Lines]",
          "2029:     for (i = 0; i < gap->ga_len; ++i)",
          "2030:  vim_free(((char_u **)(gap->ga_data))[i]);",
          "",
          "[Added Lines]",
          "2029:     if (gap->ga_data != NULL)",
          "2030:  for (i = 0; i < gap->ga_len; ++i)",
          "2031:      vim_free(((char_u **)(gap->ga_data))[i]);",
          "",
          "---------------"
        ],
        "src/proto/vim9compile.pro||src/proto/vim9compile.pro": [
          "File: src/proto/vim9compile.pro -> src/proto/vim9compile.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: char_u *to_name_const_end(char_u *arg);",
          "15: exprtype_T get_compare_type(char_u *p, int *len, int *type_is);",
          "16: void error_white_both(char_u *op, int len);",
          "17: int assignment_len(char_u *p, int *heredoc);",
          "18: void vim9_declare_error(char_u *name);",
          "19: int check_vim9_unlet(char_u *name);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: void fill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_expr.vim||src/testdir/test_vim9_expr.vim": [
          "File: src/testdir/test_vim9_expr.vim -> src/testdir/test_vim9_expr.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1946:   CheckScriptSuccess(lines)",
          "1947: enddef",
          "1949: def NewLambdaWithComments(): func",
          "1950:   return (x) =>",
          "1951:             # some comment",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1949: def Test_expr7_lambda_block()",
          "1950:   var lines =<< trim END",
          "1951:       var Func = (s: string): string => {",
          "1952:                       return 'hello ' .. s",
          "1953:                     }",
          "1954:       assert_equal('hello there', Func('there'))",
          "1956:       var ll = range(3)",
          "1957:       var dll = mapnew(ll, (k, v): string => {",
          "1958:           if v % 2",
          "1959:             return 'yes'",
          "1960:           endif",
          "1961:           return 'no'",
          "1962:         })",
          "1963:       assert_equal(['no', 'yes', 'no'], dll)",
          "1964:   END",
          "1965:   CheckDefAndScriptSuccess(lines)",
          "1966: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:     return OK;",
          "398: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "400:     static int",
          "401: parse_return_type(ufunc_T *fp, char_u *ret_type)",
          "402: {",
          "403:     if (ret_type == NULL)",
          "404:  fp->uf_ret_type = &t_void;",
          "405:     else",
          "406:     {",
          "407:  char_u *p = ret_type;",
          "409:  fp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);",
          "410:  if (fp->uf_ret_type == NULL)",
          "411:  {",
          "412:      fp->uf_ret_type = &t_void;",
          "413:      return FAIL;",
          "414:  }",
          "415:     }",
          "416:     return OK;",
          "417: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "516:   return NULL;",
          "517:      }",
          "518:  }",
          "524:     }",
          "529:     {",
          "534:     }",
          "536: }",
          "",
          "[Removed Lines]",
          "519:  bef = s;",
          "520:  s = skipwhite(s);",
          "521:  if (*s != '=')",
          "522:      return NULL;",
          "523:  ++s;",
          "525:     if (*s != '>')",
          "526:  return NULL;",
          "527:     if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')",
          "528:   || !IS_WHITE_OR_NUL(s[1])))",
          "531:  semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "532:             equal_arrow ? \"=>\" : \"->\", bef);",
          "533:  return NULL;",
          "535:     return skipwhite(s + 1);",
          "",
          "[Added Lines]",
          "538:  bef = s;",
          "539:  s = skipwhite(s);",
          "540:  if (*s != '=')",
          "541:      return NULL;",
          "542:  ++s;",
          "543:     }",
          "544:     if (*s != '>')",
          "545:  return NULL;",
          "546:     if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')",
          "547:   || !IS_WHITE_OR_NUL(s[1])))",
          "548:     {",
          "550:  semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "551:             equal_arrow ? \"=>\" : \"->\", bef);",
          "552:  return NULL;",
          "553:     }",
          "554:     return skipwhite(s + 1);",
          "555: }",
          "563:     static int",
          "564: is_function_cmd(char_u **cmd)",
          "565: {",
          "566:     char_u *p = *cmd;",
          "568:     if (checkforcmd(&p, \"function\", 2))",
          "569:     {",
          "570:  if (*p == '(')",
          "571:      return FALSE;",
          "573:  return TRUE;",
          "574:     }",
          "575:     return FALSE;",
          "576: }",
          "583:     static int",
          "584: get_function_body(",
          "585:  exarg_T     *eap,",
          "586:  garray_T    *newlines,",
          "587:  char_u     *line_arg_in,",
          "588:  char_u     **line_to_free)",
          "589: {",
          "590:     linenr_T sourcing_lnum_top = SOURCING_LNUM;",
          "591:     linenr_T sourcing_lnum_off;",
          "592:     int  saved_wait_return = need_wait_return;",
          "593:     char_u *line_arg = line_arg_in;",
          "594:     int  vim9_function = eap->cmdidx == CMD_def",
          "595:          || eap->cmdidx == CMD_block;",
          "596: #define MAX_FUNC_NESTING 50",
          "597:     char nesting_def[MAX_FUNC_NESTING];",
          "598:     int  nesting = 0;",
          "599:     getline_opt_T getline_options;",
          "600:     int  indent = 2;",
          "601:     char_u *skip_until = NULL;",
          "602:     int  ret = FAIL;",
          "603:     int  is_heredoc = FALSE;",
          "604:     char_u *heredoc_trimmed = NULL;",
          "608:     sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "609:     if (SOURCING_LNUM < sourcing_lnum_off)",
          "610:     {",
          "611:  sourcing_lnum_off -= SOURCING_LNUM;",
          "612:  if (ga_grow(newlines, sourcing_lnum_off) == FAIL)",
          "613:      goto theend;",
          "614:  while (sourcing_lnum_off-- > 0)",
          "615:      ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;",
          "616:     }",
          "618:     nesting_def[nesting] = vim9_function;",
          "619:     getline_options = vim9_function",
          "620:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "621:     for (;;)",
          "622:     {",
          "623:  char_u *theline;",
          "624:  char_u *p;",
          "625:  char_u *arg;",
          "627:  if (KeyTyped)",
          "628:  {",
          "629:      msg_scroll = TRUE;",
          "630:      saved_wait_return = FALSE;",
          "631:  }",
          "632:  need_wait_return = FALSE;",
          "634:  if (line_arg != NULL)",
          "635:  {",
          "637:      theline = line_arg;",
          "638:      p = vim_strchr(theline, '\\n');",
          "639:      if (p == NULL)",
          "640:   line_arg += STRLEN(line_arg);",
          "641:      else",
          "642:      {",
          "644:   line_arg = p + 1;",
          "645:      }",
          "646:  }",
          "647:  else",
          "648:  {",
          "649:      vim_free(*line_to_free);",
          "650:      if (eap->getline == NULL)",
          "651:   theline = getcmdline(':', 0L, indent, getline_options);",
          "652:      else",
          "653:   theline = eap->getline(':', eap->cookie, indent,",
          "654:              getline_options);",
          "656:  }",
          "657:  if (KeyTyped)",
          "658:      lines_left = Rows - 1;",
          "659:  if (theline == NULL)",
          "660:  {",
          "662:      SOURCING_LNUM = sourcing_lnum_top;",
          "663:      if (skip_until != NULL)",
          "664:   semsg(_(e_missing_heredoc_end_marker_str), skip_until);",
          "665:      else if (eap->cmdidx == CMD_def)",
          "666:   emsg(_(e_missing_enddef));",
          "667:      else if (eap->cmdidx == CMD_block)",
          "668:   emsg(_(e_missing_end_block));",
          "669:      else",
          "670:   emsg(_(\"E126: Missing :endfunction\"));",
          "671:      goto theend;",
          "672:  }",
          "675:  sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "676:  if (SOURCING_LNUM < sourcing_lnum_off)",
          "677:      sourcing_lnum_off -= SOURCING_LNUM;",
          "678:  else",
          "679:      sourcing_lnum_off = 0;",
          "681:  if (skip_until != NULL)",
          "682:  {",
          "687:      if (heredoc_trimmed == NULL",
          "688:       || (is_heredoc && skipwhite(theline) == theline)",
          "689:       || STRNCMP(theline, heredoc_trimmed,",
          "690:        STRLEN(heredoc_trimmed)) == 0)",
          "691:      {",
          "692:   if (heredoc_trimmed == NULL)",
          "693:       p = theline;",
          "694:   else if (is_heredoc)",
          "695:       p = skipwhite(theline) == theline",
          "696:      ? theline : theline + STRLEN(heredoc_trimmed);",
          "697:   else",
          "698:       p = theline + STRLEN(heredoc_trimmed);",
          "699:   if (STRCMP(p, skip_until) == 0)",
          "700:   {",
          "701:       VIM_CLEAR(skip_until);",
          "702:       VIM_CLEAR(heredoc_trimmed);",
          "703:       getline_options = vim9_function",
          "704:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "705:       is_heredoc = FALSE;",
          "706:   }",
          "707:      }",
          "708:  }",
          "709:  else",
          "710:  {",
          "711:      int c;",
          "714:      for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)",
          "715:   ;",
          "719:      if ((nesting == 0 && eap->cmdidx == CMD_block)",
          "720:       ? *p == '}'",
          "721:       : (checkforcmd(&p, nesting_def[nesting]",
          "722:       ? \"enddef\" : \"endfunction\", 4)",
          "723:    && *p != ':'))",
          "724:      {",
          "725:   if (nesting-- == 0)",
          "726:   {",
          "727:       char_u *nextcmd = NULL;",
          "729:       if (*p == '|' || *p == '}')",
          "730:    nextcmd = p + 1;",
          "731:       else if (line_arg != NULL && *skipwhite(line_arg) != NUL)",
          "732:    nextcmd = line_arg;",
          "733:       else if (*p != NUL && *p != (vim9_function ? '#' : '\"')",
          "734:      && p_verbose > 0",
          "735:      && eap->cmdidx != CMD_block)",
          "736:    give_warning2(eap->cmdidx == CMD_def",
          "737:        ? (char_u *)_(\"W1001: Text found after :enddef: %s\")",
          "738:        : (char_u *)_(\"W22: Text found after :endfunction: %s\"),",
          "739:         p, TRUE);",
          "740:       if (nextcmd != NULL)",
          "741:       {",
          "745:    eap->nextcmd = nextcmd;",
          "746:    if (*line_to_free != NULL)",
          "747:    {",
          "748:        vim_free(*eap->cmdlinep);",
          "751:    }",
          "752:       }",
          "753:       break;",
          "754:   }",
          "755:      }",
          "762:      else if (nesting_def[nesting])",
          "763:      {",
          "764:   if (checkforcmd(&p, \"endfunction\", 4) && *p != ':')",
          "765:       emsg(_(e_mismatched_endfunction));",
          "766:      }",
          "767:      else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))",
          "768:   emsg(_(e_mismatched_enddef));",
          "772:      if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))",
          "773:   indent -= 2;",
          "774:      else if (STRNCMP(p, \"if\", 2) == 0",
          "775:       || STRNCMP(p, \"wh\", 2) == 0",
          "776:       || STRNCMP(p, \"for\", 3) == 0",
          "777:       || STRNCMP(p, \"try\", 3) == 0)",
          "778:   indent += 2;",
          "783:      c = *p;",
          "784:      if (is_function_cmd(&p)",
          "785:       || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))",
          "786:      {",
          "787:   if (*p == '!')",
          "788:       p = skipwhite(p + 1);",
          "789:   p += eval_fname_script(p);",
          "790:   vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,",
          "791:           NULL, NULL));",
          "792:   if (*skipwhite(p) == '(')",
          "793:   {",
          "794:       if (nesting == MAX_FUNC_NESTING - 1)",
          "795:    emsg(_(e_function_nesting_too_deep));",
          "796:       else",
          "797:       {",
          "798:    ++nesting;",
          "799:    nesting_def[nesting] = (c == 'd');",
          "800:    indent += 2;",
          "801:       }",
          "802:   }",
          "803:      }",
          "806:      p = skip_range(p, FALSE, NULL);",
          "807:      if (!vim9_function",
          "808:   && ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))",
          "809:       || (p[0] == 'c'",
          "810:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'",
          "811:     && (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'",
          "812:      && (STRNCMP(&p[3], \"nge\", 3) != 0",
          "813:          || !ASCII_ISALPHA(p[6])))))))",
          "814:       || (p[0] == 'i'",
          "815:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'",
          "816:     && (!ASCII_ISALPHA(p[2])",
          "817:         || (p[2] == 's'",
          "818:      && (!ASCII_ISALPHA(p[3])",
          "819:       || p[3] == 'e'))))))))",
          "820:   skip_until = vim_strsave((char_u *)\".\");",
          "823:      arg = skipwhite(skiptowhite(p));",
          "824:      if (arg[0] == '<' && arg[1] =='<'",
          "825:       && ((p[0] == 'p' && p[1] == 'y'",
          "826:         && (!ASCII_ISALNUM(p[2]) || p[2] == 't'",
          "827:      || ((p[2] == '3' || p[2] == 'x')",
          "828:          && !ASCII_ISALPHA(p[3]))))",
          "829:    || (p[0] == 'p' && p[1] == 'e'",
          "830:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))",
          "831:    || (p[0] == 't' && p[1] == 'c'",
          "832:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))",
          "833:    || (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'",
          "834:         && !ASCII_ISALPHA(p[3]))",
          "835:    || (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'",
          "836:         && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))",
          "837:    || (p[0] == 'm' && p[1] == 'z'",
          "838:         && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))",
          "839:    ))",
          "840:      {",
          "842:   p = skipwhite(arg + 2);",
          "843:   if (STRNCMP(p, \"trim\", 4) == 0)",
          "844:   {",
          "846:       p = skipwhite(p + 4);",
          "847:       heredoc_trimmed = vim_strnsave(theline,",
          "848:        skipwhite(theline) - theline);",
          "849:   }",
          "850:   if (*p == NUL)",
          "851:       skip_until = vim_strsave((char_u *)\".\");",
          "852:   else",
          "853:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "854:   getline_options = GETLINE_NONE;",
          "855:   is_heredoc = TRUE;",
          "856:      }",
          "862:      arg = skipwhite(skiptowhite(p));",
          "863:      if (*arg == '[')",
          "864:   arg = vim_strchr(arg, ']');",
          "865:      if (arg != NULL)",
          "866:      {",
          "867:   int found = (eap->cmdidx == CMD_def && arg[0] == '='",
          "868:           && arg[1] == '<' && arg[2] =='<');",
          "870:   if (!found)",
          "872:       arg = skipwhite(skiptowhite(arg));",
          "873:   if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'",
          "874:    && (checkforcmd(&p, \"let\", 2)",
          "875:        || checkforcmd(&p, \"var\", 3)",
          "876:        || checkforcmd(&p, \"final\", 5)",
          "877:        || checkforcmd(&p, \"const\", 5))))",
          "878:   {",
          "879:       p = skipwhite(arg + 3);",
          "880:       if (STRNCMP(p, \"trim\", 4) == 0)",
          "881:       {",
          "883:    p = skipwhite(p + 4);",
          "884:    heredoc_trimmed = vim_strnsave(theline,",
          "885:        skipwhite(theline) - theline);",
          "886:       }",
          "887:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "888:       getline_options = GETLINE_NONE;",
          "889:       is_heredoc = TRUE;",
          "890:   }",
          "891:      }",
          "892:  }",
          "895:  if (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)",
          "896:      goto theend;",
          "901:  p = vim_strsave(theline);",
          "902:  if (p == NULL)",
          "903:      goto theend;",
          "904:  ((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;",
          "908:  while (sourcing_lnum_off-- > 0)",
          "909:      ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;",
          "912:  if (line_arg != NULL && *line_arg == NUL)",
          "913:      line_arg = NULL;",
          "914:     }",
          "918:     if (!eap->skip && !did_emsg)",
          "919:  ret = OK;",
          "921: theend:",
          "922:     vim_free(skip_until);",
          "923:     vim_free(heredoc_trimmed);",
          "924:     need_wait_return |= saved_wait_return;",
          "925:     return ret;",
          "926: }",
          "933:     static int",
          "934: lambda_function_body(",
          "935:  char_u     **arg,",
          "936:  typval_T    *rettv,",
          "937:  evalarg_T   *evalarg,",
          "938:  garray_T    *newargs,",
          "939:  garray_T    *argtypes,",
          "940:  int     varargs,",
          "941:  garray_T    *default_args,",
          "942:  char_u     *ret_type)",
          "943: {",
          "944:     int  evaluate = evalarg != NULL",
          "945:           && (evalarg->eval_flags & EVAL_EVALUATE);",
          "946:     ufunc_T *ufunc;",
          "947:     exarg_T eap;",
          "948:     garray_T newlines;",
          "949:     char_u *cmdline = NULL;",
          "950:     int  ret = FAIL;",
          "951:     char_u *line_to_free = NULL;",
          "952:     partial_T *pt;",
          "953:     char_u *name;",
          "954:     int  lnum_save = -1;",
          "955:     linenr_T sourcing_lnum_top = SOURCING_LNUM;",
          "957:     CLEAR_FIELD(eap);",
          "958:     eap.cmdidx = CMD_block;",
          "959:     eap.forceit = FALSE;",
          "960:     eap.arg = *arg + 1;",
          "961:     eap.cmdlinep = &cmdline;",
          "962:     eap.skip = !evaluate;",
          "963:     if (evalarg->eval_cctx != NULL)",
          "964:  fill_exarg_from_cctx(&eap, evalarg->eval_cctx);",
          "965:     else",
          "966:     {",
          "967:  eap.getline = evalarg->eval_getline;",
          "968:  eap.cookie = evalarg->eval_cookie;",
          "969:     }",
          "971:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
          "972:     if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)",
          "973:  goto erret;",
          "974:     if (cmdline != NULL)",
          "975:     {",
          "978:  if (evalarg->eval_cctx == NULL)",
          "979:  {",
          "981:      vim_free(evalarg->eval_tofree_lambda);",
          "982:      evalarg->eval_tofree_lambda = cmdline;",
          "983:  }",
          "985:     else",
          "988:     name = get_lambda_name();",
          "989:     ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);",
          "990:     if (ufunc == NULL)",
          "991:  goto erret;",
          "992:     set_ufunc_name(ufunc, name);",
          "993:     if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)",
          "995:  vim_free(ufunc);",
          "996:  goto erret;",
          "998:     ufunc->uf_refcount = 1;",
          "999:     ufunc->uf_args = *newargs;",
          "1000:     newargs->ga_data = NULL;",
          "1001:     ufunc->uf_def_args = *default_args;",
          "1002:     default_args->ga_data = NULL;",
          "1003:     ufunc->uf_func_type = &t_func_any;",
          "1006:     lnum_save = SOURCING_LNUM;",
          "1007:     SOURCING_LNUM = sourcing_lnum_top;",
          "1010:     if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)",
          "1011:     {",
          "1012:  SOURCING_LNUM = lnum_save;",
          "1013:  goto erret;",
          "1014:     }",
          "1017:     if (parse_return_type(ufunc, ret_type) == FAIL)",
          "1018:  goto erret;",
          "1020:     pt = ALLOC_CLEAR_ONE(partial_T);",
          "1021:     if (pt == NULL)",
          "1022:  goto erret;",
          "1023:     pt->pt_func = ufunc;",
          "1024:     pt->pt_refcount = 1;",
          "1026:     ufunc->uf_lines = newlines;",
          "1027:     newlines.ga_data = NULL;",
          "1028:     if (sandbox)",
          "1029:  ufunc->uf_flags |= FC_SANDBOX;",
          "1030:     if (!ASCII_ISUPPER(*ufunc->uf_name))",
          "1031:  ufunc->uf_flags |= FC_VIM9;",
          "1032:     ufunc->uf_script_ctx = current_sctx;",
          "1033:     ufunc->uf_script_ctx_version = current_sctx.sc_version;",
          "1034:     ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;",
          "1035:     set_function_type(ufunc);",
          "1037:     rettv->vval.v_partial = pt;",
          "1038:     rettv->v_type = VAR_PARTIAL;",
          "1039:     ret = OK;",
          "1041: erret:",
          "1042:     if (lnum_save >= 0)",
          "1043:  SOURCING_LNUM = lnum_save;",
          "1044:     vim_free(line_to_free);",
          "1045:     ga_clear_strings(&newlines);",
          "1046:     ga_clear_strings(newargs);",
          "1047:     ga_clear_strings(default_args);",
          "1048:     return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "554:     garray_T newlines;",
          "555:     garray_T *pnewargs;",
          "556:     garray_T argtypes;",
          "557:     ufunc_T *fp = NULL;",
          "558:     partial_T   *pt = NULL;",
          "559:     int  varargs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1070:     garray_T default_args;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "597:     ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,",
          "598:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "600:     if (ret == FAIL",
          "601:     || (s = skip_arrow(*arg, equal_arrow, &ret_type,",
          "602:   equal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)",
          "",
          "[Removed Lines]",
          "599:          &varargs, NULL, FALSE, NULL, NULL);",
          "",
          "[Added Lines]",
          "1113:          &varargs, &default_args,",
          "1114:          FALSE, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "625:     if (equal_arrow && **arg == '{')",
          "626:     {",
          "630:  goto errret;",
          "631:     }",
          "",
          "[Removed Lines]",
          "629:  emsg(\"Lambda function body not supported yet\");",
          "",
          "[Added Lines]",
          "1142:  if (lambda_function_body(arg, rettv, evalarg, pnewargs,",
          "1143:       types_optional ? &argtypes : NULL, varargs,",
          "1144:       &default_args, ret_type) == FAIL)",
          "1145:      goto errret;",
          "1146:  goto theend;",
          "1147:     }",
          "1148:     if (default_args.ga_len > 0)",
          "1149:     {",
          "1150:  emsg(_(e_cannot_use_default_values_in_lambda));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "732:  hash_add(&func_hashtab, UF2HIKEY(fp));",
          "733:     }",
          "735:     eval_lavars_used = old_eval_lavars;",
          "736:     if (evalarg != NULL && evalarg->eval_tofree == NULL)",
          "737:  evalarg->eval_tofree = tofree1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1256: theend:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "745: errret:",
          "746:     ga_clear_strings(&newargs);",
          "747:     ga_clear_strings(&newlines);",
          "748:     if (types_optional)",
          "749:  ga_clear_strings(&argtypes);",
          "750:     vim_free(fp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1270:     ga_clear_strings(&default_args);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2459:     {",
          "2461:  if (check_argument_types(funcexe->check_type, argvars, argcount,",
          "2463:      error = FCERR_OTHER;",
          "2464:     }",
          "",
          "[Removed Lines]",
          "2462:          name) == FAIL)",
          "",
          "[Added Lines]",
          "2985:          (name != NULL) ? name : funcname) == FAIL)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3005:     }",
          "3006: }",
          "",
          "[Removed Lines]",
          "3014:     static int",
          "3015: is_function_cmd(char_u **cmd)",
          "3016: {",
          "3017:     char_u *p = *cmd;",
          "3019:     if (checkforcmd(&p, \"function\", 2))",
          "3020:     {",
          "3021:  if (*p == '(')",
          "3022:      return FALSE;",
          "3024:  return TRUE;",
          "3025:     }",
          "3026:     return FALSE;",
          "3027: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3035:     ufunc_T *",
          "3036: define_function(exarg_T *eap, char_u *name_arg)",
          "3037: {",
          "3039:     char_u *line_to_free = NULL;",
          "3040:     int  j;",
          "3041:     int  c;",
          "3042:     int  saved_did_emsg;",
          "3044:     char_u *name = name_arg;",
          "3045:     int  is_global = FALSE;",
          "3046:     char_u *p;",
          "",
          "[Removed Lines]",
          "3038:     char_u *theline;",
          "3043:     int  saved_wait_return = need_wait_return;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3056:     char_u *ret_type = NULL;",
          "3057:     ufunc_T *fp = NULL;",
          "3058:     int  overwrite = FALSE;",
          "3063:     dictitem_T *v;",
          "3064:     funcdict_T fudi;",
          "3065:     static int func_nr = 0;     // number for nameless function",
          "3066:     int  paren;",
          "3067:     hashitem_T *hi;",
          "3070:     linenr_T sourcing_lnum_top;",
          "3074:     int  vim9script = in_vim9script();",
          "3075:     imported_T *import = NULL;",
          "",
          "[Removed Lines]",
          "3059:     int  indent;",
          "3060:     int  nesting;",
          "3061: #define MAX_FUNC_NESTING 50",
          "3062:     char nesting_def[MAX_FUNC_NESTING];",
          "3068:     getline_opt_T getline_options;",
          "3069:     linenr_T sourcing_lnum_off;",
          "3071:     int  is_heredoc = FALSE;",
          "3072:     char_u *skip_until = NULL;",
          "3073:     char_u *heredoc_trimmed = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3263:  goto ret_free;",
          "3264:     }",
          "3268:     if (!eap->skip && name_arg == NULL)",
          "3269:     {",
          "",
          "[Removed Lines]",
          "3266:     ga_init2(&newlines, (int)sizeof(char_u *), 3);",
          "",
          "[Added Lines]",
          "3757:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3305:     if (eap->cmdidx == CMD_def)",
          "3306:     {",
          "3499:      }",
          "3500:  }",
          "3502:  {",
          "3512:      {",
          "3541:      }",
          "3549:      {",
          "3552:      }",
          "3572:      {",
          "3589:      }",
          "3626:      {",
          "3630:   {",
          "3635:   }",
          "3642:      }",
          "3678:  }",
          "3689:      goto erret;",
          "3700:     }",
          "3705:  goto erret;",
          "",
          "[Removed Lines]",
          "3308:  if (*p == ':')",
          "3309:  {",
          "3310:      ret_type = skipwhite(p + 1);",
          "3311:      p = skip_type(ret_type, FALSE);",
          "3312:      if (p > ret_type)",
          "3313:      {",
          "3314:   ret_type = vim_strnsave(ret_type, p - ret_type);",
          "3315:   whitep = p;",
          "3316:   p = skipwhite(p);",
          "3317:      }",
          "3318:      else",
          "3319:      {",
          "3320:   semsg(_(e_expected_type_str), ret_type);",
          "3321:   ret_type = NULL;",
          "3322:      }",
          "3323:  }",
          "3324:  p = skipwhite(p);",
          "3325:     }",
          "3326:     else",
          "3328:  for (;;)",
          "3329:  {",
          "3330:      whitep = p;",
          "3331:      p = skipwhite(p);",
          "3332:      if (STRNCMP(p, \"range\", 5) == 0)",
          "3333:      {",
          "3334:   flags |= FC_RANGE;",
          "3335:   p += 5;",
          "3336:      }",
          "3337:      else if (STRNCMP(p, \"dict\", 4) == 0)",
          "3338:      {",
          "3339:   flags |= FC_DICT;",
          "3340:   p += 4;",
          "3341:      }",
          "3342:      else if (STRNCMP(p, \"abort\", 5) == 0)",
          "3343:      {",
          "3344:   flags |= FC_ABORT;",
          "3345:   p += 5;",
          "3346:      }",
          "3347:      else if (STRNCMP(p, \"closure\", 7) == 0)",
          "3348:      {",
          "3349:   flags |= FC_CLOSURE;",
          "3350:   p += 7;",
          "3351:   if (current_funccal == NULL)",
          "3352:   {",
          "3353:       emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),",
          "3354:        name == NULL ? (char_u *)\"\" : name);",
          "3355:       goto erret;",
          "3356:   }",
          "3357:      }",
          "3358:      else",
          "3359:   break;",
          "3360:  }",
          "3364:     if (*p == '\\n')",
          "3365:  line_arg = p + 1;",
          "3366:     else if (*p != NUL",
          "3367:      && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)",
          "3368:            && eap->cmdidx != CMD_def)",
          "3369:      && !(VIM_ISWHITE(*whitep) && *p == '#'",
          "3370:          && (vim9script || eap->cmdidx == CMD_def))",
          "3371:      && !eap->skip",
          "3372:      && !did_emsg)",
          "3373:  semsg(_(e_trailing_arg), p);",
          "3379:     if (KeyTyped)",
          "3380:     {",
          "3384:  if (!eap->skip && !eap->forceit)",
          "3385:  {",
          "3386:      if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)",
          "3387:   emsg(_(e_funcdict));",
          "3388:      else if (name != NULL && find_func(name, is_global, NULL) != NULL)",
          "3389:   emsg_funcname(e_funcexts, name);",
          "3390:  }",
          "3392:  if (!eap->skip && did_emsg)",
          "3393:      goto erret;",
          "3395:  msg_putchar('\\n');     // don't overwrite the function name",
          "3396:  cmdline_row = msg_row;",
          "3397:     }",
          "3400:     sourcing_lnum_top = SOURCING_LNUM;",
          "3404:     sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "3405:     if (SOURCING_LNUM < sourcing_lnum_off)",
          "3406:     {",
          "3407:  sourcing_lnum_off -= SOURCING_LNUM;",
          "3408:  if (ga_grow(&newlines, sourcing_lnum_off) == FAIL)",
          "3409:      goto erret;",
          "3410:  while (sourcing_lnum_off-- > 0)",
          "3411:      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;",
          "3412:     }",
          "3414:     indent = 2;",
          "3415:     nesting = 0;",
          "3416:     nesting_def[nesting] = (eap->cmdidx == CMD_def);",
          "3417:     getline_options = eap->cmdidx == CMD_def",
          "3418:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "3419:     for (;;)",
          "3420:     {",
          "3421:  if (KeyTyped)",
          "3422:  {",
          "3423:      msg_scroll = TRUE;",
          "3424:      saved_wait_return = FALSE;",
          "3425:  }",
          "3426:  need_wait_return = FALSE;",
          "3428:  if (line_arg != NULL)",
          "3429:  {",
          "3431:      theline = line_arg;",
          "3432:      p = vim_strchr(theline, '\\n');",
          "3433:      if (p == NULL)",
          "3434:   line_arg += STRLEN(line_arg);",
          "3435:      else",
          "3436:      {",
          "3438:   line_arg = p + 1;",
          "3439:      }",
          "3440:  }",
          "3441:  else",
          "3442:  {",
          "3443:      vim_free(line_to_free);",
          "3444:      if (eap->getline == NULL)",
          "3445:   theline = getcmdline(':', 0L, indent, getline_options);",
          "3446:      else",
          "3447:   theline = eap->getline(':', eap->cookie, indent,",
          "3448:              getline_options);",
          "3449:      line_to_free = theline;",
          "3450:  }",
          "3451:  if (KeyTyped)",
          "3452:      lines_left = Rows - 1;",
          "3453:  if (theline == NULL)",
          "3454:  {",
          "3456:      SOURCING_LNUM = sourcing_lnum_top;",
          "3457:      if (skip_until != NULL)",
          "3458:   semsg(_(e_missing_heredoc_end_marker_str), skip_until);",
          "3459:      else if (eap->cmdidx == CMD_def)",
          "3460:   emsg(_(e_missing_enddef));",
          "3461:      else",
          "3462:   emsg(_(\"E126: Missing :endfunction\"));",
          "3463:      goto erret;",
          "3464:  }",
          "3467:  sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "3468:  if (SOURCING_LNUM < sourcing_lnum_off)",
          "3469:      sourcing_lnum_off -= SOURCING_LNUM;",
          "3470:  else",
          "3471:      sourcing_lnum_off = 0;",
          "3473:  if (skip_until != NULL)",
          "3474:  {",
          "3479:      if (heredoc_trimmed == NULL",
          "3480:       || (is_heredoc && skipwhite(theline) == theline)",
          "3481:       || STRNCMP(theline, heredoc_trimmed,",
          "3482:        STRLEN(heredoc_trimmed)) == 0)",
          "3483:      {",
          "3484:   if (heredoc_trimmed == NULL)",
          "3485:       p = theline;",
          "3486:   else if (is_heredoc)",
          "3487:       p = skipwhite(theline) == theline",
          "3488:      ? theline : theline + STRLEN(heredoc_trimmed);",
          "3489:   else",
          "3490:       p = theline + STRLEN(heredoc_trimmed);",
          "3491:   if (STRCMP(p, skip_until) == 0)",
          "3492:   {",
          "3493:       VIM_CLEAR(skip_until);",
          "3494:       VIM_CLEAR(heredoc_trimmed);",
          "3495:       getline_options = eap->cmdidx == CMD_def",
          "3496:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "3497:       is_heredoc = FALSE;",
          "3498:   }",
          "3501:  else",
          "3504:      for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)",
          "3505:   ;",
          "3509:      if (checkforcmd(&p, nesting_def[nesting]",
          "3510:       ? \"enddef\" : \"endfunction\", 4)",
          "3511:       && *p != ':')",
          "3513:   if (nesting-- == 0)",
          "3514:   {",
          "3515:       char_u *nextcmd = NULL;",
          "3517:       if (*p == '|')",
          "3518:    nextcmd = p + 1;",
          "3519:       else if (line_arg != NULL && *skipwhite(line_arg) != NUL)",
          "3520:    nextcmd = line_arg;",
          "3521:       else if (*p != NUL && *p != '\"' && p_verbose > 0)",
          "3522:    give_warning2(eap->cmdidx == CMD_def",
          "3523:        ? (char_u *)_(\"W1001: Text found after :enddef: %s\")",
          "3524:        : (char_u *)_(\"W22: Text found after :endfunction: %s\"),",
          "3525:         p, TRUE);",
          "3526:       if (nextcmd != NULL)",
          "3527:       {",
          "3531:    eap->nextcmd = nextcmd;",
          "3532:    if (line_to_free != NULL)",
          "3533:    {",
          "3534:        vim_free(*eap->cmdlinep);",
          "3536:        line_to_free = NULL;",
          "3537:    }",
          "3538:       }",
          "3539:       break;",
          "3540:   }",
          "3548:      else if (nesting_def[nesting])",
          "3550:   if (checkforcmd(&p, \"endfunction\", 4) && *p != ':')",
          "3551:       emsg(_(e_mismatched_endfunction));",
          "3553:      else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))",
          "3554:   emsg(_(e_mismatched_enddef));",
          "3558:      if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))",
          "3559:   indent -= 2;",
          "3560:      else if (STRNCMP(p, \"if\", 2) == 0",
          "3561:       || STRNCMP(p, \"wh\", 2) == 0",
          "3562:       || STRNCMP(p, \"for\", 3) == 0",
          "3563:       || STRNCMP(p, \"try\", 3) == 0)",
          "3564:   indent += 2;",
          "3569:      c = *p;",
          "3570:      if (is_function_cmd(&p)",
          "3571:       || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))",
          "3573:   if (*p == '!')",
          "3574:       p = skipwhite(p + 1);",
          "3575:   p += eval_fname_script(p);",
          "3576:   vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,",
          "3577:           NULL, NULL));",
          "3578:   if (*skipwhite(p) == '(')",
          "3579:   {",
          "3580:       if (nesting == MAX_FUNC_NESTING - 1)",
          "3581:    emsg(_(e_function_nesting_too_deep));",
          "3582:       else",
          "3583:       {",
          "3584:    ++nesting;",
          "3585:    nesting_def[nesting] = (c == 'd');",
          "3586:    indent += 2;",
          "3587:       }",
          "3588:   }",
          "3592:      p = skip_range(p, FALSE, NULL);",
          "3593:      if (eap->cmdidx != CMD_def",
          "3594:   && ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))",
          "3595:       || (p[0] == 'c'",
          "3596:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'",
          "3597:     && (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'",
          "3598:      && (STRNCMP(&p[3], \"nge\", 3) != 0",
          "3599:          || !ASCII_ISALPHA(p[6])))))))",
          "3600:       || (p[0] == 'i'",
          "3601:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'",
          "3602:     && (!ASCII_ISALPHA(p[2])",
          "3603:         || (p[2] == 's'",
          "3604:      && (!ASCII_ISALPHA(p[3])",
          "3605:       || p[3] == 'e'))))))))",
          "3606:   skip_until = vim_strsave((char_u *)\".\");",
          "3609:      arg = skipwhite(skiptowhite(p));",
          "3610:      if (arg[0] == '<' && arg[1] =='<'",
          "3611:       && ((p[0] == 'p' && p[1] == 'y'",
          "3612:         && (!ASCII_ISALNUM(p[2]) || p[2] == 't'",
          "3613:      || ((p[2] == '3' || p[2] == 'x')",
          "3614:          && !ASCII_ISALPHA(p[3]))))",
          "3615:    || (p[0] == 'p' && p[1] == 'e'",
          "3616:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))",
          "3617:    || (p[0] == 't' && p[1] == 'c'",
          "3618:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))",
          "3619:    || (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'",
          "3620:         && !ASCII_ISALPHA(p[3]))",
          "3621:    || (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'",
          "3622:         && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))",
          "3623:    || (p[0] == 'm' && p[1] == 'z'",
          "3624:         && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))",
          "3625:    ))",
          "3628:   p = skipwhite(arg + 2);",
          "3629:   if (STRNCMP(p, \"trim\", 4) == 0)",
          "3632:       p = skipwhite(p + 4);",
          "3633:       heredoc_trimmed = vim_strnsave(theline,",
          "3634:        skipwhite(theline) - theline);",
          "3636:   if (*p == NUL)",
          "3637:       skip_until = vim_strsave((char_u *)\".\");",
          "3638:   else",
          "3639:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "3640:   getline_options = GETLINE_NONE;",
          "3641:   is_heredoc = TRUE;",
          "3648:      arg = skipwhite(skiptowhite(p));",
          "3649:      if (*arg == '[')",
          "3650:   arg = vim_strchr(arg, ']');",
          "3651:      if (arg != NULL)",
          "3652:      {",
          "3653:   int found = (eap->cmdidx == CMD_def && arg[0] == '='",
          "3654:           && arg[1] == '<' && arg[2] =='<');",
          "3656:   if (!found)",
          "3658:       arg = skipwhite(skiptowhite(arg));",
          "3659:   if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'",
          "3660:    && (checkforcmd(&p, \"let\", 2)",
          "3661:        || checkforcmd(&p, \"var\", 3)",
          "3662:        || checkforcmd(&p, \"final\", 5)",
          "3663:        || checkforcmd(&p, \"const\", 5))))",
          "3664:   {",
          "3665:       p = skipwhite(arg + 3);",
          "3666:       if (STRNCMP(p, \"trim\", 4) == 0)",
          "3667:       {",
          "3669:    p = skipwhite(p + 4);",
          "3670:    heredoc_trimmed = vim_strnsave(theline,",
          "3671:        skipwhite(theline) - theline);",
          "3672:       }",
          "3673:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "3674:       getline_options = GETLINE_NONE;",
          "3675:       is_heredoc = TRUE;",
          "3676:   }",
          "3677:      }",
          "3681:  if (ga_grow(&newlines, 1 + sourcing_lnum_off) == FAIL)",
          "3682:      goto erret;",
          "3687:  p = vim_strsave(theline);",
          "3688:  if (p == NULL)",
          "3690:  ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;",
          "3694:  while (sourcing_lnum_off-- > 0)",
          "3695:      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;",
          "3698:  if (line_arg != NULL && *line_arg == NUL)",
          "3699:      line_arg = NULL;",
          "3704:     if (eap->skip || did_emsg)",
          "",
          "[Added Lines]",
          "3799:  if (*p == ':')",
          "3800:  {",
          "3801:      ret_type = skipwhite(p + 1);",
          "3802:      p = skip_type(ret_type, FALSE);",
          "3803:      if (p > ret_type)",
          "3804:      {",
          "3805:   ret_type = vim_strnsave(ret_type, p - ret_type);",
          "3806:   whitep = p;",
          "3807:   p = skipwhite(p);",
          "3808:      }",
          "3809:      else",
          "3810:      {",
          "3811:   semsg(_(e_expected_type_str), ret_type);",
          "3812:   ret_type = NULL;",
          "3815:  p = skipwhite(p);",
          "3816:     }",
          "3817:     else",
          "3819:  for (;;)",
          "3821:      whitep = p;",
          "3822:      p = skipwhite(p);",
          "3823:      if (STRNCMP(p, \"range\", 5) == 0)",
          "3825:   flags |= FC_RANGE;",
          "3826:   p += 5;",
          "3828:      else if (STRNCMP(p, \"dict\", 4) == 0)",
          "3830:   flags |= FC_DICT;",
          "3831:   p += 4;",
          "3833:      else if (STRNCMP(p, \"abort\", 5) == 0)",
          "3835:   flags |= FC_ABORT;",
          "3836:   p += 5;",
          "3838:      else if (STRNCMP(p, \"closure\", 7) == 0)",
          "3840:   flags |= FC_CLOSURE;",
          "3841:   p += 7;",
          "3842:   if (current_funccal == NULL)",
          "3844:       emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),",
          "3845:        name == NULL ? (char_u *)\"\" : name);",
          "3846:       goto erret;",
          "3849:      else",
          "3850:   break;",
          "3851:  }",
          "3855:     if (*p == '\\n')",
          "3856:  line_arg = p + 1;",
          "3857:     else if (*p != NUL",
          "3858:      && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)",
          "3859:            && eap->cmdidx != CMD_def)",
          "3860:      && !(VIM_ISWHITE(*whitep) && *p == '#'",
          "3861:          && (vim9script || eap->cmdidx == CMD_def))",
          "3862:      && !eap->skip",
          "3863:      && !did_emsg)",
          "3864:  semsg(_(e_trailing_arg), p);",
          "3870:     if (KeyTyped)",
          "3871:     {",
          "3875:  if (!eap->skip && !eap->forceit)",
          "3876:  {",
          "3877:      if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)",
          "3878:   emsg(_(e_funcdict));",
          "3879:      else if (name != NULL && find_func(name, is_global, NULL) != NULL)",
          "3880:   emsg_funcname(e_funcexts, name);",
          "3883:  if (!eap->skip && did_emsg)",
          "3886:  msg_putchar('\\n');     // don't overwrite the function name",
          "3887:  cmdline_row = msg_row;",
          "3891:     sourcing_lnum_top = SOURCING_LNUM;",
          "3893:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3933:  varargs = FALSE;",
          "3939:  {",
          "3948:  }",
          "3949:  SOURCING_LNUM = lnum_save;",
          "3950:     }",
          "",
          "[Removed Lines]",
          "3936:  if (ret_type == NULL)",
          "3937:      fp->uf_ret_type = &t_void;",
          "3938:  else",
          "3940:      p = ret_type;",
          "3941:      fp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);",
          "3942:      if (fp->uf_ret_type == NULL)",
          "3943:      {",
          "3944:   fp->uf_ret_type = &t_void;",
          "3945:   SOURCING_LNUM = lnum_save;",
          "3946:   goto erret;",
          "3947:      }",
          "",
          "[Added Lines]",
          "4125:  if (parse_return_type(fp, ret_type) == FAIL)",
          "4127:      SOURCING_LNUM = lnum_save;",
          "4128:      goto erret;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4004:  VIM_CLEAR(fp->uf_arg_types);",
          "4005: ret_free:",
          "4006:     ga_clear_strings(&argtypes);",
          "4009:     vim_free(line_to_free);",
          "4010:     vim_free(fudi.fd_newkey);",
          "4011:     if (name != name_arg)",
          "4012:  vim_free(name);",
          "4013:     vim_free(ret_type);",
          "4014:     did_emsg |= saved_did_emsg;",
          "4017:     return fp;",
          "4018: }",
          "",
          "[Removed Lines]",
          "4007:     vim_free(skip_until);",
          "4008:     vim_free(heredoc_trimmed);",
          "4015:     need_wait_return |= saved_wait_return;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2634,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2635,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5126:     }",
          "5127: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5129:     void",
          "5130: fill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)",
          "5131: {",
          "5132:     eap->getline = exarg_getline;",
          "5133:     eap->cookie = cctx;",
          "5134: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5176:  return NULL;",
          "5178:     eap->arg = name_end;",
          "5182:     eap->forceit = FALSE;",
          "5183:     lambda_name = vim_strsave(get_lambda_name());",
          "5184:     if (lambda_name == NULL)",
          "",
          "[Removed Lines]",
          "5179:     eap->getline = exarg_getline;",
          "5180:     eap->cookie = cctx;",
          "5181:     eap->skip = cctx->ctx_skip == SKIP_YES;",
          "",
          "[Added Lines]",
          "5186:     fill_exarg_from_cctx(eap, cctx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ffdaca9e6f3d39af6857ac52ced9385df203a152",
      "candidate_info": {
        "commit_hash": "ffdaca9e6f3d39af6857ac52ced9385df203a152",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/ffdaca9e6f3d39af6857ac52ced9385df203a152",
        "files": [
          "src/errors.h",
          "src/eval.c",
          "src/proto/userfunc.pro",
          "src/proto/vim9execute.pro",
          "src/proto/vim9instr.pro",
          "src/structs.h",
          "src/testdir/test_vim9_class.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim.h",
          "src/vim9.h",
          "src/vim9class.c",
          "src/vim9compile.c",
          "src/vim9execute.c",
          "src/vim9expr.c",
          "src/vim9instr.c",
          "src/vim9type.c"
        ],
        "message": "patch 9.0.1041: cannot define a method in a class\n\nProblem:    Cannot define a method in a class.\nSolution:   Implement defining an object method.  Make calling an object\n            method work.",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/eval.c||src/eval.c",
          "src/proto/userfunc.pro||src/proto/userfunc.pro",
          "src/proto/vim9execute.pro||src/proto/vim9execute.pro",
          "src/proto/vim9instr.pro||src/proto/vim9instr.pro",
          "src/structs.h||src/structs.h",
          "src/testdir/test_vim9_class.vim||src/testdir/test_vim9_class.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim.h||src/vim.h",
          "src/vim9.h||src/vim9.h",
          "src/vim9class.c||src/vim9class.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9execute.c||src/vim9execute.c",
          "src/vim9expr.c||src/vim9expr.c",
          "src/vim9instr.c||src/vim9instr.c",
          "src/vim9type.c||src/vim9type.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ],
          "candidate": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c",
            "src/vim9execute.c||src/vim9execute.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3370:  INIT(= N_(\"E1325: Method not found on class \\\"%s\\\": %s\"));",
          "3371: EXTERN char e_member_not_found_on_object_str_str[]",
          "3372:  INIT(= N_(\"E1326: Member not found on object \\\"%s\\\": %s\"));",
          "3373: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3373: EXTERN char e_object_required_found_str[]",
          "3374:  INIT(= N_(\"E1327: Object required, found %s\"));",
          "",
          "---------------"
        ],
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "297:      r = call_def_function(partial->pt_func, argc, argv,",
          "299:      if (fc_arg == NULL)",
          "300:   remove_funccal();",
          "301:      if (r == FAIL)",
          "",
          "[Removed Lines]",
          "298:        DEF_USE_PT_ARGV, partial, fc, rettv);",
          "",
          "[Added Lines]",
          "298:         DEF_USE_PT_ARGV, partial, NULL, fc, rettv);",
          "",
          "---------------"
        ],
        "src/proto/userfunc.pro||src/proto/userfunc.pro": [
          "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: char_u *alloc_printable_func_name(char_u *fname);",
          "47: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
          "48: void list_functions(regmatch_T *regmatch);",
          "50: void ex_function(exarg_T *eap);",
          "51: ufunc_T *find_func_by_name(char_u *name, compiletype_T *compile_type);",
          "52: void ex_defcompile(exarg_T *eap);",
          "",
          "[Removed Lines]",
          "49: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free, class_T *class_arg);",
          "",
          "[Added Lines]",
          "49: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free, int in_class);",
          "",
          "---------------"
        ],
        "src/proto/vim9execute.pro||src/proto/vim9execute.pro": [
          "File: src/proto/vim9execute.pro -> src/proto/vim9execute.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: int add_defer_function(char_u *name, int argcount, typval_T *argvars);",
          "10: char_u *char_from_string(char_u *str, varnumber_T index);",
          "11: char_u *string_slice(char_u *str, varnumber_T first, varnumber_T last, int exclusive);",
          "13: int may_load_script(int sid, int *loaded);",
          "14: typval_T *lookup_debug_var(char_u *name);",
          "15: int may_break_in_function(ufunc_T *ufunc);",
          "",
          "[Removed Lines]",
          "12: int fill_partial_and_closure(partial_T *pt, ufunc_T *ufunc, loopvarinfo_T *loopvarinfo, ectx_T *ectx);",
          "",
          "[Added Lines]",
          "12: int fill_partial_and_closure(partial_T *pt, ufunc_T *ufunc, loopvarinfo_T *lvi, ectx_T *ectx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17: int set_ref_in_loopvars(int copyID);",
          "18: int exe_typval_instr(typval_T *tv, typval_T *rettv);",
          "19: char_u *exe_substitute_instr(void);",
          "21: void unwind_def_callstack(ectx_T *ectx);",
          "22: void may_invoke_defer_funcs(ectx_T *ectx);",
          "23: void set_context_in_disassemble_cmd(expand_T *xp, char_u *arg);",
          "",
          "[Removed Lines]",
          "20: int call_def_function(ufunc_T *ufunc, int argc_arg, typval_T *argv, int flags, partial_T *partial, funccall_T *funccal, typval_T *rettv);",
          "",
          "[Added Lines]",
          "20: int call_def_function(ufunc_T *ufunc, int argc_arg, typval_T *argv, int flags, partial_T *partial, object_T *object, funccall_T *funccal, typval_T *rettv);",
          "",
          "---------------"
        ],
        "src/proto/vim9instr.pro||src/proto/vim9instr.pro": [
          "File: src/proto/vim9instr.pro -> src/proto/vim9instr.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: isn_T *generate_instr_type(cctx_T *cctx, isntype_T isn_type, type_T *type);",
          "5: isn_T *generate_instr_debug(cctx_T *cctx);",
          "6: int generate_CONSTRUCT(cctx_T *cctx, class_T *cl);",
          "7: int may_generate_2STRING(int offset, int tolerant, cctx_T *cctx);",
          "8: int generate_add_instr(cctx_T *cctx, vartype_T vartype, type_T *type1, type_T *type2, exprtype_T expr_type);",
          "9: vartype_T operator_type(type_T *type1, type_T *type2);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: int generate_OBJ_MEMBER(cctx_T *cctx, int idx, type_T *type);",
          "",
          "---------------"
        ],
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1479:     int  class_obj_method_count;",
          "1480:     ufunc_T **class_obj_methods; // allocated",
          "1483:     garray_T class_type_list; // used for type pointers",
          "1484:     type_T class_type;",
          "1485: };",
          "1490:     class_T *obj_class;     // class this object is created for;",
          "1492:     int  obj_refcount;",
          "",
          "[Removed Lines]",
          "1481:     ufunc_T *class_new_func; // new() function that was created",
          "1489: struct object_S {",
          "",
          "[Added Lines]",
          "1484:     type_T class_object_type; // same as class_type but VAR_OBJECT",
          "1489: struct object_S",
          "1490: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2123:     int  fe_evaluate; // actually evaluate expressions",
          "2124:     partial_T *fe_partial; // for extra arguments",
          "2125:     dict_T *fe_selfdict; // Dictionary for \"self\"",
          "2126:     typval_T *fe_basetv; // base for base->method()",
          "2127:     type_T *fe_check_type; // type from funcref or NULL",
          "2128:     int  fe_found_var; // if the function is not found then give an",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2127:     object_T *fe_object; // object, e.g. for \"this.Func()\"",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_class.vim||src/testdir/test_vim9_class.vim": [
          "File: src/testdir/test_vim9_class.vim -> src/testdir/test_vim9_class.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:       class TextPosition",
          "131:         this.lnum: number",
          "132:  this.col: number",
          "133:       endclass",
          "135:       # use the automatically generated new() method",
          "136:       var pos = TextPosition.new(2, 12)",
          "137:       assert_equal(2, pos.lnum)",
          "138:       assert_equal(12, pos.col)",
          "139:   END",
          "140:   v9.CheckScriptSuccess(lines)",
          "141: enddef",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134:         def ToString(): string",
          "135:           return $'({this.lnum}, {this.col})'",
          "136:         enddef",
          "144:       # call an object method",
          "145:       assert_equal('(2, 12)', pos.ToString())",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:     if (theline != NULL)",
          "189:     {",
          "190:  if (lines_to_free->ga_len > 0",
          "191:   && *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)",
          "192:          [lines_to_free->ga_len - 1])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191:   && eap->cmdlinep != NULL",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "214:     garray_T *default_args,",
          "215:     int  skip,",
          "216:     exarg_T *eap,  // can be NULL",
          "218:     garray_T *newlines, // function body lines",
          "219:     garray_T *lines_to_free)",
          "220: {",
          "",
          "[Removed Lines]",
          "217:     class_T *class_arg,",
          "",
          "[Added Lines]",
          "218:     int  in_class, // TRUE when inside a class",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "294:   }",
          "295:      }",
          "296:  }",
          "298:  {",
          "300:      p += 5;",
          "",
          "[Removed Lines]",
          "297:  else if (class_arg != NULL && STRNCMP(p, \"this.\", 5) == 0)",
          "",
          "[Added Lines]",
          "298:  else if (in_class && STRNCMP(p, \"this.\", 5) == 0)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1436:     s = *arg + 1;",
          "1437:     ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,",
          "1438:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "1440:     if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)",
          "1441:     {",
          "1442:  if (types_optional)",
          "",
          "[Removed Lines]",
          "1439:        NULL, &default_args, TRUE, NULL, NULL, NULL, NULL);",
          "",
          "[Added Lines]",
          "1440:       NULL, &default_args, TRUE, NULL, FALSE, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1453:     ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,",
          "1454:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "1455:          &varargs, &default_args,",
          "1457:     if (ret == FAIL",
          "1458:     || (s = skip_arrow(*arg, equal_arrow, &ret_type,",
          "1459:   equal_arrow || vim9script ? &white_error : NULL)) == NULL)",
          "",
          "[Removed Lines]",
          "1456:          FALSE, NULL, NULL, NULL, NULL);",
          "",
          "[Added Lines]",
          "1457:          FALSE, NULL, FALSE, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2733:      profile_may_start_func(&profile_info, fp, caller);",
          "2734: #endif",
          "2735:  sticky_cmdmod_flags = 0;",
          "2738:  funcdepth_decrement();",
          "2739: #ifdef FEAT_PROFILE",
          "2740:  if (do_profiling == PROF_YES && (fp->uf_profiling",
          "",
          "[Removed Lines]",
          "2736:  call_def_function(fp, argcount, argvars, 0, funcexe->fe_partial,",
          "2737:             fc, rettv);",
          "",
          "[Added Lines]",
          "2737:  call_def_function(fp, argcount, argvars, 0,",
          "2738:       funcexe->fe_partial, funcexe->fe_object, fc, rettv);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4172:     }",
          "",
          "[Removed Lines]",
          "4176:     vim9_local = ASCII_ISUPPER(*start) && vim9script;",
          "",
          "[Added Lines]",
          "4178:     vim9_local = ASCII_ISUPPER(*start) && vim9script",
          "4179:       && (flags & TFN_IN_CLASS) == 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4211:   lead += (int)STRLEN(sid_buf);",
          "4212:  }",
          "4213:     }",
          "4216:     {",
          "4217:  semsg(_(vim9script ? e_function_name_must_start_with_capital_str",
          "4218:       : e_function_name_must_start_with_capital_or_s_str),",
          "",
          "[Removed Lines]",
          "4214:     else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)",
          "4215:        || (vim9script && *lv.ll_name == '_')))",
          "",
          "[Added Lines]",
          "4217:     else if (!(flags & TFN_INT)",
          "4218:      && (builtin_function(lv.ll_name, len)",
          "4219:        || (vim9script && *lv.ll_name == '_'))",
          "4220:      && !((flags & TFN_IN_CLASS) && STRNCMP(lv.ll_name, \"new\", 3) == 0))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4425:  exarg_T     *eap,",
          "4426:  char_u     *name_arg,",
          "4427:  garray_T    *lines_to_free,",
          "4429: {",
          "4430:     int  j;",
          "4431:     int  c;",
          "",
          "[Removed Lines]",
          "4428:  class_T     *class_arg)",
          "",
          "[Added Lines]",
          "4433:  int     in_class)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4541:  }",
          "4543:  int tfn_flags = TFN_NO_AUTOLOAD | TFN_NEW_FUNC",
          "4545:  name = save_function_name(&p, &is_global, eap->skip, tfn_flags, &fudi);",
          "4546:  paren = (vim_strchr(p, '(') != NULL);",
          "4547:  if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)",
          "",
          "[Removed Lines]",
          "4544:            | (class_arg == 0 ? 0 : TFN_INT);",
          "",
          "[Added Lines]",
          "4549:             | (in_class ? TFN_IN_CLASS : 0);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4743:     if (get_function_args(&p, ')', &newargs,",
          "4744:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
          "4745:     NULL, &varargs, &default_args, eap->skip,",
          "4747:  goto errret_2;",
          "4748:     whitep = p;",
          "",
          "[Removed Lines]",
          "4746:     eap, class_arg, &newlines, lines_to_free) == FAIL)",
          "",
          "[Added Lines]",
          "4751:     eap, in_class, &newlines, lines_to_free) == FAIL)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4864:     {",
          "4865:  hashtab_T *ht;",
          "4866:  char_u  *find_name = name;",
          "",
          "[Removed Lines]",
          "4863:     if (fudi.fd_dict == NULL)",
          "",
          "[Added Lines]",
          "4868:     if (fudi.fd_dict != NULL)",
          "4869:     {",
          "4870:  char numbuf[20];",
          "4872:  fp = NULL;",
          "4873:  if (fudi.fd_newkey == NULL && !eap->forceit)",
          "4874:  {",
          "4875:      emsg(_(e_dictionary_entry_already_exists));",
          "4876:      goto erret;",
          "4877:  }",
          "4878:  if (fudi.fd_di == NULL)",
          "4879:  {",
          "4881:      if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))",
          "4882:   goto erret;",
          "4883:  }",
          "4885:  else if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))",
          "4886:      goto erret;",
          "4890:  vim_free(name);",
          "4891:  sprintf(numbuf, \"%d\", ++func_nr);",
          "4892:  name = vim_strsave((char_u *)numbuf);",
          "4893:  if (name == NULL)",
          "4894:      goto erret;",
          "4895:     }",
          "4896:     else if (!in_class)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4967:      }",
          "4968:  }",
          "4969:     }",
          "4999:     if (fp == NULL)",
          "5000:     {",
          "",
          "[Removed Lines]",
          "4970:     else",
          "4971:     {",
          "4972:  char numbuf[20];",
          "4974:  fp = NULL;",
          "4975:  if (fudi.fd_newkey == NULL && !eap->forceit)",
          "4976:  {",
          "4977:      emsg(_(e_dictionary_entry_already_exists));",
          "4978:      goto erret;",
          "4979:  }",
          "4980:  if (fudi.fd_di == NULL)",
          "4981:  {",
          "4983:      if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))",
          "4984:   goto erret;",
          "4985:  }",
          "4987:  else if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))",
          "4988:      goto erret;",
          "4992:  vim_free(name);",
          "4993:  sprintf(numbuf, \"%d\", ++func_nr);",
          "4994:  name = vim_strsave((char_u *)numbuf);",
          "4995:  if (name == NULL)",
          "4996:      goto erret;",
          "4997:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "5113:      hi = hash_find(&func_hashtab, name);",
          "5114:      hi->hi_key = UF2HIKEY(fp);",
          "5115:  }",
          "5117:  {",
          "5118:      free_fp = TRUE;",
          "5119:      goto erret;",
          "",
          "[Removed Lines]",
          "5116:  else if (hash_add(&func_hashtab, UF2HIKEY(fp), \"add function\") == FAIL)",
          "",
          "[Added Lines]",
          "5121:  else if (!in_class && hash_add(&func_hashtab,",
          "5122:       UF2HIKEY(fp), \"add function\") == FAIL)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5198:     garray_T lines_to_free;",
          "5200:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "5202:     ga_clear_strings(&lines_to_free);",
          "5203: }",
          "",
          "[Removed Lines]",
          "5201:     (void)define_function(eap, NULL, &lines_to_free, NULL);",
          "",
          "[Added Lines]",
          "5207:     (void)define_function(eap, NULL, &lines_to_free, FALSE);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696: static int included_patches[] =",
          "699:     1040,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:     1041,",
          "",
          "---------------"
        ],
        "src/vim.h||src/vim.h": [
          "File: src/vim.h -> src/vim.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2676: #define TFN_NO_DECL 0x20 // only used for GLV_NO_DECL",
          "2677: #define TFN_COMPILING 0x40 // only used for GLV_COMPILING",
          "2678: #define TFN_NEW_FUNC 0x80 // defining a new function",
          "2682: #define GLV_QUIET TFN_QUIET // no error messages",
          "",
          "[Removed Lines]",
          "2679: #define TFN_ASSIGN_WITH_OP 0x100 // only for GLV_ASSIGN_WITH_OP",
          "",
          "[Added Lines]",
          "2679: #define TFN_ASSIGN_WITH_OP 0x100  // only for GLV_ASSIGN_WITH_OP",
          "2680: #define TFN_IN_CLASS 0x200 // function in a class",
          "",
          "---------------"
        ],
        "src/vim9.h||src/vim9.h": [
          "File: src/vim9.h -> src/vim9.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:     ISN_SOURCE,     // source autoload script, isn_arg.number is the script ID",
          "34:     ISN_INSTR,     // instructions compiled from expression",
          "35:     ISN_CONSTRUCT,  // construct an object, using contstruct_T",
          "38:     ISN_LOAD,     // push local variable isn_arg.number",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:     ISN_OBJ_MEMBER, // object member, index is isn_arg.number",
          "",
          "---------------"
        ],
        "src/vim9class.c||src/vim9class.c": [
          "File: src/vim9class.c -> src/vim9class.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:     garray_T objmethods;",
          "",
          "[Removed Lines]",
          "80:     ga_init2(&objmethods, sizeof(ufunc_T), 10);",
          "",
          "[Added Lines]",
          "80:     ga_init2(&objmethods, sizeof(ufunc_T *), 10);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:      ++objmembers.ga_len;",
          "173:  }",
          "175:  else",
          "176:  {",
          "177:      semsg(_(e_not_valid_command_in_class_str), line);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174:  else if (checkforcmd(&p, \"def\", 3))",
          "175:  {",
          "176:      exarg_T ea;",
          "177:      garray_T lines_to_free;",
          "179:      CLEAR_FIELD(ea);",
          "180:      ea.cmd = line;",
          "181:      ea.arg = p;",
          "182:      ea.cmdidx = CMD_def;",
          "183:      ea.getline = eap->getline;",
          "184:      ea.cookie = eap->cookie;",
          "186:      ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "187:      ufunc_T *uf = define_function(&ea, NULL, &lines_to_free, TRUE);",
          "188:      ga_clear_strings(&lines_to_free);",
          "191:      if (uf != NULL && ga_grow(&objmethods, 1) == OK)",
          "192:      {",
          "193:   ((ufunc_T **)objmethods.ga_data)[objmethods.ga_len] = uf;",
          "194:   ++objmethods.ga_len;",
          "195:      }",
          "196:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:  int have_new = FALSE;",
          "208:  for (int i = 0; i < objmethods.ga_len; ++i)",
          "210:            \"new\") == 0)",
          "211:      {",
          "212:   have_new = TRUE;",
          "",
          "[Removed Lines]",
          "209:      if (STRCMP((((ufunc_T *)objmethods.ga_data) + i)->uf_name,",
          "",
          "[Added Lines]",
          "232:      if (STRCMP(((ufunc_T **)objmethods.ga_data)[i]->uf_name,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "237:      garray_T lines_to_free;",
          "238:      ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "242:      ga_clear_strings(&lines_to_free);",
          "243:      vim_free(fga.ga_data);",
          "",
          "[Removed Lines]",
          "240:      ufunc_T *nf = define_function(&fea, NULL, &lines_to_free, cl);",
          "",
          "[Added Lines]",
          "263:      ufunc_T *nf = define_function(&fea, NULL, &lines_to_free, TRUE);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "248:   ++objmethods.ga_len;",
          "250:   nf->uf_flags |= FC_NEW;",
          "252:   nf->uf_ret_type = get_type_ptr(&type_list);",
          "253:   if (nf->uf_ret_type != NULL)",
          "254:   {",
          "",
          "[Removed Lines]",
          "251:   nf->uf_class = cl;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "257:       nf->uf_ret_type->tt_argcount = 0;",
          "258:       nf->uf_ret_type->tt_args = NULL;",
          "259:   }",
          "261:      }",
          "262:  }",
          "",
          "[Removed Lines]",
          "260:   cl->class_new_func = nf;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "275:      sizeof(ufunc_T *) * objmethods.ga_len);",
          "276:  vim_free(objmethods.ga_data);",
          "278:  cl->class_type.tt_type = VAR_CLASS;",
          "279:  cl->class_type.tt_member = (type_T *)cl;",
          "280:  cl->class_type_list = type_list;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "300:  for (int i = 0; i < objmethods.ga_len; ++i)",
          "301:  {",
          "302:      ufunc_T *fp = cl->class_obj_methods[i];",
          "303:      fp->uf_class = cl;",
          "304:      fp->uf_flags |= FC_OBJECT;  // TODO: not for class method",
          "305:  }",
          "309:  cl->class_object_type.tt_type = VAR_OBJECT;",
          "310:  cl->class_object_type.tt_member = (type_T *)cl;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "305:     }",
          "306:     ga_clear(&objmembers);",
          "308:     ga_clear(&objmethods);",
          "309:     clear_type_list(&type_list);",
          "310: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "339:     for (int i = 0; i < objmethods.ga_len; ++i)",
          "340:     {",
          "341:  ufunc_T *uf = ((ufunc_T **)objmethods.ga_data)[i];",
          "342:  func_clear_free(uf, FALSE);",
          "343:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "419:   funcexe_T   funcexe;",
          "420:   CLEAR_FIELD(funcexe);",
          "421:   funcexe.fe_evaluate = TRUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "458:   if (rettv->v_type == VAR_OBJECT)",
          "459:   {",
          "460:       funcexe.fe_object = rettv->vval.v_object;",
          "461:       ++funcexe.fe_object->obj_refcount;",
          "462:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "545:  }",
          "546:  vim_free(cl->class_obj_members);",
          "548:  vim_free(cl->class_obj_methods);",
          "553:  clear_type_list(&cl->class_type_list);",
          "555:  vim_free(cl);",
          "",
          "[Removed Lines]",
          "550:  if (cl->class_new_func != NULL)",
          "551:      func_ptr_unref(cl->class_new_func);",
          "",
          "[Added Lines]",
          "588:  for (int i = 0; i < cl->class_obj_method_count; ++i)",
          "589:  {",
          "590:      ufunc_T *uf = cl->class_obj_methods[i];",
          "591:      func_clear_free(uf, FALSE);",
          "592:  }",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:      CLEAR_POINTER(lvar);",
          "53:      lvar->lv_name = (char_u *)\"this\";",
          "54:      if (cctx->ctx_ufunc->uf_class != NULL)",
          "56:  }",
          "57:  return OK;",
          "58:     }",
          "",
          "[Removed Lines]",
          "55:   lvar->lv_type = &cctx->ctx_ufunc->uf_class->class_type;",
          "",
          "[Added Lines]",
          "55:   lvar->lv_type = &cctx->ctx_ufunc->uf_class->class_object_type;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "975:  goto theend;",
          "976:     }",
          "979:     if (ufunc == NULL)",
          "980:     {",
          "981:  r = eap->skip ? OK : FAIL;",
          "",
          "[Removed Lines]",
          "978:     ufunc = define_function(eap, lambda_name, lines_to_free, NULL);",
          "",
          "[Added Lines]",
          "978:     ufunc = define_function(eap, lambda_name, lines_to_free, FALSE);",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4225:       CLEAR_FIELD(ea);",
          "4226:       ea.cmd = ea.arg = iptr->isn_arg.string;",
          "4227:       ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "4229:       ga_clear_strings(&lines_to_free);",
          "4230:   }",
          "4231:   break;",
          "",
          "[Removed Lines]",
          "4228:       define_function(&ea, NULL, &lines_to_free, NULL);",
          "",
          "[Added Lines]",
          "4228:       define_function(&ea, NULL, &lines_to_free, FALSE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5114:   }",
          "5115:   break;",
          "5117:      case ISN_CLEARDICT:",
          "5118:   dict_stack_drop();",
          "5119:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5117:      case ISN_OBJ_MEMBER:",
          "5118:   {",
          "5119:       tv = STACK_TV_BOT(-1);",
          "5120:       if (tv->v_type != VAR_OBJECT)",
          "5121:       {",
          "5122:    SOURCING_LNUM = iptr->isn_lnum;",
          "5123:    garray_T type_list;",
          "5124:    ga_init2(&type_list, sizeof(type_T *), 10);",
          "5125:    type_T *type = typval2type(tv, get_copyID(),",
          "5126:          &type_list, TVTT_DO_MEMBER);",
          "5127:    char *tofree = NULL;",
          "5128:    char *typename = type_name(type, &tofree);",
          "5129:    semsg(_(e_object_required_found_str), typename);",
          "5130:    vim_free(tofree);",
          "5131:    clear_type_list(&type_list);",
          "5132:    goto on_error;",
          "5133:       }",
          "5134:       int idx = iptr->isn_arg.number;",
          "5135:       object_T *obj = tv->vval.v_object;",
          "5137:       typval_T *mtv = ((typval_T *)(obj + 1)) + idx;",
          "5142:       object_unref(obj);",
          "5143:   }",
          "5144:   break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5577:     typval_T *argv,  // arguments",
          "5578:     int  flags,  // DEF_ flags",
          "5579:     partial_T *partial, // optional partial for context",
          "5580:     funccall_T *funccal,",
          "5581:     typval_T *rettv)  // return value",
          "5582: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5609:     object_T *object, // object, e.g. for this.Func()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5818:      STACK_TV_VAR(idx)->vval.v_number = 0;",
          "5819:  }",
          "5820:  ectx.ec_stack.ga_len += dfunc->df_varcount;",
          "5821:  if (dfunc->df_has_closure)",
          "5822:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5852:  if (object != NULL)",
          "5853:  {",
          "5855:      tv = STACK_TV_VAR(0);",
          "5856:      tv->v_type = VAR_OBJECT;",
          "5857:      tv->vval.v_object = object;",
          "5858:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6766:      case ISN_MEMBER: smsg(\"%s%4d MEMBER\", pfx, current); break;",
          "6767:      case ISN_STRINGMEMBER: smsg(\"%s%4d MEMBER %s\", pfx, current,",
          "6768:         iptr->isn_arg.string); break;",
          "6769:      case ISN_CLEARDICT: smsg(\"%s%4d CLEARDICT\", pfx, current); break;",
          "6770:      case ISN_USEDICT: smsg(\"%s%4d USEDICT\", pfx, current); break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6808:      case ISN_OBJ_MEMBER: smsg(\"%s%4d OBJ_MEMBER %d\", pfx, current,",
          "6809:           (int)iptr->isn_arg.number); break;",
          "",
          "---------------"
        ],
        "src/vim9expr.c||src/vim9expr.c": [
          "File: src/vim9expr.c -> src/vim9expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "250:     return OK;",
          "251: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "257:     static int",
          "258: compile_class_object_index(cctx_T *cctx, char_u **arg, type_T *type)",
          "259: {",
          "260:     if (VIM_ISWHITE((*arg)[1]))",
          "261:     {",
          "262:  semsg(_(e_no_white_space_allowed_after_str_str), \".\", *arg);",
          "263:  return FAIL;",
          "264:     }",
          "266:     ++*arg;",
          "267:     char_u *name = *arg;",
          "268:     char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);",
          "269:     if (name_end == name)",
          "270:  return FAIL;",
          "271:     size_t len = name_end - name;",
          "273:     class_T *cl = (class_T *)type->tt_member;",
          "274:     if (*name_end == '(')",
          "275:     {",
          "277:     }",
          "278:     else if (type->tt_type == VAR_OBJECT)",
          "279:     {",
          "280:  for (int i = 0; i < cl->class_obj_member_count; ++i)",
          "281:  {",
          "282:      objmember_T *m = &cl->class_obj_members[i];",
          "283:      if (STRNCMP(name, m->om_name, len) == 0 && m->om_name[len] == NUL)",
          "284:      {",
          "285:   generate_OBJ_MEMBER(cctx, i, m->om_type);",
          "288:   return OK;",
          "289:      }",
          "290:  }",
          "292:  semsg(_(e_member_not_found_on_object_str_str), cl->class_name, name);",
          "293:     }",
          "294:     else",
          "295:     {",
          "297:  emsg(\"compile_class_object_index(): not handled\");",
          "298:     }",
          "300:     return FAIL;",
          "301: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1797:     for (;;)",
          "1798:     {",
          "1799:  char_u *p = skipwhite(*arg);",
          "1801:  if (*p == NUL || (VIM_ISWHITE(**arg) && vim9_comment_start(p)))",
          "1802:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1850:  type_T *type;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1825:  if (**arg == '(')",
          "1826:  {",
          "1828:      int  argcount = 0;",
          "1830:      if (generate_ppconst(cctx, ppconst) == FAIL)",
          "",
          "[Removed Lines]",
          "1827:      type_T *type;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1911:   int     argcount = 1;",
          "1912:   garray_T    *stack = &cctx->ctx_type_stack;",
          "1913:   int     type_idx_start = stack->ga_len;",
          "1915:   int     expr_isn_start = cctx->ctx_instr.ga_len;",
          "1916:   int     expr_isn_end;",
          "1917:   int     arg_isn_count;",
          "",
          "[Removed Lines]",
          "1914:   type_T     *type;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2097:      if (compile_member(is_slice, &keeping_dict, cctx) == FAIL)",
          "2098:   return FAIL;",
          "2099:  }",
          "2100:  else if (*p == '.' && p[1] != '.')",
          "2101:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2149:  else if (*p == '.'",
          "2150:   && (type = get_type_on_stack(cctx, 0)) != &t_unknown",
          "2151:   && (type->tt_type == VAR_CLASS || type->tt_type == VAR_OBJECT))",
          "2152:  {",
          "2158:      if (compile_class_object_index(cctx, arg, type) == FAIL)",
          "2159:   return FAIL;",
          "2160:  }",
          "",
          "---------------"
        ],
        "src/vim9instr.c||src/vim9instr.c": [
          "File: src/vim9instr.c -> src/vim9instr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:     return OK;",
          "132: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137:     int",
          "138: generate_OBJ_MEMBER(cctx_T *cctx, int idx, type_T *type)",
          "139: {",
          "140:     RETURN_OK_IF_SKIP(cctx);",
          "143:     isn_T *isn = generate_instr_drop(cctx, ISN_OBJ_MEMBER, 1);",
          "144:     if (isn == NULL)",
          "145:  return FAIL;",
          "147:     isn->isn_arg.number = idx;",
          "148:     return push_type_stack2(cctx, type, &t_any);",
          "149: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2460:  case ISN_NEWDICT:",
          "2461:  case ISN_NEWLIST:",
          "2462:  case ISN_NEWPARTIAL:",
          "2463:  case ISN_OPANY:",
          "2464:  case ISN_OPFLOAT:",
          "2465:  case ISN_OPNR:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2480:  case ISN_OBJ_MEMBER:",
          "",
          "---------------"
        ],
        "src/vim9type.c||src/vim9type.c": [
          "File: src/vim9type.c -> src/vim9type.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1585:     if (tofree != NULL)",
          "1586:  rettv->vval.v_string = (char_u *)tofree;",
          "1587:     else",
          "1589:  rettv->vval.v_string = vim_strsave((char_u *)name);",
          "1592:     clear_type_list(&type_list);",
          "1593: }",
          "",
          "[Removed Lines]",
          "1588:     {",
          "1590:  vim_free(tofree);",
          "1591:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cef1270dec61efb3544f26ceea0f6a4f57e0198a",
      "candidate_info": {
        "commit_hash": "cef1270dec61efb3544f26ceea0f6a4f57e0198a",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/cef1270dec61efb3544f26ceea0f6a4f57e0198a",
        "files": [
          "src/proto/userfunc.pro",
          "src/testdir/test_vim9_func.vim",
          "src/userfunc.c",
          "src/version.c"
        ],
        "message": "patch 8.2.2298: Vim9: comment right after \"(\" of function not recognized\n\nProblem:    Vim9: comment right after \"(\" of function not recognized.\nSolution:   Do not skip over white space before calling get_function_args().\n            (closes #7613)",
        "before_after_code_files": [
          "src/proto/userfunc.pro||src/proto/userfunc.pro",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/proto/userfunc.pro||src/proto/userfunc.pro": [
          "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: void func_init(void);",
          "3: hashtab_T *func_tbl_get(void);",
          "5: char_u *get_lambda_name(void);",
          "6: char_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state);",
          "7: int get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);",
          "",
          "[Removed Lines]",
          "4: int get_function_args(char_u **argp, char_u endchar, garray_T *newargs, garray_T *argtypes, int types_optional, int *varargs, garray_T *default_args, int skip, exarg_T *eap, char_u **line_to_free);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:   delfunc g:Func",
          "242: enddef",
          "244: def Test_nested_function()",
          "245:   def Nested(arg: string): string",
          "246:     return 'nested ' .. arg",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "244: def FuncWithComment(  # comment",
          "245:   a: number, #comment",
          "246:   b: bool, # comment",
          "247:   c: string) #comment",
          "248:   assert_equal(4, a)",
          "249:   assert_equal(true, b)",
          "250:   assert_equal('yes', c)",
          "251: enddef",
          "253: def Test_func_with_comments()",
          "254:   FuncWithComment(4, true, 'yes')",
          "256:   var lines =<< trim END",
          "257:       def Func(# comment",
          "258:         arg: string)",
          "259:       enddef",
          "260:   END",
          "261:   CheckScriptFailure(lines, 'E125:', 1)",
          "263:   lines =<< trim END",
          "264:       def Func(",
          "265:         arg: string# comment",
          "266:         )",
          "267:       enddef",
          "268:   END",
          "269:   CheckScriptFailure(lines, 'E475:', 2)",
          "271:   lines =<< trim END",
          "272:       def Func(",
          "273:         arg: string",
          "274:         )# comment",
          "275:       enddef",
          "276:   END",
          "277:   CheckScriptFailure(lines, 'E488:', 3)",
          "278: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "160: get_function_args(",
          "161:     char_u **argp,",
          "162:     char_u endchar,",
          "",
          "[Removed Lines]",
          "159:     int",
          "",
          "[Added Lines]",
          "160:     static int",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170:     char_u **line_to_free)",
          "171: {",
          "172:     int  mustend = FALSE;",
          "175:     int  c;",
          "176:     int  any_default = FALSE;",
          "177:     char_u *expr;",
          "180:     if (newargs != NULL)",
          "181:  ga_init2(newargs, (int)sizeof(char_u *), 3);",
          "",
          "[Removed Lines]",
          "173:     char_u *arg = *argp;",
          "174:     char_u *p = arg;",
          "178:     char_u *whitep = arg;",
          "",
          "[Added Lines]",
          "174:     char_u *arg;",
          "175:     char_u *p;",
          "179:     char_u *whitep = *argp;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "193:     while (*p != endchar)",
          "194:     {",
          "195:  while (eap != NULL && eap->getline != NULL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:     arg = skipwhite(*argp);",
          "195:     p = arg;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "552:     ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,",
          "553:      types_optional ? &argtypes : NULL, types_optional,",
          "554:        NULL, NULL, TRUE, NULL, NULL);",
          "",
          "[Removed Lines]",
          "551:     s = skipwhite(*arg + 1);",
          "",
          "[Added Lines]",
          "554:     s = *arg + 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2964:     int  is_global = FALSE;",
          "2965:     char_u *p;",
          "2966:     char_u *arg;",
          "2967:     char_u *line_arg = NULL;",
          "2968:     garray_T newargs;",
          "2969:     garray_T argtypes;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2970:     char_u *whitep;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3159:  if (vim_strchr(p, '(') != NULL)",
          "3160:      p = vim_strchr(p, '(');",
          "3161:     }",
          "3165:     if (vim9script && eap->forceit && !is_global)",
          "",
          "[Removed Lines]",
          "3162:     p = skipwhite(p + 1);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3202:     if (get_function_args(&p, ')', &newargs,",
          "3203:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
          "3204:     &varargs, &default_args, eap->skip,",
          "3205:     eap, &line_to_free) == FAIL)",
          "3206:  goto errret_2;",
          "3208:     if (eap->cmdidx == CMD_def)",
          "3209:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3205:     ++p;",
          "3211:     whitep = p;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3215:      if (p > ret_type)",
          "3216:      {",
          "3217:   ret_type = vim_strnsave(ret_type, p - ret_type);",
          "3218:   p = skipwhite(p);",
          "3219:      }",
          "3220:      else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3223:   whitep = p;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3230:  for (;;)",
          "3231:  {",
          "3232:      p = skipwhite(p);",
          "3233:      if (STRNCMP(p, \"range\", 5) == 0)",
          "3234:      {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3238:      whitep = p;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3267:     else if (*p != NUL",
          "3268:      && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)",
          "3269:            && eap->cmdidx != CMD_def)",
          "3271:      && !eap->skip",
          "3272:      && !did_emsg)",
          "3273:  semsg(_(e_trailing_arg), p);",
          "",
          "[Removed Lines]",
          "3270:      && !(*p == '#' && (vim9script || eap->cmdidx == CMD_def))",
          "",
          "[Added Lines]",
          "3277:      && !(VIM_ISWHITE(*whitep) && *p == '#'",
          "3278:          && (vim9script || eap->cmdidx == CMD_def))",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2297,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2298,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "143367256836b0f69881dc0c65ff165ae091dbc5",
      "candidate_info": {
        "commit_hash": "143367256836b0f69881dc0c65ff165ae091dbc5",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/143367256836b0f69881dc0c65ff165ae091dbc5",
        "files": [
          "src/version.c",
          "src/vim9execute.c"
        ],
        "message": "patch 8.2.4042: Vim9: build error\n\nProblem:    Vim9: build error.\nSolution:   Use grow array instead of character pointer.",
        "before_after_code_files": [
          "src/version.c||src/version.c",
          "src/vim9execute.c||src/vim9execute.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/version.c||src/version.c",
            "src/vim9execute.c||src/vim9execute.c"
          ],
          "candidate": [
            "src/version.c||src/version.c",
            "src/vim9execute.c||src/vim9execute.c"
          ]
        }
      },
      "candidate_diff": {
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     4041,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     4042,",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3344:       list_functions(NULL);",
          "3345:   else",
          "3346:   {",
          "3350:       CLEAR_FIELD(ea);",
          "3351:       ea.cmd = ea.arg = iptr->isn_arg.string;",
          "3354:   }",
          "3355:   break;",
          "",
          "[Removed Lines]",
          "3347:       exarg_T ea;",
          "3348:       char_u  *line_to_free = NULL;",
          "3352:       define_function(&ea, NULL, &line_to_free);",
          "3353:       vim_free(line_to_free);",
          "",
          "[Added Lines]",
          "3347:       exarg_T ea;",
          "3348:       garray_T lines_to_free;",
          "3352:       ga_init2(&lines_to_free, sizeof(char_u *), 50);",
          "3353:       define_function(&ea, NULL, &lines_to_free);",
          "3354:       ga_clear_strings(&lines_to_free);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
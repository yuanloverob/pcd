{
  "cve_id": "CVE-2019-19924",
  "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
  "repo": "sqlite/sqlite",
  "patch_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
  "patch_info": {
    "commit_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/vdbeaux.c",
      "src/window.c"
    ],
    "message": "When an error occurs while rewriting the parser tree for window functions in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/vdbeaux.c||src/vdbeaux.c",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "376:   int addr;",
      "377:   CollSeq *p4;",
      "379:   if( isCommuted ){",
      "380:     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);",
      "381:   }else{",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:   if( pParse->nErr ) return 0;",
      "",
      "---------------"
    ],
    "src/vdbeaux.c||src/vdbeaux.c": [
      "File: src/vdbeaux.c -> src/vdbeaux.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1304: static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){",
      "1305:   assert( p->nOp>0 || p->aOp==0 );",
      "1307:   if( p->nOp ){",
      "1308:     assert( p->aOp );",
      "1309:     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
      "",
      "[Removed Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );",
      "",
      "[Added Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
      "1307:           || p->pParse->nErr>0 );",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "935:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
      "936:     if( pTab==0 ){",
      "938:     }",
      "940:     p->pSrc = 0;",
      "",
      "[Removed Lines]",
      "937:       return SQLITE_NOMEM;",
      "",
      "[Added Lines]",
      "937:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1039:     sqlite3DbFree(db, pTab);",
      "1040:   }",
      "1042:   return rc;",
      "1043: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1042:   if( rc && pParse->nErr==0 ){",
      "1043:     assert( pParse->db->mallocFailed );",
      "1044:     return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
      "1045:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0f55a571fcd028d57fcde0d25150aa3a933b2d8d",
      "candidate_info": {
        "commit_hash": "0f55a571fcd028d57fcde0d25150aa3a933b2d8d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/0f55a571fcd028d57fcde0d25150aa3a933b2d8d",
        "files": [
          "ext/fts5/fts5_index.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Avoid an \"unitialized value read\" problem in fts5 that can occur with a corrupt database.\n\nFossilOrigin-Name: 6cae81cd1ffb0180e0260d5ba921502c7dee2f54637bff3558a4d1cb5dfd3f32",
        "before_after_code_files": [
          "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c": [
          "File: ext/fts5/fts5_index.c -> ext/fts5/fts5_index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "690:         pRet = 0;",
          "691:       }else{",
          "694:         pRet->p[nByte] = 0x00;",
          "695:       }",
          "696:     }",
          "697:     p->rc = rc;",
          "",
          "[Removed Lines]",
          "693:         pRet->szLeaf = fts5GetU16(&pRet->p[2]);",
          "",
          "[Added Lines]",
          "694:         pRet->szLeaf = fts5GetU16(&pRet->p[2]);",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9bad745d373f4686a2726c3f77a2ccad60e7181645d7ed483a2e43075a4ef30c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1116b1785c018911c33c4148aee1987810b5670b",
      "candidate_info": {
        "commit_hash": "1116b1785c018911c33c4148aee1987810b5670b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1116b1785c018911c33c4148aee1987810b5670b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/os_unix.c"
        ],
        "message": "In the unix VFS layer, do not attempt to chown() the journal to be the same as the database if running in 8+3 filename mode.  Also, update the comments on the chown() attempt to be more precise.\n\nFossilOrigin-Name: ab853724a7e01ca32167d294c3c80d6632e805bdf39b6d56db82226a00ad72dc",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/os_unix.c||src/os_unix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 489a1eb3aa2f1225b97b50a5f8688cf1a4ab0371973da1badc29616d70386c03",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/os_unix.c||src/os_unix.c": [
          "File: src/os_unix.c -> src/os_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6059:       goto open_finished;",
          "6060:     }",
          "6067:       robustFchown(fd, uid, gid);",
          "6068:     }",
          "6069:   }",
          "",
          "[Removed Lines]",
          "6066:     if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){",
          "",
          "[Added Lines]",
          "6074:     if( openFlags && (flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL))!=0 ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b6a9121bb383f37c78b8d8d99e6f1d8dd3b6b4e3",
      "candidate_info": {
        "commit_hash": "b6a9121bb383f37c78b8d8d99e6f1d8dd3b6b4e3",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b6a9121bb383f37c78b8d8d99e6f1d8dd3b6b4e3",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "test/join.test"
        ],
        "message": "Fix another case where SQLite assumes that if \"~(? AND FALSE)\" is true, \"?\" must be non-null.\n\nFossilOrigin-Name: 616f5663b3dbd0929128c0990fc6d8bba1513c7ae196b87c450ac0b3b3203ecd",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "test/join.test||test/join.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 84ae41fd2f50cb7c0c3f6522d0f94817e1bbf96eae5316279e3e32cee4e46e91",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5103:   switch( pExpr->op ){",
          "5104:     case TK_ISNOT:",
          "5105:     case TK_NOT:",
          "5106:     case TK_ISNULL:",
          "5107:     case TK_NOTNULL:",
          "5108:     case TK_IS:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5106:     case TK_BITNOT:",
          "",
          "---------------"
        ],
        "test/join.test||test/join.test": [
          "File: test/join.test -> test/join.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "812:     FROM t1 LEFT JOIN t2",
          "813:    WHERE a IN (1,3,x,y);",
          "814: } {1 2 {} {} x 3 4 {} {} x}",
          "816:   SELECT *, 'x'",
          "817:     FROM t1 LEFT JOIN t2",
          "818:    WHERE NOT ( 'x'='y' AND t2.y=1 );",
          "819: } {1 2 {} {} x 3 4 {} {} x}",
          "820: do_execsql_test join-15.107 {",
          "821:   SELECT *, 'x'",
          "822:     FROM t1 LEFT JOIN t2",
          "",
          "[Removed Lines]",
          "815: do_execsql_test join-15.106 {",
          "",
          "[Added Lines]",
          "815: do_execsql_test join-15.106a {",
          "820: do_execsql_test join-15.106b {",
          "821:   SELECT *, 'x'",
          "822:     FROM t1 LEFT JOIN t2",
          "823:    WHERE ~ ( 'x'='y' AND t2.y=1 );",
          "824: } {1 2 {} {} x 3 4 {} {} x}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b84b38fd899ec1e104c2937bfb4ed54ae08e792f",
      "candidate_info": {
        "commit_hash": "b84b38fd899ec1e104c2937bfb4ed54ae08e792f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b84b38fd899ec1e104c2937bfb4ed54ae08e792f",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/autoinc.test",
          "test/delete4.test",
          "test/insert4.test",
          "test/pragma.test",
          "test/triggerC.test",
          "test/without_rowid1.test"
        ],
        "message": "Add test cases to improve coverage of VDBE branches. Still some to go.\n\nFossilOrigin-Name: 4cef609d61de272cfdc2b39e1d49c7cd56ec834086bd63095116ff98f4d402bd",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/autoinc.test||test/autoinc.test",
          "test/delete4.test||test/delete4.test",
          "test/insert4.test||test/insert4.test",
          "test/pragma.test||test/pragma.test",
          "test/triggerC.test||test/triggerC.test",
          "test/without_rowid1.test||test/without_rowid1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4fca46ded7873d4939d7c6bff363ded41667f2255a4ab624a1a24bebbae733eb",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/autoinc.test||test/autoinc.test": [
          "File: test/autoinc.test -> test/autoinc.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: set testdir [file dirname $argv0]",
          "18: source $testdir/tester.tcl",
          "20: # If the library is not compiled with autoincrement support then",
          "21: # skip all tests in this file.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: set testprefix autoinc",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "856:   lappend res $msg",
          "857: } {0 ok}",
          "859: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "860: #--------------------------------------------------------------------------",
          "861: reset_db",
          "862: do_execsql_test 13.0 {",
          "863:   CREATE TABLE t1(i INTEGER PRIMARY KEY AUTOINCREMENT, j);",
          "864:   CREATE TABLE t2(i INTEGER PRIMARY KEY AUTOINCREMENT, j);",
          "865:   CREATE TABLE t3(i INTEGER PRIMARY KEY AUTOINCREMENT, j);",
          "867:   INSERT INTO t1 VALUES(NULL, 1);",
          "868:   INSERT INTO t2 VALUES(NULL, 2);",
          "869:   INSERT INTO t3 VALUES(NULL, 3);",
          "871:   SELECT name FROM sqlite_sequence;",
          "872: } {t1 t2 t3}",
          "874: do_execsql_test 13.1 {",
          "875:   UPDATE sqlite_sequence SET name=NULL WHERE name='t2';",
          "876:   INSERT INTO t3 VALUES(NULL, 4);",
          "877:   DELETE FROM t3;",
          "878:   INSERT INTO t3 VALUES(NULL, 5);",
          "879:   SELECT * FROM t3;",
          "880: } {3 5}",
          "",
          "---------------"
        ],
        "test/delete4.test||test/delete4.test": [
          "File: test/delete4.test -> test/delete4.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:   SELECT x FROM t2;",
          "184: } {5}",
          "187: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: #-------------------------------------------------------------------------",
          "187: # Test the effect of failing to find a table row based on an index key",
          "188: # within a DELETE. Either because the db is corrupt, or a trigger on another",
          "189: # row already deleted the entry, or because a BEFORE trigger on the current",
          "190: # row has already deleted it.",
          "191: #",
          "192: do_execsql_test 7.1.0 {",
          "193:   CREATE TABLE t3(id INT PRIMARY KEY, a, b) WITHOUT ROWID;",
          "194:   CREATE INDEX t3a ON t3(a);",
          "195:   CREATE INDEX t3b ON t3(b);",
          "197:   INSERT INTO t3 VALUES(1, 1, 1);",
          "198:   INSERT INTO t3 VALUES(2, 2, 2);",
          "199:   INSERT INTO t3 VALUES(3, 3, 3);",
          "200:   INSERT INTO t3 VALUES(4, 4, 1);",
          "201: }",
          "202: do_execsql_test 7.1.1 {",
          "203:   DELETE FROM t3 WHERE a=4 OR b=1;",
          "204: }",
          "205: do_execsql_test 7.1.2 {",
          "206:   SELECT * FROM t3;",
          "207: } { 2 2 2   3 3 3 }",
          "209: do_execsql_test 7.2.0 {",
          "210:   CREATE TABLE t4(a PRIMARY KEY, b) WITHOUT ROWID;",
          "211:   CREATE INDEX t4i ON t4(b);",
          "212:   INSERT INTO t4 VALUES(1, 'hello');",
          "213:   INSERT INTO t4 VALUES(2, 'world');",
          "215:   CREATE TABLE t5(a PRIMARY KEY, b) WITHOUT ROWID;",
          "216:   CREATE INDEX t5i ON t5(b);",
          "217:   INSERT INTO t5 VALUES(1, 'hello');",
          "218:   INSERT INTO t5 VALUES(3, 'world');",
          "220:   PRAGMA writable_schema = 1;",
          "221:   UPDATE sqlite_master SET rootpage = (",
          "222:     SELECT rootpage FROM sqlite_master WHERE name = 't5'",
          "223:   ) WHERE name = 't4';",
          "224: }",
          "226: db close",
          "227: sqlite3 db test.db",
          "228: do_execsql_test 7.2.1 {",
          "229:   DELETE FROM t4 WHERE b='world'",
          "230: }",
          "231: reset_db",
          "233: do_execsql_test 7.3.0 {",
          "234:   CREATE TABLE t3(id INT PRIMARY KEY, a, b) WITHOUT ROWID;",
          "235:   INSERT INTO t3 VALUES(1, 2, 3);",
          "236:   INSERT INTO t3 VALUES(4, 5, 6);",
          "237:   INSERT INTO t3 VALUES(7, 8, 9);",
          "238:   CREATE TRIGGER t3t BEFORE DELETE ON t3 BEGIN",
          "239:     DELETE FROM t3 WHERE id=old.id+3;",
          "240:   END;",
          "241: }",
          "243: do_execsql_test 7.3.1 {",
          "244:   DELETE FROM t3 WHERE a IN(2, 5, 8);",
          "245:   SELECT * FROM t3;",
          "246: } {}",
          "248: do_execsql_test 7.3.2 {",
          "249:   DROP TRIGGER t3t;",
          "250:   INSERT INTO t3 VALUES(1, 2, 3);",
          "251:   INSERT INTO t3 VALUES(4, 5, 6);",
          "252:   INSERT INTO t3 VALUES(7, 8, 9);",
          "253:   CREATE TRIGGER t3t BEFORE DELETE ON t3 BEGIN",
          "254:     DELETE FROM t3 WHERE id=old.id;",
          "255:   END;",
          "256: }",
          "258: do_execsql_test 7.3.3 {",
          "259:   DELETE FROM t3 WHERE a IN(2, 5, 8);",
          "260:   SELECT * FROM t3;",
          "261: } {}",
          "",
          "---------------"
        ],
        "test/insert4.test||test/insert4.test": [
          "File: test/insert4.test -> test/insert4.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "598:   set sqlite3_xferopt_count",
          "599: } {1}",
          "602: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "601: #-------------------------------------------------------------------------",
          "602: # xfer transfer between tables where the source has an empty partial index.",
          "603: #",
          "604: do_execsql_test 11.0 {",
          "605:   CREATE TABLE t9(a, b, c);",
          "606:   CREATE INDEX t9a ON t9(a);",
          "607:   CREATE INDEX t9b ON t9(b) WHERE c=0;",
          "609:   INSERT INTO t9 VALUES(1, 1, 1);",
          "610:   INSERT INTO t9 VALUES(2, 2, 2);",
          "611:   INSERT INTO t9 VALUES(3, 3, 3);",
          "613:   CREATE TABLE t10(a, b, c);",
          "614:   CREATE INDEX t10a ON t10(a);",
          "615:   CREATE INDEX t10b ON t10(b) WHERE c=0;",
          "617:   INSERT INTO t10 SELECT * FROM t9;",
          "618:   SELECT * FROM t10;",
          "619:   PRAGMA integrity_check;",
          "620: } {1 1 1  2 2 2  3 3 3  ok}",
          "",
          "---------------"
        ],
        "test/pragma.test||test/pragma.test": [
          "File: test/pragma.test -> test/pragma.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "251:     PRAGMA synchronous;",
          "252:   }",
          "253: } {2}",
          "254: } ;# ifcapable pager_pragmas",
          "256: # Test turning \"flag\" pragmas on and off.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "255: do_execsql_test 1.15.1 {",
          "256:   PRAGMA default_cache_size = 0;",
          "257: }",
          "258: do_execsql_test 1.15.2 {",
          "259:   PRAGMA default_cache_size;",
          "260: } $DFLT_CACHE_SZ",
          "261: do_execsql_test 1.15.3 {",
          "262:   PRAGMA default_cache_size = -500;",
          "263: }",
          "264: do_execsql_test 1.15.4 {",
          "265:   PRAGMA default_cache_size;",
          "266: } 500",
          "267: do_execsql_test 1.15.3 {",
          "268:   PRAGMA default_cache_size = 500;",
          "269: }",
          "270: do_execsql_test 1.15.4 {",
          "271:   PRAGMA default_cache_size;",
          "272: } 500",
          "273: db close",
          "274: hexio_write test.db 48 FFFFFF00",
          "275: sqlite3 db test.db",
          "276: do_execsql_test 1.15.4 {",
          "277:   PRAGMA default_cache_size;",
          "278: } 256",
          "",
          "---------------"
        ],
        "test/triggerC.test||test/triggerC.test": [
          "File: test/triggerC.test -> test/triggerC.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1057:   HAVING raise(ABORT, 'msg');",
          "1058: } {1 {RAISE() may only be used within a trigger-program}}",
          "1060: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1060: #-------------------------------------------------------------------------",
          "1061: # Datatype mismatch on IPK when there are BEFORE triggers.",
          "1062: #",
          "1063: do_execsql_test 17.0 {",
          "1064:   CREATE TABLE xyz(x INTEGER PRIMARY KEY, y, z);",
          "1065:   CREATE TRIGGER xyz_tr BEFORE INSERT ON xyz BEGIN",
          "1066:     SELECT new.x;",
          "1067:   END;",
          "1068: }",
          "1069: do_catchsql_test 17.1 {",
          "1070:   INSERT INTO xyz VALUES('hello', 2, 3);",
          "1071: } {1 {datatype mismatch}}",
          "",
          "---------------"
        ],
        "test/without_rowid1.test||test/without_rowid1.test": [
          "File: test/without_rowid1.test -> test/without_rowid1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "355:   DELETE FROM t2 WHERE b=1",
          "356: }",
          "359: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "358: #-------------------------------------------------------------------------",
          "359: # UNIQUE constraint violation in an UPDATE with a multi-column PK.",
          "360: #",
          "361: reset_db",
          "362: do_execsql_test 10.0 {",
          "363:   CREATE TABLE t1(a, b, c UNIQUE, PRIMARY KEY(a, b)) WITHOUT ROWID;",
          "364:   INSERT INTO t1 VALUES('a', 'a', 1);",
          "365:   INSERT INTO t1 VALUES('a', 'b', 2);",
          "366:   INSERT INTO t1 VALUES('b', 'a', 3);",
          "367:   INSERT INTO t1 VALUES('b', 'b', 4);",
          "368: }",
          "370: do_catchsql_test 10.1 {",
          "371:   UPDATE t1 SET c=1 WHERE (a, b) = ('a', 'a');",
          "372: } {0 {}}",
          "373: do_catchsql_test 10.2 {",
          "374:   UPDATE t1 SET c=1 WHERE (a, b) = ('a', 'b');",
          "375: } {1 {UNIQUE constraint failed: t1.c}}",
          "376: do_catchsql_test 10.3 {",
          "377:   UPDATE t1 SET c=1 WHERE (a, b) = ('b', 'a');",
          "378: } {1 {UNIQUE constraint failed: t1.c}}",
          "379: do_catchsql_test 10.4 {",
          "380:   UPDATE t1 SET c=1 WHERE (a, b) = ('b', 'b');",
          "381: } {1 {UNIQUE constraint failed: t1.c}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1df339ba7540af78342ea09feb47fdef579a1310",
      "candidate_info": {
        "commit_hash": "1df339ba7540af78342ea09feb47fdef579a1310",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1df339ba7540af78342ea09feb47fdef579a1310",
        "files": [
          "ext/misc/dbdata.c",
          "main.mk",
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/func.c",
          "src/resolve.c",
          "src/shell.c.in",
          "src/vdbe.c",
          "src/vdbeInt.h",
          "src/vdbemem.c",
          "src/vtab.c",
          "src/whereexpr.c",
          "test/altertab3.test",
          "test/dbdata.test",
          "test/fts4rename.test",
          "test/index.test",
          "test/like3.test",
          "test/oserror.test",
          "test/recover.test",
          "test/wapptest.tcl",
          "test/without_rowid1.test",
          "tool/lemon.c",
          "tool/mkshellc.tcl"
        ],
        "message": "Merge enhancements from trunk\n\nFossilOrigin-Name: 3a4751a9f2784131f81071305b838caa63410a76533fb879627e1849d626f893",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "main.mk||main.mk",
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/func.c||src/func.c",
          "src/resolve.c||src/resolve.c",
          "src/shell.c.in||src/shell.c.in",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbeInt.h||src/vdbeInt.h",
          "src/vdbemem.c||src/vdbemem.c",
          "src/vtab.c||src/vtab.c",
          "src/whereexpr.c||src/whereexpr.c",
          "test/altertab3.test||test/altertab3.test",
          "test/dbdata.test||test/dbdata.test",
          "test/fts4rename.test||test/fts4rename.test",
          "test/index.test||test/index.test",
          "test/like3.test||test/like3.test",
          "test/oserror.test||test/oserror.test",
          "test/recover.test||test/recover.test",
          "test/wapptest.tcl||test/wapptest.tcl",
          "test/without_rowid1.test||test/without_rowid1.test",
          "tool/lemon.c||tool/lemon.c",
          "tool/mkshellc.tcl||tool/mkshellc.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: #if !defined(SQLITEINT_H)",
          "75: #include \"sqlite3ext.h\"",
          "77: typedef unsigned char u8;",
          "79: #endif",
          "80: SQLITE_EXTENSION_INIT1",
          "81: #include <string.h>",
          "82: #include <assert.h>",
          "84: typedef struct DbdataTable DbdataTable;",
          "85: typedef struct DbdataCursor DbdataCursor;",
          "88: struct DbdataCursor {",
          "98:   int szDb;",
          "99:   sqlite3_int64 iRowid;",
          "106:   u8 *pHdrPtr;",
          "107:   u8 *pPtr;",
          "110: };",
          "113: struct DbdataTable {",
          "118: };",
          "121: #define DBDATA_COLUMN_PGNO        0",
          "122: #define DBDATA_COLUMN_CELL        1",
          "123: #define DBDATA_COLUMN_FIELD       2",
          "124: #define DBDATA_COLUMN_VALUE       3",
          "125: #define DBDATA_COLUMN_SCHEMA      4",
          "126: #define DBDATA_SCHEMA             \\",
          "127:       \"CREATE TABLE x(\"           \\",
          "128:       \"  pgno INTEGER,\"           \\",
          "129:       \"  cell INTEGER,\"           \\",
          "130:       \"  field INTEGER,\"          \\",
          "131:       \"  value ANY,\"              \\",
          "132:       \"  schema TEXT HIDDEN\"      \\",
          "133:       \")\"",
          "136: #define DBPTR_COLUMN_PGNO         0",
          "137: #define DBPTR_COLUMN_CHILD        1",
          "138: #define DBPTR_COLUMN_SCHEMA       2",
          "139: #define DBPTR_SCHEMA              \\",
          "140:       \"CREATE TABLE x(\"           \\",
          "141:       \"  pgno INTEGER,\"           \\",
          "142:       \"  child INTEGER,\"          \\",
          "143:       \"  schema TEXT HIDDEN\"      \\",
          "144:       \")\"",
          "150: static int dbdataConnect(",
          "151:   sqlite3 *db,",
          "152:   void *pAux,",
          "153:   int argc, const char *const*argv,",
          "154:   sqlite3_vtab **ppVtab,",
          "155:   char **pzErr",
          "156: ){",
          "157:   DbdataTable *pTab = 0;",
          "158:   int rc = sqlite3_declare_vtab(db, pAux ? DBPTR_SCHEMA : DBDATA_SCHEMA);",
          "160:   if( rc==SQLITE_OK ){",
          "161:     pTab = (DbdataTable*)sqlite3_malloc64(sizeof(DbdataTable));",
          "162:     if( pTab==0 ){",
          "163:       rc = SQLITE_NOMEM;",
          "164:     }else{",
          "165:       memset(pTab, 0, sizeof(DbdataTable));",
          "166:       pTab->db = db;",
          "167:       pTab->bPtr = (pAux!=0);",
          "168:     }",
          "169:   }",
          "172:   return rc;",
          "173: }",
          "178: static int dbdataDisconnect(sqlite3_vtab *pVtab){",
          "179:   DbdataTable *pTab = (DbdataTable*)pVtab;",
          "180:   if( pTab ){",
          "181:     sqlite3_finalize(pTab->pStmt);",
          "182:     sqlite3_free(pVtab);",
          "183:   }",
          "184:   return SQLITE_OK;",
          "185: }",
          "200: static int dbdataBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdx){",
          "201:   DbdataTable *pTab = (DbdataTable*)tab;",
          "202:   int i;",
          "203:   int iSchema = -1;",
          "204:   int iPgno = -1;",
          "205:   int colSchema = (pTab->bPtr ? DBPTR_COLUMN_SCHEMA : DBDATA_COLUMN_SCHEMA);",
          "207:   for(i=0; i<pIdx->nConstraint; i++){",
          "208:     struct sqlite3_index_constraint *p = &pIdx->aConstraint[i];",
          "209:     if( p->op==SQLITE_INDEX_CONSTRAINT_EQ ){",
          "210:       if( p->iColumn==colSchema ){",
          "211:         if( p->usable==0 ) return SQLITE_CONSTRAINT;",
          "212:         iSchema = i;",
          "213:       }",
          "214:       if( p->iColumn==DBDATA_COLUMN_PGNO && p->usable ){",
          "215:         iPgno = i;",
          "216:       }",
          "217:     }",
          "218:   }",
          "220:   if( iSchema>=0 ){",
          "221:     pIdx->aConstraintUsage[iSchema].argvIndex = 1;",
          "222:     pIdx->aConstraintUsage[iSchema].omit = 1;",
          "223:   }",
          "224:   if( iPgno>=0 ){",
          "225:     pIdx->aConstraintUsage[iPgno].argvIndex = 1 + (iSchema>=0);",
          "226:     pIdx->aConstraintUsage[iPgno].omit = 1;",
          "227:     pIdx->estimatedCost = 100;",
          "228:     pIdx->estimatedRows =  50;",
          "230:     if( pTab->bPtr==0 && pIdx->nOrderBy && pIdx->aOrderBy[0].desc==0 ){",
          "231:       int iCol = pIdx->aOrderBy[0].iColumn;",
          "232:       if( pIdx->nOrderBy==1 ){",
          "233:         pIdx->orderByConsumed = (iCol==0 || iCol==1);",
          "234:       }else if( pIdx->nOrderBy==2 && pIdx->aOrderBy[1].desc==0 && iCol==0 ){",
          "235:         pIdx->orderByConsumed = (pIdx->aOrderBy[1].iColumn==1);",
          "236:       }",
          "237:     }",
          "239:   }else{",
          "240:     pIdx->estimatedCost = 100000000;",
          "241:     pIdx->estimatedRows = 1000000000;",
          "242:   }",
          "243:   pIdx->idxNum = (iSchema>=0 ? 0x01 : 0x00) | (iPgno>=0 ? 0x02 : 0x00);",
          "244:   return SQLITE_OK;",
          "245: }",
          "250: static int dbdataOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){",
          "251:   DbdataCursor *pCsr;",
          "253:   pCsr = (DbdataCursor*)sqlite3_malloc64(sizeof(DbdataCursor));",
          "254:   if( pCsr==0 ){",
          "255:     return SQLITE_NOMEM;",
          "256:   }else{",
          "257:     memset(pCsr, 0, sizeof(DbdataCursor));",
          "258:     pCsr->base.pVtab = pVTab;",
          "259:   }",
          "262:   return SQLITE_OK;",
          "263: }",
          "269: static void dbdataResetCursor(DbdataCursor *pCsr){",
          "270:   DbdataTable *pTab = (DbdataTable*)(pCsr->base.pVtab);",
          "271:   if( pTab->pStmt==0 ){",
          "272:     pTab->pStmt = pCsr->pStmt;",
          "273:   }else{",
          "274:     sqlite3_finalize(pCsr->pStmt);",
          "275:   }",
          "276:   pCsr->pStmt = 0;",
          "277:   pCsr->iPgno = 1;",
          "278:   pCsr->iCell = 0;",
          "279:   pCsr->iField = 0;",
          "280:   pCsr->bOnePage = 0;",
          "281: }",
          "286: static int dbdataClose(sqlite3_vtab_cursor *pCursor){",
          "287:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "288:   dbdataResetCursor(pCsr);",
          "289:   sqlite3_free(pCsr);",
          "290:   return SQLITE_OK;",
          "291: }",
          "296: static unsigned int get_uint16(unsigned char *a){",
          "297:   return (a[0]<<8)|a[1];",
          "298: }",
          "299: static unsigned int get_uint32(unsigned char *a){",
          "300:   return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|a[3];",
          "301: }",
          "313: static int dbdataLoadPage(",
          "318: ){",
          "319:   int rc2;",
          "320:   int rc = SQLITE_OK;",
          "321:   sqlite3_stmt *pStmt = pCsr->pStmt;",
          "325:   sqlite3_bind_int64(pStmt, 2, pgno);",
          "326:   if( SQLITE_ROW==sqlite3_step(pStmt) ){",
          "327:     int nCopy = sqlite3_column_bytes(pStmt, 0);",
          "328:     if( nCopy>0 ){",
          "329:       u8 *pPage;",
          "330:       pPage = (u8*)sqlite3_malloc64(nCopy);",
          "331:       if( pPage==0 ){",
          "332:         rc = SQLITE_NOMEM;",
          "333:       }else{",
          "334:         const u8 *pCopy = sqlite3_column_blob(pStmt, 0);",
          "335:         memcpy(pPage, pCopy, nCopy);",
          "336:       }",
          "339:     }",
          "340:   }",
          "341:   rc2 = sqlite3_reset(pStmt);",
          "342:   if( rc==SQLITE_OK ) rc = rc2;",
          "344:   return rc;",
          "345: }",
          "350: static int dbdataGetVarint(const u8 *z, sqlite3_int64 *pVal){",
          "351:   sqlite3_int64 v = 0;",
          "352:   int i;",
          "353:   for(i=0; i<8; i++){",
          "354:     v = (v<<7) + (z[i]&0x7f);",
          "355:     if( (z[i]&0x80)==0 ){ *pVal = v; return i+1; }",
          "356:   }",
          "357:   v = (v<<8) + (z[i]&0xff);",
          "359:   return 9;",
          "360: }",
          "366: static int dbdataValueBytes(int eType){",
          "367:   switch( eType ){",
          "368:     case 0: case 8: case 9:",
          "369:     case 10: case 11:",
          "370:       return 0;",
          "371:     case 1:",
          "372:       return 1;",
          "373:     case 2:",
          "374:       return 2;",
          "375:     case 3:",
          "376:       return 3;",
          "377:     case 4:",
          "378:       return 4;",
          "379:     case 5:",
          "380:       return 6;",
          "381:     case 6:",
          "382:     case 7:",
          "383:       return 8;",
          "384:     default:",
          "385:       return ((eType-12) / 2);",
          "386:   }",
          "387: }",
          "393: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "394:   switch( eType ){",
          "395:     case 0:",
          "396:     case 10:",
          "397:     case 11:",
          "398:       sqlite3_result_null(pCtx);",
          "399:       break;",
          "401:     case 8:",
          "402:       sqlite3_result_int(pCtx, 0);",
          "403:       break;",
          "404:     case 9:",
          "405:       sqlite3_result_int(pCtx, 1);",
          "406:       break;",
          "408:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "409:       sqlite3_uint64 v = (signed char)pData[0];",
          "410:       pData++;",
          "411:       switch( eType ){",
          "412:         case 7:",
          "413:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "414:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "415:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "416:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "417:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "418:       }",
          "420:       if( eType==7 ){",
          "421:         double r;",
          "422:         memcpy(&r, &v, sizeof(r));",
          "423:         sqlite3_result_double(pCtx, r);",
          "424:       }else{",
          "425:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "426:       }",
          "427:       break;",
          "428:     }",
          "430:     default: {",
          "431:       int n = ((eType-12) / 2);",
          "432:       if( eType % 2 ){",
          "433:         sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "434:       }else{",
          "435:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "436:       }",
          "437:     }",
          "438:   }",
          "439: }",
          "445: static int dbdataNext(sqlite3_vtab_cursor *pCursor){",
          "446:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "447:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "449:   pCsr->iRowid++;",
          "450:   while( 1 ){",
          "451:     int rc;",
          "452:     int iOff = (pCsr->iPgno==1 ? 100 : 0);",
          "454:     if( pCsr->aPage==0 ){",
          "455:       while( 1 ){",
          "456:         if( pCsr->bOnePage==0 && pCsr->iPgno>pCsr->szDb ) return SQLITE_OK;",
          "457:         rc = dbdataLoadPage(pCsr, pCsr->iPgno, &pCsr->aPage, &pCsr->nPage);",
          "458:         if( rc!=SQLITE_OK ) return rc;",
          "459:         if( pCsr->aPage ) break;",
          "460:         pCsr->iPgno++;",
          "461:       }",
          "462:       pCsr->iCell = pTab->bPtr ? -2 : 0;",
          "463:       pCsr->nCell = get_uint16(&pCsr->aPage[iOff+3]);",
          "464:     }",
          "466:     if( pTab->bPtr ){",
          "467:       if( pCsr->aPage[iOff]!=0x02 && pCsr->aPage[iOff]!=0x05 ){",
          "468:         pCsr->iCell = pCsr->nCell;",
          "469:       }",
          "470:       pCsr->iCell++;",
          "471:       if( pCsr->iCell>=pCsr->nCell ){",
          "472:         sqlite3_free(pCsr->aPage);",
          "473:         pCsr->aPage = 0;",
          "474:         if( pCsr->bOnePage ) return SQLITE_OK;",
          "475:         pCsr->iPgno++;",
          "476:       }else{",
          "477:         return SQLITE_OK;",
          "478:       }",
          "479:     }else{",
          "481:       if( pCsr->pRec==0 ){",
          "482:         int bHasRowid = 0;",
          "483:         int nPointer = 0;",
          "484:         sqlite3_int64 nPayload = 0;",
          "485:         sqlite3_int64 nHdr = 0;",
          "486:         int iHdr;",
          "487:         int U, X;",
          "488:         int nLocal;",
          "490:         switch( pCsr->aPage[iOff] ){",
          "491:           case 0x02:",
          "492:             nPointer = 4;",
          "493:             break;",
          "494:           case 0x0a:",
          "495:             break;",
          "496:           case 0x0d:",
          "497:             bHasRowid = 1;",
          "498:             break;",
          "499:           default:",
          "501:             pCsr->iCell = pCsr->nCell;",
          "502:             break;",
          "503:         }",
          "505:         if( pCsr->iCell>=pCsr->nCell ){",
          "506:           sqlite3_free(pCsr->aPage);",
          "507:           pCsr->aPage = 0;",
          "508:           if( pCsr->bOnePage ) return SQLITE_OK;",
          "509:           pCsr->iPgno++;",
          "510:           continue;",
          "511:         }",
          "513:         iOff += 8 + nPointer + pCsr->iCell*2;",
          "514:         iOff = get_uint16(&pCsr->aPage[iOff]);",
          "517:         iOff += nPointer;",
          "520:         iOff += dbdataGetVarint(&pCsr->aPage[iOff], &nPayload);",
          "523:         if( bHasRowid ){",
          "524:           iOff += dbdataGetVarint(&pCsr->aPage[iOff], &pCsr->iIntkey);",
          "525:         }",
          "528:         pCsr->pRec = (u8*)sqlite3_malloc64(nPayload);",
          "529:         if( pCsr->pRec==0 ) return SQLITE_NOMEM;",
          "530:         pCsr->nRec = nPayload;",
          "532:         U = pCsr->nPage;",
          "533:         if( bHasRowid ){",
          "534:           X = U-35;",
          "535:         }else{",
          "536:           X = ((U-12)*64/255)-23;",
          "537:         }",
          "538:         if( nPayload<=X ){",
          "539:           nLocal = nPayload;",
          "540:         }else{",
          "541:           int M, K;",
          "542:           M = ((U-12)*32/255)-23;",
          "543:           K = M+((nPayload-M)%(U-4));",
          "544:           if( K<=X ){",
          "545:             nLocal = K;",
          "546:           }else{",
          "547:             nLocal = M;",
          "548:           }",
          "549:         }",
          "552:         memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);",
          "553:         iOff += nLocal;",
          "556:         if( nPayload>nLocal ){",
          "557:           sqlite3_int64 nRem = nPayload - nLocal;",
          "558:           unsigned int pgnoOvfl = get_uint32(&pCsr->aPage[iOff]);",
          "559:           while( nRem>0 ){",
          "560:             u8 *aOvfl = 0;",
          "561:             int nOvfl = 0;",
          "562:             int nCopy;",
          "563:             rc = dbdataLoadPage(pCsr, pgnoOvfl, &aOvfl, &nOvfl);",
          "564:             assert( rc!=SQLITE_OK || nOvfl==pCsr->nPage );",
          "565:             if( rc!=SQLITE_OK ) return rc;",
          "567:             nCopy = U-4;",
          "568:             if( nCopy>nRem ) nCopy = nRem;",
          "569:             memcpy(&pCsr->pRec[nPayload-nRem], &aOvfl[4], nCopy);",
          "570:             nRem -= nCopy;",
          "572:             pgnoOvfl = get_uint32(aOvfl);",
          "573:             sqlite3_free(aOvfl);",
          "574:           }",
          "575:         }",
          "577:         iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);",
          "578:         pCsr->nHdr = nHdr;",
          "579:         pCsr->pHdrPtr = &pCsr->pRec[iHdr];",
          "580:         pCsr->pPtr = &pCsr->pRec[pCsr->nHdr];",
          "581:         pCsr->iField = (bHasRowid ? -1 : 0);",
          "582:       }else{",
          "583:         pCsr->iField++;",
          "584:         if( pCsr->iField>0 ){",
          "585:           sqlite3_int64 iType;",
          "586:           pCsr->pHdrPtr += dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "587:           pCsr->pPtr += dbdataValueBytes(iType);",
          "588:         }",
          "589:       }",
          "591:       if( pCsr->iField<0 || pCsr->pHdrPtr<&pCsr->pRec[pCsr->nHdr] ){",
          "592:         return SQLITE_OK;",
          "593:       }",
          "597:       sqlite3_free(pCsr->pRec);",
          "598:       pCsr->pRec = 0;",
          "599:       pCsr->iCell++;",
          "600:     }",
          "601:   }",
          "603:   assert( !\"can't get here\" );",
          "604:   return SQLITE_OK;",
          "605: }",
          "610: static int dbdataEof(sqlite3_vtab_cursor *pCursor){",
          "611:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "612:   return pCsr->aPage==0;",
          "613: }",
          "621: static int dbdataDbsize(DbdataCursor *pCsr, const char *zSchema){",
          "622:   DbdataTable *pTab = (DbdataTable*)pCsr->base.pVtab;",
          "623:   char *zSql = 0;",
          "624:   int rc, rc2;",
          "625:   sqlite3_stmt *pStmt = 0;",
          "627:   zSql = sqlite3_mprintf(\"PRAGMA %Q.page_count\", zSchema);",
          "628:   if( zSql==0 ) return SQLITE_NOMEM;",
          "629:   rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pStmt, 0);",
          "630:   sqlite3_free(zSql);",
          "631:   if( rc==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){",
          "632:     pCsr->szDb = sqlite3_column_int(pStmt, 0);",
          "633:   }",
          "634:   rc2 = sqlite3_finalize(pStmt);",
          "635:   if( rc==SQLITE_OK ) rc = rc2;",
          "636:   return rc;",
          "637: }",
          "642: static int dbdataFilter(",
          "643:   sqlite3_vtab_cursor *pCursor,",
          "644:   int idxNum, const char *idxStr,",
          "645:   int argc, sqlite3_value **argv",
          "646: ){",
          "647:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "648:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "649:   int rc = SQLITE_OK;",
          "650:   const char *zSchema = \"main\";",
          "652:   dbdataResetCursor(pCsr);",
          "653:   assert( pCsr->iPgno==1 );",
          "654:   if( idxNum & 0x01 ){",
          "655:     zSchema = (const char*)sqlite3_value_text(argv[0]);",
          "656:   }",
          "657:   if( idxNum & 0x02 ){",
          "658:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);",
          "659:     pCsr->bOnePage = 1;",
          "660:   }else{",
          "661:     pCsr->nPage = dbdataDbsize(pCsr, zSchema);",
          "662:     rc = dbdataDbsize(pCsr, zSchema);",
          "663:   }",
          "665:   if( rc==SQLITE_OK ){",
          "666:     if( pTab->pStmt ){",
          "667:       pCsr->pStmt = pTab->pStmt;",
          "668:       pTab->pStmt = 0;",
          "669:     }else{",
          "670:       rc = sqlite3_prepare_v2(pTab->db,",
          "671:           \"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\", -1,",
          "672:           &pCsr->pStmt, 0",
          "673:       );",
          "674:     }",
          "675:   }",
          "676:   if( rc==SQLITE_OK ){",
          "677:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);",
          "678:   }else{",
          "679:     pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(pTab->db));",
          "680:   }",
          "681:   if( rc==SQLITE_OK ){",
          "682:     rc = dbdataNext(pCursor);",
          "683:   }",
          "684:   return rc;",
          "685: }",
          "690: static int dbdataColumn(",
          "691:   sqlite3_vtab_cursor *pCursor,",
          "692:   sqlite3_context *ctx,",
          "693:   int i",
          "694: ){",
          "695:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "696:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "697:   if( pTab->bPtr ){",
          "698:     switch( i ){",
          "699:       case DBPTR_COLUMN_PGNO:",
          "700:         sqlite3_result_int64(ctx, pCsr->iPgno);",
          "701:         break;",
          "702:       case DBPTR_COLUMN_CHILD: {",
          "703:         int iOff = pCsr->iPgno==1 ? 100 : 0;",
          "704:         if( pCsr->iCell<0 ){",
          "705:           iOff += 8;",
          "706:         }else{",
          "707:           iOff += 12 + pCsr->iCell*2;",
          "708:           iOff = get_uint16(&pCsr->aPage[iOff]);",
          "709:         }",
          "710:         sqlite3_result_int64(ctx, get_uint32(&pCsr->aPage[iOff]));",
          "711:         break;",
          "712:       }",
          "713:     }",
          "714:   }else{",
          "715:     switch( i ){",
          "716:       case DBDATA_COLUMN_PGNO:",
          "717:         sqlite3_result_int64(ctx, pCsr->iPgno);",
          "718:         break;",
          "719:       case DBDATA_COLUMN_CELL:",
          "720:         sqlite3_result_int(ctx, pCsr->iCell);",
          "721:         break;",
          "722:       case DBDATA_COLUMN_FIELD:",
          "723:         sqlite3_result_int(ctx, pCsr->iField);",
          "724:         break;",
          "725:       case DBDATA_COLUMN_VALUE: {",
          "726:         if( pCsr->iField<0 ){",
          "727:           sqlite3_result_int64(ctx, pCsr->iIntkey);",
          "728:         }else{",
          "729:           sqlite3_int64 iType;",
          "730:           dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "731:           dbdataValue(ctx, iType, pCsr->pPtr);",
          "732:         }",
          "733:         break;",
          "734:       }",
          "735:     }",
          "736:   }",
          "737:   return SQLITE_OK;",
          "738: }",
          "743: static int dbdataRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){",
          "744:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "746:   return SQLITE_OK;",
          "747: }",
          "753: static int sqlite3DbdataRegister(sqlite3 *db){",
          "754:   static sqlite3_module dbdata_module = {",
          "779:   };",
          "781:   int rc = sqlite3_create_module(db, \"sqlite_dbdata\", &dbdata_module, 0);",
          "782:   if( rc==SQLITE_OK ){",
          "783:     rc = sqlite3_create_module(db, \"sqlite_dbptr\", &dbdata_module, (void*)1);",
          "784:   }",
          "785:   return rc;",
          "786: }",
          "788: #ifdef _WIN32",
          "789: __declspec(dllexport)",
          "790: #endif",
          "791: int sqlite3_dbdata_init(",
          "792:   sqlite3 *db,",
          "793:   char **pzErrMsg,",
          "794:   const sqlite3_api_routines *pApi",
          "795: ){",
          "796:   SQLITE_EXTENSION_INIT2(pApi);",
          "797:   return sqlite3DbdataRegister(db);",
          "798: }",
          "",
          "---------------"
        ],
        "main.mk||main.mk": [
          "File: main.mk -> main.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:  $(TOP)/ext/expert/sqlite3expert.h \\",
          "739:  $(TOP)/ext/misc/zipfile.c \\",
          "740:  $(TOP)/ext/misc/memtrace.c \\",
          "741:         $(TOP)/src/test_windirent.c",
          "743: shell.c: $(SHELL_SRC) $(TOP)/tool/mkshellc.tcl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741:  $(TOP)/ext/misc/dbdata.c \\",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b0ccef61a7f92d20228becbf4f997bf0f4e46dad2deaf0896dc63b976ad1dd11",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1726:   pIdx->szIdxRow = sqlite3LogEst(wIndex*4);",
          "1727: }",
          "1731: static int hasColumn(const i16 *aiCol, int nCol, int x){",
          "1733:   return 0;",
          "1734: }",
          "",
          "[Removed Lines]",
          "1732:   while( nCol-- > 0 ) if( x==*(aiCol++) ) return 1;",
          "",
          "[Added Lines]",
          "1734:   while( nCol-- > 0 ){",
          "1735:     assert( aiCol[0]>=0 );",
          "1736:     if( x==*(aiCol++) ){",
          "1737:       return 1;",
          "1738:     }",
          "1739:   }",
          "1740:   return 0;",
          "1741: }",
          "1756: static int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){",
          "1757:   int i, j;",
          "1758:   assert( nKey<=pIdx->nColumn );",
          "1759:   assert( iCol<MAX(pPk->nColumn,pPk->nKeyCol) );",
          "1760:   assert( pPk->idxType==SQLITE_IDXTYPE_PRIMARYKEY );",
          "1761:   assert( pPk->pTable->tabFlags & TF_WithoutRowid );",
          "1762:   assert( pPk->pTable==pIdx->pTable );",
          "1763:   testcase( pPk==pIdx );",
          "1764:   j = pPk->aiColumn[iCol];",
          "1765:   assert( j!=XN_ROWID && j!=XN_EXPR );",
          "1766:   for(i=0; i<nKey; i++){",
          "1767:     assert( pIdx->aiColumn[i]>=0 || j>=0 );",
          "1768:     if( pIdx->aiColumn[i]==j",
          "1769:      && sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0",
          "1770:     ){",
          "1771:       return 1;",
          "1772:     }",
          "1773:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1837:     for(i=j=1; i<pPk->nKeyCol; i++){",
          "1839:         pPk->nColumn--;",
          "1840:       }else{",
          "1841:         pPk->aiColumn[j++] = pPk->aiColumn[i];",
          "1842:       }",
          "1843:     }",
          "",
          "[Removed Lines]",
          "1838:       if( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) ){",
          "",
          "[Added Lines]",
          "1879:       if( isDupColumn(pPk, j, pPk, i) ){",
          "1882:         testcase( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1867:     int n;",
          "1868:     if( IsPrimaryKeyIndex(pIdx) ) continue;",
          "1869:     for(i=n=0; i<nPk; i++){",
          "1871:     }",
          "1872:     if( n==0 ){",
          "",
          "[Removed Lines]",
          "1870:       if( !hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) ) n++;",
          "",
          "[Added Lines]",
          "1912:       if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){",
          "1913:         testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );",
          "1914:         n++;",
          "1915:       }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1876:     }",
          "1877:     if( resizeIndexObject(db, pIdx, pIdx->nKeyCol+n) ) return;",
          "1878:     for(i=0, j=pIdx->nKeyCol; i<nPk; i++){",
          "1880:         pIdx->aiColumn[j] = pPk->aiColumn[i];",
          "1881:         pIdx->azColl[j] = pPk->azColl[i];",
          "1882:         j++;",
          "",
          "[Removed Lines]",
          "1879:       if( !hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) ){",
          "",
          "[Added Lines]",
          "1924:       if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){",
          "1925:         testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3392:     for(j=0; j<pPk->nKeyCol; j++){",
          "3393:       int x = pPk->aiColumn[j];",
          "3394:       assert( x>=0 );",
          "3396:         pIndex->nColumn--;",
          "3397:       }else{",
          "3398:         pIndex->aiColumn[i] = x;",
          "3399:         pIndex->azColl[i] = pPk->azColl[j];",
          "3400:         pIndex->aSortOrder[i] = pPk->aSortOrder[j];",
          "",
          "[Removed Lines]",
          "3395:       if( hasColumn(pIndex->aiColumn, pIndex->nKeyCol, x) ){",
          "",
          "[Added Lines]",
          "3441:       if( isDupColumn(pIndex, pIndex->nKeyCol, pPk, j) ){",
          "3444:         testcase( hasColumn(pIndex->aiColumn,pIndex->nKeyCol,x) );",
          "",
          "---------------"
        ],
        "src/func.c||src/func.c": [
          "File: src/func.c -> src/func.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "843:     return;",
          "844:   }",
          "845: #endif",
          "",
          "[Removed Lines]",
          "846:   zB = sqlite3_value_text(argv[0]);",
          "847:   zA = sqlite3_value_text(argv[1]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "873:   }else{",
          "874:     escape = pInfo->matchSet;",
          "875:   }",
          "876:   if( zA && zB ){",
          "877: #ifdef SQLITE_TEST",
          "878:     sqlite3_like_count++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "872:   zB = sqlite3_value_text(argv[0]);",
          "873:   zA = sqlite3_value_text(argv[1]);",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "866: #ifndef SQLITE_OMIT_WINDOWFUNC",
          "867:         if( pExpr->y.pWin ){",
          "868:           Select *pSel = pNC->pWinSelect;",
          "870:           sqlite3WalkExprList(pWalker, pExpr->y.pWin->pPartition);",
          "871:           sqlite3WalkExprList(pWalker, pExpr->y.pWin->pOrderBy);",
          "872:           sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);",
          "",
          "[Removed Lines]",
          "869:           sqlite3WindowUpdate(pParse, pSel->pWinDefn, pExpr->y.pWin, pDef);",
          "",
          "[Added Lines]",
          "869:           if( IN_RENAME_OBJECT==0 ){",
          "870:             sqlite3WindowUpdate(pParse, pSel->pWinDefn, pExpr->y.pWin, pDef);",
          "871:           }",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "948: INCLUDE ../ext/expert/sqlite3expert.h",
          "949: INCLUDE ../ext/expert/sqlite3expert.c",
          "951: #if defined(SQLITE_ENABLE_SESSION)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "952: INCLUDE ../ext/misc/dbdata.c",
          "953: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3574:   \".prompt MAIN CONTINUE    Replace the standard prompts\",",
          "3575:   \".quit                    Exit this program\",",
          "3576:   \".read FILE               Read input from FILE\",",
          "3577:   \".restore ?DB? FILE       Restore content of DB (default \\\"main\\\") from FILE\",",
          "3578:   \".save FILE               Write in-memory database into FILE\",",
          "3579:   \".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3581: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "3582:   \".recover                 Recover as much data as possible from corrupt db.\",",
          "3583: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3931: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3947: static void shellInt32(",
          "3948:   sqlite3_context *context,",
          "3949:   int argc,",
          "3950:   sqlite3_value **argv",
          "3951: ){",
          "3952:   const unsigned char *pBlob;",
          "3953:   int nBlob;",
          "3954:   int iInt;",
          "3956:   nBlob = sqlite3_value_bytes(argv[0]);",
          "3957:   pBlob = (const unsigned char*)sqlite3_value_blob(argv[0]);",
          "3958:   iInt = sqlite3_value_int(argv[1]);",
          "3960:   if( iInt>=0 && (iInt+1)*4<=nBlob ){",
          "3961:     const unsigned char *a = &pBlob[iInt*4];",
          "3962:     sqlite3_int64 iVal = ((sqlite3_int64)a[0]<<24)",
          "3963:                        + ((sqlite3_int64)a[1]<<16)",
          "3964:                        + ((sqlite3_int64)a[2]<< 8)",
          "3965:                        + ((sqlite3_int64)a[3]<< 0);",
          "3966:     sqlite3_result_int64(context, iVal);",
          "3967:   }",
          "3968: }",
          "3983: static void shellEscapeCrnl(",
          "3984:   sqlite3_context *context,",
          "3985:   int argc,",
          "3986:   sqlite3_value **argv",
          "3987: ){",
          "3988:   const char *zText = (const char*)sqlite3_value_text(argv[0]);",
          "3989:   if( zText[0]=='\\'' ){",
          "3990:     int nText = sqlite3_value_bytes(argv[0]);",
          "3991:     int i;",
          "3992:     char zBuf1[20];",
          "3993:     char zBuf2[20];",
          "3994:     const char *zNL = 0;",
          "3995:     const char *zCR = 0;",
          "3996:     int nCR = 0;",
          "3997:     int nNL = 0;",
          "3999:     for(i=0; zText[i]; i++){",
          "4000:       if( zNL==0 && zText[i]=='\\n' ){",
          "4001:         zNL = unused_string(zText, \"\\\\n\", \"\\\\012\", zBuf1);",
          "4002:         nNL = (int)strlen(zNL);",
          "4003:       }",
          "4004:       if( zCR==0 && zText[i]=='\\r' ){",
          "4005:         zCR = unused_string(zText, \"\\\\r\", \"\\\\015\", zBuf2);",
          "4006:         nCR = (int)strlen(zCR);",
          "4007:       }",
          "4008:     }",
          "4010:     if( zNL || zCR ){",
          "4011:       int iOut = 0;",
          "4012:       i64 nMax = (nNL > nCR) ? nNL : nCR;",
          "4013:       i64 nAlloc = nMax * nText + (nMax+64)*2;",
          "4014:       char *zOut = (char*)sqlite3_malloc64(nAlloc);",
          "4015:       if( zOut==0 ){",
          "4016:         sqlite3_result_error_nomem(context);",
          "4017:         return;",
          "4018:       }",
          "4020:       if( zNL && zCR ){",
          "4021:         memcpy(&zOut[iOut], \"replace(replace(\", 16);",
          "4022:         iOut += 16;",
          "4023:       }else{",
          "4024:         memcpy(&zOut[iOut], \"replace(\", 8);",
          "4025:         iOut += 8;",
          "4026:       }",
          "4027:       for(i=0; zText[i]; i++){",
          "4028:         if( zText[i]=='\\n' ){",
          "4029:           memcpy(&zOut[iOut], zNL, nNL);",
          "4030:           iOut += nNL;",
          "4031:         }else if( zText[i]=='\\r' ){",
          "4032:           memcpy(&zOut[iOut], zCR, nCR);",
          "4033:           iOut += nCR;",
          "4034:         }else{",
          "4035:           zOut[iOut] = zText[i];",
          "4036:           iOut++;",
          "4037:         }",
          "4038:       }",
          "4040:       if( zNL ){",
          "4041:         memcpy(&zOut[iOut], \",'\", 2); iOut += 2;",
          "4042:         memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;",
          "4043:         memcpy(&zOut[iOut], \"', char(10))\", 12); iOut += 12;",
          "4044:       }",
          "4045:       if( zCR ){",
          "4046:         memcpy(&zOut[iOut], \",'\", 2); iOut += 2;",
          "4047:         memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;",
          "4048:         memcpy(&zOut[iOut], \"', char(13))\", 12); iOut += 12;",
          "4049:       }",
          "4051:       sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);",
          "4052:       sqlite3_free(zOut);",
          "4053:       return;",
          "4054:     }",
          "4055:   }",
          "4057:   sqlite3_result_value(context, argv[0]);",
          "4058: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3999:     sqlite3_fileio_init(p->db, 0, 0);",
          "4000:     sqlite3_shathree_init(p->db, 0, 0);",
          "4001:     sqlite3_completion_init(p->db, 0, 0);",
          "4002: #ifdef SQLITE_HAVE_ZLIB",
          "4003:     sqlite3_zipfile_init(p->db, 0, 0);",
          "4004:     sqlite3_sqlar_init(p->db, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4128: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "4129:     sqlite3_dbdata_init(p->db, 0, 0);",
          "4130: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4009:                             shellModuleSchema, 0, 0);",
          "4010:     sqlite3_create_function(p->db, \"shell_putsnl\", 1, SQLITE_UTF8, p,",
          "4011:                             shellPutsFunc, 0, 0);",
          "4012: #ifndef SQLITE_NOHAVE_SYSTEM",
          "4013:     sqlite3_create_function(p->db, \"edit\", 1, SQLITE_UTF8, 0,",
          "4014:                             editFunc, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4141:     sqlite3_create_function(p->db, \"shell_escape_crnl\", 1, SQLITE_UTF8, 0,",
          "4142:                             shellEscapeCrnl, 0, 0);",
          "4143:     sqlite3_create_function(p->db, \"shell_int32\", 2, SQLITE_UTF8, 0,",
          "4144:                             shellInt32, 0, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5263:   return SQLITE_ERROR;",
          "5264: }",
          "5270: static void shellPrepare(",
          "5271:   sqlite3 *db,",
          "5272:   int *pRc,",
          "",
          "[Removed Lines]",
          "5266: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)",
          "",
          "[Added Lines]",
          "5399: #if !defined SQLITE_OMIT_VIRTUALTABLE",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5338:   }",
          "5339: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5472: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6165: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "6172: static void shellExec(sqlite3 *db, int *pRc, const char *zSql){",
          "6173:   int rc = *pRc;",
          "6174:   if( rc==SQLITE_OK ){",
          "6175:     char *zErr = 0;",
          "6176:     rc = sqlite3_exec(db, zSql, 0, 0, &zErr);",
          "6177:     if( rc!=SQLITE_OK ){",
          "6178:       raw_printf(stderr, \"SQL error: %s\\n\", zErr);",
          "6179:     }",
          "6181:   }",
          "6182: }",
          "6187: static void shellExecPrintf(sqlite3 *db, int *pRc, const char *zFmt, ...){",
          "6188:   char *z = 0;",
          "6189:   if( *pRc==SQLITE_OK ){",
          "6190:     va_list ap;",
          "6191:     va_start(ap, zFmt);",
          "6192:     z = sqlite3_vmprintf(zFmt, ap);",
          "6193:     va_end(ap);",
          "6194:     if( z==0 ){",
          "6196:     }else{",
          "6197:       shellExec(db, pRc, z);",
          "6198:     }",
          "6199:     sqlite3_free(z);",
          "6200:   }",
          "6201: }",
          "6209: static void *shellMalloc(int *pRc, sqlite3_int64 nByte){",
          "6210:   void *pRet = 0;",
          "6211:   if( *pRc==SQLITE_OK ){",
          "6212:     pRet = sqlite3_malloc64(nByte);",
          "6213:     if( pRet==0 ){",
          "6215:     }else{",
          "6216:       memset(pRet, 0, nByte);",
          "6217:     }",
          "6218:   }",
          "6219:   return pRet;",
          "6220: }",
          "6233: static char *shellMPrintf(int *pRc, const char *zFmt, ...){",
          "6234:   char *z = 0;",
          "6235:   if( *pRc==SQLITE_OK ){",
          "6236:     va_list ap;",
          "6237:     va_start(ap, zFmt);",
          "6238:     z = sqlite3_vmprintf(zFmt, ap);",
          "6239:     va_end(ap);",
          "6240:     if( z==0 ){",
          "6242:     }",
          "6243:   }",
          "6244:   return z;",
          "6245: }",
          "6252: typedef struct RecoverTable RecoverTable;",
          "6253: struct RecoverTable {",
          "6258: };",
          "6264: static void recoverFreeTable(RecoverTable *pTab){",
          "6265:   if( pTab ){",
          "6266:     sqlite3_free(pTab->zQuoted);",
          "6267:     if( pTab->azlCol ){",
          "6268:       int i;",
          "6269:       for(i=0; i<=pTab->nCol; i++){",
          "6270:         sqlite3_free(pTab->azlCol[i]);",
          "6271:       }",
          "6272:       sqlite3_free(pTab->azlCol);",
          "6273:     }",
          "6274:     sqlite3_free(pTab);",
          "6275:   }",
          "6276: }",
          "6285: static RecoverTable *recoverNewTable(",
          "6289:   int bIntkey,",
          "6290:   int nCol",
          "6291: ){",
          "6293:   int rc = *pRc;",
          "6294:   RecoverTable *pTab = 0;",
          "6296:   pTab = (RecoverTable*)shellMalloc(&rc, sizeof(RecoverTable));",
          "6297:   if( rc==SQLITE_OK ){",
          "6298:     int nSqlCol = 0;",
          "6299:     int bSqlIntkey = 0;",
          "6300:     sqlite3_stmt *pStmt = 0;",
          "6302:     rc = sqlite3_open(\"\", &dbtmp);",
          "6303:     if( rc==SQLITE_OK ){",
          "6304:       rc = sqlite3_exec(dbtmp, \"PRAGMA writable_schema = on\", 0, 0, 0);",
          "6305:     }",
          "6306:     if( rc==SQLITE_OK ){",
          "6307:       rc = sqlite3_exec(dbtmp, zSql, 0, 0, 0);",
          "6308:       if( rc==SQLITE_ERROR ){",
          "6309:         rc = SQLITE_OK;",
          "6310:         goto finished;",
          "6311:       }",
          "6312:     }",
          "6313:     shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6314:         \"SELECT count(*) FROM pragma_table_info(%Q)\", zName",
          "6315:     );",
          "6316:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6317:       nSqlCol = sqlite3_column_int(pStmt, 0);",
          "6318:     }",
          "6319:     shellFinalize(&rc, pStmt);",
          "6321:     if( rc!=SQLITE_OK || nSqlCol<nCol ){",
          "6322:       goto finished;",
          "6323:     }",
          "6325:     shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6326:       \"SELECT (\"",
          "6327:       \"  SELECT substr(data,1,1)==X'0D' FROM sqlite_dbpage WHERE pgno=rootpage\"",
          "6328:       \") FROM sqlite_master WHERE name = %Q\", zName",
          "6329:     );",
          "6330:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6331:       bSqlIntkey = sqlite3_column_int(pStmt, 0);",
          "6332:     }",
          "6333:     shellFinalize(&rc, pStmt);",
          "6335:     if( bIntkey==bSqlIntkey ){",
          "6336:       int i;",
          "6337:       const char *zPk = \"_rowid_\";",
          "6338:       sqlite3_stmt *pPkFinder = 0;",
          "6345:       pTab->iPk = -2;",
          "6346:       if( bIntkey ){",
          "6347:         shellPreparePrintf(dbtmp, &rc, &pPkFinder,",
          "6348:           \"SELECT cid, name FROM pragma_table_info(%Q) \"",
          "6349:           \"  WHERE pk=1 AND type='integer' COLLATE nocase\"",
          "6350:           \"  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\"",
          "6351:           , zName, zName",
          "6352:         );",
          "6353:         if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){",
          "6354:           pTab->iPk = sqlite3_column_int(pPkFinder, 0);",
          "6355:           zPk = (const char*)sqlite3_column_text(pPkFinder, 1);",
          "6356:         }",
          "6357:       }",
          "6359:       pTab->zQuoted = shellMPrintf(&rc, \"%Q\", zName);",
          "6360:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * (nSqlCol+1));",
          "6361:       pTab->nCol = nSqlCol;",
          "6363:       if( bIntkey ){",
          "6364:         pTab->azlCol[0] = shellMPrintf(&rc, \"%Q\", zPk);",
          "6365:       }else{",
          "6366:         pTab->azlCol[0] = shellMPrintf(&rc, \"\");",
          "6367:       }",
          "6368:       i = 1;",
          "6369:       shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6370:           \"SELECT %Q || group_concat(name, ', ') \"",
          "6371:           \"  FILTER (WHERE cid!=%d) OVER (ORDER BY %s cid) \"",
          "6372:           \"FROM pragma_table_info(%Q)\",",
          "6373:           bIntkey ? \", \" : \"\", pTab->iPk,",
          "6374:           bIntkey ? \"\" : \"(CASE WHEN pk=0 THEN 1000000 ELSE pk END), \",",
          "6375:           zName",
          "6376:       );",
          "6377:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6378:         const char *zText = (const char*)sqlite3_column_text(pStmt, 0);",
          "6379:         pTab->azlCol[i] = shellMPrintf(&rc, \"%s%s\", pTab->azlCol[0], zText);",
          "6380:         i++;",
          "6381:       }",
          "6382:       shellFinalize(&rc, pStmt);",
          "6384:       shellFinalize(&rc, pPkFinder);",
          "6385:     }",
          "6386:   }",
          "6388:  finished:",
          "6389:   sqlite3_close(dbtmp);",
          "6391:   if( rc!=SQLITE_OK ){",
          "6392:     recoverFreeTable(pTab);",
          "6393:     pTab = 0;",
          "6394:   }",
          "6395:   return pTab;",
          "6396: }",
          "6413: static RecoverTable *recoverFindTable(",
          "6420: ){",
          "6421:   sqlite3_stmt *pStmt = 0;",
          "6422:   RecoverTable *pRet = 0;",
          "6423:   int bNoop = 0;",
          "6424:   const char *zSql = 0;",
          "6425:   const char *zName = 0;",
          "6428:   shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6429:       \"SELECT type, name, sql FROM recovery.schema WHERE rootpage=%d\", iRoot",
          "6430:   );",
          "6431:   while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6432:     const char *zType = (const char*)sqlite3_column_text(pStmt, 0);",
          "6433:     if( bIntkey==0 && sqlite3_stricmp(zType, \"index\")==0 ){",
          "6434:       bNoop = 1;",
          "6435:       break;",
          "6436:     }",
          "6437:     if( sqlite3_stricmp(zType, \"table\")==0 ){",
          "6438:       zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6439:       zSql = (const char*)sqlite3_column_text(pStmt, 2);",
          "6440:       pRet = recoverNewTable(pRc, zName, zSql, bIntkey, nCol);",
          "6441:       break;",
          "6442:     }",
          "6443:   }",
          "6445:   shellFinalize(pRc, pStmt);",
          "6447:   return pRet;",
          "6448: }",
          "6453: static RecoverTable *recoverOrphanTable(",
          "6458: ){",
          "6459:   RecoverTable *pTab = 0;",
          "6460:   if( nCol>=0 && *pRc==SQLITE_OK ){",
          "6461:     int i;",
          "6467:     int iTab = 0;",
          "6468:     char *zTab = shellMPrintf(pRc, \"%s\", zLostAndFound);",
          "6469:     sqlite3_stmt *pTest = 0;",
          "6470:     shellPrepare(pState->db, pRc,",
          "6471:         \"SELECT 1 FROM recovery.schema WHERE name=?\", &pTest",
          "6472:     );",
          "6473:     if( pTest ) sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6474:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pTest) ){",
          "6475:       shellReset(pRc, pTest);",
          "6476:       sqlite3_free(zTab);",
          "6477:       zTab = shellMPrintf(pRc, \"%s_%d\", zLostAndFound, iTab++);",
          "6478:       sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6479:     }",
          "6480:     shellFinalize(pRc, pTest);",
          "6482:     pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6483:     if( pTab ){",
          "6484:       pTab->zQuoted = shellMPrintf(pRc, \"%Q\", zTab);",
          "6485:       pTab->nCol = nCol;",
          "6486:       pTab->iPk = -2;",
          "6487:       if( nCol>0 ){",
          "6488:         pTab->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * (nCol+1));",
          "6489:         if( pTab->azlCol ){",
          "6490:           pTab->azlCol[nCol] = shellMPrintf(pRc, \"\");",
          "6491:           for(i=nCol-1; i>=0; i--){",
          "6492:             pTab->azlCol[i] = shellMPrintf(pRc, \"%s, NULL\", pTab->azlCol[i+1]);",
          "6493:           }",
          "6494:         }",
          "6495:       }",
          "6497:       if( *pRc!=SQLITE_OK ){",
          "6498:         recoverFreeTable(pTab);",
          "6499:         pTab = 0;",
          "6500:       }else{",
          "6501:         raw_printf(pState->out,",
          "6502:             \"CREATE TABLE %s(rootpgno INTEGER, \"",
          "6503:             \"pgno INTEGER, nfield INTEGER, id INTEGER\", pTab->zQuoted",
          "6504:         );",
          "6505:         for(i=0; i<nCol; i++){",
          "6506:           raw_printf(pState->out, \", c%d\", i);",
          "6507:         }",
          "6508:         raw_printf(pState->out, \");\\n\");",
          "6509:       }",
          "6510:     }",
          "6511:     sqlite3_free(zTab);",
          "6512:   }",
          "6513:   return pTab;",
          "6514: }",
          "6521: static int recoverDatabaseCmd(ShellState *pState, int nArg, char **azArg){",
          "6522:   int rc = SQLITE_OK;",
          "6527:   const char *zLostAndFound = \"lost_and_found\";",
          "6528:   int i;",
          "6529:   int nOrphan = -1;",
          "6530:   RecoverTable *pOrphan = 0;",
          "6533:   for(i=1; i<nArg; i++){",
          "6534:     char *z = azArg[i];",
          "6535:     int n;",
          "6536:     if( z[0]=='-' && z[1]=='-' ) z++;",
          "6537:     n = strlen(z);",
          "6538:     if( n<=17 && memcmp(\"-freelist-corrupt\", z, n)==0 ){",
          "6539:       bFreelist = 0;",
          "6540:     }else",
          "6541:     if( n<=12 && memcmp(\"-recovery-db\", z, n)==0 && i<(nArg-1) ){",
          "6542:       i++;",
          "6543:       zRecoveryDb = azArg[i];",
          "6544:     }else",
          "6545:     if( n<=15 && memcmp(\"-lost-and-found\", z, n)==0 && i<(nArg-1) ){",
          "6546:       i++;",
          "6547:       zLostAndFound = azArg[i];",
          "6548:     }",
          "6549:     else{",
          "6550:       raw_printf(stderr, \"unexpected option: %s\\n\", azArg[i]);",
          "6551:       raw_printf(stderr, \"options are:\\n\");",
          "6552:       raw_printf(stderr, \"    --freelist-corrupt\\n\");",
          "6553:       raw_printf(stderr, \"    --recovery-db DATABASE\\n\");",
          "6554:       raw_printf(stderr, \"    --lost-and-found TABLE-NAME\\n\");",
          "6555:       return 1;",
          "6556:     }",
          "6557:   }",
          "6559:   shellExecPrintf(pState->db, &rc,",
          "6562:     \"ATTACH %Q AS recovery;\"",
          "6563:     \"DROP TABLE IF EXISTS recovery.dbptr;\"",
          "6564:     \"DROP TABLE IF EXISTS recovery.freelist;\"",
          "6565:     \"DROP TABLE IF EXISTS recovery.map;\"",
          "6566:     \"DROP TABLE IF EXISTS recovery.schema;\"",
          "6567:     \"CREATE TABLE recovery.freelist(pgno INTEGER PRIMARY KEY);\", zRecoveryDb",
          "6568:   );",
          "6570:   if( bFreelist ){",
          "6571:     shellExec(pState->db, &rc,",
          "6572:       \"WITH trunk(pgno) AS (\"",
          "6573:       \"  SELECT shell_int32(\"",
          "6574:       \"      (SELECT data FROM sqlite_dbpage WHERE pgno=1), 8) AS x \"",
          "6575:       \"      WHERE x>0\"",
          "6576:       \"    UNION\"",
          "6577:       \"  SELECT shell_int32(\"",
          "6578:       \"      (SELECT data FROM sqlite_dbpage WHERE pgno=trunk.pgno), 0) AS x \"",
          "6579:       \"      FROM trunk WHERE x>0\"",
          "6580:       \"),\"",
          "6581:       \"freelist(data, n, freepgno) AS (\"",
          "6582:       \"  SELECT data, shell_int32(data, 1)-1, t.pgno \"",
          "6583:       \"      FROM trunk t, sqlite_dbpage s WHERE s.pgno=t.pgno\"",
          "6584:       \"    UNION ALL\"",
          "6585:       \"  SELECT data, n-1, shell_int32(data, 2+n) \"",
          "6586:       \"      FROM freelist WHERE n>=0\"",
          "6587:       \")\"",
          "6588:       \"REPLACE INTO recovery.freelist SELECT freepgno FROM freelist;\"",
          "6589:     );",
          "6590:   }",
          "6592:   shellExec(pState->db, &rc,",
          "6593:     \"CREATE TABLE recovery.dbptr(\"",
          "6594:     \"      pgno, child, PRIMARY KEY(child, pgno)\"",
          "6595:     \") WITHOUT ROWID;\"",
          "6596:     \"INSERT OR IGNORE INTO recovery.dbptr(pgno, child) \"",
          "6597:     \"    SELECT * FROM sqlite_dbptr\"",
          "6598:     \"      WHERE pgno NOT IN freelist AND child NOT IN freelist;\"",
          "6602:     \"DELETE FROM recovery.dbptr WHERE child = 1;\"",
          "6607:     \"DELETE FROM recovery.dbptr WHERE child IN (\"",
          "6608:     \"  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1\"",
          "6609:     \");\"",
          "6614:     \"CREATE TABLE recovery.map(\"",
          "6615:       \"pgno INTEGER PRIMARY KEY, maxlen INT, intkey, root INT\"",
          "6616:     \");\"",
          "6621:     \"WITH pages(i, maxlen) AS (\"",
          "6622:     \"  SELECT page_count, (\"",
          "6623:     \"    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=page_count\"",
          "6624:     \"  ) FROM pragma_page_count\"",
          "6625:     \"    UNION ALL\"",
          "6626:     \"  SELECT i-1, (\"",
          "6627:     \"    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=i-1\"",
          "6628:     \"  ) FROM pages WHERE i>=2\"",
          "6629:     \")\"",
          "6630:     \"INSERT INTO recovery.map(pgno, maxlen, intkey, root) \"",
          "6631:     \"  SELECT i, maxlen, NULL, (\"",
          "6632:     \"    WITH p(orig, pgno, parent) AS (\"",
          "6633:     \"      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)\"",
          "6634:     \"        UNION ALL\"",
          "6635:     \"      SELECT i, p.parent, \"",
          "6636:     \"        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p\"",
          "6637:     \"    )\"",
          "6638:     \"    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)\"",
          "6639:     \") \"",
          "6640:     \"FROM pages WHERE maxlen > 0 AND i NOT IN freelist;\"",
          "6641:     \"UPDATE recovery.map AS o SET intkey = (\"",
          "6642:     \"  SELECT substr(data, 1, 1)==X'0D' FROM sqlite_dbpage WHERE pgno=o.pgno\"",
          "6643:     \");\"",
          "6647:     \"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\"",
          "6648:     \"INSERT INTO recovery.schema SELECT \"",
          "6649:     \"  max(CASE WHEN field=0 THEN value ELSE NULL END),\"",
          "6650:     \"  max(CASE WHEN field=1 THEN value ELSE NULL END),\"",
          "6651:     \"  max(CASE WHEN field=2 THEN value ELSE NULL END),\"",
          "6652:     \"  max(CASE WHEN field=3 THEN value ELSE NULL END),\"",
          "6653:     \"  max(CASE WHEN field=4 THEN value ELSE NULL END)\"",
          "6654:     \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6655:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6656:     \")\"",
          "6657:     \"GROUP BY pgno, cell;\"",
          "6658:     \"CREATE INDEX recovery.schema_rootpage ON schema(rootpage);\"",
          "6659:   );",
          "6663:   if( rc==SQLITE_OK ){",
          "6664:     sqlite3_stmt *pStmt = 0;",
          "6665:     raw_printf(pState->out, \"BEGIN;\\n\");",
          "6666:     raw_printf(pState->out, \"PRAGMA writable_schema = on;\\n\");",
          "6667:     shellPrepare(pState->db, &rc,",
          "6668:         \"SELECT sql FROM recovery.schema \"",
          "6669:         \"WHERE type='table' AND sql LIKE 'create table%'\", &pStmt",
          "6670:     );",
          "6671:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6672:       const char *zCreateTable = (const char*)sqlite3_column_text(pStmt, 0);",
          "6673:       raw_printf(pState->out, \"CREATE TABLE IF NOT EXISTS %s;\\n\",",
          "6674:           &zCreateTable[12]",
          "6675:       );",
          "6676:     }",
          "6677:     shellFinalize(&rc, pStmt);",
          "6678:   }",
          "6682:   shellPrepare(pState->db, &rc,",
          "6683:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map\"",
          "6684:       \"  WHERE root>1 AND root NOT IN (SELECT rootpage FROM recovery.schema)\"",
          "6685:       , &pLoop",
          "6686:   );",
          "6687:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6688:     nOrphan = sqlite3_column_int(pLoop, 0);",
          "6689:   }",
          "6690:   shellFinalize(&rc, pLoop);",
          "6691:   pLoop = 0;",
          "6692:   pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "6694:   shellPrepare(pState->db, &rc,",
          "6695:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "6696:   );",
          "6697:   shellPrepare(pState->db, &rc,",
          "6698:       \"SELECT max(field), group_concat(shell_escape_crnl(quote(value)), ', ')\"",
          "6699:       \"FROM sqlite_dbdata WHERE pgno = ? AND field != ?\"",
          "6700:       \"GROUP BY cell\", &pCells",
          "6701:   );",
          "6704:   shellPrepare(pState->db, &rc,",
          "6705:       \"SELECT root, intkey, max(maxlen) FROM recovery.map\"",
          "6706:       \" WHERE root>1 GROUP BY root, intkey ORDER BY root=(\"",
          "6707:       \"  SELECT rootpage FROM recovery.schema WHERE name='sqlite_sequence'\"",
          "6708:       \")\", &pLoop",
          "6709:   );",
          "6710:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6711:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6712:     int bIntkey = sqlite3_column_int(pLoop, 1);",
          "6713:     int nCol = sqlite3_column_int(pLoop, 2);",
          "6714:     int bNoop = 0;",
          "6715:     RecoverTable *pTab;",
          "6717:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6718:     if( bNoop || rc ) continue;",
          "6719:     if( pTab==0 ) pTab = pOrphan;",
          "6721:     if( 0==sqlite3_stricmp(pTab->zQuoted, \"'sqlite_sequence'\") ){",
          "6722:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6723:     }",
          "6724:     sqlite3_bind_int(pPages, 1, iRoot);",
          "6725:     sqlite3_bind_int(pCells, 2, pTab->iPk);",
          "6727:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){",
          "6728:       int iPgno = sqlite3_column_int(pPages, 0);",
          "6729:       sqlite3_bind_int(pCells, 1, iPgno);",
          "6730:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6731:         int nField = sqlite3_column_int(pCells, 0);",
          "6732:         const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6734:         nField = nField+1;",
          "6735:         if( pTab==pOrphan ){",
          "6736:           raw_printf(pState->out,",
          "6737:               \"INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\\n\",",
          "6738:               pTab->zQuoted, iRoot, iPgno, nField,",
          "6739:               bIntkey ? \"\" : \"NULL, \", zVal, pTab->azlCol[nField]",
          "6740:           );",
          "6741:         }else{",
          "6742:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6743:               pTab->zQuoted, pTab->azlCol[nField], zVal",
          "6744:           );",
          "6745:         }",
          "6746:       }",
          "6747:       shellReset(&rc, pCells);",
          "6748:     }",
          "6749:     shellReset(&rc, pPages);",
          "6750:     if( pTab!=pOrphan ) recoverFreeTable(pTab);",
          "6751:   }",
          "6752:   shellFinalize(&rc, pLoop);",
          "6753:   shellFinalize(&rc, pPages);",
          "6754:   shellFinalize(&rc, pCells);",
          "6755:   recoverFreeTable(pOrphan);",
          "6758:   if( rc==SQLITE_OK ){",
          "6759:     sqlite3_stmt *pStmt = 0;",
          "6760:     shellPrepare(pState->db, &rc,",
          "6761:         \"SELECT sql, name FROM recovery.schema \"",
          "6762:         \"WHERE sql NOT LIKE 'create table%'\", &pStmt",
          "6763:     );",
          "6764:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6765:       const char *zSql = (const char*)sqlite3_column_text(pStmt, 0);",
          "6766:       if( sqlite3_strnicmp(zSql, \"create virt\", 11)==0 ){",
          "6767:         const char *zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6768:         char *zPrint = shellMPrintf(&rc,",
          "6769:           \"INSERT INTO sqlite_master VALUES('table', %Q, %Q, 0, %Q)\",",
          "6770:           zName, zName, zSql",
          "6771:         );",
          "6772:         raw_printf(pState->out, \"%s;\\n\", zPrint);",
          "6773:         sqlite3_free(zPrint);",
          "6774:       }else{",
          "6775:         raw_printf(pState->out, \"%s;\\n\", zSql);",
          "6776:       }",
          "6777:     }",
          "6778:     shellFinalize(&rc, pStmt);",
          "6779:   }",
          "6781:   if( rc==SQLITE_OK ){",
          "6782:     raw_printf(pState->out, \"PRAGMA writable_schema = off;\\n\");",
          "6783:     raw_printf(pState->out, \"COMMIT;\\n\");",
          "6784:   }",
          "6785:   sqlite3_exec(pState->db, \"DETACH recovery\", 0, 0, 0);",
          "6786:   return rc;",
          "6787: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6313:     rc = shell_dbinfo_command(p, nArg, azArg);",
          "6314:   }else",
          "6316:   if( c=='d' && strncmp(azArg[0], \"dump\", n)==0 ){",
          "6317:     const char *zLike = 0;",
          "6318:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7077: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "7078:   if( c=='r' && strncmp(azArg[0], \"recover\", n)==0 ){",
          "7079:     open_db(p, 0);",
          "7080:     rc = recoverDatabaseCmd(p, nArg, azArg);",
          "7081:   }else",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6398:     }",
          "6399:     sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);",
          "6400:     sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);",
          "6402:     p->showHeader = savedShowHeader;",
          "6403:     p->shellFlgs = savedShellFlags;",
          "6404:   }else",
          "",
          "[Removed Lines]",
          "6401:     raw_printf(p->out, p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");",
          "",
          "[Added Lines]",
          "7171:     raw_printf(p->out, p->nErr?\"ROLLBACK; -- due to errors\\n\":\"COMMIT;\\n\");",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:   }",
          "196: #endif",
          "",
          "[Removed Lines]",
          "202: #define Stringify(P, enc) \\",
          "203:    if(((P)->flags&(MEM_Str|MEM_Blob))==0 && sqlite3VdbeMemStringify(P,enc,0)) \\",
          "204:      { goto no_mem; }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "522:     printf(p->flags & MEM_Zero ? \" NULL-nochng\" : \" NULL\");",
          "523:   }else if( (p->flags & (MEM_Int|MEM_Str))==(MEM_Int|MEM_Str) ){",
          "524:     printf(\" si:%lld\", p->u.i);",
          "525:   }else if( p->flags & MEM_Int ){",
          "526:     printf(\" i:%lld\", p->u.i);",
          "527: #ifndef SQLITE_OMIT_FLOATING_POINT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "517:   }else if( (p->flags & (MEM_Int|MEM_IntReal))==(MEM_Int|MEM_IntReal) ){",
          "518:     printf(\" ir:%lld\", p->u.i);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1468:   pIn1 = &aMem[pOp->p1];",
          "1469:   pIn2 = &aMem[pOp->p2];",
          "1470:   pOut = &aMem[pOp->p3];",
          "1471:   assert( pIn1!=pOut );",
          "1473:     sqlite3VdbeMemSetNull(pOut);",
          "1474:     break;",
          "1475:   }",
          "1479:   nByte = pIn1->n + pIn2->n;",
          "1480:   if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){",
          "1481:     goto too_big;",
          "",
          "[Removed Lines]",
          "1466:   i64 nByte;",
          "1472:   if( (pIn1->flags | pIn2->flags) & MEM_Null ){",
          "1476:   if( ExpandBlob(pIn1) || ExpandBlob(pIn2) ) goto no_mem;",
          "1477:   Stringify(pIn1, encoding);",
          "1478:   Stringify(pIn2, encoding);",
          "",
          "[Added Lines]",
          "1467:   testcase( pIn1==pIn2 );",
          "1468:   testcase( pOut==pIn2 );",
          "1470:   flags1 = pIn1->flags;",
          "1471:   testcase( flags1 & MEM_Null );",
          "1472:   testcase( pIn2->flags & MEM_Null );",
          "1473:   if( (flags1 | pIn2->flags) & MEM_Null ){",
          "1477:   if( (flags1 & (MEM_Str|MEM_Blob))==0 ){",
          "1478:     if( sqlite3VdbeMemStringify(pIn1,encoding,0) ) goto no_mem;",
          "1479:     flags1 = pIn1->flags & ~MEM_Str;",
          "1480:   }else if( (flags1 & MEM_Zero)!=0 ){",
          "1481:     if( sqlite3VdbeMemExpandBlob(pIn1) ) goto no_mem;",
          "1482:     flags1 = pIn1->flags & ~MEM_Str;",
          "1483:   }",
          "1484:   flags2 = pIn2->flags;",
          "1485:   if( (flags2 & (MEM_Str|MEM_Blob))==0 ){",
          "1486:     if( sqlite3VdbeMemStringify(pIn2,encoding,0) ) goto no_mem;",
          "1487:     flags2 = pIn2->flags & ~MEM_Str;",
          "1488:   }else if( (flags2 & MEM_Zero)!=0 ){",
          "1489:     if( sqlite3VdbeMemExpandBlob(pIn2) ) goto no_mem;",
          "1490:     flags2 = pIn2->flags & ~MEM_Str;",
          "1491:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1486:   MemSetTypeFlag(pOut, MEM_Str);",
          "1487:   if( pOut!=pIn2 ){",
          "1488:     memcpy(pOut->z, pIn2->z, pIn2->n);",
          "1489:   }",
          "1490:   memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);",
          "1491:   pOut->z[nByte]=0;",
          "1492:   pOut->z[nByte+1] = 0;",
          "1493:   pOut->flags |= MEM_Term;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1502:     assert( (pIn2->flags & MEM_Dyn) == (flags2 & MEM_Dyn) );",
          "1503:     pIn2->flags = flags2;",
          "1506:   assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );",
          "1507:   pIn1->flags = flags1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2765:   assert( pOp->p2>0 );",
          "2766:   assert( zAffinity[pOp->p2]==0 );",
          "2767:   pIn1 = &aMem[pOp->p1];",
          "2769:     assert( pIn1 <= &p->aMem[(p->nMem+1 - p->nCursor)] );",
          "2770:     assert( memIsValid(pIn1) );",
          "2772:     pIn1++;",
          "2774:   break;",
          "2775: }",
          "",
          "[Removed Lines]",
          "2768:   do{",
          "2771:     applyAffinity(pIn1, *(zAffinity++), encoding);",
          "2773:   }while( zAffinity[0] );",
          "",
          "[Added Lines]",
          "2785:   while( 1 /*edit-by-break*/ ){",
          "2788:     applyAffinity(pIn1, zAffinity[0], encoding);",
          "2789:     if( zAffinity[0]==SQLITE_AFF_REAL && (pIn1->flags & MEM_Int)!=0 ){",
          "2792:       pIn1->flags |= MEM_IntReal;",
          "2793:     }",
          "2794:     REGISTER_TRACE((int)(pIn1-aMem), pIn1);",
          "2795:     zAffinity++;",
          "2796:     if( zAffinity[0]==0 ) break;",
          "2798:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2933:       goto no_mem;",
          "2934:     }",
          "2935:   }",
          "2941:   assert( pData0<=pLast );",
          "2942:   pRec = pData0;",
          "2943:   do{",
          "2944:     serial_type = pRec->uTemp;",
          "2951:   }while( (++pRec)<=pLast );",
          "2955:   assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );",
          "2962:   REGISTER_TRACE(pOp->p3, pOut);",
          "2964:   break;",
          "2965: }",
          "",
          "[Removed Lines]",
          "2936:   zNewRecord = (u8 *)pOut->z;",
          "2939:   i = putVarint32(zNewRecord, nHdr);",
          "2940:   j = nHdr;",
          "2952:   assert( i==nHdr );",
          "2953:   assert( j==nByte );",
          "2956:   pOut->n = (int)nByte;",
          "2957:   pOut->flags = MEM_Blob;",
          "2958:   if( nZero ){",
          "2959:     pOut->u.nZero = nZero;",
          "2960:     pOut->flags |= MEM_Zero;",
          "2961:   }",
          "2963:   UPDATE_MAX_BLOBSIZE(pOut);",
          "",
          "[Added Lines]",
          "2960:   pOut->n = (int)nByte;",
          "2961:   pOut->flags = MEM_Blob;",
          "2962:   if( nZero ){",
          "2963:     pOut->u.nZero = nZero;",
          "2964:     pOut->flags |= MEM_Zero;",
          "2965:   }",
          "2966:   UPDATE_MAX_BLOBSIZE(pOut);",
          "2967:   zHdr = (u8 *)pOut->z;",
          "2968:   zPayload = zHdr + nHdr;",
          "2971:   zHdr += putVarint32(zHdr, nHdr);",
          "2983:   assert( nHdr==(int)(zHdr - (u8*)pOut->z) );",
          "2984:   assert( nByte==(int)(zPayload - (u8*)pOut->z) );",
          "",
          "---------------"
        ],
        "src/vdbeInt.h||src/vdbeInt.h": [
          "File: src/vdbeInt.h -> src/vdbeInt.h"
        ],
        "src/vdbemem.c||src/vdbemem.c": [
          "File: src/vdbemem.c -> src/vdbemem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "92: }",
          "93: #endif",
          "95: #ifdef SQLITE_DEBUG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99: static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){",
          "100:   StrAccum acc;",
          "101:   assert( p->flags & (MEM_Int|MEM_Real) );",
          "102:   sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);",
          "103:   if( p->flags & MEM_IntReal ){",
          "104:     sqlite3_str_appendf(&acc, \"%!.15g\", (double)p->u.i);",
          "105:   }else if( p->flags & MEM_Int ){",
          "106:     sqlite3_str_appendf(&acc, \"%lld\", p->u.i);",
          "107:   }else{",
          "108:     sqlite3_str_appendf(&acc, \"%!.15g\", p->u.r);",
          "109:   }",
          "110:   assert( acc.zText==zBuf && acc.mxAlloc<=0 );",
          "112: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118:   int i, j, incr;",
          "119:   if( (p->flags & MEM_Str)==0 ) return 1;",
          "120:   if( (p->flags & (MEM_Int|MEM_Real))==0 ) return 1;",
          "126:   z = p->z;",
          "127:   i = j = 0;",
          "128:   incr = 1;",
          "",
          "[Removed Lines]",
          "121:   if( p->flags & MEM_Int ){",
          "122:     sqlite3_snprintf(sizeof(zBuf),zBuf,\"%lld\",p->u.i);",
          "123:   }else{",
          "124:     sqlite3_snprintf(sizeof(zBuf),zBuf,\"%!.15g\",p->u.r);",
          "125:   }",
          "",
          "[Added Lines]",
          "140:   vdbeMemRenderNum(sizeof(zBuf), zBuf, p);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "248:   }",
          "249:   assert( (pMem->flags & MEM_Dyn)==0 );",
          "250:   pMem->z = pMem->zMalloc;",
          "252:   return SQLITE_OK;",
          "253: }",
          "",
          "[Removed Lines]",
          "251:   pMem->flags &= (MEM_Null|MEM_Int|MEM_Real);",
          "",
          "[Added Lines]",
          "266:   pMem->flags &= (MEM_Null|MEM_Int|MEM_Real|MEM_IntReal);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "351: int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce){",
          "353:   const int nByte = 32;",
          "355:   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );",
          "359:   assert( !sqlite3VdbeMemIsRowSet(pMem) );",
          "360:   assert( EIGHT_BYTE_ALIGNMENT(pMem) );",
          "",
          "[Removed Lines]",
          "352:   int fg = pMem->flags;",
          "356:   assert( !(fg&MEM_Zero) );",
          "357:   assert( !(fg&(MEM_Str|MEM_Blob)) );",
          "358:   assert( fg&(MEM_Int|MEM_Real) );",
          "",
          "[Added Lines]",
          "370:   assert( !(pMem->flags&MEM_Zero) );",
          "371:   assert( !(pMem->flags&(MEM_Str|MEM_Blob)) );",
          "372:   assert( pMem->flags&(MEM_Int|MEM_Real) );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "365:     return SQLITE_NOMEM_BKPT;",
          "366:   }",
          "380:   assert( pMem->z!=0 );",
          "381:   pMem->n = sqlite3Strlen30NN(pMem->z);",
          "382:   pMem->enc = SQLITE_UTF8;",
          "383:   pMem->flags |= MEM_Str|MEM_Term;",
          "385:   sqlite3VdbeChangeEncoding(pMem, enc);",
          "386:   return SQLITE_OK;",
          "387: }",
          "",
          "[Removed Lines]",
          "374:   if( fg & MEM_Int ){",
          "375:     sqlite3_snprintf(nByte, pMem->z, \"%lld\", pMem->u.i);",
          "376:   }else{",
          "377:     assert( fg & MEM_Real );",
          "378:     sqlite3_snprintf(nByte, pMem->z, \"%!.15g\", pMem->u.r);",
          "379:   }",
          "384:   if( bForce ) pMem->flags &= ~(MEM_Int|MEM_Real);",
          "",
          "[Added Lines]",
          "382:   vdbeMemRenderNum(nByte, pMem->z, pMem);",
          "387:   if( bForce ) pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "741:       pMem->flags |= (pMem->flags&MEM_Blob)>>3;",
          "742:       sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);",
          "743:       assert( pMem->flags & MEM_Str || pMem->db->mallocFailed );",
          "745:       break;",
          "746:     }",
          "747:   }",
          "",
          "[Removed Lines]",
          "744:       pMem->flags &= ~(MEM_Int|MEM_Real|MEM_Blob|MEM_Zero);",
          "",
          "[Added Lines]",
          "747:       pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal|MEM_Blob|MEM_Zero);",
          "",
          "---------------"
        ],
        "src/vtab.c||src/vtab.c": [
          "File: src/vtab.c -> src/vtab.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "841:     p = vtabDisconnectAll(db, pTab);",
          "842:     xDestroy = p->pMod->pModule->xDestroy;",
          "844:     rc = xDestroy(p->pVtab);",
          "846:     if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "844:     pTab->nTabRef++;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "849:       pTab->pVTable = 0;",
          "850:       sqlite3VtabUnlock(p);",
          "851:     }",
          "852:   }",
          "854:   return rc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "853:     sqlite3DeleteTable(db, pTab);",
          "",
          "---------------"
        ],
        "src/whereexpr.c||src/whereexpr.c": [
          "File: src/whereexpr.c -> src/whereexpr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "278:         if( sqlite3Isdigit(zNew[0])",
          "279:          || zNew[0]=='-'",
          "280:          || (zNew[0]+1=='0' && iTo==1)",
          "281:         ){",
          "282:           if( pLeft->op!=TK_COLUMN",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "280:          || zNew[0]=='+'",
          "",
          "---------------"
        ],
        "test/altertab3.test||test/altertab3.test": [
          "File: test/altertab3.test -> test/altertab3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:   ALTER TABLE Table0 RENAME Col0 TO Col0;",
          "143: }",
          "145: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145: #-------------------------------------------------------------------------",
          "146: reset_db",
          "147: do_execsql_test 7.1.0 {",
          "148:   CREATE TABLE t1(a,b,c);",
          "149:   CREATE TRIGGER AFTER INSERT ON t1 BEGIN",
          "150:     SELECT a, rank() OVER w1 FROM t1",
          "151:     WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1);",
          "152:   END;",
          "153: }",
          "155: do_execsql_test 7.1.2 {",
          "156:   ALTER TABLE t1 RENAME TO t1x;",
          "157:   SELECT sql FROM sqlite_master;",
          "158: } {",
          "159:   {CREATE TABLE \"t1x\"(a,b,c)}",
          "160:   {CREATE TRIGGER AFTER INSERT ON \"t1x\" BEGIN",
          "161:     SELECT a, rank() OVER w1 FROM \"t1x\"",
          "162:     WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1);",
          "163:   END}",
          "164: }",
          "166: do_execsql_test 7.2.1 {",
          "167:   DROP TRIGGER after;",
          "168:   CREATE TRIGGER AFTER INSERT ON t1x BEGIN",
          "169:     SELECT a, rank() OVER w1 FROM t1x",
          "170:     WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1 ORDER BY d);",
          "171:   END;",
          "172: }",
          "174: do_catchsql_test 7.2.2 {",
          "175:   ALTER TABLE t1x RENAME TO t1;",
          "176: } {1 {error in trigger AFTER: no such column: d}}",
          "",
          "---------------"
        ],
        "test/dbdata.test||test/dbdata.test": [
          "File: test/dbdata.test -> test/dbdata.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019-04-11",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this file is testing the sqlite_dbpage virtual table.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix dbdata",
          "19: ifcapable !vtab||!compound {",
          "20:   finish_test",
          "21:   return",
          "22: }",
          "23: if { [catch { db enable_load_extension 1 }]",
          "24:   || [catch { db eval { SELECT load_extension('../dbdata') } }]",
          "25: } {",
          "26:   finish_test",
          "27:   return",
          "28: }",
          "30: do_execsql_test 1.0 {",
          "31:   CREATE TABLE T1(a, b);",
          "32:   INSERT INTO t1(rowid, a ,b) VALUES(5, 'v', 'five');",
          "33:   INSERT INTO t1(rowid, a, b) VALUES(10, 'x', 'ten');",
          "34: }",
          "36: do_execsql_test 1.1 {",
          "37:   SELECT pgno, cell, field, quote(value) FROM sqlite_dbdata WHERE pgno=2;",
          "38: } {",
          "39:   2 0 -1 5",
          "40:   2 0  0 'v'",
          "41:   2 0  1 'five'",
          "42:   2 1 -1 10",
          "43:   2 1  0 'x'",
          "44:   2 1  1 'ten'",
          "45: }",
          "47: breakpoint",
          "48: do_execsql_test 1.2 {",
          "49:   SELECT pgno, cell, field, quote(value) FROM sqlite_dbdata;",
          "50: } {",
          "51:   1 0 -1 1",
          "52:   1 0 0 'table'",
          "53:   1 0 1 'T1'",
          "54:   1 0 2 'T1'",
          "55:   1 0 3 2",
          "56:   1 0 4 {'CREATE TABLE T1(a, b)'}",
          "57:   2 0 -1 5",
          "58:   2 0  0 'v'",
          "59:   2 0  1 'five'",
          "60:   2 1 -1 10",
          "61:   2 1  0 'x'",
          "62:   2 1  1 'ten'",
          "63: }",
          "65: set big [string repeat big 2000]",
          "66: do_execsql_test 1.3 {",
          "67:   INSERT INTO t1 VALUES(NULL, $big);",
          "68:   SELECT value FROM sqlite_dbdata WHERE pgno=2 AND cell=2 AND field=1;",
          "69: } $big",
          "71: do_execsql_test 1.4 {",
          "72:   DELETE FROM t1;",
          "73:   INSERT INTO t1 VALUES(NULL, randomblob(5050));",
          "74: }",
          "75: do_test 1.5 {",
          "76:   execsql {",
          "77:     SELECT quote(value) FROM sqlite_dbdata WHERE pgno=2 AND cell=0 AND field=1;",
          "78:   }",
          "79: } [db one {SELECT quote(b) FROM t1}]",
          "81: #-------------------------------------------------------------------------",
          "82: reset_db",
          "83: db enable_load_extension 1",
          "84: db eval { SELECT load_extension('../dbdata') }",
          "86: do_execsql_test 2.0 {",
          "87:   CREATE TABLE t1(a);",
          "88:   CREATE INDEX i1 ON t1(a);",
          "89:   WITH s(i) AS (",
          "90:     SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<10",
          "91:   )",
          "92:   INSERT INTO t1 SELECT randomblob(900) FROM s;",
          "93: }",
          "95: do_execsql_test 2.1 {",
          "96:   SELECT * FROM sqlite_dbptr WHERE pgno=2;",
          "97: } {",
          "98:   2 25   2 6   2 7   2 9   2 11   2 13   2 15   2 17   2 19   2 21",
          "99: }",
          "101: do_execsql_test 2.2 {",
          "102:   SELECT * FROM sqlite_dbptr WHERE pgno=3;",
          "103: } {",
          "104:   3 24   3 23",
          "105: }",
          "107: do_execsql_test 2.3 {",
          "108:   SELECT * FROM sqlite_dbptr",
          "109: } {",
          "110:   2 25   2 6   2 7   2 9   2 11   2 13   2 15   2 17   2 19   2 21",
          "111:   3 24   3 23",
          "112: }",
          "115: finish_test",
          "",
          "---------------"
        ],
        "test/fts4rename.test||test/fts4rename.test": [
          "File: test/fts4rename.test -> test/fts4rename.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 April 30",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #*************************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: source $testdir/fts3_common.tcl",
          "16: set ::testprefix fts4rename",
          "18: # If SQLITE_ENABLE_FTS3 is defined, omit this file.",
          "19: ifcapable !fts3 {",
          "20:   finish_test",
          "21:   return",
          "22: }",
          "24: do_execsql_test 1.0 {",
          "25:   CREATE VIRTUAL TABLE temp.t1 USING fts3(a);",
          "26:   BEGIN;",
          "27:   CREATE TABLE t2(x);",
          "28: } {}",
          "30: do_catchsql_test 1.1 {",
          "31:   ALTER TABLE t1_content RENAME c0a TO docid;",
          "32: } {1 {duplicate column name: docid}}",
          "34: do_catchsql_test 1.2 {",
          "35:   UPDATE t1 SET Col0 = 1 ;",
          "36: } {1 {no such column: Col0}}",
          "38: do_catchsql_test 1.3 {",
          "39:   ROLLBACK;",
          "40:   DROP TABLE t1;",
          "41: } {0 {}}",
          "43: finish_test",
          "",
          "---------------"
        ],
        "test/index.test||test/index.test": [
          "File: test/index.test -> test/index.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:   }",
          "739: } {0 {9 5 1}}",
          "743: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741: # 2019-05-01 ticket https://www.sqlite.org/src/info/3be1295b264be2fa",
          "742: do_execsql_test index-22.0 {",
          "743:   DROP TABLE IF EXISTS t1;",
          "744:   CREATE TABLE t1(a, b TEXT);",
          "745:   CREATE UNIQUE INDEX IF NOT EXISTS x1 ON t1(b==0);",
          "746:   CREATE INDEX IF NOT EXISTS x2 ON t1(a || 0) WHERE b;",
          "747:   INSERT INTO t1(a,b) VALUES('a',1),('a',0);",
          "748:   SELECT a, b, '|' FROM t1;",
          "749: } {a 1 | a 0 |}",
          "751: # 2019-05-10 ticket https://www.sqlite.org/src/info/ae0f637bddc5290b",
          "752: do_execsql_test index-23.0 {",
          "753:   DROP TABLE t1;",
          "754:   CREATE TABLE t1(a TEXT, b REAL);",
          "755:   CREATE UNIQUE INDEX t1x1 ON t1(a GLOB b);",
          "756:   INSERT INTO t1(a,b) VALUES('0.0','1'),('1.0','1');",
          "757:   SELECT * FROM t1;",
          "758:   REINDEX;",
          "759: } {0.0 1.0 1.0 1.0}",
          "",
          "---------------"
        ],
        "test/like3.test||test/like3.test": [
          "File: test/like3.test -> test/like3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:   `--SEARCH TABLE t5b USING COVERING INDEX sqlite_autoindex_t5b_1 (x>? AND x<?)",
          "179: }",
          "181: # 2019-02-27",
          "182: # Verify that the LIKE optimization works with an ESCAPE clause when",
          "183: # using PRAGMA case_sensitive_like=ON.",
          "184: #",
          "185: do_execsql_test like3-6.100 {",
          "186:   DROP TABLE IF EXISTS t1;",
          "187:   CREATE TABLE t1(path TEXT COLLATE nocase PRIMARY KEY,a,b,c) WITHOUT ROWID;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181: # 2019-05-01",
          "182: # another case of the above reported on the mailing list by Manual Rigger.",
          "183: #",
          "184: do_execsql_test like3-5.300 {",
          "185:   CREATE TABLE t5c (c0 REAL);",
          "186:   CREATE INDEX t5c_0 ON t5c(c0 COLLATE NOCASE);",
          "187:   INSERT INTO t5c(rowid, c0) VALUES (99,'+/');",
          "188:   SELECT * FROM t5c WHERE (c0 LIKE '+/');",
          "189: } {+/}",
          "195: ifcapable !icu {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "229:   QUERY PLAN",
          "230:   `--SEARCH TABLE t2 USING INDEX t2path2 (path>? AND path<?)",
          "231: }",
          "233: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243: }",
          "",
          "---------------"
        ],
        "test/oserror.test||test/oserror.test": [
          "File: test/oserror.test -> test/oserror.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: # an error may be reported for either open() or getcwd() here.",
          "53: #",
          "54: if {![clang_sanitize_address]} {",
          "55:   do_test 1.1.1 {",
          "56:     set ::log [list]",
          "61:   do_test 1.1.2 {",
          "67: }",
          "",
          "[Removed Lines]",
          "57:     list [catch {",
          "58:       for {set i 0} {$i < 20000} {incr i} { sqlite3 dbh_$i test.db -readonly 1 }",
          "59:     } msg] $msg",
          "60:   } {1 {unable to open database file}}",
          "62:     catch { for {set i 0} {$i < 20000} {incr i} { dbh_$i close } }",
          "63:   } {1}",
          "64:   do_re_test 1.1.3 {",
          "65:     lindex $::log 0",
          "66:   } {^os_unix.c:\\d+: \\(\\d+\\) (open|getcwd)\\(.*test.db\\) - }",
          "",
          "[Added Lines]",
          "55:   unset -nocomplain rc",
          "56:   unset -nocomplain nOpen",
          "57:   set nOpen 20000",
          "60:     set ::rc [catch {",
          "61:       for {set i 0} {$i < $::nOpen} {incr i} { sqlite3 dbh_$i test.db -readonly 1 }",
          "62:     } msg]",
          "63:     if {$::rc==0} {",
          "64:       # Some system (ex: Debian) are able to create 20000+ file descriptiors",
          "65:       # such systems will not fail here",
          "66:       set x ok",
          "67:     } elseif {$::rc==1 && $msg==\"unable to open database file\"} {",
          "68:       set x ok",
          "69:     } else {",
          "70:       set x [list $::rc $msg]",
          "71:     }",
          "72:   } {ok}",
          "74:     catch { for {set i 0} {$i < $::nOpen} {incr i} { dbh_$i close } }",
          "75:   } $::rc",
          "76:   if {$rc} {",
          "77:     do_re_test 1.1.3 {",
          "78:       lindex $::log 0",
          "79:     } {^os_unix.c:\\d+: \\(\\d+\\) (open|getcwd)\\(.*test.db\\) - }",
          "80:   }",
          "",
          "---------------"
        ],
        "test/recover.test||test/recover.test": [
          "File: test/recover.test -> test/recover.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 April 23",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # Test the shell tool \".ar\" command.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix recover",
          "19: ifcapable !vtab {",
          "20:   finish_test; return",
          "21: }",
          "22: set CLI [test_find_cli]",
          "24: proc compare_result {db1 db2 sql} {",
          "25:   set r1 [$db1 eval $sql]",
          "26:   set r2 [$db2 eval $sql]",
          "27:   if {$r1 != $r2} {",
          "28:   puts \"r1: $r1\"",
          "29:   puts \"r2: $r2\"",
          "30:     error \"mismatch for $sql\"",
          "31:   }",
          "32:   return \"\"",
          "33: }",
          "35: proc compare_dbs {db1 db2} {",
          "36:   compare_result $db1 $db2 \"SELECT sql FROM sqlite_master ORDER BY 1\"",
          "37:   foreach tbl [$db1 eval {SELECT name FROM sqlite_master WHERE type='table'}] {",
          "38:     compare_result $db1 $db2 \"SELECT * FROM $tbl\"",
          "39:   }",
          "40: }",
          "42: proc do_recover_test {tn {tsql {}} {res {}}} {",
          "43:   set fd [open \"|$::CLI test.db .recover\"]",
          "44:   fconfigure $fd -encoding binary",
          "45:   fconfigure $fd -translation binary",
          "46:   set sql [read $fd]",
          "47:   close $fd",
          "49:   forcedelete test.db2",
          "50:   sqlite3 db2 test.db2",
          "51:   execsql $sql db2",
          "52:   if {$tsql==\"\"} {",
          "53:     uplevel [list do_test $tn [list compare_dbs db db2] {}]",
          "54:   } else {",
          "55:     uplevel [list do_execsql_test -db db2 $tn $tsql $res]",
          "56:   }",
          "57:   db2 close",
          "58: }",
          "60: set doc {",
          "61:   hello",
          "62:   world",
          "63: }",
          "64: do_execsql_test 1.1.1 {",
          "65:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "66:   INSERT INTO t1 VALUES(1, 4, X'1234567800');",
          "67:   INSERT INTO t1 VALUES(2, 'test', 8.1);",
          "68:   INSERT INTO t1 VALUES(3, $doc, 8.4);",
          "69: }",
          "70: do_recover_test 1.1.2",
          "72: do_execsql_test 1.2.1 \"",
          "73:   DELETE FROM t1;",
          "74:   INSERT INTO t1 VALUES(13, 'hello\\r\\nworld', 13);",
          "75: \"",
          "76: do_recover_test 1.2.2",
          "78: do_execsql_test 1.3.1 \"",
          "79:   CREATE TABLE t2(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "80:   INSERT INTO t2 VALUES(NULL, 1, 2);",
          "81:   INSERT INTO t2 VALUES(NULL, 3, 4);",
          "82:   INSERT INTO t2 VALUES(NULL, 5, 6);",
          "83:   CREATE TABLE t3(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "84:   INSERT INTO t3 VALUES(NULL, 1, 2);",
          "85:   INSERT INTO t3 VALUES(NULL, 3, 4);",
          "86:   INSERT INTO t3 VALUES(NULL, 5, 6);",
          "87:   DELETE FROM t2;",
          "88: \"",
          "89: do_recover_test 1.3.2",
          "91: #-------------------------------------------------------------------------",
          "92: reset_db",
          "93: do_execsql_test 2.1.0 {",
          "94:   PRAGMA auto_vacuum = 0;",
          "95:   CREATE TABLE t1(a, b, c, PRIMARY KEY(b, c)) WITHOUT ROWID;",
          "96:   INSERT INTO t1 VALUES(1, 2, 3);",
          "97:   INSERT INTO t1 VALUES(4, 5, 6);",
          "98:   INSERT INTO t1 VALUES(7, 8, 9);",
          "99: }",
          "101: do_recover_test 2.1.1",
          "103: do_execsql_test 2.2.0 {",
          "104:   PRAGMA writable_schema = 1;",
          "105:   DELETE FROM sqlite_master WHERE name='t1';",
          "106: }",
          "107: do_recover_test 2.2.1 {",
          "108:   SELECT name FROM sqlite_master",
          "109: } {lost_and_found}",
          "111: do_execsql_test 2.3.0 {",
          "112:   CREATE TABLE lost_and_found(a, b, c);",
          "113: }",
          "114: do_recover_test 2.3.1 {",
          "115:   SELECT name FROM sqlite_master",
          "116: } {lost_and_found lost_and_found_0}",
          "118: do_execsql_test 2.4.0 {",
          "119:   CREATE TABLE lost_and_found_0(a, b, c);",
          "120: }",
          "121: do_recover_test 2.4.1 {",
          "122:   SELECT name FROM sqlite_master;",
          "123:   SELECT * FROM lost_and_found_1;",
          "124: } {lost_and_found lost_and_found_0 lost_and_found_1",
          "125:   2 2 3 {} 2 3 1",
          "126:   2 2 3 {} 5 6 4",
          "127:   2 2 3 {} 8 9 7",
          "128: }",
          "130: finish_test",
          "",
          "---------------"
        ],
        "test/wapptest.tcl||test/wapptest.tcl": [
          "File: test/wapptest.tcl -> test/wapptest.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #",
          "21: set G(platform) $::tcl_platform(os)-$::tcl_platform(machine)",
          "22: set G(test)     Normal",
          "25: set G(tcl)      [::tcl::pkgconfig get libdir,install]",
          "26: set G(jobs)     3",
          "27: set G(debug)    0",
          "",
          "[Removed Lines]",
          "23: set G(keep)     0",
          "24: set G(msvc)     0",
          "",
          "[Added Lines]",
          "23: set G(keep)     1",
          "24: set G(msvc)     [expr {$::tcl_platform(platform)==\"windows\"}]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37:   # The root of the SQLite source tree.",
          "38:   set G(srcdir)   [file dirname [file dirname [info script]]]",
          "43:   set G(sqlite_version) \"unknown\"",
          "45:   # Either \"config\", \"running\" or \"stopped\":",
          "",
          "[Removed Lines]",
          "40:   # releasetest.tcl script",
          "41:   set G(releaseTest) [file join [file dirname [info script]] releasetest.tcl]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:   append G(host) \" $::tcl_platform(machine) $::tcl_platform(byteOrder)\"",
          "53: }",
          "57: #",
          "70: proc generate_fossil_info {} {",
          "71:   global G",
          "72:   set pwd [pwd]",
          "73:   cd $G(srcdir)",
          "76:   cd $pwd",
          "78:   foreach line [split $r1 \"\\n\"] {",
          "79:     if {[regexp {^checkout: *(.*)$} $line -> co]} {",
          "",
          "[Removed Lines]",
          "55: # Check to see if there are uncommitted changes in the SQLite source",
          "56: # directory. Return true if there are, or false otherwise.",
          "58: proc check_uncommitted {} {",
          "59:   global G",
          "60:   set ret 0",
          "61:   set pwd [pwd]",
          "62:   cd $G(srcdir)",
          "63:   if {[catch {exec fossil changes} res]==0 && [string trim $res]!=\"\"} {",
          "64:     set ret 1",
          "65:   }",
          "66:   cd $pwd",
          "67:   return $ret",
          "68: }",
          "74:   if {[catch {exec fossil info}    r1]} return",
          "75:   if {[catch {exec fossil changes} r2]} return",
          "",
          "[Added Lines]",
          "52: # Generate the text for the box at the top of the UI. The current SQLite",
          "53: # version, according to fossil, along with a warning if there are",
          "54: # uncommitted changes in the checkout.",
          "60:   set rc [catch {",
          "61:     set r1 [exec fossil info]",
          "62:     set r2 [exec fossil changes]",
          "63:   }]",
          "65:   if {$rc} return",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "208:   }",
          "209: }",
          "211: proc slave_test_done {name rc} {",
          "212:   global G",
          "213:   set G(test.$name.done) [clock seconds]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200: # This command is invoked once a slave process has finished running its",
          "201: # tests, successfully or otherwise. Parameter $name is the name of the",
          "202: # test, $rc the exit code returned by the slave process.",
          "203: #",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "220:   if {[file exists $G(test.$name.log)]} {",
          "221:     count_tests_and_errors $name $G(test.$name.log)",
          "222:   }",
          "223: }",
          "225: proc slave_fileevent {name} {",
          "226:   global G",
          "227:   set fd $G(test.$name.channel)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217:   # If the \"keep files\" checkbox is clear, delete all files except for",
          "218:   # the executables and test logs. And any core file that is present.",
          "219:   if {$G(keep)==0} {",
          "220:     set keeplist {",
          "221:       testfixture testfixture.exe",
          "222:       sqlite3 sqlite3.exe",
          "223:       test.log test-out.txt",
          "224:       core",
          "225:       wapptest_make.sh",
          "226:       wapptest_configure.sh",
          "227:       wapptest_run.tcl",
          "228:     }",
          "229:     foreach f [glob -nocomplain [file join $G(test.$name.dir) *]] {",
          "230:       set t [file tail $f]",
          "231:       if {[lsearch $keeplist $t]<0} {",
          "232:         catch { file delete -force $f }",
          "233:       }",
          "234:     }",
          "235:   }",
          "238: # This is a fileevent callback invoked each time a file-descriptor that",
          "239: # connects this process to a slave process is readable.",
          "240: #",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "239:   do_some_stuff",
          "240: }",
          "242: proc do_some_stuff {} {",
          "243:   global G",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "258: # Return the contents of the \"slave script\" - the script run by slave",
          "259: # processes to actually perform the test. It does two things:",
          "260: #",
          "261: #   1. Reads and [exec]s the contents of file wapptest_configure.sh.",
          "262: #   2. Reads and [exec]s the contents of file wapptest_make.sh.",
          "263: #",
          "264: # Step 1 is omitted if the test uses MSVC (which does not use configure).",
          "265: #",
          "266: proc wapptest_slave_script {} {",
          "267:   global G",
          "268:   set res {",
          "269:     proc readfile {filename} {",
          "270:       set fd [open $filename]",
          "271:       set data [read $fd]",
          "272:       close $fd",
          "273:       return $data",
          "274:     }",
          "275:   }",
          "277:   if {$G(msvc)==0} {",
          "278:     append res {",
          "279:       set cfg  [readfile wapptest_configure.sh]",
          "280:       set rc [catch { exec {*}$cfg >& test.log } msg]",
          "281:       if {$rc==0} {",
          "282:         set make [readfile wapptest_make.sh]",
          "283:         set rc [catch { exec {*}$make >>& test.log }]",
          "284:       }",
          "285:     }",
          "286:   } else {",
          "287:     append res {",
          "288:       set make [readfile wapptest_make.sh]",
          "289:       set rc [catch { exec {*}$make >>& test.log }]",
          "290:     }",
          "291:   }",
          "293:   append res { exit $rc }",
          "295:   set res",
          "296: }",
          "299: # Launch a slave process to run a test.",
          "300: #",
          "301: proc slave_launch {",
          "302:   name wtcl title dir configOpts testtarget makeOpts cflags opts",
          "303: } {",
          "304:   global G",
          "306:   catch { file mkdir $dir } msg",
          "307:   foreach f [glob -nocomplain [file join $dir *]] {",
          "308:     catch { file delete -force $f }",
          "309:   }",
          "310:   set G(test.$name.dir) $dir",
          "312:   # Write the configure command to wapptest_configure.sh. This file",
          "313:   # is empty if using MSVC - MSVC does not use configure.",
          "314:   #",
          "315:   set fd1 [open [file join $dir wapptest_configure.sh] w]",
          "316:   if {$G(msvc)==0} {",
          "317:     puts $fd1 \"[file join .. $G(srcdir) configure] $wtcl $configOpts\"",
          "318:   }",
          "319:   close $fd1",
          "321:   # Write the make command to wapptest_make.sh. Using nmake for MSVC and",
          "322:   # make for all other systems.",
          "323:   #",
          "324:   set makecmd \"make\"",
          "325:   if {$G(msvc)} {",
          "326:     set nativedir [file nativename $G(srcdir)]",
          "327:     set nativedir [string map [list \"\\\\\" \"\\\\\\\\\"] $nativedir]",
          "328:     set makecmd \"nmake /f [file join $nativedir Makefile.msc] TOP=$nativedir\"",
          "329:   }",
          "330:   set fd2 [open [file join $dir wapptest_make.sh] w]",
          "331:   puts $fd2 \"$makecmd $makeOpts $testtarget \\\"CFLAGS=$cflags\\\" \\\"OPTS=$opts\\\"\"",
          "332:   close $fd2",
          "334:   # Write the wapptest_run.tcl script to the test directory. To run the",
          "335:   # commands in the other two files.",
          "336:   #",
          "337:   set fd3 [open [file join $dir wapptest_run.tcl] w]",
          "338:   puts $fd3 [wapptest_slave_script]",
          "339:   close $fd3",
          "341:   set pwd [pwd]",
          "342:   cd $dir",
          "343:   set fd [open \"|[info nameofexecutable] wapptest_run.tcl\" r+]",
          "344:   cd $pwd",
          "346:   set G(test.$name.channel) $fd",
          "347:   fconfigure $fd -blocking 0",
          "348:   fileevent $fd readable [list slave_fileevent $name]",
          "349: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "275:       if { ![info exists G(test.$name.channel)]",
          "276:         && ![info exists G(test.$name.done)]",
          "277:       } {",
          "278:         set target [dict get $j target]",
          "279:         set G(test.$name.start) [clock seconds]",
          "287:         set wtcl \"\"",
          "288:         if {$G(tcl)!=\"\"} { set wtcl \"--with-tcl=$G(tcl)\" }",
          "",
          "[Removed Lines]",
          "280:         set fd [open \"|[info nameofexecutable] $G(releaseTest) --slave\" r+]",
          "281:         set G(test.$name.channel) $fd",
          "282:         fconfigure $fd -blocking 0",
          "283:         fileevent $fd readable [list slave_fileevent $name]",
          "285:         puts $fd [list 0 $G(msvc) 0 $G(keep)]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "303:         }",
          "305:         set L [make_test_suite $G(msvc) $wtcl $name $target $opts]",
          "308:         set G(test.$name.log) [file join [lindex $L 1] test.log]",
          "309:         incr nLaunch -1",
          "310:       }",
          "",
          "[Removed Lines]",
          "306:         puts $fd $L",
          "307:         flush $fd",
          "",
          "[Added Lines]",
          "409:         set G(test.$name.log) [file join [lindex $L 1] test.log]",
          "410:         slave_launch $name $wtcl {*}$L",
          "",
          "---------------"
        ],
        "test/without_rowid1.test||test/without_rowid1.test": [
          "File: test/without_rowid1.test -> test/without_rowid1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "391:   SELECT * FROM t1;",
          "392: } {b a 3  b b 4}",
          "395: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "394: # 2019-04-29 ticket https://www.sqlite.org/src/info/3182d3879020ef3",
          "395: do_execsql_test 11.1 {",
          "396:   CREATE TABLE t11(a TEXT PRIMARY KEY, b INT) WITHOUT ROWID;",
          "397:   CREATE INDEX t11a ON t11(a COLLATE NOCASE);",
          "398:   INSERT INTO t11(a,b) VALUES ('A',1),('a',2);",
          "399:   PRAGMA integrity_check;",
          "400:   SELECT a FROM t11 ORDER BY a COLLATE binary;",
          "401: } {ok A a}",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3848:           ErrorMsg(lemp->filename,rp->ruleline,",
          "3849:             \"%s(%s) has the same label as the LHS but is not the left-most \"",
          "3850:             \"symbol on the RHS.\",",
          "3852:           lemp->errorcnt++;",
          "3853:         }",
          "3854:         for(j=0; j<i; j++){",
          "",
          "[Removed Lines]",
          "3851:             rp->rhs[i]->name, rp->rhsalias);",
          "",
          "[Added Lines]",
          "3851:             rp->rhs[i]->name, rp->rhsalias[i]);",
          "",
          "---------------"
        ],
        "tool/mkshellc.tcl||tool/mkshellc.tcl": [
          "File: tool/mkshellc.tcl -> tool/mkshellc.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   }",
          "41:   return $line",
          "42: }",
          "43: while {1} {",
          "44:   set lx [omit_redundant_typedefs [gets $in]]",
          "45:   if {[eof $in]} break;",
          "46:   if {[regexp {^INCLUDE } $lx]} {",
          "47:     set cfile [lindex $lx 1]",
          "48:     puts $out \"/************************* Begin $cfile ******************/\"",
          "49:     set in2 [open $topdir/src/$cfile rb]",
          "50:     while {![eof $in2]} {",
          "51:       set lx [omit_redundant_typedefs [gets $in2]]",
          "53:       if {[regexp {^# *include \"test_windirent.h\"} $lx]} {",
          "54:         set lx \"/* $lx */\"",
          "55:       }",
          "",
          "[Removed Lines]",
          "52:       if {[regexp {^#include \"sqlite} $lx]} continue",
          "",
          "[Added Lines]",
          "43: set iLine 0",
          "47:   incr iLine",
          "51: #   puts $out \"#line 1 \\\"$cfile\\\"\"",
          "55:       if {[regexp {^#include \"sqlite} $lx]} {",
          "56:         set lx \"/* $lx */\"",
          "57:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     }",
          "59:     close $in2",
          "60:     puts $out \"/************************* End $cfile ********************/\"",
          "61:     continue",
          "62:   }",
          "63:   puts $out $lx",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: #   puts $out \"#line [expr $iLine+1] \\\"shell.c.in\\\"\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-25299",
  "cve_desc": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.",
  "repo": "cesanta/mongoose",
  "patch_hash": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
  "patch_info": {
    "commit_hash": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
    "files": [
      "Makefile",
      "mongoose.c",
      "src/http.c",
      "test/unit_test.c"
    ],
    "message": "Protect against the directory traversal in mg_upload()",
    "before_after_code_files": [
      "mongoose.c||mongoose.c",
      "src/http.c||src/http.c",
      "test/unit_test.c||test/unit_test.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1142:   return buf;",
      "1143: }",
      "1173: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
      "1174:                       void *fn_data) {",
      "1175:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
      "",
      "[Removed Lines]",
      "1145: #if MG_ENABLE_FILE",
      "1146: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "1147:                    const char *dir) {",
      "1148:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "1149:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "1150:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "1151:   if (name[0] == '\\0') {",
      "1152:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "1153:     return -1;",
      "1154:   } else {",
      "1155:     FILE *fp;",
      "1156:     size_t oft = strtoul(offset, NULL, 0);",
      "1157:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "1158:     LOG(LL_DEBUG,",
      "1159:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
      "1160:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "1161:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
      "1162:       return -2;",
      "1163:     } else {",
      "1164:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "1165:       fclose(fp);",
      "1166:       mg_http_reply(c, 200, \"\", \"\");",
      "1167:       return (int) hm->body.len;",
      "1168:     }",
      "1169:   }",
      "1170: }",
      "1171: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1680:   c->recv.len -= ch.len;",
      "1681: }",
      "1683: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
      "1684:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
      "1685:     struct mg_http_message hm;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1655: #if MG_ENABLE_FILE",
      "1656: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "1657:                    const char *dir) {",
      "1658:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "1659:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "1660:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "1661:   if (name[0] == '\\0') {",
      "1662:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "1663:     return -1;",
      "1664:   } else {",
      "1665:     FILE *fp;",
      "1666:     long oft = strtol(offset, NULL, 0);",
      "1667:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "1668:     remove_double_dots(path);",
      "1669:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
      "1670:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "1671:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
      "1672:       return -2;",
      "1673:     } else {",
      "1674:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "1675:       fclose(fp);",
      "1676:       mg_http_reply(c, 200, \"\", \"\");",
      "1677:       return (int) hm->body.len;",
      "1678:     }",
      "1679:   }",
      "1680: }",
      "1681: #endif",
      "",
      "---------------"
    ],
    "src/http.c||src/http.c": [
      "File: src/http.c -> src/http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "378:   return buf;",
      "379: }",
      "409: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
      "410:                       void *fn_data) {",
      "411:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
      "",
      "[Removed Lines]",
      "381: #if MG_ENABLE_FILE",
      "382: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "383:                    const char *dir) {",
      "384:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "385:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "386:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "387:   if (name[0] == '\\0') {",
      "388:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "389:     return -1;",
      "390:   } else {",
      "391:     FILE *fp;",
      "392:     size_t oft = strtoul(offset, NULL, 0);",
      "393:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "394:     LOG(LL_DEBUG,",
      "395:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
      "396:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "397:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
      "398:       return -2;",
      "399:     } else {",
      "400:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "401:       fclose(fp);",
      "402:       mg_http_reply(c, 200, \"\", \"\");",
      "403:       return (int) hm->body.len;",
      "404:     }",
      "405:   }",
      "406: }",
      "407: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "916:   c->recv.len -= ch.len;",
      "917: }",
      "919: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
      "920:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
      "921:     struct mg_http_message hm;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "891: #if MG_ENABLE_FILE",
      "892: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "893:                    const char *dir) {",
      "894:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "895:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "896:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "897:   if (name[0] == '\\0') {",
      "898:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "899:     return -1;",
      "900:   } else {",
      "901:     FILE *fp;",
      "902:     long oft = strtol(offset, NULL, 0);",
      "903:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "904:     remove_double_dots(path);",
      "905:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
      "906:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "907:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
      "908:       return -2;",
      "909:     } else {",
      "910:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "911:       fclose(fp);",
      "912:       mg_http_reply(c, 200, \"\", \"\");",
      "913:       return (int) hm->body.len;",
      "914:     }",
      "915:   }",
      "916: }",
      "917: #endif",
      "",
      "---------------"
    ],
    "test/unit_test.c||test/unit_test.c": [
      "File: test/unit_test.c -> test/unit_test.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "698:     remove(\"uploaded.txt\");",
      "699:   }",
      "702:   ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);",
      "703:   ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "700:   {",
      "702:     char *p;",
      "703:     remove(\"uploaded.txt\");",
      "704:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);",
      "705:     ASSERT(fetch(&mgr, buf, url,",
      "706:                  \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"",
      "707:                  \"Content-Length: 5\\r\\n\"",
      "708:                  \"\\r\\nhello\") == 200);",
      "709:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);",
      "710:     ASSERT(strcmp(p, \"hello\") == 0);",
      "711:     free(p);",
      "712:     remove(\"uploaded.txt\");",
      "713:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9346122c296871a6d12858990c66bd75b32b7170",
      "candidate_info": {
        "commit_hash": "9346122c296871a6d12858990c66bd75b32b7170",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/9346122c296871a6d12858990c66bd75b32b7170",
        "files": [
          "mongoose.c",
          "mongoose.h",
          "src/fs.c",
          "src/fs.h",
          "src/fs_packed.c",
          "src/fs_posix.c",
          "src/http.c",
          "src/http.h",
          "test/mongoose_custom.h",
          "test/unit_test.c"
        ],
        "message": "Add FS API layer",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/fs.c||src/fs.c",
          "src/fs.h||src/fs.h",
          "src/fs_packed.c||src/fs_packed.c",
          "src/fs_posix.c||src/fs_posix.c",
          "src/http.c||src/http.c",
          "src/http.h||src/http.h",
          "test/mongoose_custom.h||test/mongoose_custom.h",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "407: }",
          "409: #ifdef MG_ENABLE_LINES",
          "411: #endif",
          "",
          "[Removed Lines]",
          "410: #line 1 \"src/fs.c\"",
          "",
          "[Added Lines]",
          "410: #line 1 \"src/fs_packed.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "423:   return NULL;",
          "424: }",
          "433: }",
          "438: }",
          "453: }",
          "463:   size_t size = 0;",
          "464:   const char *data = mg_unpack(path, &size);",
          "465:   if (data == NULL) return NULL;",
          "470: }",
          "471: #else",
          "474:   return NULL;",
          "475: }",
          "476: #endif",
          "478: #ifdef MG_ENABLE_LINES",
          "479: #line 1 \"src/http.c\"",
          "480: #endif",
          "",
          "[Removed Lines]",
          "426: #if defined(MG_FOPENCOOKIE)",
          "427: ssize_t packed_read(void *cookie, char *buf, size_t size) {",
          "428:   struct packed_file *fp = (struct packed_file *) cookie;",
          "429:   if (size > fp->size - fp->pos) size = fp->size - fp->pos;",
          "430:   memcpy(buf, &fp->data[fp->pos], size);",
          "431:   fp->pos += size;",
          "432:   return (ssize_t) size;",
          "435: ssize_t packed_write(void *cookie, const char *buf, size_t size) {",
          "436:   (void) cookie, (void) buf, (void) size;",
          "437:   return -1;",
          "440: int packed_seek(void *cookie, long *offset, int whence) {",
          "441:   struct packed_file *fp = (struct packed_file *) cookie;",
          "442:   if (whence == SEEK_SET) fp->pos = (size_t) *offset;",
          "443:   if (whence == SEEK_END) fp->pos = (size_t)((long) fp->size + *offset);",
          "444:   if (whence == SEEK_CUR) fp->pos = (size_t)((long) fp->pos + *offset);",
          "445:   if (fp->pos > fp->size) fp->pos = fp->size;",
          "447:   return 0;",
          "448: }",
          "450: int packed_close(void *cookie) {",
          "451:   free(cookie);",
          "452:   return 0;",
          "455: FILE *mg_fopen_packed(const char *path, const char *mode) {",
          "456:   cookie_io_functions_t funcs = {",
          "457:       .read = packed_read,",
          "458:       .write = packed_write,",
          "459:       .seek = packed_seek,",
          "460:       .close = packed_close,",
          "461:   };",
          "462:   struct packed_file *cookie = NULL;",
          "466:   if ((cookie = calloc(1, sizeof(*cookie))) == NULL) return NULL;",
          "467:   cookie->data = data;",
          "468:   cookie->size = size;",
          "469:   return fopencookie(cookie, mode, funcs);",
          "472: FILE *mg_fopen_packed(const char *path, const char *mode) {",
          "473:   (void) path, (void) mode;",
          "",
          "[Added Lines]",
          "426: static char *packed_realpath(const char *path, char *resolved_path) {",
          "427:   if (resolved_path == NULL) resolved_path = malloc(strlen(path) + 1);",
          "428:   strcpy(resolved_path, path);",
          "429:   return resolved_path;",
          "432: static int packed_stat(const char *path, size_t *size, unsigned *mtime) {",
          "433:   const char *data = mg_unpack(path, size);",
          "434:   if (mtime) *mtime = 0;",
          "435:   return data == NULL ? 0 : MG_FS_READ;",
          "438: static void packed_list(const char *path, void (*fn)(const char *, void *),",
          "439:                         void *userdata) {",
          "440:   (void) path, (void) fn, (void) userdata;",
          "443: static struct mg_fd *packed_open(const char *path, int flags) {",
          "446:   struct packed_file *fp = NULL;",
          "447:   struct mg_fd *fd = NULL;",
          "449:   if (flags & MG_FS_WRITE) return NULL;",
          "450:   fp = calloc(1, sizeof(*fp));",
          "451:   fd = calloc(1, sizeof(*fd));",
          "452:   fp->size = size;",
          "453:   fp->data = data;",
          "454:   fd->fd = fp;",
          "455:   fd->fs = &mg_fs_packed;",
          "456:   return fd;",
          "457: }",
          "459: static void packed_close(struct mg_fd *fd) {",
          "460:   if (fd) free(fd->fd), free(fd);",
          "461: }",
          "463: static size_t packed_read(void *fd, void *buf, size_t len) {",
          "464:   struct packed_file *fp = (struct packed_file *) fd;",
          "465:   if (fp->pos + len > fp->size) len = fp->size - fp->pos;",
          "466:   memcpy(buf, &fp->data[fp->pos], len);",
          "467:   fp->pos += len;",
          "468:   return len;",
          "469: }",
          "471: static size_t packed_write(void *fd, const void *buf, size_t len) {",
          "472:   (void) fd, (void) buf, (void) len;",
          "473:   return 0;",
          "474: }",
          "476: static size_t packed_seek(void *fd, size_t offset) {",
          "477:   struct packed_file *fp = (struct packed_file *) fd;",
          "478:   fp->pos = offset;",
          "479:   if (fp->pos > fp->size) fp->pos = fp->size;",
          "480:   return fp->pos;",
          "481: }",
          "483: struct mg_fs mg_fs_packed = {packed_realpath, packed_stat,  packed_list,",
          "484:                              packed_open,     packed_close, packed_read,",
          "485:                              packed_write,    packed_seek};",
          "487: #ifdef MG_ENABLE_LINES",
          "488: #line 1 \"src/fs_posix.c\"",
          "489: #endif",
          "492: #if defined(O_READ)",
          "493: static char *posix_realpath(const char *path, char *resolved_path) {",
          "494: #ifdef _WIN32",
          "495:   return _fullpath(path, resolved_path, PATH_MAX);",
          "496: #else",
          "497:   return realpath(path, resolved_path);",
          "498: #endif",
          "499: }",
          "501: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "502: #ifdef _WIN32",
          "503:   struct _stati64 st;",
          "504:   wchar_t tmp[PATH_MAX];",
          "505:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "506:   if (_wstati64(tmp, &st) != 0) return 0;",
          "507: #else",
          "508:   struct stat st;",
          "509:   if (stat(path, &st) != 0) return 0;",
          "510: #endif",
          "511:   if (size) *size = (size_t) st.st_size;",
          "512:   if (mtime) *mtime = (unsigned) st.st_mtime;",
          "513:   return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);",
          "514: }",
          "516: static void posix_list(const char *dir, void (*fn)(const char *, void *),",
          "517:                        void *userdata) {",
          "519:   struct dirent *dp;",
          "520:   DIR *dirp;",
          "523:   if ((dirp = (opendir(dir))) != NULL) {",
          "524:     size_t off, n;",
          "525:     while ((dp = readdir(dirp)) != NULL) {",
          "527:       if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "528:       fn(dp->d_name, &st);",
          "529:     }",
          "530:     closedir(dirp);",
          "531:   }",
          "532: }",
          "534: static struct mg_fd *posix_open(const char *path, int flags) {",
          "535:   const char *mode =",
          "536:       flags & (MG_FS_READ | MG_FS_WRITE)",
          "537:           ? \"r+b\"",
          "538:           : flags & MG_FS_READ ? \"rb\" : flags & MG_FS_WRITE ? \"wb\" : \"\";",
          "539:   void *fp = NULL;",
          "540:   struct mg_fd *fd = NULL;",
          "541: #ifdef _WIN32",
          "542:   wchar_t b1[PATH_MAX], b2[10];",
          "543:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "544:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "545:   fp = (void *) _wfopen(b1, b2);",
          "546: #else",
          "547:   fp = (void *) fopen(path, mode);",
          "548: #endif",
          "549:   if (fp == NULL) return NULL;",
          "550:   fd = calloc(1, sizeof(*fd));",
          "551:   fd->fd = fp;",
          "552:   fd->fs = &mg_fs_posix;",
          "553:   return fd;",
          "554: }",
          "556: static void posix_close(struct mg_fd *fd) {",
          "557:   if (fd) fclose((FILE *) fd->fd), free(fd);",
          "558: }",
          "560: static size_t posix_read(void *fp, void *buf, size_t len) {",
          "561:   return fread(buf, 1, len, (FILE *) fp);",
          "562: }",
          "564: static size_t posix_write(void *fp, const void *buf, size_t len) {",
          "565:   return fwrite(buf, 1, len, (FILE *) fp);",
          "568: static size_t posix_seek(void *fp, size_t offset) {",
          "569: #if _FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE >= 200112L || \\",
          "570:     _XOPEN_SOURCE >= 600",
          "571:   fseeko((FILE *) fp, (off_t) offset, SEEK_SET);",
          "573:   fseek((FILE *) fp, (long) offset, SEEK_SET);",
          "574: #endif",
          "575:   return (size_t) ftell((FILE *) fp);",
          "576: }",
          "577: #else",
          "578: static char *posix_realpath(const char *path, char *resolved_path) {",
          "579:   (void) path, (void) resolved_path;",
          "583: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "584:   (void) path, (void) size, (void) mtime;",
          "585:   return 0;",
          "586: }",
          "588: static void posix_list(const char *path, void (*fn)(const char *, void *),",
          "589:                        void *userdata) {",
          "590:   (void) path, (void) fn, (void) userdata;",
          "591: }",
          "593: static struct mg_fd *posix_open(const char *path, int flags) {",
          "594:   (void) path, (void) flags;",
          "595:   return NULL;",
          "596: }",
          "598: static void posix_close(struct mg_fd *fd) {",
          "599:   (void) fd;",
          "600: }",
          "602: static size_t posix_read(void *fd, void *buf, size_t len) {",
          "603:   (void) fd, (void) buf, (void) len;",
          "604:   return 0;",
          "605: }",
          "607: static size_t posix_write(void *fd, const void *buf, size_t len) {",
          "608:   (void) fd, (void) buf, (void) len;",
          "609:   return 0;",
          "610: }",
          "612: static size_t posix_seek(void *fd, size_t offset) {",
          "613:   (void) fd, (void) offset;",
          "614:   return (size_t) ~0;",
          "615: }",
          "618: struct mg_fs mg_fs_posix = {posix_realpath, posix_stat,  posix_list,",
          "619:                             posix_open,     posix_close, posix_read,",
          "620:                             posix_write,    posix_seek};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "900:   (void) ev_data;",
          "901: }",
          "968:   }",
          "970: }",
          "972: static int getrange(struct mg_str *s, int64_t *a, int64_t *b) {",
          "",
          "[Removed Lines]",
          "903: static const char *guess_content_type(const char *filename) {",
          "904:   size_t n = strlen(filename);",
          "905: #define MIME_ENTRY(_ext, _type) \\",
          "906:   { _ext, sizeof(_ext) - 1, _type }",
          "907:   const struct {",
          "908:     const char *ext;",
          "909:     size_t ext_len;",
          "910:     const char *type;",
          "911:   } * t, types[] = {",
          "912:              MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "913:              MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "914:              MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),",
          "915:              MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),",
          "916:              MIME_ENTRY(\"gif\", \"image/gif\"),",
          "917:              MIME_ENTRY(\"png\", \"image/png\"),",
          "918:              MIME_ENTRY(\"woff\", \"font/woff\"),",
          "919:              MIME_ENTRY(\"ttf\", \"font/ttf\"),",
          "920:              MIME_ENTRY(\"aac\", \"audio/aac\"),",
          "921:              MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "922:              MIME_ENTRY(\"azw\", \"application/vnd.amazon.ebook\"),",
          "923:              MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "924:              MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "925:              MIME_ENTRY(\"bz\", \"application/x-bzip\"),",
          "926:              MIME_ENTRY(\"bz2\", \"application/x-bzip2\"),",
          "927:              MIME_ENTRY(\"csv\", \"text/csv\"),",
          "928:              MIME_ENTRY(\"doc\", \"application/msword\"),",
          "929:              MIME_ENTRY(\"epub\", \"application/epub+zip\"),",
          "930:              MIME_ENTRY(\"exe\", \"application/octet-stream\"),",
          "931:              MIME_ENTRY(\"gz\", \"application/gzip\"),",
          "932:              MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "933:              MIME_ENTRY(\"json\", \"application/json\"),",
          "934:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "935:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "936:              MIME_ENTRY(\"mov\", \"video/quicktime\"),",
          "937:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "938:              MIME_ENTRY(\"mp4\", \"video/mp4\"),",
          "939:              MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "940:              MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "941:              MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "942:              MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "943:              MIME_ENTRY(\"rar\", \"application/rar\"),",
          "944:              MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "945:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "946:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "947:              MIME_ENTRY(\"tar\", \"application/tar\"),",
          "948:              MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "949:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "950:              MIME_ENTRY(\"wasm\", \"application/wasm\"),",
          "951:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "952:              MIME_ENTRY(\"weba\", \"audio/webm\"),",
          "953:              MIME_ENTRY(\"webm\", \"video/webm\"),",
          "954:              MIME_ENTRY(\"webp\", \"image/webp\"),",
          "955:              MIME_ENTRY(\"xls\", \"application/excel\"),",
          "956:              MIME_ENTRY(\"xml\", \"application/xml\"),",
          "957:              MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "958:              MIME_ENTRY(\"zip\", \"application/zip\"),",
          "959:              MIME_ENTRY(\"3gp\", \"video/3gpp\"),",
          "960:              MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "961:              {NULL, 0, NULL},",
          "962:          };",
          "964:   for (t = types; t->ext != NULL; t++) {",
          "965:     if (n < t->ext_len + 2) continue;",
          "966:     if (mg_ncasecmp(t->ext, &filename[n - t->ext_len], t->ext_len)) continue;",
          "967:     return t->type;",
          "969:   return \"text/plain; charset=utf-8\";",
          "",
          "[Added Lines]",
          "1047: static struct mg_str guess_content_type(struct mg_str path, const char *extra) {",
          "1049:   struct mimeentry { struct mg_str extension, value; };",
          "1050:   #define MIME_ENTRY(a, b) {{a, sizeof(a) - 1 }, { b, sizeof(b) - 1 }}",
          "1052:   const struct mimeentry tab[] = {",
          "1053:       MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "1054:       MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "1055:       MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),",
          "1056:       MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),",
          "1057:       MIME_ENTRY(\"gif\", \"image/gif\"),",
          "1058:       MIME_ENTRY(\"png\", \"image/png\"),",
          "1059:       MIME_ENTRY(\"woff\", \"font/woff\"),",
          "1060:       MIME_ENTRY(\"ttf\", \"font/ttf\"),",
          "1061:       MIME_ENTRY(\"aac\", \"audio/aac\"),",
          "1062:       MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "1063:       MIME_ENTRY(\"azw\", \"application/vnd.amazon.ebook\"),",
          "1064:       MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "1065:       MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "1066:       MIME_ENTRY(\"bz\", \"application/x-bzip\"),",
          "1067:       MIME_ENTRY(\"bz2\", \"application/x-bzip2\"),",
          "1068:       MIME_ENTRY(\"csv\", \"text/csv\"),",
          "1069:       MIME_ENTRY(\"doc\", \"application/msword\"),",
          "1070:       MIME_ENTRY(\"epub\", \"application/epub+zip\"),",
          "1071:       MIME_ENTRY(\"exe\", \"application/octet-stream\"),",
          "1072:       MIME_ENTRY(\"gz\", \"application/gzip\"),",
          "1073:       MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "1074:       MIME_ENTRY(\"json\", \"application/json\"),",
          "1075:       MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "1076:       MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "1077:       MIME_ENTRY(\"mov\", \"video/quicktime\"),",
          "1078:       MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "1079:       MIME_ENTRY(\"mp4\", \"video/mp4\"),",
          "1080:       MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "1081:       MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "1082:       MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "1083:       MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "1084:       MIME_ENTRY(\"rar\", \"application/rar\"),",
          "1085:       MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "1086:       MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "1087:       MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "1088:       MIME_ENTRY(\"tar\", \"application/tar\"),",
          "1089:       MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "1090:       MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "1091:       MIME_ENTRY(\"wasm\", \"application/wasm\"),",
          "1092:       MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "1093:       MIME_ENTRY(\"weba\", \"audio/webm\"),",
          "1094:       MIME_ENTRY(\"webm\", \"video/webm\"),",
          "1095:       MIME_ENTRY(\"webp\", \"image/webp\"),",
          "1096:       MIME_ENTRY(\"xls\", \"application/excel\"),",
          "1097:       MIME_ENTRY(\"xml\", \"application/xml\"),",
          "1098:       MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "1099:       MIME_ENTRY(\"zip\", \"application/zip\"),",
          "1100:       MIME_ENTRY(\"3gp\", \"video/3gpp\"),",
          "1101:       MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "1102:       MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "1103:       {{0, 0}, {0, 0}},",
          "1104:   };",
          "1105:   size_t i = 0;",
          "1106:   struct mg_str k, v, s = mg_str(extra);",
          "1109:   while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;",
          "1110:   path.ptr += path.len - i;",
          "1111:   path.len = i;",
          "1114:   while (mg_next_comma_entry(&s, &k, &v)) {",
          "1115:     if (mg_strcmp(path, k) == 0) return v;",
          "1119:   for (i = 0; tab[i].extension.ptr != NULL; i++) {",
          "1120:     if (mg_strcmp(path, tab[i].extension) == 0) return tab[i].value;",
          "1121:   }",
          "1123:   return mg_str(\"text/plain; charset=utf-8\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "990: }",
          "992: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "994:   struct mg_str *inm = mg_http_get_header(hm, \"If-None-Match\");",
          "995:   struct stat st;",
          "996:   char etag[64];",
          "",
          "[Removed Lines]",
          "993:                         const char *path, const char *mime, const char *hdrs) {",
          "",
          "[Added Lines]",
          "1147:                         const char *path, struct mg_http_serve_opts *opts) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1008:     int n, status = 200;",
          "1009:     char range[100] = \"\";",
          "1010:     int64_t r1 = 0, r2 = 0, cl = st.st_size;",
          "1013:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1165:     struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1038:     }",
          "1040:     mg_printf(c,",
          "1042:               \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",",
          "1045:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "1046:       fclose(fp);",
          "1047:     } else {",
          "",
          "[Removed Lines]",
          "1041:               \"HTTP/1.1 %d %s\\r\\nContent-Type: %s\\r\\n\"",
          "1043:               status, mg_http_status_code_str(status), mime, etag, cl, range,",
          "1044:               hdrs ? hdrs : \"\");",
          "",
          "[Added Lines]",
          "1196:               \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"",
          "1198:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "1199:               etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1346: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "1347:                        struct mg_http_serve_opts *opts) {",
          "1349:   bool is_index = false, exists;",
          "1350:   struct stat st;",
          "1355:     return;",
          "1358: #if MG_ENABLE_SSI",
          "1359:   if (is_index && !exists) {",
          "1365:   }",
          "1366: #endif",
          "1367:   if (is_index && !exists) {",
          "1368: #if MG_ENABLE_DIRECTORY_LISTING",
          "1370: #else",
          "1371:     mg_http_reply(c, 403, \"\", \"%s\", \"Directory listing not supported\");",
          "1372: #endif",
          "1373: #if MG_ENABLE_SSI",
          "1374:   } else if (opts->ssi_pattern != NULL &&",
          "1378: #endif",
          "1379:   } else {",
          "1382:   }",
          "1383: }",
          "",
          "[Removed Lines]",
          "1348:   char root_dir[MG_PATH_MAX], full_path[sizeof(root_dir)];",
          "1351:   root_dir[0] = full_path[0] = '\\0';",
          "1353:   if (!uri_to_local_path(c, hm, opts, root_dir, sizeof(root_dir), full_path,",
          "1354:                          sizeof(full_path), &is_index))",
          "1357:   exists = stat(full_path, &st) == 0;",
          "1360:     char *p = full_path + strlen(full_path);",
          "1361:     while (p > full_path && p[-1] != '/') p--;",
          "1362:     strncpy(p, \"index.shtml\", (size_t)(&full_path[sizeof(full_path)] - p - 2));",
          "1363:     full_path[sizeof(full_path) - 1] = '\\0';",
          "1364:     exists = stat(full_path, &st) == 0;",
          "1369:     listdir(c, hm, opts, full_path);",
          "1375:              mg_globmatch(opts->ssi_pattern, strlen(opts->ssi_pattern),",
          "1376:                           full_path, strlen(full_path))) {",
          "1377:     mg_http_serve_ssi(c, root_dir, full_path);",
          "1380:     mg_http_serve_file(c, hm, full_path, guess_content_type(full_path),",
          "1381:                        opts->extra_headers);",
          "",
          "[Added Lines]",
          "1503:   char root_dir[MG_PATH_MAX], path[sizeof(root_dir)];",
          "1506:   root_dir[0] = path[0] = '\\0';",
          "1508:   if (!uri_to_local_path(c, hm, opts, root_dir, sizeof(root_dir), path,",
          "1509:                          sizeof(path), &is_index))",
          "1512:   exists = stat(path, &st) == 0;",
          "1515:     char *p = path + strlen(path);",
          "1516:     while (p > path && p[-1] != '/') p--;",
          "1517:     strncpy(p, \"index.shtml\", (size_t)(&path[sizeof(path)] - p - 2));",
          "1518:     path[sizeof(path) - 1] = '\\0';",
          "1519:     exists = stat(path, &st) == 0;",
          "1524:     listdir(c, hm, opts, path);",
          "1530:              mg_globmatch(opts->ssi_pattern, strlen(opts->ssi_pattern), path,",
          "1531:                           strlen(path))) {",
          "1532:     mg_http_serve_ssi(c, root_dir, path);",
          "1535:     mg_http_serve_file(c, hm, path, opts);",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "609: FILE *mg_fopen_packed(const char *path, const char *mode);",
          "611: #if (defined(__linux__) && defined(__GNUC__)) || defined(__NEWLIB__)",
          "612: #define MG_ENABLE_PACKED_FS 1",
          "613: #define MG_FOPENCOOKIE",
          "614: #else",
          "615: #define MG_ENABLE_PACKED_FS 0",
          "616: #endif",
          "",
          "[Added Lines]",
          "609: enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };",
          "612: struct mg_fs {",
          "613:   char *(*realpath)(const char *path, char *resolved_path);",
          "614:   int (*stat)(const char *path, size_t *size, unsigned *mtime);",
          "615:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "616:   struct mg_fd *(*open)(const char *path, int flags);",
          "617:   void (*close)(struct mg_fd *fd);",
          "618:   size_t (*read)(void *fd, void *buf, size_t len);",
          "619:   size_t (*write)(void *fd, const void *buf, size_t len);",
          "620:   size_t (*seek)(void *fd, size_t offset);",
          "621: };",
          "624: struct mg_fd {",
          "625:   void *fd;",
          "626:   struct mg_fs *fs;",
          "627: };",
          "629: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "630: extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/complete",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "800:   const char *root_dir;       // Web root directory, must be non-NULL",
          "801:   const char *ssi_pattern;    // SSI file name pattern, e.g. #.shtml",
          "802:   const char *extra_headers;  // Extra HTTP headers to add in responses",
          "804: };",
          "",
          "[Removed Lines]",
          "803:   bool use_packed_fs;         // Serve files embedded into binary",
          "",
          "[Added Lines]",
          "818:   const char *mime_types;     // Extra mime types, ext1=type1,ext2=type2,..",
          "819:   struct mg_fs *fs;           // Filesystem implementation. Use NULL for POSIX",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "820: struct mg_connection *mg_http_connect(struct mg_mgr *, const char *url,",
          "821:                                       mg_event_handler_t fn, void *fn_data);",
          "822: void mg_http_serve_dir(struct mg_connection *, struct mg_http_message *hm,",
          "826: void mg_http_reply(struct mg_connection *, int status_code, const char *headers,",
          "827:                    const char *body_fmt, ...);",
          "828: struct mg_str *mg_http_get_header(struct mg_http_message *, const char *name);",
          "",
          "[Removed Lines]",
          "823:                        struct mg_http_serve_opts *);",
          "824: void mg_http_serve_file(struct mg_connection *, struct mg_http_message *,",
          "825:                         const char *, const char *mime, const char *headers);",
          "",
          "[Added Lines]",
          "839:                        struct mg_http_serve_opts *opts);",
          "840: void mg_http_serve_file(struct mg_connection *, struct mg_http_message *hm,",
          "841:                         const char *path, struct mg_http_serve_opts *opts);",
          "",
          "---------------"
        ],
        "src/fs.c||src/fs.c": [
          "File: src/fs.c -> src/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/fs.h||src/fs.h": [
          "File: src/fs.h -> src/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"arch.h\"",
          "",
          "[Removed Lines]",
          "5: FILE *mg_fopen_packed(const char *path, const char *mode);",
          "7: #if (defined(__linux__) && defined(__GNUC__)) || defined(__NEWLIB__)",
          "8: #define MG_ENABLE_PACKED_FS 1",
          "9: #define MG_FOPENCOOKIE",
          "10: #else",
          "11: #define MG_ENABLE_PACKED_FS 0",
          "12: #endif",
          "",
          "[Added Lines]",
          "5: enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };",
          "8: struct mg_fs {",
          "9:   char *(*realpath)(const char *path, char *resolved_path);",
          "10:   int (*stat)(const char *path, size_t *size, unsigned *mtime);",
          "11:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "12:   struct mg_fd *(*open)(const char *path, int flags);",
          "13:   void (*close)(struct mg_fd *fd);",
          "14:   size_t (*read)(void *fd, void *buf, size_t len);",
          "15:   size_t (*write)(void *fd, const void *buf, size_t len);",
          "16:   size_t (*seek)(void *fd, size_t offset);",
          "17: };",
          "20: struct mg_fd {",
          "21:   void *fd;",
          "22:   struct mg_fs *fs;",
          "23: };",
          "25: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "26: extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/complete",
          "",
          "---------------"
        ],
        "src/fs_packed.c||src/fs_packed.c": [
          "File: src/fs_packed.c -> src/fs_packed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"fs.h\"",
          "3: struct packed_file {",
          "4:   const char *data;",
          "5:   size_t size;",
          "6:   size_t pos;",
          "7: };",
          "9: const char *mg_unpack(const char *, size_t *) WEAK;",
          "10: const char *mg_unpack(const char *path, size_t *size) {",
          "11:   (void) path, (void) size;",
          "12:   return NULL;",
          "13: }",
          "15: static char *packed_realpath(const char *path, char *resolved_path) {",
          "16:   if (resolved_path == NULL) resolved_path = malloc(strlen(path) + 1);",
          "17:   strcpy(resolved_path, path);",
          "18:   return resolved_path;",
          "19: }",
          "21: static int packed_stat(const char *path, size_t *size, unsigned *mtime) {",
          "22:   const char *data = mg_unpack(path, size);",
          "23:   if (mtime) *mtime = 0;",
          "24:   return data == NULL ? 0 : MG_FS_READ;",
          "25: }",
          "27: static void packed_list(const char *path, void (*fn)(const char *, void *),",
          "28:                         void *userdata) {",
          "29:   (void) path, (void) fn, (void) userdata;",
          "30: }",
          "32: static struct mg_fd *packed_open(const char *path, int flags) {",
          "33:   size_t size = 0;",
          "34:   const char *data = mg_unpack(path, &size);",
          "35:   struct packed_file *fp = NULL;",
          "36:   struct mg_fd *fd = NULL;",
          "37:   if (data == NULL) return NULL;",
          "38:   if (flags & MG_FS_WRITE) return NULL;",
          "39:   fp = calloc(1, sizeof(*fp));",
          "40:   fd = calloc(1, sizeof(*fd));",
          "41:   fp->size = size;",
          "42:   fp->data = data;",
          "43:   fd->fd = fp;",
          "44:   fd->fs = &mg_fs_packed;",
          "45:   return fd;",
          "46: }",
          "48: static void packed_close(struct mg_fd *fd) {",
          "49:   if (fd) free(fd->fd), free(fd);",
          "50: }",
          "52: static size_t packed_read(void *fd, void *buf, size_t len) {",
          "53:   struct packed_file *fp = (struct packed_file *) fd;",
          "54:   if (fp->pos + len > fp->size) len = fp->size - fp->pos;",
          "55:   memcpy(buf, &fp->data[fp->pos], len);",
          "56:   fp->pos += len;",
          "57:   return len;",
          "58: }",
          "60: static size_t packed_write(void *fd, const void *buf, size_t len) {",
          "61:   (void) fd, (void) buf, (void) len;",
          "62:   return 0;",
          "63: }",
          "65: static size_t packed_seek(void *fd, size_t offset) {",
          "66:   struct packed_file *fp = (struct packed_file *) fd;",
          "67:   fp->pos = offset;",
          "68:   if (fp->pos > fp->size) fp->pos = fp->size;",
          "69:   return fp->pos;",
          "70: }",
          "72: struct mg_fs mg_fs_packed = {packed_realpath, packed_stat,  packed_list,",
          "73:                              packed_open,     packed_close, packed_read,",
          "74:                              packed_write,    packed_seek};",
          "",
          "---------------"
        ],
        "src/fs_posix.c||src/fs_posix.c": [
          "File: src/fs_posix.c -> src/fs_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"fs.h\"",
          "3: #if defined(O_READ)",
          "4: static char *posix_realpath(const char *path, char *resolved_path) {",
          "5: #ifdef _WIN32",
          "6:   return _fullpath(path, resolved_path, PATH_MAX);",
          "7: #else",
          "8:   return realpath(path, resolved_path);",
          "9: #endif",
          "10: }",
          "12: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "13: #ifdef _WIN32",
          "14:   struct _stati64 st;",
          "15:   wchar_t tmp[PATH_MAX];",
          "16:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "17:   if (_wstati64(tmp, &st) != 0) return 0;",
          "18: #else",
          "19:   struct stat st;",
          "20:   if (stat(path, &st) != 0) return 0;",
          "21: #endif",
          "22:   if (size) *size = (size_t) st.st_size;",
          "23:   if (mtime) *mtime = (unsigned) st.st_mtime;",
          "24:   return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);",
          "25: }",
          "27: static void posix_list(const char *dir, void (*fn)(const char *, void *),",
          "28:                        void *userdata) {",
          "30:   struct dirent *dp;",
          "31:   DIR *dirp;",
          "34:   if ((dirp = (opendir(dir))) != NULL) {",
          "35:     size_t off, n;",
          "36:     while ((dp = readdir(dirp)) != NULL) {",
          "38:       if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "39:       fn(dp->d_name, &st);",
          "40:     }",
          "41:     closedir(dirp);",
          "42:   }",
          "43: }",
          "45: static struct mg_fd *posix_open(const char *path, int flags) {",
          "46:   const char *mode =",
          "47:       flags & (MG_FS_READ | MG_FS_WRITE)",
          "48:           ? \"r+b\"",
          "49:           : flags & MG_FS_READ ? \"rb\" : flags & MG_FS_WRITE ? \"wb\" : \"\";",
          "50:   void *fp = NULL;",
          "51:   struct mg_fd *fd = NULL;",
          "52: #ifdef _WIN32",
          "53:   wchar_t b1[PATH_MAX], b2[10];",
          "54:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "55:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "56:   fp = (void *) _wfopen(b1, b2);",
          "57: #else",
          "58:   fp = (void *) fopen(path, mode);",
          "59: #endif",
          "60:   if (fp == NULL) return NULL;",
          "61:   fd = calloc(1, sizeof(*fd));",
          "62:   fd->fd = fp;",
          "63:   fd->fs = &mg_fs_posix;",
          "64:   return fd;",
          "65: }",
          "67: static void posix_close(struct mg_fd *fd) {",
          "68:   if (fd) fclose((FILE *) fd->fd), free(fd);",
          "69: }",
          "71: static size_t posix_read(void *fp, void *buf, size_t len) {",
          "72:   return fread(buf, 1, len, (FILE *) fp);",
          "73: }",
          "75: static size_t posix_write(void *fp, const void *buf, size_t len) {",
          "76:   return fwrite(buf, 1, len, (FILE *) fp);",
          "77: }",
          "79: static size_t posix_seek(void *fp, size_t offset) {",
          "80: #if _FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE >= 200112L || \\",
          "81:     _XOPEN_SOURCE >= 600",
          "82:   fseeko((FILE *) fp, (off_t) offset, SEEK_SET);",
          "83: #else",
          "84:   fseek((FILE *) fp, (long) offset, SEEK_SET);",
          "85: #endif",
          "86:   return (size_t) ftell((FILE *) fp);",
          "87: }",
          "88: #else",
          "89: static char *posix_realpath(const char *path, char *resolved_path) {",
          "90:   (void) path, (void) resolved_path;",
          "91:   return NULL;",
          "92: }",
          "94: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "95:   (void) path, (void) size, (void) mtime;",
          "96:   return 0;",
          "97: }",
          "99: static void posix_list(const char *path, void (*fn)(const char *, void *),",
          "100:                        void *userdata) {",
          "101:   (void) path, (void) fn, (void) userdata;",
          "102: }",
          "104: static struct mg_fd *posix_open(const char *path, int flags) {",
          "105:   (void) path, (void) flags;",
          "106:   return NULL;",
          "107: }",
          "109: static void posix_close(struct mg_fd *fd) {",
          "110:   (void) fd;",
          "111: }",
          "113: static size_t posix_read(void *fd, void *buf, size_t len) {",
          "114:   (void) fd, (void) buf, (void) len;",
          "115:   return 0;",
          "116: }",
          "118: static size_t posix_write(void *fd, const void *buf, size_t len) {",
          "119:   (void) fd, (void) buf, (void) len;",
          "120:   return 0;",
          "121: }",
          "123: static size_t posix_seek(void *fd, size_t offset) {",
          "124:   (void) fd, (void) offset;",
          "125:   return (size_t) ~0;",
          "126: }",
          "127: #endif",
          "129: struct mg_fs mg_fs_posix = {posix_realpath, posix_stat,  posix_list,",
          "130:                             posix_open,     posix_close, posix_read,",
          "131:                             posix_write,    posix_seek};",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "420:   (void) ev_data;",
          "421: }",
          "488:   }",
          "490: }",
          "492: static int getrange(struct mg_str *s, int64_t *a, int64_t *b) {",
          "",
          "[Removed Lines]",
          "423: static const char *guess_content_type(const char *filename) {",
          "424:   size_t n = strlen(filename);",
          "425: #define MIME_ENTRY(_ext, _type) \\",
          "426:   { _ext, sizeof(_ext) - 1, _type }",
          "427:   const struct {",
          "428:     const char *ext;",
          "429:     size_t ext_len;",
          "430:     const char *type;",
          "431:   } * t, types[] = {",
          "432:              MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "433:              MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "434:              MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),",
          "435:              MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),",
          "436:              MIME_ENTRY(\"gif\", \"image/gif\"),",
          "437:              MIME_ENTRY(\"png\", \"image/png\"),",
          "438:              MIME_ENTRY(\"woff\", \"font/woff\"),",
          "439:              MIME_ENTRY(\"ttf\", \"font/ttf\"),",
          "440:              MIME_ENTRY(\"aac\", \"audio/aac\"),",
          "441:              MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "442:              MIME_ENTRY(\"azw\", \"application/vnd.amazon.ebook\"),",
          "443:              MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "444:              MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "445:              MIME_ENTRY(\"bz\", \"application/x-bzip\"),",
          "446:              MIME_ENTRY(\"bz2\", \"application/x-bzip2\"),",
          "447:              MIME_ENTRY(\"csv\", \"text/csv\"),",
          "448:              MIME_ENTRY(\"doc\", \"application/msword\"),",
          "449:              MIME_ENTRY(\"epub\", \"application/epub+zip\"),",
          "450:              MIME_ENTRY(\"exe\", \"application/octet-stream\"),",
          "451:              MIME_ENTRY(\"gz\", \"application/gzip\"),",
          "452:              MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "453:              MIME_ENTRY(\"json\", \"application/json\"),",
          "454:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "455:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "456:              MIME_ENTRY(\"mov\", \"video/quicktime\"),",
          "457:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "458:              MIME_ENTRY(\"mp4\", \"video/mp4\"),",
          "459:              MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "460:              MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "461:              MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "462:              MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "463:              MIME_ENTRY(\"rar\", \"application/rar\"),",
          "464:              MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "465:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "466:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "467:              MIME_ENTRY(\"tar\", \"application/tar\"),",
          "468:              MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "469:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "470:              MIME_ENTRY(\"wasm\", \"application/wasm\"),",
          "471:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "472:              MIME_ENTRY(\"weba\", \"audio/webm\"),",
          "473:              MIME_ENTRY(\"webm\", \"video/webm\"),",
          "474:              MIME_ENTRY(\"webp\", \"image/webp\"),",
          "475:              MIME_ENTRY(\"xls\", \"application/excel\"),",
          "476:              MIME_ENTRY(\"xml\", \"application/xml\"),",
          "477:              MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "478:              MIME_ENTRY(\"zip\", \"application/zip\"),",
          "479:              MIME_ENTRY(\"3gp\", \"video/3gpp\"),",
          "480:              MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "481:              {NULL, 0, NULL},",
          "482:          };",
          "484:   for (t = types; t->ext != NULL; t++) {",
          "485:     if (n < t->ext_len + 2) continue;",
          "486:     if (mg_ncasecmp(t->ext, &filename[n - t->ext_len], t->ext_len)) continue;",
          "487:     return t->type;",
          "489:   return \"text/plain; charset=utf-8\";",
          "",
          "[Added Lines]",
          "423: static struct mg_str guess_content_type(struct mg_str path, const char *extra) {",
          "425:   struct mimeentry { struct mg_str extension, value; };",
          "426:   #define MIME_ENTRY(a, b) {{a, sizeof(a) - 1 }, { b, sizeof(b) - 1 }}",
          "428:   const struct mimeentry tab[] = {",
          "429:       MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "430:       MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "431:       MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),",
          "432:       MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),",
          "433:       MIME_ENTRY(\"gif\", \"image/gif\"),",
          "434:       MIME_ENTRY(\"png\", \"image/png\"),",
          "435:       MIME_ENTRY(\"woff\", \"font/woff\"),",
          "436:       MIME_ENTRY(\"ttf\", \"font/ttf\"),",
          "437:       MIME_ENTRY(\"aac\", \"audio/aac\"),",
          "438:       MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "439:       MIME_ENTRY(\"azw\", \"application/vnd.amazon.ebook\"),",
          "440:       MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "441:       MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "442:       MIME_ENTRY(\"bz\", \"application/x-bzip\"),",
          "443:       MIME_ENTRY(\"bz2\", \"application/x-bzip2\"),",
          "444:       MIME_ENTRY(\"csv\", \"text/csv\"),",
          "445:       MIME_ENTRY(\"doc\", \"application/msword\"),",
          "446:       MIME_ENTRY(\"epub\", \"application/epub+zip\"),",
          "447:       MIME_ENTRY(\"exe\", \"application/octet-stream\"),",
          "448:       MIME_ENTRY(\"gz\", \"application/gzip\"),",
          "449:       MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "450:       MIME_ENTRY(\"json\", \"application/json\"),",
          "451:       MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "452:       MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "453:       MIME_ENTRY(\"mov\", \"video/quicktime\"),",
          "454:       MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "455:       MIME_ENTRY(\"mp4\", \"video/mp4\"),",
          "456:       MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "457:       MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "458:       MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "459:       MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "460:       MIME_ENTRY(\"rar\", \"application/rar\"),",
          "461:       MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "462:       MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "463:       MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "464:       MIME_ENTRY(\"tar\", \"application/tar\"),",
          "465:       MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "466:       MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "467:       MIME_ENTRY(\"wasm\", \"application/wasm\"),",
          "468:       MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "469:       MIME_ENTRY(\"weba\", \"audio/webm\"),",
          "470:       MIME_ENTRY(\"webm\", \"video/webm\"),",
          "471:       MIME_ENTRY(\"webp\", \"image/webp\"),",
          "472:       MIME_ENTRY(\"xls\", \"application/excel\"),",
          "473:       MIME_ENTRY(\"xml\", \"application/xml\"),",
          "474:       MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "475:       MIME_ENTRY(\"zip\", \"application/zip\"),",
          "476:       MIME_ENTRY(\"3gp\", \"video/3gpp\"),",
          "477:       MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "478:       MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "479:       {{0, 0}, {0, 0}},",
          "480:   };",
          "481:   size_t i = 0;",
          "482:   struct mg_str k, v, s = mg_str(extra);",
          "485:   while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;",
          "486:   path.ptr += path.len - i;",
          "487:   path.len = i;",
          "490:   while (mg_next_comma_entry(&s, &k, &v)) {",
          "491:     if (mg_strcmp(path, k) == 0) return v;",
          "495:   for (i = 0; tab[i].extension.ptr != NULL; i++) {",
          "496:     if (mg_strcmp(path, tab[i].extension) == 0) return tab[i].value;",
          "497:   }",
          "499:   return mg_str(\"text/plain; charset=utf-8\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "510: }",
          "512: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "514:   struct mg_str *inm = mg_http_get_header(hm, \"If-None-Match\");",
          "515:   struct stat st;",
          "516:   char etag[64];",
          "",
          "[Removed Lines]",
          "513:                         const char *path, const char *mime, const char *hdrs) {",
          "",
          "[Added Lines]",
          "523:                         const char *path, struct mg_http_serve_opts *opts) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "528:     int n, status = 200;",
          "529:     char range[100] = \"\";",
          "530:     int64_t r1 = 0, r2 = 0, cl = st.st_size;",
          "533:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "541:     struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "558:     }",
          "560:     mg_printf(c,",
          "562:               \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",",
          "565:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "566:       fclose(fp);",
          "567:     } else {",
          "",
          "[Removed Lines]",
          "561:               \"HTTP/1.1 %d %s\\r\\nContent-Type: %s\\r\\n\"",
          "563:               status, mg_http_status_code_str(status), mime, etag, cl, range,",
          "564:               hdrs ? hdrs : \"\");",
          "",
          "[Added Lines]",
          "572:               \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"",
          "574:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "575:               etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "866: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "867:                        struct mg_http_serve_opts *opts) {",
          "869:   bool is_index = false, exists;",
          "870:   struct stat st;",
          "875:     return;",
          "878: #if MG_ENABLE_SSI",
          "879:   if (is_index && !exists) {",
          "885:   }",
          "886: #endif",
          "887:   if (is_index && !exists) {",
          "888: #if MG_ENABLE_DIRECTORY_LISTING",
          "890: #else",
          "891:     mg_http_reply(c, 403, \"\", \"%s\", \"Directory listing not supported\");",
          "892: #endif",
          "893: #if MG_ENABLE_SSI",
          "894:   } else if (opts->ssi_pattern != NULL &&",
          "898: #endif",
          "899:   } else {",
          "902:   }",
          "903: }",
          "",
          "[Removed Lines]",
          "868:   char root_dir[MG_PATH_MAX], full_path[sizeof(root_dir)];",
          "871:   root_dir[0] = full_path[0] = '\\0';",
          "873:   if (!uri_to_local_path(c, hm, opts, root_dir, sizeof(root_dir), full_path,",
          "874:                          sizeof(full_path), &is_index))",
          "877:   exists = stat(full_path, &st) == 0;",
          "880:     char *p = full_path + strlen(full_path);",
          "881:     while (p > full_path && p[-1] != '/') p--;",
          "882:     strncpy(p, \"index.shtml\", (size_t)(&full_path[sizeof(full_path)] - p - 2));",
          "883:     full_path[sizeof(full_path) - 1] = '\\0';",
          "884:     exists = stat(full_path, &st) == 0;",
          "889:     listdir(c, hm, opts, full_path);",
          "895:              mg_globmatch(opts->ssi_pattern, strlen(opts->ssi_pattern),",
          "896:                           full_path, strlen(full_path))) {",
          "897:     mg_http_serve_ssi(c, root_dir, full_path);",
          "900:     mg_http_serve_file(c, hm, full_path, guess_content_type(full_path),",
          "901:                        opts->extra_headers);",
          "",
          "[Added Lines]",
          "879:   char root_dir[MG_PATH_MAX], path[sizeof(root_dir)];",
          "882:   root_dir[0] = path[0] = '\\0';",
          "884:   if (!uri_to_local_path(c, hm, opts, root_dir, sizeof(root_dir), path,",
          "885:                          sizeof(path), &is_index))",
          "888:   exists = stat(path, &st) == 0;",
          "891:     char *p = path + strlen(path);",
          "892:     while (p > path && p[-1] != '/') p--;",
          "893:     strncpy(p, \"index.shtml\", (size_t)(&path[sizeof(path)] - p - 2));",
          "894:     path[sizeof(path) - 1] = '\\0';",
          "895:     exists = stat(path, &st) == 0;",
          "900:     listdir(c, hm, opts, path);",
          "906:              mg_globmatch(opts->ssi_pattern, strlen(opts->ssi_pattern), path,",
          "907:                           strlen(path))) {",
          "908:     mg_http_serve_ssi(c, root_dir, path);",
          "911:     mg_http_serve_file(c, hm, path, opts);",
          "",
          "---------------"
        ],
        "src/http.h||src/http.h": [
          "File: src/http.h -> src/http.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #pragma once",
          "3: #include \"config.h\"",
          "4: #include \"net.h\"",
          "5: #include \"str.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include \"fs.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23:   const char *root_dir;       // Web root directory, must be non-NULL",
          "24:   const char *ssi_pattern;    // SSI file name pattern, e.g. #.shtml",
          "25:   const char *extra_headers;  // Extra HTTP headers to add in responses",
          "27: };",
          "",
          "[Removed Lines]",
          "26:   bool use_packed_fs;         // Serve files embedded into binary",
          "",
          "[Added Lines]",
          "27:   const char *mime_types;     // Extra mime types, ext1=type1,ext2=type2,..",
          "28:   struct mg_fs *fs;           // Filesystem implementation. Use NULL for POSIX",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "43: struct mg_connection *mg_http_connect(struct mg_mgr *, const char *url,",
          "44:                                       mg_event_handler_t fn, void *fn_data);",
          "45: void mg_http_serve_dir(struct mg_connection *, struct mg_http_message *hm,",
          "49: void mg_http_reply(struct mg_connection *, int status_code, const char *headers,",
          "50:                    const char *body_fmt, ...);",
          "51: struct mg_str *mg_http_get_header(struct mg_http_message *, const char *name);",
          "",
          "[Removed Lines]",
          "46:                        struct mg_http_serve_opts *);",
          "47: void mg_http_serve_file(struct mg_connection *, struct mg_http_message *,",
          "48:                         const char *, const char *mime, const char *headers);",
          "",
          "[Added Lines]",
          "48:                        struct mg_http_serve_opts *opts);",
          "49: void mg_http_serve_file(struct mg_connection *, struct mg_http_message *hm,",
          "50:                         const char *path, struct mg_http_serve_opts *opts);",
          "",
          "---------------"
        ],
        "test/mongoose_custom.h||test/mongoose_custom.h": [
          "File: test/mongoose_custom.h -> test/mongoose_custom.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #undef MG_ENABLE_SOCKET",
          "23: #define MG_ENABLE_SOCKET 0",
          "27: int clock_gettime(clockid_t clock_id, struct timespec *tp);",
          "",
          "[Removed Lines]",
          "25: #define realpath(a, b) (a)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "363:       sopts.root_dir = \".\";",
          "364:       sopts.extra_headers = \"A: B\\r\\nC: D\\r\\n\";",
          "365:       mg_http_serve_dir(c, hm, &sopts);",
          "366:     } else {",
          "367:       struct mg_http_serve_opts sopts;",
          "368:       memset(&sopts, 0, sizeof(sopts));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "366:     } else if (mg_http_match_uri(hm, \"/packed/#\")) {",
          "367:       struct mg_http_serve_opts sopts;",
          "368:       memset(&sopts, 0, sizeof(sopts));",
          "369:       sopts.root_dir = \".\";",
          "370:       mg_http_serve_dir(c, hm, &sopts);",
          "371:     } else if (mg_http_match_uri(hm, \"/servefile\")) {",
          "372:       struct mg_http_serve_opts sopts;",
          "373:       memset(&sopts, 0, sizeof(sopts));",
          "374:       sopts.mime_types = \"foo=a/b,txt=c/d\";",
          "375:       mg_http_serve_file(c, hm, \"test/data/a.txt\", &sopts);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "501:                  etag) == 304);",
          "502:   }",
          "504:   ASSERT(fetch(&mgr, buf, url, \"GET /foo/1 HTTP/1.0\\r\\n\\n\") == 200);",
          "506:   ASSERT(cmpbody(buf, \"uri: 1\") == 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "515:   ASSERT(fetch(&mgr, buf, url, \"GET /servefile HTTP/1.0\\n\\n\") == 200);",
          "516:   ASSERT(cmpbody(buf, \"hello\\n\") == 0);",
          "517:   {",
          "518:     struct mg_http_message hm;",
          "519:     mg_http_parse(buf, strlen(buf), &hm);",
          "520:     ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);",
          "521:     ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"), mg_str(\"c/d\")) ==",
          "522:            0);",
          "523:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1336: }",
          "1338: static void test_packed(void) {",
          "1351: }",
          "1353: int main(void) {",
          "",
          "[Removed Lines]",
          "1339:   const char *path = \"Makefile\";",
          "1340:   FILE *fp = mg_fopen_packed(path, \"r\");",
          "1341: #if MG_ENABLE_PACKED_FS",
          "1342:   struct stat st;",
          "1343:   ASSERT(stat(path, &st) == 0);",
          "1344:   ASSERT(fp != NULL);",
          "1345:   fseek(fp, 0, SEEK_END);",
          "1346:   ASSERT(ftell(fp) == st.st_size);",
          "1347:   fclose(fp);",
          "1348: #else",
          "1349:   ASSERT(fp == NULL);",
          "1350: #endif",
          "",
          "[Added Lines]",
          "1360:   struct mg_mgr mgr;",
          "1361:   const char *url = \"http://127.0.0.1:12351\";",
          "1362:   char buf[FETCH_BUF_SIZE];",
          "1363:   mg_mgr_init(&mgr);",
          "1364:   mg_http_listen(&mgr, url, eh1, NULL);",
          "1365:   ASSERT(fetch(&mgr, buf, url, \"GET /packed/ HTTP/1.0\\n\\n\") == 404);",
          "1366:   mg_mgr_free(&mgr);",
          "1367:   ASSERT(mgr.conns == NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56a7438114b3649a2b08a83bbd874316c4997199",
      "candidate_info": {
        "commit_hash": "56a7438114b3649a2b08a83bbd874316c4997199",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/56a7438114b3649a2b08a83bbd874316c4997199",
        "files": [
          "Makefile",
          "docs/README.md",
          "examples/complete/main.c",
          "examples/esp32/main/main.c",
          "examples/video-stream/main.c",
          "mongoose.c",
          "mongoose.h",
          "src/fs.c",
          "src/fs.h",
          "src/fs_fat.c",
          "src/fs_packed.c",
          "src/fs_posix.c",
          "src/http.c",
          "src/http.h",
          "src/tls.h",
          "src/tls_mbed.c",
          "src/tls_mbed.h",
          "src/util.c",
          "src/util.h",
          "test/unit_test.c"
        ],
        "message": "Add fs arg to mg_file* and mg_http_upload API",
        "before_after_code_files": [
          "examples/complete/main.c||examples/complete/main.c",
          "examples/esp32/main/main.c||examples/esp32/main/main.c",
          "examples/video-stream/main.c||examples/video-stream/main.c",
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/fs.c||src/fs.c",
          "src/fs.h||src/fs.h",
          "src/fs_fat.c||src/fs_fat.c",
          "src/fs_packed.c||src/fs_packed.c",
          "src/fs_posix.c||src/fs_posix.c",
          "src/http.c||src/http.c",
          "src/http.h||src/http.h",
          "src/tls.h||src/tls.h",
          "src/tls_mbed.c||src/tls_mbed.c",
          "src/tls_mbed.h||src/tls_mbed.h",
          "src/util.c||src/util.c",
          "src/util.h||src/util.h",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "examples/complete/main.c||examples/complete/main.c": [
          "File: examples/complete/main.c -> examples/complete/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:   static size_t i;",
          "148:   const char *path = files[i++ % nfiles];",
          "149:   size_t size = 0;",
          "151:   struct mg_connection *c;",
          "152:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "153:     if (c->label[0] != 'S') continue;         // Skip non-stream connections",
          "",
          "[Removed Lines]",
          "150:   char *data = mg_file_read(path, &size);  // Read next file",
          "",
          "[Added Lines]",
          "150:   char *data = mg_file_read(&mg_fs_posix, path, &size);  // Read next file",
          "",
          "---------------"
        ],
        "examples/esp32/main/main.c||examples/esp32/main/main.c": [
          "File: examples/esp32/main/main.c -> examples/esp32/main/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:       .base_path = FS_ROOT, .max_files = 20, .format_if_mount_failed = true};",
          "41:   int res = esp_vfs_spiffs_register(&conf);",
          "42:   LOG(res == ESP_OK ? LL_INFO : LL_ERROR, (\"FS %s, %d\", conf.base_path, res));",
          "",
          "[Removed Lines]",
          "43:   mg_file_printf(FS_ROOT \"/hello.txt\", \"%s\", \"hello from ESP\");",
          "",
          "[Added Lines]",
          "43:   mg_file_printf(&mg_fs_posix, FS_ROOT \"/hello.txt\", \"%s\", \"hello from ESP\");",
          "",
          "---------------"
        ],
        "examples/video-stream/main.c||examples/video-stream/main.c": [
          "File: examples/video-stream/main.c -> examples/video-stream/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:   static size_t i;",
          "34:   const char *path = files[i++ % nfiles];",
          "35:   size_t size = 0;",
          "37:   struct mg_connection *c;",
          "38:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "39:     if (c->label[0] != 'S') continue;         // Skip non-stream connections",
          "",
          "[Removed Lines]",
          "36:   char *data = mg_file_read(path, &size);  // Read next file",
          "",
          "[Added Lines]",
          "36:   char *data = mg_file_read(&mg_fs_posix, path, &size);  // Read next file",
          "",
          "---------------"
        ],
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "433:   }",
          "434: }",
          "436: #ifdef MG_ENABLE_LINES",
          "437: #line 1 \"src/fs_fat.c\"",
          "438: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "437: char *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {",
          "438:   struct mg_fd *fd;",
          "439:   char *data = NULL;",
          "440:   size_t size = 0;",
          "441:   fs->stat(path, &size, NULL);",
          "442:   if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {",
          "443:     data = (char *) calloc(1, size + 1);",
          "444:     if (data != NULL) {",
          "445:       if (fs->read(fd->fd, data, size) != size) {",
          "446:         free(data);",
          "447:         data = NULL;",
          "448:       } else {",
          "449:         data[size] = '\\0';",
          "450:         if (sizep != NULL) *sizep = size;",
          "451:       }",
          "452:     }",
          "453:     mg_fs_close(fd);",
          "454:   }",
          "455:   return data;",
          "456: }",
          "458: bool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,",
          "459:                    size_t len) {",
          "460:   bool result = false;",
          "461:   struct mg_fd *fd;",
          "462:   char tmp[MG_PATH_MAX];",
          "463:   snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "464:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "465:     result = fs->write(fd->fd, buf, len) == len;",
          "466:     mg_fs_close(fd);",
          "467:     if (result) {",
          "468:       fs->remove(path);",
          "469:       fs->rename(tmp, path);",
          "470:     } else {",
          "471:       fs->remove(tmp);",
          "472:     }",
          "473:   }",
          "474:   return result;",
          "475: }",
          "477: bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {",
          "478:   char tmp[256], *buf = tmp;",
          "479:   bool result;",
          "480:   int len;",
          "481:   va_list ap;",
          "482:   va_start(ap, fmt);",
          "483:   len = mg_vasprintf(&buf, sizeof(tmp), fmt, ap);",
          "484:   va_end(ap);",
          "485:   result = mg_file_write(fs, path, buf, len > 0 ? (size_t) len : 0);",
          "486:   if (buf != tmp) free(buf);",
          "487:   return result;",
          "488: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "476: static void *ff_open(const char *path, int flags) {",
          "477:   FIL f;",
          "482:   if (f_open(&f, path, mode) == 0) {",
          "483:     FIL *fp = calloc(1, sizeof(*fp));",
          "",
          "[Removed Lines]",
          "478:   const char mode = flags == (MG_FS_READ | MG_FS_WRITE) ? FA_READ | FA_WRITE",
          "479:                     : flags & MG_FS_READ                ? FA_READ",
          "480:                     : flags & MG_FS_WRITE               ? FA_WRITE",
          "481:                                                         : 0;",
          "",
          "[Added Lines]",
          "532:   unsigned char mode =",
          "533:       flags == MG_FS_READ ? FA_READ : FA_READ | FA_WRITE | FA_OPEN_APPEND;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "512:   return offset;",
          "513: }",
          "517: #endif",
          "519: #ifdef MG_ENABLE_LINES",
          "",
          "[Removed Lines]",
          "515: struct mg_fs mg_fs_fat = {ff_stat, ff_list,  ff_open, ff_close,",
          "516:                           ff_read, ff_write, ff_seek};",
          "",
          "[Added Lines]",
          "567: static bool ff_rename(const char *from, const char *to) {",
          "568:   return ff_rename(from, to) == FR_OK;",
          "569: }",
          "571: static bool ff_remove(const char *path) {",
          "572:   return ff_remove(path) == 0;",
          "573: }",
          "575: struct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close, ff_read,",
          "576:                           ff_write, ff_seek, ff_rename, ff_remove};",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "614:   return fp->pos;",
          "615: }",
          "621: #ifdef MG_ENABLE_LINES",
          "622: #line 1 \"src/fs_posix.c\"",
          "",
          "[Removed Lines]",
          "617: struct mg_fs mg_fs_packed = {packed_stat,  packed_list, packed_open,",
          "618:                              packed_close, packed_read, packed_write,",
          "619:                              packed_seek};",
          "",
          "[Added Lines]",
          "677: static bool packed_rename(const char *from, const char *to) {",
          "678:   (void) from, (void) to;",
          "679:   return false;",
          "680: }",
          "682: static bool packed_remove(const char *path) {",
          "683:   (void) path;",
          "684:   return false;",
          "685: }",
          "687: struct mg_fs mg_fs_packed = {packed_stat,  packed_list,   packed_open,",
          "688:                              packed_close, packed_read,   packed_write,",
          "689:                              packed_seek,  packed_rename, packed_remove};",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "779: }",
          "781: static void *p_open(const char *path, int flags) {",
          "786: #ifdef _WIN32",
          "787:   wchar_t b1[PATH_MAX], b2[10];",
          "788:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "",
          "[Removed Lines]",
          "782:   const char *mode = flags == (MG_FS_READ | MG_FS_WRITE) ? \"r+b\"",
          "783:                      : flags & MG_FS_READ                ? \"rb\"",
          "784:                      : flags & MG_FS_WRITE               ? \"wb\"",
          "785:                                                          : \"\";",
          "",
          "[Added Lines]",
          "852:   const char *mode = flags == MG_FS_READ ? \"rb\" : \"a+b\";",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "794: }",
          "796: static void p_close(void *fp) {",
          "798: }",
          "800: static size_t p_read(void *fp, void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "797:   if (fp != NULL) fclose((FILE *) fp);",
          "",
          "[Added Lines]",
          "864:   fclose((FILE *) fp);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "816:   return (size_t) ftell((FILE *) fp);",
          "817: }",
          "819: #else",
          "821: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "886: static bool p_rename(const char *from, const char *to) {",
          "887:   return rename(from, to) == 0;",
          "888: }",
          "890: static bool p_remove(const char *path) {",
          "891:   return remove(path) == 0;",
          "892: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "851:   (void) fd, (void) offset;",
          "852:   return (size_t) ~0;",
          "853: }",
          "854: #endif",
          "859: #ifdef MG_ENABLE_LINES",
          "860: #line 1 \"src/http.c\"",
          "",
          "[Removed Lines]",
          "856: struct mg_fs mg_fs_posix = {p_stat, p_list,  p_open, p_close,",
          "857:                             p_read, p_write, p_seek};",
          "",
          "[Added Lines]",
          "929: static bool p_rename(const char *from, const char *to) {",
          "930:   (void) from, (void) to;",
          "931:   return false;",
          "932: }",
          "933: static bool p_remove(const char *path) {",
          "934:   (void) path;",
          "935:   return false;",
          "936: }",
          "939: struct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close, p_read,",
          "940:                             p_write, p_seek, p_rename, p_remove};",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1748:   c->recv.len -= ch.len;",
          "1749: }",
          "1752: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "1754:   char offset[40] = \"\", name[200] = \"\", path[256];",
          "1755:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
          "1756:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "",
          "[Removed Lines]",
          "1751: #if MG_ENABLE_FILE",
          "1753:                    const char *dir) {",
          "",
          "[Added Lines]",
          "1835:                    struct mg_fs *fs, const char *dir) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1758:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "1759:     return -1;",
          "1760:   } else {",
          "1762:     long oft = strtol(offset, NULL, 0);",
          "1763:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "1764:     remove_double_dots(path);",
          "1765:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "1768:       return -2;",
          "1769:     } else {",
          "1772:       mg_http_reply(c, 200, \"\", \"\");",
          "1773:       return (int) hm->body.len;",
          "1774:     }",
          "1775:   }",
          "1776: }",
          "1779: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
          "1780:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "1761:     FILE *fp;",
          "1766:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
          "1767:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
          "1770:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
          "1771:       fclose(fp);",
          "1777: #endif",
          "",
          "[Added Lines]",
          "1843:     struct mg_fd *fd;",
          "1848:     if (oft == 0) fs->remove(path);",
          "1849:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "1850:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "1853:       fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "1854:       mg_fs_close(fd);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3840: #endif",
          "3843: #if MG_ENABLE_MBEDTLS",
          "3844: void mg_tls_handshake(struct mg_connection *c) {",
          "3845:   struct mg_tls *tls = (struct mg_tls *) c->tls;",
          "3846:   int rc;",
          "3848:   rc = mbedtls_ssl_handshake(&tls->ssl);",
          "3849:   if (rc == 0) {  // Success",
          "3850:     LOG(LL_DEBUG, (\"%lu success\", c->id));",
          "",
          "[Removed Lines]",
          "3847:   mbedtls_ssl_set_bio(&tls->ssl, &c->fd, mbedtls_net_send, mbedtls_net_recv, 0);",
          "",
          "[Added Lines]",
          "3928: #if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000",
          "3929: #define MGRNG , rng_get, NULL",
          "3930: #else",
          "3931: #define MGRNG",
          "3932: #endif",
          "3934: void mg_tls_free(struct mg_connection *c) {",
          "3935:   struct mg_tls *tls = (struct mg_tls *) c->tls;",
          "3936:   if (tls != NULL) {",
          "3937:     free(tls->cafile);",
          "3938:     mbedtls_ssl_free(&tls->ssl);",
          "3939:     mbedtls_pk_free(&tls->pk);",
          "3940:     mbedtls_x509_crt_free(&tls->ca);",
          "3941:     mbedtls_x509_crl_free(&tls->crl);",
          "3942:     mbedtls_x509_crt_free(&tls->cert);",
          "3943:     mbedtls_ssl_config_free(&tls->conf);",
          "3944:     free(tls);",
          "3945:     c->tls = NULL;",
          "3946:   }",
          "3947: }",
          "3949: static bool mg_wouldblock(int n) {",
          "3950:   return n < 0 &&",
          "3951:          (errno == EINPROGRESS || errno == EAGAIN || errno == EWOULDBLOCK);",
          "3952: }",
          "3954: static int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {",
          "3955:   int fd = *(int *) ctx;",
          "3956:   int n = (int) send(fd, buf, len, 0);",
          "3957:   if (n > 0) return n;",
          "3958:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_WRITE;",
          "3959:   return MBEDTLS_ERR_NET_SEND_FAILED;",
          "3960: }",
          "3962: static int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {",
          "3963:   int fd = *(int *) ctx;",
          "3964:   int n = (int) recv(fd, buf, len, 0);",
          "3965:   if (n > 0) return n;",
          "3966:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_READ;",
          "3967:   return MBEDTLS_ERR_NET_RECV_FAILED;",
          "3968: }",
          "3973:   mbedtls_ssl_set_bio(&tls->ssl, &c->fd, mg_net_send, mg_net_recv, 0);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3880: }",
          "3881: #endif",
          "3883: void mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {",
          "3884:   struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));",
          "3885:   int rc = 0;",
          "3899:     mg_error(c, \"TLS OOM\");",
          "3900:     goto fail;",
          "3901:   }",
          "3904:   mbedtls_ssl_init(&tls->ssl);",
          "3905:   mbedtls_ssl_config_init(&tls->conf);",
          "3906:   mbedtls_x509_crt_init(&tls->ca);",
          "",
          "[Removed Lines]",
          "3886:   const char *ca = opts->ca == NULL     ? \"-\"",
          "3887:                    : opts->ca[0] == '-' ? \"(emb)\"",
          "3888:                                         : opts->ca;",
          "3889:   const char *crl = opts->crl == NULL     ? \"-\"",
          "3890:                     : opts->crl[0] == '-' ? \"(emb)\"",
          "3891:                                           : opts->crl;",
          "3892:   const char *cert = opts->cert == NULL     ? \"-\"",
          "3893:                      : opts->cert[0] == '-' ? \"(emb)\"",
          "3894:                                             : opts->cert;",
          "3895:   const char *certkey = opts->certkey == NULL     ? \"-\"",
          "3896:                         : opts->certkey[0] == '-' ? \"(emb)\"",
          "3897:                                                   : opts->certkey;",
          "3898:   if (tls == NULL) {",
          "3902:   LOG(LL_DEBUG, (\"%lu Setting TLS, CA: %s, CRL: %s, cert: %s, key: %s\", c->id,",
          "3903:                  ca, crl, cert, certkey));",
          "",
          "[Added Lines]",
          "4009: static struct mg_str mg_loadfile(struct mg_fs *fs, const char *path) {",
          "4010:   size_t n = 0;",
          "4011:   if (path[0] == '-') return mg_str(path);",
          "4012:   char *p = mg_file_read(fs, path, &n);",
          "4013:   return mg_str_n(p, n);",
          "4014: }",
          "4017:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "4020:   c->tls = tls;",
          "4021:   if (c->tls == NULL) {",
          "4025:   LOG(LL_DEBUG, (\"%lu Setting TLS\", c->id));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3921:   mbedtls_ssl_conf_rng(&tls->conf, mbed_rng, c);",
          "3922:   if (opts->ca == NULL || strcmp(opts->ca, \"*\") == 0) {",
          "3923:     mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);",
          "3926:     if (opts->crl != NULL && opts->crl[0] != '\\0') {",
          "3931:       if (rc != 0) {",
          "3933:         goto fail;",
          "3934:       }",
          "3935:     }",
          "",
          "[Removed Lines]",
          "3924:   }",
          "3925:   if (opts->ca != NULL && opts->ca[0] != '\\0') {",
          "3927:       rc = opts->crl[0] == '-'",
          "3928:                ? mbedtls_x509_crl_parse(&tls->crl, (uint8_t *) opts->crl,",
          "3929:                                         strlen(opts->crl) + 1)",
          "3930:                : mbedtls_x509_crl_parse_file(&tls->crl, opts->crl);",
          "3932:         mg_error(c, \"parse(%s) err %#x\", crl, -rc);",
          "",
          "[Added Lines]",
          "4043:   } else if (opts->ca != NULL && opts->ca[0] != '\\0') {",
          "4045:       struct mg_str s = mg_loadfile(fs, opts->crl);",
          "4046:       rc = mbedtls_x509_crl_parse(&tls->crl, (uint8_t *) s.ptr, s.len + 1);",
          "4047:       if (opts->crl[0] != '-') free((char *) s.ptr);",
          "4049:         mg_error(c, \"parse(%s) err %#x\", opts->crl, -rc);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3941:       goto fail;",
          "3942:     }",
          "3943: #else",
          "3948:     if (rc != 0) {",
          "3950:       goto fail;",
          "3951:     }",
          "3952:     mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, &tls->crl);",
          "",
          "[Removed Lines]",
          "3944:     rc = opts->ca[0] == '-'",
          "3945:              ? mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) opts->ca,",
          "3946:                                       strlen(opts->ca) + 1)",
          "3947:              : mbedtls_x509_crt_parse_file(&tls->ca, opts->ca);",
          "3949:       mg_error(c, \"parse(%s) err %#x\", ca, -rc);",
          "",
          "[Added Lines]",
          "4061:     struct mg_str s = mg_loadfile(fs, opts->ca);",
          "4062:     rc = mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) s.ptr, s.len + 1);",
          "4063:     if (opts->ca[0] != '-') free((char *) s.ptr);",
          "4064:     LOG(LL_INFO, (\"%s %d\", opts->ca, (int) s.len));",
          "4066:       mg_error(c, \"parse(%s) err %#x\", opts->ca, -rc);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3961:     mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);",
          "3962:   }",
          "3963:   if (opts->cert != NULL && opts->cert[0] != '\\0') {",
          "3973:     if (rc != 0) {",
          "3975:       goto fail;",
          "3976:     }",
          "3980:     if (rc != 0) {",
          "3982:       goto fail;",
          "3983:     }",
          "3984:     rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk);",
          "",
          "[Removed Lines]",
          "3964:     const char *key = opts->certkey;",
          "3965:     if (key == NULL) {",
          "3966:       key = opts->cert;",
          "3967:       certkey = cert;",
          "3968:     }",
          "3969:     rc = opts->cert[0] == '-'",
          "3970:              ? mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) opts->cert,",
          "3971:                                       strlen(opts->cert) + 1)",
          "3972:              : mbedtls_x509_crt_parse_file(&tls->cert, opts->cert);",
          "3974:       mg_error(c, \"parse(%s) err %#x\", cert, -rc);",
          "3977:     rc = key[0] == '-' ? mbedtls_pk_parse_key(&tls->pk, (uint8_t *) key,",
          "3978:                                               strlen(key) + 1, NULL, 0 RNG)",
          "3979:                        : mbedtls_pk_parse_keyfile(&tls->pk, key, NULL RNG);",
          "3981:       mg_error(c, \"tls key(%s) %#x\", certkey, -rc);",
          "",
          "[Added Lines]",
          "4081:     struct mg_str s = mg_loadfile(fs, opts->cert);",
          "4082:     const char *key = opts->certkey == NULL ? opts->cert : opts->certkey;",
          "4083:     rc = mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) s.ptr, s.len + 1);",
          "4084:     if (opts->cert[0] != '-') free((char *) s.ptr);",
          "4086:       mg_error(c, \"parse(%s) err %#x\", opts->cert, -rc);",
          "4089:     s = mg_loadfile(fs, key);",
          "4090:     rc = mbedtls_pk_parse_key(&tls->pk, (uint8_t *) s.ptr, s.len + 1, NULL,",
          "4091:                               0 MGRNG);",
          "4092:     if (key[0] != '-') free((char *) s.ptr);",
          "4094:       mg_error(c, \"tls key(%s) %#x\", key, -rc);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3999:   }",
          "4000:   return;",
          "4001: fail:",
          "4004: }",
          "4006: long mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "4002:   c->is_closing = 1;",
          "4003:   free(tls);",
          "",
          "[Added Lines]",
          "4115:   mg_tls_free(c);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "4014:   long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);",
          "4015:   return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_WRITE ? 0 : n;",
          "4016: }",
          "4031: #endif",
          "4033: #ifdef MG_ENABLE_LINES",
          "",
          "[Removed Lines]",
          "4018: void mg_tls_free(struct mg_connection *c) {",
          "4019:   struct mg_tls *tls = (struct mg_tls *) c->tls;",
          "4020:   if (tls == NULL) return;",
          "4021:   free(tls->cafile);",
          "4022:   mbedtls_ssl_free(&tls->ssl);",
          "4023:   mbedtls_pk_free(&tls->pk);",
          "4024:   mbedtls_x509_crt_free(&tls->ca);",
          "4025:   mbedtls_x509_crl_free(&tls->crl);",
          "4026:   mbedtls_x509_crt_free(&tls->cert);",
          "4027:   mbedtls_ssl_config_free(&tls->conf);",
          "4028:   free(tls);",
          "4029:   c->tls = NULL;",
          "4030: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "4279: #include <mach/mach_time.h>",
          "4280: #endif",
          "4339: #if MG_ENABLE_CUSTOM_RANDOM",
          "4340: #else",
          "4341: void mg_random(void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "4282: #if MG_ENABLE_FILE",
          "4283: char *mg_file_read(const char *path, size_t *sizep) {",
          "4284:   FILE *fp;",
          "4285:   char *data = NULL;",
          "4286:   size_t size = 0;",
          "4287:   if ((fp = fopen(path, \"rb\")) != NULL) {",
          "4288:     fseek(fp, 0, SEEK_END);",
          "4289:     size = (size_t) ftell(fp);",
          "4290:     rewind(fp);",
          "4291:     data = (char *) calloc(1, size + 1);",
          "4292:     if (data != NULL) {",
          "4293:       if (fread(data, 1, size, fp) != size) {",
          "4294:         free(data);",
          "4295:         data = NULL;",
          "4296:       } else {",
          "4297:         data[size] = '\\0';",
          "4298:         if (sizep != NULL) *sizep = size;",
          "4299:       }",
          "4300:     }",
          "4301:     fclose(fp);",
          "4302:   }",
          "4303:   return data;",
          "4304: }",
          "4306: bool mg_file_write(const char *path, const void *buf, size_t len) {",
          "4307:   bool result = false;",
          "4308:   FILE *fp;",
          "4309:   char tmp[MG_PATH_MAX];",
          "4310:   snprintf(tmp, sizeof(tmp), \"%s.%d\", path, rand());",
          "4311:   fp = fopen(tmp, \"wb\");",
          "4312:   if (fp != NULL) {",
          "4313:     result = fwrite(buf, 1, len, fp) == len;",
          "4314:     fclose(fp);",
          "4315:     if (result) {",
          "4316:       remove(path);",
          "4317:       rename(tmp, path);",
          "4318:     } else {",
          "4319:       remove(tmp);",
          "4320:     }",
          "4321:   }",
          "4322:   return result;",
          "4323: }",
          "4325: bool mg_file_printf(const char *path, const char *fmt, ...) {",
          "4326:   char tmp[256], *buf = tmp;",
          "4327:   bool result;",
          "4328:   int len;",
          "4329:   va_list ap;",
          "4330:   va_start(ap, fmt);",
          "4331:   len = mg_vasprintf(&buf, sizeof(tmp), fmt, ap);",
          "4332:   va_end(ap);",
          "4333:   result = mg_file_write(path, buf, len > 0 ? (size_t) len : 0);",
          "4334:   if (buf != tmp) free(buf);",
          "4335:   return result;",
          "4336: }",
          "4337: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "617: void mg_random(void *buf, size_t len);",
          "618: bool mg_globmatch(const char *pattern, size_t plen, const char *s, size_t n);",
          "619: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);",
          "",
          "[Removed Lines]",
          "614: char *mg_file_read(const char *path, size_t *size);",
          "615: bool mg_file_write(const char *path, const void *buf, size_t len);",
          "616: bool mg_file_printf(const char *path, const char *fmt, ...);",
          "",
          "[Added Lines]",
          "613: enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };",
          "618: struct mg_fs {",
          "619:   int (*stat)(const char *path, size_t *size, time_t *mtime);",
          "620:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "621:   void *(*open)(const char *path, int flags);              // Open file",
          "622:   void (*close)(void *fd);                                 // Close file",
          "623:   size_t (*read)(void *fd, void *buf, size_t len);         // Read file",
          "624:   size_t (*write)(void *fd, const void *buf, size_t len);  // Write file",
          "625:   size_t (*seek)(void *fd, size_t offset);                 // Set file position",
          "626:   bool (*rename)(const char *from, const char *to);        // Rename",
          "627:   bool (*remove)(const char *path);                        // Delete file",
          "628: };",
          "631: struct mg_fd {",
          "632:   void *fd;",
          "633:   struct mg_fs *fs;",
          "634: };",
          "636: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags);",
          "637: void mg_fs_close(struct mg_fd *fd);",
          "638: char *mg_file_read(struct mg_fs *fs, const char *path, size_t *size);",
          "639: bool mg_file_write(struct mg_fs *fs, const char *path, const void *, size_t);",
          "640: bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...);",
          "642: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "643: extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/complete",
          "644: extern struct mg_fs mg_fs_fat;     // FAT FS",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "710: unsigned short mg_url_port(const char *url);",
          "711: int mg_url_is_ssl(const char *url);",
          "712: struct mg_str mg_url_host(const char *url);",
          "",
          "[Removed Lines]",
          "681: enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };",
          "686: struct mg_fs {",
          "687:   int (*stat)(const char *path, size_t *size, time_t *mtime);",
          "688:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "689:   void *(*open)(const char *path, int flags);              // Open file",
          "690:   void (*close)(void *fd);                                 // Close file",
          "691:   size_t (*read)(void *fd, void *buf, size_t len);         // Read file",
          "692:   size_t (*write)(void *fd, const void *buf, size_t len);  // Write file",
          "693:   size_t (*seek)(void *fd, size_t offset);                 // Set file position",
          "694: };",
          "697: struct mg_fd {",
          "698:   void *fd;",
          "699:   struct mg_fs *fs;",
          "700: };",
          "701: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags);",
          "702: void mg_fs_close(struct mg_fd *fd);",
          "704: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "705: extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/complete",
          "706: extern struct mg_fs mg_fs_fat;     // FAT FS",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "930: void mg_http_creds(struct mg_http_message *, char *, size_t, char *, size_t);",
          "931: bool mg_http_match_uri(const struct mg_http_message *, const char *glob);",
          "932: int mg_http_upload(struct mg_connection *, struct mg_http_message *hm,",
          "934: void mg_http_bauth(struct mg_connection *, const char *user, const char *pass);",
          "935: struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);",
          "936: size_t mg_http_next_multipart(struct mg_str, size_t, struct mg_http_part *);",
          "",
          "[Removed Lines]",
          "933:                    const char *dir);",
          "",
          "[Added Lines]",
          "936:                    struct mg_fs *fs, const char *dir);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "951:   const char *certkey;    // Certificate key",
          "952:   const char *ciphers;    // Cipher list",
          "953:   struct mg_str srvname;  // If not empty, enables server name verification",
          "954: };",
          "956: void mg_tls_init(struct mg_connection *, struct mg_tls_opts *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "957:   struct mg_fs *fs;       // FS API for reading certificate files",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "968: #include <mbedtls/debug.h>",
          "969: #include <mbedtls/ssl.h>",
          "981: struct mg_tls {",
          "982:   char *cafile;             // CA certificate path",
          "983:   mbedtls_x509_crt ca;      // Parsed CA certificate",
          "",
          "[Removed Lines]",
          "971: #if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000",
          "972: #define RNG , rng_get, NULL",
          "973: #else",
          "974: #define RNG",
          "975: #endif",
          "978: EXTERN_C int mbedtls_net_recv(void *, unsigned char *, size_t);",
          "979: EXTERN_C int mbedtls_net_send(void *, const unsigned char *, size_t);",
          "",
          "[Added Lines]",
          "973: #include <mbedtls/net_sockets.h>",
          "",
          "---------------"
        ],
        "src/fs.c||src/fs.c": [
          "File: src/fs.c -> src/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"fs.h\"",
          "3: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {",
          "4:   struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include \"util.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19:     free(fd);",
          "20:   }",
          "21: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: char *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {",
          "25:   struct mg_fd *fd;",
          "26:   char *data = NULL;",
          "27:   size_t size = 0;",
          "28:   fs->stat(path, &size, NULL);",
          "29:   if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {",
          "30:     data = (char *) calloc(1, size + 1);",
          "31:     if (data != NULL) {",
          "32:       if (fs->read(fd->fd, data, size) != size) {",
          "33:         free(data);",
          "34:         data = NULL;",
          "35:       } else {",
          "36:         data[size] = '\\0';",
          "37:         if (sizep != NULL) *sizep = size;",
          "38:       }",
          "39:     }",
          "40:     mg_fs_close(fd);",
          "41:   }",
          "42:   return data;",
          "43: }",
          "45: bool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,",
          "46:                    size_t len) {",
          "47:   bool result = false;",
          "48:   struct mg_fd *fd;",
          "49:   char tmp[MG_PATH_MAX];",
          "50:   snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "51:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "52:     result = fs->write(fd->fd, buf, len) == len;",
          "53:     mg_fs_close(fd);",
          "54:     if (result) {",
          "55:       fs->remove(path);",
          "56:       fs->rename(tmp, path);",
          "57:     } else {",
          "58:       fs->remove(tmp);",
          "59:     }",
          "60:   }",
          "61:   return result;",
          "62: }",
          "64: bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {",
          "65:   char tmp[256], *buf = tmp;",
          "66:   bool result;",
          "67:   int len;",
          "68:   va_list ap;",
          "69:   va_start(ap, fmt);",
          "70:   len = mg_vasprintf(&buf, sizeof(tmp), fmt, ap);",
          "71:   va_end(ap);",
          "72:   result = mg_file_write(fs, path, buf, len > 0 ? (size_t) len : 0);",
          "73:   if (buf != tmp) free(buf);",
          "74:   return result;",
          "75: }",
          "",
          "---------------"
        ],
        "src/fs.h||src/fs.h": [
          "File: src/fs.h -> src/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:   size_t (*read)(void *fd, void *buf, size_t len);         // Read file",
          "17:   size_t (*write)(void *fd, const void *buf, size_t len);  // Write file",
          "18:   size_t (*seek)(void *fd, size_t offset);                 // Set file position",
          "19: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19:   bool (*rename)(const char *from, const char *to);        // Rename",
          "20:   bool (*remove)(const char *path);                        // Delete file",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23:   void *fd;",
          "24:   struct mg_fs *fs;",
          "25: };",
          "26: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags);",
          "27: void mg_fs_close(struct mg_fd *fd);",
          "29: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "30: extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/complete",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: char *mg_file_read(struct mg_fs *fs, const char *path, size_t *size);",
          "32: bool mg_file_write(struct mg_fs *fs, const char *path, const void *, size_t);",
          "33: bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...);",
          "",
          "---------------"
        ],
        "src/fs_fat.c||src/fs_fat.c": [
          "File: src/fs_fat.c -> src/fs_fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: static void *ff_open(const char *path, int flags) {",
          "39:   FIL f;",
          "44:   if (f_open(&f, path, mode) == 0) {",
          "45:     FIL *fp = calloc(1, sizeof(*fp));",
          "",
          "[Removed Lines]",
          "40:   const char mode = flags == (MG_FS_READ | MG_FS_WRITE) ? FA_READ | FA_WRITE",
          "41:                     : flags & MG_FS_READ                ? FA_READ",
          "42:                     : flags & MG_FS_WRITE               ? FA_WRITE",
          "43:                                                         : 0;",
          "",
          "[Added Lines]",
          "40:   unsigned char mode =",
          "41:       flags == MG_FS_READ ? FA_READ : FA_READ | FA_WRITE | FA_OPEN_APPEND;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:   return offset;",
          "75: }",
          "79: #endif",
          "",
          "[Removed Lines]",
          "77: struct mg_fs mg_fs_fat = {ff_stat, ff_list,  ff_open, ff_close,",
          "78:                           ff_read, ff_write, ff_seek};",
          "",
          "[Added Lines]",
          "75: static bool ff_rename(const char *from, const char *to) {",
          "76:   return ff_rename(from, to) == FR_OK;",
          "77: }",
          "79: static bool ff_remove(const char *path) {",
          "80:   return ff_remove(path) == 0;",
          "81: }",
          "83: struct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close, ff_read,",
          "84:                           ff_write, ff_seek, ff_rename, ff_remove};",
          "",
          "---------------"
        ],
        "src/fs_packed.c||src/fs_packed.c": [
          "File: src/fs_packed.c -> src/fs_packed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:   return fp->pos;",
          "94: }",
          "",
          "[Removed Lines]",
          "96: struct mg_fs mg_fs_packed = {packed_stat,  packed_list, packed_open,",
          "97:                              packed_close, packed_read, packed_write,",
          "98:                              packed_seek};",
          "",
          "[Added Lines]",
          "96: static bool packed_rename(const char *from, const char *to) {",
          "97:   (void) from, (void) to;",
          "98:   return false;",
          "99: }",
          "101: static bool packed_remove(const char *path) {",
          "102:   (void) path;",
          "103:   return false;",
          "104: }",
          "106: struct mg_fs mg_fs_packed = {packed_stat,  packed_list,   packed_open,",
          "107:                              packed_close, packed_read,   packed_write,",
          "108:                              packed_seek,  packed_rename, packed_remove};",
          "",
          "---------------"
        ],
        "src/fs_posix.c||src/fs_posix.c": [
          "File: src/fs_posix.c -> src/fs_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "156: }",
          "158: static void *p_open(const char *path, int flags) {",
          "163: #ifdef _WIN32",
          "164:   wchar_t b1[PATH_MAX], b2[10];",
          "165:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "",
          "[Removed Lines]",
          "159:   const char *mode = flags == (MG_FS_READ | MG_FS_WRITE) ? \"r+b\"",
          "160:                      : flags & MG_FS_READ                ? \"rb\"",
          "161:                      : flags & MG_FS_WRITE               ? \"wb\"",
          "162:                                                          : \"\";",
          "",
          "[Added Lines]",
          "159:   const char *mode = flags == MG_FS_READ ? \"rb\" : \"a+b\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171: }",
          "173: static void p_close(void *fp) {",
          "175: }",
          "177: static size_t p_read(void *fp, void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "174:   if (fp != NULL) fclose((FILE *) fp);",
          "",
          "[Added Lines]",
          "171:   fclose((FILE *) fp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "193:   return (size_t) ftell((FILE *) fp);",
          "194: }",
          "196: #else",
          "198: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: static bool p_rename(const char *from, const char *to) {",
          "194:   return rename(from, to) == 0;",
          "195: }",
          "197: static bool p_remove(const char *path) {",
          "198:   return remove(path) == 0;",
          "199: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:   (void) fd, (void) offset;",
          "229:   return (size_t) ~0;",
          "230: }",
          "231: #endif",
          "",
          "[Removed Lines]",
          "233: struct mg_fs mg_fs_posix = {p_stat, p_list,  p_open, p_close,",
          "234:                             p_read, p_write, p_seek};",
          "",
          "[Added Lines]",
          "236: static bool p_rename(const char *from, const char *to) {",
          "237:   (void) from, (void) to;",
          "238:   return false;",
          "239: }",
          "240: static bool p_remove(const char *path) {",
          "241:   (void) path;",
          "242:   return false;",
          "243: }",
          "246: struct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close, p_read,",
          "247:                             p_write, p_seek, p_rename, p_remove};",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "887:   c->recv.len -= ch.len;",
          "888: }",
          "891: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "893:   char offset[40] = \"\", name[200] = \"\", path[256];",
          "894:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
          "895:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "",
          "[Removed Lines]",
          "890: #if MG_ENABLE_FILE",
          "892:                    const char *dir) {",
          "",
          "[Added Lines]",
          "891:                    struct mg_fs *fs, const char *dir) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "897:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "898:     return -1;",
          "899:   } else {",
          "901:     long oft = strtol(offset, NULL, 0);",
          "902:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "903:     remove_double_dots(path);",
          "904:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "907:       return -2;",
          "908:     } else {",
          "911:       mg_http_reply(c, 200, \"\", \"\");",
          "912:       return (int) hm->body.len;",
          "913:     }",
          "914:   }",
          "915: }",
          "918: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
          "919:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "900:     FILE *fp;",
          "905:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
          "906:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
          "909:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
          "910:       fclose(fp);",
          "916: #endif",
          "",
          "[Added Lines]",
          "899:     struct mg_fd *fd;",
          "904:     if (oft == 0) fs->remove(path);",
          "905:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "906:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "909:       fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "910:       mg_fs_close(fd);",
          "",
          "---------------"
        ],
        "src/http.h||src/http.h": [
          "File: src/http.h -> src/http.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: void mg_http_creds(struct mg_http_message *, char *, size_t, char *, size_t);",
          "59: bool mg_http_match_uri(const struct mg_http_message *, const char *glob);",
          "60: int mg_http_upload(struct mg_connection *, struct mg_http_message *hm,",
          "62: void mg_http_bauth(struct mg_connection *, const char *user, const char *pass);",
          "63: struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);",
          "64: size_t mg_http_next_multipart(struct mg_str, size_t, struct mg_http_part *);",
          "",
          "[Removed Lines]",
          "61:                    const char *dir);",
          "",
          "[Added Lines]",
          "61:                    struct mg_fs *fs, const char *dir);",
          "",
          "---------------"
        ],
        "src/tls.h||src/tls.h": [
          "File: src/tls.h -> src/tls.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:   const char *certkey;    // Certificate key",
          "12:   const char *ciphers;    // Cipher list",
          "13:   struct mg_str srvname;  // If not empty, enables server name verification",
          "14: };",
          "16: void mg_tls_init(struct mg_connection *, struct mg_tls_opts *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14:   struct mg_fs *fs;       // FS API for reading certificate files",
          "",
          "---------------"
        ],
        "src/tls_mbed.c||src/tls_mbed.c": [
          "File: src/tls_mbed.c -> src/tls_mbed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"tls.h\"",
          "3: #if MG_ENABLE_MBEDTLS",
          "4: void mg_tls_handshake(struct mg_connection *c) {",
          "5:   struct mg_tls *tls = (struct mg_tls *) c->tls;",
          "6:   int rc;",
          "8:   rc = mbedtls_ssl_handshake(&tls->ssl);",
          "9:   if (rc == 0) {  // Success",
          "10:     LOG(LL_DEBUG, (\"%lu success\", c->id));",
          "",
          "[Removed Lines]",
          "7:   mbedtls_ssl_set_bio(&tls->ssl, &c->fd, mbedtls_net_send, mbedtls_net_recv, 0);",
          "",
          "[Added Lines]",
          "1: #include \"fs.h\"",
          "6: #if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000",
          "7: #define MGRNG , rng_get, NULL",
          "8: #else",
          "9: #define MGRNG",
          "10: #endif",
          "12: void mg_tls_free(struct mg_connection *c) {",
          "13:   struct mg_tls *tls = (struct mg_tls *) c->tls;",
          "14:   if (tls != NULL) {",
          "15:     free(tls->cafile);",
          "16:     mbedtls_ssl_free(&tls->ssl);",
          "17:     mbedtls_pk_free(&tls->pk);",
          "18:     mbedtls_x509_crt_free(&tls->ca);",
          "19:     mbedtls_x509_crl_free(&tls->crl);",
          "20:     mbedtls_x509_crt_free(&tls->cert);",
          "21:     mbedtls_ssl_config_free(&tls->conf);",
          "22:     free(tls);",
          "23:     c->tls = NULL;",
          "24:   }",
          "25: }",
          "27: static bool mg_wouldblock(int n) {",
          "28:   return n < 0 &&",
          "29:          (errno == EINPROGRESS || errno == EAGAIN || errno == EWOULDBLOCK);",
          "30: }",
          "32: static int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {",
          "33:   int fd = *(int *) ctx;",
          "34:   int n = (int) send(fd, buf, len, 0);",
          "35:   if (n > 0) return n;",
          "36:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_WRITE;",
          "37:   return MBEDTLS_ERR_NET_SEND_FAILED;",
          "38: }",
          "40: static int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {",
          "41:   int fd = *(int *) ctx;",
          "42:   int n = (int) recv(fd, buf, len, 0);",
          "43:   if (n > 0) return n;",
          "44:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_READ;",
          "45:   return MBEDTLS_ERR_NET_RECV_FAILED;",
          "46: }",
          "51:   mbedtls_ssl_set_bio(&tls->ssl, &c->fd, mg_net_send, mg_net_recv, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40: }",
          "41: #endif",
          "43: void mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {",
          "44:   struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));",
          "45:   int rc = 0;",
          "59:     mg_error(c, \"TLS OOM\");",
          "60:     goto fail;",
          "61:   }",
          "64:   mbedtls_ssl_init(&tls->ssl);",
          "65:   mbedtls_ssl_config_init(&tls->conf);",
          "66:   mbedtls_x509_crt_init(&tls->ca);",
          "",
          "[Removed Lines]",
          "46:   const char *ca = opts->ca == NULL     ? \"-\"",
          "47:                    : opts->ca[0] == '-' ? \"(emb)\"",
          "48:                                         : opts->ca;",
          "49:   const char *crl = opts->crl == NULL     ? \"-\"",
          "50:                     : opts->crl[0] == '-' ? \"(emb)\"",
          "51:                                           : opts->crl;",
          "52:   const char *cert = opts->cert == NULL     ? \"-\"",
          "53:                      : opts->cert[0] == '-' ? \"(emb)\"",
          "54:                                             : opts->cert;",
          "55:   const char *certkey = opts->certkey == NULL     ? \"-\"",
          "56:                         : opts->certkey[0] == '-' ? \"(emb)\"",
          "57:                                                   : opts->certkey;",
          "58:   if (tls == NULL) {",
          "62:   LOG(LL_DEBUG, (\"%lu Setting TLS, CA: %s, CRL: %s, cert: %s, key: %s\", c->id,",
          "63:                  ca, crl, cert, certkey));",
          "",
          "[Added Lines]",
          "87: static struct mg_str mg_loadfile(struct mg_fs *fs, const char *path) {",
          "88:   size_t n = 0;",
          "89:   if (path[0] == '-') return mg_str(path);",
          "90:   char *p = mg_file_read(fs, path, &n);",
          "91:   return mg_str_n(p, n);",
          "92: }",
          "95:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "98:   c->tls = tls;",
          "99:   if (c->tls == NULL) {",
          "103:   LOG(LL_DEBUG, (\"%lu Setting TLS\", c->id));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:   mbedtls_ssl_conf_rng(&tls->conf, mbed_rng, c);",
          "82:   if (opts->ca == NULL || strcmp(opts->ca, \"*\") == 0) {",
          "83:     mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);",
          "86:     if (opts->crl != NULL && opts->crl[0] != '\\0') {",
          "91:       if (rc != 0) {",
          "93:         goto fail;",
          "94:       }",
          "95:     }",
          "",
          "[Removed Lines]",
          "84:   }",
          "85:   if (opts->ca != NULL && opts->ca[0] != '\\0') {",
          "87:       rc = opts->crl[0] == '-'",
          "88:                ? mbedtls_x509_crl_parse(&tls->crl, (uint8_t *) opts->crl,",
          "89:                                         strlen(opts->crl) + 1)",
          "90:                : mbedtls_x509_crl_parse_file(&tls->crl, opts->crl);",
          "92:         mg_error(c, \"parse(%s) err %#x\", crl, -rc);",
          "",
          "[Added Lines]",
          "121:   } else if (opts->ca != NULL && opts->ca[0] != '\\0') {",
          "123:       struct mg_str s = mg_loadfile(fs, opts->crl);",
          "124:       rc = mbedtls_x509_crl_parse(&tls->crl, (uint8_t *) s.ptr, s.len + 1);",
          "125:       if (opts->crl[0] != '-') free((char *) s.ptr);",
          "127:         mg_error(c, \"parse(%s) err %#x\", opts->crl, -rc);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "101:       goto fail;",
          "102:     }",
          "103: #else",
          "108:     if (rc != 0) {",
          "110:       goto fail;",
          "111:     }",
          "112:     mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, &tls->crl);",
          "",
          "[Removed Lines]",
          "104:     rc = opts->ca[0] == '-'",
          "105:              ? mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) opts->ca,",
          "106:                                       strlen(opts->ca) + 1)",
          "107:              : mbedtls_x509_crt_parse_file(&tls->ca, opts->ca);",
          "109:       mg_error(c, \"parse(%s) err %#x\", ca, -rc);",
          "",
          "[Added Lines]",
          "139:     struct mg_str s = mg_loadfile(fs, opts->ca);",
          "140:     rc = mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) s.ptr, s.len + 1);",
          "141:     if (opts->ca[0] != '-') free((char *) s.ptr);",
          "142:     LOG(LL_INFO, (\"%s %d\", opts->ca, (int) s.len));",
          "144:       mg_error(c, \"parse(%s) err %#x\", opts->ca, -rc);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "121:     mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);",
          "122:   }",
          "123:   if (opts->cert != NULL && opts->cert[0] != '\\0') {",
          "133:     if (rc != 0) {",
          "135:       goto fail;",
          "136:     }",
          "140:     if (rc != 0) {",
          "142:       goto fail;",
          "143:     }",
          "144:     rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk);",
          "",
          "[Removed Lines]",
          "124:     const char *key = opts->certkey;",
          "125:     if (key == NULL) {",
          "126:       key = opts->cert;",
          "127:       certkey = cert;",
          "128:     }",
          "129:     rc = opts->cert[0] == '-'",
          "130:              ? mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) opts->cert,",
          "131:                                       strlen(opts->cert) + 1)",
          "132:              : mbedtls_x509_crt_parse_file(&tls->cert, opts->cert);",
          "134:       mg_error(c, \"parse(%s) err %#x\", cert, -rc);",
          "137:     rc = key[0] == '-' ? mbedtls_pk_parse_key(&tls->pk, (uint8_t *) key,",
          "138:                                               strlen(key) + 1, NULL, 0 RNG)",
          "139:                        : mbedtls_pk_parse_keyfile(&tls->pk, key, NULL RNG);",
          "141:       mg_error(c, \"tls key(%s) %#x\", certkey, -rc);",
          "",
          "[Added Lines]",
          "159:     struct mg_str s = mg_loadfile(fs, opts->cert);",
          "160:     const char *key = opts->certkey == NULL ? opts->cert : opts->certkey;",
          "161:     rc = mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) s.ptr, s.len + 1);",
          "162:     if (opts->cert[0] != '-') free((char *) s.ptr);",
          "164:       mg_error(c, \"parse(%s) err %#x\", opts->cert, -rc);",
          "167:     s = mg_loadfile(fs, key);",
          "168:     rc = mbedtls_pk_parse_key(&tls->pk, (uint8_t *) s.ptr, s.len + 1, NULL,",
          "169:                               0 MGRNG);",
          "170:     if (key[0] != '-') free((char *) s.ptr);",
          "172:       mg_error(c, \"tls key(%s) %#x\", key, -rc);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "159:   }",
          "160:   return;",
          "161: fail:",
          "164: }",
          "166: long mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "162:   c->is_closing = 1;",
          "163:   free(tls);",
          "",
          "[Added Lines]",
          "193:   mg_tls_free(c);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "174:   long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);",
          "175:   return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_WRITE ? 0 : n;",
          "176: }",
          "191: #endif",
          "",
          "[Removed Lines]",
          "178: void mg_tls_free(struct mg_connection *c) {",
          "179:   struct mg_tls *tls = (struct mg_tls *) c->tls;",
          "180:   if (tls == NULL) return;",
          "181:   free(tls->cafile);",
          "182:   mbedtls_ssl_free(&tls->ssl);",
          "183:   mbedtls_pk_free(&tls->pk);",
          "184:   mbedtls_x509_crt_free(&tls->ca);",
          "185:   mbedtls_x509_crl_free(&tls->crl);",
          "186:   mbedtls_x509_crt_free(&tls->cert);",
          "187:   mbedtls_ssl_config_free(&tls->conf);",
          "188:   free(tls);",
          "189:   c->tls = NULL;",
          "190: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/tls_mbed.h||src/tls_mbed.h": [
          "File: src/tls_mbed.h -> src/tls_mbed.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"util.h\"",
          "8: #include <mbedtls/debug.h>",
          "9: #include <mbedtls/ssl.h>",
          "21: struct mg_tls {",
          "22:   char *cafile;             // CA certificate path",
          "23:   mbedtls_x509_crt ca;      // Parsed CA certificate",
          "",
          "[Removed Lines]",
          "11: #if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000",
          "12: #define RNG , rng_get, NULL",
          "13: #else",
          "14: #define RNG",
          "15: #endif",
          "18: EXTERN_C int mbedtls_net_recv(void *, unsigned char *, size_t);",
          "19: EXTERN_C int mbedtls_net_send(void *, const unsigned char *, size_t);",
          "",
          "[Added Lines]",
          "9: #include <mbedtls/net_sockets.h>",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <mach/mach_time.h>",
          "5: #endif",
          "64: #if MG_ENABLE_CUSTOM_RANDOM",
          "65: #else",
          "66: void mg_random(void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "7: #if MG_ENABLE_FILE",
          "8: char *mg_file_read(const char *path, size_t *sizep) {",
          "9:   FILE *fp;",
          "10:   char *data = NULL;",
          "11:   size_t size = 0;",
          "12:   if ((fp = fopen(path, \"rb\")) != NULL) {",
          "13:     fseek(fp, 0, SEEK_END);",
          "14:     size = (size_t) ftell(fp);",
          "15:     rewind(fp);",
          "16:     data = (char *) calloc(1, size + 1);",
          "17:     if (data != NULL) {",
          "18:       if (fread(data, 1, size, fp) != size) {",
          "19:         free(data);",
          "20:         data = NULL;",
          "21:       } else {",
          "22:         data[size] = '\\0';",
          "23:         if (sizep != NULL) *sizep = size;",
          "24:       }",
          "25:     }",
          "26:     fclose(fp);",
          "27:   }",
          "28:   return data;",
          "29: }",
          "31: bool mg_file_write(const char *path, const void *buf, size_t len) {",
          "32:   bool result = false;",
          "33:   FILE *fp;",
          "34:   char tmp[MG_PATH_MAX];",
          "35:   snprintf(tmp, sizeof(tmp), \"%s.%d\", path, rand());",
          "36:   fp = fopen(tmp, \"wb\");",
          "37:   if (fp != NULL) {",
          "38:     result = fwrite(buf, 1, len, fp) == len;",
          "39:     fclose(fp);",
          "40:     if (result) {",
          "41:       remove(path);",
          "42:       rename(tmp, path);",
          "43:     } else {",
          "44:       remove(tmp);",
          "45:     }",
          "46:   }",
          "47:   return result;",
          "48: }",
          "50: bool mg_file_printf(const char *path, const char *fmt, ...) {",
          "51:   char tmp[256], *buf = tmp;",
          "52:   bool result;",
          "53:   int len;",
          "54:   va_list ap;",
          "55:   va_start(ap, fmt);",
          "56:   len = mg_vasprintf(&buf, sizeof(tmp), fmt, ap);",
          "57:   va_end(ap);",
          "58:   result = mg_file_write(path, buf, len > 0 ? (size_t) len : 0);",
          "59:   if (buf != tmp) free(buf);",
          "60:   return result;",
          "61: }",
          "62: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/util.h||src/util.h": [
          "File: src/util.h -> src/util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include \"config.h\"",
          "5: #include \"str.h\"",
          "10: void mg_random(void *buf, size_t len);",
          "11: bool mg_globmatch(const char *pattern, size_t plen, const char *s, size_t n);",
          "12: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);",
          "",
          "[Removed Lines]",
          "7: char *mg_file_read(const char *path, size_t *size);",
          "8: bool mg_file_write(const char *path, const void *buf, size_t len);",
          "9: bool mg_file_printf(const char *path, const char *fmt, ...);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "380:       mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass));",
          "381:       mg_http_reply(c, 200, \"\", \"[%s]:[%s]\", user, pass);",
          "382:     } else if (mg_http_match_uri(hm, \"/upload\")) {",
          "384:     } else if (mg_http_match_uri(hm, \"/test/\")) {",
          "385:       struct mg_http_serve_opts sopts;",
          "386:       memset(&sopts, 0, sizeof(sopts));",
          "",
          "[Removed Lines]",
          "383:       mg_http_upload(c, hm, \".\");",
          "",
          "[Added Lines]",
          "383:       mg_http_upload(c, hm, &mg_fs_posix, \".\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "416: };",
          "418: static void fcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {",
          "419:   if (ev == MG_EV_HTTP_MSG) {",
          "420:     struct mg_http_message *hm = (struct mg_http_message *) ev_data;",
          "422:     snprintf(fd->buf, FETCH_BUF_SIZE, \"%.*s\", (int) hm->message.len,",
          "423:              hm->message.ptr);",
          "424:     fd->code = atoi(hm->uri.ptr);",
          "",
          "[Removed Lines]",
          "421:     struct fetch_data *fd = (struct fetch_data *) fn_data;",
          "",
          "[Added Lines]",
          "419:   struct fetch_data *fd = (struct fetch_data *) fn_data;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:       opts.srvname = host;",
          "449:     }",
          "450:     mg_tls_init(c, &opts);",
          "452:   }",
          "453:   va_start(ap, fmt);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "451:     if (c->tls == NULL) fd.closed = 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "617:   ASSERT(cmpbody(buf, \"Invalid web root [/BAAADDD!]\\n\") == 0);",
          "619:   {",
          "621:     ASSERT(fetch(&mgr, buf, url, \"GET /ca.pem HTTP/1.0\\r\\n\\n\") == 200);",
          "622:     ASSERT(cmpbody(buf, data) == 0);",
          "623:     free(data);",
          "",
          "[Removed Lines]",
          "620:     char *data = mg_file_read(\"./test/data/ca.pem\", NULL);",
          "",
          "[Added Lines]",
          "621:     char *data = mg_file_read(&mg_fs_posix, \"./test/data/ca.pem\", NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "679:     char *p;",
          "680:     remove(\"uploaded.txt\");",
          "682:     ASSERT(fetch(&mgr, buf, url,",
          "683:                  \"POST /upload HTTP/1.0\\n\"",
          "684:                  \"Content-Length: 1\\n\\nx\") == 400);",
          "",
          "[Removed Lines]",
          "681:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);",
          "",
          "[Added Lines]",
          "682:     ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) == NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "691:                  \"POST /upload?name=uploaded.txt&offset=5 HTTP/1.0\\r\\n\"",
          "692:                  \"Content-Length: 6\\r\\n\"",
          "693:                  \"\\r\\n\\nworld\") == 200);",
          "695:     ASSERT(strcmp(p, \"hello\\nworld\") == 0);",
          "696:     free(p);",
          "697:     remove(\"uploaded.txt\");",
          "",
          "[Removed Lines]",
          "694:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);",
          "",
          "[Added Lines]",
          "695:     ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) != NULL);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "702:     char *p;",
          "703:     remove(\"uploaded.txt\");",
          "705:     ASSERT(fetch(&mgr, buf, url,",
          "706:                  \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"",
          "707:                  \"Content-Length: 5\\r\\n\"",
          "708:                  \"\\r\\nhello\") == 200);",
          "710:     ASSERT(strcmp(p, \"hello\") == 0);",
          "711:     free(p);",
          "712:     remove(\"uploaded.txt\");",
          "",
          "[Removed Lines]",
          "704:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);",
          "709:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);",
          "",
          "[Added Lines]",
          "705:     ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) == NULL);",
          "710:     ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) != NULL);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1213:   ASSERT(s != NULL);",
          "1214:   free(s);",
          "1215:   memset(&a, 0, sizeof(a));",
          "1218:   ASSERT(strcmp(p, \"hi\") == 0);",
          "1219:   free(p);",
          "1220:   remove(\"data.txt\");",
          "",
          "[Removed Lines]",
          "1216:   ASSERT(mg_file_printf(\"data.txt\", \"%s\", \"hi\") == true);",
          "1217:   ASSERT((p = mg_file_read(\"data.txt\", NULL)) != NULL);",
          "",
          "[Added Lines]",
          "1217:   ASSERT(mg_file_printf(&mg_fs_posix, \"data.txt\", \"%s\", \"hi\") == true);",
          "1218:   if (system(\"ls -l\") != 0) (void) 0;",
          "1219:   ASSERT((p = mg_file_read(&mg_fs_posix, \"data.txt\", NULL)) != NULL);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1462: static void test_packed(void) {",
          "1463:   struct mg_mgr mgr;",
          "1464:   const char *url = \"http://127.0.0.1:12351\";",
          "1466:   mg_mgr_init(&mgr);",
          "1467:   mg_http_listen(&mgr, url, eh7, NULL);",
          "",
          "[Removed Lines]",
          "1465:   char buf[FETCH_BUF_SIZE] = \"\", *data = mg_file_read(\"Makefile\", NULL);",
          "",
          "[Added Lines]",
          "1467:   char buf[FETCH_BUF_SIZE] = \"\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1472:   free(data);",
          "1476:   ASSERT(fetch(&mgr, buf, url, \"GET /src/ssi.h HTTP/1.0\\n\\n\") == 200);",
          "1477:   ASSERT(cmpbody(buf, data) == 0);",
          "1478:   free(data);",
          "",
          "[Removed Lines]",
          "1475:   data = mg_file_read(\"src/ssi.h\", NULL);",
          "",
          "[Added Lines]",
          "1478:   data = mg_file_read(&mg_fs_posix, \"src/ssi.h\", NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4cd830a0bf87e5b7416285ce2880f183ab867e32",
      "candidate_info": {
        "commit_hash": "4cd830a0bf87e5b7416285ce2880f183ab867e32",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/4cd830a0bf87e5b7416285ce2880f183ab867e32",
        "files": [
          "mongoose.c",
          "mongoose.h",
          "src/config.h",
          "src/fs.h",
          "src/fs_fat.c",
          "src/http.c"
        ],
        "message": "Improve ff_write - save large blocks in chunks",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/config.h||src/config.h",
          "src/fs.h||src/fs.h",
          "src/fs_fat.c||src/fs_fat.c",
          "src/http.c||src/http.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "495: #if MG_ENABLE_FATFS",
          "496: #include <ff.h>",
          "502: static int ff_stat(const char *path, size_t *size, time_t *mtime) {",
          "503:   FILINFO fi;",
          "504:   if (path[0] == '\\0' || strcmp(path, MG_FATFS_ROOT) == 0) {",
          "",
          "[Removed Lines]",
          "498: #if !defined(MG_FATFS_ROOT)",
          "499: #define MG_FATFS_ROOT \"/\"",
          "500: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "554: }",
          "556: static size_t ff_write(void *fp, const void *buf, size_t len) {",
          "560: }",
          "562: static size_t ff_seek(void *fp, size_t offset) {",
          "",
          "[Removed Lines]",
          "557:   unsigned n = 0;",
          "558:   f_write((FIL *) fp, buf, len, &n);",
          "559:   return n;",
          "",
          "[Added Lines]",
          "553:   unsigned n, sum = 0, bs = MG_FATFS_BSIZE;",
          "554:   while ((size_t) sum < len &&",
          "555:          f_write((FIL *) fp, (char *) buf + sum,",
          "556:                  sum + bs > len ? len - sum : bs, &n) == FR_OK &&",
          "557:          n > 0) {",
          "558:     sum += n;",
          "559:   }",
          "560:   return sum;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1865:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "1866:       return -2;",
          "1867:     } else {",
          "1869:       mg_fs_close(fd);",
          "1871:       return (int) hm->body.len;",
          "1872:     }",
          "1873:   }",
          "",
          "[Removed Lines]",
          "1868:       fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "1870:       mg_http_reply(c, 200, \"\", \"\");",
          "",
          "[Added Lines]",
          "1869:       int written = (int) fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "1871:       mg_http_reply(c, 200, \"\", \"%d\", written);",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "446: #define MG_ENABLE_FATFS 0",
          "447: #endif",
          "449: #ifndef MG_ENABLE_SOCKET",
          "450: #define MG_ENABLE_SOCKET 1",
          "451: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "449: #ifndef MG_FATFS_ROOT",
          "450: #define MG_FATFS_ROOT \"/\"",
          "451: #endif",
          "453: #ifndef MG_FATFS_BSIZE",
          "454: #define MG_FATFS_BSIZE 64",
          "455: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "626:   size_t (*seek)(void *fd, size_t offset);                 // Set file position",
          "627:   bool (*rename)(const char *from, const char *to);        // Rename",
          "628:   bool (*remove)(const char *path);                        // Delete file",
          "630: };",
          "",
          "[Removed Lines]",
          "629:   bool (*mkdir)(const char *path);                         // Create directory",
          "",
          "[Added Lines]",
          "637:   bool (*mkd)(const char *path);                           // Create directory",
          "",
          "---------------"
        ],
        "src/config.h||src/config.h": [
          "File: src/config.h -> src/config.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #define MG_ENABLE_FATFS 0",
          "5: #endif",
          "7: #ifndef MG_ENABLE_SOCKET",
          "8: #define MG_ENABLE_SOCKET 1",
          "9: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #ifndef MG_FATFS_ROOT",
          "8: #define MG_FATFS_ROOT \"/\"",
          "9: #endif",
          "11: #ifndef MG_FATFS_BSIZE",
          "12: #define MG_FATFS_BSIZE 64",
          "13: #endif",
          "",
          "---------------"
        ],
        "src/fs.h||src/fs.h": [
          "File: src/fs.h -> src/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:   size_t (*seek)(void *fd, size_t offset);                 // Set file position",
          "19:   bool (*rename)(const char *from, const char *to);        // Rename",
          "20:   bool (*remove)(const char *path);                        // Delete file",
          "22: };",
          "",
          "[Removed Lines]",
          "21:   bool (*mkdir)(const char *path);                         // Create directory",
          "",
          "[Added Lines]",
          "21:   bool (*mkd)(const char *path);                           // Create directory",
          "",
          "---------------"
        ],
        "src/fs_fat.c||src/fs_fat.c": [
          "File: src/fs_fat.c -> src/fs_fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #if MG_ENABLE_FATFS",
          "4: #include <ff.h>",
          "10: static int ff_stat(const char *path, size_t *size, time_t *mtime) {",
          "11:   FILINFO fi;",
          "12:   if (path[0] == '\\0' || strcmp(path, MG_FATFS_ROOT) == 0) {",
          "",
          "[Removed Lines]",
          "6: #if !defined(MG_FATFS_ROOT)",
          "7: #define MG_FATFS_ROOT \"/\"",
          "8: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62: }",
          "64: static size_t ff_write(void *fp, const void *buf, size_t len) {",
          "68: }",
          "70: static size_t ff_seek(void *fp, size_t offset) {",
          "",
          "[Removed Lines]",
          "65:   unsigned n = 0;",
          "66:   f_write((FIL *) fp, buf, len, &n);",
          "67:   return n;",
          "",
          "[Added Lines]",
          "61:   unsigned n, sum = 0, bs = MG_FATFS_BSIZE;",
          "62:   while ((size_t) sum < len &&",
          "63:          f_write((FIL *) fp, (char *) buf + sum,",
          "64:                  sum + bs > len ? len - sum : bs, &n) == FR_OK &&",
          "65:          n > 0) {",
          "66:     sum += n;",
          "67:   }",
          "68:   return sum;",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "906:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "907:       return -2;",
          "908:     } else {",
          "910:       mg_fs_close(fd);",
          "912:       return (int) hm->body.len;",
          "913:     }",
          "914:   }",
          "",
          "[Removed Lines]",
          "909:       fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "911:       mg_http_reply(c, 200, \"\", \"\");",
          "",
          "[Added Lines]",
          "909:       int written = (int) fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "911:       mg_http_reply(c, 200, \"\", \"%d\", written);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5e466f9037b05df86f14a41d8f7928d3c595f64f",
      "candidate_info": {
        "commit_hash": "5e466f9037b05df86f14a41d8f7928d3c595f64f",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/5e466f9037b05df86f14a41d8f7928d3c595f64f",
        "files": [
          "mongoose.c",
          "src/http.c",
          "test/unit_test.c"
        ],
        "message": "Fix #1294 - add more common mime types",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "src/http.c||src/http.c",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "843:   } * t, types[] = {",
          "844:              MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "845:              MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "852:              MIME_ENTRY(\"gif\", \"image/gif\"),",
          "855:              MIME_ENTRY(\"png\", \"image/png\"),",
          "863:              MIME_ENTRY(\"ttf\", \"font/ttf\"),",
          "866:              MIME_ENTRY(\"doc\", \"application/msword\"),",
          "867:              MIME_ENTRY(\"exe\", \"application/octet-stream\"),",
          "872:              MIME_ENTRY(\"gz\", \"application/gzip\"),",
          "879:              MIME_ENTRY(\"mov\", \"video/quicktime\"),",
          "880:              MIME_ENTRY(\"mp4\", \"video/mp4\"),",
          "885:              MIME_ENTRY(\"wasm\", \"application/wasm\"),",
          "886:              {NULL, 0, NULL},",
          "887:          };",
          "",
          "[Removed Lines]",
          "846:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "847:              MIME_ENTRY(\"css\", \"text/css\"),",
          "848:              MIME_ENTRY(\"js\", \"text/javascript\"),",
          "849:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "850:              MIME_ENTRY(\"json\", \"application/json\"),",
          "851:              MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "853:              MIME_ENTRY(\"jpg\", \"image/jpeg\"),",
          "854:              MIME_ENTRY(\"jpeg\", \"image/jpeg\"),",
          "856:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "857:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "858:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "859:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "860:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "861:              MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "862:              MIME_ENTRY(\"xml\", \"application/xml\"),",
          "864:              MIME_ENTRY(\"json\", \"application/json\"),",
          "865:              MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "868:              MIME_ENTRY(\"zip\", \"application/zip\"),",
          "869:              MIME_ENTRY(\"xls\", \"application/excel\"),",
          "870:              MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "871:              MIME_ENTRY(\"tar\", \"application/tar\"),",
          "873:              MIME_ENTRY(\"rar\", \"application/rar\"),",
          "874:              MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "875:              MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "876:              MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "877:              MIME_ENTRY(\"webm\", \"video/webm\"),",
          "878:              MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "881:              MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "882:              MIME_ENTRY(\"csv\", \"text/csv\"),",
          "883:              MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "884:              MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "",
          "[Added Lines]",
          "846:              MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),",
          "847:              MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),",
          "850:              MIME_ENTRY(\"woff\", \"font/woff\"),",
          "852:              MIME_ENTRY(\"aac\", \"audio/aac\"),",
          "853:              MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "854:              MIME_ENTRY(\"azw\", \"application/vnd.amazon.ebook\"),",
          "855:              MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "856:              MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "857:              MIME_ENTRY(\"bz\", \"application/x-bzip\"),",
          "858:              MIME_ENTRY(\"bz2\", \"application/x-bzip2\"),",
          "859:              MIME_ENTRY(\"csv\", \"text/csv\"),",
          "861:              MIME_ENTRY(\"epub\", \"application/epub+zip\"),",
          "864:              MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "865:              MIME_ENTRY(\"json\", \"application/json\"),",
          "866:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "867:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "869:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "871:              MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "872:              MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "873:              MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "874:              MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "875:              MIME_ENTRY(\"rar\", \"application/rar\"),",
          "876:              MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "877:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "878:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "879:              MIME_ENTRY(\"tar\", \"application/tar\"),",
          "880:              MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "881:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "883:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "884:              MIME_ENTRY(\"weba\", \"audio/webm\"),",
          "885:              MIME_ENTRY(\"webm\", \"video/webm\"),",
          "886:              MIME_ENTRY(\"webp\", \"image/webp\"),",
          "887:              MIME_ENTRY(\"xls\", \"application/excel\"),",
          "888:              MIME_ENTRY(\"xml\", \"application/xml\"),",
          "889:              MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "890:              MIME_ENTRY(\"zip\", \"application/zip\"),",
          "891:              MIME_ENTRY(\"3gp\", \"video/3gpp\"),",
          "892:              MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "432:   } * t, types[] = {",
          "433:              MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "434:              MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "441:              MIME_ENTRY(\"gif\", \"image/gif\"),",
          "444:              MIME_ENTRY(\"png\", \"image/png\"),",
          "452:              MIME_ENTRY(\"ttf\", \"font/ttf\"),",
          "455:              MIME_ENTRY(\"doc\", \"application/msword\"),",
          "456:              MIME_ENTRY(\"exe\", \"application/octet-stream\"),",
          "461:              MIME_ENTRY(\"gz\", \"application/gzip\"),",
          "468:              MIME_ENTRY(\"mov\", \"video/quicktime\"),",
          "469:              MIME_ENTRY(\"mp4\", \"video/mp4\"),",
          "474:              MIME_ENTRY(\"wasm\", \"application/wasm\"),",
          "475:              {NULL, 0, NULL},",
          "476:          };",
          "",
          "[Removed Lines]",
          "435:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "436:              MIME_ENTRY(\"css\", \"text/css\"),",
          "437:              MIME_ENTRY(\"js\", \"text/javascript\"),",
          "438:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "439:              MIME_ENTRY(\"json\", \"application/json\"),",
          "440:              MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "442:              MIME_ENTRY(\"jpg\", \"image/jpeg\"),",
          "443:              MIME_ENTRY(\"jpeg\", \"image/jpeg\"),",
          "445:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "446:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "447:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "448:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "449:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "450:              MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "451:              MIME_ENTRY(\"xml\", \"application/xml\"),",
          "453:              MIME_ENTRY(\"json\", \"application/json\"),",
          "454:              MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "457:              MIME_ENTRY(\"zip\", \"application/zip\"),",
          "458:              MIME_ENTRY(\"xls\", \"application/excel\"),",
          "459:              MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "460:              MIME_ENTRY(\"tar\", \"application/tar\"),",
          "462:              MIME_ENTRY(\"rar\", \"application/rar\"),",
          "463:              MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "464:              MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "465:              MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "466:              MIME_ENTRY(\"webm\", \"video/webm\"),",
          "467:              MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "470:              MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "471:              MIME_ENTRY(\"csv\", \"text/csv\"),",
          "472:              MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "473:              MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "",
          "[Added Lines]",
          "435:              MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),",
          "436:              MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),",
          "439:              MIME_ENTRY(\"woff\", \"font/woff\"),",
          "441:              MIME_ENTRY(\"aac\", \"audio/aac\"),",
          "442:              MIME_ENTRY(\"avi\", \"video/x-msvideo\"),",
          "443:              MIME_ENTRY(\"azw\", \"application/vnd.amazon.ebook\"),",
          "444:              MIME_ENTRY(\"bin\", \"application/octet-stream\"),",
          "445:              MIME_ENTRY(\"bmp\", \"image/bmp\"),",
          "446:              MIME_ENTRY(\"bz\", \"application/x-bzip\"),",
          "447:              MIME_ENTRY(\"bz2\", \"application/x-bzip2\"),",
          "448:              MIME_ENTRY(\"csv\", \"text/csv\"),",
          "450:              MIME_ENTRY(\"epub\", \"application/epub+zip\"),",
          "453:              MIME_ENTRY(\"ico\", \"image/x-icon\"),",
          "454:              MIME_ENTRY(\"json\", \"application/json\"),",
          "455:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "456:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "458:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "460:              MIME_ENTRY(\"mpeg\", \"video/mpeg\"),",
          "461:              MIME_ENTRY(\"mpg\", \"video/mpeg\"),",
          "462:              MIME_ENTRY(\"ogg\", \"application/ogg\"),",
          "463:              MIME_ENTRY(\"pdf\", \"application/pdf\"),",
          "464:              MIME_ENTRY(\"rar\", \"application/rar\"),",
          "465:              MIME_ENTRY(\"rtf\", \"application/rtf\"),",
          "466:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "467:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "468:              MIME_ENTRY(\"tar\", \"application/tar\"),",
          "469:              MIME_ENTRY(\"tgz\", \"application/tar-gz\"),",
          "470:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "472:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "473:              MIME_ENTRY(\"weba\", \"audio/webm\"),",
          "474:              MIME_ENTRY(\"webm\", \"video/webm\"),",
          "475:              MIME_ENTRY(\"webp\", \"image/webp\"),",
          "476:              MIME_ENTRY(\"xls\", \"application/excel\"),",
          "477:              MIME_ENTRY(\"xml\", \"application/xml\"),",
          "478:              MIME_ENTRY(\"xsl\", \"application/xml\"),",
          "479:              MIME_ENTRY(\"zip\", \"application/zip\"),",
          "480:              MIME_ENTRY(\"3gp\", \"video/3gpp\"),",
          "481:              MIME_ENTRY(\"7z\", \"application/x-7z-compressed\"),",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "530:     mg_http_parse(buf, strlen(buf), &hm);",
          "531:     ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);",
          "532:     ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),",
          "534:   }",
          "536:   {",
          "",
          "[Removed Lines]",
          "533:                      mg_str(\"text/javascript\")) == 0);",
          "",
          "[Added Lines]",
          "533:                      mg_str(\"text/javascript; charset=utf-8\")) == 0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
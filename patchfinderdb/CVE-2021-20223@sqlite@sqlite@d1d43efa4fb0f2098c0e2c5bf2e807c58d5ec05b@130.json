{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c6b2f9e323e2eb4c1141fa6ba004a235f7a13a20",
      "candidate_info": {
        "commit_hash": "c6b2f9e323e2eb4c1141fa6ba004a235f7a13a20",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c6b2f9e323e2eb4c1141fa6ba004a235f7a13a20",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/sqlite.h.in"
        ],
        "message": "More documentation updates.  No code changes.\n\nFossilOrigin-Name: a684d4ef08a48962c632b598242f5e34c9b2fa3ad6339023fbce8ac91582b5e3",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/sqlite.h.in||src/sqlite.h.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: cc0e0aa3a7d534b806cdf63200b32ab3b7f0e08dde717f043a36d2f91c8a046c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/sqlite.h.in||src/sqlite.h.in": [
          "File: src/sqlite.h.in -> src/sqlite.h.in"
        ]
      }
    },
    {
      "candidate_hash": "f575c1cf065dd547caecb600051313087fb65fd8",
      "candidate_info": {
        "commit_hash": "f575c1cf065dd547caecb600051313087fb65fd8",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f575c1cf065dd547caecb600051313087fb65fd8",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "src/whereInt.h",
          "test/analyzeG.test"
        ],
        "message": "If STAT4 determines that a WHERE clause term that is not used by an index has very high probability of being true, then do not use that term to reduce the estimated output row count.\n\nFossilOrigin-Name: 40739c793b0e98a3bae296d3a1f74944edcdd4cc33c26b417fde4eaf6f14d062",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "src/whereInt.h||src/whereInt.h",
          "test/analyzeG.test||test/analyzeG.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c431b3fd8fd0f6a6974bba3e9366b0430ec003d570e7ce70ceefbcff5fe4b6fa",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2300:         pLoop->nOut--;",
          "2302:           Expr *pRight = pTerm->pExpr->pRight;",
          "2303:           int k = 0;",
          "2304:           testcase( pTerm->pExpr->op==TK_IS );",
          "",
          "[Removed Lines]",
          "2301:         if( pTerm->eOperator&(WO_EQ|WO_IS) ){",
          "",
          "[Added Lines]",
          "2301:         if( (pTerm->eOperator&(WO_EQ|WO_IS))!=0",
          "2303:         ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2307:           }else{",
          "2308:             k = 20;",
          "2309:           }",
          "2311:         }",
          "2312:       }",
          "2313:     }",
          "",
          "[Removed Lines]",
          "2310:           if( iReduce<k ) iReduce = k;",
          "",
          "[Added Lines]",
          "2312:           if( iReduce<k ){",
          "2313:             pTerm->wtFlags |= TERM_HEURTRUTH;",
          "2314:             iReduce = k;",
          "2315:           }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2489:     }",
          "2491:     if( IsUniqueIndex(pProbe) && saved_nEq==pProbe->nKeyCol-1 ){",
          "2493:     }else{",
          "2495:     }",
          "2496:     pNew->wsFlags = saved_wsFlags;",
          "2497:     pNew->u.btree.nEq = saved_nEq;",
          "",
          "[Removed Lines]",
          "2492:       pBuilder->bldFlags |= SQLITE_BLDF_UNIQUE;",
          "2494:       pBuilder->bldFlags |= SQLITE_BLDF_INDEXED;",
          "",
          "[Added Lines]",
          "2497:       pBuilder->bldFlags1 |= SQLITE_BLDF1_UNIQUE;",
          "2499:       pBuilder->bldFlags1 |= SQLITE_BLDF1_INDEXED;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2657:           if( nOut ){",
          "2658:             pNew->nOut = sqlite3LogEst(nOut);",
          "2659:             if( pNew->nOut>saved_nOut ) pNew->nOut = saved_nOut;",
          "2660:             pNew->nOut -= nIn;",
          "2661:           }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2664:             if( nEq==1",
          "2668:              && pNew->nOut+10 > pProbe->aiRowLogEst[0]",
          "2669:             ){",
          "2671:               if( sqlite3WhereTrace & 0x01 ){",
          "2672:                 sqlite3DebugPrintf(",
          "2673:                    \"STAT4 determines term has low selectivity:\\n\");",
          "2674:                 sqlite3WhereTermPrint(pTerm, 999);",
          "2675:               }",
          "2676: #endif",
          "2677:               pTerm->wtFlags |= TERM_HIGHTRUTH;",
          "2678:               if( pTerm->wtFlags & TERM_HEURTRUTH ){",
          "2682:                 pBuilder->bldFlags2 |= SQLITE_BLDF2_2NDPASS;",
          "2683:               }",
          "2684:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3080:       }",
          "3081:     }",
          "3084:     rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0);",
          "",
          "[Removed Lines]",
          "3083:     pBuilder->bldFlags = 0;",
          "3085:     if( pBuilder->bldFlags==SQLITE_BLDF_INDEXED ){",
          "",
          "[Added Lines]",
          "3109:     pBuilder->bldFlags1 = 0;",
          "3111:     if( pBuilder->bldFlags1==SQLITE_BLDF1_INDEXED ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4537:   return w.eCode;",
          "4538: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4567: #ifdef WHERETRACE_ENABLED",
          "4571: static void showAllWhereLoops(WhereInfo *pWInfo, WhereClause *pWC){",
          "4573:     WhereLoop *p;",
          "4574:     int i;",
          "4575:     static const char zLabel[] = \"0123456789abcdefghijklmnopqrstuvwyxz\"",
          "4576:                                            \"ABCDEFGHIJKLMNOPQRSTUVWYXZ\";",
          "4577:     for(p=pWInfo->pLoops, i=0; p; p=p->pNextLoop, i++){",
          "4578:       p->cId = zLabel[i%(sizeof(zLabel)-1)];",
          "4579:       sqlite3WhereLoopPrint(p, pWC);",
          "4580:     }",
          "4581:   }",
          "4582: }",
          "4583: # define WHERETRACE_ALL_LOOPS(W,C) showAllWhereLoops(W,C)",
          "4584: #else",
          "4585: # define WHERETRACE_ALL_LOOPS(W,C)",
          "4586: #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4838:   if( nTabList!=1 || whereShortCut(&sWLB)==0 ){",
          "4839:     rc = whereLoopAddAll(&sWLB);",
          "4840:     if( rc ) goto whereBeginError;",
          "4851:       }",
          "4852:     }",
          "4853: #endif",
          "4855:     wherePathSolver(pWInfo, 0);",
          "4856:     if( db->mallocFailed ) goto whereBeginError;",
          "",
          "[Removed Lines]",
          "4842: #ifdef WHERETRACE_ENABLED",
          "4844:       WhereLoop *p;",
          "4845:       int i;",
          "4846:       static const char zLabel[] = \"0123456789abcdefghijklmnopqrstuvwyxz\"",
          "4847:                                              \"ABCDEFGHIJKLMNOPQRSTUVWYXZ\";",
          "4848:       for(p=pWInfo->pLoops, i=0; p; p=p->pNextLoop, i++){",
          "4849:         p->cId = zLabel[i%(sizeof(zLabel)-1)];",
          "4850:         sqlite3WhereLoopPrint(p, sWLB.pWC);",
          "",
          "[Added Lines]",
          "4890: #ifdef SQLITE_ENABLE_STAT4",
          "4896:     if( sWLB.bldFlags2 & SQLITE_BLDF2_2NDPASS ){",
          "4897:       WHERETRACE_ALL_LOOPS(pWInfo, sWLB.pWC);",
          "4898:       WHERETRACE(0xffff,",
          "4899:            (\"**** Redo all loop computations due to\"",
          "4900:             \" TERM_HIGHTRUTH changes ****\\n\"));",
          "4901:       while( pWInfo->pLoops ){",
          "4902:         WhereLoop *p = pWInfo->pLoops;",
          "4903:         pWInfo->pLoops = p->pNextLoop;",
          "4904:         whereLoopDelete(db, p);",
          "4906:       rc = whereLoopAddAll(&sWLB);",
          "4907:       if( rc ) goto whereBeginError;",
          "4910:     WHERETRACE_ALL_LOOPS(pWInfo, sWLB.pWC);",
          "",
          "---------------"
        ],
        "src/whereInt.h||src/whereInt.h": [
          "File: src/whereInt.h -> src/whereInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "295: #ifdef SQLITE_ENABLE_STAT4",
          "297: #else",
          "299: #endif",
          "",
          "---------------"
        ],
        "test/analyzeG.test||test/analyzeG.test": [
          "File: test/analyzeG.test -> test/analyzeG.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020-02-23",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # Tests for functionality related to ANALYZE.",
          "12: #",
          "14: set testdir [file dirname $argv0]",
          "15: source $testdir/tester.tcl",
          "17: ifcapable !stat4 {",
          "18:   finish_test",
          "19:   return",
          "20: }",
          "21: set testprefix analyzeG",
          "23: proc do_scan_order_test {tn sql expect} {",
          "24:   uplevel [list do_test $tn [subst -nocommands {",
          "25:     set res \"\"",
          "26:     db eval \"explain query plan $sql\" {",
          "27:       lappend res [set detail]",
          "28:     }",
          "29:     set res",
          "30:   }] [list {*}$expect]]",
          "31: }",
          "33: #-------------------------------------------------------------------------",
          "34: # Test cases 1.* seek to verify that even if an index is not used, its",
          "35: # stat4 data may be used by the planner to estimate the number of",
          "36: # rows that match an unindexed constraint on the same column.",
          "37: #",
          "38: do_execsql_test 1.0 {",
          "39:   PRAGMA automatic_index = 0;",
          "40:   CREATE TABLE t1(a, x);",
          "41:   CREATE TABLE t2(b, y);",
          "42:   WITH s(i) AS (",
          "43:     SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<100",
          "44:   )",
          "45:   INSERT INTO t1 SELECT (i%50), NULL FROM s;",
          "46:   WITH s(i) AS (",
          "47:     SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<100",
          "48:   )",
          "49:   INSERT INTO t2 SELECT (CASE WHEN i<95 THEN 44 ELSE i END), NULL FROM s;",
          "50: }",
          "52: # Join tables t1 and t2. Both contain 100 rows. (a=44) matches 2 rows",
          "53: # in \"t1\", (b=44) matches 95 rows in table \"t2\". But the planner doesn't",
          "54: # know this, so it has no preference as to which order the tables are",
          "55: # scanned in. In practice this means that tables are scanned in the order",
          "56: # they are specified in in the FROM clause.",
          "57: do_scan_order_test 1.1.1 {",
          "58:   SELECT * FROM t1, t2 WHERE a=44 AND b=44;",
          "59: } {",
          "60:   {SCAN TABLE t1} {SCAN TABLE t2}",
          "61: }",
          "62: do_scan_order_test 1.1.2 {",
          "63:   SELECT * FROM t2, t1 WHERE a=44 AND b=44",
          "64: } {",
          "65:   {SCAN TABLE t2} {SCAN TABLE t1}",
          "66: }",
          "68: do_execsql_test 1.2 {",
          "69:   CREATE INDEX t2b ON t2(b);",
          "70:   ANALYZE;",
          "71: }",
          "73: # Now, with the ANALYZE data, the planner knows that (b=44) matches a",
          "74: # large number of rows. So it elects to scan table \"t1\" first, regardless",
          "75: # of the order in which the tables are specified in the FROM clause.",
          "76: do_scan_order_test 1.3.1 {",
          "77:   SELECT * FROM t1, t2 WHERE a=44 AND b=44;",
          "78: } {",
          "79:   {SCAN TABLE t1} {SCAN TABLE t2}",
          "80: }",
          "81: do_scan_order_test 1.3.2 {",
          "82:   SELECT * FROM t2, t1 WHERE a=44 AND b=44",
          "83: } {",
          "84:   {SCAN TABLE t1} {SCAN TABLE t2}",
          "85: }",
          "88: finish_test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0ba3621592a060a4dbabcac02c48bf3d9d603c42",
      "candidate_info": {
        "commit_hash": "0ba3621592a060a4dbabcac02c48bf3d9d603c42",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/0ba3621592a060a4dbabcac02c48bf3d9d603c42",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/os_unix.c"
        ],
        "message": "Omit O_NOFOLLOW from the open() call when opening /dev/null, since /dev/null is a symlink on Solaris, we are told.\n\nFossilOrigin-Name: 0c683c43a62fe25c6cb765e4a31556ec91a7c21af79349b3d7eeb13f73dd1cdc",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/os_unix.c||src/os_unix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: abfb043ebb0c55fdc2be58255bc852b13865d81fa4c2e0dbe8c375810557aafe",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/os_unix.c||src/os_unix.c": [
          "File: src/os_unix.c -> src/os_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "689:     sqlite3_log(SQLITE_WARNING,",
          "690:                 \"attempt to open \\\"%s\\\" as file descriptor %d\", z, fd);",
          "691:     fd = -1;",
          "693:   }",
          "694:   if( fd>=0 ){",
          "695:     if( m!=0 ){",
          "",
          "[Removed Lines]",
          "692:     if( osOpen(\"/dev/null\", f, m)<0 ) break;",
          "",
          "[Added Lines]",
          "692:     if( osOpen(\"/dev/null\", O_RDONLY, m)<0 ) break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "91d028f0a1528af6567c2651fba706fdd9ccb12c",
      "candidate_info": {
        "commit_hash": "91d028f0a1528af6567c2651fba706fdd9ccb12c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/91d028f0a1528af6567c2651fba706fdd9ccb12c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/analyze.c",
          "src/btree.c",
          "src/btree.h",
          "src/btreeInt.h",
          "src/build.c",
          "src/insert.c",
          "src/main.c",
          "src/pager.c",
          "src/pager.h",
          "src/pragma.c",
          "src/prepare.c",
          "src/select.c",
          "src/sqliteInt.h",
          "src/test1.c",
          "src/util.c",
          "src/vdbe.c",
          "src/vdbe.h",
          "src/vdbeInt.h",
          "src/vdbeaux.c",
          "src/wal.c",
          "src/wherecode.c",
          "test/corrupt3.test",
          "test/corruptL.test",
          "test/dbfuzz001.test",
          "test/fts3corrupt4.test",
          "test/pager1.test",
          "test/tester.tcl",
          "tool/enlargedb.c",
          "tool/showdb.c"
        ],
        "message": "Allow for page numbers as large as 4294967294 (0xfffffffe) which means database files as large as 281 TB.\n\nFossilOrigin-Name: 166e82dd20efbfd355ef3fb8b500bfebd8b946f1b13619b46722de96b57ed039",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/analyze.c||src/analyze.c",
          "src/btree.c||src/btree.c",
          "src/btree.h||src/btree.h",
          "src/btreeInt.h||src/btreeInt.h",
          "src/build.c||src/build.c",
          "src/insert.c||src/insert.c",
          "src/main.c||src/main.c",
          "src/pager.c||src/pager.c",
          "src/pager.h||src/pager.h",
          "src/pragma.c||src/pragma.c",
          "src/prepare.c||src/prepare.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/test1.c||src/test1.c",
          "src/util.c||src/util.c",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbe.h||src/vdbe.h",
          "src/vdbeInt.h||src/vdbeInt.h",
          "src/vdbeaux.c||src/vdbeaux.c",
          "src/wal.c||src/wal.c",
          "src/wherecode.c||src/wherecode.c",
          "test/corrupt3.test||test/corrupt3.test",
          "test/corruptL.test||test/corruptL.test",
          "test/dbfuzz001.test||test/dbfuzz001.test",
          "test/fts3corrupt4.test||test/fts3corrupt4.test",
          "test/pager1.test||test/pager1.test",
          "test/tester.tcl||test/tester.tcl",
          "tool/enlargedb.c||tool/enlargedb.c",
          "tool/showdb.c||tool/showdb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ee8a108058c304f9b6b02f84f1da01a0b7a3a21992627bcc1f97d42e8d23da69",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/analyze.c||src/analyze.c": [
          "File: src/analyze.c -> src/analyze.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "186:   sqlite3 *db = pParse->db;",
          "187:   Db *pDb;",
          "188:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "190:   u8 aCreateTbl[ArraySize(aTable)];",
          "191: #ifdef SQLITE_ENABLE_STAT4",
          "192:   const int nToOpen = OptimizationEnabled(db,SQLITE_Stat4) ? 2 : 1;",
          "",
          "[Removed Lines]",
          "189:   int aRoot[ArraySize(aTable)];",
          "",
          "[Added Lines]",
          "189:   u32 aRoot[ArraySize(aTable)];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "215:         sqlite3NestedParse(pParse,",
          "216:             \"CREATE TABLE %Q.%s(%s)\", pDb->zDbSName, zTab, aTable[i].zCols",
          "217:         );",
          "219:         aCreateTbl[i] = OPFLAG_P2ISREG;",
          "220:       }",
          "221:     }else{",
          "",
          "[Removed Lines]",
          "218:         aRoot[i] = pParse->regRoot;",
          "",
          "[Added Lines]",
          "218:         aRoot[i] = (u32)pParse->regRoot;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "235: #endif",
          "236:       }else{",
          "239:       }",
          "240:     }",
          "241:   }",
          "",
          "[Removed Lines]",
          "238:         sqlite3VdbeAddOp2(v, OP_Clear, aRoot[i], iDb);",
          "",
          "[Added Lines]",
          "238:         sqlite3VdbeAddOp2(v, OP_Clear, (int)aRoot[i], iDb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "244:   for(i=0; i<nToOpen; i++){",
          "245:     assert( i<ArraySize(aTable) );",
          "247:     sqlite3VdbeChangeP5(v, aCreateTbl[i]);",
          "248:     VdbeComment((v, aTable[i].zName));",
          "249:   }",
          "",
          "[Removed Lines]",
          "246:     sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, aRoot[i], iDb, 3);",
          "",
          "[Added Lines]",
          "246:     sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, (int)aRoot[i], iDb, 3);",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2141: static Pgno btreePagecount(BtShared *pBt){",
          "2143:   return pBt->nPage;",
          "2144: }",
          "2146:   assert( sqlite3BtreeHoldsMutex(p) );",
          "2148: }",
          "",
          "[Removed Lines]",
          "2142:   assert( (pBt->nPage & 0x80000000)==0 || CORRUPT_DB );",
          "2145: u32 sqlite3BtreeLastPage(Btree *p){",
          "2147:   return btreePagecount(p->pBt) & 0x7fffffff;",
          "",
          "[Added Lines]",
          "2144: Pgno sqlite3BtreeLastPage(Btree *p){",
          "2146:   return btreePagecount(p->pBt);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2937:   sqlite3BtreeEnter(p);",
          "2938:   n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage);",
          "2939:   sqlite3BtreeLeave(p);",
          "",
          "[Removed Lines]",
          "2935: int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){",
          "2936:   int n;",
          "",
          "[Added Lines]",
          "2934: Pgno sqlite3BtreeMaxPageCount(Btree *p, Pgno mxPage){",
          "2935:   Pgno n;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4419:   pCur->iPage = -1;",
          "4420:   pCur->pKeyInfo = pKeyInfo;",
          "4421:   pCur->pBtree = p;",
          "",
          "[Removed Lines]",
          "4418:   pCur->pgnoRoot = (Pgno)iTable;",
          "",
          "[Added Lines]",
          "4417:   pCur->pgnoRoot = iTable;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4427:   for(pX=pBt->pCursor; pX; pX=pX->pNext){",
          "4429:       pX->curFlags |= BTCF_Multiple;",
          "4430:       pCur->curFlags |= BTCF_Multiple;",
          "4431:     }",
          "",
          "[Removed Lines]",
          "4428:     if( pX->pgnoRoot==(Pgno)iTable ){",
          "",
          "[Added Lines]",
          "4427:     if( pX->pgnoRoot==iTable ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4875:     assert( rc==SQLITE_OK && amt>0 );",
          "4876:     while( nextPage ){",
          "4878:       assert( pCur->aOverflow[iIdx]==0",
          "4879:               || pCur->aOverflow[iIdx]==nextPage",
          "4880:               || CORRUPT_DB );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4877:       if( nextPage > pBt->nPage ) return SQLITE_CORRUPT_BKPT;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5948: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "5949:     if( eMode==BTALLOC_EXACT ){",
          "5951:         u8 eType;",
          "5952:         assert( nearby>0 );",
          "5953:         assert( pBt->autoVacuum );",
          "",
          "[Removed Lines]",
          "5950:       if( nearby<=mxPage ){",
          "",
          "[Added Lines]",
          "5950:       if( ALWAYS(nearby<=mxPage) ){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6243:   assert( CORRUPT_DB || iPage>1 );",
          "6244:   assert( !pMemPage || pMemPage->pgno==iPage );",
          "6247:     return SQLITE_CORRUPT_BKPT;",
          "6248:   }",
          "6249:   if( pMemPage ){",
          "",
          "[Removed Lines]",
          "6246:   if( iPage<2 || iPage>pBt->nPage ){",
          "",
          "[Added Lines]",
          "6246:   if( iPage<2 || NEVER(iPage>pBt->nPage) ){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6292:     iTrunk = get4byte(&pPage1->aData[32]);",
          "6293:     rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);",
          "6294:     if( rc!=SQLITE_OK ){",
          "6295:       goto freepage_out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6293:     if( iTrunk>btreePagecount(pBt) ){",
          "6294:       rc = SQLITE_CORRUPT_BKPT;",
          "6295:       goto freepage_out;",
          "6296:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "9098:   BtShared *pBt = p->pBt;",
          "9099:   MemPage *pRoot;",
          "9100:   Pgno pgnoRoot;",
          "",
          "[Removed Lines]",
          "9097: static int btreeCreateTable(Btree *p, int *piTable, int createTabFlags){",
          "",
          "[Added Lines]",
          "9101: static int btreeCreateTable(Btree *p, Pgno *piTable, int createTabFlags){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "9129:     sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &pgnoRoot);",
          "9130:     pgnoRoot++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9134:     if( pgnoRoot>btreePagecount(pBt) ){",
          "9135:       return SQLITE_CORRUPT_BKPT;",
          "9136:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "9136:         pgnoRoot==PENDING_BYTE_PAGE(pBt) ){",
          "9137:       pgnoRoot++;",
          "9138:     }",
          "",
          "[Removed Lines]",
          "9139:     assert( pgnoRoot>=3 || CORRUPT_DB );",
          "9140:     testcase( pgnoRoot<3 );",
          "",
          "[Added Lines]",
          "9146:     assert( pgnoRoot>=3 );",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "9234:   zeroPage(pRoot, ptfFlags);",
          "9235:   sqlite3PagerUnref(pRoot->pDbPage);",
          "9236:   assert( (pBt->openFlags & BTREE_SINGLE)==0 || pgnoRoot==2 );",
          "9238:   return SQLITE_OK;",
          "9239: }",
          "9241:   int rc;",
          "9242:   sqlite3BtreeEnter(p);",
          "9243:   rc = btreeCreateTable(p, piTable, flags);",
          "",
          "[Removed Lines]",
          "9240: int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){",
          "",
          "[Added Lines]",
          "9246: int sqlite3BtreeCreateTable(Btree *p, Pgno *piTable, int flags){",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "9889:   usableSize = pBt->usableSize;",
          "9890:   if( iPage==0 ) return 0;",
          "9891:   if( checkRef(pCheck, iPage) ) return 0;",
          "9893:   pCheck->v1 = iPage;",
          "9895:     checkAppendMsg(pCheck,",
          "9896:        \"unable to get the page. error code=%d\", rc);",
          "9897:     goto end_of_check;",
          "",
          "[Removed Lines]",
          "9892:   pCheck->zPfx = \"Page %d: \";",
          "9894:   if( (rc = btreeGetPage(pBt, (Pgno)iPage, &pPage, 0))!=0 ){",
          "",
          "[Added Lines]",
          "9898:   pCheck->zPfx = \"Page %u: \";",
          "9900:   if( (rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0 ){",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "9916:   hdr = pPage->hdrOffset;",
          "9920:   contentOffset = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Removed Lines]",
          "9919:   pCheck->zPfx = \"On tree page %d cell %d: \";",
          "",
          "[Added Lines]",
          "9925:   pCheck->zPfx = \"On tree page %u cell %d: \";",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "9936:     pgno = get4byte(&data[hdr+8]);",
          "9937: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "9938:     if( pBt->autoVacuum ){",
          "9940:       checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);",
          "9941:     }",
          "9942: #endif",
          "",
          "[Removed Lines]",
          "9939:       pCheck->zPfx = \"On page %d at right child: \";",
          "",
          "[Added Lines]",
          "9945:       pCheck->zPfx = \"On page %u at right child: \";",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "10077:     while( btreeHeapPull(heap,&x) ){",
          "10078:       if( (prev&0xffff)>=(x>>16) ){",
          "10079:         checkAppendMsg(pCheck,",
          "10081:         break;",
          "10082:       }else{",
          "10083:         nFrag += (x>>16) - (prev&0xffff) - 1;",
          "",
          "[Removed Lines]",
          "10080:           \"Multiple uses for byte %u of page %d\", x>>16, iPage);",
          "",
          "[Added Lines]",
          "10086:           \"Multiple uses for byte %u of page %u\", x>>16, iPage);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "10093:     if( heap[0]==0 && nFrag!=data[hdr+7] ){",
          "10094:       checkAppendMsg(pCheck,",
          "10096:           nFrag, data[hdr+7], iPage);",
          "10097:     }",
          "10098:   }",
          "",
          "[Removed Lines]",
          "10095:           \"Fragmentation of %d bytes reported as %d on page %d\",",
          "",
          "[Added Lines]",
          "10101:           \"Fragmentation of %d bytes reported as %d on page %u\",",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "10143:   BtShared *pBt = p->pBt;",
          "10144:   u64 savedDbFlags = pBt->db->flags;",
          "10145:   char zErr[100];",
          "10149:   assert( nRoot>0 );",
          "",
          "[Removed Lines]",
          "10146:   VVA_ONLY( int nRef );",
          "",
          "[Added Lines]",
          "10154:   VVA_ONLY( int nRef );",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "10205: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "10206:   if( !bPartial ){",
          "10207:     if( pBt->autoVacuum ){",
          "10210:       for(i=0; (int)i<nRoot; i++) if( mx<aRoot[i] ) mx = aRoot[i];",
          "10211:       mxInHdr = get4byte(&pBt->pPage1->aData[52]);",
          "10212:       if( mx!=mxInHdr ){",
          "",
          "[Removed Lines]",
          "10208:       int mx = 0;",
          "10209:       int mxInHdr;",
          "",
          "[Added Lines]",
          "10214:       Pgno mx = 0;",
          "10215:       Pgno mxInHdr;",
          "",
          "---------------"
        ],
        "src/btree.h||src/btree.h": [
          "File: src/btree.h -> src/btree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "71: int sqlite3BtreeSetPagerFlags(Btree*,unsigned);",
          "72: int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);",
          "73: int sqlite3BtreeGetPageSize(Btree*);",
          "76: int sqlite3BtreeSecureDelete(Btree*,int);",
          "77: int sqlite3BtreeGetRequestedReserve(Btree*);",
          "78: int sqlite3BtreeGetReserveNoMutex(Btree *p);",
          "",
          "[Removed Lines]",
          "74: int sqlite3BtreeMaxPageCount(Btree*,int);",
          "75: u32 sqlite3BtreeLastPage(Btree*);",
          "",
          "[Added Lines]",
          "74: Pgno sqlite3BtreeMaxPageCount(Btree*,Pgno);",
          "75: Pgno sqlite3BtreeLastPage(Btree*);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84: int sqlite3BtreeCommit(Btree*);",
          "85: int sqlite3BtreeRollback(Btree*,int,int);",
          "86: int sqlite3BtreeBeginStmt(Btree*,int);",
          "88: int sqlite3BtreeIsInTrans(Btree*);",
          "89: int sqlite3BtreeIsInReadTrans(Btree*);",
          "90: int sqlite3BtreeIsInBackup(Btree*);",
          "",
          "[Removed Lines]",
          "87: int sqlite3BtreeCreateTable(Btree*, int*, int flags);",
          "",
          "[Added Lines]",
          "87: int sqlite3BtreeCreateTable(Btree*, Pgno*, int flags);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "316: u32 sqlite3BtreePayloadSize(BtCursor*);",
          "317: sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor*);",
          "320: struct Pager *sqlite3BtreePager(Btree*);",
          "321: i64 sqlite3BtreeRowCountEst(BtCursor*);",
          "",
          "[Removed Lines]",
          "319: char *sqlite3BtreeIntegrityCheck(sqlite3*,Btree*,int*aRoot,int nRoot,int,int*);",
          "",
          "[Added Lines]",
          "319: char *sqlite3BtreeIntegrityCheck(sqlite3*,Btree*,Pgno*aRoot,int nRoot,int,int*);",
          "",
          "---------------"
        ],
        "src/btreeInt.h||src/btreeInt.h": [
          "File: src/btreeInt.h -> src/btreeInt.h"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "889: ){",
          "890:   sqlite3 *db = pParse->db;",
          "893:     return SQLITE_OK;",
          "894:   }",
          "",
          "[Removed Lines]",
          "891:   if( sqlite3WritableSchema(db) || db->init.imposterTable ){",
          "",
          "[Added Lines]",
          "891:   if( sqlite3WritableSchema(db)",
          "892:    || db->init.imposterTable",
          "893:    || !sqlite3Config.bExtraSchemaChecks",
          "894:   ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "897:      || sqlite3_stricmp(zName, db->init.azInit[1])",
          "898:      || sqlite3_stricmp(zTblName, db->init.azInit[2])",
          "899:     ){",
          "904:     }",
          "905:   }else{",
          "906:     if( (pParse->nested==0 && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7))",
          "",
          "[Removed Lines]",
          "900:       if( sqlite3Config.bExtraSchemaChecks ){",
          "902:         return SQLITE_ERROR;",
          "903:       }",
          "",
          "[Added Lines]",
          "904:       return SQLITE_ERROR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2115:   if( v && pPk->tnum>0 ){",
          "2116:     assert( db->init.busy==0 );",
          "2118:   }",
          "",
          "[Removed Lines]",
          "2117:     sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);",
          "",
          "[Added Lines]",
          "2118:     sqlite3VdbeChangeOpcode(v, (int)pPk->tnum, OP_Goto);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2812: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "2814:   HashElem *pElem;",
          "2815:   Hash *pHash;",
          "2816:   Db *pDb;",
          "",
          "[Removed Lines]",
          "2813: void sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo){",
          "",
          "[Added Lines]",
          "2814: void sqlite3RootPageMoved(sqlite3 *db, int iDb, Pgno iFrom, Pgno iTo){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2843: static void destroyRootPage(Parse *pParse, int iTable, int iDb){",
          "2844:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2845:   int r1 = sqlite3GetTempReg(pParse);",
          "2847:   sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb);",
          "2848:   sqlite3MayAbort(pParse);",
          "2849: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "",
          "[Removed Lines]",
          "2846:   if( iTable<2 ) sqlite3ErrorMsg(pParse, \"corrupt schema\");",
          "",
          "[Added Lines]",
          "2847:   if( NEVER(iTable<2) ) return;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2893:   while( 1 ){",
          "2894:     Index *pIdx;",
          "2897:     if( iDestroyed==0 || iTab<iDestroyed ){",
          "2898:       iLargest = iTab;",
          "2899:     }",
          "2900:     for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){",
          "2902:       assert( pIdx->pSchema==pTab->pSchema );",
          "2903:       if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){",
          "2904:         iLargest = iIdx;",
          "",
          "[Removed Lines]",
          "2890:   int iTab = pTab->tnum;",
          "2891:   int iDestroyed = 0;",
          "2895:     int iLargest = 0;",
          "2901:       int iIdx = pIdx->tnum;",
          "",
          "[Added Lines]",
          "2891:   Pgno iTab = pTab->tnum;",
          "2892:   Pgno iDestroyed = 0;",
          "2896:     Pgno iLargest = 0;",
          "2902:       Pgno iIdx = pIdx->tnum;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3342:   v = sqlite3GetVdbe(pParse);",
          "3343:   if( v==0 ) return;",
          "3344:   if( memRootPage>=0 ){",
          "3346:   }else{",
          "3347:     tnum = pIndex->tnum;",
          "3348:   }",
          "",
          "[Removed Lines]",
          "3345:     tnum = memRootPage;",
          "",
          "[Added Lines]",
          "3346:     tnum = (Pgno)memRootPage;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3367:   sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1+1); VdbeCoverage(v);",
          "3368:   sqlite3VdbeJumpHere(v, addr1);",
          "3369:   if( memRootPage<0 ) sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb);",
          "3371:                     (char *)pKey, P4_KEYINFO);",
          "3372:   sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR|((memRootPage>=0)?OPFLAG_P2ISREG:0));",
          "",
          "[Removed Lines]",
          "3370:   sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb,",
          "",
          "[Added Lines]",
          "3371:   sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, (int)tnum, iDb,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3980:       sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, iMem, BTREE_BLOBKEY);",
          "",
          "[Removed Lines]",
          "3979:       pIndex->tnum = sqlite3VdbeAddOp0(v, OP_Noop);",
          "",
          "[Added Lines]",
          "3980:       pIndex->tnum = (Pgno)sqlite3VdbeAddOp0(v, OP_Noop);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4018:         sqlite3VdbeAddOp2(v, OP_Expire, 0, 1);",
          "4019:       }",
          "4022:     }",
          "4023:   }",
          "4024:   if( db->init.busy || pTblName==0 ){",
          "",
          "[Removed Lines]",
          "4021:       sqlite3VdbeJumpHere(v, pIndex->tnum);",
          "",
          "[Added Lines]",
          "4022:       sqlite3VdbeJumpHere(v, (int)pIndex->tnum);",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "180:     assert( pOp!=0 );",
          "181:     if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){",
          "182:       Index *pIndex;",
          "184:       if( tnum==pTab->tnum ){",
          "185:         return 1;",
          "186:       }",
          "",
          "[Removed Lines]",
          "183:       int tnum = pOp->p2;",
          "",
          "[Added Lines]",
          "183:       Pgno tnum = pOp->p2;",
          "",
          "---------------"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c"
        ],
        "src/pager.c||src/pager.c": [
          "File: src/pager.c -> src/pager.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "786: # define USEFETCH(x) 0",
          "787: #endif",
          "",
          "[Removed Lines]",
          "792: #define PAGER_MAX_PGNO 2147483647",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3767:   if( mxPage>0 ){",
          "3768:     pPager->mxPgno = mxPage;",
          "3769:   }",
          "",
          "[Removed Lines]",
          "3766: int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){",
          "",
          "[Added Lines]",
          "3761: Pgno sqlite3PagerMaxPageCount(Pager *pPager, Pgno mxPage){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5490:   if( pPg->pPager && !noContent ){",
          "5494:     pPager->aStat[PAGER_STAT_HIT]++;",
          "5495:     return SQLITE_OK;",
          "",
          "[Removed Lines]",
          "5493:     assert( pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) );",
          "",
          "[Added Lines]",
          "5488:     assert( pgno!=PAGER_MJ_PGNO(pPager) );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5505:       rc = SQLITE_CORRUPT_BKPT;",
          "5506:       goto pager_acquire_err;",
          "5507:     }",
          "",
          "[Removed Lines]",
          "5504:     if( pgno>PAGER_MAX_PGNO || pgno==PAGER_MJ_PGNO(pPager) ){",
          "",
          "[Added Lines]",
          "5499:     if( pgno==PAGER_MJ_PGNO(pPager) ){",
          "",
          "---------------"
        ],
        "src/pager.h||src/pager.h": [
          "File: src/pager.h -> src/pager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "129: void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);",
          "130: int sqlite3PagerSetPagesize(Pager*, u32*, int);",
          "132: void sqlite3PagerSetCachesize(Pager*, int);",
          "133: int sqlite3PagerSetSpillsize(Pager*, int);",
          "134: void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);",
          "",
          "[Removed Lines]",
          "131: int sqlite3PagerMaxPageCount(Pager*, int);",
          "",
          "[Added Lines]",
          "131: Pgno sqlite3PagerMaxPageCount(Pager*, Pgno);",
          "",
          "---------------"
        ],
        "src/pragma.c||src/pragma.c": [
          "File: src/pragma.c -> src/pragma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "612:   case PragTyp_PAGE_COUNT: {",
          "613:     int iReg;",
          "614:     sqlite3CodeVerifySchema(pParse, iDb);",
          "615:     iReg = ++pParse->nMem;",
          "616:     if( sqlite3Tolower(zLeft[0])=='p' ){",
          "617:       sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);",
          "618:     }else{",
          "621:     }",
          "622:     sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);",
          "623:     break;",
          "",
          "[Removed Lines]",
          "619:       sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg,",
          "620:                         sqlite3AbsInt32(sqlite3Atoi(zRight)));",
          "",
          "[Added Lines]",
          "614:     i64 x = 0;",
          "620:       if( zRight && sqlite3DecOrHexToI64(zRight,&x)==0 ){",
          "621:         if( x<0 ) x = 0;",
          "622:         else if( x>0xfffffffe ) x = 0xfffffffe;",
          "623:       }else{",
          "624:         x = 0;",
          "625:       }",
          "626:       sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg, (int)x);",
          "",
          "---------------"
        ],
        "src/prepare.c||src/prepare.c": [
          "File: src/prepare.c -> src/prepare.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:     assert( db->init.busy );",
          "117:     db->init.iDb = iDb;",
          "119:     db->init.orphanTrigger = 0;",
          "120:     db->init.azInit = argv;",
          "121:     pStmt = 0;",
          "",
          "[Removed Lines]",
          "118:     db->init.newTnum = sqlite3Atoi(argv[3]);",
          "",
          "[Added Lines]",
          "118:     if( sqlite3GetUInt32(argv[3], &db->init.newTnum)==0",
          "119:      || (db->init.newTnum>pData->mxPage && pData->mxPage>0)",
          "120:     ){",
          "121:       if( sqlite3Config.bExtraSchemaChecks ){",
          "122:         corruptSchema(pData, argv[1], \"invalid rootpage\");",
          "123:       }",
          "124:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "149:     Index *pIndex;",
          "150:     pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);",
          "153:      || pIndex->tnum<2",
          "154:      || sqlite3IndexHasDuplicateRootPage(pIndex)",
          "155:     ){",
          "157:     }",
          "158:   }",
          "159:   return 0;",
          "",
          "[Removed Lines]",
          "151:     if( pIndex==0",
          "152:      || sqlite3GetInt32(argv[3],&pIndex->tnum)==0",
          "156:       corruptSchema(pData, argv[1], pIndex?\"invalid rootpage\":\"orphan index\");",
          "",
          "[Added Lines]",
          "157:     if( pIndex==0 ){",
          "158:       corruptSchema(pData, argv[1], \"orphan index\");",
          "159:     }else",
          "160:     if( sqlite3GetUInt32(argv[3],&pIndex->tnum)==0",
          "162:      || pIndex->tnum>pData->mxPage",
          "165:       if( sqlite3Config.bExtraSchemaChecks ){",
          "166:         corruptSchema(pData, argv[1], \"invalid rootpage\");",
          "167:       }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:   initData.pzErrMsg = pzErrMsg;",
          "208:   initData.mInitFlags = mFlags;",
          "209:   initData.nInitRow = 0;",
          "210:   sqlite3InitCallback(&initData, 5, (char **)azArg, 0);",
          "211:   db->mDbFlags &= mask;",
          "212:   if( initData.rc ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221:   initData.mxPage = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "331:   assert( db->init.busy );",
          "332:   {",
          "333:     char *zSql;",
          "334:     zSql = sqlite3MPrintf(db,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "344:   initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3234:   if( aPermute ){",
          "3235:     struct ExprList_item *pItem;",
          "3236:     aPermute[0] = nOrderBy;",
          "",
          "[Removed Lines]",
          "3233:   aPermute = sqlite3DbMallocRawNN(db, sizeof(int)*(nOrderBy + 1));",
          "",
          "[Added Lines]",
          "3233:   aPermute = sqlite3DbMallocRawNN(db, sizeof(u32)*(nOrderBy + 1));",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1189: #include \"btree.h\"",
          "1190: #include \"vdbe.h\"",
          "1192: #include \"pcache.h\"",
          "1193: #include \"os.h\"",
          "1194: #include \"mutex.h\"",
          "",
          "[Removed Lines]",
          "1191: #include \"pager.h\"",
          "",
          "[Added Lines]",
          "1189: #include \"pager.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4465: void sqlite3Int64ToText(i64,char*);",
          "4466: int sqlite3AtoF(const char *z, double*, int, u8);",
          "4467: int sqlite3GetInt32(const char *, int*);",
          "4468: int sqlite3Atoi(const char*);",
          "4469: #ifndef SQLITE_OMIT_UTF16",
          "4470: int sqlite3Utf16ByteLen(const void *pData, int nChar);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4469: int sqlite3GetUInt32(const char*, u32*);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4592: #ifdef VDBE_PROFILE",
          "4593: extern sqlite3_uint64 sqlite3NProfileCnt;",
          "4594: #endif",
          "4596: void sqlite3Reindex(Parse*, Token*, Token*);",
          "4597: void sqlite3AlterFunctions(void);",
          "4598: void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);",
          "",
          "[Removed Lines]",
          "4595: void sqlite3RootPageMoved(sqlite3*, int, int, int);",
          "",
          "[Added Lines]",
          "4597: void sqlite3RootPageMoved(sqlite3*, int, Pgno, Pgno);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4706: #endif",
          "4708: #ifndef SQLITE_OMIT_SHARED_CACHE",
          "4710: #else",
          "4711:   #define sqlite3TableLock(v,w,x,y,z)",
          "4712: #endif",
          "",
          "[Removed Lines]",
          "4709:   void sqlite3TableLock(Parse *, int, int, u8, const char *);",
          "",
          "[Added Lines]",
          "4711:   void sqlite3TableLock(Parse *, int, Pgno, u8, const char *);",
          "",
          "---------------"
        ],
        "src/test1.c||src/test1.c": [
          "File: src/test1.c -> src/test1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6437:   return TCL_OK;",
          "6438: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6448: static int SQLITE_TCLAPI extra_schema_checks(",
          "6453: ){",
          "6454:   int i = 0;",
          "6455:   if( objc!=2 ){",
          "6456:     Tcl_WrongNumArgs(interp, 1, objv, \"BOOLEAN\");",
          "6457:     return TCL_ERROR;",
          "6458:   }",
          "6459:   if( Tcl_GetBooleanFromObj(interp,objv[1],&i) ) return TCL_ERROR;",
          "6460:   sqlite3_test_control(SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, i);",
          "6461:   return TCL_OK;",
          "6462: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8003:      { \"restore_prng_state\",            restore_prng_state, 0 },",
          "8004:      { \"reset_prng_state\",              reset_prng_state,   0 },",
          "8005:      { \"prng_seed\",                     prng_seed,          0 },",
          "8006:      { \"database_never_corrupt\",        database_never_corrupt, 0},",
          "8007:      { \"database_may_be_corrupt\",       database_may_be_corrupt, 0},",
          "8008:      { \"optimization_control\",          optimization_control,0},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8030:      { \"extra_schema_checks\",           extra_schema_checks,    0},",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "605:   u64 x;",
          "606:   char zTemp[22];",
          "607:   if( v<0 ){",
          "609:   }else{",
          "610:     x = v;",
          "611:   }",
          "",
          "[Removed Lines]",
          "608:     x = (v==SMALLEST_INT64) ? ((u64)1)<<63 : -v;",
          "",
          "[Added Lines]",
          "608:     x = (v==SMALLEST_INT64) ? ((u64)1)<<63 : (u64)-v;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "860: int sqlite3Atoi(const char *z){",
          "861:   int x = 0;",
          "863:   return x;",
          "864: }",
          "",
          "[Removed Lines]",
          "862:   if( z ) sqlite3GetInt32(z, &x);",
          "",
          "[Added Lines]",
          "862:   sqlite3GetInt32(z, &x);",
          "872: int sqlite3GetUInt32(const char *z, u32 *pI){",
          "873:   u64 v = 0;",
          "874:   int i;",
          "875:   for(i=0; sqlite3Isdigit(z[i]); i++){",
          "876:     v = v*10 + z[i] - '0';",
          "877:     if( v>4294967296LL ){ *pI = 0; return 0; }",
          "878:   }",
          "879:   if( i==0 || z[i]!=0 ){ *pI = 0; return 0; }",
          "881:   return 1;",
          "882: }",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2250:   int p1;",
          "2251:   int p2;",
          "2252:   const KeyInfo *pKeyInfo;",
          "2258:   if( (pOp->p5 & OPFLAG_PERMUTE)==0 ){",
          "2259:     aPermute = 0;",
          "",
          "[Removed Lines]",
          "2253:   int idx;",
          "",
          "[Added Lines]",
          "2253:   u32 idx;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2282:   }",
          "2284:   for(i=0; i<n; i++){",
          "2286:     assert( memIsValid(&aMem[p1+idx]) );",
          "2287:     assert( memIsValid(&aMem[p2+idx]) );",
          "2288:     REGISTER_TRACE(p1+idx, &aMem[p1+idx]);",
          "",
          "[Removed Lines]",
          "2285:     idx = aPermute ? aPermute[i] : i;",
          "",
          "[Added Lines]",
          "2285:     idx = aPermute ? aPermute[i] : (u32)i;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2611:   assert( pOp->p1>=0 && pOp->p1<p->nCursor );",
          "2612:   pC = p->apCsr[pOp->p1];",
          "2613:   assert( pC!=0 );",
          "",
          "[Removed Lines]",
          "2614:   p2 = pOp->p2;",
          "",
          "[Added Lines]",
          "2614:   p2 = (u32)pOp->p2;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2738:           offset64 += sqlite3VdbeSerialTypeLen(t);",
          "2739:         }",
          "2740:         aOffset[++i] = (u32)(offset64 & 0xffffffff);",
          "",
          "[Removed Lines]",
          "2741:       }while( i<=p2 && zHdr<zEndHdr );",
          "",
          "[Added Lines]",
          "2741:       }while( (u32)i<=p2 && zHdr<zEndHdr );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3762: case OP_ReopenIdx: {",
          "3763:   int nField;",
          "3764:   KeyInfo *pKeyInfo;",
          "3766:   int iDb;",
          "3767:   int wrFlag;",
          "3768:   Btree *pX;",
          "",
          "[Removed Lines]",
          "3765:   int p2;",
          "",
          "[Added Lines]",
          "3765:   u32 p2;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3794:   nField = 0;",
          "3795:   pKeyInfo = 0;",
          "3797:   iDb = pOp->p3;",
          "3798:   assert( iDb>=0 && iDb<db->nDb );",
          "3799:   assert( DbMaskTest(p->btreeMask, iDb) );",
          "",
          "[Removed Lines]",
          "3796:   p2 = pOp->p2;",
          "",
          "[Added Lines]",
          "3796:   p2 = (u32)pOp->p2;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3966:       if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){",
          "3967:         assert( pOp->p4type==P4_KEYINFO );",
          "3969:                                      BTREE_BLOBKEY | pOp->p5);",
          "3970:         if( rc==SQLITE_OK ){",
          "3971:           assert( pCx->pgnoRoot==SCHEMA_ROOT+1 );",
          "",
          "[Removed Lines]",
          "3968:         rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,",
          "",
          "[Added Lines]",
          "3968:         rc = sqlite3BtreeCreateTable(pCx->pBtx, &pCx->pgnoRoot,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5230:   assert( pC->deferredMoveto==0 );",
          "5231:   assert( sqlite3BtreeCursorIsValid(pCrsr) );",
          "5237:   n = sqlite3BtreePayloadSize(pCrsr);",
          "5238:   if( n>(u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){",
          "",
          "[Removed Lines]",
          "5233:   rc = sqlite3VdbeCursorMoveto(pC);",
          "5234:   if( rc!=SQLITE_OK ) goto abort_due_to_error;",
          "5235: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6002:   assert( p->readOnly==0 );",
          "6003:   assert( DbMaskTest(p->btreeMask, pOp->p2) );",
          "6004:   rc = sqlite3BtreeClearTable(",
          "6006:   );",
          "6007:   if( pOp->p3 ){",
          "6008:     p->nChange += nChange;",
          "",
          "[Removed Lines]",
          "6005:       db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)",
          "",
          "[Added Lines]",
          "6001:       db->aDb[pOp->p2].pBt, (u32)pOp->p1, (pOp->p3 ? &nChange : 0)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6055:   Db *pDb;",
          "6057:   sqlite3VdbeIncrWriteCounter(p, 0);",
          "",
          "[Removed Lines]",
          "6054:   int pgno;",
          "",
          "[Added Lines]",
          "6050:   Pgno pgno;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6126:     initData.iDb = iDb;",
          "6127:     initData.pzErrMsg = &p->zErrMsg;",
          "6128:     initData.mInitFlags = 0;",
          "6129:     zSql = sqlite3MPrintf(db,",
          "6130:        \"SELECT*FROM\\\"%w\\\".%s WHERE %s ORDER BY rowid\",",
          "6131:        db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6125:     initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);",
          "",
          "---------------"
        ],
        "src/vdbe.h||src/vdbe.h": [
          "File: src/vdbe.h -> src/vdbe.h"
        ],
        "src/vdbeInt.h||src/vdbeInt.h": [
          "File: src/vdbeInt.h -> src/vdbeInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "485: void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);",
          "486: void sqliteVdbePopStack(Vdbe*,int);",
          "487: int SQLITE_NOINLINE sqlite3VdbeFinishMoveto(VdbeCursor*);",
          "489: int sqlite3VdbeCursorRestore(VdbeCursor*);",
          "490: u32 sqlite3VdbeSerialTypeLen(u32);",
          "491: u8 sqlite3VdbeOneByteSerialTypeLen(u8);",
          "",
          "[Removed Lines]",
          "488: int sqlite3VdbeCursorMoveto(VdbeCursor**, int*);",
          "",
          "[Added Lines]",
          "488: int sqlite3VdbeCursorMoveto(VdbeCursor**, u32*);",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1712:     }",
          "1713: #endif",
          "1714:     case P4_INTARRAY: {",
          "1719:       for(i=1; i<=n; i++){",
          "1721:       }",
          "1722:       sqlite3_str_append(&x, \"]\", 1);",
          "1723:       break;",
          "",
          "[Removed Lines]",
          "1715:       int i;",
          "1716:       int *ai = pOp->p4.ai;",
          "1717:       int n = ai[0];   /* The first element of an INTARRAY is always the",
          "1720:         sqlite3_str_appendf(&x, \"%c%d\", (i==1 ? '[' : ','), ai[i]);",
          "",
          "[Added Lines]",
          "1715:       u32 i;",
          "1716:       u32 *ai = pOp->p4.ai;",
          "1717:       u32 n = ai[0];   /* The first element of an INTARRAY is always the",
          "1720:         sqlite3_str_appendf(&x, \"%c%u\", (i==1 ? '[' : ','), ai[i]);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3565:   VdbeCursor *p = *pp;",
          "3566:   assert( p->eCurType==CURTYPE_BTREE || p->eCurType==CURTYPE_PSEUDO );",
          "3567:   if( p->deferredMoveto ){",
          "3569:     if( p->aAltMap && (iMap = p->aAltMap[1+*piCol])>0 && !p->nullRow ){",
          "",
          "[Removed Lines]",
          "3564: int sqlite3VdbeCursorMoveto(VdbeCursor **pp, int *piCol){",
          "3568:     int iMap;",
          "",
          "[Added Lines]",
          "3564: int sqlite3VdbeCursorMoveto(VdbeCursor **pp, u32 *piCol){",
          "3568:     u32 iMap;",
          "",
          "---------------"
        ],
        "src/wal.c||src/wal.c": [
          "File: src/wal.c -> src/wal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "967:        && (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)",
          "968:        && (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE))",
          "969:   );",
          "970:   return iHash;",
          "971: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "970:   assert( iHash>=0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1246:     iLastFrame = (nSize - WAL_HDRSIZE) / szFrame;",
          "1248:       u32 *aShare;",
          "1253:       rc = walIndexPage(pWal, iPg, (volatile u32**)&aShare);",
          "1254:       if( rc ) break;",
          "1255:       pWal->apWiData[iPg] = aPrivate;",
          "",
          "[Removed Lines]",
          "1247:     for(iPg=0; iPg<=walFramePage(iLastFrame); iPg++){",
          "1250:       int iLast = MIN(iLastFrame, HASHTABLE_NPAGE_ONE+iPg*HASHTABLE_NPAGE);",
          "1251:       int iFirst = 1 + (iPg==0?0:HASHTABLE_NPAGE_ONE+(iPg-1)*HASHTABLE_NPAGE);",
          "1252:       int nHdr, nHdr32;",
          "",
          "[Added Lines]",
          "1248:     for(iPg=0; iPg<=(u32)walFramePage(iLastFrame); iPg++){",
          "1251:       u32 iLast = MIN(iLastFrame, HASHTABLE_NPAGE_ONE+iPg*HASHTABLE_NPAGE);",
          "1252:       u32 iFirst = 1 + (iPg==0?0:HASHTABLE_NPAGE_ONE+(iPg-1)*HASHTABLE_NPAGE);",
          "1253:       u32 nHdr, nHdr32;",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1052:   ){",
          "1053:     int i;",
          "1054:     Table *pTab = pIdx->pTable;",
          "1056:     if( ai ){",
          "1057:       ai[0] = pTab->nCol;",
          "1058:       for(i=0; i<pIdx->nColumn-1; i++){",
          "",
          "[Removed Lines]",
          "1055:     int *ai = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*(pTab->nCol+1));",
          "",
          "[Added Lines]",
          "1055:     u32 *ai = (u32*)sqlite3DbMallocZero(pParse->db, sizeof(u32)*(pTab->nCol+1));",
          "",
          "---------------"
        ],
        "test/corrupt3.test||test/corrupt3.test": [
          "File: test/corrupt3.test -> test/corrupt3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:   catchsql {",
          "95:     SELECT substr(x,1,10) FROM t1",
          "96:   }",
          "98: do_test corrupt3-1.10 {",
          "99:   catchsql {",
          "100:     PRAGMA integrity_check",
          "",
          "[Removed Lines]",
          "97: } [list 0 0123456789]",
          "",
          "[Added Lines]",
          "97: } [list 1 {database disk image is malformed}]",
          "",
          "---------------"
        ],
        "test/corruptL.test||test/corruptL.test": [
          "File: test/corruptL.test -> test/corruptL.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1174: | end clusterfuzz-testcase-minimized-sqlite3_dbfuzz2_fuzzer-4806406219825152",
          "1175: }]} {}",
          "1177: do_catchsql_test 14.1 {",
          "1178:   PRAGMA integrity_check;",
          "1179: } {1 {database disk image is malformed}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1177: extra_schema_checks 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1181: do_catchsql_test 14.2 {",
          "1182:   ALTER TABLE t1 RENAME TO alkjalkjdfiiiwuer987lkjwer82mx97sf98788s9789s;",
          "1183: } {1 {database disk image is malformed}}",
          "1185: #-------------------------------------------------------------------------",
          "1186: reset_db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1185: extra_schema_checks 1",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1263: | end crash-3afa1ca9e9c1bd.db",
          "1264: }]} {}",
          "1266: do_execsql_test 15.1 {",
          "1267:   UPDATE c1 SET c= NOT EXISTS(SELECT 1 FROM c1 ORDER BY (SELECT 1 FROM c1 ORDER BY a)) +10 WHERE d BETWEEN 4 AND 7;",
          "1268: } {}",
          "1270: #-------------------------------------------------------------------------",
          "1271: reset_db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1268: extra_schema_checks 0",
          "1272: extra_schema_checks 1",
          "",
          "---------------"
        ],
        "test/dbfuzz001.test||test/dbfuzz001.test": [
          "File: test/dbfuzz001.test -> test/dbfuzz001.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "361:   }]",
          "362: } {}",
          "364: do_catchsql_test dbfuzz001-320 {",
          "365:   PRAGMA integrity_check;",
          "366: } {1 {database disk image is malformed}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "364: extra_schema_checks 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "368: do_catchsql_test dbfuzz001-330 {",
          "369:   DELETE FROM t3 WHERE x IN (SELECT x FROM t4);",
          "370: } {1 {database disk image is malformed}}",
          "372: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "372: extra_schema_checks 1",
          "",
          "---------------"
        ],
        "test/fts3corrupt4.test||test/fts3corrupt4.test": [
          "File: test/fts3corrupt4.test -> test/fts3corrupt4.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: sqlite3_fts3_may_be_corrupt 1",
          "29: database_may_be_corrupt",
          "31: do_execsql_test 1.0 {",
          "32:   BEGIN;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: extra_schema_checks 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6281: } {1 {database disk image is malformed}}",
          "6283: set sqlite_fts3_enable_parentheses $saved",
          "6285: #-------------------------------------------------------------------------",
          "6286: reset_db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6285: extra_schema_checks 1",
          "",
          "---------------"
        ],
        "test/pager1.test||test/pager1.test": [
          "File: test/pager1.test -> test/pager1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1930:   catchsql { SELECT length(x||'') FROM t2 } db2",
          "1931: } {1 {database disk image is malformed}}",
          "1932: db2 close",
          "1933: do_test pager1-18.5 {",
          "1934:   sqlite3 db \"\"",
          "1935:   sqlite3_db_config db DEFENSIVE 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1933: extra_schema_checks 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1944:   catchsql { SELECT * FROM x1 }",
          "1945: } {1 {database disk image is malformed}}",
          "1946: db close",
          "1948: do_test pager1-18.6 {",
          "1949:   faultsim_delete_and_reopen",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1948: extra_schema_checks 1",
          "",
          "---------------"
        ],
        "test/tester.tcl||test/tester.tcl": [
          "File: test/tester.tcl -> test/tester.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "2479: # this setting by invoking \"database_can_be_corrupt\"",
          "2480: #",
          "2481: database_never_corrupt",
          "2483: source $testdir/thread_common.tcl",
          "2484: source $testdir/malloc_common.tcl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2482: extra_schema_checks 1",
          "",
          "---------------"
        ],
        "tool/enlargedb.c||tool/enlargedb.c": [
          "File: tool/enlargedb.c -> tool/enlargedb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include <stdio.h>",
          "15: #include <string.h>",
          "16: #include <stdlib.h>",
          "18: int main(int argc, char **argv){",
          "19:   char *zEnd;",
          "20:   long long int toAppend;",
          "21:   long long int currentSz;",
          "22:   long long int newSz;",
          "23:   FILE *f;",
          "24:   size_t got;",
          "25:   int pgsz;",
          "26:   char zero = 0;",
          "27:   unsigned char buf[100];",
          "29:   if( argc!=3 ) goto usage_error;",
          "30:   toAppend = strtoll(argv[2], &zEnd, 0);",
          "31:   if( zEnd==argv[2] || zEnd[0] ) goto usage_error;",
          "32:   if( toAppend<1 ){",
          "33:     fprintf(stderr, \"N must be at least 1\\n\");",
          "34:     exit(1);",
          "35:   }",
          "36:   f = fopen(argv[1], \"r+b\");",
          "37:   if( f==0 ){",
          "38:     fprintf(stderr, \"cannot open \\\"%s\\\" for reading and writing\\n\", argv[1]);",
          "39:     exit(1);",
          "40:   }",
          "41:   got = fread(buf, 1, sizeof(buf), f);",
          "42:   if( got!=sizeof(buf) ) goto not_valid_db;",
          "43:   if( strcmp((char*)buf,\"SQLite format 3\")!=0 ) goto not_valid_db;",
          "44:   pgsz = (buf[16]<<8) + buf[17];",
          "45:   if( pgsz==1 ) pgsz = 65536;",
          "46:   if( pgsz<512 || pgsz>65536 || (pgsz&(pgsz-1))!=0 ) goto not_valid_db;",
          "47:   currentSz = (buf[28]<<24) + (buf[29]<<16) + (buf[30]<<8) + buf[31];",
          "48:   newSz = currentSz + toAppend;",
          "49:   if( newSz > 0xffffffff ) newSz = 0xffffffff;",
          "50:   buf[28] = (newSz>>24) & 0xff;",
          "51:   buf[29] = (newSz>>16) & 0xff;",
          "52:   buf[30] = (newSz>>8) & 0xff;",
          "53:   buf[31] = newSz & 0xff;",
          "54:   fseek(f, 28, SEEK_SET);",
          "55:   fwrite(&buf[28],4,1,f);",
          "56:   fseek(f, (long)(newSz*pgsz - 1), SEEK_SET);",
          "57:   fwrite(&zero,1,1,f);",
          "58:   fclose(f);",
          "59:   return 0;",
          "61: not_valid_db:",
          "62:   fprintf(stderr,\"not a valid database: %s\\n\", argv[1]);",
          "63:   exit(1);",
          "65: usage_error:",
          "66:   fprintf(stderr,\"Usage: %s DATABASE N\\n\", argv[0]);",
          "67:   exit(1);",
          "68: }",
          "",
          "---------------"
        ],
        "tool/showdb.c||tool/showdb.c": [
          "File: tool/showdb.c -> tool/showdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:   return (z[0]<<24) + (z[1]<<16) + (z[2]<<8) + z[3];",
          "59: }",
          "",
          "[Removed Lines]",
          "57: static unsigned int decodeInt32(const unsigned char *z){",
          "",
          "[Added Lines]",
          "58: static u32 decodeInt32(const u8 *z){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141: static unsigned char *fileRead(sqlite3_int64 ofst, int nByte){",
          "142:   unsigned char *aData;",
          "143:   int got;",
          "145:   if( aData==0 ) out_of_memory();",
          "146:   memset(aData, 0, nByte+32);",
          "147:   if( g.bRaw==0 ){",
          "",
          "[Removed Lines]",
          "144:   aData = sqlite3_malloc(nByte+32);",
          "",
          "[Added Lines]",
          "145:   aData = sqlite3_malloc64(32+(i64)nByte);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:   if( g.bRaw==0 ){",
          "167:     int rc = g.pFd->pMethods->xFileSize(g.pFd, &res);",
          "168:     if( rc!=SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "164: static sqlite3_int64 fileGetsize(void){",
          "165:   sqlite3_int64 res = 0;",
          "",
          "[Added Lines]",
          "165: static i64 fileGetsize(void){",
          "166:   i64 res = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "208:   aData = fileRead(ofst, nByte);",
          "209:   for(i=0; i<nByte; i += g.perLine){",
          "210:     fprintf(stdout, zOfstFmt, i+printOfst);",
          "211:     for(j=0; j<g.perLine; j++){",
          "212:       if( i+j>nByte ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211:     int go = 0;",
          "212:     for(j=0; j<g.perLine; j++){",
          "213:       if( i+j>nByte ){ break; }",
          "214:       if( aData[i+j] ){ go = 1; break; }",
          "215:     }",
          "216:     if( !go && i>0 && i+g.perLine<nByte ) continue;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "235:   unsigned char *aData;",
          "238:           iPg, iStart, iStart+g.pagesize-1);",
          "239:   aData = print_byte_range(iStart, g.pagesize, 0);",
          "240:   sqlite3_free(aData);",
          "241: }",
          "246: static void print_decode_line(",
          "",
          "[Removed Lines]",
          "233: static void print_page(int iPg){",
          "234:   int iStart;",
          "236:   iStart = (iPg-1)*g.pagesize;",
          "237:   fprintf(stdout, \"Page %d:   (offsets 0x%x..0x%x)\\n\",",
          "",
          "[Added Lines]",
          "240: static void print_page(u32 iPg){",
          "241:   i64 iStart;",
          "243:   iStart = ((i64)(iPg-1))*g.pagesize;",
          "244:   fprintf(stdout, \"Page %u:   (offsets 0x%llx..0x%llx)\\n\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "250: ){",
          "251:   int i, j;",
          "253:   char zBuf[100];",
          "254:   sprintf(zBuf, \" %03x: %02x\", ofst, aData[ofst]);",
          "255:   i = (int)strlen(zBuf);",
          "",
          "[Removed Lines]",
          "252:   int val = aData[ofst];",
          "",
          "[Added Lines]",
          "259:   u32 val = aData[ofst];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "262:     }",
          "263:     i += (int)strlen(&zBuf[i]);",
          "264:   }",
          "266:   printf(\"%s  %s\\n\", zBuf, zMsg);",
          "267: }",
          "",
          "[Removed Lines]",
          "265:   sprintf(&zBuf[i], \"   %9d\", val);",
          "",
          "[Added Lines]",
          "272:   sprintf(&zBuf[i], \"   %10u\", val);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "296:   print_decode_line(aData, 88, 4, \"meta[12]\");",
          "297:   print_decode_line(aData, 92, 4, \"Change counter for version number\");",
          "298:   print_decode_line(aData, 96, 4, \"SQLite version number\");",
          "299: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "306:   sqlite3_free(aData);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "408:   int i;",
          "409:   i64 nDesc = 0;",
          "410:   int n = 0;",
          "412:   i64 nPayload;",
          "413:   i64 rowid;",
          "414:   i64 nLocal;",
          "",
          "[Removed Lines]",
          "411:   int leftChild;",
          "",
          "[Added Lines]",
          "419:   u32 leftChild;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "418:     leftChild = ((a[0]*256 + a[1])*256 + a[2])*256 + a[3];",
          "419:     a += 4;",
          "420:     n += 4;",
          "422:     nDesc = strlen(zDesc);",
          "423:   }",
          "424:   if( cType!=5 ){",
          "",
          "[Removed Lines]",
          "421:     sprintf(zDesc, \"lx: %d \", leftChild);",
          "",
          "[Added Lines]",
          "429:     sprintf(zDesc, \"lx: %u \", leftChild);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "439:     nDesc += strlen(&zDesc[nDesc]);",
          "440:   }",
          "441:   if( nLocal<nPayload ){",
          "443:     unsigned char *b = &a[nLocal];",
          "444:     ovfl = ((b[0]*256 + b[1])*256 + b[2])*256 + b[3];",
          "446:     nDesc += strlen(&zDesc[nDesc]);",
          "447:     n += 4;",
          "448:   }",
          "",
          "[Removed Lines]",
          "442:     int ovfl;",
          "445:     sprintf(&zDesc[nDesc], \"ov: %d \", ovfl);",
          "",
          "[Added Lines]",
          "450:     u32 ovfl;",
          "453:     sprintf(&zDesc[nDesc], \"ov: %u \", ovfl);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "486: ){",
          "487:   int i, j = 0;",
          "489:   i64 k;",
          "490:   i64 nPayload;",
          "491:   i64 rowid;",
          "",
          "[Removed Lines]",
          "488:   int leftChild;",
          "",
          "[Added Lines]",
          "496:   u32 leftChild;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "504:   if( cType<=5 ){",
          "505:     leftChild = ((x[0]*256 + x[1])*256 + x[2])*256 + x[3];",
          "506:     printBytes(a, x, 4);",
          "508:     x += 4;",
          "509:   }",
          "510:   if( cType!=5 ){",
          "",
          "[Removed Lines]",
          "507:     printf(\"left child page:: %d\\n\", leftChild);",
          "",
          "[Added Lines]",
          "515:     printf(\"left child page:: %u\\n\", leftChild);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "622:   }",
          "623:   if( nLocal<nPayload ){",
          "624:     printBytes(a, x+nLocal, 4);",
          "626:   }",
          "627: }",
          "",
          "[Removed Lines]",
          "625:     printf(\"overflow-page: %d\\n\", decodeInt32(x+nLocal));",
          "",
          "[Added Lines]",
          "633:     printf(\"overflow-page: %u\\n\", decodeInt32(x+nLocal));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "731: static void decode_trunk_page(",
          "735: ){",
          "737:   unsigned char *a;",
          "738:   while( pgno>0 ){",
          "739:     a = fileRead((pgno-1)*g.pagesize, g.pagesize);",
          "",
          "[Removed Lines]",
          "736:   int n, i;",
          "",
          "[Added Lines]",
          "744:   u32 i;",
          "745:   u32 n;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "741:     print_decode_line(a, 0, 4, \"Next freelist trunk page\");",
          "742:     print_decode_line(a, 4, 4, \"Number of entries on this page\");",
          "743:     if( detail ){",
          "747:         char zIdx[10];",
          "748:         sprintf(zIdx, \"[%d]\", i);",
          "749:         printf(\"  %5s %7u\", zIdx, x);",
          "",
          "[Removed Lines]",
          "744:       n = (int)decodeInt32(&a[4]);",
          "745:       for(i=0; i<n; i++){",
          "746:         unsigned int x = decodeInt32(&a[8+4*i]);",
          "",
          "[Added Lines]",
          "753:       n = decodeInt32(&a[4]);",
          "754:       for(i=0; i<n && i<g.pagesize/4; i++){",
          "755:         u32 x = decodeInt32(&a[8+4*i]);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "754:     if( !recursive ){",
          "755:       pgno = 0;",
          "756:     }else{",
          "758:     }",
          "759:     sqlite3_free(a);",
          "760:   }",
          "",
          "[Removed Lines]",
          "757:       pgno = (int)decodeInt32(&a[0]);",
          "",
          "[Added Lines]",
          "766:       pgno = decodeInt32(&a[0]);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "772:   va_list ap;",
          "773:   char *zMsg;",
          "",
          "[Removed Lines]",
          "771: static void page_usage_msg(int pgno, const char *zFormat, ...){",
          "",
          "[Added Lines]",
          "780: static void page_usage_msg(u32 pgno, const char *zFormat, ...){",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "776:   zMsg = sqlite3_vmprintf(zFormat, ap);",
          "777:   va_end(ap);",
          "778:   if( pgno<=0 || pgno>g.mxPage ){",
          "780:             pgno, g.mxPage, zMsg);",
          "781:     sqlite3_free(zMsg);",
          "782:     return;",
          "",
          "[Removed Lines]",
          "779:     printf(\"ERROR: page %d out of range 1..%d: %s\\n\",",
          "",
          "[Added Lines]",
          "788:     printf(\"ERROR: page %d out of range 1..%u: %s\\n\",",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "823:     n += i;",
          "824:   }",
          "825:   if( nLocal<nPayload ){",
          "828:     while( ovfl && (cnt++)<g.mxPage ){",
          "830:                      cnt, cellno, pgno);",
          "831:       a = fileRead((ovfl-1)*(sqlite3_int64)g.pagesize, 4);",
          "832:       ovfl = decodeInt32(a);",
          "",
          "[Removed Lines]",
          "826:     int ovfl = decodeInt32(a+nLocal);",
          "827:     int cnt = 0;",
          "829:       page_usage_msg(ovfl, \"overflow %d from cell %d of page %d\",",
          "",
          "[Added Lines]",
          "835:     u32 ovfl = decodeInt32(a+nLocal);",
          "836:     u32 cnt = 0;",
          "838:       page_usage_msg(ovfl, \"overflow %d from cell %d of page %u\",",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "901:   }",
          "902:   if( a[hdr]==2 || a[hdr]==5 ){",
          "903:     int cellstart = hdr+12;",
          "905:     for(i=0; i<nCell; i++){",
          "908:       ofst = cellstart + i*2;",
          "909:       ofst = a[ofst]*256 + a[ofst+1];",
          "",
          "[Removed Lines]",
          "904:     unsigned int child;",
          "906:       int ofst;",
          "",
          "[Added Lines]",
          "913:     u32 child;",
          "915:       u32 ofst;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "932:   unsigned char *a;",
          "933:   int cnt = 0;",
          "934:   int i;",
          "",
          "[Removed Lines]",
          "931: static void page_usage_freelist(int pgno){",
          "",
          "[Added Lines]",
          "940: static void page_usage_freelist(u32 pgno){",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "959:   if( decodeInt32(a+52) ){",
          "960:     int usable = g.pagesize - a[20];",
          "962:     int perPage = usable/5;",
          "963:     while( pgno<=g.mxPage ){",
          "965:                            pgno+1, pgno+perPage);",
          "966:       pgno += perPage + 1;",
          "967:     }",
          "",
          "[Removed Lines]",
          "958: static void page_usage_ptrmap(unsigned char *a){",
          "961:     int pgno = 2;",
          "964:       page_usage_msg(pgno, \"PTRMAP page covering %d..%d\",",
          "",
          "[Added Lines]",
          "967: static void page_usage_ptrmap(u8 *a){",
          "970:     u64 pgno = 2;",
          "973:       page_usage_msg((u32)pgno, \"PTRMAP page covering %llu..%llu\",",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "974: static void page_usage_report(const char *zPrg, const char *zDbName){",
          "976:   int rc;",
          "977:   sqlite3 *db;",
          "978:   sqlite3_stmt *pStmt;",
          "",
          "[Removed Lines]",
          "975:   int i, j;",
          "",
          "[Added Lines]",
          "984:   u32 i, j;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "994:   if( zPageUse==0 ) out_of_memory();",
          "995:   memset(zPageUse, 0, sizeof(zPageUse[0])*(g.mxPage+1));",
          "",
          "[Removed Lines]",
          "993:   zPageUse = sqlite3_malloc( sizeof(zPageUse[0])*(g.mxPage+1) );",
          "",
          "[Added Lines]",
          "1002:   zPageUse = sqlite3_malloc64( sizeof(zPageUse[0])*(g.mxPage+1) );",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1008:     rc = sqlite3_prepare_v2(db, zQuery, -1, &pStmt, 0);",
          "1009:     if( rc==SQLITE_OK ){",
          "1010:       while( sqlite3_step(pStmt)==SQLITE_ROW ){",
          "1012:         page_usage_btree(pgno, 0, 0, (const char*)sqlite3_column_text(pStmt,1));",
          "1013:       }",
          "1014:     }else{",
          "",
          "[Removed Lines]",
          "1011:         int pgno = sqlite3_column_int(pStmt, 2);",
          "",
          "[Added Lines]",
          "1020:         u32 pgno = (u32)sqlite3_column_int64(pStmt, 2);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1023:   for(i=1; i<=g.mxPage; i++){",
          "1024:     if( zPageUse[i]==0 ) page_usage_btree(i, -1, 0, 0);",
          "1026:     sqlite3_free(zPageUse[i]);",
          "1027:   }",
          "1028:   sqlite3_free(zPageUse);",
          "",
          "[Removed Lines]",
          "1025:     printf(\"%5d: %s\\n\", i, zPageUse[i] ? zPageUse[i] : \"???\");",
          "",
          "[Added Lines]",
          "1034:     printf(\"%5u: %s\\n\", i, zPageUse[i] ? zPageUse[i] : \"???\");",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1035: static void ptrmap_coverage_report(const char *zDbName){",
          "1037:   unsigned char *aHdr;",
          "1038:   unsigned char *a;",
          "1039:   int usable;",
          "",
          "[Removed Lines]",
          "1036:   int pgno;",
          "",
          "[Added Lines]",
          "1045:   u64 pgno;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1057:   sqlite3_free(aHdr);",
          "1058:   printf(\"%5d: root of sqlite_schema\\n\", 1);",
          "1059:   for(pgno=2; pgno<=g.mxPage; pgno += perPage+1){",
          "1061:            pgno+1, pgno+perPage);",
          "1062:     a = fileRead((pgno-1)*g.pagesize, usable);",
          "1063:     for(i=0; i+5<=usable && pgno+1+i/5<=g.mxPage; i+=5){",
          "1064:       const char *zType = \"???\";",
          "1066:       switch( a[i] ){",
          "1067:         case 1:  zType = \"b-tree root page\";        break;",
          "1068:         case 2:  zType = \"freelist page\";           break;",
          "",
          "[Removed Lines]",
          "1060:     printf(\"%5d: PTRMAP page covering %d..%d\\n\", pgno,",
          "1065:       unsigned int iFrom = decodeInt32(&a[i+1]);",
          "",
          "[Added Lines]",
          "1069:     printf(\"%5llu: PTRMAP page covering %llu..%llu\\n\", pgno,",
          "1074:       u32 iFrom = decodeInt32(&a[i+1]);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1070:         case 4:  zType = \"later page of overflow\";  break;",
          "1071:         case 5:  zType = \"b-tree non-root page\";    break;",
          "1072:       }",
          "1074:     }",
          "1075:     sqlite3_free(a);",
          "1076:   }",
          "",
          "[Removed Lines]",
          "1073:       printf(\"%5d: %s, parent=%u\\n\", pgno+1+i/5, zType, iFrom);",
          "",
          "[Added Lines]",
          "1082:       printf(\"%5llu: %s, parent=%u\\n\", pgno+1+i/5, zType, iFrom);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1132:   sqlite3_free(zPgSz);",
          "1134:   printf(\"Pagesize: %d\\n\", g.pagesize);",
          "1138:   if( nArg==2 ){",
          "1140:     for(i=1; i<=g.mxPage; i++) print_page(i);",
          "1141:   }else{",
          "1142:     int i;",
          "1143:     for(i=2; i<nArg; i++){",
          "1145:       char *zLeft;",
          "1146:       if( strcmp(azArg[i], \"dbheader\")==0 ){",
          "1147:         print_db_header();",
          "",
          "[Removed Lines]",
          "1135:   g.mxPage = (int)((szFile+g.pagesize-1)/g.pagesize);",
          "1137:   printf(\"Available pages: 1..%d\\n\", g.mxPage);",
          "1139:     int i;",
          "1144:       int iStart, iEnd;",
          "",
          "[Added Lines]",
          "1144:   g.mxPage = (u32)((szFile+g.pagesize-1)/g.pagesize);",
          "1146:   printf(\"Available pages: 1..%u\\n\", g.mxPage);",
          "1148:     u32 i;",
          "1153:       u32 iStart, iEnd;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1163:         fprintf(stderr, \"%s: unknown option: [%s]\\n\", zPrg, azArg[i]);",
          "1164:         continue;",
          "1165:       }",
          "1167:       if( zLeft && strcmp(zLeft,\"..end\")==0 ){",
          "1168:         iEnd = g.mxPage;",
          "1169:       }else if( zLeft && zLeft[0]=='.' && zLeft[1]=='.' ){",
          "",
          "[Removed Lines]",
          "1166:       iStart = strtol(azArg[i], &zLeft, 0);",
          "",
          "[Added Lines]",
          "1175:       iStart = strtoul(azArg[i], &zLeft, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d9674b385c0f5ed16cddcd659c99ef5a937d1d4f",
      "candidate_info": {
        "commit_hash": "d9674b385c0f5ed16cddcd659c99ef5a937d1d4f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d9674b385c0f5ed16cddcd659c99ef5a937d1d4f",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c",
          "src/attach.c",
          "src/build.c",
          "src/delete.c",
          "src/mem2.c",
          "src/parse.y",
          "src/resolve.c",
          "src/select.c",
          "src/sqliteInt.h",
          "src/test_malloc.c",
          "src/trigger.c",
          "src/update.c",
          "test/altertab3.test",
          "test/fts4upfrom.test",
          "test/pg_common.tcl",
          "test/tester.tcl",
          "test/triggerupfrom.test",
          "test/upfrom1.tcl",
          "test/upfrom1.test",
          "test/upfrom2.test",
          "test/upfrom3.test",
          "test/upfromfault.test"
        ],
        "message": "Add UPDATE FROM compatible with postgresql.\n\nFossilOrigin-Name: 88baf1eb0706503214012520be4d872594ccc5b4c9674c44cc07b67ade2bfcf2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c",
          "src/attach.c||src/attach.c",
          "src/build.c||src/build.c",
          "src/delete.c||src/delete.c",
          "src/mem2.c||src/mem2.c",
          "src/parse.y||src/parse.y",
          "src/resolve.c||src/resolve.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/test_malloc.c||src/test_malloc.c",
          "src/trigger.c||src/trigger.c",
          "src/update.c||src/update.c",
          "test/altertab3.test||test/altertab3.test",
          "test/fts4upfrom.test||test/fts4upfrom.test",
          "test/pg_common.tcl||test/pg_common.tcl",
          "test/tester.tcl||test/tester.tcl",
          "test/triggerupfrom.test||test/triggerupfrom.test",
          "test/upfrom1.tcl||test/upfrom1.tcl",
          "test/upfrom1.test||test/upfrom1.test",
          "test/upfrom2.test||test/upfrom2.test",
          "test/upfrom3.test||test/upfrom3.test",
          "test/upfromfault.test||test/upfromfault.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c1ea064948ba08c4be209ad6efc2126a7367bcb06266ea35eb957bf2d4e2cb9f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1191:       if( pParse->nErr ) rc = pParse->rc;",
          "1192:     }",
          "1193:     if( rc==SQLITE_OK && pStep->zTarget ){",
          "1205:           rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);",
          "1206:         }",
          "1207:         if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "1194:       Table *pTarget = sqlite3LocateTable(pParse, 0, pStep->zTarget, zDb);",
          "1195:       if( pTarget==0 ){",
          "1196:         rc = SQLITE_ERROR;",
          "1197:       }else if( SQLITE_OK==(rc = sqlite3ViewGetColumnNames(pParse, pTarget)) ){",
          "1198:         SrcList sSrc;",
          "1199:         memset(&sSrc, 0, sizeof(sSrc));",
          "1200:         sSrc.nSrc = 1;",
          "1201:         sSrc.a[0].zName = pStep->zTarget;",
          "1202:         sSrc.a[0].pTab = pTarget;",
          "1203:         sNC.pSrcList = &sSrc;",
          "1204:         if( pStep->pWhere ){",
          "",
          "[Added Lines]",
          "1194:       SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);",
          "1195:       if( pSrc ){",
          "1196:         int i;",
          "1197:         for(i=0; i<pSrc->nSrc; i++){",
          "1198:           struct SrcList_item *p = &pSrc->a[i];",
          "1199:           p->pTab = sqlite3LocateTableItem(pParse, 0, p);",
          "1200:           p->iCursor = pParse->nTab++;",
          "1201:           if( p->pTab==0 ){",
          "1202:             rc = SQLITE_ERROR;",
          "1203:           }else{",
          "1204:             p->pTab->nTabRef++;",
          "1205:             rc = sqlite3ViewGetColumnNames(pParse, p->pTab);",
          "1206:           }",
          "1207:         }",
          "1208:         sNC.pSrcList = pSrc;",
          "1209:         if( rc==SQLITE_OK && pStep->pWhere ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1211:         if( pStep->pUpsert ){",
          "1212:           Upsert *pUpsert = pStep->pUpsert;",
          "1213:           assert( rc==SQLITE_OK );",
          "1215:           sNC.uNC.pUpsert = pUpsert;",
          "1216:           sNC.ncFlags = NC_UUpsert;",
          "1217:           rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);",
          "",
          "[Removed Lines]",
          "1214:           pUpsert->pUpsertSrc = &sSrc;",
          "",
          "[Added Lines]",
          "1219:           pUpsert->pUpsertSrc = pSrc;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1228:           sNC.ncFlags = 0;",
          "1229:         }",
          "1230:         sNC.pSrcList = 0;",
          "1231:       }",
          "1232:     }",
          "1233:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1236:         sqlite3SrcListDelete(db, pSrc);",
          "1237:       }else{",
          "1238:         rc = SQLITE_NOMEM;",
          "",
          "---------------"
        ],
        "src/attach.c||src/attach.c": [
          "File: src/attach.c -> src/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "599:     if( sqlite3FixExprList(pFix, pStep->pExprList) ){",
          "600:       return 1;",
          "601:     }",
          "602: #ifndef SQLITE_OMIT_UPSERT",
          "603:     if( pStep->pUpsert ){",
          "604:       Upsert *pUp = pStep->pUpsert;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602:     if( pStep->pFrom && sqlite3FixSrcList(pFix, pStep->pFrom) ){",
          "603:       return 1;",
          "604:     }",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4569:   }",
          "4570: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4577: SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2){",
          "4578:   assert( p1 && p1->nSrc==1 );",
          "4579:   if( p2 ){",
          "4580:     SrcList *pNew = sqlite3SrcListEnlarge(pParse, p1, p2->nSrc, 1);",
          "4581:     if( pNew==0 ){",
          "4582:       sqlite3SrcListDelete(pParse->db, p2);",
          "4583:     }else{",
          "4584:       p1 = pNew;",
          "4585:       memcpy(&p1->a[1], p2->a, p2->nSrc*sizeof(struct SrcList_item));",
          "4586:       sqlite3DbFree(pParse->db, p2);",
          "4587:     }",
          "4588:   }",
          "4589:   return p1;",
          "4590: }",
          "",
          "---------------"
        ],
        "src/delete.c||src/delete.c": [
          "File: src/delete.c -> src/delete.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){",
          "32:   struct SrcList_item *pItem = pSrc->a;",
          "33:   Table *pTab;",
          "35:   pTab = sqlite3LocateTableItem(pParse, 0, pItem);",
          "36:   sqlite3DeleteTable(pParse->db, pItem->pTab);",
          "37:   pItem->pTab = pTab;",
          "",
          "[Removed Lines]",
          "34:   assert( pItem && pSrc->nSrc==1 );",
          "",
          "[Added Lines]",
          "34:   assert( pItem && pSrc->nSrc>=1 );",
          "",
          "---------------"
        ],
        "src/mem2.c||src/mem2.c": [
          "File: src/mem2.c -> src/mem2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "381: void sqlite3MemdebugSetType(void *p, u8 eType){",
          "383:     struct MemBlockHdr *pHdr;",
          "384:     pHdr = sqlite3MemsysGetHeader(p);",
          "385:     assert( pHdr->iForeGuard==FOREGUARD );",
          "",
          "[Removed Lines]",
          "382:   if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){",
          "",
          "[Added Lines]",
          "382:   if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "399: int sqlite3MemdebugHasType(void *p, u8 eType){",
          "400:   int rc = 1;",
          "402:     struct MemBlockHdr *pHdr;",
          "403:     pHdr = sqlite3MemsysGetHeader(p);",
          "",
          "[Removed Lines]",
          "401:   if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){",
          "",
          "[Added Lines]",
          "401:   if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "421: int sqlite3MemdebugNoType(void *p, u8 eType){",
          "422:   int rc = 1;",
          "424:     struct MemBlockHdr *pHdr;",
          "425:     pHdr = sqlite3MemsysGetHeader(p);",
          "",
          "[Removed Lines]",
          "423:   if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){",
          "",
          "[Added Lines]",
          "423:   if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "662: from(A) ::= FROM seltablist(X). {",
          "663:   A = X;",
          "664:   sqlite3SrcListShiftJoinType(A);",
          "",
          "[Removed Lines]",
          "661: from(A) ::= .                {A = sqlite3DbMallocZero(pParse->db, sizeof(*A));}",
          "",
          "[Added Lines]",
          "661: from(A) ::= .                {A = 0;}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "892: %if SQLITE_ENABLE_UPDATE_DELETE_LIMIT || SQLITE_UDL_CAPABLE_PARSER",
          "894:         where_opt(W) orderby_opt(O) limit_opt(L).  {",
          "895:   sqlite3SrcListIndexedBy(pParse, X, &I);",
          "896:   sqlite3ExprListCheckLength(pParse,Y,\"set list\");",
          "897: #ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "898:   if( O || L ){",
          "",
          "[Removed Lines]",
          "893: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)",
          "",
          "[Added Lines]",
          "893: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y) from(F)",
          "896:   X = sqlite3SrcListAppendList(pParse, X, F);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "904:   sqlite3Update(pParse,X,Y,W,R,O,L,0);",
          "905: }",
          "906: %else",
          "908:         where_opt(W). {",
          "909:   sqlite3SrcListIndexedBy(pParse, X, &I);",
          "910:   sqlite3ExprListCheckLength(pParse,Y,\"set list\");",
          "911:   sqlite3Update(pParse,X,Y,W,R,0,0,0);",
          "912: }",
          "913: %endif",
          "",
          "[Removed Lines]",
          "907: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)",
          "",
          "[Added Lines]",
          "908: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y) from(F)",
          "912:   X = sqlite3SrcListAppendList(pParse, X, F);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1515: %destructor trigger_cmd {sqlite3DeleteTriggerStep(pParse->db, $$);}",
          "1517: trigger_cmd(A) ::=",
          "1522: trigger_cmd(A) ::= scanpt(B) insert_cmd(R) INTO",
          "",
          "[Removed Lines]",
          "1518:    UPDATE(B) orconf(R) trnm(X) tridxby SET setlist(Y) where_opt(Z) scanpt(E).",
          "1519:    {A = sqlite3TriggerUpdateStep(pParse, &X, Y, Z, R, B.z, E);}",
          "",
          "[Added Lines]",
          "1520:    UPDATE(B) orconf(R) trnm(X) tridxby SET setlist(Y) from(F) where_opt(Z) scanpt(E).",
          "1521:    {A = sqlite3TriggerUpdateStep(pParse, &X, F, Y, Z, R, B.z, E);}",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "756: #endif",
          "757:   switch( pExpr->op ){",
          "764:     case TK_ROW: {",
          "765:       SrcList *pSrcList = pNC->pSrcList;",
          "766:       struct SrcList_item *pItem;",
          "768:       pItem = pSrcList->a;",
          "770:       pExpr->op = TK_COLUMN;",
          "771:       pExpr->y.pTab = pItem->pTab;",
          "772:       pExpr->iTable = pItem->iCursor;",
          "774:       pExpr->affExpr = SQLITE_AFF_INTEGER;",
          "775:       break;",
          "776:     }",
          "",
          "[Removed Lines]",
          "759: #if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)",
          "767:       assert( pSrcList && pSrcList->nSrc==1 );",
          "769:       assert( HasRowid(pItem->pTab) && pItem->pTab->pSelect==0 );",
          "773:       pExpr->iColumn = -1;",
          "777: #endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)",
          "",
          "[Added Lines]",
          "767:       assert( pSrcList && pSrcList->nSrc>=1 );",
          "772:       pExpr->iColumn--;",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){",
          "104:   pDest->eDest = (u8)eDest;",
          "105:   pDest->iSDParm = iParm;",
          "106:   pDest->zAffSdst = 0;",
          "107:   pDest->iSdst = 0;",
          "108:   pDest->nSdst = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:   pDest->iSDParm2 = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "975:       testcase( eDest==SRT_Coroutine );",
          "976:       testcase( eDest==SRT_Output );",
          "977:       assert( eDest==SRT_Set || eDest==SRT_Mem",
          "979:     }",
          "980:     sRowLoadInfo.regResult = regResult;",
          "981:     sRowLoadInfo.ecelFlags = ecelFlags;",
          "",
          "[Removed Lines]",
          "978:            || eDest==SRT_Coroutine || eDest==SRT_Output );",
          "",
          "[Added Lines]",
          "979:            || eDest==SRT_Coroutine || eDest==SRT_Output",
          "980:            || eDest==SRT_Upfrom );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1124:       break;",
          "1125:     }",
          "1127: #ifndef SQLITE_OMIT_SUBQUERY",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1129:     case SRT_Upfrom: {",
          "1130: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "1131:       if( pSort ){",
          "1132:         pushOntoSorter(",
          "1133:             pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);",
          "1134:       }else",
          "1135: #endif",
          "1136:       {",
          "1137:         int i2 = pDest->iSDParm2;",
          "1138:         int r1 = sqlite3GetTempReg(pParse);",
          "1139:         sqlite3VdbeAddOp3(v, OP_MakeRecord,regResult+(i2<0),nResultCol-(i2<0),r1);",
          "1140:         if( i2<0 ){",
          "1141:           sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);",
          "1142:         }else{",
          "1143:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);",
          "1144:         }",
          "1145:       }",
          "1146:       break;",
          "1147:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1555:       break;",
          "1556:     }",
          "1557: #endif",
          "1558:     default: {",
          "1559:       assert( eDest==SRT_Output || eDest==SRT_Coroutine );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1580: #endif",
          "1581: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "1582:     case SRT_Upfrom: {",
          "1583:       int i2 = pDest->iSDParm2;",
          "1584:       int r1 = sqlite3GetTempReg(pParse);",
          "1585:       sqlite3VdbeAddOp3(v, OP_MakeRecord,regRow+(i2<0),nColumn-(i2<0),r1);",
          "1586:       if( i2<0 ){",
          "1587:         sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regRow);",
          "1588:       }else{",
          "1589:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regRow, i2);",
          "1590:       }",
          "1591:       break;",
          "1592:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4969:   for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){",
          "4970:     Table *pTab;",
          "4971:     assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );",
          "4974: #ifndef SQLITE_OMIT_CTE",
          "4975:     if( withExpand(pWalker, pFrom) ) return WRC_Abort;",
          "4976:     if( pFrom->pTab ) {} else",
          "",
          "[Removed Lines]",
          "4972:     if( pFrom->fg.isRecursive ) continue;",
          "4973:     assert( pFrom->pTab==0 );",
          "",
          "[Added Lines]",
          "5008:     if( pFrom->pTab ) continue;",
          "5009:     assert( pFrom->fg.isRecursive==0 );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5792:   }",
          "5793: #endif",
          "5795:   if( pDest->eDest==SRT_Output ){",
          "5796:     generateColumnNames(pParse, p);",
          "5797:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5835:   if( p->selFlags & SF_UpdateFrom ){",
          "5836:     struct SrcList_item *p0 = &p->pSrc->a[0];",
          "5837:     for(i=1; i<p->pSrc->nSrc; i++){",
          "5838:       struct SrcList_item *p1 = &p->pSrc->a[i];",
          "5839:       if( p0->pTab==p1->pTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){",
          "5840:         sqlite3ErrorMsg(pParse,",
          "5841:             \"target object/alias may not appear in FROM clause: %s\",",
          "5842:             p0->zAlias ? p0->zAlias : p0->pTab->zName",
          "5843:         );",
          "5844:         goto select_end;",
          "5845:       }",
          "5846:     }",
          "5847:   }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4230: IdList *sqlite3IdListAppend(Parse*, IdList*, Token*);",
          "4231: int sqlite3IdListIndex(IdList*,const char*);",
          "4232: SrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int);",
          "4233: SrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*);",
          "4234: SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,",
          "4235:                                       Token*, Select*, Expr*, IdList*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4245: SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4399:   TriggerStep *sqlite3TriggerInsertStep(Parse*,Token*, IdList*,",
          "4400:                                         Select*,u8,Upsert*,",
          "4401:                                         const char*,const char*);",
          "4404:   TriggerStep *sqlite3TriggerDeleteStep(Parse*,Token*, Expr*,",
          "4405:                                         const char*,const char*);",
          "4406:   void sqlite3DeleteTrigger(sqlite3*, Trigger*);",
          "4407:   void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);",
          "4408:   u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);",
          "4409: # define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))",
          "4410: # define sqlite3IsToplevel(p) ((p)->pToplevel==0)",
          "4411: #else",
          "",
          "[Removed Lines]",
          "4402:   TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,ExprList*, Expr*, u8,",
          "4403:                                         const char*,const char*);",
          "",
          "[Added Lines]",
          "4415:   TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,SrcList*,ExprList*,",
          "4416:                                         Expr*, u8, const char*,const char*);",
          "4422:   SrcList *sqlite3TriggerStepSrc(Parse*, TriggerStep*);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4419: # define sqlite3ParseToplevel(p) p",
          "4420: # define sqlite3IsToplevel(p) 1",
          "4421: # define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0",
          "4422: #endif",
          "4424: int sqlite3JoinType(Parse*, Token*, Token*, Token*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4436: # define sqlite3TriggerStepSrc(A,B) 0",
          "",
          "---------------"
        ],
        "src/test_malloc.c||src/test_malloc.c": [
          "File: src/test_malloc.c -> src/test_malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:   return p;",
          "113: }",
          "",
          "[Removed Lines]",
          "125: static void faultsimFree(void *p){",
          "126:   memfault.m.xFree(p);",
          "127: }",
          "128: static int faultsimSize(void *p){",
          "129:   return memfault.m.xSize(p);",
          "130: }",
          "131: static int faultsimRoundup(int n){",
          "132:   return memfault.m.xRoundup(n);",
          "133: }",
          "134: static int faultsimInit(void *p){",
          "135:   return memfault.m.xInit(memfault.m.pAppData);",
          "136: }",
          "137: static void faultsimShutdown(void *p){",
          "138:   memfault.m.xShutdown(memfault.m.pAppData);",
          "139: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "206: static int faultsimInstall(int install){",
          "217:   int rc;",
          "219:   install = (install ? 1 : 0);",
          "",
          "[Removed Lines]",
          "207:   static struct sqlite3_mem_methods m = {",
          "216:   };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "227:     rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &memfault.m);",
          "228:     assert(memfault.m.xMalloc);",
          "229:     if( rc==SQLITE_OK ){",
          "230:       rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &m);",
          "231:     }",
          "232:     sqlite3_test_control(SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:       sqlite3_mem_methods m = memfault.m;",
          "195:       m.xMalloc = faultsimMalloc;",
          "196:       m.xRealloc = faultsimRealloc;",
          "",
          "---------------"
        ],
        "src/trigger.c||src/trigger.c": [
          "File: src/trigger.c -> src/trigger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:     sqlite3SelectDelete(db, pTmp->pSelect);",
          "27:     sqlite3IdListDelete(db, pTmp->pIdList);",
          "28:     sqlite3UpsertDelete(db, pTmp->pUpsert);",
          "29:     sqlite3DbFree(db, pTmp->zSpan);",
          "31:     sqlite3DbFree(db, pTmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29:     sqlite3SrcListDelete(db, pTmp->pFrom);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "486: TriggerStep *sqlite3TriggerUpdateStep(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "490:   SrcList *pFrom,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "500:     if( IN_RENAME_OBJECT ){",
          "501:       pTriggerStep->pExprList = pEList;",
          "502:       pTriggerStep->pWhere = pWhere;",
          "503:       pEList = 0;",
          "504:       pWhere = 0;",
          "505:     }else{",
          "506:       pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, EXPRDUP_REDUCE);",
          "507:       pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);",
          "508:     }",
          "509:     pTriggerStep->orconf = orconf;",
          "510:   }",
          "511:   sqlite3ExprListDelete(db, pEList);",
          "512:   sqlite3ExprDelete(db, pWhere);",
          "513:   return pTriggerStep;",
          "514: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "505:       pTriggerStep->pFrom = pFrom;",
          "508:       pFrom = 0;",
          "512:       pTriggerStep->pFrom = sqlite3SrcListDup(db, pFrom, EXPRDUP_REDUCE);",
          "518:   sqlite3SrcListDelete(db, pFrom);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "742: ){",
          "743:   sqlite3 *db = pParse->db;",
          "747:   pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);",
          "748:   if( pSrc ){",
          "757:     }",
          "758:   }",
          "759:   return pSrc;",
          "760: }",
          "",
          "[Removed Lines]",
          "739: static SrcList *targetSrcList(",
          "749:     assert( pSrc->nSrc>0 );",
          "750:     pSrc->a[pSrc->nSrc-1].zName = sqlite3DbStrDup(db, pStep->zTarget);",
          "751:     iDb = sqlite3SchemaToIndex(db, pStep->pTrig->pSchema);",
          "752:     if( iDb==0 || iDb>=2 ){",
          "753:       const char *zDb;",
          "754:       assert( iDb<db->nDb );",
          "755:       zDb = db->aDb[iDb].zDbSName;",
          "756:       pSrc->a[pSrc->nSrc-1].zDatabase =  sqlite3DbStrDup(db, zDb);",
          "",
          "[Added Lines]",
          "745: SrcList *sqlite3TriggerStepSrc(",
          "751:   char *zName = sqlite3DbStrDup(db, pStep->zTarget);",
          "753:   assert( pSrc==0 || pSrc->nSrc==1 );",
          "754:   assert( zName || pSrc==0 );",
          "756:     Schema *pSchema = pStep->pTrig->pSchema;",
          "757:     pSrc->a[0].zName = zName;",
          "758:     if( pSchema!=db->aDb[1].pSchema ){",
          "759:       pSrc->a[0].pSchema = pSchema;",
          "760:     }",
          "761:     if( pStep->pFrom ){",
          "762:       SrcList *pDup = sqlite3SrcListDup(db, pStep->pFrom, 0);",
          "763:       pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);",
          "765:   }else{",
          "766:     sqlite3DbFree(db, zName);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "803:     switch( pStep->op ){",
          "804:       case TK_UPDATE: {",
          "805:         sqlite3Update(pParse,",
          "807:           sqlite3ExprListDup(db, pStep->pExprList, 0),",
          "808:           sqlite3ExprDup(db, pStep->pWhere, 0),",
          "809:           pParse->eOrconf, 0, 0, 0",
          "",
          "[Removed Lines]",
          "806:           targetSrcList(pParse, pStep),",
          "",
          "[Added Lines]",
          "815:           sqlite3TriggerStepSrc(pParse, pStep),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "812:       }",
          "813:       case TK_INSERT: {",
          "814:         sqlite3Insert(pParse,",
          "816:           sqlite3SelectDup(db, pStep->pSelect, 0),",
          "817:           sqlite3IdListDup(db, pStep->pIdList),",
          "818:           pParse->eOrconf,",
          "",
          "[Removed Lines]",
          "815:           targetSrcList(pParse, pStep),",
          "",
          "[Added Lines]",
          "824:           sqlite3TriggerStepSrc(pParse, pStep),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "822:       }",
          "823:       case TK_DELETE: {",
          "824:         sqlite3DeleteFrom(pParse,",
          "826:           sqlite3ExprDup(db, pStep->pWhere, 0), 0, 0",
          "827:         );",
          "828:         break;",
          "",
          "[Removed Lines]",
          "825:           targetSrcList(pParse, pStep),",
          "",
          "[Added Lines]",
          "834:           sqlite3TriggerStepSrc(pParse, pStep),",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:                                             aXRef, chngRowid);",
          "131: }",
          "140: void sqlite3Update(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139: static Expr *exprRowColumn(Parse *pParse, int iCol){",
          "140:   Expr *pRet = sqlite3PExpr(pParse, TK_ROW, 0, 0);",
          "141:   if( pRet ) pRet->iColumn = iCol+1;",
          "142:   return pRet;",
          "143: }",
          "183: static void updateFromSelect(",
          "190:   ExprList *pOrderBy,",
          "191:   Expr *pLimit",
          "192: ){",
          "193:   int i;",
          "194:   SelectDest dest;",
          "195:   Select *pSelect = 0;",
          "196:   ExprList *pList = 0;",
          "197:   ExprList *pGrp = 0;",
          "198:   Expr *pLimit2 = 0;",
          "199:   ExprList *pOrderBy2 = 0;",
          "200:   sqlite3 *db = pParse->db;",
          "201:   Table *pTab = pTabList->a[0].pTab;",
          "202:   SrcList *pSrc;",
          "203:   Expr *pWhere2;",
          "204:   int eDest;",
          "206: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "207:   if( pOrderBy && pLimit==0 ) {",
          "208:     sqlite3ErrorMsg(pParse, \"ORDER BY without LIMIT on UPDATE\");",
          "209:     return;",
          "210:   }",
          "211:   pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);",
          "212:   pLimit2 = sqlite3ExprDup(db, pLimit, 0);",
          "213: #endif",
          "215:   pSrc = sqlite3SrcListDup(db, pTabList, 0);",
          "216:   pWhere2 = sqlite3ExprDup(db, pWhere, 0);",
          "218:   assert( pTabList->nSrc>1 );",
          "219:   if( pSrc ){",
          "220:     pSrc->a[0].iCursor = -1;",
          "221:     pSrc->a[0].pTab->nTabRef--;",
          "222:     pSrc->a[0].pTab = 0;",
          "223:   }",
          "224:   if( pPk ){",
          "225:     for(i=0; i<pPk->nKeyCol; i++){",
          "226:       Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);",
          "227: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "228:       if( pLimit ){",
          "229:         pGrp = sqlite3ExprListAppend(pParse, pGrp, sqlite3ExprDup(db, pNew, 0));",
          "230:       }",
          "231: #endif",
          "232:       pList = sqlite3ExprListAppend(pParse, pList, pNew);",
          "233:     }",
          "234:     eDest = SRT_Upfrom;",
          "235:   }else if( pTab->pSelect ){",
          "236:     for(i=0; i<pTab->nCol; i++){",
          "237:       pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));",
          "238:     }",
          "239:     eDest = SRT_Table;",
          "240:   }else{",
          "241:     eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;",
          "242:     pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));",
          "243: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "244:     if( pLimit ){",
          "245:       pGrp = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));",
          "246:     }",
          "247: #endif",
          "248:   }",
          "249:   if( ALWAYS(pChanges) ){",
          "250:     for(i=0; i<pChanges->nExpr; i++){",
          "251:       pList = sqlite3ExprListAppend(pParse, pList,",
          "252:           sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)",
          "253:       );",
          "254:     }",
          "255:   }",
          "256:   pSelect = sqlite3SelectNew(pParse, pList,",
          "257:       pSrc, pWhere2, pGrp, 0, pOrderBy2, SF_UpdateFrom|SF_IncludeHidden, pLimit2",
          "258:   );",
          "259:   sqlite3SelectDestInit(&dest, eDest, iEph);",
          "260:   dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);",
          "261:   sqlite3Select(pParse, pSelect, &dest);",
          "262:   sqlite3SelectDelete(db, pSelect);",
          "263: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:   if( pParse->nErr || db->mallocFailed ){",
          "208:     goto update_cleanup;",
          "209:   }",
          "",
          "[Removed Lines]",
          "210:   assert( pTabList->nSrc==1 );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232: # define isView 0",
          "233: #endif",
          "235: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "237:     pWhere = sqlite3LimitWhere(",
          "238:         pParse, pTabList, pWhere, pOrderBy, pLimit, \"UPDATE\"",
          "239:     );",
          "",
          "[Removed Lines]",
          "236:   if( !isView ){",
          "",
          "[Added Lines]",
          "374:   nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;",
          "375:   assert( nChangeFrom==0 || pUpsert==0 );",
          "378:   if( !isView && nChangeFrom==0 ){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "303:   chngRowid = chngPk = 0;",
          "304:   for(i=0; i<pChanges->nExpr; i++){",
          "306:       goto update_cleanup;",
          "307:     }",
          "308:     for(j=0; j<pTab->nCol; j++){",
          "",
          "[Removed Lines]",
          "305:     if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){",
          "",
          "[Added Lines]",
          "449:     if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "310:         if( j==pTab->iPKey ){",
          "311:           chngRowid = 1;",
          "312:           pRowidExpr = pChanges->a[i].pExpr;",
          "313:         }else if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){",
          "314:           chngPk = 1;",
          "315:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "457:           iRowidExpr = i;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "332:         j = -1;",
          "333:         chngRowid = 1;",
          "334:         pRowidExpr = pChanges->a[i].pExpr;",
          "335:       }else{",
          "336:         sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zEName);",
          "337:         pParse->checkSchema = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480:         iRowidExpr = i;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "463: #if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)",
          "465:     sqlite3MaterializeView(pParse, pTab,",
          "466:         pWhere, pOrderBy, pLimit, iDataCur",
          "467:     );",
          "",
          "[Removed Lines]",
          "464:   if( isView ){",
          "",
          "[Added Lines]",
          "610:   if( nChangeFrom==0 && isView ){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "477:     goto update_cleanup;",
          "478:   }",
          "",
          "[Removed Lines]",
          "476:   if( sqlite3ResolveExprNames(&sNC, pWhere) ){",
          "",
          "[Added Lines]",
          "622:   if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "500:     sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);",
          "501:   }",
          "504:     sqlite3VdbeAddOp3(v, OP_Null, 0, regRowSet, regOldRowid);",
          "505:   }else{",
          "508:     iPk = pParse->nMem+1;",
          "509:     pParse->nMem += nPk;",
          "510:     regKey = ++pParse->nMem;",
          "511:     if( pUpsert==0 ){",
          "512:       iEph = pParse->nTab++;",
          "516:     }",
          "517:   }",
          "529:   }else{",
          "562:         }",
          "564:       }",
          "565:     }",
          "593:     }else{",
          "597:     }",
          "598:   }",
          "600:   if( pUpsert==0 ){",
          "602:       sqlite3WhereEnd(pWInfo);",
          "603:     }",
          "",
          "[Removed Lines]",
          "503:   if( HasRowid(pTab) ){",
          "506:     assert( pPk!=0 );",
          "507:     nPk = pPk->nKeyCol;",
          "513:         sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);",
          "514:       addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nPk);",
          "515:       sqlite3VdbeSetP4KeyInfo(pParse, pPk);",
          "519:   if( pUpsert ){",
          "525:     pWInfo = 0;",
          "526:     eOnePass = ONEPASS_SINGLE;",
          "527:     sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);",
          "528:     bFinishSeek = 0;",
          "537:     flags = WHERE_ONEPASS_DESIRED|WHERE_SEEK_UNIQ_TABLE;",
          "538:     if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){",
          "539:       flags |= WHERE_ONEPASS_MULTIROW;",
          "540:     }",
          "541:     pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags, iIdxCur);",
          "542:     if( pWInfo==0 ) goto update_cleanup;",
          "554:     eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);",
          "555:     bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);",
          "556:     if( eOnePass!=ONEPASS_SINGLE ){",
          "557:       sqlite3MultiWrite(pParse);",
          "558:       if( eOnePass==ONEPASS_MULTI ){",
          "559:         int iCur = aiCurOnePass[1];",
          "560:         if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){",
          "561:           eOnePass = ONEPASS_OFF;",
          "563:         assert( iCur!=iDataCur || !HasRowid(pTab) );",
          "566:   }",
          "568:   if( HasRowid(pTab) ){",
          "572:     sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);",
          "573:     if( eOnePass==ONEPASS_OFF ){",
          "575:       aRegIdx[nAllIdx] = ++pParse->nMem;",
          "576:       sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);",
          "577:     }",
          "578:   }else{",
          "584:     for(i=0; i<nPk; i++){",
          "585:       assert( pPk->aiColumn[i]>=0 );",
          "586:       sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,",
          "587:                                       pPk->aiColumn[i], iPk+i);",
          "588:     }",
          "589:     if( eOnePass ){",
          "590:       if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);",
          "591:       nKey = nPk;",
          "592:       regKey = iPk;",
          "594:       sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,",
          "595:                         sqlite3IndexAffinityStr(db, pPk), nPk);",
          "596:       sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);",
          "601:     if( eOnePass!=ONEPASS_MULTI ){",
          "",
          "[Added Lines]",
          "649:   if( nChangeFrom==0 && HasRowid(pTab) ){",
          "652:     assert( pPk!=0 || HasRowid(pTab) );",
          "653:     nPk = pPk ? pPk->nKeyCol : 0;",
          "656:     pParse->nMem += nChangeFrom;",
          "659:       int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);",
          "661:       if( pPk ) sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);",
          "662:       addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);",
          "663:       if( pPk ){",
          "664:         KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);",
          "665:         if( pKeyInfo ){",
          "666:           pKeyInfo->nAllField = nEphCol;",
          "667:           sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);",
          "668:         }",
          "669:       }",
          "670:       if( nChangeFrom ){",
          "671:         updateFromSelect(",
          "672:             pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit",
          "673:         );",
          "674: #ifndef SQLITE_OMIT_SUBQUERY",
          "675:         if( isView ) iDataCur = iEph;",
          "676: #endif",
          "677:       }",
          "681:   if( nChangeFrom ){",
          "682:     sqlite3MultiWrite(pParse);",
          "683:     eOnePass = ONEPASS_OFF;",
          "684:     nKey = nPk;",
          "685:     regKey = iPk;",
          "687:     if( pUpsert ){",
          "693:       pWInfo = 0;",
          "694:       eOnePass = ONEPASS_SINGLE;",
          "695:       sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);",
          "696:       bFinishSeek = 0;",
          "697:     }else{",
          "705:       flags = WHERE_ONEPASS_DESIRED|WHERE_SEEK_UNIQ_TABLE;",
          "706:       if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){",
          "707:         flags |= WHERE_ONEPASS_MULTIROW;",
          "708:       }",
          "709:       pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags,iIdxCur);",
          "710:       if( pWInfo==0 ) goto update_cleanup;",
          "722:       eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);",
          "723:       bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);",
          "724:       if( eOnePass!=ONEPASS_SINGLE ){",
          "725:         sqlite3MultiWrite(pParse);",
          "726:         if( eOnePass==ONEPASS_MULTI ){",
          "727:           int iCur = aiCurOnePass[1];",
          "728:           if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){",
          "729:             eOnePass = ONEPASS_OFF;",
          "730:           }",
          "731:           assert( iCur!=iDataCur || !HasRowid(pTab) );",
          "736:     if( HasRowid(pTab) ){",
          "740:       sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);",
          "741:       if( eOnePass==ONEPASS_OFF ){",
          "743:         aRegIdx[nAllIdx] = ++pParse->nMem;",
          "744:         sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);",
          "745:       }",
          "752:       for(i=0; i<nPk; i++){",
          "753:         assert( pPk->aiColumn[i]>=0 );",
          "754:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,",
          "755:                                         pPk->aiColumn[i], iPk+i);",
          "756:       }",
          "757:       if( eOnePass ){",
          "758:         if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);",
          "759:         nKey = nPk;",
          "760:         regKey = iPk;",
          "761:       }else{",
          "762:         sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,",
          "763:                           sqlite3IndexAffinityStr(db, pPk), nPk);",
          "764:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);",
          "765:       }",
          "770:     if( nChangeFrom==0 && eOnePass!=ONEPASS_MULTI ){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "634:       sqlite3VdbeAddOp2(v, OP_IsNull, pPk ? regKey : regOldRowid, labelBreak);",
          "635:       VdbeCoverageIf(v, pPk==0);",
          "636:       VdbeCoverageIf(v, pPk!=0);",
          "638:       labelContinue = sqlite3VdbeMakeLabel(pParse);",
          "639:       sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);",
          "643:     }else{",
          "644:       labelContinue = sqlite3VdbeAddOp3(v, OP_RowSetRead, regRowSet,labelBreak,",
          "645:                                regOldRowid);",
          "",
          "[Removed Lines]",
          "637:     }else if( pPk ){",
          "640:       addrTop = sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);",
          "641:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey, 0);",
          "642:       VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "806:     }else if( pPk || nChangeFrom ){",
          "809:       addrTop = sqlite3VdbeCurrentAddr(v);",
          "810:       if( nChangeFrom ){",
          "811:         if( !isView ){",
          "812:           if( pPk ){",
          "813:             for(i=0; i<nPk; i++){",
          "814:               sqlite3VdbeAddOp3(v, OP_Column, iEph, i, iPk+i);",
          "815:             }",
          "816:             sqlite3VdbeAddOp4Int(",
          "817:                 v, OP_NotFound, iDataCur, labelContinue, iPk, nPk",
          "818:             ); VdbeCoverage(v);",
          "819:           }else{",
          "820:             sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);",
          "821:             sqlite3VdbeAddOp3(",
          "822:                 v, OP_NotExists, iDataCur, labelContinue, regOldRowid",
          "823:             ); VdbeCoverage(v);",
          "824:           }",
          "825:         }",
          "826:       }else{",
          "827:         sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);",
          "828:         sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey,0);",
          "829:         VdbeCoverage(v);",
          "830:       }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "656:   assert( chngKey || pTrigger || hasFK || regOldRowid==regNewRowid );",
          "657:   if( chngRowid ){",
          "659:     sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid); VdbeCoverage(v);",
          "660:   }",
          "",
          "[Removed Lines]",
          "658:     sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);",
          "",
          "[Added Lines]",
          "846:     assert( iRowidExpr>=0 );",
          "847:     if( nChangeFrom==0 ){",
          "848:       sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);",
          "849:     }else{",
          "850:       sqlite3VdbeAddOp3(v, OP_Column, iEph, iRowidExpr, regNewRowid);",
          "851:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "708:     }else{",
          "709:       j = aXRef[i];",
          "710:       if( j>=0 ){",
          "712:       }else if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i)) ){",
          "",
          "[Removed Lines]",
          "711:         sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);",
          "",
          "[Added Lines]",
          "904:         if( nChangeFrom ){",
          "905:           assert( eOnePass==ONEPASS_OFF );",
          "906:           int nOff = (isView ? pTab->nCol : nPk);",
          "907:           sqlite3VdbeAddOp3(v, OP_Column, iEph, nOff+j, k);",
          "908:         }else{",
          "909:           sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);",
          "910:         }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "740:     sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,",
          "741:         TRIGGER_BEFORE, pTab, regOldRowid, onError, labelContinue);",
          "771:       }",
          "773: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "779: #endif",
          "780:   }",
          "782:   if( !isView ){",
          "",
          "[Removed Lines]",
          "749:     if( pPk ){",
          "750:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue,regKey,nKey);",
          "751:       VdbeCoverage(v);",
          "752:     }else{",
          "753:       sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);",
          "754:       VdbeCoverage(v);",
          "755:     }",
          "766:     for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "767:       if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "768:         if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "769:       }else if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "770:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "772:     }",
          "774:     if( pTab->tabFlags & TF_HasGenerated ){",
          "775:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "776:       testcase( pTab->tabFlags & TF_HasStored );",
          "777:       sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "778:     }",
          "",
          "[Added Lines]",
          "942:     if( !isView ){",
          "949:       if( pPk ){",
          "950:         sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);",
          "951:         VdbeCoverage(v);",
          "952:       }else{",
          "953:         sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);",
          "954:         VdbeCoverage(v);",
          "955:       }",
          "966:       for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "967:         if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "968:           if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "969:         }else if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "970:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "971:         }",
          "974:       if( pTab->tabFlags & TF_HasGenerated ){",
          "975:         testcase( pTab->tabFlags & TF_HasVirtual );",
          "976:         testcase( pTab->tabFlags & TF_HasStored );",
          "977:         sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "978:       }",
          "980:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "879:   }else if( eOnePass==ONEPASS_MULTI ){",
          "880:     sqlite3VdbeResolveLabel(v, labelContinue);",
          "881:     sqlite3WhereEnd(pWInfo);",
          "883:     sqlite3VdbeResolveLabel(v, labelContinue);",
          "884:     sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);",
          "885:   }else{",
          "",
          "[Removed Lines]",
          "882:   }else if( pPk ){",
          "",
          "[Added Lines]",
          "1083:   }else if( pPk || nChangeFrom ){",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "982:   addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);",
          "983:   regArg = pParse->nMem + 1;",
          "984:   pParse->nMem += nArg;",
          "1004:     if( pRowid ){",
          "1006:     }else{",
          "1008:     }",
          "1009:   }else{",
          "1035: #if defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_NULL_TRIM)",
          "1039: #endif",
          "1042:   }",
          "1045:   if( eOnePass==ONEPASS_OFF ){",
          "1050:     addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "985:   regRec = ++pParse->nMem;",
          "986:   regRowid = ++pParse->nMem;",
          "989:   pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0,0,WHERE_ONEPASS_DESIRED,0);",
          "990:   if( pWInfo==0 ) return;",
          "993:   for(i=0; i<pTab->nCol; i++){",
          "994:     assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );",
          "995:     if( aXRef[i]>=0 ){",
          "996:       sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);",
          "997:     }else{",
          "998:       sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);",
          "1000:     }",
          "1001:   }",
          "1002:   if( HasRowid(pTab) ){",
          "1003:     sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);",
          "1005:       sqlite3ExprCode(pParse, pRowid, regArg+1);",
          "1007:       sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);",
          "1012:     pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1013:     assert( pPk!=0 );",
          "1014:     assert( pPk->nKeyCol==1 );",
          "1015:     iPk = pPk->aiColumn[0];",
          "1016:     sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);",
          "1017:     sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);",
          "1018:   }",
          "1020:   eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);",
          "1023:   assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );",
          "1025:   if( eOnePass ){",
          "1028:     sqlite3VdbeChangeToNoop(v, addr);",
          "1029:     sqlite3VdbeAddOp1(v, OP_Close, iCsr);",
          "1030:   }else{",
          "1033:     sqlite3MultiWrite(pParse);",
          "1034:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);",
          "1038:     sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);",
          "1040:     sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);",
          "1041:     sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);",
          "1047:     sqlite3WhereEnd(pWInfo);",
          "",
          "[Added Lines]",
          "1186:   if( pSrc->nSrc>1 ){",
          "1187:     Expr *pRow;",
          "1188:     ExprList *pList;",
          "1190:       pRow = sqlite3ExprDup(db, pRowid, 0);",
          "1192:       pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);",
          "1193:     }",
          "1194:     pList = sqlite3ExprListAppend(pParse, 0, pRow);",
          "1196:     for(i=0; i<pTab->nCol; i++){",
          "1197:       if( aXRef[i]>=0 ){",
          "1198:         pList = sqlite3ExprListAppend(pParse, pList,",
          "1199:           sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)",
          "1200:         );",
          "1201:       }else{",
          "1202:         pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));",
          "1203:       }",
          "1206:     updateFromSelect(pParse, ephemTab, 0, pList, pSrc, pWhere, 0, 0);",
          "1207:     sqlite3ExprListDelete(db, pList);",
          "1208:     eOnePass = ONEPASS_OFF;",
          "1210:     regRec = ++pParse->nMem;",
          "1211:     regRowid = ++pParse->nMem;",
          "1214:     pWInfo = sqlite3WhereBegin(pParse, pSrc,pWhere,0,0,WHERE_ONEPASS_DESIRED,0);",
          "1215:     if( pWInfo==0 ) return;",
          "1218:     for(i=0; i<pTab->nCol; i++){",
          "1219:       assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );",
          "1220:       if( aXRef[i]>=0 ){",
          "1221:         sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);",
          "1222:       }else{",
          "1223:         sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);",
          "1225:       }",
          "1226:     }",
          "1227:     if( HasRowid(pTab) ){",
          "1228:       sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);",
          "1229:       if( pRowid ){",
          "1230:         sqlite3ExprCode(pParse, pRowid, regArg+1);",
          "1231:       }else{",
          "1232:         sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);",
          "1233:       }",
          "1234:     }else{",
          "1237:       pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1238:       assert( pPk!=0 );",
          "1239:       assert( pPk->nKeyCol==1 );",
          "1240:       iPk = pPk->aiColumn[0];",
          "1241:       sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);",
          "1242:       sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);",
          "1243:     }",
          "1245:     eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);",
          "1248:     assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );",
          "1250:     if( eOnePass ){",
          "1253:       sqlite3VdbeChangeToNoop(v, addr);",
          "1254:       sqlite3VdbeAddOp1(v, OP_Close, iCsr);",
          "1255:     }else{",
          "1258:       sqlite3MultiWrite(pParse);",
          "1259:       sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);",
          "1263:       sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);",
          "1265:       sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);",
          "1266:       sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);",
          "1267:     }",
          "1273:     if( pSrc->nSrc==1 ){",
          "1274:       sqlite3WhereEnd(pWInfo);",
          "1275:     }",
          "",
          "---------------"
        ],
        "test/altertab3.test||test/altertab3.test": [
          "File: test/altertab3.test -> test/altertab3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "586:     DELETE FROM v2;",
          "587:   END}}",
          "589: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "589: #------------------------------------------------------------------------",
          "590: #",
          "591: reset_db",
          "592: do_execsql_test 25.1 {",
          "593:   CREATE TABLE t1(a, b, c);",
          "594:   CREATE TABLE t2(a, b, c);",
          "595:   CREATE TRIGGER ttt AFTER INSERT ON t1 BEGIN",
          "596:     UPDATE t1 SET a=t2.a FROM t2 WHERE t1.a=t2.a;",
          "597:   END;",
          "598: }",
          "599: #do_execsql_test 25.2 {",
          "600: #  ALTER TABLE t2 RENAME COLUMN a TO aaa;",
          "601: #}",
          "",
          "---------------"
        ],
        "test/fts4upfrom.test||test/fts4upfrom.test": [
          "File: test/fts4upfrom.test -> test/fts4upfrom.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 February 24",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #*************************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this script is testing UPDATE statements with FROM clauses",
          "13: # against FTS4 tables.",
          "14: #",
          "15: #",
          "17: set testdir [file dirname $argv0]",
          "18: source $testdir/tester.tcl",
          "19: set testprefix fts4upfrom",
          "21: # If SQLITE_ENABLE_FTS3 is defined, omit this file.",
          "22: ifcapable !fts3 {",
          "23:   finish_test",
          "24:   return",
          "25: }",
          "27: foreach {tn create_table} {",
          "28:   0 { CREATE VIRTUAL TABLE ft USING fts5(a, b, c) }",
          "29:   1 { CREATE VIRTUAL TABLE ft USING fts3(a, b, c) }",
          "30:   2 { CREATE TABLE ft(a, b, c) }",
          "31:   3 {",
          "32:     CREATE TABLE real(a, b, c);",
          "33:     CREATE INDEX i1 ON real(a);",
          "34:     CREATE VIEW ft AS SELECT rowid, a, b, c FROM real;",
          "35:     CREATE TRIGGER tr1 INSTEAD OF INSERT ON ft BEGIN",
          "36:       INSERT INTO real(rowid, a, b, c) VALUES(new.rowid, new.a, new.b, new.c);",
          "37:     END;",
          "38:     CREATE TRIGGER tr2 INSTEAD OF UPDATE ON ft BEGIN",
          "39:       UPDATE real SET rowid=new.rowid, a=new.a, b=new.b, c=new.c",
          "40:       WHERE rowid=old.rowid;",
          "41:     END;",
          "42:   }",
          "43: } {",
          "44:   if {$tn==0} { ifcapable !fts5 { continue } }",
          "45:   catchsql { DROP VIEW IF EXISTS changes }",
          "46:   catchsql { DROP TABLE IF EXISTS ft }",
          "47:   catchsql { DROP VIEW IF EXISTS ft }",
          "48:   execsql $create_table",
          "50:   do_execsql_test 1.$tn.0 {",
          "51:     INSERT INTO ft(a, b, c) VALUES('a', NULL, 'apple');",
          "52:     INSERT INTO ft(a, b, c) VALUES('b', NULL, 'banana');",
          "53:     INSERT INTO ft(a, b, c) VALUES('c', NULL, 'cherry');",
          "54:     INSERT INTO ft(a, b, c) VALUES('d', NULL, 'damson plum');",
          "55:   }",
          "57:   do_execsql_test 1.$tn.1 {",
          "58:     SELECT a, b, c FROM ft ORDER BY rowid;",
          "59:   } {",
          "60:     a {} apple",
          "61:     b {} banana",
          "62:     c {} cherry",
          "63:     d {} {damson plum}",
          "64:   }",
          "66:   do_execsql_test 1.$tn.2 {",
          "67:     UPDATE ft SET b=o.c FROM ft AS o WHERE (ft.a == char(unicode(o.a)+1))",
          "68:   }",
          "70:   do_execsql_test 1.$tn.3 {",
          "71:     SELECT a, b, c FROM ft ORDER BY rowid;",
          "72:   } {",
          "73:     a {} apple",
          "74:     b apple banana",
          "75:     c banana cherry",
          "76:     d cherry {damson plum}",
          "77:   }",
          "79:   do_catchsql_test 1.$tn.4 {",
          "80:     UPDATE ft SET c=v FROM changes WHERE a=k;",
          "81:   } {1 {no such table: changes}}",
          "83:   do_execsql_test 1.$tn.5 {",
          "84:     create view changes(k, v) AS",
          "85:       VALUES( 'd', 'dewberry' ) UNION ALL",
          "86:       VALUES( 'c', 'clementine' ) UNION ALL",
          "87:       VALUES( 'b', 'blueberry' ) UNION ALL",
          "88:       VALUES( 'a', 'apricot' )",
          "89:     ;",
          "90:   }",
          "92:   do_execsql_test 1.$tn.6 {",
          "93:     UPDATE ft SET c=v FROM changes WHERE a=k;",
          "94:   }",
          "96:   do_execsql_test 1.$tn.7 {",
          "97:     SELECT rowid, a, b, c FROM ft ORDER BY rowid;",
          "98:   } {",
          "99:     1 a {} apricot",
          "100:     2 b apple blueberry",
          "101:     3 c banana clementine",
          "102:     4 d cherry dewberry",
          "103:   }",
          "105:   do_execsql_test 1.$tn.8 \"",
          "106:     WITH x1(o, n) AS (",
          "107:         VALUES(1, 11) UNION ALL",
          "108:         VALUES(2, 12) UNION ALL",
          "109:         VALUES(3, 13) UNION ALL",
          "110:         VALUES(4, 14)",
          "111:     )",
          "112:     SELECT ft.rowid, a, b, c, o, n FROM ft, x1 WHERE ft.rowid = o;",
          "113:   \" {",
          "114:     1 a {} apricot 1 11",
          "115:     2 b apple blueberry 2 12",
          "116:     3 c banana clementine 3 13",
          "117:     4 d cherry dewberry 4 14",
          "118:   }",
          "120:   set ROWID rowid",
          "121:   if {$tn==1} { set ROWID docid }",
          "122:   do_execsql_test 1.$tn.9 \"",
          "123:     WITH x1(o, n) AS (",
          "124:         VALUES(1, 11) UNION ALL",
          "125:         VALUES(2, 12) UNION ALL",
          "126:         VALUES(3, 13) UNION ALL",
          "127:         VALUES(4, 14)",
          "128:     )",
          "129:     UPDATE ft SET $ROWID = n FROM x1 WHERE ft.rowid = o;",
          "130:     SELECT rowid, a, b, c FROM ft ORDER BY rowid;",
          "131:   \" {",
          "132:     11 a {} apricot",
          "133:     12 b apple blueberry",
          "134:     13 c banana clementine",
          "135:     14 d cherry dewberry",
          "136:   }",
          "137: }",
          "139: finish_test",
          "",
          "---------------"
        ],
        "test/pg_common.tcl||test/pg_common.tcl": [
          "File: test/pg_common.tcl -> test/pg_common.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: proc execsql {sql} {",
          "21:   set lSql [list]",
          "22:   set frag \"\"",
          "23:   while {[string length $sql]>0} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21:   set sql [string map {{WITHOUT ROWID} {}} $sql]",
          "",
          "---------------"
        ],
        "test/tester.tcl||test/tester.tcl": [
          "File: test/tester.tcl -> test/tester.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:         set ::dbhandle [lindex $args 0]",
          "130:         uplevel #0 $::G(perm:dbconfig)",
          "131:       }",
          "132:       set res",
          "133:     } else {",
          "134:       # This command is not opening a new database connection. Pass the",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:       [lindex $args 0] cache size 3",
          "",
          "---------------"
        ],
        "test/triggerupfrom.test||test/triggerupfrom.test": [
          "File: test/triggerupfrom.test -> test/triggerupfrom.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 July 14",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix triggerupfrom",
          "17: do_execsql_test 1.0 {",
          "18:   CREATE TABLE map(k, v);",
          "19:   INSERT INTO map VALUES(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four');",
          "21:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "23:   CREATE TRIGGER tr AFTER INSERT ON t1 BEGIN",
          "24:     UPDATE t1 SET c = v FROM map WHERE k=new.a AND a=new.a;",
          "25:   END;",
          "26: }",
          "28: do_execsql_test 1.1 {",
          "29:   INSERT INTO t1(a) VALUES(1);",
          "30: }",
          "32: do_execsql_test 1.2 {",
          "33:   SELECT a, c FROM t1 ORDER BY a;",
          "34: } {1 one}",
          "36: do_execsql_test 1.3 {",
          "37:   INSERT INTO t1(a) VALUES(2), (3), (4), (5);",
          "38:   SELECT a, c FROM t1 ORDER BY a;",
          "39: } {1 one 2 two 3 three 4 four 5 {}}",
          "41: forcedelete test.db2",
          "42: do_execsql_test 2.0 {",
          "43:   ATTACH 'test.db2' AS aux;",
          "44:   CREATE TABLE aux.t3(x, y);",
          "45:   INSERT INTO aux.t3 VALUES('x', 'y');",
          "46: }",
          "48: do_catchsql_test 2.1 {",
          "49:   CREATE TRIGGER tr2 AFTER INSERT ON t1 BEGIN",
          "50:     UPDATE t1 SET b = y FROM aux.t3 WHERE k=new.a;",
          "51:   END;",
          "52: } {1 {trigger tr2 cannot reference objects in database aux}}",
          "54: do_execsql_test 2.2 {",
          "55:   CREATE TEMP TRIGGER tr2 AFTER INSERT ON t1 BEGIN",
          "56:     UPDATE t1 SET b = y FROM aux.t3 WHERE a=new.a;",
          "57:   END;",
          "58:   INSERT INTO t1(a) VALUES(10), (20);",
          "59:   SELECT * FROM t1;",
          "60: } {",
          "61:   1 {} one",
          "62:   2 {} two",
          "63:   3 {} three",
          "64:   4 {} four",
          "65:   5 {} {}",
          "66:   10 y {}",
          "67:   20 y {}",
          "68: }",
          "70: do_execsql_test 2.3 {",
          "71:   CREATE TABLE link(f, t);",
          "72:   INSERT INTO link VALUES(5, 2), (20, 10), (2, 1);",
          "73:   CREATE TRIGGER tr3 BEFORE DELETE ON t1 BEGIN",
          "74:     UPDATE t1 SET b=coalesce(old.b,old.c) FROM main.link WHERE a=t AND old.a=f;",
          "75:   END;",
          "76:   DELETE FROM t1 WHERE a=2;",
          "77:   SELECT * FROM t1;",
          "78: } {",
          "79:   1 two one",
          "80:   3 {} three",
          "81:   4 {} four",
          "82:   5 {} {}",
          "83:   10 y {}",
          "84:   20 y {}",
          "85: }",
          "87: db close",
          "88: sqlite3 db \"\"",
          "89: do_catchsql_test 2.4 {",
          "90:   ATTACH 'test.db' AS yyy;",
          "91:   SELECT * FROM t1;",
          "92: } {1 {malformed database schema (tr3) - trigger tr3 cannot reference objects in database main}}",
          "94: #-------------------------------------------------------------------------",
          "95: reset_db",
          "96: forcedelete test.db2",
          "97: do_execsql_test 3.0 {",
          "98:   CREATE TABLE mmm(x, y);",
          "99:   INSERT INTO mmm VALUES(1, 'one');",
          "100:   INSERT INTO mmm VALUES(2, 'two');",
          "101:   INSERT INTO mmm VALUES(3, 'three');",
          "103:   ATTACH 'test.db2' AS aux;",
          "104:   CREATE TABLE aux.t1(a, b);",
          "105:   CREATE TABLE aux.mmm(x, y);",
          "106:   INSERT INTO aux.mmm VALUES(1, 'ONE');",
          "107:   INSERT INTO aux.mmm VALUES(2, 'TWO');",
          "108:   INSERT INTO aux.mmm VALUES(3, 'THREE');",
          "110:   CREATE TRIGGER aux.ttt AFTER INSERT ON t1 BEGIN",
          "111:     UPDATE t1 SET b=y FROM mmm WHERE x=new.a AND a=new.a;",
          "112:   END;",
          "114:   INSERT INTO t1(a) VALUES (2);",
          "115:   SELECT * FROM t1;",
          "116: } {2 TWO}",
          "118: #-------------------------------------------------------------------------",
          "119: # Test that INSTEAD OF UPDATE triggers on views work with UPDATE...FROM",
          "120: # statements. Including, if the library is built with ENABLE_HIDDEN_COLUMNS,",
          "121: # that they work correctly on views with hidden columns.",
          "122: #",
          "123: reset_db",
          "124: do_execsql_test 4.0 {",
          "125:   CREATE TABLE t1(k, a, b);",
          "126:   INSERT INTO t1 VALUES('a', 1, 'one');",
          "127:   INSERT INTO t1 VALUES('b', 2, 'two');",
          "128:   INSERT INTO t1 VALUES('c', 3, 'three');",
          "129:   INSERT INTO t1 VALUES('d', 4, 'four');",
          "131:   CREATE TABLE log(x);",
          "132:   CREATE VIEW v1 AS SELECT k, a, b AS __hidden__b FROM t1;",
          "133:   CREATE TRIGGER tr1 INSTEAD OF UPDATE ON v1 BEGIN",
          "134:     INSERT INTO log VALUES(",
          "135:       '('||old.a||','||old.__hidden__b||')->('||new.a||','||new.__hidden__b||')'",
          "136:     );",
          "137:   END;",
          "138: }",
          "140: ifcapable hiddencolumns {",
          "141:   do_execsql_test 4.1-hc-enabled {",
          "142:     SELECT * FROM v1",
          "143:   } {a 1 b 2 c 3 d 4}",
          "144: } else {",
          "145:   do_execsql_test 4.1-hc-disabled {",
          "146:     SELECT * FROM v1",
          "147:   } {a 1 one b 2 two c 3 three d 4 four}",
          "148: }",
          "150: do_execsql_test 4.2 {",
          "151:   UPDATE v1 SET a='xyz' WHERE k IN ('a', 'c');",
          "152:   SELECT * FROM log;",
          "153:   DELETE FROM log;",
          "154: } {",
          "155:   (1,one)->(xyz,one)",
          "156:   (3,three)->(xyz,three)",
          "157: }",
          "159: do_execsql_test 4.3 {",
          "160:   CREATE TABLE map(k, v);",
          "161:   INSERT INTO map VALUES('b', 'twelve');",
          "162:   INSERT INTO map VALUES('d', 'fourteen');",
          "163:   UPDATE v1 SET a=map.v FROM map WHERE v1.k=map.k;",
          "164:   SELECT * FROM log;",
          "165:   DELETE FROM log;",
          "166: } {",
          "167:   (2,two)->(twelve,two)",
          "168:   (4,four)->(fourteen,four)",
          "169: }",
          "173: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom1.tcl||test/upfrom1.tcl": [
          "File: test/upfrom1.tcl -> test/upfrom1.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 22",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: source [file join [file dirname $argv0] pg_common.tcl]",
          "15: #=========================================================================",
          "17: start_test upfrom1 \"2020 April 22\"",
          "19: foreach {tn wo} {",
          "20:   1 \"WITHOUT ROWID\"",
          "21:   2 \"\"",
          "22: } {",
          "23: eval [string map [list %TN% $tn %WITHOUT_ROWID% $wo] {",
          "24: execsql_test 1.%TN%.0 {",
          "25:   DROP TABLE IF EXISTS t2;",
          "26:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) %WITHOUT_ROWID%;",
          "27:   INSERT INTO t2 VALUES(1, 2, 3);",
          "28:   INSERT INTO t2 VALUES(4, 5, 6);",
          "29:   INSERT INTO t2 VALUES(7, 8, 9);",
          "31:   DROP TABLE IF EXISTS chng;",
          "32:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "33:   INSERT INTO chng VALUES(1, 100, 1000);",
          "34:   INSERT INTO chng VALUES(7, 700, 7000);",
          "35: }",
          "37: execsql_test 1.%TN%.1 {",
          "38:   SELECT * FROM t2;",
          "39: }",
          "41: execsql_test 1.%TN%.2 {",
          "42:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "43:   SELECT * FROM t2 ORDER BY a;",
          "44: }",
          "46: execsql_test 1.%TN%.3 {",
          "47:   DELETE FROM t2;",
          "48:   INSERT INTO t2 VALUES(1, 2, 3);",
          "49:   INSERT INTO t2 VALUES(4, 5, 6);",
          "50:   INSERT INTO t2 VALUES(7, 8, 9);",
          "51: }",
          "53: execsql_test 1.%TN%.4 {",
          "54:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "55:     WHERE a IN (SELECT a FROM chng);",
          "56:   SELECT * FROM t2 ORDER BY a;",
          "57: }",
          "59: execsql_test 1.%TN%.5 {",
          "60:   DROP TABLE IF EXISTS t3;",
          "61:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) %WITHOUT_ROWID%;",
          "62:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "63:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "64:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "66:   DROP TABLE IF EXISTS t4;",
          "67:   CREATE TABLE t4(x TEXT);",
          "68:   INSERT INTO t4 VALUES('five');",
          "70:   SELECT * FROM t3 ORDER BY a;",
          "71: }",
          "73: execsql_test 1.%TN%.6 {",
          "74:   UPDATE t3 SET c=x FROM t4;",
          "75:   SELECT * FROM t3 ORDER BY a;",
          "76: }",
          "77: }]}",
          "79: execsql_test 2.1 {",
          "80:   DROP TABLE IF EXISTS t5;",
          "81:   DROP TABLE IF EXISTS m1;",
          "82:   DROP TABLE IF EXISTS m2;",
          "83:   CREATE TABLE t5(a INTEGER PRIMARY KEY, b TEXT, c TEXT);",
          "84:   CREATE TABLE m1(x INTEGER PRIMARY KEY, y TEXT);",
          "85:   CREATE TABLE m2(u INTEGER PRIMARY KEY, v TEXT);",
          "87:   INSERT INTO t5 VALUES(1, 'one', 'ONE');",
          "88:   INSERT INTO t5 VALUES(2, 'two', 'TWO');",
          "89:   INSERT INTO t5 VALUES(3, 'three', 'THREE');",
          "90:   INSERT INTO t5 VALUES(4, 'four', 'FOUR');",
          "92:   INSERT INTO m1 VALUES(1, 'i');",
          "93:   INSERT INTO m1 VALUES(2, 'ii');",
          "94:   INSERT INTO m1 VALUES(3, 'iii');",
          "96:   INSERT INTO m2 VALUES(1, 'I');",
          "97:   INSERT INTO m2 VALUES(3, 'II');",
          "98:   INSERT INTO m2 VALUES(4, 'III');",
          "99: }",
          "101: execsql_test 2.2 {",
          "102:   UPDATE t5 SET b=y, c=v FROM m1 LEFT JOIN m2 ON (x=u) WHERE x=a;",
          "103:   SELECT * FROM t5 ORDER BY a;",
          "104: }",
          "106: errorsql_test 2.3.1 {",
          "107:   UPDATE t5 SET b=1 FROM t5;",
          "108: }",
          "109: errorsql_test 2.3.2 {",
          "110:   UPDATE t5 AS apples SET b=1 FROM t5 AS apples;",
          "111: }",
          "114: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom1.test||test/upfrom1.test": [
          "File: test/upfrom1.test -> test/upfrom1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 22",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.",
          "12: #",
          "14: ####################################################",
          "15: # DO NOT EDIT! THIS FILE IS AUTOMATICALLY GENERATED!",
          "16: ####################################################",
          "18: set testdir [file dirname $argv0]",
          "19: source $testdir/tester.tcl",
          "20: set testprefix upfrom1",
          "22: do_execsql_test 1.1.0 {",
          "23:   DROP TABLE IF EXISTS t2;",
          "24:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) WITHOUT ROWID;",
          "25:   INSERT INTO t2 VALUES(1, 2, 3);",
          "26:   INSERT INTO t2 VALUES(4, 5, 6);",
          "27:   INSERT INTO t2 VALUES(7, 8, 9);",
          "29:   DROP TABLE IF EXISTS chng;",
          "30:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "31:   INSERT INTO chng VALUES(1, 100, 1000);",
          "32:   INSERT INTO chng VALUES(7, 700, 7000);",
          "33: } {}",
          "35: do_execsql_test 1.1.1 {",
          "36:   SELECT * FROM t2;",
          "37: } {1 2 3   4 5 6   7 8 9}",
          "39: do_execsql_test 1.1.2 {",
          "40:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "41:   SELECT * FROM t2 ORDER BY a;",
          "42: } {1 100 1000   4 5 6   7 700 7000}",
          "44: do_execsql_test 1.1.3 {",
          "45:   DELETE FROM t2;",
          "46:   INSERT INTO t2 VALUES(1, 2, 3);",
          "47:   INSERT INTO t2 VALUES(4, 5, 6);",
          "48:   INSERT INTO t2 VALUES(7, 8, 9);",
          "49: } {}",
          "51: do_execsql_test 1.1.4 {",
          "52:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "53:     WHERE a IN (SELECT a FROM chng);",
          "54:   SELECT * FROM t2 ORDER BY a;",
          "55: } {1 100 1000   4 5 6   7 700 7000}",
          "57: do_execsql_test 1.1.5 {",
          "58:   DROP TABLE IF EXISTS t3;",
          "59:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) WITHOUT ROWID;",
          "60:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "61:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "62:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "64:   DROP TABLE IF EXISTS t4;",
          "65:   CREATE TABLE t4(x TEXT);",
          "66:   INSERT INTO t4 VALUES('five');",
          "68:   SELECT * FROM t3 ORDER BY a;",
          "69: } {1 1 one   2 2 two   3 3 three}",
          "71: do_execsql_test 1.1.6 {",
          "72:   UPDATE t3 SET c=x FROM t4;",
          "73:   SELECT * FROM t3 ORDER BY a;",
          "74: } {1 1 five   2 2 five   3 3 five}",
          "76: do_execsql_test 1.2.0 {",
          "77:   DROP TABLE IF EXISTS t2;",
          "78:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) ;",
          "79:   INSERT INTO t2 VALUES(1, 2, 3);",
          "80:   INSERT INTO t2 VALUES(4, 5, 6);",
          "81:   INSERT INTO t2 VALUES(7, 8, 9);",
          "83:   DROP TABLE IF EXISTS chng;",
          "84:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "85:   INSERT INTO chng VALUES(1, 100, 1000);",
          "86:   INSERT INTO chng VALUES(7, 700, 7000);",
          "87: } {}",
          "89: do_execsql_test 1.2.1 {",
          "90:   SELECT * FROM t2;",
          "91: } {1 2 3   4 5 6   7 8 9}",
          "93: do_execsql_test 1.2.2 {",
          "94:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "95:   SELECT * FROM t2 ORDER BY a;",
          "96: } {1 100 1000   4 5 6   7 700 7000}",
          "98: do_execsql_test 1.2.3 {",
          "99:   DELETE FROM t2;",
          "100:   INSERT INTO t2 VALUES(1, 2, 3);",
          "101:   INSERT INTO t2 VALUES(4, 5, 6);",
          "102:   INSERT INTO t2 VALUES(7, 8, 9);",
          "103: } {}",
          "105: do_execsql_test 1.2.4 {",
          "106:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "107:     WHERE a IN (SELECT a FROM chng);",
          "108:   SELECT * FROM t2 ORDER BY a;",
          "109: } {1 100 1000   4 5 6   7 700 7000}",
          "111: do_execsql_test 1.2.5 {",
          "112:   DROP TABLE IF EXISTS t3;",
          "113:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) ;",
          "114:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "115:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "116:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "118:   DROP TABLE IF EXISTS t4;",
          "119:   CREATE TABLE t4(x TEXT);",
          "120:   INSERT INTO t4 VALUES('five');",
          "122:   SELECT * FROM t3 ORDER BY a;",
          "123: } {1 1 one   2 2 two   3 3 three}",
          "125: do_execsql_test 1.2.6 {",
          "126:   UPDATE t3 SET c=x FROM t4;",
          "127:   SELECT * FROM t3 ORDER BY a;",
          "128: } {1 1 five   2 2 five   3 3 five}",
          "130: do_execsql_test 2.1 {",
          "131:   DROP TABLE IF EXISTS t5;",
          "132:   DROP TABLE IF EXISTS m1;",
          "133:   DROP TABLE IF EXISTS m2;",
          "134:   CREATE TABLE t5(a INTEGER PRIMARY KEY, b TEXT, c TEXT);",
          "135:   CREATE TABLE m1(x INTEGER PRIMARY KEY, y TEXT);",
          "136:   CREATE TABLE m2(u INTEGER PRIMARY KEY, v TEXT);",
          "138:   INSERT INTO t5 VALUES(1, 'one', 'ONE');",
          "139:   INSERT INTO t5 VALUES(2, 'two', 'TWO');",
          "140:   INSERT INTO t5 VALUES(3, 'three', 'THREE');",
          "141:   INSERT INTO t5 VALUES(4, 'four', 'FOUR');",
          "143:   INSERT INTO m1 VALUES(1, 'i');",
          "144:   INSERT INTO m1 VALUES(2, 'ii');",
          "145:   INSERT INTO m1 VALUES(3, 'iii');",
          "147:   INSERT INTO m2 VALUES(1, 'I');",
          "148:   INSERT INTO m2 VALUES(3, 'II');",
          "149:   INSERT INTO m2 VALUES(4, 'III');",
          "150: } {}",
          "152: do_execsql_test 2.2 {",
          "153:   UPDATE t5 SET b=y, c=v FROM m1 LEFT JOIN m2 ON (x=u) WHERE x=a;",
          "154:   SELECT * FROM t5 ORDER BY a;",
          "155: } {1 i I   2 ii {}   3 iii II   4 four FOUR}",
          "157: # PG says ERROR:  table name \"t5\" specified more than once",
          "158: do_test 2.3.1 { catch { execsql {",
          "159:   UPDATE t5 SET b=1 FROM t5;",
          "160: } } } 1",
          "162: # PG says ERROR:  table name \"apples\" specified more than once",
          "163: do_test 2.3.2 { catch { execsql {",
          "164:   UPDATE t5 AS apples SET b=1 FROM t5 AS apples;",
          "165: } } } 1",
          "167: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom2.test||test/upfrom2.test": [
          "File: test/upfrom2.test -> test/upfrom2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 29",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix upfrom2",
          "17: # Test cases:",
          "18: #",
          "19: #   1.*: Test that triggers are fired correctly for UPDATE FROM statements,",
          "20: #        and only once for each row. Except for INSTEAD OF triggers on",
          "21: #        views - these are fired once for each row returned by the join,",
          "22: #        including duplicates.",
          "23: #",
          "24: #   2.*: Test adding ORDER BY and LIMIT clauses with UPDATE FROM statements.",
          "25: #",
          "26: #   5.*: Test that specifying the target table name or alias in the FROM",
          "27: #        clause of an UPDATE statement is an error.",
          "28: #",
          "30: foreach {tn wo} {",
          "31:   1 \"\"",
          "32:   2 \"WITHOUT ROWID\"",
          "33: } {",
          "34:   reset_db",
          "36:   eval [string map [list %WO% $wo %TN% $tn] {",
          "37:   do_execsql_test 1.%TN%.0 {",
          "38:     CREATE TABLE log(t TEXT);",
          "39:     CREATE TABLE t1(x PRIMARY KEY, y, z UNIQUE) %WO%;",
          "40:     CREATE INDEX t1y ON t1(y);",
          "42:     INSERT INTO t1 VALUES(1, 'i',   'one');",
          "43:     INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "44:     INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "45:     INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "47:     CREATE TRIGGER tr1 BEFORE UPDATE ON t1 BEGIN",
          "48:       INSERT INTO log VALUES(old.z || '->' || new.z);",
          "49:     END;",
          "50:     CREATE TRIGGER tr2 AFTER UPDATE ON t1 BEGIN",
          "51:       INSERT INTO log VALUES(old.y || '->' || new.y);",
          "52:     END;",
          "53:   }",
          "55:   do_execsql_test 1.%TN%.1 {",
          "56:     WITH data(k, v) AS (",
          "57:       VALUES(3, 'thirty'), (1, 'ten')",
          "58:     )",
          "59:     UPDATE t1 SET z=v FROM data WHERE x=k;",
          "61:     SELECT * FROM t1;",
          "62:     SELECT * FROM log;",
          "63:   } {",
          "64:     1 i ten   2 ii two   3 iii thirty   4 iv four",
          "65:     one->ten        i->i",
          "66:     three->thirty   iii->iii",
          "67:   }",
          "69:   do_execsql_test 1.%TN%.2 {",
          "70:     CREATE TABLE t2(a, b);",
          "71:     CREATE TABLE t3(k, v);",
          "73:     INSERT INTO t3 VALUES(5,   'v');",
          "74:     INSERT INTO t3 VALUES(12, 'xii');",
          "76:     INSERT INTO t2 VALUES(2, 12);",
          "77:     INSERT INTO t2 VALUES(3, 5);",
          "79:     DELETE FROM log;",
          "80:     UPDATE t1 SET y=v FROM t2, t3 WHERE t1.x=t2.a AND t3.k=t2.b;",
          "82:     SELECT * FROM t1;",
          "83:     SELECT * FROM log;",
          "84:   } {",
          "85:     1 i ten   2 xii two   3 v thirty   4 iv four",
          "86:     two->two         ii->xii",
          "87:     thirty->thirty   iii->v",
          "88:   }",
          "90:   do_execsql_test 1.%TN%.3 {",
          "91:     DELETE FROM log;",
          "92:     WITH data(k, v) AS (",
          "93:       VALUES(1, 'seven'), (1, 'eight'), (2, 'eleven'), (2, 'twelve')",
          "94:     )",
          "95:     UPDATE t1 SET z=v FROM data WHERE x=k;",
          "97:     SELECT * FROM t1;",
          "98:     SELECT * FROM log;",
          "99:   } {",
          "100:     1 i eight   2 xii twelve   3 v thirty   4 iv four",
          "101:     ten->eight        i->i",
          "102:     two->twelve       xii->xii",
          "103:   }",
          "105:   do_test 1.%TN%.4 { db changes } {2}",
          "107:   do_execsql_test 1.%TN%.5 {",
          "108:     CREATE VIEW v1 AS SELECT * FROM t1;",
          "109:     CREATE TRIGGER v1tr INSTEAD OF UPDATE ON v1 BEGIN",
          "110:       UPDATE t1 SET y=new.y, z=new.z WHERE x=new.x;",
          "111:     END;",
          "113:     DELETE FROM log;",
          "114:     WITH data(k, v) AS (",
          "115:       VALUES(3, 'thirteen'), (3, 'fourteen'), (4, 'fifteen'), (4, 'sixteen')",
          "116:     )",
          "117:     UPDATE v1 SET z=v FROM data WHERE x=k;",
          "118:   }",
          "120:   do_execsql_test 1.%TN%.6 {",
          "121:     SELECT * FROM v1;",
          "122:     SELECT * FROM log;",
          "123:   } {",
          "124:     1 i eight   2 xii twelve   3 v fourteen   4 iv sixteen",
          "125:     thirty->thirteen  v->v",
          "126:     thirteen->fourteen  v->v",
          "127:     four->fifteen  iv->iv",
          "128:     fifteen->sixteen  iv->iv",
          "129:   }",
          "131:   #--------------------------------------------------------------",
          "133:   do_execsql_test 1.%TN%.7 {",
          "134:     CREATE TABLE o1(w, x, y, z UNIQUE, PRIMARY KEY(w, x)) %WO%;",
          "135:     CREATE INDEX o1y ON t1(y);",
          "137:     INSERT INTO o1 VALUES(0, 0, 'i', 'one');",
          "138:     INSERT INTO o1 VALUES(0, 1, 'ii', 'two');",
          "139:     INSERT INTO o1 VALUES(1, 0, 'iii', 'three');",
          "140:     INSERT INTO o1 VALUES(1, 1, 'iv', 'four');",
          "142:     CREATE TRIGGER tro1 BEFORE UPDATE ON o1 BEGIN",
          "143:       INSERT INTO log VALUES(old.z || '->' || new.z);",
          "144:     END;",
          "145:     CREATE TRIGGER tro2 AFTER UPDATE ON o1 BEGIN",
          "146:       INSERT INTO log VALUES(old.y || '->' || new.y);",
          "147:     END;",
          "148:   }",
          "150:   do_execsql_test 1.%TN%.8 {",
          "151:     DELETE FROM log;",
          "152:     WITH data(k, v) AS (",
          "153:       VALUES(3, 'thirty'), (1, 'ten')",
          "154:     )",
          "155:     UPDATE o1 SET z=v FROM data WHERE (1+x+w*2)=k;",
          "157:     SELECT * FROM o1;",
          "158:     SELECT * FROM log;",
          "159:   } {",
          "160:     0 0 i ten   0 1 ii two   1 0 iii thirty   1 1 iv four",
          "161:     one->ten        i->i",
          "162:     three->thirty   iii->iii",
          "163:   }",
          "165:   do_execsql_test 1.%TN%.9 {",
          "166:     DELETE FROM log;",
          "167:     UPDATE o1 SET y=v FROM t2, t3 WHERE (1+o1.w*2+o1.x)=t2.a AND t3.k=t2.b;",
          "169:     SELECT * FROM o1;",
          "170:     SELECT * FROM log;",
          "171:   } {",
          "172:     0 0 i ten   0 1 xii two   1 0 v thirty   1 1 iv four",
          "173:     two->two         ii->xii",
          "174:     thirty->thirty   iii->v",
          "175:   }",
          "177:   do_execsql_test 1.%TN%.10 {",
          "178:     DELETE FROM log;",
          "179:     WITH data(k, v) AS (",
          "180:       VALUES(1, 'seven'), (1, 'eight'), (2, 'eleven'), (2, 'twelve')",
          "181:     )",
          "182:     UPDATE o1 SET z=v FROM data WHERE (1+w*2+x)=k;",
          "184:     SELECT * FROM o1;",
          "185:     SELECT * FROM log;",
          "186:   } {",
          "187:     0 0 i eight   0 1 xii twelve   1 0 v thirty   1 1 iv four",
          "188:     ten->eight        i->i",
          "189:     two->twelve       xii->xii",
          "190:   }",
          "192:   do_test 1.%TN%.11 { db changes } {2}",
          "194:   do_execsql_test 1.%TN%.12 {",
          "195:     CREATE VIEW w1 AS SELECT * FROM o1;",
          "196:     CREATE TRIGGER w1tr INSTEAD OF UPDATE ON w1 BEGIN",
          "197:       UPDATE o1 SET y=new.y, z=new.z WHERE w=new.w AND x=new.x;",
          "198:     END;",
          "200:     DELETE FROM log;",
          "201:     WITH data(k, v) AS (",
          "202:       VALUES(3, 'thirteen'), (3, 'fourteen'), (4, 'fifteen'), (4, 'sixteen')",
          "203:     )",
          "204:     UPDATE w1 SET z=v FROM data WHERE (1+w*2+x)=k;",
          "205:   }",
          "207:   do_execsql_test 1.%TN%.13 {",
          "208:     SELECT * FROM w1;",
          "209:     SELECT * FROM log;",
          "210:   } {",
          "211:     0 0 i eight   0 1 xii twelve   1 0 v fourteen   1 1 iv sixteen",
          "212:     thirty->thirteen  v->v",
          "213:     thirteen->fourteen  v->v",
          "214:     four->fifteen  iv->iv",
          "215:     fifteen->sixteen  iv->iv",
          "216:   }",
          "218: }]",
          "219: }",
          "221: ifcapable update_delete_limit {",
          "222: foreach {tn wo} {",
          "223:   1 \"\"",
          "224:   2 \"WITHOUT ROWID\"",
          "225: } {",
          "226:   reset_db",
          "228: eval [string map [list %WO% $wo %TN% $tn] {",
          "229:   do_execsql_test 2.%TN%.1 {",
          "230:     CREATE TABLE x1(a INTEGER PRIMARY KEY, b) %WO%;",
          "231:     INSERT INTO x1 VALUES",
          "232:         (1, 'one'), (2, 'two'), (3, 'three'), (4, 'four'),",
          "233:         (5, 'five'), (6, 'six'), (7, 'seven'), (8, 'eight');",
          "234:   }",
          "236:   do_execsql_test 2.%TN%.2 {",
          "237:     CREATE TABLE data1(x, y);",
          "238:     INSERT INTO data1 VALUES",
          "239:     (1, 'eleven'), (1, 'twenty-one'), (2, 'twelve'), (2, 'twenty-two'),",
          "240:     (3, 'thirteen'), (3, 'twenty-three'), (4, 'fourteen'), (4, 'twenty-four');",
          "241:   }",
          "243:   do_execsql_test 2.%TN%.3 {",
          "244:     UPDATE x1 SET b=y FROM data1 WHERE a=x ORDER BY a LIMIT 3;",
          "245:     SELECT * FROM x1;",
          "246:   } {",
          "247:     1 eleven 2 twelve 3 thirteen 4 four 5 five 6 six 7 seven 8 eight",
          "248:   }",
          "250:   do_execsql_test 2.%TN%.4 {",
          "251:     UPDATE x1 SET b=b||y FROM data1 WHERE a=x ORDER BY b LIMIT 3;",
          "252:     SELECT * FROM x1;",
          "253:   } {",
          "254:     1 eleveneleven 2 twelve 3 thirteenthirteen 4 fourfourteen",
          "255:     5 five 6 six 7 seven 8 eight",
          "256:   }",
          "258:   do_catchsql_test 2.%TN%.5 {",
          "259:     UPDATE x1 SET b=b||b ORDER BY b;",
          "260:   } {1 {ORDER BY without LIMIT on UPDATE}}",
          "261:   do_catchsql_test 2.%TN%.6 {",
          "262:     UPDATE x1 SET b=b||y FROM data1 WHERE a=x ORDER BY b;",
          "263:   } {1 {ORDER BY without LIMIT on UPDATE}}",
          "265:   #-----------------------------------------------------------------------",
          "267:   do_execsql_test 2.%TN%.6 {",
          "268:     DROP TABLE x1;",
          "269:     CREATE TABLE x1(u, v, b, PRIMARY KEY(u, v)) %WO%;",
          "270:     INSERT INTO x1 VALUES",
          "271:         (0, 1, 'one'), (1, 0, 'two'), (1, 1, 'three'), (2, 0, 'four'),",
          "272:         (2, 1, 'five'), (3, 0, 'six'), (3, 1, 'seven'), (4, 0, 'eight');",
          "273:   }",
          "275:   do_execsql_test 2.%TN%.7 {",
          "276:     UPDATE x1 SET b=y FROM data1 WHERE (u*2+v)=x ORDER BY u, v LIMIT 3;",
          "277:     SELECT * FROM x1;",
          "278:   } {",
          "279:     0 1 eleven 1 0 twelve 1 1 thirteen 2 0 four",
          "280:     2 1 five 3 0 six 3 1 seven 4 0 eight",
          "281:   }",
          "283:   do_execsql_test 2.%TN%.8 {",
          "284:     UPDATE x1 SET b=b||y FROM data1 WHERE (u*2+v)=x ORDER BY b LIMIT 3;",
          "285:     SELECT * FROM x1;",
          "286:   } {",
          "287:     0 1 eleveneleven 1 0 twelve 1 1 thirteenthirteen 2 0 fourfourteen",
          "288:     2 1 five  3 0 six 3 1 seven 4 0 eight",
          "289:   }",
          "292: }]",
          "293: }}",
          "295: reset_db",
          "296: do_execsql_test 3.0 {",
          "297:   CREATE TABLE data(x, y, z);",
          "298:   CREATE VIEW t1 AS SELECT * FROM data;",
          "299:   CREATE TRIGGER t1_insert INSTEAD OF INSERT ON t1 BEGIN",
          "300:     INSERT INTO data VALUES(new.x, new.y, new.z);",
          "301:   END;",
          "302:   CREATE TRIGGER t1_update INSTEAD OF UPDATE ON t1 BEGIN",
          "303:     INSERT INTO log VALUES(old.z || '->' || new.z);",
          "304:   END;",
          "306:   CREATE TABLE log(t TEXT);",
          "308:   INSERT INTO t1 VALUES(1, 'i',   'one');",
          "309:   INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "310:   INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "311:   INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "312: }",
          "314: do_execsql_test 3.1 {",
          "315:   WITH input(k, v) AS (",
          "316:       VALUES(3, 'thirty'), (1, 'ten')",
          "317:   )",
          "318:   UPDATE t1 SET z=v FROM input WHERE x=k;",
          "319: }",
          "321: foreach {tn sql} {",
          "322:   2 {",
          "323:     CREATE TABLE x1(a INT PRIMARY KEY, b, c) WITHOUT ROWID;",
          "324:   }",
          "325:   1 {",
          "326:     CREATE TABLE x1(a INTEGER PRIMARY KEY, b, c);",
          "327:   }",
          "328:   3 {",
          "329:     CREATE TABLE x1(a INT PRIMARY KEY, b, c);",
          "330:   }",
          "331: } {",
          "333:   reset_db",
          "334:   execsql $sql",
          "336:   do_execsql_test 4.$tn.0 {",
          "337:     INSERT INTO x1 VALUES(1, 1, 1);",
          "338:     INSERT INTO x1 VALUES(2, 2, 2);",
          "339:     INSERT INTO x1 VALUES(3, 3, 3);",
          "340:     INSERT INTO x1 VALUES(4, 4, 4);",
          "341:     INSERT INTO x1 VALUES(5, 5, 5);",
          "342:     CREATE TABLE map(o, t);",
          "343:     INSERT INTO map VALUES(3, 30), (4, 40), (1, 10);",
          "344:   }",
          "346:   do_execsql_test 4.$tn.1 {",
          "347:     UPDATE x1 SET a=t FROM map WHERE a=o;",
          "348:     SELECT * FROM x1 ORDER BY a;",
          "349:   } {2 2 2   5 5 5   10 1 1  30 3 3  40 4 4}",
          "350: }",
          "352: reset_db",
          "353: do_execsql_test 5.0 {",
          "354:   CREATE TABLE x1(a, b, c);",
          "355:   CREATE TABLE x2(a, b, c);",
          "356: }",
          "358: foreach {tn update nm} {",
          "359:   1 \"UPDATE x1 SET a=5 FROM x1\" x1",
          "360:   2 \"UPDATE x1 AS grapes SET a=5 FROM x1 AS grapes\" grapes",
          "361:   3 \"UPDATE x1 SET a=5 FROM x2, x1\" x1",
          "362:   4 \"UPDATE x1 AS grapes SET a=5 FROM x2, x1 AS grapes\" grapes",
          "363: } {",
          "364:   do_catchsql_test 5.$tn $update \\",
          "365:     \"1 {target object/alias may not appear in FROM clause: $nm}\"",
          "366: }",
          "369: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom3.test||test/upfrom3.test": [
          "File: test/upfrom3.test -> test/upfrom3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 July 14",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix upfrom3",
          "17: # Test plan:",
          "18: #",
          "19: #   1.*: Test UPDATE ... FROM statements that modify IPK fields. And that",
          "20: #        modify \"INTEGER PRIMARY KEY\" fields on WITHOUT ROWID tables.",
          "21: #",
          "22: #   2.*: Test UPDATE ... FROM statements that modify PK fields of WITHOUT",
          "23: #        ROWID tables.",
          "24: #",
          "25: #   3.*: Test that UPDATE ... FROM statements are not confused if there",
          "26: #        are multiple tables of the same name in attached databases.",
          "27: #",
          "28: #   4.*: Tests for UPDATE ... FROM statements and foreign keys.",
          "29: #",
          "31: foreach {tn wo} {",
          "32:   1 \"\"",
          "33:   2 \"WITHOUT ROWID\"",
          "34: } {",
          "35:   reset_db",
          "36:   eval [string map [list %WO% $wo %TN% $tn] {",
          "38:   do_execsql_test 1.%TN%.0 {",
          "39:     CREATE TABLE log(t TEXT);",
          "40:     CREATE TABLE t1(x INTEGER PRIMARY KEY, y, z UNIQUE) %WO%;",
          "41:     CREATE INDEX t1y ON t1(y);",
          "43:     INSERT INTO t1 VALUES(1, 'i',   'one');",
          "44:     INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "45:     INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "46:     INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "47:   }",
          "49:   do_execsql_test 1.%TN%.1 {",
          "50:     CREATE TABLE x1(o, n);",
          "51:     INSERT INTO x1 VALUES(1, 11);",
          "52:     INSERT INTO x1 VALUES(2, 12);",
          "53:     INSERT INTO x1 VALUES(3, 13);",
          "54:     INSERT INTO x1 VALUES(4, 14);",
          "55:     UPDATE t1 SET x=n FROM x1 WHERE x=o;",
          "56:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "57:   } {",
          "58:     11 i one",
          "59:     12 ii two",
          "60:     13 iii three",
          "61:     14 iv four",
          "62:   }",
          "64:   do_test 1.%TN%.2 { db changes } 4",
          "66:   do_execsql_test 1.%TN%.3 {",
          "67:     INSERT INTO x1 VALUES(11, 21);",
          "68:     INSERT INTO x1 VALUES(12, 22);",
          "69:     INSERT INTO x1 VALUES(13, 23);",
          "70:     INSERT INTO x1 VALUES(14, 24);",
          "72:     INSERT INTO x1 VALUES(21, 31);",
          "73:     INSERT INTO x1 VALUES(22, 32);",
          "74:     INSERT INTO x1 VALUES(23, 33);",
          "75:     INSERT INTO x1 VALUES(24, 34);",
          "76:     UPDATE t1 SET x=n FROM x1 WHERE x=o;",
          "77:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "78:   } {",
          "79:     21 i one",
          "80:     22 ii two",
          "81:     23 iii three",
          "82:     24 iv four",
          "83:   }",
          "85:   do_execsql_test 1.%TN%.4 {",
          "86:     UPDATE t1 SET x=n FROM x1 WHERE x=o;",
          "87:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "88:   } {",
          "89:     31 i one",
          "90:     32 ii two",
          "91:     33 iii three",
          "92:     34 iv four",
          "93:   }",
          "95:   do_execsql_test 1.%TN%.5 {",
          "96:     INSERT INTO x1 VALUES(31, 32);",
          "97:     INSERT INTO x1 VALUES(33, 34);",
          "98:     UPDATE OR REPLACE t1 SET x=n FROM x1 WHERE x=o;",
          "99:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "100:   } {",
          "101:     32 i one",
          "102:     34 iii three",
          "103:   }",
          "105:   do_execsql_test 1.%TN%.6 {",
          "106:     INSERT INTO t1 VALUES(33, 'ii', 'two');",
          "107:     INSERT INTO t1 VALUES(35, 'iv', 'four');",
          "108:   }",
          "110:   do_execsql_test 1.%TN%.7 {",
          "111:     CREATE TABLE x2(o, n, zz);",
          "112:     INSERT INTO x2 VALUES(32, 41, 'four');",
          "113:     INSERT INTO x2 VALUES(33, 42, 'three');",
          "114:     UPDATE OR IGNORE t1 SET x=n, z=zz FROM x2 WHERE x=o;",
          "115:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "116:   } {",
          "117:     32 i one",
          "118:     33 ii two",
          "119:     34 iii three",
          "120:     35 iv four",
          "121:   }",
          "123:   do_execsql_test 1.%TN%.8 {",
          "124:     UPDATE OR REPLACE t1 SET x=n, z=zz FROM x2 WHERE x=o;",
          "125:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "126:   } {",
          "127:     41 i four",
          "128:     42 ii three",
          "129:   }",
          "131:   }]",
          "132: }",
          "134: do_execsql_test 2.1.1 {",
          "135:   CREATE TABLE u1(a, b, c, PRIMARY KEY(b, c)) WITHOUT ROWID;",
          "136:   INSERT INTO u1 VALUES(0, 0, 0);",
          "137:   INSERT INTO u1 VALUES(1, 0, 1);",
          "138:   INSERT INTO u1 VALUES(2, 1, 0);",
          "139:   INSERT INTO u1 VALUES(3, 1, 1);",
          "140: }",
          "142: do_execsql_test 2.1.2 {",
          "143:   CREATE TABLE map(f, t);",
          "144:   INSERT INTO map VALUES(0, 10);",
          "145:   INSERT INTO map VALUES(1, 11);",
          "146:   UPDATE u1 SET c=t FROM map WHERE c=f;",
          "147:   SELECT * FROM u1 ORDER BY a;",
          "148: } {",
          "149:   0 0 10",
          "150:   1 0 11",
          "151:   2 1 10",
          "152:   3 1 11",
          "153: }",
          "155: do_execsql_test 2.1.3 {",
          "156:   UPDATE u1 SET b=t FROM map WHERE b=f;",
          "157:   SELECT * FROM u1 ORDER BY a;",
          "158: } {",
          "159:   0 10 10",
          "160:   1 10 11",
          "161:   2 11 10",
          "162:   3 11 11",
          "163: }",
          "165: do_execsql_test 2.1.4 {",
          "166:   CREATE TABLE map2(o1, o2, n1, n2);",
          "167:   INSERT INTO map2 VALUES",
          "168:     (10, 10, 50, 50), (10, 11, 50, 60),",
          "169:     (11, 10, 60, 50), (11, 11, 60, 60);",
          "170:   UPDATE u1 SET b=n1, c=n2 FROM map2 WHERE b=o1 AND c=o2;",
          "171:   SELECT * FROM u1 ORDER BY a;",
          "172: } {",
          "173:   0 50 50",
          "174:   1 50 60",
          "175:   2 60 50",
          "176:   3 60 60",
          "177: }",
          "179: #-------------------------------------------------------------------------",
          "180: foreach {tn wo} {",
          "181:   1 \"\"",
          "182:   2 \"WITHOUT ROWID\"",
          "183: } {",
          "184:   reset_db",
          "185:   forcedelete test.db2",
          "186:   eval [string map [list %WO% $wo %TN% $tn] {",
          "187:     do_execsql_test 3.$tn.1 {",
          "188:       CREATE TABLE g1(a, b, c, PRIMARY KEY(a, b)) %WO%;",
          "189:       INSERT INTO g1 VALUES(1, 1, 1);",
          "191:       ATTACH 'test.db2' AS aux;",
          "192:       CREATE TABLE aux.g1(a, b, c, PRIMARY KEY(a, b)) %WO%;",
          "193:       INSERT INTO aux.g1 VALUES(10, 1, 10);",
          "194:       INSERT INTO aux.g1 VALUES(20, 2, 20);",
          "195:       INSERT INTO aux.g1 VALUES(30, 3, 30);",
          "196:     }",
          "198:     do_execsql_test 3.$tn.2 {",
          "199:       UPDATE aux.g1 SET c=101 FROM main.g1;",
          "200:     }",
          "201:     do_execsql_test 3.$tn.3 {",
          "202:       SELECT * FROM aux.g1;",
          "203:     } {10 1 101  20 2 101  30 3 101}",
          "205:     do_execsql_test 3.$tn.4 {",
          "206:       UPDATE g1 SET c=101 FROM g1 AS g2;",
          "207:     }",
          "208:     do_execsql_test 3.$tn.5 {",
          "209:       SELECT * FROM g1;",
          "210:     } {1 1 101}",
          "211:   }]",
          "212: }",
          "214: #-------------------------------------------------------------------------",
          "215: reset_db",
          "216: foreach {tn wo} {",
          "217:   1 \"\"",
          "218:   2 \"WITHOUT ROWID\"",
          "219: } {",
          "220:   reset_db",
          "221:   forcedelete test.db2",
          "222:   eval [string map [list %WO% $wo %TN% $tn] {",
          "224:     do_execsql_test 4.$tn.1 {",
          "225:       CREATE TABLE p1(a INTEGER PRIMARY KEY, b) %WO%;",
          "226:       CREATE TABLE c1(x PRIMARY KEY, y REFERENCES p1 ON UPDATE CASCADE) %WO%;",
          "227:       PRAGMA foreign_keys = 1;",
          "229:       INSERT INTO p1 VALUES(1, 'one');",
          "230:       INSERT INTO p1 VALUES(11, 'eleven');",
          "231:       INSERT INTO p1 VALUES(111, 'eleventyone');",
          "233:       INSERT INTO c1 VALUES('a', 1);",
          "234:       INSERT INTO c1 VALUES('b', 11);",
          "235:       INSERT INTO c1 VALUES('c', 111);",
          "236:     }",
          "238:     do_execsql_test 4.$tn.2 {",
          "239:       CREATE TABLE map(f, t);",
          "240:       INSERT INTO map VALUES('a', 111);",
          "241:       INSERT INTO map VALUES('c', 112);",
          "242:     }",
          "244:     do_catchsql_test 4.$tn.3 {",
          "245:       UPDATE c1 SET y=t FROM map WHERE x=f;",
          "246:     } {1 {FOREIGN KEY constraint failed}}",
          "248:     do_execsql_test 4.$tn.4 {",
          "249:       INSERT INTO map VALUES('eleven', 12);",
          "250:       INSERT INTO map VALUES('eleventyone', 112);",
          "251:       UPDATE p1 SET a=t FROM map WHERE b=f;",
          "252:     }",
          "254:     do_execsql_test 4.$tn.5 {",
          "255:       SELECT * FROM c1",
          "256:     } {a 1  b 12  c 112}",
          "258:   }]",
          "259: }",
          "261: finish_test",
          "",
          "---------------"
        ],
        "test/upfromfault.test||test/upfromfault.test": [
          "File: test/upfromfault.test -> test/upfromfault.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 29",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix upfromfault",
          "17: foreach {tn sql} {",
          "18:   1 {",
          "19:     CREATE TABLE t1(x PRIMARY KEY, y, z UNIQUE);",
          "20:     CREATE INDEX t1y ON t1(y);",
          "21:   }",
          "22:   2 {",
          "23:     CREATE TABLE t1(x PRIMARY KEY, y, z UNIQUE) WITHOUT ROWID;",
          "24:     CREATE INDEX t1y ON t1(y);",
          "25:   }",
          "26:   3 {",
          "27:     CREATE TABLE t1(x, y, z UNIQUE, PRIMARY KEY(x,y)) WITHOUT ROWID;",
          "28:   }",
          "29:   4 {",
          "30:     CREATE VIRTUAL TABLE t1 USING fts5(x, y, z);",
          "31:   }",
          "32:   5 {",
          "33:     CREATE TABLE real(x, y, z);",
          "34:     CREATE VIEW t1 AS SELECT * FROM real;",
          "35:     CREATE TRIGGER t1_insert INSTEAD OF INSERT ON t1 BEGIN",
          "36:       INSERT INTO real VALUES(new.x, new.y, new.z);",
          "37:     END;",
          "38:     CREATE TRIGGER t1_update INSTEAD OF UPDATE ON t1 BEGIN",
          "39:       INSERT INTO log VALUES(old.z || '->' || new.z);",
          "40:       UPDATE real SET y=new.y, z=new.z WHERE x=old.x;",
          "41:     END;",
          "42:   }",
          "43: } {",
          "44: if {$tn<5} continue",
          "45:   reset_db",
          "47:   ifcapable !fts5 { if {$tn==4} continue }",
          "49:   execsql $sql",
          "50:   do_execsql_test 1.$tn.0 {",
          "51:     CREATE TABLE log(t TEXT);",
          "53:     INSERT INTO t1 VALUES(1, 'i',   'one');",
          "54:     INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "55:     INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "56:     INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "57:   }",
          "58:   if {$tn!=4 && $tn!=5} {",
          "59:     do_execsql_test 1.$tn.0b {",
          "60:       CREATE TRIGGER tr1 BEFORE UPDATE ON t1 BEGIN",
          "61:         INSERT INTO log VALUES(old.z || '->' || new.z);",
          "62:       END;",
          "63:       CREATE TRIGGER tr2 AFTER UPDATE ON t1 BEGIN",
          "64:         INSERT INTO log VALUES(old.y || '->' || new.y);",
          "65:       END;",
          "66:     }",
          "67:   }",
          "69:   faultsim_save_and_close",
          "71:   do_faultsim_test 1.$tn -prep {",
          "72:     faultsim_restore_and_reopen",
          "73:     execsql { SELECT * FROM t1 }",
          "74:   } -body {",
          "75:     execsql {",
          "76:       WITH data(k, v) AS (",
          "77:           VALUES(3, 'thirty'), (1, 'ten')",
          "78:       )",
          "79:       UPDATE t1 SET z=v FROM data WHERE x=k;",
          "80:     }",
          "81:   } -test {",
          "82:     faultsim_test_result {0 {}} {1 {vtable constructor failed: t1}}",
          "83:     if {$testrc==0} {",
          "84:       set res [execsql { SELECT * FROM t1 }]",
          "85:       if {$res!=\"1 i ten 2 ii two 3 iii thirty 4 iv four\"} {",
          "86:         error \"unexpected result: $res\"",
          "87:       }",
          "88:     }",
          "89:   }",
          "90: }",
          "92: reset_db",
          "93: do_execsql_test 2.0 {",
          "94:   CREATE TABLE t1(a, b, c);",
          "95:   CREATE TABLE t2(x, y, z);",
          "96: }",
          "97: faultsim_save_and_close",
          "98: do_faultsim_test 2.1 -prep {",
          "99:   faultsim_restore_and_reopen",
          "100: } -body {",
          "101:   execsql {",
          "102:     CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN",
          "103:       UPDATE t2 SET x=a FROM t1 WHERE c=z;",
          "104:     END;",
          "105:   }",
          "106: } -test {",
          "107:     faultsim_test_result {0 {}}",
          "108: }",
          "110: faultsim_restore_and_reopen",
          "111: do_execsql_test 2.2 {",
          "112:   CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN",
          "113:     UPDATE t1 SET a=x FROM t2 WHERE c=z;",
          "114:   END;",
          "116:   INSERT INTO t2 VALUES(1, 1, 1);",
          "117:   INSERT INTO t2 VALUES(2, 2, 2);",
          "118:   INSERT INTO t2 VALUES(3, 3, 3);",
          "119: }",
          "120: faultsim_save_and_close",
          "122: do_faultsim_test 2.3 -prep {",
          "123:   faultsim_restore_and_reopen",
          "124: } -body {",
          "125:   execsql {",
          "126:     INSERT INTO t1 VALUES(NULL, NULL, 1), (NULL, NULL, 3);",
          "127:   }",
          "128: } -test {",
          "129:   faultsim_test_result {0 {}}",
          "130:   if {$testrc==0} {",
          "131:     set res [execsql { SELECT * FROM t1 }]",
          "132:     if {$res!=\"1 {} 1 3 {} 3\"} {",
          "133:       error \"unexpected result: $res\"",
          "134:     }",
          "135:   }",
          "136: }",
          "139: finish_test",
          "",
          "---------------"
        ]
      }
    }
  ]
}
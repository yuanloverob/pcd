{
  "cve_id": "CVE-2017-7185",
  "cve_desc": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.",
  "repo": "cesanta/mongoose",
  "patch_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
  "patch_info": {
    "commit_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "files": [
      "mongoose.c"
    ],
    "message": "Fix crash in multipart handling\n\nClose cesanta/dev#6974\n\nPUBLISHED_FROM=4d4e4a46eceba10aec8dacb7f8f58bd078c92307",
    "before_after_code_files": [
      "mongoose.c||mongoose.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5961:   struct mbuf *io = &c->recv_mbuf;",
      "5962:   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);",
      "5964:   if ((int) io->len < pd->mp_stream.boundary_len + 2) {",
      "5965:     return 0;",
      "5966:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5964:   if (pd->mp_stream.boundary == NULL) {",
      "5965:     pd->mp_stream.state = MPS_FINALIZE;",
      "5966:     DBG((\"Invalid request: boundary not initilaized\"));",
      "5967:     return 0;",
      "5968:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cae0a1cbc0b4efcf340368ce17d02a023deb9273",
      "candidate_info": {
        "commit_hash": "cae0a1cbc0b4efcf340368ce17d02a023deb9273",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/cae0a1cbc0b4efcf340368ce17d02a023deb9273",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix mongoose amalgamation\n\nPUBLISHED_FROM=16ae777c949caf87e7dce428d62fa8878a30d318",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c"
        ]
      }
    },
    {
      "candidate_hash": "a0527a7f0e2456d652237098cf362dcdcf5769a0",
      "candidate_info": {
        "commit_hash": "a0527a7f0e2456d652237098cf362dcdcf5769a0",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/a0527a7f0e2456d652237098cf362dcdcf5769a0",
        "files": [
          "examples/ESP8266_RTOS/user/mongoose.h"
        ],
        "message": "Fix esp8266 rtos example build\n\nPUBLISHED_FROM=80055394237617605c57a07ac29c43d5197cbf5c",
        "before_after_code_files": [
          "examples/ESP8266_RTOS/user/mongoose.h||examples/ESP8266_RTOS/user/mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "examples/ESP8266_RTOS/user/mongoose.h||examples/ESP8266_RTOS/user/mongoose.h": [
          "File: examples/ESP8266_RTOS/user/mongoose.h -> examples/ESP8266_RTOS/user/mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ../../../mongoose.h",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8354319e72c264850bf10a7798f6fcd6a85bfe53",
      "candidate_info": {
        "commit_hash": "8354319e72c264850bf10a7798f6fcd6a85bfe53",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/8354319e72c264850bf10a7798f6fcd6a85bfe53",
        "files": [
          "examples/websocket_chat/Makefile",
          "examples/websocket_chat/websocket_chat.c"
        ],
        "message": "websocket_chat added MG_EV_HTTP_REQUEST\n\nPUBLISHED_FROM=6f5e1b4a97ada21025f892d3348808bffb469dfa",
        "before_after_code_files": [
          "examples/websocket_chat/websocket_chat.c||examples/websocket_chat/websocket_chat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "examples/websocket_chat/websocket_chat.c||examples/websocket_chat/websocket_chat.c": [
          "File: examples/websocket_chat/websocket_chat.c -> examples/websocket_chat/websocket_chat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: static sig_atomic_t s_signal_received = 0;",
          "9: static const char *s_http_port = \"8000\";",
          "11: static void signal_handler(int sig_num) {",
          "12:   signal(sig_num, signal_handler);  // Reinstantiate signal handler",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: static struct mg_serve_http_opts s_http_server_opts;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:       broadcast(nc, d);",
          "47:       break;",
          "48:     }",
          "49:     case MG_EV_CLOSE: {",
          "51:       if (is_websocket(nc)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50:     case MG_EV_HTTP_REQUEST: {",
          "51:       mg_serve_http(nc, (struct http_message *) ev_data, s_http_server_opts);",
          "52:       break;",
          "53:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:   nc = mg_bind(&mgr, s_http_port, ev_handler);",
          "71:   mg_set_protocol_http_websocket(nc);",
          "73:   printf(\"Started on port %s\\n\", s_http_port);",
          "74:   while (s_signal_received == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77:   s_http_server_opts.document_root = \".\";  // Serve current directory",
          "78:   s_http_server_opts.enable_directory_listing = \"yes\";",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "83fe5a17f3c71710bdf546061387b031ac718a3e",
      "candidate_info": {
        "commit_hash": "83fe5a17f3c71710bdf546061387b031ac718a3e",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/83fe5a17f3c71710bdf546061387b031ac718a3e",
        "files": [
          "docs/c-api/http.h/intro.md",
          "docs/c-api/http.h/mg_send_websocket_framev.md",
          "docs/c-api/http.h/mg_send_websocket_handshake3v.md",
          "docs/c-api/http.h/mg_url_decode.md",
          "docs/c-api/uri.h/mg_parse_uri.md",
          "docs/c-api/util.h/mg_basic_auth_header.md",
          "mongoose.c",
          "mongoose.h"
        ],
        "message": "Make mg_connect_{http,ws} use mg_parse_uri\n\nRemove the specialized URI parser, clean up code a bit.\n\nFix parsing of URIs with IPv6 hosts (http://[2001:2:3::4]:567/)\n\nPUBLISHED_FROM=968ad97585d928123106ce3828920ee073113f83",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:                                      struct http_message *hm, char *buf,",
          "98:                                      size_t blen);",
          "105: #if MG_ENABLE_FILESYSTEM",
          "106: MG_INTERNAL int mg_uri_to_local_path(struct http_message *hm,",
          "107:                                      const struct mg_serve_http_opts *opts,",
          "",
          "[Removed Lines]",
          "100: MG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,",
          "101:                                          const char *schema_tls, int *use_ssl,",
          "102:                                          char **user, char **pass, char **addr,",
          "103:                                          int *port_i, const char **path);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154: MG_INTERNAL void mg_close_conn(struct mg_connection *conn);",
          "161: #if MG_ENABLE_SNTP",
          "162: MG_INTERNAL int mg_sntp_parse_reply(const char *buf, int len,",
          "163:                                     struct mg_sntp_message *msg);",
          "",
          "[Removed Lines]",
          "156: MG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,",
          "157:                                          const char *schema_tls, int *use_ssl,",
          "158:                                          char **user, char **pass, char **addr,",
          "159:                                          int *port_i, const char **path);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4853:   if (*p < end) (*p)++;",
          "4854: }",
          "4857:                  struct mg_str *user_info, struct mg_str *host,",
          "4858:                  unsigned int *port, struct mg_str *path, struct mg_str *query,",
          "4859:                  struct mg_str *fragment) {",
          "",
          "[Removed Lines]",
          "4856: int mg_parse_uri(struct mg_str uri, struct mg_str *scheme,",
          "",
          "[Added Lines]",
          "4846: int mg_parse_uri(const struct mg_str uri, struct mg_str *scheme,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4882:         for (; p < end; p++) {",
          "4883:           if (*p == ':') {",
          "4884:             state = P_SCHEME_OR_PORT;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4873:         if (*p == '[') {",
          "4874:           state = P_HOST;",
          "4875:           break;",
          "4876:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4898:           rscheme.p = uri.p;",
          "4899:           rscheme.len = p - uri.p;",
          "4900:           state = P_USER_INFO;",
          "4902:         } else {",
          "4903:           rhost.p = uri.p;",
          "4904:           rhost.len = p - uri.p;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4896:           p += 3;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4906:         }",
          "4907:         break;",
          "4908:       case P_USER_INFO:",
          "4910:         ruser_info.p = p;",
          "4911:         for (; p < end; p++) {",
          "4916:             break;",
          "4917:           }",
          "4918:         }",
          "4922:           p = ruser_info.p;",
          "4923:         }",
          "4924:         ruser_info.len = p - ruser_info.p;",
          "4925:         break;",
          "4926:       case P_HOST:",
          "4927:         if (*p == '@') p++;",
          "4928:         rhost.p = p;",
          "4930:           if (*p == ':') {",
          "4931:             state = P_PORT;",
          "4932:             break;",
          "",
          "[Removed Lines]",
          "4909:         p++;",
          "4912:           if (*p == '@') {",
          "4913:             state = P_HOST;",
          "4914:             break;",
          "4915:           } else if (*p == '/') {",
          "4919:         if (p == end || *p == '/') {",
          "4921:           state = P_HOST;",
          "4929:         for (; p < end; p++) {",
          "",
          "[Added Lines]",
          "4906:           if (*p == '@' || *p == '[') {",
          "4910:         if (p == end || *p == '/' || *p == '[') {",
          "4915:         state = P_HOST;",
          "4920:         if (*p == '[') {",
          "4921:           int found = 0;",
          "4922:           for (; !found && p < end; p++) {",
          "4923:             found = (*p == ']');",
          "4924:           }",
          "4925:           if (!found) return -1;",
          "4926:         } else {",
          "4927:           for (; p < end; p++) {",
          "4928:             if (*p == ':' || *p == '/') break;",
          "4929:           }",
          "4930:         }",
          "4931:         rhost.len = p - rhost.p;",
          "4932:         if (p < end) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4935:             break;",
          "4936:           }",
          "4937:         }",
          "4939:         break;",
          "4940:       case P_PORT:",
          "4941:         p++;",
          "",
          "[Removed Lines]",
          "4938:         rhost.len = p - rhost.p;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5095: struct mg_connection *mg_connect_http_base(",
          "5096:     struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),",
          "5097:     struct mg_connect_opts opts, const char *schema, const char *schema_ssl,",
          "5100: static struct mg_http_proto_data *mg_http_get_proto_data(",
          "5101:     struct mg_connection *c) {",
          "",
          "[Removed Lines]",
          "5098:     const char *url, const char **path, char **user, char **pass, char **addr);",
          "",
          "[Added Lines]",
          "5100:     const char *url, struct mg_str *path, struct mg_str *user_info,",
          "5101:     struct mg_str *host);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "7089:                            struct mg_str upstream) {",
          "7090:   struct mg_connection *be;",
          "7091:   char burl[256], *purl = burl;",
          "7094:   int i;",
          "7095:   const char *error;",
          "7096:   struct mg_connect_opts opts;",
          "7097:   memset(&opts, 0, sizeof(opts));",
          "7098:   opts.error_string = &error;",
          "7100:   mg_asprintf(&purl, sizeof(burl), \"%.*s%.*s\", (int) upstream.len, upstream.p,",
          "7101:               (int) (hm->uri.len - mount.len), hm->uri.p + mount.len);",
          "7106:   LOG(LL_DEBUG, (\"Proxying %.*s to %s (rule: %.*s)\", (int) hm->uri.len,",
          "7107:                  hm->uri.p, purl, (int) mount.len, mount.p));",
          "",
          "[Removed Lines]",
          "7092:   char *addr = NULL;",
          "7093:   const char *path = NULL;",
          "7103:   be = mg_connect_http_base(nc->mgr, MG_CB(mg_reverse_proxy_handler, NULL),",
          "7104:                             opts, \"http://\", \"https://\", purl, &path,",
          "7105:                             NULL /* user */, NULL /* pass */, &addr);",
          "",
          "[Added Lines]",
          "7098:   struct mg_str path = MG_NULL_STR, user_info = MG_NULL_STR, host = MG_NULL_STR;",
          "7105:   be =",
          "7106:       mg_connect_http_base(nc->mgr, MG_CB(mg_reverse_proxy_handler, NULL), opts,",
          "7107:                            \"http\", \"https\", purl, &path, &user_info, &host);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7117:   mg_http_get_proto_data(nc)->reverse_proxy_data.linked_conn = be;",
          "7124:   for (i = 0; i < MG_MAX_HTTP_HEADERS && hm->header_names[i].len > 0; i++) {",
          "7125:     struct mg_str hn = hm->header_names[i];",
          "7126:     struct mg_str hv = hm->header_values[i];",
          "",
          "[Removed Lines]",
          "7120:   mg_printf(be, \"%.*s %s HTTP/1.1\\r\\n\", (int) hm->method.len, hm->method.p,",
          "7121:             path);",
          "7123:   mg_printf(be, \"Host: %s\\r\\n\", addr);",
          "",
          "[Added Lines]",
          "7122:   mg_printf(be, \"%.*s %.*s HTTP/1.1\\r\\n\", (int) hm->method.len, hm->method.p,",
          "7123:             (int) path.len, path.p);",
          "7125:   mg_printf(be, \"Host: %.*s\\r\\n\", (int) host.len, host.p);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7789: struct mg_connection *mg_connect_http_base(",
          "7790:     struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),",
          "7791:     struct mg_connect_opts opts, const char *schema, const char *schema_ssl,",
          "7793:   struct mg_connection *nc = NULL;",
          "7795:   int use_ssl = 0;",
          "7799:     MG_SET_PTRPTR(opts.error_string, \"cannot parse url\");",
          "7801:   }",
          "7804:   if (use_ssl) {",
          "7805: #if MG_ENABLE_SSL",
          "",
          "[Removed Lines]",
          "7708: MG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,",
          "7709:                                          const char *schema_tls, int *use_ssl,",
          "7710:                                          char **user, char **pass, char **addr,",
          "7711:                                          int *port_i, const char **path) {",
          "7712:   int addr_len = 0;",
          "7713:   int auth_sep_pos = -1;",
          "7714:   int user_sep_pos = -1;",
          "7715:   int port_pos = -1;",
          "7716:   (void) user;",
          "7717:   (void) pass;",
          "7719:   if (strncmp(url, schema, strlen(schema)) == 0) {",
          "7720:     url += strlen(schema);",
          "7721:   } else if (strncmp(url, schema_tls, strlen(schema_tls)) == 0) {",
          "7722:     url += strlen(schema_tls);",
          "7724: #if !MG_ENABLE_SSL",
          "7726: #endif",
          "7727:   }",
          "7729:   while (*url != '\\0') {",
          "7731:     if (*addr == NULL) {",
          "7732:       DBG((\"OOM\"));",
          "7733:       return -1;",
          "7734:     }",
          "7735:     if (*url == '/') {",
          "7736:       break;",
          "7737:     }",
          "7738:     if (*url == '@') {",
          "7739:       auth_sep_pos = addr_len;",
          "7740:       user_sep_pos = port_pos;",
          "7741:       port_pos = -1;",
          "7742:     }",
          "7743:     if (*url == ':') port_pos = addr_len;",
          "7744:     (*addr)[addr_len++] = *url;",
          "7745:     (*addr)[addr_len] = '\\0';",
          "7746:     url++;",
          "7747:   }",
          "7749:   if (addr_len == 0) goto cleanup;",
          "7750:   if (port_pos < 0) {",
          "7752:     addr_len += sprintf(*addr + addr_len, \":%d\", *use_ssl ? 443 : 80);",
          "7753:   } else {",
          "7755:   }",
          "7757:   if (*path == NULL) *path = url;",
          "7759:   if (**path == '\\0') *path = \"/\";",
          "7761:   if (user != NULL && pass != NULL) {",
          "7762:     if (auth_sep_pos == -1) {",
          "7765:     } else {",
          "7768:       memcpy(*user, *addr, user_sep_pos);",
          "7769:       (*user)[user_sep_pos] = '\\0';",
          "7772:       memcpy(*pass, *addr + user_sep_pos + 1, auth_sep_pos - user_sep_pos - 1);",
          "7773:       (*pass)[auth_sep_pos - user_sep_pos - 1] = '\\0';",
          "7776:       memmove(*addr, *addr + auth_sep_pos + 1, addr_len - auth_sep_pos);",
          "7777:     }",
          "7778:   }",
          "7780:   DBG((\"%s %s\", *addr, *path));",
          "7782:   return 0;",
          "7784: cleanup:",
          "7785:   MG_FREE(*addr);",
          "7786:   return -1;",
          "7787: }",
          "7792:     const char *url, const char **path, char **user, char **pass, char **addr) {",
          "7794:   int port_i = -1;",
          "7797:   if (mg_http_common_url_parse(url, schema, schema_ssl, &use_ssl, user, pass,",
          "7798:                                addr, &port_i, path) < 0) {",
          "7800:     return NULL;",
          "7803:   LOG(LL_DEBUG, (\"%s use_ssl? %d\", url, use_ssl));",
          "",
          "[Added Lines]",
          "7712:     const char *url, struct mg_str *path, struct mg_str *user_info,",
          "7713:     struct mg_str *host) {",
          "7715:   unsigned int port_i = 0;",
          "7717:   struct mg_str scheme, query, fragment;",
          "7718:   char conn_addr_buf[2];",
          "7719:   char *conn_addr = conn_addr_buf;",
          "7721:   if (mg_parse_uri(mg_mk_str(url), &scheme, user_info, host, &port_i, path,",
          "7722:                    &query, &fragment) != 0) {",
          "7724:     goto out;",
          "7725:   }",
          "7727:   if (mg_vcmp(&scheme, schema) == 0) {",
          "7728:     use_ssl = 0;",
          "7729:     if (port_i == 0) port_i = 80;",
          "7730:   } else if (mg_vcmp(&scheme, schema_ssl) == 0) {",
          "7731:     use_ssl = 1;",
          "7732:     if (port_i == 0) port_i = 443;",
          "7733:   } else {",
          "7734:     goto out;",
          "7737:   mg_asprintf(&conn_addr, sizeof(conn_addr_buf), \"tcp://%.*s:%u\",",
          "7738:               (int) host->len, host->p, port_i);",
          "7739:   if (conn_addr == NULL) goto out;",
          "7741:   LOG(LL_DEBUG, (\"%s use_ssl? %d %s\", url, use_ssl, conn_addr));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7813:     }",
          "7814: #else",
          "7815:     MG_SET_PTRPTR(opts.error_string, \"ssl is disabled\");",
          "7820: #endif",
          "7821:   }",
          "7825:     mg_set_protocol_http_websocket(nc);",
          "7828:   }",
          "7830:   return nc;",
          "7831: }",
          "",
          "[Removed Lines]",
          "7816:     if (user != NULL) MG_FREE(*user);",
          "7817:     if (pass != NULL) MG_FREE(*pass);",
          "7818:     MG_FREE(*addr);",
          "7819:     return NULL;",
          "7823:   if ((nc = mg_connect_opt(mgr, *addr, MG_CB(ev_handler, user_data), opts)) !=",
          "7824:       NULL) {",
          "7827:     if (port_i >= 0) (*addr)[port_i] = '\\0';",
          "",
          "[Added Lines]",
          "7754:     goto out;",
          "7758:   if ((nc = mg_connect_opt(mgr, conn_addr, MG_CB(ev_handler, user_data),",
          "7759:                            opts)) != NULL) {",
          "7763: out:",
          "7764:   if (conn_addr != NULL && conn_addr != conn_addr_buf) MG_FREE(conn_addr);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7834:     struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),",
          "7835:     struct mg_connect_opts opts, const char *url, const char *extra_headers,",
          "7836:     const char *post_data) {",
          "7839:   struct mbuf auth;",
          "7840:   struct mg_connection *nc =",
          "7844:   if (nc == NULL) {",
          "7845:     return NULL;",
          "7846:   }",
          "7848:   mbuf_init(&auth, 0);",
          "7851:   }",
          "7853:   if (post_data == NULL) post_data = \"\";",
          "7854:   if (extra_headers == NULL) extra_headers = \"\";",
          "7857:                 \"\\r\\n%.*s%s\\r\\n%s\",",
          "7860:             (auth.buf == NULL ? \"\" : auth.buf), extra_headers, post_data);",
          "7862:   mbuf_free(&auth);",
          "7866:   return nc;",
          "7867: }",
          "",
          "[Removed Lines]",
          "7837:   char *user = NULL, *pass = NULL, *addr = NULL;",
          "7838:   const char *path = NULL;",
          "7841:       mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"http://\",",
          "7842:                            \"https://\", url, &path, &user, &pass, &addr);",
          "7849:   if (user != NULL) {",
          "7850:     mg_basic_auth_header(user, pass, &auth);",
          "7856:   mg_printf(nc, \"%s %s HTTP/1.1\\r\\nHost: %s\\r\\nContent-Length: %\" SIZE_T_FMT",
          "7858:             post_data[0] == '\\0' ? \"GET\" : \"POST\", path, addr,",
          "7859:             strlen(post_data), (int) auth.len,",
          "7863:   MG_FREE(user);",
          "7864:   MG_FREE(pass);",
          "7865:   MG_FREE(addr);",
          "",
          "[Added Lines]",
          "7772:   struct mg_str user = MG_NULL_STR, null_str = MG_NULL_STR;",
          "7773:   struct mg_str host = MG_NULL_STR, path = MG_NULL_STR;",
          "7776:       mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"http\",",
          "7777:                            \"https\", url, &path, &user, &host);",
          "7784:   if (user.len > 0) {",
          "7785:     mg_basic_auth_header(user, null_str, &auth);",
          "7790:   if (path.len == 0) path = mg_mk_str(\"/\");",
          "7792:   mg_printf(nc, \"%s %.*s HTTP/1.1\\r\\nHost: %.*s\\r\\nContent-Length: %\" SIZE_T_FMT",
          "7794:             (post_data[0] == '\\0' ? \"GET\" : \"POST\"), (int) path.len, path.p,",
          "7795:             (int) host.len, host.p, strlen(post_data), (int) auth.len,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "8974: #define MG_WEBSOCKET_PING_INTERVAL_SECONDS 5",
          "8975: #endif",
          "8979: static int mg_is_ws_fragment(unsigned char flags) {",
          "8980:   return (flags & 0x80) == 0 || (flags & 0x0f) == 0;",
          "8981: }",
          "",
          "[Removed Lines]",
          "8977: #define MG_WS_NO_HOST_HEADER_MAGIC ((char *) 0x1)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "9283:                                   const char *host, const char *protocol,",
          "9284:                                   const char *extra_headers, const char *user,",
          "9285:                                   const char *pass) {",
          "9286:   struct mbuf auth;",
          "9287:   char key[25];",
          "9288:   uint32_t nonce[4];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9217:   mg_send_websocket_handshake3v(nc, mg_mk_str(path), mg_mk_str(host),",
          "9218:                                 mg_mk_str(protocol), mg_mk_str(extra_headers),",
          "9219:                                 mg_mk_str(user), mg_mk_str(pass));",
          "9220: }",
          "9222: void mg_send_websocket_handshake3v(struct mg_connection *nc,",
          "9223:                                    const struct mg_str path,",
          "9224:                                    const struct mg_str host,",
          "9225:                                    const struct mg_str protocol,",
          "9226:                                    const struct mg_str extra_headers,",
          "9227:                                    const struct mg_str user,",
          "9228:                                    const struct mg_str pass) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "9293:   mg_base64_encode((unsigned char *) &nonce, sizeof(nonce), key);",
          "9295:   mbuf_init(&auth, 0);",
          "9297:     mg_basic_auth_header(user, pass, &auth);",
          "9298:   }",
          "",
          "[Removed Lines]",
          "9296:   if (user != NULL) {",
          "",
          "[Added Lines]",
          "9239:   if (user.len > 0) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "9306:   mg_printf(nc,",
          "9308:             \"Upgrade: websocket\\r\\n\"",
          "9309:             \"Connection: Upgrade\\r\\n\"",
          "9310:             \"%.*s\"",
          "9311:             \"Sec-WebSocket-Version: 13\\r\\n\"",
          "9312:             \"Sec-WebSocket-Key: %s\\r\\n\",",
          "9318:   }",
          "9321:   }",
          "9324:   }",
          "9325:   mg_printf(nc, \"\\r\\n\");",
          "",
          "[Removed Lines]",
          "9307:             \"GET %s HTTP/1.1\\r\\n\"",
          "9313:             path, (int) auth.len, (auth.buf == NULL ? \"\" : auth.buf), key);",
          "9316:   if (host != MG_WS_NO_HOST_HEADER_MAGIC) {",
          "9317:     mg_printf(nc, \"Host: %s\\r\\n\", host);",
          "9319:   if (protocol != NULL) {",
          "9320:     mg_printf(nc, \"Sec-WebSocket-Protocol: %s\\r\\n\", protocol);",
          "9322:   if (extra_headers != NULL) {",
          "9323:     mg_printf(nc, \"%s\", extra_headers);",
          "",
          "[Added Lines]",
          "9250:             \"GET %.*s HTTP/1.1\\r\\n\"",
          "9256:             (int) path.len, path.p, (int) auth.len,",
          "9257:             (auth.buf == NULL ? \"\" : auth.buf), key);",
          "9260:   if (host.len > 0) {",
          "9261:     mg_printf(nc, \"Host: %.*s\\r\\n\", (int) host.len, host.p);",
          "9263:   if (protocol.len > 0) {",
          "9264:     mg_printf(nc, \"Sec-WebSocket-Protocol: %.*s\\r\\n\", (int) protocol.len,",
          "9265:               protocol.p);",
          "9267:   if (extra_headers.len > 0) {",
          "9268:     mg_printf(nc, \"%.*s\", (int) extra_headers.len, extra_headers.p);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "9330: void mg_send_websocket_handshake(struct mg_connection *nc, const char *path,",
          "9331:                                  const char *extra_headers) {",
          "9334: }",
          "9336: struct mg_connection *mg_connect_ws_opt(",
          "9337:     struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),",
          "9338:     struct mg_connect_opts opts, const char *url, const char *protocol,",
          "9339:     const char *extra_headers) {",
          "9342:   struct mg_connection *nc =",
          "9346:   if (nc != NULL) {",
          "9349:   }",
          "9354:   return nc;",
          "9355: }",
          "",
          "[Removed Lines]",
          "9332:   mg_send_websocket_handshake2(nc, path, MG_WS_NO_HOST_HEADER_MAGIC, NULL,",
          "9333:                                extra_headers);",
          "9340:   char *user = NULL, *pass = NULL, *addr = NULL;",
          "9341:   const char *path = NULL;",
          "9343:       mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"ws://\",",
          "9344:                            \"wss://\", url, &path, &user, &pass, &addr);",
          "9347:     mg_send_websocket_handshake3(nc, path, addr, protocol, extra_headers, user,",
          "9348:                                  pass);",
          "9351:   MG_FREE(addr);",
          "9352:   MG_FREE(user);",
          "9353:   MG_FREE(pass);",
          "",
          "[Added Lines]",
          "9277:   struct mg_str null_str = MG_NULL_STR;",
          "9278:   mg_send_websocket_handshake3v(",
          "9279:       nc, mg_mk_str(path), null_str /* host */, null_str /* protocol */,",
          "9280:       mg_mk_str(extra_headers), null_str /* user */, null_str /* pass */);",
          "9287:   struct mg_str null_str = MG_NULL_STR;",
          "9288:   struct mg_str host = MG_NULL_STR, path = MG_NULL_STR, user_info = MG_NULL_STR;",
          "9290:       mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"ws\", \"wss\",",
          "9291:                            url, &path, &user_info, &host);",
          "9293:     mg_send_websocket_handshake3v(nc, path, host, mg_mk_str(protocol),",
          "9294:                                   mg_mk_str(extra_headers), user_info,",
          "9295:                                   null_str);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "9749:   cs_base64_finish(&ctx);",
          "9750: }",
          "9753:                           struct mbuf *buf) {",
          "9754:   const char *header_prefix = \"Authorization: Basic \";",
          "9755:   const char *header_suffix = \"\\r\\n\";",
          "",
          "[Removed Lines]",
          "9752: void mg_basic_auth_header(const char *user, const char *pass,",
          "",
          "[Added Lines]",
          "9695: void mg_basic_auth_header(const struct mg_str user, const struct mg_str pass,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "9760:   mbuf_append(buf, header_prefix, strlen(header_prefix));",
          "9764:     cs_base64_update(&ctx, \":\", 1);",
          "9766:   }",
          "9767:   cs_base64_finish(&ctx);",
          "9768:   mbuf_append(buf, header_suffix, strlen(header_suffix));",
          "",
          "[Removed Lines]",
          "9762:   cs_base64_update(&ctx, user, strlen(user));",
          "9763:   if (pass != NULL) {",
          "9765:     cs_base64_update(&ctx, pass, strlen(pass));",
          "",
          "[Added Lines]",
          "9705:   cs_base64_update(&ctx, user.p, user.len);",
          "9706:   if (pass.len > 0) {",
          "9708:     cs_base64_update(&ctx, pass.p, pass.len);",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1775: #define MG_MK_STR(str_literal) \\",
          "1776:   { str_literal, sizeof(str_literal) - 1 }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1777: #define MG_NULL_STR \\",
          "1778:   { NULL, 0 }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3832:                  struct mg_str *user_info, struct mg_str *host,",
          "3833:                  unsigned int *port, struct mg_str *path, struct mg_str *query,",
          "3834:                  struct mg_str *fragment);",
          "",
          "[Removed Lines]",
          "3831: int mg_parse_uri(struct mg_str uri, struct mg_str *scheme,",
          "",
          "[Added Lines]",
          "3833: int mg_parse_uri(const struct mg_str uri, struct mg_str *scheme,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4061: #ifdef __cplusplus",
          "4062: }",
          "",
          "[Removed Lines]",
          "4059: void mg_basic_auth_header(const char *user, const char *pass, struct mbuf *buf);",
          "",
          "[Added Lines]",
          "4061: void mg_basic_auth_header(const struct mg_str user, const struct mg_str pass,",
          "4062:                           struct mbuf *buf);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4280:                                   const char *host, const char *protocol,",
          "4281:                                   const char *extra_headers, const char *user,",
          "4282:                                   const char *pass);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4289: void mg_send_websocket_handshake3v(struct mg_connection *nc,",
          "4290:                                    const struct mg_str path,",
          "4291:                                    const struct mg_str host,",
          "4292:                                    const struct mg_str protocol,",
          "4293:                                    const struct mg_str extra_headers,",
          "4294:                                    const struct mg_str user,",
          "4295:                                    const struct mg_str pass);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "57e32b87c7d273c881fb4cff679215978899ee0a",
      "candidate_info": {
        "commit_hash": "57e32b87c7d273c881fb4cff679215978899ee0a",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/57e32b87c7d273c881fb4cff679215978899ee0a",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix MQTT will_message length calculation\n\nPUBLISHED_FROM=d2400f6ef4837411586fb27db0b1fa03d94283c6",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10011:     rem_len += 2 + hlen;",
          "10013:     hlen = strlen(opts.will_message);",
          "10015:     mg_send(nc, &nlen, 2);",
          "10016:     mg_send(nc, opts.will_message, hlen);",
          "10017:     rem_len += 2 + hlen;",
          "",
          "[Removed Lines]",
          "10014:     nlen = htons((uint16_t) nlen);",
          "",
          "[Added Lines]",
          "10014:     nlen = htons((uint16_t) hlen);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
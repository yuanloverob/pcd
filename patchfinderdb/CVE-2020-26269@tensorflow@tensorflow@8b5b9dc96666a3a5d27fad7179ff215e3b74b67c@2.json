{
  "cve_id": "CVE-2020-26269",
  "cve_desc": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "8b5b9dc96666a3a5d27fad7179ff215e3b74b67c",
  "patch_info": {
    "commit_hash": "8b5b9dc96666a3a5d27fad7179ff215e3b74b67c",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/8b5b9dc96666a3a5d27fad7179ff215e3b74b67c",
    "files": [
      "tensorflow/core/platform/file_system_helper.cc"
    ],
    "message": "Completely rewrite `GetMatchingPaths`.\n\nThe current parallel implementation is too complex (lambda inside lambda, two levels of parallelism) and has a read outside of bounds issue.\n\nThe new implementation cleans up artifacts from the previous implementations that were left in the code as it evolves. We add multiple helper functions, and document invariants and preconditions as well as every major step. This way, we fix the security issue and a potential new one which was not caught before\n\nPiperOrigin-RevId: 346146220\nChange-Id: Iec0f44673f43349797bf9944dffe9b2f779137d8",
    "before_after_code_files": [
      "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
      "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: #endif",
      "53: }",
      "55: }  // namespace",
      "57: Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,",
      "58:                         std::vector<string>* results) {",
      "59:   results->clear();",
      "60:   if (pattern.empty()) {",
      "61:     return Status::OK();",
      "62:   }",
      "86:   }",
      "110:       if (s.code() == tensorflow::error::PERMISSION_DENIED) {",
      "111:         return;",
      "112:       }",
      "129:               Status(tensorflow::error::CANCELLED, \"Operation not needed\");",
      "132:         } else {",
      "135:         }",
      "136:       };",
      "137:       ForEach(0, children.size(), handle_children);",
      "143:           continue;",
      "144:         }",
      "155:         }",
      "156:       }",
      "157:     };",
      "162:   }",
      "164: }",
      "166: }  // namespace internal",
      "",
      "[Removed Lines]",
      "64:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
      "65:   string eval_pattern = pattern;",
      "66:   string dir(io::Dirname(fixed_prefix));",
      "69:   if (dir.empty()) {",
      "70:     dir = \".\";",
      "71:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
      "72:     eval_pattern = io::JoinPath(dir, eval_pattern);",
      "73:   }",
      "74:   bool is_directory = pattern[pattern.size() - 1] == '/';",
      "75: #ifdef PLATFORM_WINDOWS",
      "76:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
      "77: #endif",
      "78:   std::vector<string> dirs;",
      "79:   if (!is_directory) {",
      "80:     dirs.emplace_back(eval_pattern);",
      "81:   }",
      "82:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
      "83:   while (tmp_dir.size() > dir.size()) {",
      "84:     dirs.emplace_back(string(tmp_dir));",
      "85:     tmp_dir = io::Dirname(tmp_dir);",
      "87:   dirs.emplace_back(dir);",
      "88:   std::reverse(dirs.begin(), dirs.end());",
      "90:   std::deque<std::pair<string, int>> dir_q;",
      "91:   std::deque<std::pair<string, int>> next_dir_q;",
      "92:   dir_q.emplace_back(std::make_pair(dirs[0], 0));",
      "93:   Status ret;  // Status to return.",
      "94:   mutex results_mutex;",
      "95:   condition_variable results_cond;",
      "96:   mutex next_que_mutex;",
      "97:   condition_variable next_que_cond;",
      "98:   while (!dir_q.empty()) {",
      "99:     next_dir_q.clear();",
      "100:     std::vector<Status> new_rets(dir_q.size());",
      "101:     auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,",
      "102:                          &is_directory, &dirs, &results_mutex, &results_cond,",
      "103:                          &next_que_mutex, &next_que_cond](int i) {",
      "104:       string current_dir = dir_q.at(i).first;",
      "105:       int dir_index = dir_q.at(i).second;",
      "106:       dir_index++;",
      "107:       std::vector<string> children;",
      "108:       Status s = fs->GetChildren(current_dir, &children);",
      "113:       new_rets[i] = s;",
      "114:       if (children.empty()) return;",
      "120:       std::vector<Status> children_dir_status;",
      "123:       children_dir_status.resize(children.size());",
      "124:       auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,",
      "125:                               is_directory, &children_dir_status](int j) {",
      "126:         const string child_path = io::JoinPath(current_dir, children[j]);",
      "127:         if (!fs->Match(child_path, dirs[dir_index])) {",
      "128:           children_dir_status[j] =",
      "130:         } else if (dir_index != dirs.size() - 1) {",
      "131:           children_dir_status[j] = fs->IsDirectory(child_path);",
      "133:           children_dir_status[j] =",
      "134:               is_directory ? fs->IsDirectory(child_path) : Status::OK();",
      "139:       for (size_t j = 0; j < children.size(); ++j) {",
      "140:         const string child_path = io::JoinPath(current_dir, children[j]);",
      "142:         if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {",
      "145:         if (children_dir_status[j].ok()) {",
      "146:           if (dir_index != dirs.size() - 1) {",
      "147:             mutex_lock lk(next_que_mutex);",
      "148:             next_dir_q.emplace_back(std::make_pair(child_path, dir_index));",
      "149:             next_que_cond.notify_one();",
      "150:           } else {",
      "151:             mutex_lock lk(results_mutex);",
      "152:             results->emplace_back(child_path);",
      "153:             results_cond.notify_one();",
      "154:           }",
      "158:     ForEach(0, dir_q.size(), handle_level);",
      "160:     ret.Update(new_rets[dir_q.size() - 1]);",
      "161:     std::swap(dir_q, next_dir_q);",
      "163:   return ret;",
      "",
      "[Added Lines]",
      "56: static const char kGlobbingChars[] = \"*?[\\\\\";",
      "58: static inline bool IsGlobbingPattern(const std::string& pattern) {",
      "59:   return (pattern.find_first_of(kGlobbingChars) != std::string::npos);",
      "60: }",
      "65: static std::string PatchPattern(const std::string& pattern) {",
      "66:   const std::string fixed_prefix =",
      "67:       pattern.substr(0, pattern.find_first_of(kGlobbingChars));",
      "70:   if (io::Dirname(fixed_prefix).empty()) {",
      "71:     return io::JoinPath(\".\", pattern);",
      "72:   }",
      "75:   return pattern;",
      "76: }",
      "78: static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {",
      "79:   std::vector<std::string> dirs;",
      "80:   const std::string patched = PatchPattern(d);",
      "81:   StringPiece dir(patched);",
      "86:   bool is_directory = d[d.size() - 1] == '/';",
      "87: #ifdef PLATFORM_WINDOWS",
      "88:   is_directory = is_directory || (d[d.size() - 1] == '\\\\');",
      "89: #endif",
      "90:   if (is_directory) {",
      "91:     dir = io::Dirname(dir);",
      "92:   }",
      "94:   while (!dir.empty()) {",
      "95:     dirs.emplace_back(dir);",
      "96:     StringPiece new_dir(io::Dirname(dir));",
      "100:     if (dir == new_dir) break;",
      "101:     dir = new_dir;",
      "102:   }",
      "105:   std::reverse(dirs.begin(), dirs.end());",
      "107:   return dirs;",
      "108: }",
      "110: static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {",
      "111:   int i = 0;",
      "112:   for (const auto& d : dirs) {",
      "113:     if (IsGlobbingPattern(d)) {",
      "114:       break;",
      "115:     }",
      "116:     i++;",
      "117:   }",
      "118:   return i;",
      "119: }",
      "126:   if (fs == nullptr || env == nullptr || results == nullptr) {",
      "127:     return Status(tensorflow::error::INVALID_ARGUMENT,",
      "128:                   \"Filesystem calls GetMatchingPaths with nullptr arguments\");",
      "129:   }",
      "144:   std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);",
      "149:   int matching_index = GetFirstGlobbingEntry(dirs);",
      "153:   if (matching_index == dirs.size()) {",
      "154:     if (fs->FileExists(pattern).ok()) {",
      "155:       results->emplace_back(pattern);",
      "156:     }",
      "157:     return Status::OK();",
      "182:   std::deque<std::pair<string, int>> expand_queue;",
      "183:   std::deque<std::pair<string, int>> next_expand_queue;",
      "184:   expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);",
      "188:   mutex result_mutex;",
      "189:   mutex queue_mutex;",
      "191:   while (!expand_queue.empty()) {",
      "192:     next_expand_queue.clear();",
      "196:     auto handle_level = [&fs, &results, &dirs, &expand_queue,",
      "197:                          &next_expand_queue, &result_mutex,",
      "198:                          &queue_mutex](int i) {",
      "200:       const auto& queue_item = expand_queue.at(i);",
      "201:       const std::string& parent = queue_item.first;",
      "202:       const int index = queue_item.second + 1;",
      "203:       const std::string& match_pattern = dirs[index];",
      "206:       std::vector<std::string> children;",
      "207:       Status s = fs->GetChildren(parent, &children);",
      "213:       if (children.empty()) {",
      "214:         return;",
      "215:       }",
      "222:       std::vector<Status> children_status(children.size());",
      "223:       auto handle_children = [&fs, &match_pattern, &parent, &children,",
      "224:                               &children_status](int j) {",
      "225:         const std::string path = io::JoinPath(parent, children[j]);",
      "226:         if (!fs->Match(path, match_pattern)) {",
      "227:           children_status[j] =",
      "230:           children_status[j] = fs->IsDirectory(path);",
      "244:       for (size_t j = 0; j < children.size(); j++) {",
      "245:         if (children_status[j].code() == tensorflow::error::CANCELLED) {",
      "249:         const std::string path = io::JoinPath(parent, children[j]);",
      "250:         if (index == dirs.size() - 1) {",
      "251:           mutex_lock l(result_mutex);",
      "252:           results->emplace_back(path);",
      "253:         } else if (children_status[j].ok()) {",
      "254:           mutex_lock l(queue_mutex);",
      "255:           next_expand_queue.emplace_back(path, index);",
      "259:     ForEach(0, expand_queue.size(), handle_level);",
      "262:     std::swap(expand_queue, next_expand_queue);",
      "265:   return Status::OK();",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "044f4b85fa1531807ec41fd3f1ca9218aaea9679",
      "candidate_info": {
        "commit_hash": "044f4b85fa1531807ec41fd3f1ca9218aaea9679",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/044f4b85fa1531807ec41fd3f1ca9218aaea9679",
        "files": [
          "tensorflow/core/platform/file_system_helper.cc"
        ],
        "message": "Merge pull request #40861 from zhuzilin:fix_matching_files\n\nPiperOrigin-RevId: 319434874\nChange-Id: Ief4865c5446c6044c6072fb9eaf8556d3ba2c04a",
        "before_after_code_files": [
          "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ],
          "candidate": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
          "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,",
          "56:                         std::vector<string>* results) {",
          "57:   results->clear();",
          "59:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
          "60:   string eval_pattern = pattern;",
          "62:   string dir(io::Dirname(fixed_prefix));",
          "65:   if (dir.empty()) {",
          "66:     dir = \".\";",
          "67:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
          "69:   }",
          "74:   Status ret;  // Status to return.",
          "",
          "[Removed Lines]",
          "61:   std::vector<string> all_files;",
          "68:     eval_pattern = io::JoinPath(dir, pattern);",
          "72:   std::deque<string> dir_q;",
          "73:   dir_q.push_back(dir);",
          "",
          "[Added Lines]",
          "58:   if (pattern.empty()) {",
          "59:     return Status::OK();",
          "60:   }",
          "70:     eval_pattern = io::JoinPath(dir, eval_pattern);",
          "72:   bool is_directory = pattern[pattern.size() - 1] == '/';",
          "73: #ifdef PLATFORM_WINDOWS",
          "74:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
          "75: #endif",
          "76:   std::vector<string> dirs;",
          "77:   if (!is_directory) {",
          "78:     dirs.push_back(eval_pattern);",
          "79:   }",
          "80:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
          "81:   while (tmp_dir.size() > dir.size()) {",
          "82:     dirs.push_back(string(tmp_dir));",
          "83:     tmp_dir = io::Dirname(tmp_dir);",
          "84:   }",
          "85:   dirs.push_back(dir);",
          "86:   std::reverse(dirs.begin(), dirs.end());",
          "88:   std::deque<std::pair<string, int>> dir_q;",
          "89:   dir_q.push_back({dirs[0], 0});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:   std::vector<Status> children_dir_status;",
          "80:   while (!dir_q.empty()) {",
          "82:     dir_q.pop_front();",
          "83:     std::vector<string> children;",
          "84:     Status s = fs->GetChildren(current_dir, &children);",
          "",
          "[Removed Lines]",
          "81:     string current_dir = dir_q.front();",
          "",
          "[Added Lines]",
          "97:     string current_dir = dir_q.front().first;",
          "98:     int dir_index = dir_q.front().second;",
          "99:     dir_index++;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:     children_dir_status.resize(children.size());",
          "93:     ForEach(0, children.size(),",
          "95:              &children_dir_status](int i) {",
          "96:               const string child_path = io::JoinPath(current_dir, children[i]);",
          "100:                 children_dir_status[i] = Status(tensorflow::error::CANCELLED,",
          "101:                                                 \"Operation not needed\");",
          "103:                 children_dir_status[i] = fs->IsDirectory(child_path);",
          "104:               }",
          "105:             });",
          "106:     for (size_t i = 0; i < children.size(); ++i) {",
          "",
          "[Removed Lines]",
          "94:             [fs, &current_dir, &children, &fixed_prefix,",
          "99:               if (!absl::StartsWith(child_path, fixed_prefix)) {",
          "102:               } else {",
          "",
          "[Added Lines]",
          "112:             [fs, &current_dir, &children, &dirs, dir_index, is_directory,",
          "115:               if (!fs->Match(child_path, dirs[dir_index])) {",
          "118:               } else if (dir_index != dirs.size() - 1) {",
          "120:               } else {",
          "121:                 children_dir_status[i] =",
          "122:                     is_directory ? fs->IsDirectory(child_path) : Status::OK();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "109:       if (children_dir_status[i].code() == tensorflow::error::CANCELLED) {",
          "110:         continue;",
          "111:       }",
          "113:       if (children_dir_status[i].ok()) {",
          "115:       }",
          "124:     }",
          "125:   }",
          "126:   return ret;",
          "",
          "[Removed Lines]",
          "114:         dir_q.push_back(child_path);",
          "116:       all_files.push_back(child_path);",
          "117:     }",
          "118:   }",
          "121:   for (const auto& f : all_files) {",
          "122:     if (fs->Match(f, eval_pattern)) {",
          "123:       results->push_back(f);",
          "",
          "[Added Lines]",
          "132:         if (dir_index != dirs.size() - 1) {",
          "133:           dir_q.push_back({child_path, dir_index});",
          "134:         } else {",
          "135:           results->push_back(child_path);",
          "136:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "18d54d15864eaa8b163183786d05c6bd8b47ba28",
      "candidate_info": {
        "commit_hash": "18d54d15864eaa8b163183786d05c6bd8b47ba28",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/18d54d15864eaa8b163183786d05c6bd8b47ba28",
        "files": [
          "tensorflow/core/platform/file_system_helper.cc"
        ],
        "message": "Completely rewrite `GetMatchingPaths`.\n\nThe current parallel implementation is too complex (lambda inside lambda, two levels of parallelism) and has a read outside of bounds issue.\n\nThe new implementation cleans up artifacts from the previous implementations that were left in the code as it evolves. We add multiple helper functions, and document invariants and preconditions as well as every major step. This way, we fix the security issue and a potential new one which was not caught before\n\nPiperOrigin-RevId: 346146220\nChange-Id: Iec0f44673f43349797bf9944dffe9b2f779137d8",
        "before_after_code_files": [
          "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ],
          "candidate": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
          "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include <string>",
          "20: #include <vector>",
          "22: #include \"tensorflow/core/platform/env.h\"",
          "23: #include \"tensorflow/core/platform/file_system.h\"",
          "24: #include \"tensorflow/core/platform/path.h\"",
          "25: #include \"tensorflow/core/platform/platform.h\"",
          "26: #include \"tensorflow/core/platform/status.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"tensorflow/core/platform/cpu_info.h\"",
          "25: #include \"tensorflow/core/platform/mutex.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33: namespace {",
          "",
          "[Removed Lines]",
          "35: constexpr int kNumThreads = 8;",
          "",
          "[Added Lines]",
          "37: const int kNumThreads = port::NumSchedulableCPUs();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "50: #endif",
          "51: }",
          "53: }  // namespace",
          "55: Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,",
          "56:                         std::vector<string>* results) {",
          "57:   results->clear();",
          "58:   if (pattern.empty()) {",
          "59:     return Status::OK();",
          "60:   }",
          "106:     }",
          "130:       }",
          "134:         } else {",
          "136:         }",
          "137:       }",
          "139:   }",
          "141: }",
          "143: }  // namespace internal",
          "",
          "[Removed Lines]",
          "62:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
          "63:   string eval_pattern = pattern;",
          "64:   string dir(io::Dirname(fixed_prefix));",
          "67:   if (dir.empty()) {",
          "68:     dir = \".\";",
          "69:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
          "70:     eval_pattern = io::JoinPath(dir, eval_pattern);",
          "71:   }",
          "72:   bool is_directory = pattern[pattern.size() - 1] == '/';",
          "73: #ifdef PLATFORM_WINDOWS",
          "74:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
          "75: #endif",
          "76:   std::vector<string> dirs;",
          "77:   if (!is_directory) {",
          "78:     dirs.push_back(eval_pattern);",
          "79:   }",
          "80:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
          "81:   while (tmp_dir.size() > dir.size()) {",
          "82:     dirs.push_back(string(tmp_dir));",
          "83:     tmp_dir = io::Dirname(tmp_dir);",
          "84:   }",
          "85:   dirs.push_back(dir);",
          "86:   std::reverse(dirs.begin(), dirs.end());",
          "88:   std::deque<std::pair<string, int>> dir_q;",
          "89:   dir_q.push_back({dirs[0], 0});",
          "90:   Status ret;  // Status to return.",
          "95:   std::vector<Status> children_dir_status;",
          "96:   while (!dir_q.empty()) {",
          "97:     string current_dir = dir_q.front().first;",
          "98:     int dir_index = dir_q.front().second;",
          "99:     dir_index++;",
          "100:     dir_q.pop_front();",
          "101:     std::vector<string> children;",
          "102:     Status s = fs->GetChildren(current_dir, &children);",
          "104:     if (s.code() == tensorflow::error::PERMISSION_DENIED) {",
          "105:       continue;",
          "107:     ret.Update(s);",
          "108:     if (children.empty()) continue;",
          "110:     children_dir_status.resize(children.size());",
          "111:     ForEach(0, children.size(),",
          "112:             [fs, &current_dir, &children, &dirs, dir_index, is_directory,",
          "113:              &children_dir_status](int i) {",
          "114:               const string child_path = io::JoinPath(current_dir, children[i]);",
          "115:               if (!fs->Match(child_path, dirs[dir_index])) {",
          "116:                 children_dir_status[i] = Status(tensorflow::error::CANCELLED,",
          "117:                                                 \"Operation not needed\");",
          "118:               } else if (dir_index != dirs.size() - 1) {",
          "119:                 children_dir_status[i] = fs->IsDirectory(child_path);",
          "120:               } else {",
          "121:                 children_dir_status[i] =",
          "122:                     is_directory ? fs->IsDirectory(child_path) : Status::OK();",
          "123:               }",
          "124:             });",
          "125:     for (size_t i = 0; i < children.size(); ++i) {",
          "126:       const string child_path = io::JoinPath(current_dir, children[i]);",
          "128:       if (children_dir_status[i].code() == tensorflow::error::CANCELLED) {",
          "129:         continue;",
          "131:       if (children_dir_status[i].ok()) {",
          "132:         if (dir_index != dirs.size() - 1) {",
          "133:           dir_q.push_back({child_path, dir_index});",
          "135:           results->push_back(child_path);",
          "138:     }",
          "140:   return ret;",
          "",
          "[Added Lines]",
          "56: static const char kGlobbingChars[] = \"*?[\\\\\";",
          "58: static inline bool IsGlobbingPattern(const std::string& pattern) {",
          "59:   return (pattern.find_first_of(kGlobbingChars) != std::string::npos);",
          "60: }",
          "65: static std::string PatchPattern(const std::string& pattern) {",
          "66:   const std::string fixed_prefix =",
          "67:       pattern.substr(0, pattern.find_first_of(kGlobbingChars));",
          "70:   if (io::Dirname(fixed_prefix).empty()) {",
          "71:     return io::JoinPath(\".\", pattern);",
          "72:   }",
          "75:   return pattern;",
          "76: }",
          "78: static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {",
          "79:   std::vector<std::string> dirs;",
          "80:   const std::string patched = PatchPattern(d);",
          "81:   StringPiece dir(patched);",
          "86:   bool is_directory = d[d.size() - 1] == '/';",
          "87: #ifdef PLATFORM_WINDOWS",
          "88:   is_directory = is_directory || (d[d.size() - 1] == '\\\\');",
          "89: #endif",
          "90:   if (is_directory) {",
          "91:     dir = io::Dirname(dir);",
          "92:   }",
          "94:   while (!dir.empty()) {",
          "95:     dirs.emplace_back(dir);",
          "96:     StringPiece new_dir(io::Dirname(dir));",
          "100:     if (dir == new_dir) break;",
          "101:     dir = new_dir;",
          "102:   }",
          "105:   std::reverse(dirs.begin(), dirs.end());",
          "107:   return dirs;",
          "108: }",
          "110: static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {",
          "111:   int i = 0;",
          "112:   for (const auto& d : dirs) {",
          "113:     if (IsGlobbingPattern(d)) {",
          "114:       break;",
          "115:     }",
          "116:     i++;",
          "117:   }",
          "118:   return i;",
          "119: }",
          "126:   if (fs == nullptr || env == nullptr || results == nullptr) {",
          "127:     return Status(tensorflow::error::INVALID_ARGUMENT,",
          "128:                   \"Filesystem calls GetMatchingPaths with nullptr arguments\");",
          "129:   }",
          "144:   std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);",
          "149:   int matching_index = GetFirstGlobbingEntry(dirs);",
          "153:   if (matching_index == dirs.size()) {",
          "154:     if (fs->FileExists(pattern).ok()) {",
          "155:       results->emplace_back(pattern);",
          "157:     return Status::OK();",
          "158:   }",
          "182:   std::deque<std::pair<string, int>> expand_queue;",
          "183:   std::deque<std::pair<string, int>> next_expand_queue;",
          "184:   expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);",
          "188:   mutex result_mutex;",
          "189:   mutex queue_mutex;",
          "191:   while (!expand_queue.empty()) {",
          "192:     next_expand_queue.clear();",
          "196:     auto handle_level = [&fs, &results, &dirs, &expand_queue,",
          "197:                          &next_expand_queue, &result_mutex,",
          "198:                          &queue_mutex](int i) {",
          "200:       const auto& queue_item = expand_queue.at(i);",
          "201:       const std::string& parent = queue_item.first;",
          "202:       const int index = queue_item.second + 1;",
          "203:       const std::string& match_pattern = dirs[index];",
          "206:       std::vector<std::string> children;",
          "207:       Status s = fs->GetChildren(parent, &children);",
          "208:       if (s.code() == tensorflow::error::PERMISSION_DENIED) {",
          "209:         return;",
          "210:       }",
          "213:       if (children.empty()) {",
          "214:         return;",
          "222:       std::vector<Status> children_status(children.size());",
          "223:       auto handle_children = [&fs, &match_pattern, &parent, &children,",
          "224:                               &children_status](int j) {",
          "225:         const std::string path = io::JoinPath(parent, children[j]);",
          "226:         if (!fs->Match(path, match_pattern)) {",
          "227:           children_status[j] =",
          "228:               Status(tensorflow::error::CANCELLED, \"Operation not needed\");",
          "230:           children_status[j] = fs->IsDirectory(path);",
          "231:         }",
          "232:       };",
          "233:       ForEach(0, children.size(), handle_children);",
          "244:       for (size_t j = 0; j < children.size(); j++) {",
          "245:         if (children_status[j].code() == tensorflow::error::CANCELLED) {",
          "246:           continue;",
          "247:         }",
          "249:         const std::string path = io::JoinPath(parent, children[j]);",
          "250:         if (index == dirs.size() - 1) {",
          "251:           mutex_lock l(result_mutex);",
          "252:           results->emplace_back(path);",
          "253:         } else if (children_status[j].ok()) {",
          "254:           mutex_lock l(queue_mutex);",
          "255:           next_expand_queue.emplace_back(path, index);",
          "258:     };",
          "259:     ForEach(0, expand_queue.size(), handle_level);",
          "262:     std::swap(expand_queue, next_expand_queue);",
          "265:   return Status::OK();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
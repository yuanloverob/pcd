{
  "cve_id": "CVE-2016-5691",
  "cve_desc": "The DCM reader in ImageMagick before 6.9.4-5 and 7.x before 7.0.1-7 allows remote attackers to have unspecified impact by leveraging lack of validation of (1) pixel.red, (2) pixel.green, and (3) pixel.blue.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "5511ef530576ed18fd636baa3bb4eda3d667665d",
  "patch_info": {
    "commit_hash": "5511ef530576ed18fd636baa3bb4eda3d667665d",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/5511ef530576ed18fd636baa3bb4eda3d667665d",
    "files": [
      "ChangeLog",
      "coders/dcm.c"
    ],
    "message": "Add additional checks to DCM reader to prevent data-driven faults (bug report from Hanno B\u00f6ck",
    "before_after_code_files": [
      "coders/dcm.c||coders/dcm.c"
    ]
  },
  "patch_diff": {
    "coders/dcm.c||coders/dcm.c": [
      "File: coders/dcm.c -> coders/dcm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3216:             break;",
      "3217:           }",
      "3218:           case 0x0004:",
      "3219:           {",
      "3221:               Photometric interpretation.",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3219:           {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3237:             break;",
      "3238:           }",
      "3239:           case 0x0008:",
      "3240:           {",
      "3242:               Number of frames.",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3242:           {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3674:         Compute pixel scaling table.",
      "3676:       length=(size_t) (GetQuantumRange(depth)+1);",
      "3678:       if (scale == (Quantum *) NULL)",
      "3679:         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
      "3680:       range=GetQuantumRange(depth);",
      "",
      "[Removed Lines]",
      "3677:       scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));",
      "",
      "[Added Lines]",
      "3681:       scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3965:                     pixel.blue=ReadDCMShort(stream_info,image);",
      "3966:                   }",
      "3967:                 pixel.red&=mask;",
      "3971:                   {",
      "3972:                     pixel.red=scale[pixel.red];",
      "3973:                     pixel.green=scale[pixel.green];",
      "",
      "[Removed Lines]",
      "3968:                 pixel.green&=mask;",
      "3969:                 pixel.blue&=mask;",
      "3970:                 if (scale != (Quantum *) NULL)",
      "",
      "[Added Lines]",
      "3972:                 pixel.green&=mask;",
      "3973:                 pixel.blue&=mask;",
      "3974:                 if (scale != (Quantum *) NULL)",
      "3975:                   {",
      "3976:                     if (pixel.red <= GetQuantumRange(depth))",
      "3977:                       pixel.red=scale[pixel.red];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3c57527b28494cd7807f071bd6c4d5ad75ba6ebb",
      "candidate_info": {
        "commit_hash": "3c57527b28494cd7807f071bd6c4d5ad75ba6ebb",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/3c57527b28494cd7807f071bd6c4d5ad75ba6ebb",
        "files": [
          "coders/dcm.c"
        ],
        "message": "Refactored reading DCM pixels.",
        "before_after_code_files": [
          "coders/dcm.c||coders/dcm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/dcm.c||coders/dcm.c"
          ],
          "candidate": [
            "coders/dcm.c||coders/dcm.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/dcm.c||coders/dcm.c": [
          "File: coders/dcm.c -> coders/dcm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2675: %  A description of each parameter follows:",
          "2676: %",
          "2677: %    o image_info: the image info.",
          "2678: %",
          "2679: %    o exception: return any errors or warnings in this structure.",
          "2680: %",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2678: %",
          "2679: %    o exception: return any errors or warnings in this structure.",
          "2680: %",
          "2682: typedef struct _DCMInfo",
          "2683: {",
          "2684:   MagickBooleanType",
          "2685:     polarity;",
          "2687:   Quantum",
          "2690:   size_t",
          "2691:     bits_allocated,",
          "2692:     bytes_per_pixel,",
          "2693:     depth,",
          "2694:     mask,",
          "2695:     max_value,",
          "2696:     samples_per_pixel,",
          "2697:     signed_data,",
          "2698:     significant_bits,",
          "2699:     window_width;",
          "2701:   ssize_t",
          "2702:     rescale_intercept,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2776:       signed_value;",
          "2777:   } quantum;",
          "2779:   quantum.unsigned_value=ReadDCMShort(stream_info,image);",
          "2780:   return(quantum.signed_value);",
          "2781: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2804:   quantum.unsigned_value=ReadDCMShort(stream_info,image);",
          "2805:   return(quantum.signed_value);",
          "2806: }",
          "2808: static MagickBooleanType ReadDCMPixels(Image *image,DCMInfo *info,",
          "2809:   DCMStreamInfo *stream_info,MagickBooleanType first_segment,",
          "2810:   ExceptionInfo *exception)",
          "2811: {",
          "2812:   int",
          "2813:     byte,",
          "2814:     index;",
          "2816:   MagickBooleanType",
          "2817:     status;",
          "2819:   PixelPacket",
          "2820:     pixel;",
          "2822:   register ssize_t",
          "2823:     i,",
          "2824:     x;",
          "2826:   register Quantum",
          "2829:   ssize_t",
          "2830:     y;",
          "2833:     Convert DCM Medical image to pixel packets.",
          "2835:   byte=0;",
          "2836:   i=0;",
          "2837:   status=MagickTrue;",
          "2838:   (void) ResetMagickMemory(&pixel,0,sizeof(pixel));",
          "2839:   for (y=0; y < (ssize_t) image->rows; y++)",
          "2840:   {",
          "2841:     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);",
          "2842:     if (q == (Quantum *) NULL)",
          "2843:       break;",
          "2844:     for (x=0; x < (ssize_t) image->columns; x++)",
          "2845:     {",
          "2846:       if (info->samples_per_pixel == 1)",
          "2847:         {",
          "2848:           int",
          "2849:             pixel_value;",
          "2851:           if (info->bytes_per_pixel == 1)",
          "2852:             pixel_value=info->polarity != MagickFalse ?",
          "2853:               ((int) info->max_value-ReadDCMByte(stream_info,image)) :",
          "2854:               ReadDCMByte(stream_info,image);",
          "2855:           else",
          "2856:             if ((info->bits_allocated != 12) || (info->significant_bits != 12))",
          "2857:               {",
          "2858:                 if (info->signed_data)",
          "2859:                   pixel_value=ReadDCMSignedShort(stream_info,image);",
          "2860:                 else",
          "2861:                   pixel_value=ReadDCMShort(stream_info,image);",
          "2862:                 if (info->polarity != MagickFalse)",
          "2863:                   pixel_value=(int)info->max_value-pixel_value;",
          "2864:               }",
          "2865:             else",
          "2866:               {",
          "2867:                 if ((i & 0x01) != 0)",
          "2868:                   pixel_value=(ReadDCMByte(stream_info,image) << 8) |",
          "2869:                     byte;",
          "2870:                 else",
          "2871:                   {",
          "2872:                     pixel_value=ReadDCMSignedShort(stream_info,image);",
          "2873:                     byte=(int) (pixel_value & 0x0f);",
          "2874:                     pixel_value>>=4;",
          "2875:                   }",
          "2876:                 i++;",
          "2877:               }",
          "2878:           index=(pixel_value*info->rescale_slope)+info->rescale_intercept;",
          "2879:           if (info->window_width == 0)",
          "2880:             {",
          "2881:               if (info->signed_data == 1)",
          "2882:                 index-=32767;",
          "2883:             }",
          "2884:           else",
          "2885:             {",
          "2886:               ssize_t",
          "2887:                 window_max,",
          "2888:                 window_min;",
          "2890:               window_min=(ssize_t) ceil((double) info->window_center-",
          "2891:                 (info->window_width-1.0)/2.0-0.5);",
          "2892:               window_max=(ssize_t) floor((double) info->window_center+",
          "2893:                 (info->window_width-1.0)/2.0+0.5);",
          "2894:               if ((ssize_t)index <= window_min)",
          "2895:                 index=0;",
          "2896:               else",
          "2897:                 if ((ssize_t)index > window_max)",
          "2898:                   index=(int) info->max_value;",
          "2899:                 else",
          "2900:                   index=(int) (info->max_value*(((index-info->window_center-",
          "2901:                     0.5)/(info->window_width-1))+0.5));",
          "2902:             }",
          "2903:           index&=info->mask;",
          "2904:           index=(int) ConstrainColormapIndex(image,(size_t) index,exception);",
          "2905:           if (first_segment)",
          "2906:             SetPixelIndex(image,(Quantum) index,q);",
          "2907:           else",
          "2908:             SetPixelIndex(image,(Quantum) (((size_t) GetPixelIndex(image,q)) |",
          "2909:               (((size_t) index) << 8)),q);",
          "2910:           pixel.red=(unsigned int) image->colormap[index].red;",
          "2911:           pixel.green=(unsigned int) image->colormap[index].green;",
          "2912:           pixel.blue=(unsigned int) image->colormap[index].blue;",
          "2913:         }",
          "2914:       else",
          "2915:         {",
          "2916:           if (info->bytes_per_pixel == 1)",
          "2917:             {",
          "2918:               pixel.red=(unsigned int) ReadDCMByte(stream_info,image);",
          "2919:               pixel.green=(unsigned int) ReadDCMByte(stream_info,image);",
          "2920:               pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);",
          "2921:             }",
          "2922:           else",
          "2923:             {",
          "2924:               pixel.red=ReadDCMShort(stream_info,image);",
          "2925:               pixel.green=ReadDCMShort(stream_info,image);",
          "2926:               pixel.blue=ReadDCMShort(stream_info,image);",
          "2927:             }",
          "2928:           pixel.red&=info->mask;",
          "2929:           pixel.green&=info->mask;",
          "2930:           pixel.blue&=info->mask;",
          "2931:           if (info->scale != (Quantum *) NULL)",
          "2932:             {",
          "2933:               if (pixel.red <= GetQuantumRange(info->depth))",
          "2934:                 pixel.red=info->scale[pixel.red];",
          "2935:               if (pixel.green <= GetQuantumRange(info->depth))",
          "2936:                 pixel.green=info->scale[pixel.green];",
          "2937:               if (pixel.blue <= GetQuantumRange(info->depth))",
          "2938:                 pixel.blue=info->scale[pixel.blue];",
          "2939:             }",
          "2940:         }",
          "2941:       if (first_segment != MagickFalse)",
          "2942:         {",
          "2943:           SetPixelRed(image,(Quantum) pixel.red,q);",
          "2944:           SetPixelGreen(image,(Quantum) pixel.green,q);",
          "2945:           SetPixelBlue(image,(Quantum) pixel.blue,q);",
          "2946:         }",
          "2947:       else",
          "2948:         {",
          "2949:           SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |",
          "2950:             (((size_t) pixel.red) << 8)),q);",
          "2951:           SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |",
          "2952:             (((size_t) pixel.green) << 8)),q);",
          "2953:           SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |",
          "2954:             (((size_t) pixel.blue) << 8)),q);",
          "2955:         }",
          "2956:       q+=GetPixelChannels(image);",
          "2957:     }",
          "2958:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2959:       break;",
          "2960:     if (image->previous == (Image *) NULL)",
          "2961:       {",
          "2962:         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,",
          "2963:           image->rows);",
          "2964:         if (status == MagickFalse)",
          "2965:           break;",
          "2966:       }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2784: {",
          "2785:   char",
          "2786:     explicit_vr[MagickPathExtent],",
          "2787:     implicit_vr[MagickPathExtent],",
          "2788:     magick[MagickPathExtent],",
          "2789:     photometric[MagickPathExtent];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2975:     implicit_vr[MagickPathExtent],",
          "2976:     magick[MagickPathExtent],",
          "2977:     photometric[MagickPathExtent];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2797:   int",
          "2799:     datum,",
          "2802:     index,",
          "2805:   MagickBooleanType",
          "2806:     explicit_file,",
          "2807:     explicit_retry,",
          "2808:     polarity,",
          "2809:     sequence,",
          "2810:     use_explicit;",
          "2822:   register Quantum",
          "2829:     bits_allocated,",
          "2830:     bytes_per_pixel,",
          "2833:     height,",
          "2834:     length,",
          "2838:     quantum,",
          "2841:     significant_bits,",
          "2842:     status,",
          "2843:     width,",
          "2849:     rescale_slope,",
          "2850:     scene,",
          "2851:     window_center,",
          "",
          "[Removed Lines]",
          "2812:   MagickOffsetType",
          "2813:     offset;",
          "2815:   Quantum",
          "2818:   register ssize_t",
          "2819:     i,",
          "2820:     x;",
          "2825:   register unsigned char",
          "2828:   size_t",
          "2831:     colors,",
          "2832:     depth,",
          "2835:     mask,",
          "2836:     max_value,",
          "2837:     number_scenes,",
          "2839:     samples_per_pixel,",
          "2840:     signed_data,",
          "2844:     window_width;",
          "2846:   ssize_t",
          "2847:     count,",
          "2848:     rescale_intercept,",
          "",
          "[Added Lines]",
          "3004:   register unsigned char",
          "3013:     length,",
          "3017:     width;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2894:       if (offset < 0)",
          "2895:         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "2896:     }",
          "2900:   (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);",
          "2902:   bytes_per_pixel=1;",
          "2903:   polarity=MagickFalse;",
          "2904:   data=(unsigned char *) NULL;",
          "",
          "[Removed Lines]",
          "2898:     Read DCM Medical image.",
          "2901:   bits_allocated=8;",
          "",
          "[Added Lines]",
          "3067:     Read DCM Medical image.",
          "3069:   (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);",
          "3070:   info.bits_allocated=8;",
          "3071:   info.bytes_per_pixel=1;",
          "3072:   info.depth=8;",
          "3073:   info.max_value=255UL;",
          "3074:   info.mask=0xffff;",
          "3075:   info.polarity=MagickFalse;",
          "3076:   info.rescale_intercept=0;",
          "3077:   info.rescale_slope=1;",
          "3078:   info.samples_per_pixel=1;",
          "3079:   info.scale=(Quantum *) NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2908:   explicit_file=MagickFalse;",
          "2909:   colors=0;",
          "2910:   redmap=(int *) NULL;",
          "2913:   graymap=(int *) NULL;",
          "2918:   rescale_intercept=0;",
          "2921:   scale=(Quantum *) NULL;",
          "2922:   sequence=MagickFalse;",
          "2923:   signed_data=(~0UL);",
          "2926:   explicit_retry = MagickFalse;",
          "2927:   width=0;",
          "2928:   window_center=0;",
          "",
          "[Removed Lines]",
          "2911:   greenmap=(int *) NULL;",
          "2912:   bluemap=(int *) NULL;",
          "2914:   height=0;",
          "2915:   max_value=255UL;",
          "2916:   mask=0xffff;",
          "2917:   number_scenes=1;",
          "2919:   rescale_slope=1;",
          "2920:   samples_per_pixel=1;",
          "2924:   significant_bits=0;",
          "2925:   use_explicit=MagickFalse;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3208:         switch (element)",
          "3209:         {",
          "3210:           case 0x0002:",
          "3213:               Samples per pixel.",
          "",
          "[Removed Lines]",
          "3211:           {",
          "",
          "[Added Lines]",
          "3380:           {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3221:               Photometric interpretation.",
          "3223:             if (data == (unsigned char *) NULL)",
          "3225:             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)",
          "3226:               photometric[i]=(char) data[i];",
          "3227:             photometric[i]='\\0';",
          "",
          "[Removed Lines]",
          "3224:               break;",
          "",
          "[Added Lines]",
          "3393:               break;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3265:             break;",
          "3266:           }",
          "3267:           case 0x0100:",
          "3270:               Bits allocated.",
          "3274:             if (datum > 8)",
          "3276:             depth=bits_allocated;",
          "3277:             if (depth > 32)",
          "3278:               ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "",
          "[Removed Lines]",
          "3268:           {",
          "3272:             bits_allocated=(size_t) datum;",
          "3273:             bytes_per_pixel=1;",
          "3275:               bytes_per_pixel=2;",
          "",
          "[Added Lines]",
          "3437:           {",
          "3441:             info.bits_allocated=(size_t) datum;",
          "3442:             info.bytes_per_pixel=1;",
          "3444:               info.bytes_per_pixel=2;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3280:             break;",
          "3281:           }",
          "3282:           case 0x0101:",
          "3289:             if (significant_bits > 8)",
          "3292:             if (depth > 32)",
          "3293:               ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "3294:             max_value=(1UL << significant_bits)-1;",
          "",
          "[Removed Lines]",
          "3283:           {",
          "3285:               Bits stored.",
          "3287:             significant_bits=(size_t) datum;",
          "3288:             bytes_per_pixel=1;",
          "3290:               bytes_per_pixel=2;",
          "3291:             depth=significant_bits;",
          "",
          "[Added Lines]",
          "3452:           {",
          "3454:               Bits stored.",
          "3456:             info.significant_bits=(size_t) datum;",
          "3457:             info.bytes_per_pixel=1;",
          "3459:               info.bytes_per_pixel=2;",
          "3460:             info.depth=info.significant_bits;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3303:             break;",
          "3304:           }",
          "3305:           case 0x0103:",
          "3308:               Pixel representation.",
          "",
          "[Removed Lines]",
          "3306:           {",
          "",
          "[Added Lines]",
          "3475:           {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3312:           }",
          "3313:           case 0x1050:",
          "3314:           {",
          "3316:               Visible pixel range: center.",
          "3318:             if (data != (unsigned char *) NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3321:           }",
          "3322:           case 0x1051:",
          "3323:           {",
          "3325:               Visible pixel range: width.",
          "3327:             if (data != (unsigned char *) NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3330:           }",
          "3331:           case 0x1052:",
          "3332:           {",
          "3334:               Rescale intercept",
          "3336:             if (data != (unsigned char *) NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3339:           }",
          "3340:           case 0x1053:",
          "3341:           {",
          "3343:               Rescale slope",
          "3345:             if (data != (unsigned char *) NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3350:           case 0x3006:",
          "3351:           {",
          "3355:             if (data == (unsigned char *) NULL)",
          "3356:               break;",
          "3357:             colors=(size_t) (length/bytes_per_pixel);",
          "3358:             datum=(int) colors;",
          "3359:             graymap=(int *) AcquireQuantumMemory((size_t) colors,",
          "3361:             if (graymap == (int *) NULL)",
          "3362:               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3363:             for (i=0; i < (ssize_t) colors; i++)",
          "",
          "[Removed Lines]",
          "3353:               Populate graymap.",
          "3360:               sizeof(*graymap));",
          "",
          "[Added Lines]",
          "3522:               Populate graymap.",
          "3529:               sizeof(*graymap));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3460:       {",
          "3461:         switch (element)",
          "3462:         {",
          "3464:           {",
          "3465:             if ((data != (unsigned char *) NULL) &&",
          "3466:                 (strncmp((char *) data,\"INVERSE\",7) == 0))",
          "",
          "[Removed Lines]",
          "3463:           case 0x0020:",
          "",
          "[Added Lines]",
          "3632:           case 0x0020:",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3539:         break;",
          "3540:       }",
          "3541:   }",
          "3544:   image->columns=(size_t) width;",
          "3545:   image->rows=(size_t) height;",
          "3546:   if (signed_data == 0xffff)",
          "",
          "[Removed Lines]",
          "3542:   if ((width == 0) || (height == 0))",
          "3543:     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "",
          "[Added Lines]",
          "3711:   if ((width == 0) || (height == 0))",
          "3712:     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3662:           }",
          "3663:         (void) RelinquishUniqueFileResource(filename);",
          "3664:       }",
          "3666:       image=DestroyImage(image);",
          "3667:       return(GetFirstImageInList(images));",
          "3668:     }",
          "",
          "[Removed Lines]",
          "3665:       read_info=DestroyImageInfo(read_info);",
          "",
          "[Added Lines]",
          "3834:       read_info=DestroyImageInfo(read_info);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3674:       size_t",
          "3675:         length;",
          "3683:         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3684:       range=GetQuantumRange(depth);",
          "3685:       for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)",
          "",
          "[Removed Lines]",
          "3678:         Compute pixel scaling table.",
          "3680:       length=(size_t) (GetQuantumRange(depth)+1);",
          "3681:       scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));",
          "3682:       if (scale == (Quantum *) NULL)",
          "",
          "[Added Lines]",
          "3847:         Compute pixel scaling table.",
          "3849:       length=(size_t) (GetQuantumRange(info.depth)+1);",
          "3850:       info.scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*info.scale));",
          "3851:       if (info.scale == (Quantum *) NULL)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3720:     }",
          "3721:   for (scene=0; scene < (ssize_t) number_scenes; scene++)",
          "3722:   {",
          "3724:       break;",
          "3725:     image->columns=(size_t) width;",
          "3726:     image->rows=(size_t) height;",
          "3727:     image->depth=depth;",
          "3729:     if (status == MagickFalse)",
          "3730:       break;",
          "3731:     image->colorspace=RGBColorspace;",
          "3732:     if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))",
          "3733:       {",
          "3734:         size_t",
          "3737:         one=1;",
          "3738:         if (colors == 0)",
          "3739:           colors=one << depth;",
          "3740:         if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)",
          "3741:           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "3744:           {",
          "3745:             index=redmap[i];",
          "3746:             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))",
          "3747:               index=(int) scale[index];",
          "3748:             image->colormap[i].red=(MagickRealType) index;",
          "3749:           }",
          "3752:           {",
          "3753:             index=greenmap[i];",
          "3754:             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))",
          "3755:               index=(int) scale[index];",
          "3756:             image->colormap[i].green=(MagickRealType) index;",
          "3757:           }",
          "3760:           {",
          "3761:             index=bluemap[i];",
          "3762:             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))",
          "3763:               index=(int) scale[index];",
          "3764:             image->colormap[i].blue=(MagickRealType) index;",
          "3765:           }",
          "3768:           {",
          "3769:             index=graymap[i];",
          "3770:             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))",
          "",
          "[Removed Lines]",
          "3723:     if (image_info->ping != MagickFalse)",
          "3728:     status=SetImageExtent(image,image->columns,image->rows,exception);",
          "3735:           one;",
          "3742:         if (redmap != (int *) NULL)",
          "3743:           for (i=0; i < (ssize_t) colors; i++)",
          "3750:         if (greenmap != (int *) NULL)",
          "3751:           for (i=0; i < (ssize_t) colors; i++)",
          "3758:         if (bluemap != (int *) NULL)",
          "3759:           for (i=0; i < (ssize_t) colors; i++)",
          "3766:         if (graymap != (int *) NULL)",
          "3767:           for (i=0; i < (ssize_t) colors; i++)",
          "",
          "[Added Lines]",
          "3892:     if (image_info->ping != MagickFalse)",
          "3897:     status=SetImageExtent(image,image->columns,image->rows,exception);",
          "3898:     if (status == MagickFalse)",
          "3900:     image->colorspace=RGBColorspace;",
          "3901:     if ((image->colormap == (PixelInfo *) NULL) &&",
          "3902:         (info.samples_per_pixel == 1))",
          "3908:           one;",
          "3915:         if (redmap != (int *) NULL)",
          "3916:           for (i=0; i < (ssize_t) colors; i++)",
          "3917:           {",
          "3924:         if (greenmap != (int *) NULL)",
          "3925:           for (i=0; i < (ssize_t) colors; i++)",
          "3926:           {",
          "3933:         if (bluemap != (int *) NULL)",
          "3934:           for (i=0; i < (ssize_t) colors; i++)",
          "3935:           {",
          "3942:         if (graymap != (int *) NULL)",
          "3943:           for (i=0; i < (ssize_t) colors; i++)",
          "3944:           {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3789:         if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||",
          "3790:             (EOFBlob(image) != MagickFalse))",
          "3791:           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "3794:         if (stream_info->segment_count > 1)",
          "3795:           {",
          "3796:             bytes_per_pixel=1;",
          "3797:             depth=8;",
          "3798:           }",
          "3800:           stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);",
          "3801:         stream_info->remaining-=64;",
          "3802:       }",
          "3803:     if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))",
          "3806:           Convert Planar RGB DCM Medical image to pixel packets.",
          "",
          "[Removed Lines]",
          "3792:         stream_info->count=0;",
          "3793:         stream_info->segment_count=ReadBlobLSBLong(image);",
          "3799:         for (i=0; i < 15; i++)",
          "3804:       {",
          "",
          "[Added Lines]",
          "3969:         stream_info->count=0;",
          "3970:         stream_info->segment_count=ReadBlobLSBLong(image);",
          "3976:         for (i=0; i < 15; i++)",
          "3978:         stream_info->remaining-=64;",
          "3979:       }",
          "3980:     if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))",
          "3981:       {",
          "3982:         register ssize_t",
          "3983:           x;",
          "3985:         register Quantum",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3858:         }",
          "3859:       }",
          "3860:     else",
          "3868:         PixelPacket",
          "3869:           pixel;",
          "3874:         byte=0;",
          "3875:         i=0;",
          "3876:         if ((window_center != 0) && (window_width == 0))",
          "3877:           window_width=(size_t) window_center;",
          "4109:                   image->rows);",
          "4110:                 if (status == MagickFalse)",
          "4111:                   break;",
          "4112:               }",
          "",
          "[Removed Lines]",
          "3861:       {",
          "3862:         const char",
          "3865:         int",
          "3866:           byte;",
          "3872:           Convert DCM Medical image to pixel packets.",
          "3878:         option=GetImageOption(image_info,\"dcm:display-range\");",
          "3879:         if (option != (const char *) NULL)",
          "3880:           {",
          "3881:             if (LocaleCompare(option,\"reset\") == 0)",
          "3882:               window_width=0;",
          "3883:           }",
          "3884:         (void) ResetMagickMemory(&pixel,0,sizeof(pixel));",
          "3885:         for (y=0; y < (ssize_t) image->rows; y++)",
          "3886:         {",
          "3887:           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);",
          "3888:           if (q == (Quantum *) NULL)",
          "3889:             break;",
          "3890:           for (x=0; x < (ssize_t) image->columns; x++)",
          "3891:           {",
          "3892:             if (samples_per_pixel == 1)",
          "3893:               {",
          "3894:                 int",
          "3895:                   pixel_value;",
          "3897:                 if (bytes_per_pixel == 1)",
          "3898:                   pixel_value=polarity != MagickFalse ?",
          "3899:                     ((int) max_value-ReadDCMByte(stream_info,image)) :",
          "3900:                     ReadDCMByte(stream_info,image);",
          "3901:                 else",
          "3902:                   if ((bits_allocated != 12) || (significant_bits != 12))",
          "3903:                     {",
          "3904:                       if (signed_data)",
          "3905:                         pixel_value=ReadDCMSignedShort(stream_info,image);",
          "3906:                       else",
          "3907:                         pixel_value=ReadDCMShort(stream_info,image);",
          "3908:                       if (polarity != MagickFalse)",
          "3909:                         pixel_value=(int)max_value-pixel_value;",
          "3910:                     }",
          "3911:                   else",
          "3912:                     {",
          "3913:                       if ((i & 0x01) != 0)",
          "3914:                         pixel_value=(ReadDCMByte(stream_info,image) << 8) |",
          "3915:                           byte;",
          "3916:                       else",
          "3917:                         {",
          "3918:                           pixel_value=ReadDCMSignedShort(stream_info,image);",
          "3919:                           byte=(int) (pixel_value & 0x0f);",
          "3920:                           pixel_value>>=4;",
          "3921:                         }",
          "3922:                       i++;",
          "3923:                     }",
          "3924:                 index=(pixel_value*rescale_slope)+rescale_intercept;",
          "3925:                 if (window_width == 0)",
          "3926:                   {",
          "3927:                     if (signed_data == 1)",
          "3928:                       index-=32767;",
          "3929:                   }",
          "3930:                 else",
          "3931:                   {",
          "3932:                     ssize_t",
          "3933:                       window_max,",
          "3934:                       window_min;",
          "3936:                     window_min=(ssize_t) ceil((double) window_center-",
          "3937:                       (window_width-1.0)/2.0-0.5);",
          "3938:                     window_max=(ssize_t) floor((double) window_center+",
          "3939:                       (window_width-1.0)/2.0+0.5);",
          "3940:                     if ((ssize_t)index <= window_min)",
          "3941:                       index=0;",
          "3942:                     else",
          "3943:                       if ((ssize_t)index > window_max)",
          "3944:                         index=(int) max_value;",
          "3945:                       else",
          "3946:                         index=(int) (max_value*(((index-window_center-",
          "3947:                           0.5)/(window_width-1))+0.5));",
          "3948:                   }",
          "3949:                 index&=mask;",
          "3950:                 index=(int) ConstrainColormapIndex(image,(size_t) index,",
          "3951:                   exception);",
          "3952:                 SetPixelIndex(image,(Quantum) index,q);",
          "3953:                 pixel.red=(unsigned int) image->colormap[index].red;",
          "3954:                 pixel.green=(unsigned int) image->colormap[index].green;",
          "3955:                 pixel.blue=(unsigned int) image->colormap[index].blue;",
          "3956:               }",
          "3957:             else",
          "3958:               {",
          "3959:                 if (bytes_per_pixel == 1)",
          "3960:                   {",
          "3961:                     pixel.red=(unsigned int) ReadDCMByte(stream_info,image);",
          "3962:                     pixel.green=(unsigned int) ReadDCMByte(stream_info,image);",
          "3963:                     pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);",
          "3964:                   }",
          "3965:                 else",
          "3966:                   {",
          "3967:                     pixel.red=ReadDCMShort(stream_info,image);",
          "3968:                     pixel.green=ReadDCMShort(stream_info,image);",
          "3969:                     pixel.blue=ReadDCMShort(stream_info,image);",
          "3970:                   }",
          "3971:                 pixel.red&=mask;",
          "3972:                 pixel.green&=mask;",
          "3973:                 pixel.blue&=mask;",
          "3974:                 if (scale != (Quantum *) NULL)",
          "3975:                   {",
          "3976:                     if (pixel.red <= GetQuantumRange(depth))",
          "3977:                       pixel.red=scale[pixel.red];",
          "3978:                     if (pixel.green <= GetQuantumRange(depth))",
          "3979:                       pixel.green=scale[pixel.green];",
          "3980:                     if (pixel.blue <= GetQuantumRange(depth))",
          "3981:                       pixel.blue=scale[pixel.blue];",
          "3982:                   }",
          "3983:               }",
          "3984:             SetPixelRed(image,(Quantum) pixel.red,q);",
          "3985:             SetPixelGreen(image,(Quantum) pixel.green,q);",
          "3986:             SetPixelBlue(image,(Quantum) pixel.blue,q);",
          "3987:             q+=GetPixelChannels(image);",
          "3988:           }",
          "3989:           if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "3990:             break;",
          "3991:           if (image->previous == (Image *) NULL)",
          "3992:             {",
          "3993:               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,",
          "3994:                 image->rows);",
          "3995:               if (status == MagickFalse)",
          "3996:                 break;",
          "3997:             }",
          "3998:         }",
          "3999:         if (stream_info->segment_count > 1)",
          "4000:           for (y=0; y < (ssize_t) image->rows; y++)",
          "4001:           {",
          "4002:             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);",
          "4003:             if (q == (Quantum *) NULL)",
          "4004:               break;",
          "4005:             for (x=0; x < (ssize_t) image->columns; x++)",
          "4006:             {",
          "4007:               if (samples_per_pixel == 1)",
          "4008:                 {",
          "4009:                   int",
          "4010:                     pixel_value;",
          "4012:                   if (bytes_per_pixel == 1)",
          "4013:                     pixel_value=polarity != MagickFalse ?",
          "4014:                       ((int) max_value-ReadDCMByte(stream_info,image)) :",
          "4015:                       ReadDCMByte(stream_info,image);",
          "4016:                   else",
          "4017:                     if ((bits_allocated != 12) || (significant_bits != 12))",
          "4018:                       {",
          "4019:                         pixel_value=(int) (polarity != MagickFalse ?",
          "4020:                           (max_value-ReadDCMShort(stream_info,image)) :",
          "4021:                           ReadDCMShort(stream_info,image));",
          "4022:                         if (signed_data == 1)",
          "4023:                           pixel_value=((signed short) pixel_value);",
          "4024:                       }",
          "4025:                     else",
          "4026:                       {",
          "4027:                         if ((i & 0x01) != 0)",
          "4028:                           pixel_value=(ReadDCMByte(stream_info,image) << 8) |",
          "4029:                             byte;",
          "4030:                         else",
          "4031:                           {",
          "4032:                             pixel_value=ReadDCMShort(stream_info,image);",
          "4033:                             byte=(int) (pixel_value & 0x0f);",
          "4034:                             pixel_value>>=4;",
          "4035:                           }",
          "4036:                         i++;",
          "4037:                       }",
          "4038:                   index=(pixel_value*rescale_slope)+rescale_intercept;",
          "4039:                   if (window_width == 0)",
          "4040:                     {",
          "4041:                       if (signed_data == 1)",
          "4042:                         index-=32767;",
          "4043:                     }",
          "4044:                   else",
          "4045:                     {",
          "4046:                       ssize_t",
          "4047:                         window_max,",
          "4048:                         window_min;",
          "4050:                       window_min=(ssize_t) ceil((double) window_center-",
          "4051:                         (window_width-1.0)/2.0-0.5);",
          "4052:                       window_max=(ssize_t) floor((double) window_center+",
          "4053:                         (window_width-1.0)/2.0+0.5);",
          "4054:                       if ((ssize_t)index <= window_min)",
          "4055:                         index=0;",
          "4056:                       else",
          "4057:                         if ((ssize_t)index > window_max)",
          "4058:                           index=(int) max_value;",
          "4059:                         else",
          "4060:                           index=(int) (max_value*(((index-window_center-",
          "4061:                             0.5)/(window_width-1))+0.5));",
          "4062:                     }",
          "4063:                   index&=mask;",
          "4064:                   index=(int) ConstrainColormapIndex(image,(size_t) index,",
          "4065:                     exception);",
          "4066:                   SetPixelIndex(image,(Quantum) (((size_t)",
          "4067:                     GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);",
          "4068:                   pixel.red=(unsigned int) image->colormap[index].red;",
          "4069:                   pixel.green=(unsigned int) image->colormap[index].green;",
          "4070:                   pixel.blue=(unsigned int) image->colormap[index].blue;",
          "4071:                 }",
          "4072:               else",
          "4073:                 {",
          "4074:                   if (bytes_per_pixel == 1)",
          "4075:                     {",
          "4076:                       pixel.red=(unsigned int) ReadDCMByte(stream_info,image);",
          "4077:                       pixel.green=(unsigned int) ReadDCMByte(stream_info,image);",
          "4078:                       pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);",
          "4079:                     }",
          "4080:                   else",
          "4081:                     {",
          "4082:                       pixel.red=ReadDCMShort(stream_info,image);",
          "4083:                       pixel.green=ReadDCMShort(stream_info,image);",
          "4084:                       pixel.blue=ReadDCMShort(stream_info,image);",
          "4085:                     }",
          "4086:                   pixel.red&=mask;",
          "4087:                   pixel.green&=mask;",
          "4088:                   pixel.blue&=mask;",
          "4089:                   if (scale != (Quantum *) NULL)",
          "4090:                     {",
          "4091:                       pixel.red=scale[pixel.red];",
          "4092:                       pixel.green=scale[pixel.green];",
          "4093:                       pixel.blue=scale[pixel.blue];",
          "4094:                     }",
          "4095:                 }",
          "4096:               SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |",
          "4097:                 (((size_t) pixel.red) << 8)),q);",
          "4098:               SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |",
          "4099:                 (((size_t) pixel.green) << 8)),q);",
          "4100:               SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |",
          "4101:                 (((size_t) pixel.blue) << 8)),q);",
          "4102:               q+=GetPixelChannels(image);",
          "4103:             }",
          "4104:             if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "4105:               break;",
          "4106:             if (image->previous == (Image *) NULL)",
          "4107:               {",
          "4108:                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,",
          "",
          "[Added Lines]",
          "4056:         option=GetImageOption(image_info,\"dcm:display-range\");",
          "4058:           {",
          "4059:             if (LocaleCompare(option,\"reset\") == 0)",
          "4060:               info.window_width=0;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4148:     Free resources.",
          "4152:       RelinquishMagickMemory(stream_info->offsets);",
          "4153:   stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);",
          "4154:   if (scale != (Quantum *) NULL)",
          "",
          "[Removed Lines]",
          "4150:   if (stream_info->offsets != (ssize_t *) NULL)",
          "4151:     stream_info->offsets=(ssize_t *)",
          "",
          "[Added Lines]",
          "4101:   if (stream_info->offsets != (ssize_t *) NULL)",
          "4102:     stream_info->offsets=(ssize_t *)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
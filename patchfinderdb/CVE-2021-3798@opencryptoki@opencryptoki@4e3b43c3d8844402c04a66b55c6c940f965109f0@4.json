{
  "cve_id": "CVE-2021-3798",
  "cve_desc": "A flaw was found in openCryptoki. The openCryptoki Soft token does not check if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey is used with ECDH public data. This may allow a malicious user to extract the private key by performing an invalid curve attack.",
  "repo": "opencryptoki/opencryptoki",
  "patch_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
  "patch_info": {
    "commit_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
    "repo": "opencryptoki/opencryptoki",
    "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0",
    "files": [
      "usr/lib/soft_stdll/soft_specific.c"
    ],
    "message": "SOFT: Check the EC Key on C_CreateObject and C_DeriveKey\n\nWhen constructing an OpenSSL EC public or private key from PKCS#11\nattributes or ECDH public data, check that the key is valid, i.e. that\nthe point is on the curve.\n\nThis prevents one from creating an EC key object via C_CreateObject with\ninvalid key data. It also prevents C_DeriveKey to derive a secret using\nECDH with an EC public key (public data) that uses a different curve\nor is invalid by other means.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
    "before_after_code_files": [
      "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
    ]
  },
  "patch_diff": {
    "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c": [
      "File: usr/lib/soft_stdll/soft_specific.c -> usr/lib/soft_stdll/soft_specific.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4365:         goto out;",
      "4366:     }",
      "4368: out:",
      "4369:     if (allocated && ecpoint != NULL)",
      "4370:         free(ecpoint);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4368:     if (!EC_KEY_check_key(ec_key)) {",
      "4369:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "4370:         rc = CKR_PUBLIC_KEY_INVALID;",
      "4371:         goto out;",
      "4372:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4404:         goto out;",
      "4405:     }",
      "4407: out:",
      "4408:     if (point != NULL)",
      "4409:         EC_POINT_free(point);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4413:     if (!EC_KEY_check_key(ec_key)) {",
      "4414:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "4415:         rc = CKR_FUNCTION_FAILED;",
      "4416:         goto out;",
      "4417:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4dd8a952fc00dd54cce090e4c053de408ba3884b",
      "candidate_info": {
        "commit_hash": "4dd8a952fc00dd54cce090e4c053de408ba3884b",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/4dd8a952fc00dd54cce090e4c053de408ba3884b",
        "files": [
          "usr/lib/soft_stdll/soft_specific.c"
        ],
        "message": "SOFT: Detect unsupported EC curves with OpenSSL 3.0\n\nOpenSSL 3.0 behaves different in reporting an error when an unsupported\nEC curve is used to generate an EC key. OpenSSL 1.1.1 returns an error\nat EVP_PKEY_CTX_set_ec_paramgen_curve_nid() already, but OpenSSL 3.0 returns\nan error only at EVP_PKEY_keygen().\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/soft_stdll/soft_specific.c||usr/lisoft_stdll/soft_specific.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/soft_stdll/soft_specific.c||usr/lisoft_stdll/soft_specific.c": [
          "File: usr/lib/soft_stdll/soft_specific.c -> usr/lisoft_stdll/soft_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: #include <openssl/cmac.h>",
          "52: #include <openssl/ec.h>",
          "53: #include <openssl/bn.h>",
          "54: #if OPENSSL_VERSION_PREREQ(3, 0)",
          "55: #include <openssl/core_names.h>",
          "56: #include <openssl/param_build.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4549:     if (EVP_PKEY_keygen(ctx, &ec_pkey) <= 0) {",
          "4550:         TRACE_ERROR(\"EVP_PKEY_keygen failed\\n\");",
          "4552:         goto out;",
          "4553:     }",
          "",
          "[Removed Lines]",
          "4551:         rc = CKR_FUNCTION_FAILED;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50e3f06823696c74eea90a77e16b28da1f79cd47",
      "candidate_info": {
        "commit_hash": "50e3f06823696c74eea90a77e16b28da1f79cd47",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/50e3f06823696c74eea90a77e16b28da1f79cd47",
        "files": [
          "usr/lib/soft_stdll/soft_specific.c"
        ],
        "message": "SOFT: Remove deprecated OpenSSL functions\n\nAll low level RSA, EC_KEY, and DH functions are deprecated in OpenSSL 3.0.\nUpdate the code to not use any of those.\n\nChange the digest operation context to store the OpenSSL digest context,\ninstead of the deprecated way of retrieving and restoring the digest state.\nThis makes the digest operation context 'non savable'.\n\nAlso remove support for OpenSSL < v1.1.1. This code used even more\nlow level OpenSSL functions.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/soft_stdll/soft_specific.c||usr/lisoft_stdll/soft_specific.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/soft_stdll/soft_specific.c||usr/lisoft_stdll/soft_specific.c": [
          "File: usr/lib/soft_stdll/soft_specific.c -> usr/lisoft_stdll/soft_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include <openssl/opensslv.h>",
          "33: #include \"pkcs11types.h\"",
          "34: #include \"defs.h\"",
          "35: #include \"host_defs.h\"",
          "",
          "[Removed Lines]",
          "29: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "30: #define NO_EC 1",
          "31: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #include <openssl/crypto.h>",
          "55: #include <openssl/cmac.h>",
          "56: #include <openssl/ec.h>",
          "65: #endif",
          "67: #define MAX_GENERIC_KEY_SIZE 256",
          "",
          "[Removed Lines]",
          "63: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "64: #define OLDER_OPENSSL",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76: #if !(NODSA)",
          "77:     {CKM_DSA_KEY_PAIR_GEN, {512, 1024, CKF_GENERATE_KEY_PAIR}},",
          "78: #endif",
          "79:     {CKM_DES_KEY_GEN, {8, 8, CKF_GENERATE}},",
          "80:     {CKM_DES3_KEY_GEN, {24, 24, CKF_GENERATE}},",
          "81: #if !(NOCDMF)",
          "82:     {CKM_CDMF_KEY_GEN, {0, 0, CKF_GENERATE}},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "120:     {CKM_DH_PKCS_KEY_PAIR_GEN, {512, 2048, CKF_GENERATE_KEY_PAIR}},",
          "121: #endif",
          "123:     {CKM_DES_ECB, {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},",
          "124:     {CKM_DES_CBC, {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},",
          "125:     {CKM_DES_CBC_PAD,",
          "126:      {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},",
          "127: #if !(NOCDMF)",
          "128:     {CKM_CDMF_ECB, {0, 0, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},",
          "129:     {CKM_CDMF_CBC, {0, 0, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "286:                              CK_ULONG *out_data_len,",
          "287:                              OBJECT *key, CK_BYTE encrypt)",
          "288: {",
          "341:     const EVP_CIPHER *cipher = EVP_des_ecb();",
          "342:     EVP_CIPHER_CTX *ctx = NULL;",
          "343:     CK_ATTRIBUTE *attr = NULL;",
          "",
          "[Removed Lines]",
          "289: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "290:     CK_RV rc;",
          "291:     DES_key_schedule des_key2;",
          "292:     const_DES_cblock key_val_SSL, in_key_data;",
          "293:     DES_cblock out_key_data;",
          "294:     unsigned int i, j;",
          "295:     CK_ATTRIBUTE *attr = NULL;",
          "297:     UNUSED(tokdata);",
          "300:     rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "301:     if (rc != CKR_OK) {",
          "302:         TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");",
          "303:         return rc;",
          "304:     }",
          "306:     memcpy(&key_val_SSL, attr->pValue, 8);",
          "307:     DES_set_key_unchecked(&key_val_SSL, &des_key2);",
          "311:     if (in_data_len % DES_BLOCK_SIZE) {",
          "312:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));",
          "313:         return CKR_DATA_LEN_RANGE;",
          "314:     }",
          "316:     if (encrypt) {",
          "317:         for (i = 0; i < in_data_len; i = i + 8) {",
          "318:             memcpy(in_key_data, in_data + i, 8);",
          "319:             DES_ecb_encrypt(&in_key_data, &out_key_data, &des_key2,",
          "320:                             DES_ENCRYPT);",
          "321:             memcpy(out_data + i, out_key_data, 8);",
          "322:         }",
          "325:         rc = CKR_OK;",
          "326:     } else {",
          "328:         for (j = 0; j < in_data_len; j = j + 8) {",
          "329:             memcpy(in_key_data, in_data + j, 8);",
          "330:             DES_ecb_encrypt(&in_key_data, &out_key_data, &des_key2,",
          "331:                             DES_DECRYPT);",
          "332:             memcpy(out_data + j, out_key_data, 8);",
          "333:         }",
          "336:         rc = CKR_OK;",
          "337:     }",
          "339:     return rc;",
          "340: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "384:     OPENSSL_cleanse(dkey, sizeof(dkey));",
          "385:     EVP_CIPHER_CTX_free(ctx);",
          "386:     return rc;",
          "388: }",
          "390: CK_RV token_specific_des_cbc(STDLL_TokData_t *tokdata,",
          "",
          "[Removed Lines]",
          "387: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "394:                              CK_ULONG *out_data_len,",
          "395:                              OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)",
          "396: {",
          "438:     const EVP_CIPHER *cipher = EVP_des_cbc();",
          "439:     EVP_CIPHER_CTX *ctx = NULL;",
          "440:     CK_ATTRIBUTE *attr = NULL;",
          "",
          "[Removed Lines]",
          "397: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "398:     CK_RV rc;",
          "399:     CK_ATTRIBUTE *attr = NULL;",
          "400:     DES_cblock ivec;",
          "401:     DES_key_schedule des_key2;",
          "402:     const_DES_cblock key_val_SSL;",
          "404:     UNUSED(tokdata);",
          "407:     rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "408:     if (rc != CKR_OK) {",
          "409:         TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");",
          "410:         return rc;",
          "411:     }",
          "413:     memcpy(&key_val_SSL, attr->pValue, 8);",
          "414:     DES_set_key_unchecked(&key_val_SSL, &des_key2);",
          "416:     memcpy(&ivec, init_v, 8);",
          "419:     if (in_data_len % DES_BLOCK_SIZE) {",
          "420:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));",
          "421:         return CKR_DATA_LEN_RANGE;",
          "422:     }",
          "424:     if (encrypt) {",
          "425:         DES_ncbc_encrypt(in_data, out_data, in_data_len, &des_key2, &ivec,",
          "426:                          DES_ENCRYPT);",
          "428:         rc = CKR_OK;",
          "429:     } else {",
          "430:         DES_ncbc_encrypt(in_data, out_data, in_data_len, &des_key2, &ivec,",
          "431:                          DES_DECRYPT);",
          "433:         rc = CKR_OK;",
          "434:     }",
          "436:     return rc;",
          "437: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "481:     OPENSSL_cleanse(dkey, sizeof(dkey));",
          "482:     EVP_CIPHER_CTX_free(ctx);",
          "483:     return rc;",
          "485: }",
          "487: CK_RV token_specific_tdes_ecb(STDLL_TokData_t *tokdata,",
          "",
          "[Removed Lines]",
          "484: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "491:                               CK_ULONG *out_data_len,",
          "492:                               OBJECT *key, CK_BYTE encrypt)",
          "493: {",
          "568:     const EVP_CIPHER *cipher = EVP_des_ede3_ecb();",
          "569:     EVP_CIPHER_CTX *ctx = NULL;",
          "570:     CK_ATTRIBUTE *attr = NULL;",
          "",
          "[Removed Lines]",
          "494: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "495:     CK_RV rc;",
          "496:     CK_ATTRIBUTE *attr = NULL;",
          "497:     CK_BYTE key_value[3 * DES_KEY_SIZE];",
          "498:     CK_KEY_TYPE keytype;",
          "499:     unsigned int k, j;",
          "500:     DES_key_schedule des_key1;",
          "501:     DES_key_schedule des_key2;",
          "502:     DES_key_schedule des_key3;",
          "503:     const_DES_cblock key_SSL1, key_SSL2, key_SSL3, in_key_data;",
          "504:     DES_cblock out_key_data;",
          "506:     UNUSED(tokdata);",
          "509:     rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);",
          "510:     if (rc != CKR_OK) {",
          "511:         TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");",
          "512:         return rc;",
          "513:     }",
          "516:     rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "517:     if (rc != CKR_OK) {",
          "518:         TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");",
          "519:         return rc;",
          "520:     }",
          "521:     if (keytype == CKK_DES2) {",
          "522:         memcpy(key_value, attr->pValue, 2 * DES_KEY_SIZE);",
          "523:         memcpy(key_value + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);",
          "524:     } else {",
          "525:         memcpy(key_value, attr->pValue, 3 * DES_KEY_SIZE);",
          "526:     }",
          "530:     memcpy(&key_SSL1, key_value, 8);",
          "531:     memcpy(&key_SSL2, key_value + 8, 8);",
          "532:     memcpy(&key_SSL3, key_value + 16, 8);",
          "533:     DES_set_key_unchecked(&key_SSL1, &des_key1);",
          "534:     DES_set_key_unchecked(&key_SSL2, &des_key2);",
          "535:     DES_set_key_unchecked(&key_SSL3, &des_key3);",
          "539:     if (in_data_len % DES_BLOCK_SIZE) {",
          "540:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));",
          "541:         return CKR_DATA_LEN_RANGE;",
          "542:     }",
          "544:     if (encrypt) {",
          "545:         for (k = 0; k < in_data_len; k = k + 8) {",
          "546:             memcpy(in_key_data, in_data + k, 8);",
          "547:             DES_ecb3_encrypt((const_DES_cblock *) & in_key_data,",
          "548:                              (DES_cblock *) & out_key_data,",
          "549:                              &des_key1, &des_key2, &des_key3, DES_ENCRYPT);",
          "550:             memcpy(out_data + k, out_key_data, 8);",
          "551:         }",
          "553:         rc = CKR_OK;",
          "554:     } else {",
          "555:         for (j = 0; j < in_data_len; j = j + 8) {",
          "556:             memcpy(in_key_data, in_data + j, 8);",
          "557:             DES_ecb3_encrypt((const_DES_cblock *) & in_key_data,",
          "558:                              (DES_cblock *) & out_key_data,",
          "559:                              &des_key1, &des_key2, &des_key3, DES_DECRYPT);",
          "560:             memcpy(out_data + j, out_key_data, 8);",
          "561:         }",
          "563:         rc = CKR_OK;",
          "564:     }",
          "566:     return rc;",
          "567: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "624:     OPENSSL_cleanse(dkey, sizeof(dkey));",
          "625:     EVP_CIPHER_CTX_free(ctx);",
          "626:     return rc;",
          "628: }",
          "630: CK_RV token_specific_tdes_cbc(STDLL_TokData_t *tokdata,",
          "",
          "[Removed Lines]",
          "627: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "634:                               CK_ULONG *out_data_len,",
          "635:                               OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)",
          "636: {",
          "709:     const EVP_CIPHER *cipher = EVP_des_ede3_cbc();",
          "710:     EVP_CIPHER_CTX *ctx = NULL;",
          "711:     CK_ATTRIBUTE *attr = NULL;",
          "",
          "[Removed Lines]",
          "637: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "638:     CK_ATTRIBUTE *attr = NULL;",
          "639:     CK_RV rc = CKR_OK;",
          "640:     CK_BYTE key_value[3 * DES_KEY_SIZE];",
          "641:     CK_KEY_TYPE keytype;",
          "642:     DES_key_schedule des_key1;",
          "643:     DES_key_schedule des_key2;",
          "644:     DES_key_schedule des_key3;",
          "645:     const_DES_cblock key_SSL1, key_SSL2, key_SSL3;",
          "646:     DES_cblock ivec;",
          "648:     UNUSED(tokdata);",
          "651:     rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);",
          "652:     if (rc != CKR_OK) {",
          "653:         TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");",
          "654:         return rc;",
          "655:     }",
          "658:     rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "659:     if (rc != CKR_OK) {",
          "660:         TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");",
          "661:         return rc;",
          "662:     }",
          "663:     if (keytype == CKK_DES2) {",
          "664:         memcpy(key_value, attr->pValue, 2 * DES_KEY_SIZE);",
          "665:         memcpy(key_value + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);",
          "666:     } else {",
          "667:         memcpy(key_value, attr->pValue, 3 * DES_KEY_SIZE);",
          "668:     }",
          "672:     memcpy(&key_SSL1, key_value, 8);",
          "673:     memcpy(&key_SSL2, key_value + 8, 8);",
          "674:     memcpy(&key_SSL3, key_value + 16, 8);",
          "675:     DES_set_key_unchecked(&key_SSL1, &des_key1);",
          "676:     DES_set_key_unchecked(&key_SSL2, &des_key2);",
          "677:     DES_set_key_unchecked(&key_SSL3, &des_key3);",
          "679:     memcpy(ivec, init_v, sizeof(ivec));",
          "683:     if (in_data_len % DES_BLOCK_SIZE) {",
          "684:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));",
          "685:         return CKR_DATA_LEN_RANGE;",
          "686:     }",
          "688:     if (encrypt) {",
          "689:         DES_ede3_cbc_encrypt(in_data,",
          "690:                              out_data,",
          "691:                              in_data_len,",
          "692:                              &des_key1,",
          "693:                              &des_key2, &des_key3, &ivec, DES_ENCRYPT);",
          "695:         rc = CKR_OK;",
          "696:     } else {",
          "697:         DES_ede3_cbc_encrypt(in_data,",
          "698:                              out_data,",
          "699:                              in_data_len,",
          "700:                              &des_key1,",
          "701:                              &des_key2, &des_key3, &ivec, DES_DECRYPT);",
          "704:         rc = CKR_OK;",
          "705:     }",
          "707:     return rc;",
          "708: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "765:     OPENSSL_cleanse(dkey, sizeof(dkey));",
          "766:     EVP_CIPHER_CTX_free(ctx);",
          "767:     return rc;",
          "769: }",
          "771: CK_RV token_specific_tdes_mac(STDLL_TokData_t *tokdata, CK_BYTE *message,",
          "",
          "[Removed Lines]",
          "768: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "799: {",
          "800:     CK_BBOOL rc;",
          "801:     CK_ATTRIBUTE *modulus = NULL;",
          "802:     CK_ATTRIBUTE *pub_exp = NULL;",
          "805:     BIGNUM *bn_mod, *bn_exp;",
          "807:     rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,",
          "808:                                           &modulus);",
          "",
          "[Removed Lines]",
          "798: static void *rsa_convert_public_key(OBJECT *key_obj)",
          "804:     RSA *rsa;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "813:     if (rc != CKR_OK)",
          "814:         return NULL;",
          "822:     bn_mod = BN_new();",
          "823:     bn_exp = BN_new();",
          "",
          "[Removed Lines]",
          "817:     rsa = RSA_new();",
          "818:     if (rsa == NULL)",
          "819:         return NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "827:             free(bn_mod);",
          "828:         if (bn_exp)",
          "829:             free(bn_exp);",
          "831:         return NULL;",
          "832:     }",
          "834:     BN_bin2bn((unsigned char *) modulus->pValue, modulus->ulValueLen, bn_mod);",
          "835:     BN_bin2bn((unsigned char *) pub_exp->pValue, pub_exp->ulValueLen, bn_exp);",
          "841:     RSA_set0_key(rsa, bn_mod, bn_exp, NULL);",
          "842: #endif",
          "845: }",
          "848: {",
          "849:     CK_ATTRIBUTE *modulus = NULL;",
          "850:     CK_ATTRIBUTE *pub_exp = NULL;",
          "",
          "[Removed Lines]",
          "830:         RSA_free(rsa);",
          "837: #ifdef OLDER_OPENSSL",
          "838:     rsa->n = bn_mod;",
          "839:     rsa->e = bn_exp;",
          "840: #else",
          "844:     return (void *) rsa;",
          "847: static void *rsa_convert_private_key(OBJECT *key_obj)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "854:     CK_ATTRIBUTE *exp1 = NULL;",
          "855:     CK_ATTRIBUTE *exp2 = NULL;",
          "856:     CK_ATTRIBUTE *coeff = NULL;",
          "858:     RSA *rsa;",
          "859:     RSA_METHOD *meth;",
          "860:     BIGNUM *bn_mod, *bn_pub_exp, *bn_priv_exp, *bn_p1, *bn_p2, *bn_e1, *bn_e2,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "873:     if (!prime2 && !modulus) {",
          "874:         return NULL;",
          "875:     }",
          "877:     rsa = RSA_new();",
          "878:     if (rsa == NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "887: #ifdef OLDER_OPENSSL",
          "888:     if (rsa->engine) {",
          "889:         meth = (RSA_METHOD *) rsa->meth;",
          "890:         const RSA_METHOD *meth2 = RSA_PKCS1_SSLeay();",
          "891:         meth->rsa_pub_enc = meth2->rsa_pub_enc;",
          "892:         meth->rsa_pub_dec = meth2->rsa_pub_dec;",
          "893:         meth->rsa_priv_enc = meth2->rsa_priv_enc;",
          "894:         meth->rsa_priv_dec = meth2->rsa_priv_dec;",
          "895:         meth->rsa_mod_exp = meth2->rsa_mod_exp;",
          "896:         meth->bn_mod_exp = meth2->bn_mod_exp;",
          "897: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "912:         RSA_meth_set_mod_exp(meth, RSA_meth_get_mod_exp(meth2));",
          "913:         RSA_meth_set_bn_mod_exp(meth, RSA_meth_get_bn_mod_exp(meth2));",
          "914: # pragma GCC diagnostic pop",
          "916:     }",
          "918:     bn_mod = BN_new();",
          "919:     bn_pub_exp = BN_new();",
          "",
          "[Removed Lines]",
          "915: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "927:     if ((bn_cf == NULL) || (bn_e2 == NULL) || (bn_e1 == NULL) ||",
          "928:         (bn_p2 == NULL) || (bn_p1 == NULL) || (bn_priv_exp == NULL) ||",
          "952:     if (prime1) {",
          "",
          "[Removed Lines]",
          "929:         (bn_pub_exp == NULL) || (bn_mod == NULL)) {",
          "930:         if (rsa)",
          "931:             RSA_free(rsa);",
          "932:         if (bn_mod)",
          "933:             BN_free(bn_mod);",
          "934:         if (bn_pub_exp)",
          "935:             BN_free(bn_pub_exp);",
          "936:         if (bn_priv_exp)",
          "937:             BN_free(bn_priv_exp);",
          "938:         if (bn_p1)",
          "939:             BN_free(bn_p1);",
          "940:         if (bn_p2)",
          "941:             BN_free(bn_p2);",
          "942:         if (bn_e1)",
          "943:             BN_free(bn_e1);",
          "944:         if (bn_e2)",
          "945:             BN_free(bn_e2);",
          "946:         if (bn_cf)",
          "947:             BN_free(bn_cf);",
          "948:         return NULL;",
          "949:     }",
          "953:         if (!prime2 || !exp1 || !exp2 || !coeff) {",
          "954:             return NULL;",
          "955:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "969:         BN_bin2bn((unsigned char *) exp1->pValue, exp1->ulValueLen, bn_e1);",
          "970:         BN_bin2bn((unsigned char *) exp2->pValue, exp2->ulValueLen, bn_e2);",
          "971:         BN_bin2bn((unsigned char *) coeff->pValue, coeff->ulValueLen, bn_cf);",
          "981:         RSA_set0_key(rsa, bn_mod, bn_pub_exp, bn_priv_exp);",
          "982:         RSA_set0_factors(rsa, bn_p1, bn_p2);",
          "983:         RSA_set0_crt_params(rsa, bn_e1, bn_e2, bn_cf);",
          "984: #endif",
          "986:     } else {                    // must be a non-CRT key",
          "987:         if (!priv_exp) {",
          "988:             return NULL;",
          "",
          "[Removed Lines]",
          "972: #ifdef OLDER_OPENSSL",
          "973:         rsa->n = bn_mod;",
          "974:         rsa->d = bn_priv_exp;",
          "975:         rsa->p = bn_p1;",
          "976:         rsa->q = bn_p2;",
          "977:         rsa->dmp1 = bn_e1;",
          "978:         rsa->dmq1 = bn_e2;",
          "979:         rsa->iqmp = bn_cf;",
          "980: #else",
          "985:         return rsa;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "993:                   bn_pub_exp);",
          "994:         BN_bin2bn((unsigned char *) priv_exp->pValue, priv_exp->ulValueLen,",
          "995:                   bn_priv_exp);",
          "1000:         RSA_set0_key(rsa, bn_mod, bn_pub_exp, bn_priv_exp);",
          "1001: #endif",
          "1002:     }",
          "1005: }",
          "1007: static CK_RV os_specific_rsa_keygen(TEMPLATE *publ_tmpl, TEMPLATE *priv_tmpl)",
          "",
          "[Removed Lines]",
          "996: #ifdef OLDER_OPENSSL",
          "997:         rsa->n = bn_mod;",
          "998:         rsa->d = bn_priv_exp;",
          "999: #else",
          "1004:     return (void *) rsa;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1012:     CK_BBOOL flag;",
          "1013:     CK_RV rc;",
          "1014:     CK_ULONG BNLength;",
          "1016:     const BIGNUM *bignum = NULL;",
          "1017:     CK_BYTE *ssl_ptr = NULL;",
          "1018:     BIGNUM *e = NULL;",
          "1020:     EVP_PKEY *pkey = NULL;",
          "1021:     EVP_PKEY_CTX *ctx = NULL;",
          "1024:     rc = template_attribute_get_ulong(publ_tmpl, CKA_MODULUS_BITS, &mod_bits);",
          "1025:     if (rc != CKR_OK) {",
          "",
          "[Removed Lines]",
          "1015:     RSA *rsa = NULL;",
          "1019: #ifndef OLDER_OPENSSL",
          "1022: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1052:     }",
          "1053:     BN_bin2bn(publ_exp->pValue, publ_exp->ulValueLen, e);",
          "1069:     ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);",
          "1070:     if (ctx == NULL) {",
          "1071:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "",
          "[Removed Lines]",
          "1055: #ifdef OLDER_OPENSSL",
          "1056:     rsa = RSA_new();",
          "1057:     if (rsa == NULL) {",
          "1058:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "1059:         return CKR_HOST_MEMORY;",
          "1060:     }",
          "1062:     if (!RSA_generate_key_ex(rsa, mod_bits, e, NULL)) {",
          "1063:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1064:         rc = CKR_FUNCTION_FAILED;",
          "1065:         goto done;",
          "1066:     }",
          "1067:     bignum = rsa->n;",
          "1068: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1084:         rc = CKR_FUNCTION_FAILED;",
          "1085:         goto done;",
          "1086:     }",
          "1087:     if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, e) != 1) {",
          "1088:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1089:         rc = CKR_FUNCTION_FAILED;",
          "1090:         goto done;",
          "1091:     }",
          "1092:     if (EVP_PKEY_keygen(ctx, &pkey) != 1) {",
          "1093:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1094:         rc = CKR_FUNCTION_FAILED;",
          "1095:         goto done;",
          "1096:     }",
          "1097:     if ((rsa = EVP_PKEY_get0_RSA(pkey)) == NULL) {",
          "1098:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1099:         rc = CKR_FUNCTION_FAILED;",
          "1100:         goto done;",
          "1101:     }",
          "1102:     RSA_get0_key(rsa, &bignum, NULL, NULL);",
          "1103: #endif",
          "1104:     BNLength = BN_num_bytes(bignum);",
          "1105:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1122:     }",
          "1123:     free(ssl_ptr);",
          "1124:     ssl_ptr = NULL;",
          "1130:     RSA_get0_key(rsa, NULL, &bignum, NULL);",
          "1131: #endif",
          "1132:     BNLength = BN_num_bytes(bignum);",
          "1133:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1127: #ifdef OLDER_OPENSSL",
          "1128:     bignum = rsa->e;",
          "1129: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1166:     }",
          "1167:     free(ssl_ptr);",
          "1168:     ssl_ptr = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1195:     RSA_get0_key(rsa, &bignum, NULL, NULL);",
          "1196: #endif",
          "1197:     BNLength = BN_num_bytes(bignum);",
          "1198:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1192: #ifdef OLDER_OPENSSL",
          "1193:     bignum = rsa->n;",
          "1194: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1215:     }",
          "1216:     free(ssl_ptr);",
          "1217:     ssl_ptr = NULL;",
          "1223:     RSA_get0_key(rsa, NULL, NULL, &bignum);",
          "1224: #endif",
          "1225:     BNLength = BN_num_bytes(bignum);",
          "1226:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1220: #ifdef OLDER_OPENSSL",
          "1221:     bignum = rsa->d;",
          "1222: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1245:     OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1246:     free(ssl_ptr);",
          "1247:     ssl_ptr = NULL;",
          "1254:     RSA_get0_factors(rsa, &bignum, NULL);",
          "1255: #endif",
          "1256:     BNLength = BN_num_bytes(bignum);",
          "1257:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1251: #ifdef OLDER_OPENSSL",
          "1252:     bignum = rsa->p;",
          "1253: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1276:     OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1277:     free(ssl_ptr);",
          "1278:     ssl_ptr = NULL;",
          "1285:     RSA_get0_factors(rsa, NULL, &bignum);",
          "1286: #endif",
          "1287:     BNLength = BN_num_bytes(bignum);",
          "1288:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1282: #ifdef OLDER_OPENSSL",
          "1283:     bignum = rsa->q;",
          "1284: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1307:     OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1308:     free(ssl_ptr);",
          "1309:     ssl_ptr = NULL;",
          "1316:     RSA_get0_crt_params(rsa, &bignum, NULL, NULL);",
          "1317: #endif",
          "1318:     BNLength = BN_num_bytes(bignum);",
          "1319:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1313: #ifdef OLDER_OPENSSL",
          "1314:     bignum = rsa->dmp1;",
          "1315: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1338:     OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1339:     free(ssl_ptr);",
          "1340:     ssl_ptr = NULL;",
          "1347:     RSA_get0_crt_params(rsa, NULL, &bignum, NULL);",
          "1348: #endif",
          "1349:     BNLength = BN_num_bytes(bignum);",
          "1350:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1344: #ifdef OLDER_OPENSSL",
          "1345:     bignum = rsa->dmq1;",
          "1346: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1369:     OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1370:     free(ssl_ptr);",
          "1371:     ssl_ptr = NULL;",
          "1378:     RSA_get0_crt_params(rsa, NULL, NULL, &bignum);",
          "1379: #endif",
          "1380:     BNLength = BN_num_bytes(bignum);",
          "1381:     ssl_ptr = malloc(BNLength);",
          "",
          "[Removed Lines]",
          "1375: #ifdef OLDER_OPENSSL",
          "1376:     bignum = rsa->iqmp;",
          "1377: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1400:     OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1401:     free(ssl_ptr);",
          "1402:     ssl_ptr = NULL;",
          "1404:     flag = TRUE;",
          "1405:     rc = build_attribute(CKA_LOCAL, &flag, sizeof(CK_BBOOL), &attr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1415:     }",
          "1417: done:",
          "1428:     if (ssl_ptr != NULL) {",
          "1429:         OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1430:         free(ssl_ptr);",
          "",
          "[Removed Lines]",
          "1418: #ifdef OLDER_OPENSSL",
          "1419:     if (e != NULL)",
          "1420:         BN_free(e);",
          "1421:     if (rsa != NULL)",
          "1422:         RSA_free(rsa);",
          "1423:     if (ssl_ptr != NULL) {",
          "1424:         OPENSSL_cleanse(ssl_ptr, BNLength);",
          "1425:         free(ssl_ptr);",
          "1426:     }",
          "1427: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1433:         EVP_PKEY_free(pkey);",
          "1434:     if (ctx != NULL)",
          "1435:         EVP_PKEY_CTX_free(ctx);",
          "1436: #endif",
          "1437:     return rc;",
          "1438: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1457:                                      CK_ULONG in_data_len,",
          "1458:                                      CK_BYTE *out_data, OBJECT *key_obj)",
          "1459: {",
          "1488:     EVP_PKEY_CTX *ctx = NULL;",
          "1489:     EVP_PKEY *pkey = NULL;",
          "1491:     CK_RV rc;",
          "1492:     size_t outlen = in_data_len;",
          "1502:     if (pkey == NULL) {",
          "1509:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1510:         rc = CKR_FUNCTION_FAILED;",
          "1512:     }",
          "1515:     ctx = EVP_PKEY_CTX_new(pkey, NULL);",
          "1516:     if (ctx == NULL) {",
          "",
          "[Removed Lines]",
          "1460: #ifdef OLDER_OPENSSL",
          "1461:     CK_RV rc;",
          "1462:     RSA *rsa;",
          "1463:     int size;",
          "1466:     rsa = (RSA *) rsa_convert_public_key(key_obj);",
          "1467:     if (rsa == NULL) {",
          "1468:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1469:         rc = CKR_FUNCTION_FAILED;",
          "1470:         return rc;",
          "1471:     }",
          "1473:     size =",
          "1474:         RSA_public_encrypt(in_data_len, in_data, out_data, rsa, RSA_NO_PADDING);",
          "1475:     if (size == -1) {",
          "1476:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1477:         rc = CKR_ARGUMENTS_BAD;",
          "1478:         goto done;",
          "1479:     }",
          "1481:     rc = CKR_OK;",
          "1483: done:",
          "1484:     RSA_free(rsa);",
          "1486:     return rc;",
          "1487: #else",
          "1490:     RSA *rsa = NULL;",
          "1494:     rsa = (RSA *)rsa_convert_public_key(key_obj);",
          "1495:     if (rsa == NULL) {",
          "1496:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1497:         rc = CKR_FUNCTION_FAILED;",
          "1498:         return rc;",
          "1499:     }",
          "1501:     pkey = EVP_PKEY_new();",
          "1503:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "1504:         rc = CKR_HOST_MEMORY;",
          "1505:         goto done;",
          "1506:     }",
          "1508:     if (EVP_PKEY_assign_RSA(pkey, rsa) != 1) {",
          "1511:         goto done;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1539:     rc = CKR_OK;",
          "1540: done:",
          "1543:     if (pkey != NULL)",
          "1544:         EVP_PKEY_free(pkey);",
          "1545:     if (ctx != NULL)",
          "1546:         EVP_PKEY_CTX_free(ctx);",
          "1547:     return rc;",
          "1549: }",
          "1551: static CK_RV os_specific_rsa_decrypt(CK_BYTE *in_data,",
          "1552:                                      CK_ULONG in_data_len,",
          "1553:                                      CK_BYTE *out_data, OBJECT *key_obj)",
          "1554: {",
          "1585:     EVP_PKEY_CTX *ctx = NULL;",
          "1586:     EVP_PKEY *pkey = NULL;",
          "1588:     size_t outlen = in_data_len;",
          "1589:     CK_RV rc;",
          "1599:     if (pkey == NULL) {",
          "1606:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1607:         rc = CKR_FUNCTION_FAILED;",
          "1609:     }",
          "1612:     ctx = EVP_PKEY_CTX_new(pkey, NULL);",
          "1613:     if (ctx == NULL) {",
          "",
          "[Removed Lines]",
          "1541:     if (rsa != NULL)",
          "1542:         RSA_free(rsa);",
          "1548: #endif",
          "1555: #ifdef OLDER_OPENSSL",
          "1556:     CK_RV rc;",
          "1557:     RSA *rsa;",
          "1558:     int size;",
          "1561:     rsa = (RSA *) rsa_convert_private_key(key_obj);",
          "1562:     if (rsa == NULL) {",
          "1563:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1564:         rc = CKR_FUNCTION_FAILED;",
          "1565:         return rc;",
          "1566:     }",
          "1568:     size =",
          "1569:         RSA_private_decrypt(in_data_len, in_data, out_data, rsa,",
          "1570:                             RSA_NO_PADDING);",
          "1572:     if (size == -1) {",
          "1573:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1574:         rc = CKR_FUNCTION_FAILED;",
          "1575:         goto done;",
          "1576:     }",
          "1578:     rc = CKR_OK;",
          "1580: done:",
          "1581:     RSA_free(rsa);",
          "1583:     return rc;",
          "1584: #else",
          "1587:     RSA *rsa = NULL;",
          "1591:     rsa = (RSA *)rsa_convert_private_key(key_obj);",
          "1592:     if (rsa == NULL) {",
          "1593:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "1594:         rc = CKR_FUNCTION_FAILED;",
          "1595:         return rc;",
          "1596:     }",
          "1598:     pkey = EVP_PKEY_new();",
          "1600:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "1601:         rc = CKR_HOST_MEMORY;",
          "1602:         goto done;",
          "1603:     }",
          "1605:     if (EVP_PKEY_assign_RSA(pkey, rsa) != 1) {",
          "1608:         goto done;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1636:     rc = CKR_OK;",
          "1637: done:",
          "1640:     if (pkey != NULL)",
          "1641:         EVP_PKEY_free(pkey);",
          "1642:     if (ctx != NULL)",
          "1643:         EVP_PKEY_CTX_free(ctx);",
          "1644:     return rc;",
          "1646: }",
          "1648: CK_RV token_specific_rsa_encrypt(STDLL_TokData_t *tokdata, CK_BYTE *in_data,",
          "",
          "[Removed Lines]",
          "1638:     if (rsa != NULL)",
          "1639:         RSA_free(rsa);",
          "1645: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2407:                              CK_ULONG *out_data_len,",
          "2408:                              OBJECT *key, CK_BYTE encrypt)",
          "2409: {",
          "2452:     CK_RV rc;",
          "2453:     int outlen;",
          "2454:     unsigned char akey[32];",
          "",
          "[Removed Lines]",
          "2410: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "2411:     AES_KEY ssl_aes_key;",
          "2412:     unsigned int i;",
          "2413:     CK_ATTRIBUTE *attr = NULL;",
          "2416:     CK_ULONG loops = (CK_ULONG) (in_data_len / AES_BLOCK_SIZE);",
          "2417:     CK_RV rc;",
          "2419:     UNUSED(tokdata);",
          "2421:     memset(&ssl_aes_key, 0, sizeof(AES_KEY));",
          "2424:     rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "2425:     if (rc != CKR_OK) {",
          "2426:         TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");",
          "2427:         return rc;",
          "2428:     }",
          "2431:     if (encrypt) {",
          "2432:         AES_set_encrypt_key((unsigned char *) attr->pValue,",
          "2433:                             (attr->ulValueLen * 8), &ssl_aes_key);",
          "2434:         for (i = 0; i < loops; i++) {",
          "2435:             AES_ecb_encrypt((unsigned char *) in_data + (i * AES_BLOCK_SIZE),",
          "2436:                             (unsigned char *) out_data + (i * AES_BLOCK_SIZE),",
          "2437:                             &ssl_aes_key, AES_ENCRYPT);",
          "2438:         }",
          "2439:     } else {",
          "2440:         AES_set_decrypt_key((unsigned char *) attr->pValue,",
          "2441:                             (attr->ulValueLen * 8), &ssl_aes_key);",
          "2442:         for (i = 0; i < loops; i++) {",
          "2443:             AES_ecb_encrypt((unsigned char *) in_data + (i * AES_BLOCK_SIZE),",
          "2444:                             (unsigned char *) out_data + (i * AES_BLOCK_SIZE),",
          "2445:                             &ssl_aes_key, AES_DECRYPT);",
          "2446:         }",
          "2447:     }",
          "2450:     return CKR_OK;",
          "2451: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2505:     OPENSSL_cleanse(akey, sizeof(akey));",
          "2506:     EVP_CIPHER_CTX_free(ctx);",
          "2507:     return rc;",
          "2509: }",
          "2511: CK_RV token_specific_aes_cbc(STDLL_TokData_t *tokdata,",
          "",
          "[Removed Lines]",
          "2508: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2515:                              CK_ULONG *out_data_len,",
          "2516:                              OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)",
          "2517: {",
          "2550:     CK_RV rc;",
          "2551:     int outlen;",
          "2552:     unsigned char akey[32];",
          "",
          "[Removed Lines]",
          "2518: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "2519:     AES_KEY ssl_aes_key;",
          "2520:     CK_ATTRIBUTE *attr = NULL;",
          "2521:     CK_RV rc;",
          "2523:     UNUSED(tokdata);",
          "2525:     memset(&ssl_aes_key, 0, sizeof(AES_KEY));",
          "2528:     rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "2529:     if (rc != CKR_OK) {",
          "2530:         TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");",
          "2531:         return rc;",
          "2532:     }",
          "2535:     if (encrypt) {",
          "2536:         AES_set_encrypt_key((unsigned char *) attr->pValue,",
          "2537:                             (attr->ulValueLen * 8), &ssl_aes_key);",
          "2538:         AES_cbc_encrypt((unsigned char *) in_data, (unsigned char *) out_data,",
          "2539:                         in_data_len, &ssl_aes_key, init_v, AES_ENCRYPT);",
          "2540:     } else {",
          "2541:         AES_set_decrypt_key((unsigned char *) attr->pValue,",
          "2542:                             (attr->ulValueLen * 8), &ssl_aes_key);",
          "2543:         AES_cbc_encrypt((unsigned char *) in_data, (unsigned char *) out_data,",
          "2544:                         in_data_len, &ssl_aes_key, init_v, AES_DECRYPT);",
          "2545:     }",
          "2548:     return CKR_OK;",
          "2549: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2603:     OPENSSL_cleanse(akey, sizeof(akey));",
          "2604:     EVP_CIPHER_CTX_free(ctx);",
          "2605:     return rc;",
          "2607: }",
          "2609: CK_RV token_specific_aes_mac(STDLL_TokData_t *tokdata, CK_BYTE *message,",
          "",
          "[Removed Lines]",
          "2606: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2716:                                           TEMPLATE *publ_tmpl,",
          "2717:                                           TEMPLATE *priv_tmpl)",
          "2718: {",
          "2720:     CK_RV rv;",
          "2721:     CK_BBOOL rc;",
          "2722:     CK_ATTRIBUTE *prime_attr = NULL;",
          "2723:     CK_ATTRIBUTE *base_attr = NULL;",
          "2724:     CK_ATTRIBUTE *temp_attr = NULL;",
          "2725:     CK_ATTRIBUTE *value_bits_attr = NULL;",
          "2727:     CK_ULONG temp_bn_len;",
          "2733:     UNUSED(tokdata);",
          "2735:     rv = template_attribute_get_non_empty(publ_tmpl, CKA_PRIME, &prime_attr);",
          "2736:     if (rv != CKR_OK) {",
          "2737:         TRACE_ERROR(\"Could not find CKA_PRIME for the key.\\n\");",
          "2739:     }",
          "2740:     rv = template_attribute_get_non_empty(publ_tmpl, CKA_BASE, &base_attr);",
          "2741:     if (rv != CKR_OK) {",
          "2742:         TRACE_ERROR(\"Could not find CKA_BASE for the key.\\n\");",
          "2744:     }",
          "2746:     if ((prime_attr->ulValueLen > 256) || (prime_attr->ulValueLen < 64)) {",
          "2747:         TRACE_ERROR(\"CKA_PRIME attribute value is invalid.\\n\");",
          "2749:     }",
          "2757:     bn_p = BN_new();",
          "2758:     bn_g = BN_new();",
          "2759:     if (bn_g == NULL || bn_p == NULL) {",
          "2764:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "2766:     }",
          "2768:     BN_bin2bn((unsigned char *) prime_attr->pValue, prime_attr->ulValueLen,",
          "2769:               bn_p);",
          "2770:     BN_bin2bn((unsigned char *) base_attr->pValue, base_attr->ulValueLen, bn_g);",
          "2776:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "2779:     }",
          "2893: #else",
          "2976:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "2978:         goto done;",
          "2979:     }",
          "2989:     temp_bn_len = BN_num_bytes(temp_bn);",
          "2990:     temp_byte = malloc(temp_bn_len);",
          "",
          "[Removed Lines]",
          "2719: #if OPENSSL_VERSION_NUMBER < 0x10100000L",
          "2726:     CK_BYTE *temp_byte;",
          "2728:     DH *dh;",
          "2729:     BIGNUM *bn_p;",
          "2730:     BIGNUM *bn_g;",
          "2731:     const BIGNUM *temp_bn;",
          "2738:         return rv;",
          "2743:         return rv;",
          "2748:         return CKR_ATTRIBUTE_VALUE_INVALID;",
          "2751:     dh = DH_new();",
          "2752:     if (dh == NULL) {",
          "2753:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "2754:         return CKR_FUNCTION_FAILED;",
          "2755:     }",
          "2760:         if (bn_g)",
          "2761:             BN_free(bn_g);",
          "2762:         if (bn_p)",
          "2763:             BN_free(bn_p);",
          "2765:         return CKR_HOST_MEMORY;",
          "2771:     dh->p = bn_p;",
          "2772:     dh->g = bn_g;",
          "2775:     if (!DH_generate_key(dh)) {",
          "2777:         DH_free(dh);",
          "2778:         return CKR_FUNCTION_FAILED;",
          "2787:     temp_bn = dh->pub_key;",
          "2788:     temp_bn_len = BN_num_bytes(temp_bn);",
          "2789:     temp_byte = malloc(temp_bn_len);",
          "2790:     temp_bn_len = BN_bn2bin(temp_bn, temp_byte);",
          "2792:     rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);",
          "2793:     if (rc != CKR_OK) {",
          "2794:         TRACE_DEVEL(\"build_attribute failed\\n\");",
          "2795:         DH_free(dh);",
          "2796:         free(temp_byte);",
          "2797:         return CKR_FUNCTION_FAILED;",
          "2798:     }",
          "2799:     rc = template_update_attribute(publ_tmpl, temp_attr);",
          "2800:     if (rc != CKR_OK) {",
          "2801:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2802:         free(temp_attr);",
          "2803:         DH_free(dh);",
          "2804:         free(temp_byte);",
          "2805:         return rc;",
          "2806:     }",
          "2807:     free(temp_byte);",
          "2813:     temp_bn = dh->priv_key;",
          "2814:     temp_bn_len = BN_num_bytes(temp_bn);",
          "2815:     temp_byte = malloc(temp_bn_len);",
          "2816:     temp_bn_len = BN_bn2bin(temp_bn, temp_byte);",
          "2818:     rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);",
          "2819:     if (rc != CKR_OK) {",
          "2820:         TRACE_DEVEL(\"build_attribute failed\\n\");",
          "2821:         DH_free(dh);",
          "2822:         free(temp_byte);",
          "2823:         return CKR_FUNCTION_FAILED;",
          "2824:     }",
          "2825:     rc = template_update_attribute(priv_tmpl, temp_attr);",
          "2826:     if (rc != CKR_OK) {",
          "2827:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2828:         free(temp_attr);",
          "2829:         DH_free(dh);",
          "2830:         free(temp_byte);",
          "2831:         return rc;",
          "2832:     }",
          "2833:     free(temp_byte);",
          "2836:     value_bits_attr =",
          "2837:         (CK_ATTRIBUTE *) malloc(sizeof(CK_ATTRIBUTE) + sizeof(CK_ULONG));",
          "2838:     if (value_bits_attr == NULL) {",
          "2839:         TRACE_ERROR(\"malloc failed\\n\");",
          "2840:         DH_free(dh);",
          "2841:         return CKR_HOST_MEMORY;",
          "2842:     }",
          "2843:     value_bits_attr->type = CKA_VALUE_BITS;",
          "2844:     value_bits_attr->ulValueLen = sizeof(CK_ULONG);",
          "2845:     value_bits_attr->pValue =",
          "2846:         (CK_BYTE *) value_bits_attr + sizeof(CK_ATTRIBUTE);",
          "2848:     rc = template_update_attribute(priv_tmpl, value_bits_attr);",
          "2849:     if (rc != CKR_OK) {",
          "2850:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2851:         free(value_bits_attr);",
          "2852:         DH_free(dh);",
          "2853:         return rc;",
          "2854:     }",
          "2857:     rc = build_attribute(CKA_PRIME,",
          "2858:                          (unsigned char *) prime_attr->pValue,",
          "2859:                          prime_attr->ulValueLen, &temp_attr);  // in bytes",
          "2860:     if (rc != CKR_OK) {",
          "2861:         TRACE_DEVEL(\"build_attribute failed\\n\");",
          "2862:         DH_free(dh);",
          "2863:         return CKR_FUNCTION_FAILED;",
          "2864:     }",
          "2865:     rc = template_update_attribute(priv_tmpl, temp_attr);",
          "2866:     if (rc != CKR_OK) {",
          "2867:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2868:         free(temp_attr);",
          "2869:         DH_free(dh);",
          "2870:         return rc;",
          "2871:     }",
          "2873:     rc = build_attribute(CKA_BASE,",
          "2874:                          (unsigned char *) base_attr->pValue,",
          "2875:                          base_attr->ulValueLen, &temp_attr);     // in bytes",
          "2876:     if (rc != CKR_OK) {",
          "2877:         TRACE_DEVEL(\"build_attribute failed\\n\");",
          "2878:         DH_free(dh);",
          "2879:         return CKR_FUNCTION_FAILED;",
          "2880:     }",
          "2881:     rc = template_update_attribute(priv_tmpl, temp_attr);",
          "2882:     if (rc != CKR_OK) {",
          "2883:         TRACE_ERROR(\"template_update_attribute failed\\n\");",
          "2884:         free(temp_attr);",
          "2885:         DH_free(dh);",
          "2886:         return rc;",
          "2887:     }",
          "2890:     DH_free(dh);",
          "2892:     return CKR_OK;",
          "2894:     CK_RV rv;",
          "2895:     CK_BBOOL rc;",
          "2896:     CK_ATTRIBUTE *prime_attr = NULL;",
          "2897:     CK_ATTRIBUTE *base_attr = NULL;",
          "2898:     CK_ATTRIBUTE *temp_attr = NULL;",
          "2899:     CK_ATTRIBUTE *value_bits_attr = NULL;",
          "2900:     CK_BYTE *temp_byte = NULL, *temp_byte2 = NULL;",
          "2901:     CK_ULONG temp_bn_len;",
          "2902:     DH *dh = NULL;",
          "2903:     BIGNUM *bn_p = NULL;",
          "2904:     BIGNUM *bn_g = NULL;",
          "2905:     const BIGNUM *temp_bn = NULL;",
          "2906:     EVP_PKEY *params = NULL, *pkey = NULL;",
          "2907:     EVP_PKEY_CTX *ctx = NULL;",
          "2909:     UNUSED(tokdata);",
          "2911:     rv = template_attribute_get_non_empty(publ_tmpl, CKA_PRIME, &prime_attr);",
          "2912:     if (rv != CKR_OK) {",
          "2913:         TRACE_ERROR(\"Could not find CKA_PRIME for the key.\\n\");",
          "2914:         goto done;",
          "2915:     }",
          "2916:     rv = template_attribute_get_non_empty(publ_tmpl, CKA_BASE, &base_attr);",
          "2917:     if (rv != CKR_OK) {",
          "2918:         TRACE_ERROR(\"Could not find CKA_BASE for the key.\\n\");",
          "2919:         goto done;",
          "2920:     }",
          "2922:     if ((prime_attr->ulValueLen > 256) || (prime_attr->ulValueLen < 64)) {",
          "2923:         TRACE_ERROR(\"CKA_PRIME attribute value is invalid.\\n\");",
          "2924:         rv = CKR_ATTRIBUTE_VALUE_INVALID;",
          "2925:         goto done;",
          "2926:     }",
          "2928:     dh = DH_new();",
          "2929:     if (dh == NULL) {",
          "2930:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "2931:         rv = CKR_FUNCTION_FAILED;",
          "2932:         goto done;",
          "2933:     }",
          "2935:     bn_p = BN_new();",
          "2936:     bn_g = BN_new();",
          "2937:     if (bn_g == NULL || bn_p == NULL) {",
          "2938:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "2939:         rv = CKR_HOST_MEMORY;",
          "2940:         goto done;",
          "2941:     }",
          "2943:     BN_bin2bn((unsigned char *) prime_attr->pValue, prime_attr->ulValueLen,",
          "2944:               bn_p);",
          "2945:     BN_bin2bn((unsigned char *) base_attr->pValue, base_attr->ulValueLen, bn_g);",
          "2946:     DH_set0_pqg(dh, bn_p, NULL, bn_g);",
          "2948:     bn_p = NULL;",
          "2949:     bn_g = NULL;",
          "2951:     params = EVP_PKEY_new();",
          "2952:     if (params == NULL) {",
          "2953:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "2954:         rv = CKR_HOST_MEMORY;",
          "2955:         goto done;",
          "2956:     }",
          "2958:     if (EVP_PKEY_assign_DH(params, dh) != 1) {",
          "2959:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));",
          "2960:         rv = CKR_FUNCTION_FAILED;",
          "2961:         goto done;",
          "2962:     }",
          "2965:     ctx = EVP_PKEY_CTX_new(params, NULL);",
          "2966:     if (ctx == NULL) {",
          "2967:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "2968:         rv = CKR_HOST_MEMORY;",
          "2969:         goto done;",
          "2970:     }",
          "2972:     if (EVP_PKEY_keygen_init(ctx) != 1",
          "2973:         || EVP_PKEY_keygen(ctx, &pkey) != 1",
          "2975:         || (dh = EVP_PKEY_get0_DH(pkey)) == NULL) {",
          "2977:         rv = CKR_FUNCTION_FAILED;",
          "2987:     DH_get0_key(dh, &temp_bn, NULL);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3001:         free(temp_attr);",
          "3002:         goto done;",
          "3003:     }",
          "3008:     DH_get0_key(dh, NULL, &temp_bn);",
          "3009:     temp_bn_len = BN_num_bytes(temp_bn);",
          "3010:     temp_byte2 = malloc(temp_bn_len);",
          "3011:     temp_bn_len = BN_bn2bin(temp_bn, temp_byte2);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3022:         free(temp_attr);",
          "3023:         goto done;",
          "3024:     }",
          "3027:     value_bits_attr =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3086:         EVP_PKEY_free(params);",
          "3087:     free(temp_byte);",
          "3088:     free(temp_byte2);",
          "3090: #endif",
          "3092: #endif",
          "",
          "[Removed Lines]",
          "3089:     return rv;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3106:     return ock_generic_get_mechanism_info(tokdata, type, pInfo);",
          "3107: }",
          "3114: static const EVP_MD *md_from_mech(CK_MECHANISM *mech)",
          "3115: {",
          "3116:     const EVP_MD *md = NULL;",
          "",
          "[Removed Lines]",
          "3109: #ifdef OLDER_OPENSSL",
          "3110: #define EVP_MD_meth_get_app_datasize(md)        md->ctx_size",
          "3111: #define EVP_MD_CTX_md_data(ctx)                 ctx->md_data",
          "3112: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3168:     return md;",
          "3169: }",
          "3171: static EVP_MD_CTX *md_ctx_from_context(DIGEST_CONTEXT *ctx)",
          "3172: {",
          "3173:     const EVP_MD *md;",
          "3174:     EVP_MD_CTX *md_ctx;",
          "3179:     md_ctx = EVP_MD_CTX_new();",
          "3181:     if (md_ctx == NULL)",
          "3182:         return NULL;",
          "",
          "[Removed Lines]",
          "3176: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3177:     md_ctx = EVP_MD_CTX_create();",
          "3178: #else",
          "3180: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3185:     if (md == NULL ||",
          "3186:         !EVP_DigestInit_ex(md_ctx, md, NULL)) {",
          "3187:         TRACE_ERROR(\"md_from_mech or EVP_DigestInit_ex failed\\n\");",
          "3191:         EVP_MD_CTX_free(md_ctx);",
          "3193:         return NULL;",
          "3194:     }",
          "",
          "[Removed Lines]",
          "3188: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3189:         EVP_MD_CTX_destroy(md_ctx);",
          "3190: #else",
          "3192: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3198:         ctx->context = malloc(ctx->context_len);",
          "3199:         if (ctx->context == NULL) {",
          "3200:             TRACE_ERROR(\"malloc failed\\n\");",
          "3204:             EVP_MD_CTX_free(md_ctx);",
          "3206:             ctx->context_len = 0;",
          "3207:             return NULL;",
          "3208:         }",
          "",
          "[Removed Lines]",
          "3201:     #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3202:             EVP_MD_CTX_destroy(md_ctx);",
          "3203:     #else",
          "3205:     #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3222:     return md_ctx;",
          "3223: }",
          "3225: CK_RV token_specific_sha_init(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,",
          "3226:                               CK_MECHANISM *mech)",
          "3227: {",
          "3228:     EVP_MD_CTX *md_ctx;",
          "3230:     UNUSED(tokdata);",
          "3232:     ctx->mech.ulParameterLen = mech->ulParameterLen;",
          "3233:     ctx->mech.mechanism = mech->mechanism;",
          "3235:     md_ctx = md_ctx_from_context(ctx);",
          "3236:     if (md_ctx == NULL) {",
          "3237:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "3238:         return CKR_HOST_MEMORY;",
          "3239:     }",
          "3244:     EVP_MD_CTX_free(md_ctx);",
          "3245: #endif",
          "3247:     return CKR_OK;",
          "",
          "[Removed Lines]",
          "3241: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3242:     EVP_MD_CTX_destroy(md_ctx);",
          "3243: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3253: {",
          "3254:     unsigned int len;",
          "3255:     CK_RV rc = CKR_OK;",
          "3256:     EVP_MD_CTX *md_ctx;",
          "3258:     UNUSED(tokdata);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "3263:     if (!in_data || !out_data)",
          "3264:         return CKR_ARGUMENTS_BAD;",
          "3267:     md_ctx = md_ctx_from_context(ctx);",
          "3268:     if (md_ctx == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "3276:     if (!EVP_DigestUpdate(md_ctx, in_data, in_data_len) ||",
          "3277:         !EVP_DigestFinal(md_ctx, out_data, &len)) {",
          "3278:         rc = CKR_FUNCTION_FAILED;",
          "3279:         goto out;",
          "3280:     }",
          "3284: out:",
          "3288:     EVP_MD_CTX_free(md_ctx);",
          "3290:     free(ctx->context);",
          "3291:     ctx->context = NULL;",
          "3292:     ctx->context_len = 0;",
          "3294:     return rc;",
          "3295: }",
          "",
          "[Removed Lines]",
          "3285: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3286:     EVP_MD_CTX_destroy(md_ctx);",
          "3287: #else",
          "3289: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "3297: CK_RV token_specific_sha_update(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,",
          "3298:                                 CK_BYTE *in_data, CK_ULONG in_data_len)",
          "3299: {",
          "3300:     EVP_MD_CTX *md_ctx;",
          "3302:     UNUSED(tokdata);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "3307:     if (!in_data)",
          "3308:         return CKR_ARGUMENTS_BAD;",
          "3311:     md_ctx = md_ctx_from_context(ctx);",
          "3312:     if (md_ctx == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "3315:     }",
          "3317:     if (!EVP_DigestUpdate(md_ctx, in_data, in_data_len)) {",
          "3321:         EVP_MD_CTX_free(md_ctx);",
          "3323:         free(ctx->context);",
          "3324:         ctx->context = NULL;",
          "3325:         ctx->context_len = 0;",
          "3326:         return CKR_FUNCTION_FAILED;",
          "3327:     }",
          "3330:     memcpy(ctx->context,  EVP_MD_CTX_md_data(md_ctx), ctx->context_len);",
          "3335:     EVP_MD_CTX_free(md_ctx);",
          "3336: #endif",
          "3338:     return CKR_OK;",
          "",
          "[Removed Lines]",
          "3318: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3319:         EVP_MD_CTX_destroy(md_ctx);",
          "3320: #else",
          "3322: #endif",
          "3332: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3333:     EVP_MD_CTX_destroy(md_ctx);",
          "3334: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "3343: {",
          "3344:     unsigned int len;",
          "3345:     CK_RV rc = CKR_OK;",
          "3346:     EVP_MD_CTX *md_ctx;",
          "3348:     UNUSED(tokdata);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "3353:     if (!out_data)",
          "3354:         return CKR_ARGUMENTS_BAD;",
          "3357:     md_ctx = md_ctx_from_context(ctx);",
          "3358:     if (md_ctx == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "3372: out:",
          "3376:     EVP_MD_CTX_free(md_ctx);",
          "3378:     free(ctx->context);",
          "3379:     ctx->context = NULL;",
          "3380:     ctx->context_len = 0;",
          "3382:     return rc;",
          "3383: }",
          "",
          "[Removed Lines]",
          "3373: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3374:     EVP_MD_CTX_destroy(md_ctx);",
          "3375: #else",
          "3377: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "3897:                                CK_ULONG message_len, OBJECT *key, CK_BYTE *mac,",
          "3898:                                CK_BBOOL first, CK_BBOOL last, CK_VOID_PTR *ctx)",
          "3899: {",
          "3901:     int rc;",
          "3983:     CK_RV rv = CKR_OK;",
          "3984:     CK_ATTRIBUTE *attr = NULL;",
          "3985:     CK_KEY_TYPE keytype;",
          "3986:     const EVP_CIPHER *cipher;",
          "3987:     struct cmac_ctx {",
          "3988:         EVP_MD_CTX *mctx;",
          "3989:         EVP_PKEY_CTX *pctx;",
          "3990:         EVP_PKEY *pkey;",
          "3991:     };",
          "3992:     struct cmac_ctx *cmac = NULL;",
          "3994:     UNUSED(tokdata);",
          "",
          "[Removed Lines]",
          "3900: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "3902:     CK_RV rv = CKR_OK;",
          "3903:     CK_ATTRIBUTE *attr = NULL;",
          "3904:     CK_KEY_TYPE keytype;",
          "3905:     CMAC_CTX *cmac_ctx;",
          "3906:     const EVP_CIPHER *cipher;",
          "3907:     size_t maclen;",
          "3909:     UNUSED(tokdata);",
          "3911:     if (first) {",
          "3913:         rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);",
          "3914:         if (rc != CKR_OK) {",
          "3915:             TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key.\\n\");",
          "3916:             return CKR_FUNCTION_FAILED;",
          "3917:         }",
          "3920:         rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "3921:         if (rc != CKR_OK) {",
          "3922:             TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");",
          "3923:             return rc;",
          "3924:         }",
          "3925:         switch (keytype) {",
          "3926:         case CKK_DES2:",
          "3927:             cipher = EVP_des_ede_cbc();",
          "3928:             break;",
          "3929:         case CKK_DES3:",
          "3930:             cipher = EVP_des_ede3_cbc();",
          "3931:             break;",
          "3932:         default:",
          "3933:             TRACE_ERROR(\"Invalid key type: %lu\\n\", keytype);",
          "3934:             return CKR_KEY_TYPE_INCONSISTENT;",
          "3935:         }",
          "3936:         if (cipher == NULL) {",
          "3937:             TRACE_ERROR(\"Failed to allocate cipher\\n\");",
          "3938:             return CKR_HOST_MEMORY;",
          "3939:         }",
          "3941:         cmac_ctx = CMAC_CTX_new();",
          "3942:         if (cmac_ctx == NULL) {",
          "3943:             TRACE_ERROR(\"Failed to allocate CMAC context\\n\");",
          "3944:             return CKR_HOST_MEMORY;",
          "3945:         }",
          "3947:         rc = CMAC_Init(cmac_ctx, attr->pValue, attr->ulValueLen, cipher, NULL);",
          "3948:         if (rc != 1) {",
          "3949:             TRACE_ERROR(\"CMAC_Init failed\\n\");",
          "3950:             CMAC_CTX_free(cmac_ctx);",
          "3951:             return CKR_FUNCTION_FAILED;",
          "3952:         }",
          "3955:     }",
          "3957:     cmac_ctx = (CMAC_CTX *)*ctx;",
          "3959:     rc = CMAC_Update(cmac_ctx, message, message_len);",
          "3960:     if (rc != 1) {",
          "3961:         TRACE_ERROR(\"CMAC_Update failed\\n\");",
          "3962:         rv =  CKR_FUNCTION_FAILED;",
          "3963:     }",
          "3965:     if (last) {",
          "3966:         maclen = AES_BLOCK_SIZE;",
          "3967:         rc = CMAC_Final(cmac_ctx, mac, &maclen);",
          "3968:         if (rc != 1) {",
          "3969:             TRACE_ERROR(\"CMAC_Final failed\\n\");",
          "3970:             rv = CKR_FUNCTION_FAILED;",
          "3971:         }",
          "3972:     }",
          "3974:     if (last || (first && rv != CKR_OK)) {",
          "3975:         CMAC_CTX_free(cmac_ctx);",
          "3977:     }",
          "3979:     return rv;",
          "3980: #else",
          "3981:     int rc;",
          "3982:     size_t maclen;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "4031:             goto err;",
          "4032:         }",
          "4034:         cmac->mctx = EVP_MD_CTX_new();",
          "4035:         if (cmac->mctx == NULL) {",
          "4036:             TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "4038:             goto err;",
          "4039:         }",
          "",
          "[Removed Lines]",
          "4037:             rv = ERR_HOST_MEMORY;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "4053:             rv = CKR_FUNCTION_FAILED;",
          "4054:             goto err;",
          "4055:         }",
          "4058:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "4064:         goto err;",
          "4065:     }",
          "4067:     rc = EVP_DigestSignUpdate(cmac->mctx, message, message_len);",
          "4068:     if (rc != 1 || message_len > INT_MAX) {",
          "4069:         TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");",
          "4070:         rv =  CKR_FUNCTION_FAILED;",
          "4071:         goto err;",
          "4072:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "4074:     if (last) {",
          "4075:         maclen = AES_BLOCK_SIZE;",
          "4077:         rc = EVP_DigestSignFinal(cmac->mctx, mac, &maclen);",
          "4078:         if (rc != 1) {",
          "4079:             TRACE_ERROR(\"EVP_DigestSignFinal failed\\n\");",
          "4080:             rv = CKR_FUNCTION_FAILED;",
          "4081:             goto err;",
          "4082:         }",
          "4085:         EVP_PKEY_free(cmac->pkey);",
          "4086:         free(cmac);",
          "4088:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "4090:     return CKR_OK;",
          "4091: err:",
          "4092:     if (cmac != NULL) {",
          "4093:         if (cmac->mctx != NULL)",
          "4095:         if (cmac->pkey != NULL)",
          "4096:             EVP_PKEY_free(cmac->pkey);",
          "4097:         free(cmac);",
          "4098:     }",
          "4100:     return rv;",
          "4102: }",
          "",
          "[Removed Lines]",
          "4101: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "4106:                               CK_ULONG message_len, OBJECT *key, CK_BYTE *mac,",
          "4107:                               CK_BBOOL first, CK_BBOOL last, CK_VOID_PTR *ctx)",
          "4108: {",
          "4185:     int rc;",
          "4186:     size_t maclen;",
          "4187:     CK_RV rv = CKR_OK;",
          "4188:     CK_ATTRIBUTE *attr = NULL;",
          "4189:     const EVP_CIPHER *cipher;",
          "4190:     struct cmac_ctx {",
          "4191:         EVP_MD_CTX *mctx;",
          "4192:         EVP_PKEY_CTX *pctx;",
          "4193:         EVP_PKEY *pkey;",
          "4194:     };",
          "4195:     struct cmac_ctx *cmac = NULL;",
          "4197:     UNUSED(tokdata);",
          "",
          "[Removed Lines]",
          "4109: #if OPENSSL_VERSION_NUMBER < 0x10101000L",
          "4110:     int rc;",
          "4111:     CK_RV rv = CKR_OK;",
          "4112:     CK_ATTRIBUTE *attr = NULL;",
          "4113:     CMAC_CTX *cmac_ctx;",
          "4114:     const EVP_CIPHER *cipher;",
          "4115:     size_t maclen;",
          "4117:     UNUSED(tokdata);",
          "4119:     if (first) {",
          "4120:         rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);",
          "4121:         if (rc != CKR_OK) {",
          "4122:             TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");",
          "4123:             return rc;",
          "4124:         }",
          "4126:         switch (attr->ulValueLen * 8) {",
          "4127:         case 128:",
          "4128:             cipher = EVP_aes_128_cbc();",
          "4129:             break;",
          "4130:         case 192:",
          "4131:             cipher = EVP_aes_192_cbc();",
          "4132:             break;",
          "4133:         case 256:",
          "4134:             cipher = EVP_aes_256_cbc();",
          "4135:             break;",
          "4136:         default:",
          "4137:             TRACE_ERROR(\"Invalid key size: %lu\\n\", attr->ulValueLen);",
          "4138:             return CKR_KEY_TYPE_INCONSISTENT;",
          "4139:         }",
          "4140:         if (cipher == NULL) {",
          "4141:             TRACE_ERROR(\"Failed to allocate cipher\\n\");",
          "4142:             return CKR_HOST_MEMORY;",
          "4143:         }",
          "4145:         cmac_ctx = CMAC_CTX_new();",
          "4146:         if (cmac_ctx == NULL) {",
          "4147:             TRACE_ERROR(\"Failed to allocate CMAC context\\n\");",
          "4148:             return CKR_HOST_MEMORY;",
          "4149:         }",
          "4151:         rc = CMAC_Init(cmac_ctx, attr->pValue, attr->ulValueLen, cipher, NULL);",
          "4152:         if (rc != 1) {",
          "4153:             TRACE_ERROR(\"CMAC_Init failed\\n\");",
          "4154:             CMAC_CTX_free(cmac_ctx);",
          "4155:             return CKR_FUNCTION_FAILED;",
          "4156:         }",
          "4159:     }",
          "4161:     cmac_ctx = (CMAC_CTX *)*ctx;",
          "4163:     rc = CMAC_Update(cmac_ctx, message, message_len);",
          "4164:     if (rc != 1) {",
          "4165:         TRACE_ERROR(\"CMAC_Update failed\\n\");",
          "4166:         rv =  CKR_FUNCTION_FAILED;",
          "4167:     }",
          "4169:     if (last) {",
          "4170:         maclen = AES_BLOCK_SIZE;",
          "4171:         rc = CMAC_Final(cmac_ctx, mac, &maclen);",
          "4172:         if (rc != 1) {",
          "4173:             TRACE_ERROR(\"CMAC_Final failed\\n\");",
          "4174:             rv = CKR_FUNCTION_FAILED;",
          "4175:         }",
          "4176:     }",
          "4178:     if (last || (first && rv != CKR_OK)) {",
          "4179:         CMAC_CTX_free(cmac_ctx);",
          "4181:     }",
          "4183:     return rv;",
          "4184: #else",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "4229:             goto err;",
          "4230:         }",
          "4232:         cmac->mctx = EVP_MD_CTX_new();",
          "4233:         if (cmac->mctx == NULL) {",
          "4234:             TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "4251:             rv = CKR_FUNCTION_FAILED;",
          "4252:             goto err;",
          "4253:         }",
          "4256:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "4262:         goto err;",
          "4263:     }",
          "4265:     rc = EVP_DigestSignUpdate(cmac->mctx, message, message_len);",
          "4266:     if (rc != 1 || message_len > INT_MAX) {",
          "4267:         TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");",
          "4268:         rv =  CKR_FUNCTION_FAILED;",
          "4269:         goto err;",
          "4270:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "4272:     if (last) {",
          "4273:         maclen = AES_BLOCK_SIZE;",
          "4275:         rc = EVP_DigestSignFinal(cmac->mctx, mac, &maclen);",
          "4276:         if (rc != 1) {",
          "4277:             TRACE_ERROR(\"EVP_DigestSignFinal failed\\n\");",
          "4278:             rv = CKR_FUNCTION_FAILED;",
          "4279:             goto err;",
          "4280:         }",
          "4283:         EVP_PKEY_free(cmac->pkey);",
          "4284:         free(cmac);",
          "4286:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "4288:     return CKR_OK;",
          "4289: err:",
          "4290:     if (cmac != NULL) {",
          "4291:         if (cmac->mctx != NULL)",
          "4293:         if (cmac->pkey != NULL)",
          "4294:             EVP_PKEY_free(cmac->pkey);",
          "4295:         free(cmac);",
          "4296:     }",
          "4298:     return rv;",
          "4300: }",
          "4302: #ifndef NO_EC",
          "4306: {",
          "4307:     const unsigned char *oid;",
          "4308:     ASN1_OBJECT *obj = NULL;",
          "4310:     int nid;",
          "4313:     oid = params;",
          "4314:     obj = d2i_ASN1_OBJECT(NULL, &oid, params_len);",
          "4315:     if (obj == NULL) {",
          "4316:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "4319:     }",
          "4321:     nid = OBJ_obj2nid(obj);",
          "4322:     if (nid == NID_undef) {",
          "4323:         TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");",
          "4324:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "4299: #endif",
          "4304: static CK_RV make_ec_key_from_params(const CK_BYTE *params, CK_ULONG params_len,",
          "4305:                                      EC_KEY **key)",
          "4309:     EC_KEY *ec_key = NULL;",
          "4311:     CK_RV rc = CKR_OK;",
          "4317:         rc = CKR_CURVE_NOT_SUPPORTED;",
          "4318:         goto out;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "4333:     }",
          "4335: out:",
          "4339:     if (rc != CKR_OK) {",
          "4340:         if (ec_key != NULL)",
          "4341:             EC_KEY_free(ec_key);",
          "",
          "[Removed Lines]",
          "4336:     if (obj != NULL)",
          "4337:         ASN1_OBJECT_free(obj);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "4348:     return CKR_OK;",
          "4349: }",
          "4351: static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,",
          "4353: {",
          "4354:     CK_BYTE *ecpoint = NULL;",
          "4355:     CK_ULONG ecpoint_len, privlen;",
          "4356:     CK_BBOOL allocated = FALSE;",
          "4357:     CK_RV rc;",
          "4361:     rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,",
          "4362:                                    &allocated, &ecpoint, &ecpoint_len);",
          "",
          "[Removed Lines]",
          "4352:                                      CK_ULONG data_len, CK_BBOOL allow_raw)",
          "4359:     privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "4365:         goto out;",
          "4366:     }",
          "4368:     if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {",
          "4369:         TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");",
          "4370:         rc = CKR_FUNCTION_FAILED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "4377:         goto out;",
          "4378:     }",
          "4380: out:",
          "4381:     if (allocated && ecpoint != NULL)",
          "4382:         free(ecpoint);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "4384:     return rc;",
          "4385: }",
          "4387: static CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,",
          "4389: {",
          "4390:     EC_POINT *point = NULL;",
          "4391:     CK_RV rc = CKR_OK;",
          "4393:     if (!EC_KEY_oct2priv(ec_key, data, data_len)) {",
          "4394:         TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");",
          "4395:         rc = CKR_FUNCTION_FAILED;",
          "",
          "[Removed Lines]",
          "4388:                                       CK_ULONG data_len)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "4422:         goto out;",
          "4423:     }",
          "4425: out:",
          "4426:     if (point != NULL)",
          "4427:         EC_POINT_free(point);",
          "4429:     return rc;",
          "4430: }",
          "4433: {",
          "4434:     CK_ATTRIBUTE *attr = NULL;",
          "4435:     CK_OBJECT_CLASS keyclass;",
          "4436:     EC_KEY *ec_key = NULL;",
          "4437:     CK_RV rc;",
          "4439:     rc = template_attribute_get_ulong(template, CKA_CLASS, &keyclass);",
          "",
          "[Removed Lines]",
          "4432: static CK_RV make_ec_key_from_template(TEMPLATE *template, EC_KEY **key)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "4448:         goto out;",
          "4449:     }",
          "4451:     rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);",
          "4452:     if (rc != CKR_OK)",
          "4453:         goto out;",
          "4455:     switch (keyclass) {",
          "4456:     case CKO_PUBLIC_KEY:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "4460:             goto out;",
          "4461:         }",
          "4463:         rc = fill_ec_key_from_pubkey(ec_key, attr->pValue, attr->ulValueLen,",
          "4465:         if (rc != CKR_OK) {",
          "4466:             TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");",
          "4467:             goto out;",
          "",
          "[Removed Lines]",
          "4464:                                      FALSE);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "4475:             goto out;",
          "4476:         }",
          "4479:         if (rc != CKR_OK) {",
          "4480:             TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");",
          "4481:             goto out;",
          "",
          "[Removed Lines]",
          "4478:         rc = fill_ec_key_from_privkey(ec_key, attr->pValue, attr->ulValueLen);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "4487:         goto out;",
          "4488:     }",
          "4490:     rc = CKR_OK;",
          "4492: out:",
          "4493:     if (rc != CKR_OK) {",
          "4494:         if (ec_key != NULL)",
          "4495:             EC_KEY_free(ec_key);",
          "4497:         return rc;",
          "4498:     }",
          "4502:     return CKR_OK;",
          "4503: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "4508: {",
          "4510:     CK_ATTRIBUTE *attr = NULL, *ec_point_attr, *value_attr, *parms_attr;",
          "4513:     CK_BYTE *ecpoint = NULL, *enc_ecpoint = NULL, *d = NULL;",
          "4514:     CK_ULONG ecpoint_len, enc_ecpoint_len, d_len;",
          "4515:     CK_RV rc;",
          "4517:     UNUSED(tokdata);",
          "",
          "[Removed Lines]",
          "4511:     EC_KEY *ec_key = NULL;",
          "4512:     BN_CTX *ctx = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "4520:     if (rc != CKR_OK)",
          "4521:         goto out;",
          "4525:         goto out;",
          "4529:         rc = CKR_FUNCTION_FAILED;",
          "4530:         goto out;",
          "4531:     }",
          "4535:         rc = CKR_HOST_MEMORY;",
          "4536:         goto out;",
          "4537:     }",
          "4539:     ecpoint_len = EC_KEY_key2buf(ec_key, POINT_CONVERSION_UNCOMPRESSED,",
          "4541:     if (ecpoint_len == 0) {",
          "4542:         TRACE_ERROR(\"Failed to get the EC Point compressed.\\n\");",
          "4543:         rc = CKR_FUNCTION_FAILED;",
          "4544:         goto out;",
          "4545:     }",
          "4547:     rc = ber_encode_OCTET_STRING(FALSE, &enc_ecpoint, &enc_ecpoint_len,",
          "4548:                                  ecpoint, ecpoint_len);",
          "",
          "[Removed Lines]",
          "4523:     rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);",
          "4524:     if (rc != CKR_OK)",
          "4527:     if (!EC_KEY_generate_key(ec_key)) {",
          "4528:         TRACE_ERROR(\"Failed to generate an EC key.\\n\");",
          "4533:     ctx = BN_CTX_new();",
          "4534:     if (ctx == NULL) {",
          "4540:                                  &ecpoint, ctx);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "4564:         goto out;",
          "4565:     }",
          "4567:     d_len = EC_KEY_priv2buf(ec_key, &d);",
          "4568:     if (d_len == 0) {",
          "4569:         TRACE_ERROR(\"Failed to get the EC private key.\\n\");",
          "4570:         rc = CKR_FUNCTION_FAILED;",
          "4571:         goto out;",
          "4572:     }",
          "4574:     rc = build_attribute(CKA_VALUE, d, d_len, &value_attr);",
          "4575:     if (rc != CKR_OK) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "4602:     rc = CKR_OK;",
          "4604: out:",
          "4609:     if (ecpoint != NULL)",
          "4610:         OPENSSL_free(ecpoint);",
          "4611:     if (enc_ecpoint != NULL)",
          "",
          "[Removed Lines]",
          "4605:     if (ctx)",
          "4606:         BN_CTX_free(ctx);",
          "4607:     if (ec_key != NULL)",
          "4608:         EC_KEY_free(ec_key);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "4621:                              CK_BYTE *out_data, CK_ULONG *out_data_len,",
          "4622:                              OBJECT *key_obj)",
          "4623: {",
          "4626:     const BIGNUM *r, *s;",
          "4627:     CK_ULONG privlen, n;",
          "4628:     CK_RV rc = CKR_OK;",
          "4630:     UNUSED(tokdata);",
          "4631:     UNUSED(sess);",
          "",
          "[Removed Lines]",
          "4624:     EC_KEY *ec_key;",
          "4625:     ECDSA_SIG *sig;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "4636:     if (rc != CKR_OK)",
          "4637:         return rc;",
          "4640:     if (sig == NULL) {",
          "4642:         rc = CKR_FUNCTION_FAILED;",
          "4643:         goto out;",
          "4644:     }",
          "4646:     ECDSA_SIG_get0(sig, &r, &s);",
          "4651:     n = privlen - BN_num_bytes(r);",
          "",
          "[Removed Lines]",
          "4639:     sig = ECDSA_do_sign(in_data, in_data_len, ec_key);",
          "4641:         TRACE_ERROR(\"ECDSA_do_sign failed\\n\");",
          "4648:     privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "4662:     if (sig != NULL)",
          "4663:         ECDSA_SIG_free(sig);",
          "4664:     if (ec_key != NULL)",
          "4667:     return rc;",
          "4668: }",
          "",
          "[Removed Lines]",
          "4665:         EC_KEY_free(ec_key);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "4674:                                CK_BYTE *signature,",
          "4675:                                CK_ULONG signature_len, OBJECT *key_obj)",
          "4676: {",
          "4678:     CK_ULONG privlen;",
          "4679:     ECDSA_SIG *sig = NULL;",
          "4680:     BIGNUM *r = NULL, *s = NULL;",
          "4681:     CK_RV rc = CKR_OK;",
          "4683:     UNUSED(tokdata);",
          "4684:     UNUSED(sess);",
          "",
          "[Removed Lines]",
          "4677:     EC_KEY *ec_key;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "4687:     if (rc != CKR_OK)",
          "4688:         return rc;",
          "4692:     if (signature_len < 2 * privlen) {",
          "4693:         TRACE_ERROR(\"Signature is too short\\n\");",
          "",
          "[Removed Lines]",
          "4690:     privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "4715:         goto out;",
          "4716:     }",
          "4719:     switch (rc) {",
          "4720:     case 0:",
          "4721:         rc = CKR_SIGNATURE_INVALID;",
          "",
          "[Removed Lines]",
          "4718:     rc = ECDSA_do_verify(in_data, in_data_len, sig, ec_key);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "4732:     if (sig != NULL)",
          "4733:         ECDSA_SIG_free(sig);",
          "4734:     if (ec_key != NULL)",
          "4737:     return rc;",
          "4738: }",
          "",
          "[Removed Lines]",
          "4735:         EC_KEY_free(ec_key);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "4746:                                       CK_ULONG *secret_value_len,",
          "4747:                                       CK_BYTE *oid, CK_ULONG oid_length)",
          "4748: {",
          "4752:     CK_RV rc;",
          "4754:     UNUSED(tokdata);",
          "4757:     if (rc != CKR_OK) {",
          "4758:         TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");",
          "4759:         goto out;",
          "4760:     }",
          "4763:     if (rc != CKR_OK) {",
          "4764:         TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");",
          "4765:         goto out;",
          "4766:     }",
          "4769:     if (rc != CKR_OK) {",
          "4770:         TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");",
          "4771:         goto out;",
          "4772:     }",
          "4775:     if (rc != CKR_OK) {",
          "4776:         TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");",
          "4777:         goto out;",
          "4778:     }",
          "4786:         TRACE_DEVEL(\"ECDH_compute_key failed\\n\");",
          "4787:         rc = CKR_FUNCTION_FAILED;",
          "",
          "[Removed Lines]",
          "4749:     EC_KEY *ec_pub = NULL, *ec_priv = NULL;",
          "4750:     CK_ULONG privlen;",
          "4751:     int secret_len;",
          "4756:     rc = make_ec_key_from_params(oid, oid_length, &ec_priv);",
          "4762:     rc = fill_ec_key_from_privkey(ec_priv, priv_bytes, priv_length);",
          "4768:     rc = make_ec_key_from_params(oid, oid_length, &ec_pub);",
          "4774:     rc = fill_ec_key_from_pubkey(ec_pub, pub_bytes, pub_length, TRUE);",
          "4780:     privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_priv)) + 7) / 8;",
          "4782:     secret_len = ECDH_compute_key(secret_value, privlen,",
          "4783:                                   EC_KEY_get0_public_key(ec_pub), ec_priv,",
          "4784:                                   NULL);",
          "4785:     if (secret_len <= 0) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "4794: out:",
          "4795:     if (ec_priv != NULL)",
          "4797:     if (ec_pub != NULL)",
          "4800:     return rc;",
          "4801: }",
          "",
          "[Removed Lines]",
          "4796:         EC_KEY_free(ec_priv);",
          "4798:         EC_KEY_free(ec_pub);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "4807: {",
          "4808:     CK_KEY_TYPE keytype;",
          "4809: #ifndef NO_EC",
          "4811: #endif",
          "4812:     CK_RV rc;",
          "",
          "[Removed Lines]",
          "4810:     EC_KEY *ec_key = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "4825:         rc = make_ec_key_from_template(obj->template, &ec_key);",
          "4826:         if (ec_key != NULL)",
          "4828:         return rc;",
          "4829: #endif",
          "",
          "[Removed Lines]",
          "4827:                 EC_KEY_free(ec_key);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
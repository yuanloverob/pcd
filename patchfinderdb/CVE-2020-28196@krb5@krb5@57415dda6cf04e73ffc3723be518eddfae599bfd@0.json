{
  "cve_id": "CVE-2020-28196",
  "cve_desc": "MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.",
  "repo": "krb5/krb5",
  "patch_hash": "57415dda6cf04e73ffc3723be518eddfae599bfd",
  "patch_info": {
    "commit_hash": "57415dda6cf04e73ffc3723be518eddfae599bfd",
    "repo": "krb5/krb5",
    "commit_url": "https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd",
    "files": [
      "src/lib/krb5/asn.1/asn1_encode.c"
    ],
    "message": "Add recursion limit for ASN.1 indefinite lengths\n\nThe libkrb5 ASN.1 decoder supports BER indefinite lengths.  It\ncomputes the tag length using recursion; the lack of a recursion limit\nallows an attacker to overrun the stack and cause the process to\ncrash.  Reported by Demi Obenour.\n\nCVE-2020-28196:\n\nIn MIT krb5 releases 1.11 and later, an unauthenticated attacker can\ncause a denial of service for any client or server to which it can\nsend an ASN.1-encoded Kerberos message of sufficient length.\n\nticket: 8959 (new)\ntags: pullup\ntarget_version: 1.18-next\ntarget_version: 1.17-next",
    "before_after_code_files": [
      "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
    ]
  },
  "patch_diff": {
    "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c": [
      "File: src/lib/krb5/asn.1/asn1_encode.c -> src/lib/krb5/asn.1/asn1_encode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "356: static krb5_error_code",
      "357: get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,",
      "358:         const uint8_t **contents_out, size_t *clen_out,",
      "360: {",
      "361:     krb5_error_code ret;",
      "362:     uint8_t o;",
      "",
      "[Removed Lines]",
      "359:         const uint8_t **remainder_out, size_t *rlen_out)",
      "",
      "[Added Lines]",
      "359:         const uint8_t **remainder_out, size_t *rlen_out, int recursion)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "395:         if (tag_out->construction != CONSTRUCTED)",
      "396:             return ASN1_MISMATCH_INDEF;",
      "397:         p = asn1;",
      "398:         while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {",
      "400:             if (ret)",
      "401:                 return ret;",
      "402:         }",
      "",
      "[Removed Lines]",
      "399:             ret = get_tag(p, len, &t, &c, &clen, &p, &len);",
      "",
      "[Added Lines]",
      "397:         if (recursion >= 32)",
      "398:             return ASN1_OVERFLOW;",
      "401:             ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "613:     const uint8_t *contents, *remainder;",
      "614:     size_t clen, rlen;",
      "617:     if (ret)",
      "618:         return ret;",
      "619:     if (rlen != 0)",
      "",
      "[Removed Lines]",
      "616:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);",
      "",
      "[Added Lines]",
      "618:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1199:         const uint8_t *rem;",
      "1200:         size_t rlen;",
      "1201:         if (!tag->implicit) {",
      "1203:             if (ret)",
      "1204:                 return ret;",
      "",
      "[Removed Lines]",
      "1202:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);",
      "",
      "[Added Lines]",
      "1204:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1420:     for (i = 0; i < seq->n_fields; i++) {",
      "1421:         if (len == 0)",
      "1422:             break;",
      "1424:         if (ret)",
      "1425:             goto error;",
      "",
      "[Removed Lines]",
      "1423:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
      "",
      "[Added Lines]",
      "1425:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1480:     while (len > 0) {",
      "1482:         if (ret)",
      "1483:             goto error;",
      "1484:         if (!check_atype_tag(elemtype, &t)) {",
      "",
      "[Removed Lines]",
      "1481:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
      "",
      "[Added Lines]",
      "1483:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1586:     ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,",
      "1588:     if (ret)",
      "1589:         return ret;",
      "",
      "[Removed Lines]",
      "1587:                   &clen, &remainder, &rlen);",
      "",
      "[Added Lines]",
      "1589:                   &clen, &remainder, &rlen, 0);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "207ad69c87cf1b5c047d6c0c0165e5afe29700a6",
      "candidate_info": {
        "commit_hash": "207ad69c87cf1b5c047d6c0c0165e5afe29700a6",
        "repo": "krb5/krb5",
        "commit_url": "https://github.com/krb5/krb5/commit/207ad69c87cf1b5c047d6c0c0165e5afe29700a6",
        "files": [
          "src/lib/krb5/asn.1/asn1_encode.c"
        ],
        "message": "Add recursion limit for ASN.1 indefinite lengths\n\nThe libkrb5 ASN.1 decoder supports BER indefinite lengths.  It\ncomputes the tag length using recursion; the lack of a recursion limit\nallows an attacker to overrun the stack and cause the process to\ncrash.  Reported by Demi Obenour.\n\nCVE-2020-28196:\n\nIn MIT krb5 releases 1.11 and later, an unauthenticated attacker can\ncause a denial of service for any client or server to which it can\nsend an ASN.1-encoded Kerberos message of sufficient length.\n\n(cherry picked from commit 57415dda6cf04e73ffc3723be518eddfae599bfd)\n\nticket: 8959\nversion_fixed: 1.18.3",
        "before_after_code_files": [
          "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
          ],
          "candidate": [
            "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c": [
          "File: src/lib/krb5/asn.1/asn1_encode.c -> src/lib/krb5/asn.1/asn1_encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "356: static krb5_error_code",
          "357: get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,",
          "358:         const uint8_t **contents_out, size_t *clen_out,",
          "360: {",
          "361:     krb5_error_code ret;",
          "362:     uint8_t o;",
          "",
          "[Removed Lines]",
          "359:         const uint8_t **remainder_out, size_t *rlen_out)",
          "",
          "[Added Lines]",
          "359:         const uint8_t **remainder_out, size_t *rlen_out, int recursion)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "395:         if (tag_out->construction != CONSTRUCTED)",
          "396:             return ASN1_MISMATCH_INDEF;",
          "397:         p = asn1;",
          "398:         while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {",
          "400:             if (ret)",
          "401:                 return ret;",
          "402:         }",
          "",
          "[Removed Lines]",
          "399:             ret = get_tag(p, len, &t, &c, &clen, &p, &len);",
          "",
          "[Added Lines]",
          "397:         if (recursion >= 32)",
          "398:             return ASN1_OVERFLOW;",
          "401:             ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "613:     const uint8_t *contents, *remainder;",
          "614:     size_t clen, rlen;",
          "617:     if (ret)",
          "618:         return ret;",
          "619:     if (rlen != 0)",
          "",
          "[Removed Lines]",
          "616:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);",
          "",
          "[Added Lines]",
          "618:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1199:         const uint8_t *rem;",
          "1200:         size_t rlen;",
          "1201:         if (!tag->implicit) {",
          "1203:             if (ret)",
          "1204:                 return ret;",
          "",
          "[Removed Lines]",
          "1202:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);",
          "",
          "[Added Lines]",
          "1204:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1420:     for (i = 0; i < seq->n_fields; i++) {",
          "1421:         if (len == 0)",
          "1422:             break;",
          "1424:         if (ret)",
          "1425:             goto error;",
          "",
          "[Removed Lines]",
          "1423:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
          "",
          "[Added Lines]",
          "1425:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1480:     while (len > 0) {",
          "1482:         if (ret)",
          "1483:             goto error;",
          "1484:         if (!check_atype_tag(elemtype, &t)) {",
          "",
          "[Removed Lines]",
          "1481:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
          "",
          "[Added Lines]",
          "1483:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1586:     ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,",
          "1588:     if (ret)",
          "1589:         return ret;",
          "",
          "[Removed Lines]",
          "1587:                   &clen, &remainder, &rlen);",
          "",
          "[Added Lines]",
          "1589:                   &clen, &remainder, &rlen, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9239fa1d0124bdf3c78c20eb70873e3af2baabb1",
      "candidate_info": {
        "commit_hash": "9239fa1d0124bdf3c78c20eb70873e3af2baabb1",
        "repo": "krb5/krb5",
        "commit_url": "https://github.com/krb5/krb5/commit/9239fa1d0124bdf3c78c20eb70873e3af2baabb1",
        "files": [
          "src/lib/krb5/asn.1/asn1_encode.c"
        ],
        "message": "Add recursion limit for ASN.1 indefinite lengths\n\nThe libkrb5 ASN.1 decoder supports BER indefinite lengths.  It\ncomputes the tag length using recursion; the lack of a recursion limit\nallows an attacker to overrun the stack and cause the process to\ncrash.  Reported by Demi Obenour.\n\nCVE-2020-28196:\n\nIn MIT krb5 releases 1.11 and later, an unauthenticated attacker can\ncause a denial of service for any client or server to which it can\nsend an ASN.1-encoded Kerberos message of sufficient length.\n\n(cherry picked from commit 57415dda6cf04e73ffc3723be518eddfae599bfd)\n\nticket: 8959\nversion_fixed: 1.17.2",
        "before_after_code_files": [
          "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
          ],
          "candidate": [
            "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c": [
          "File: src/lib/krb5/asn.1/asn1_encode.c -> src/lib/krb5/asn.1/asn1_encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "356: static krb5_error_code",
          "357: get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,",
          "358:         const uint8_t **contents_out, size_t *clen_out,",
          "360: {",
          "361:     krb5_error_code ret;",
          "362:     uint8_t o;",
          "",
          "[Removed Lines]",
          "359:         const uint8_t **remainder_out, size_t *rlen_out)",
          "",
          "[Added Lines]",
          "359:         const uint8_t **remainder_out, size_t *rlen_out, int recursion)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "395:         if (tag_out->construction != CONSTRUCTED)",
          "396:             return ASN1_MISMATCH_INDEF;",
          "397:         p = asn1;",
          "398:         while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {",
          "400:             if (ret)",
          "401:                 return ret;",
          "402:         }",
          "",
          "[Removed Lines]",
          "399:             ret = get_tag(p, len, &t, &c, &clen, &p, &len);",
          "",
          "[Added Lines]",
          "397:         if (recursion >= 32)",
          "398:             return ASN1_OVERFLOW;",
          "401:             ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "613:     const uint8_t *contents, *remainder;",
          "614:     size_t clen, rlen;",
          "617:     if (ret)",
          "618:         return ret;",
          "619:     if (rlen != 0)",
          "",
          "[Removed Lines]",
          "616:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);",
          "",
          "[Added Lines]",
          "618:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1199:         const uint8_t *rem;",
          "1200:         size_t rlen;",
          "1201:         if (!tag->implicit) {",
          "1203:             if (ret)",
          "1204:                 return ret;",
          "",
          "[Removed Lines]",
          "1202:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);",
          "",
          "[Added Lines]",
          "1204:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1420:     for (i = 0; i < seq->n_fields; i++) {",
          "1421:         if (len == 0)",
          "1422:             break;",
          "1424:         if (ret)",
          "1425:             goto error;",
          "",
          "[Removed Lines]",
          "1423:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
          "",
          "[Added Lines]",
          "1425:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1480:     while (len > 0) {",
          "1482:         if (ret)",
          "1483:             goto error;",
          "1484:         if (!check_atype_tag(elemtype, &t)) {",
          "",
          "[Removed Lines]",
          "1481:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
          "",
          "[Added Lines]",
          "1483:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1586:     ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,",
          "1588:     if (ret)",
          "1589:         return ret;",
          "",
          "[Removed Lines]",
          "1587:                   &clen, &remainder, &rlen);",
          "",
          "[Added Lines]",
          "1589:                   &clen, &remainder, &rlen, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d9443a58cd364349b7d764f4e997f3af7d979a87",
      "candidate_info": {
        "commit_hash": "d9443a58cd364349b7d764f4e997f3af7d979a87",
        "repo": "krb5/krb5",
        "commit_url": "https://github.com/krb5/krb5/commit/d9443a58cd364349b7d764f4e997f3af7d979a87",
        "files": [
          "src/lib/krb5/asn.1/README.asn1",
          "src/lib/krb5/asn.1/asn1_encode.c",
          "src/lib/krb5/asn.1/asn1_encode.h",
          "src/lib/krb5/asn.1/asn1_k_encode.c",
          "src/lib/krb5/asn.1/krbasn1.h",
          "src/lib/krb5/error_tables/asn1_err.et",
          "src/tests/asn.1/krb5_decode_test.c"
        ],
        "message": "Be stricter about ASN.1 decoding\n\nRemove support for BER indefinite-length encodings, which are not\nvalid in DER.  Enforce validity of digits in GeneralizedTime values.\nReject signed integer encodings large enough to possibly overflow\nintmax_t, and use regular arithmetic to avoid the undefined behavior\nof left-shifting a negative integer.  Reject trailing garbage in\nexplicitly-tagged single values.  Remove the unnecessary\nKRB5_GENEROUS_LR_TYPE workaround; our KDC doesn't generate last-req\ninformation, so the broken pre-2000 encoding behavior had no impact.\n\n[ghudson@mit.edu: edited commit message]",
        "before_after_code_files": [
          "src/lib/krb5/asn.1/README.asn1||src/lib/krb5/asn.1/README.asn1",
          "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c",
          "src/lib/krb5/asn.1/asn1_encode.h||src/lib/krb5/asn.1/asn1_encode.h",
          "src/lib/krb5/asn.1/asn1_k_encode.c||src/lib/krb5/asn.1/asn1_k_encode.c",
          "src/lib/krb5/asn.1/krbasn1.h||src/lib/krb5/asn.1/krbasn1.h",
          "src/lib/krb5/error_tables/asn1_err.et||src/lib/krb5/error_tables/asn1_err.et",
          "src/tests/asn.1/krb5_decode_test.c||src/tests/asn.1/krb5_decode_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
          ],
          "candidate": [
            "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/krb5/asn.1/README.asn1||src/lib/krb5/asn.1/README.asn1": [
          "File: src/lib/krb5/asn.1/README.asn1 -> src/lib/krb5/asn.1/README.asn1",
          "--- Hunk 1 ---",
          "[Context before]",
          "527: field.  It should be very rare for ASN.1 modules to use choice or open",
          "528: types this way.",
          "536: Debugging",
          "537: ---------",
          "",
          "[Removed Lines]",
          "530: For historical interoperability reasons, our decoder accepts the",
          "531: indefinite length form for constructed tags, which is allowed by BER",
          "532: but not DER.  We still require the primitive forms of basic scalar",
          "533: types, however, so we do not accept all BER encodings of ASN.1 values.",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lib/krb5/asn.1/asn1_encode.c||src/lib/krb5/asn.1/asn1_encode.c": [
          "File: src/lib/krb5/asn.1/asn1_encode.c -> src/lib/krb5/asn.1/asn1_encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:     if (len == 0)",
          "192:         return ASN1_BAD_LENGTH;",
          "193:     n = (asn1[0] & 0x80) ? -1 : 0;",
          "196:         return ASN1_OVERFLOW;",
          "197:     for (i = 0; i < len; i++)",
          "200:     return 0;",
          "201: }",
          "",
          "[Removed Lines]",
          "195:     if (len > sizeof(intmax_t) + (asn1[0] == 0))",
          "198:         n = (n << 8) | asn1[i];",
          "",
          "[Added Lines]",
          "195:     if (len > sizeof(intmax_t))",
          "198:         n = n * 256 + asn1[i];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244:     const char *s = (char *)asn1;",
          "245:     struct tm ts;",
          "246:     time_t t;",
          "249:     if (len != 15)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "247:     size_t i;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "256:         return 0;",
          "257:     }",
          "258: #define c2i(c) ((c) - '0')",
          "259:     ts.tm_year = 1000 * c2i(s[0]) + 100 * c2i(s[1]) + 10 * c2i(s[2]) +",
          "260:         c2i(s[3]) - 1900;",
          "261:     ts.tm_mon = 10 * c2i(s[4]) + c2i(s[5]) - 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "260:     for (i = 0; i < 14; ++i) {",
          "261:         if ((uint8_t)c2i(s[i]) > 9)",
          "262:             return ASN1_BAD_TIMEFORMAT;",
          "263:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "344: }",
          "356: static krb5_error_code",
          "357: get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,",
          "358:         const uint8_t **contents_out, size_t *clen_out,",
          "360: {",
          "362:     uint8_t o;",
          "364:     size_t clen, llen, i;",
          "",
          "[Removed Lines]",
          "359:         const uint8_t **remainder_out, size_t *rlen_out, int recursion)",
          "361:     krb5_error_code ret;",
          "363:     const uint8_t *c, *p, *tag_start = asn1;",
          "365:     taginfo t;",
          "",
          "[Added Lines]",
          "360:         const uint8_t **remainder_out, size_t *rlen_out)",
          "363:     const uint8_t *tag_start = asn1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "379:         do {",
          "380:             if (len == 0)",
          "381:                 return ASN1_OVERRUN;",
          "382:             o = *asn1++;",
          "383:             len--;",
          "384:             tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);",
          "385:         } while (o & 0x80);",
          "386:     }",
          "388:     if (len == 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "381:             if (tag_out->tagnum > (ASN1_TAGNUM_MAX >> 7))",
          "382:                 return ASN1_OVERFLOW;",
          "388:         if (tag_out->tagnum > ASN1_TAGNUM_MAX)",
          "389:             return ASN1_OVERFLOW;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "390:     o = *asn1++;",
          "391:     len--;",
          "412:         if (o > len)",
          "413:             return ASN1_OVERRUN;",
          "",
          "[Removed Lines]",
          "393:     if (o == 0x80) {",
          "395:         if (tag_out->construction != CONSTRUCTED)",
          "396:             return ASN1_MISMATCH_INDEF;",
          "397:         if (recursion >= 32)",
          "398:             return ASN1_OVERFLOW;",
          "399:         p = asn1;",
          "400:         while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {",
          "401:             ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);",
          "402:             if (ret)",
          "403:                 return ret;",
          "404:         }",
          "405:         tag_out->tag_end_len = 2;",
          "410:     } else if ((o & 0x80) == 0) {",
          "414:         tag_out->tag_end_len = 0;",
          "",
          "[Added Lines]",
          "397:     if ((o & 0x80) == 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "423:             return ASN1_OVERRUN;",
          "424:         if (llen > sizeof(*clen_out))",
          "425:             return ASN1_OVERFLOW;",
          "426:         for (i = 0, clen = 0; i < llen; i++)",
          "427:             clen = (clen << 8) | asn1[i];",
          "428:         if (clen > len - llen)",
          "429:             return ASN1_OVERRUN;",
          "",
          "[Removed Lines]",
          "430:         tag_out->tag_end_len = 0;",
          "",
          "[Added Lines]",
          "412:         if (llen == 0)",
          "413:             return ASN1_INDEF;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "615:     const uint8_t *contents, *remainder;",
          "616:     size_t clen, rlen;",
          "619:     if (ret)",
          "620:         return ret;",
          "621:     if (rlen != 0)",
          "",
          "[Removed Lines]",
          "618:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);",
          "",
          "[Added Lines]",
          "605:     ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "637:     size_t der_len;",
          "641:     der = malloc(der_len);",
          "642:     if (der == NULL)",
          "643:         return ENOMEM;",
          "",
          "[Removed Lines]",
          "640:     der_len = t->tag_len + len + t->tag_end_len;",
          "",
          "[Added Lines]",
          "627:     der_len = t->tag_len + len;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1201:         const uint8_t *rem;",
          "1202:         size_t rlen;",
          "1203:         if (!tag->implicit) {",
          "1205:             if (ret)",
          "1206:                 return ret;",
          "1208:             tp = &inner_tag;",
          "1209:             if (!check_atype_tag(tag->basetype, tp))",
          "1210:                 return ASN1_BAD_ID;",
          "",
          "[Removed Lines]",
          "1204:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);",
          "",
          "[Added Lines]",
          "1191:             ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);",
          "1194:             if (rlen)",
          "1195:                 return ASN1_BAD_LENGTH;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1422:     for (i = 0; i < seq->n_fields; i++) {",
          "1423:         if (len == 0)",
          "1424:             break;",
          "1426:         if (ret)",
          "1427:             goto error;",
          "",
          "[Removed Lines]",
          "1425:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
          "",
          "[Added Lines]",
          "1413:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1482:     while (len > 0) {",
          "1484:         if (ret)",
          "1485:             goto error;",
          "1486:         if (!check_atype_tag(elemtype, &t)) {",
          "",
          "[Removed Lines]",
          "1483:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);",
          "",
          "[Added Lines]",
          "1471:         ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1588:     ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,",
          "1590:     if (ret)",
          "1591:         return ret;",
          "",
          "[Removed Lines]",
          "1589:                   &clen, &remainder, &rlen, 0);",
          "",
          "[Added Lines]",
          "1577:                   &clen, &remainder, &rlen);",
          "",
          "---------------"
        ],
        "src/lib/krb5/asn.1/asn1_encode.h||src/lib/krb5/asn.1/asn1_encode.h": [
          "File: src/lib/krb5/asn.1/asn1_encode.h -> src/lib/krb5/asn.1/asn1_encode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:     asn1_construction construction;",
          "39:     asn1_tagnum tagnum;",
          "43:     size_t tag_len;",
          "45: } taginfo;",
          "",
          "[Removed Lines]",
          "44:     size_t tag_end_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lib/krb5/asn.1/asn1_k_encode.c||src/lib/krb5/asn.1/asn1_k_encode.c": [
          "File: src/lib/krb5/asn.1/asn1_k_encode.c -> src/lib/krb5/asn.1/asn1_k_encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:         return ret;",
          "335:     if (val > INT32_MAX || val < INT32_MIN)",
          "336:         return ASN1_OVERFLOW;",
          "343:     return 0;",
          "344: }",
          "",
          "[Removed Lines]",
          "337: #ifdef KRB5_GENEROUS_LR_TYPE",
          "339:     if (val >= 128 && val <= 255)",
          "340:         val -= 256;",
          "341: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lib/krb5/asn.1/krbasn1.h||src/lib/krb5/asn.1/krbasn1.h": [
          "File: src/lib/krb5/asn.1/krbasn1.h -> src/lib/krb5/asn.1/krbasn1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <stdlib.h>",
          "11: #endif",
          "30: typedef krb5_error_code asn1_error_code;",
          "32: typedef enum { PRIMITIVE = 0x00, CONSTRUCTED = 0x20 } asn1_construction;",
          "",
          "[Removed Lines]",
          "28: #define KRB5_GENEROUS_LR_TYPE",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lib/krb5/error_tables/asn1_err.et||src/lib/krb5/error_tables/asn1_err.et": [
          "File: src/lib/krb5/error_tables/asn1_err.et -> src/lib/krb5/error_tables/asn1_err.et",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: error_code ASN1_BAD_FORMAT, \"ASN.1 badly-formatted encoding\"",
          "11: error_code ASN1_PARSE_ERROR, \"ASN.1 parse error\"",
          "12: error_code ASN1_BAD_GMTIME, \"ASN.1 bad return from gmtime\"",
          "14: error_code ASN1_MISSING_EOC, \"ASN.1 missing expected EOC\"",
          "15: error_code ASN1_OMITTED, \"ASN.1 object omitted in sequence\"",
          "16: end",
          "",
          "[Removed Lines]",
          "13: error_code ASN1_MISMATCH_INDEF, \"ASN.1 non-constructed indefinite encoding\"",
          "",
          "[Added Lines]",
          "13: error_code ASN1_INDEF, \"ASN.1 indefinite encoding\"",
          "",
          "---------------"
        ],
        "src/tests/asn.1/krb5_decode_test.c||src/tests/asn.1/krb5_decode_test.c": [
          "File: src/tests/asn.1/krb5_decode_test.c -> src/tests/asn.1/krb5_decode_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: #define setup(type,constructor)                                         \\",
          "73:     type ref, *var;                                                     \\",
          "74:     constructor(&ref);                                                  \\",
          "77:     retval = krb5_data_hex_parse(&code,encoding);                       \\",
          "78:     if (retval) {                                                       \\",
          "79:         com_err(\"krb5_decode_test\", retval, \"while parsing %s\", typestring); \\",
          "",
          "[Removed Lines]",
          "76: #define decode_run(typestring,description,encoding,decoder,comparator,cleanup) \\",
          "",
          "[Added Lines]",
          "75:     do {} while (0)",
          "77: #define decode_run(typestring,description,encoding,decoder,comparator,cleanup) do { \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:     test(comparator(&ref,var),typestring);                              \\",
          "88:     printf(\"%s\\n\",description);                                         \\",
          "89:     krb5_free_data_contents(test_context, &code);                       \\",
          "",
          "[Removed Lines]",
          "90:     cleanup(test_context, var);",
          "",
          "[Added Lines]",
          "91:     cleanup(test_context, var);                                         \\",
          "92: } while (0)",
          "94: #define decode_fail(err,typestring,description,encoding,decoder) do {   \\",
          "95:     retval = krb5_data_hex_parse(&code,encoding);                       \\",
          "96:     if (retval) {                                                       \\",
          "97:         com_err(\"krb5_decode_test\", retval, \"while parsing %s\", typestring); \\",
          "98:         exit(1);                                                        \\",
          "99:     }                                                                   \\",
          "100:     retval = decoder(&code,&var);                                       \\",
          "101:     if (retval != (err)) {                                              \\",
          "102:         com_err(\"krb5_decode_test\", retval, \"while decoding %s\", typestring); \\",
          "103:         error_count++;                                                  \\",
          "104:     }                                                                   \\",
          "105:     test(1,typestring);                                                 \\",
          "106:     printf(\"%s\\n\",description);                                         \\",
          "107: } while (0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "303:   \"  00 00 00 00\"",
          "304:   \"00 00 00 00\"",
          "308:   \"61 80 30 80 \"",
          "309:   \"  A0 03 02 01 05 \"",
          "",
          "[Removed Lines]",
          "306:         decode_run(\"ticket\",\"(indefinite lengths)\", \"61 80 30 80 A0 03 02 01 05 A1 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A2 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A3 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 00 00 00 00\" ,decode_krb5_ticket,ktest_equal_ticket,krb5_free_ticket);",
          "",
          "[Added Lines]",
          "323:         decode_fail(ASN1_INDEF,\"ticket\",\"(indefinite lengths)\", \"61 80 30 80 A0 03 02 01 05 A1 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A2 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A3 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 00 00 00 00\" ,decode_krb5_ticket);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "324:   \"  A4 03 02 01 01 \"",
          "325:   \"00 00 00 00\"",
          "329:         ktest_empty_ticket(&ref);",
          "",
          "[Removed Lines]",
          "327:         decode_run(\"ticket\",\"(indefinite lengths + trailing [4] INTEGER)\", \"61 80 30 80 A0 03 02 01 05 A1 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A2 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A3 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 A4 03 02 01 01 00 00 00 00\",decode_krb5_ticket,ktest_equal_ticket,krb5_free_ticket);",
          "",
          "[Added Lines]",
          "344:         decode_fail(ASN1_INDEF,\"ticket\",\"(indefinite lengths + trailing [4] INTEGER)\", \"61 80 30 80 A0 03 02 01 05 A1 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A2 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A3 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 A4 03 02 01 01 00 00 00 00\",decode_krb5_ticket);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "340:         decode_run(\"encryption_key\",\"(+ trailing [2] INTEGER)\",\"30 16 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A2 03 02 01 01\",decode_krb5_encryption_key,ktest_equal_encryption_key,krb5_free_keyblock);",
          "341:         decode_run(\"encryption_key\",\"(+ trailing [2] SEQUENCE {[0] INTEGER})\",\"30 1A A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A2 07 30 05 A0 03 02 01 01\",decode_krb5_encryption_key,ktest_equal_encryption_key,krb5_free_keyblock);",
          "346:         ref.enctype = -1;",
          "347:         decode_run(\"encryption_key\",\"(enctype = -1)\",\"30 11 A0 03 02 01 FF A1 0A 04 08 31 32 33 34 35 36 37 38\",decode_krb5_encryption_key,ktest_equal_encryption_key,krb5_free_keyblock);",
          "348:         ref.enctype = -255;",
          "",
          "[Removed Lines]",
          "342:         decode_run(\"encryption_key\",\"(indefinite lengths)\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 00 00\",decode_krb5_encryption_key,ktest_equal_encryption_key,krb5_free_keyblock);",
          "343:         decode_run(\"encryption_key\",\"(indefinite lengths + trailing [2] INTEGER)\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A2 03 02 01 01 00 00\",decode_krb5_encryption_key,ktest_equal_encryption_key,krb5_free_keyblock);",
          "344:         decode_run(\"encryption_key\",\"(indefinite lengths + trailing [2] SEQUENCE {[0] INTEGER})\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A2 80 30 80 A0 03 02 01 01 00 00 00 00 00 00\",decode_krb5_encryption_key,ktest_equal_encryption_key,krb5_free_keyblock);",
          "345:         decode_run(\"encryption_key\",\"(indefinite lengths + trailing SEQUENCE {[0] INTEGER})\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 30 80 A0 03 02 01 01 00 00 00 00\",decode_krb5_encryption_key,ktest_equal_encryption_key,krb5_free_keyblock);",
          "",
          "[Added Lines]",
          "359:         decode_fail(ASN1_INDEF,\"encryption_key\",\"(indefinite lengths)\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 00 00\",decode_krb5_encryption_key);",
          "360:         decode_fail(ASN1_INDEF,\"encryption_key\",\"(indefinite lengths + trailing [2] INTEGER)\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A2 03 02 01 01 00 00\",decode_krb5_encryption_key);",
          "361:         decode_fail(ASN1_INDEF,\"encryption_key\",\"(indefinite lengths + trailing [2] SEQUENCE {[0] INTEGER})\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A2 80 30 80 A0 03 02 01 01 00 00 00 00 00 00\",decode_krb5_encryption_key);",
          "362:         decode_fail(ASN1_INDEF,\"encryption_key\",\"(indefinite lengths + trailing SEQUENCE {[0] INTEGER})\",\"30 80 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 30 80 A0 03 02 01 01 00 00 00 00\",decode_krb5_encryption_key);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "393:     {",
          "394:         setup(krb5_enc_kdc_rep_part,ktest_make_sample_enc_kdc_rep_part);",
          "400:         decode_run(\"enc_kdc_rep_part\",\"\",\"7A 82 01 0E 30 82 01 0A A0 13 30 11 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A1 36 30 34 30 18 A0 03 02 01 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A 30 18 A0 03 02 01 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A2 03 02 01 2A A3 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A4 07 03 05 00 FE DC BA 98 A5 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A6 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A7 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A8 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A9 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 AA 1A 30 18 A0 03 02 01 01 A1 11 30 0F 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 AB 20 30 1E 30 0D A0 03 02 01 02 A1 06 04 04 12 D0 00 23 30 0D A0 03 02 01 02 A1 06 04 04 12 D0 00 23\",decode_krb5_enc_kdc_rep_part,ktest_equal_enc_kdc_rep_part,krb5_free_enc_kdc_rep_part);",
          "402:         ref.key_exp = 0;",
          "",
          "[Removed Lines]",
          "396: #ifdef KRB5_GENEROUS_LR_TYPE",
          "397:         decode_run(\"enc_kdc_rep_part\",\"(compat_lr_type)\",\"7A 82 01 10 30 82 01 0C A0 13 30 11 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A1 38 30 36 30 19 A0 04 02 02 00 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A 30 19 A0 04 02 02 00 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A2 03 02 01 2A A3 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A4 07 03 05 00 FE DC BA 98 A5 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A6 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A7 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A8 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A9 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 AA 1A 30 18 A0 03 02 01 01 A1 11 30 0F 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 AB 20 30 1E 30 0D A0 03 02 01 02 A1 06 04 04 12 D0 00 23 30 0D A0 03 02 01 02 A1 06 04 04 12 D0 00 23\",decode_krb5_enc_kdc_rep_part,ktest_equal_enc_kdc_rep_part,krb5_free_enc_kdc_rep_part);",
          "398: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "406:         ref.flags &= ~TKT_FLG_RENEWABLE;",
          "407:         ktest_destroy_addresses(&(ref.caddrs));",
          "413:         decode_run(\"enc_kdc_rep_part\",\"(optionals NULL)\",\"7A 81 B2 30 81 AF A0 13 30 11 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A1 36 30 34 30 18 A0 03 02 01 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A 30 18 A0 03 02 01 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A2 03 02 01 2A A4 07 03 05 00 FE 5C BA 98 A5 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A7 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A9 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 AA 1A 30 18 A0 03 02 01 01 A1 11 30 0F 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61\",decode_krb5_enc_kdc_rep_part,ktest_equal_enc_kdc_rep_part,krb5_free_enc_kdc_rep_part);",
          "415:         ktest_empty_enc_kdc_rep_part(&ref);",
          "",
          "[Removed Lines]",
          "409: #ifdef KRB5_GENEROUS_LR_TYPE",
          "410:         decode_run(\"enc_kdc_rep_part\",\"(optionals NULL)(compat lr_type)\",\"7A 81 B4 30 81 B1 A0 13 30 11 A0 03 02 01 01 A1 0A 04 08 31 32 33 34 35 36 37 38 A1 38 30 36 30 19 A0 04 02 02 00 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A 30 19 A0 04 02 02 00 FB A1 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A2 03 02 01 2A A4 07 03 05 00 FE 5C BA 98 A5 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A7 11 18 0F 31 39 39 34 30 36 31 30 30 36 30 33 31 37 5A A9 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 AA 1A 30 18 A0 03 02 01 01 A1 11 30 0F 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61\",decode_krb5_enc_kdc_rep_part,ktest_equal_enc_kdc_rep_part,krb5_free_enc_kdc_rep_part);",
          "411: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "472:   00 00 00 00",
          "473:   00 00 00 00",
          "476:         ktest_destroy_pa_data_array(&(ref.padata));",
          "477:         decode_run(\"as_rep\",\"(optionals NULL)\",\"6B 81 C2 30 81 BF A0 03 02 01 05 A1 03 02 01 0B A3 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A4 1A 30 18 A0 03 02 01 01 A1 11 30 0F 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 A5 5E 61 5C 30 5A A0 03 02 01 05 A1 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A2 1A 30 18 A0 03 02 01 01 A1 11 30 0F 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 A3 25 30 23 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 A6 25 30 23 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65\",decode_krb5_as_rep,ktest_equal_as_rep,krb5_free_kdc_rep);",
          "",
          "[Removed Lines]",
          "475:         decode_run(\"as_rep\",\"(indefinite lengths)\",\"6B 80 30 80 A0 03 02 01 05 A1 03 02 01 0B A2 80 30 80 30 80 A1 03 02 01 0D A2 09 04 07 70 61 2D 64 61 74 61 00 00 30 80 A1 03 02 01 0D A2 09 04 07 70 61 2D 64 61 74 61 00 00 00 00 00 00 A3 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A4 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A5 80 61 80 30 80 A0 03 02 01 05 A1 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A2 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A3 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 00 00 00 00 00 00 A6 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 00 00 00 00\",decode_krb5_as_rep,ktest_equal_as_rep,krb5_free_kdc_rep);",
          "",
          "[Added Lines]",
          "484:         decode_fail(ASN1_INDEF,\"as_rep\",\"(indefinite lengths)\",\"6B 80 30 80 A0 03 02 01 05 A1 03 02 01 0B A2 80 30 80 30 80 A1 03 02 01 0D A2 09 04 07 70 61 2D 64 61 74 61 00 00 30 80 A1 03 02 01 0D A2 09 04 07 70 61 2D 64 61 74 61 00 00 00 00 00 00 A3 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A4 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A5 80 61 80 30 80 A0 03 02 01 05 A1 10 1B 0E 41 54 48 45 4E 41 2E 4D 49 54 2E 45 44 55 A2 80 30 80 A0 03 02 01 01 A1 80 30 80 1B 06 68 66 74 73 61 69 1B 05 65 78 74 72 61 00 00 00 00 00 00 00 00 A3 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 00 00 00 00 00 00 A6 80 30 80 A0 03 02 01 00 A1 03 02 01 05 A2 17 04 15 6B 72 62 41 53 4E 2E 31 20 74 65 73 74 20 6D 65 73 73 61 67 65 00 00 00 00 00 00 00 00\",decode_krb5_as_rep);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
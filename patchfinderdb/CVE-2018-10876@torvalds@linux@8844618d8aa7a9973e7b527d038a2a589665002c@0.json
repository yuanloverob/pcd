{
  "cve_id": "CVE-2018-10876",
  "cve_desc": "A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.",
  "repo": "torvalds/linux",
  "patch_hash": "8844618d8aa7a9973e7b527d038a2a589665002c",
  "patch_info": {
    "commit_hash": "8844618d8aa7a9973e7b527d038a2a589665002c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/8844618d8aa7a9973e7b527d038a2a589665002c",
    "files": [
      "fs/ext4/balloc.c",
      "fs/ext4/ialloc.c",
      "fs/ext4/mballoc.c",
      "fs/ext4/super.c"
    ],
    "message": "ext4: only look at the bg_flags field if it is valid\n\nThe bg_flags field in the block group descripts is only valid if the\nuninit_bg or metadata_csum feature is enabled.  We were not\nconsistently looking at this field; fix this.\n\nAlso block group #0 must never have uninitialized allocation bitmaps,\nor need to be zeroed, since that's where the root inode, and other\nspecial inodes are set up.  Check for these conditions and mark the\nfile system as corrupted if they are detected.\n\nThis addresses CVE-2018-10876.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=199403\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@kernel.org",
    "before_after_code_files": [
      "fs/ext4/balloc.c||fs/ext4/balloc.c",
      "fs/ext4/ialloc.c||fs/ext4/ialloc.c",
      "fs/ext4/mballoc.c||fs/ext4/mballoc.c",
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/balloc.c||fs/ext4/balloc.c": [
      "File: fs/ext4/balloc.c -> fs/ext4/balloc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "438:   goto verify;",
      "439:  }",
      "440:  ext4_lock_group(sb, block_group);",
      "442:   err = ext4_init_block_bitmap(sb, bh, block_group, desc);",
      "443:   set_bitmap_uptodate(bh);",
      "444:   set_buffer_uptodate(bh);",
      "",
      "[Removed Lines]",
      "441:  if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {",
      "",
      "[Added Lines]",
      "441:  if (ext4_has_group_desc_csum(sb) &&",
      "442:      (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {",
      "443:   if (block_group == 0) {",
      "444:    ext4_unlock_group(sb, block_group);",
      "445:    unlock_buffer(bh);",
      "446:    ext4_error(sb, \"Block bitmap for bg 0 marked \"",
      "447:        \"uninitialized\");",
      "448:    err = -EFSCORRUPTED;",
      "449:    goto out;",
      "450:   }",
      "",
      "---------------"
    ],
    "fs/ext4/ialloc.c||fs/ext4/ialloc.c": [
      "File: fs/ext4/ialloc.c -> fs/ext4/ialloc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:  }",
      "152:  ext4_lock_group(sb, block_group);",
      "154:   memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);",
      "155:   ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),",
      "156:          sb->s_blocksize * 8, bh->b_data);",
      "",
      "[Removed Lines]",
      "153:  if (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {",
      "",
      "[Added Lines]",
      "153:  if (ext4_has_group_desc_csum(sb) &&",
      "154:      (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT))) {",
      "155:   if (block_group == 0) {",
      "156:    ext4_unlock_group(sb, block_group);",
      "157:    unlock_buffer(bh);",
      "158:    ext4_error(sb, \"Inode bitmap for bg 0 marked \"",
      "159:        \"uninitialized\");",
      "160:    err = -EFSCORRUPTED;",
      "161:    goto out;",
      "162:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "996:   ext4_lock_group(sb, group);",
      "998:    gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);",
      "999:    ext4_free_group_clusters_set(sb, gdp,",
      "1000:     ext4_free_clusters_after_init(sb, group, gdp));",
      "",
      "[Removed Lines]",
      "997:   if (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {",
      "",
      "[Added Lines]",
      "1006:   if (ext4_has_group_desc_csum(sb) &&",
      "1007:       (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {",
      "",
      "---------------"
    ],
    "fs/ext4/mballoc.c||fs/ext4/mballoc.c": [
      "File: fs/ext4/mballoc.c -> fs/ext4/mballoc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2448:   meta_group_info[i]->bb_free =",
      "2449:    ext4_free_clusters_after_init(sb, group, desc);",
      "2450:  } else {",
      "",
      "[Removed Lines]",
      "2447:  if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {",
      "",
      "[Added Lines]",
      "2447:  if (ext4_has_group_desc_csum(sb) &&",
      "2448:      (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3010: #endif",
      "3011:  ext4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,",
      "3012:         ac->ac_b_ex.fe_len);",
      "3014:   gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);",
      "3015:   ext4_free_group_clusters_set(sb, gdp,",
      "3016:           ext4_free_clusters_after_init(sb,",
      "",
      "[Removed Lines]",
      "3013:  if (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {",
      "",
      "[Added Lines]",
      "3014:  if (ext4_has_group_desc_csum(sb) &&",
      "3015:      (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {",
      "",
      "---------------"
    ],
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3139:  ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;",
      "3140:  struct ext4_group_desc *gdp = NULL;",
      "3142:  for (group = 0; group < ngroups; group++) {",
      "3143:   gdp = ext4_get_group_desc(sb, group, NULL);",
      "3144:   if (!gdp)",
      "3145:    continue;",
      "3148:    break;",
      "3149:  }",
      "3151:  return group;",
      "",
      "[Removed Lines]",
      "3147:   if (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))",
      "",
      "[Added Lines]",
      "3142:  if (!ext4_has_group_desc_csum(sb))",
      "3143:   return ngroups;",
      "3150:   if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))",
      "3151:    continue;",
      "3152:   if (group != 0)",
      "3154:   ext4_error(sb, \"Inode table for bg 0 marked as \"",
      "3155:       \"needing zeroing\");",
      "3156:   if (sb_rdonly(sb))",
      "3157:    return ngroups;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d52e4d0c0c428bf2ba35074a7495cdb28e2efbae",
      "candidate_info": {
        "commit_hash": "d52e4d0c0c428bf2ba35074a7495cdb28e2efbae",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d52e4d0c0c428bf2ba35074a7495cdb28e2efbae",
        "files": [
          "drivers/usb/gadget/function/f_fs.c"
        ],
        "message": "usb: gadget: ffs: Fix BUG when userland exits with submitted AIO transfers\n\nThis bug happens only when the UDC needs to sleep during usb_ep_dequeue,\nas is the case for (at least) dwc3.\n\n[  382.200896] BUG: scheduling while atomic: screen/1808/0x00000100\n[  382.207124] 4 locks held by screen/1808:\n[  382.211266]  #0:  (rcu_callback){....}, at: [<c10b4ff0>] rcu_process_callbacks+0x260/0x440\n[  382.219949]  #1:  (rcu_read_lock_sched){....}, at: [<c1358ba0>] percpu_ref_switch_to_atomic_rcu+0xb0/0x130\n[  382.230034]  #2:  (&(&ctx->ctx_lock)->rlock){....}, at: [<c11f0c73>] free_ioctx_users+0x23/0xd0\n[  382.230096]  #3:  (&(&ffs->eps_lock)->rlock){....}, at: [<f81e7710>] ffs_aio_cancel+0x20/0x60 [usb_f_fs]\n[  382.230160] Modules linked in: usb_f_fs libcomposite configfs bnep btsdio bluetooth ecdh_generic brcmfmac brcmutil intel_powerclamp coretemp dwc3 kvm_intel ulpi udc_core kvm irqbypass crc32_pclmul crc32c_intel pcbc dwc3_pci aesni_intel aes_i586 crypto_simd cryptd ehci_pci ehci_hcd gpio_keys usbcore basincove_gpadc industrialio usb_common\n[  382.230407] CPU: 1 PID: 1808 Comm: screen Not tainted 4.14.0-edison+ #117\n[  382.230416] Hardware name: Intel Corporation Merrifield/BODEGA BAY, BIOS 542 2015.01.21:18.19.48\n[  382.230425] Call Trace:\n[  382.230438]  <SOFTIRQ>\n[  382.230466]  dump_stack+0x47/0x62\n[  382.230498]  __schedule_bug+0x61/0x80\n[  382.230522]  __schedule+0x43/0x7a0\n[  382.230587]  schedule+0x5f/0x70\n[  382.230625]  dwc3_gadget_ep_dequeue+0x14c/0x270 [dwc3]\n[  382.230669]  ? do_wait_intr_irq+0x70/0x70\n[  382.230724]  usb_ep_dequeue+0x19/0x90 [udc_core]\n[  382.230770]  ffs_aio_cancel+0x37/0x60 [usb_f_fs]\n[  382.230798]  kiocb_cancel+0x31/0x40\n[  382.230822]  free_ioctx_users+0x4d/0xd0\n[  382.230858]  percpu_ref_switch_to_atomic_rcu+0x10a/0x130\n[  382.230881]  ? percpu_ref_exit+0x40/0x40\n[  382.230904]  rcu_process_callbacks+0x2b3/0x440\n[  382.230965]  __do_softirq+0xf8/0x26b\n[  382.231011]  ? __softirqentry_text_start+0x8/0x8\n[  382.231033]  do_softirq_own_stack+0x22/0x30\n[  382.231042]  </SOFTIRQ>\n[  382.231071]  irq_exit+0x45/0xc0\n[  382.231089]  smp_apic_timer_interrupt+0x13c/0x150\n[  382.231118]  apic_timer_interrupt+0x35/0x3c\n[  382.231132] EIP: __copy_user_ll+0xe2/0xf0\n[  382.231142] EFLAGS: 00210293 CPU: 1\n[  382.231154] EAX: bfd4508c EBX: 00000004 ECX: 00000003 EDX: f3d8fe50\n[  382.231165] ESI: f3d8fe51 EDI: bfd4508d EBP: f3d8fe14 ESP: f3d8fe08\n[  382.231176]  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\n[  382.231265]  core_sys_select+0x25f/0x320\n[  382.231346]  ? __wake_up_common_lock+0x62/0x80\n[  382.231399]  ? tty_ldisc_deref+0x13/0x20\n[  382.231438]  ? ldsem_up_read+0x1b/0x40\n[  382.231459]  ? tty_ldisc_deref+0x13/0x20\n[  382.231479]  ? tty_write+0x29f/0x2e0\n[  382.231514]  ? n_tty_ioctl+0xe0/0xe0\n[  382.231541]  ? tty_write_unlock+0x30/0x30\n[  382.231566]  ? __vfs_write+0x22/0x110\n[  382.231604]  ? security_file_permission+0x2f/0xd0\n[  382.231635]  ? rw_verify_area+0xac/0x120\n[  382.231677]  ? vfs_write+0x103/0x180\n[  382.231711]  SyS_select+0x87/0xc0\n[  382.231739]  ? SyS_write+0x42/0x90\n[  382.231781]  do_fast_syscall_32+0xd6/0x1a0\n[  382.231836]  entry_SYSENTER_32+0x47/0x71\n[  382.231848] EIP: 0xb7f75b05\n[  382.231857] EFLAGS: 00000246 CPU: 1\n[  382.231868] EAX: ffffffda EBX: 00000400 ECX: bfd4508c EDX: bfd4510c\n[  382.231878] ESI: 00000000 EDI: 00000000 EBP: 00000000 ESP: bfd45020\n[  382.231889]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 007b\n[  382.232281] softirq: huh, entered softirq 9 RCU c10b4d90 with preempt_count 00000100, exited with 00000000?\n\nTested-by: Sam Protsenko <semen.protsenko@linaro.org>\nSigned-off-by: Vincent Pelletier <plr.vincent@gmail.com>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>",
        "before_after_code_files": [
          "drivers/usb/gadget/function/f_fs.c||drivers/usgadget/function/f_fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/gadget/function/f_fs.c||drivers/usgadget/function/f_fs.c": [
          "File: drivers/usb/gadget/function/f_fs.c -> drivers/usgadget/function/f_fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:  struct mm_struct *mm;",
          "217:  struct work_struct work;",
          "219:  struct usb_ep *ep;",
          "220:  struct usb_request *req;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1072:  return 0;",
          "1073: }",
          "1075: static int ffs_aio_cancel(struct kiocb *kiocb)",
          "1076: {",
          "1077:  struct ffs_io_data *io_data = kiocb->private;",
          "1079:  int value;",
          "1081:  ENTER();",
          "1088:   value = -EINVAL;",
          "1092:  return value;",
          "1093: }",
          "",
          "[Removed Lines]",
          "1078:  struct ffs_epfile *epfile = kiocb->ki_filp->private_data;",
          "1083:  spin_lock_irq(&epfile->ffs->eps_lock);",
          "1085:  if (likely(io_data && io_data->ep && io_data->req))",
          "1086:   value = usb_ep_dequeue(io_data->ep, io_data->req);",
          "1087:  else",
          "1090:  spin_unlock_irq(&epfile->ffs->eps_lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e88f01206edab0e5bc105d8f35fac10f4ee14c5",
      "candidate_info": {
        "commit_hash": "6e88f01206edab0e5bc105d8f35fac10f4ee14c5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6e88f01206edab0e5bc105d8f35fac10f4ee14c5",
        "files": [
          "arch/arm64/crypto/aes-glue.c"
        ],
        "message": "crypto: arm64/aes-blk - fix and move skcipher_walk_done out of kernel_neon_begin, _end\n\nIn a arm64 server(QDF2400),I met a similar might-sleep warning as [1]:\n[    7.019116] BUG: sleeping function called from invalid context at\n./include/crypto/algapi.h:416\n[    7.027863] in_atomic(): 1, irqs_disabled(): 0, pid: 410, name:\ncryptomgr_test\n[    7.035106] 1 lock held by cryptomgr_test/410:\n[    7.039549]  #0:         (ptrval) (&drbg->drbg_mutex){+.+.}, at:\ndrbg_instantiate+0x34/0x398\n[    7.048038] CPU: 9 PID: 410 Comm: cryptomgr_test Not tainted\n4.17.0-rc6+ #27\n[    7.068228]  dump_backtrace+0x0/0x1c0\n[    7.071890]  show_stack+0x24/0x30\n[    7.075208]  dump_stack+0xb0/0xec\n[    7.078523]  ___might_sleep+0x160/0x238\n[    7.082360]  skcipher_walk_done+0x118/0x2c8\n[    7.086545]  ctr_encrypt+0x98/0x130\n[    7.090035]  simd_skcipher_encrypt+0x68/0xc0\n[    7.094304]  drbg_kcapi_sym_ctr+0xd4/0x1f8\n[    7.098400]  drbg_ctr_update+0x98/0x330\n[    7.102236]  drbg_seed+0x1b8/0x2f0\n[    7.105637]  drbg_instantiate+0x2ac/0x398\n[    7.109646]  drbg_kcapi_seed+0xbc/0x188\n[    7.113482]  crypto_rng_reset+0x4c/0xb0\n[    7.117319]  alg_test_drbg+0xec/0x330\n[    7.120981]  alg_test.part.6+0x1c8/0x3c8\n[    7.124903]  alg_test+0x58/0xa0\n[    7.128044]  cryptomgr_test+0x50/0x58\n[    7.131708]  kthread+0x134/0x138\n[    7.134936]  ret_from_fork+0x10/0x1c\n\nSeems there is a bug in Ard Biesheuvel's commit.\nFixes: 683381747270 (\"crypto: arm64/aes-blk - move kernel mode neon\nen/disable into loop\")\n\n[1] https://www.spinics.net/lists/linux-crypto/msg33103.html\n\nSigned-off-by: jia.he@hxt-semitech.com\nAcked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>\nCc: <stable@vger.kernel.org> # 4.17\nAcked-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
        "before_after_code_files": [
          "arch/arm64/crypto/aes-glue.c||arch/arm64/crypto/aes-glue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm64/crypto/aes-glue.c||arch/arm64/crypto/aes-glue.c": [
          "File: arch/arm64/crypto/aes-glue.c -> arch/arm64/crypto/aes-glue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:   kernel_neon_begin();",
          "224:   aes_ctr_encrypt(walk.dst.virt.addr, walk.src.virt.addr,",
          "225:     (u8 *)ctx->key_enc, rounds, blocks, walk.iv);",
          "227:   kernel_neon_end();",
          "228:  }",
          "229:  if (walk.nbytes) {",
          "230:   u8 __aligned(8) tail[AES_BLOCK_SIZE];",
          "",
          "[Removed Lines]",
          "226:   err = skcipher_walk_done(&walk, walk.nbytes % AES_BLOCK_SIZE);",
          "",
          "[Added Lines]",
          "227:   err = skcipher_walk_done(&walk, walk.nbytes % AES_BLOCK_SIZE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "401c636a0eeb0d51862fce222da1bf08e3a0ffd0",
      "candidate_info": {
        "commit_hash": "401c636a0eeb0d51862fce222da1bf08e3a0ffd0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/401c636a0eeb0d51862fce222da1bf08e3a0ffd0",
        "files": [
          "kernel/hung_task.c"
        ],
        "message": "kernel/hung_task.c: show all hung tasks before panic\n\nWhen we get a hung task it can often be valuable to see _all_ the hung\ntasks on the system before calling panic().\n\nQuoting from https://syzkaller.appspot.com/text?tag=CrashReport&id=5316056503549952\n----------------------------------------\nINFO: task syz-executor0:6540 blocked for more than 120 seconds.\n      Not tainted 4.16.0+ #13\n\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\nsyz-executor0   D23560  6540   4521 0x80000004\nCall Trace:\n context_switch kernel/sched/core.c:2848 [inline]\n __schedule+0x8fb/0x1ef0 kernel/sched/core.c:3490\n schedule+0xf5/0x430 kernel/sched/core.c:3549\n schedule_preempt_disabled+0x10/0x20 kernel/sched/core.c:3607\n __mutex_lock_common kernel/locking/mutex.c:833 [inline]\n __mutex_lock+0xb7f/0x1810 kernel/locking/mutex.c:893\n mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:908\n lo_ioctl+0x8b/0x1b70 drivers/block/loop.c:1355\n __blkdev_driver_ioctl block/ioctl.c:303 [inline]\n blkdev_ioctl+0x1759/0x1e00 block/ioctl.c:601\n ioctl_by_bdev+0xa5/0x110 fs/block_dev.c:2060\n isofs_get_last_session fs/isofs/inode.c:567 [inline]\n isofs_fill_super+0x2ba9/0x3bc0 fs/isofs/inode.c:660\n mount_bdev+0x2b7/0x370 fs/super.c:1119\n isofs_mount+0x34/0x40 fs/isofs/inode.c:1560\n mount_fs+0x66/0x2d0 fs/super.c:1222\n vfs_kern_mount.part.26+0xc6/0x4a0 fs/namespace.c:1037\n vfs_kern_mount fs/namespace.c:2514 [inline]\n do_new_mount fs/namespace.c:2517 [inline]\n do_mount+0xea4/0x2b90 fs/namespace.c:2847\n ksys_mount+0xab/0x120 fs/namespace.c:3063\n SYSC_mount fs/namespace.c:3077 [inline]\n SyS_mount+0x39/0x50 fs/namespace.c:3074\n do_syscall_64+0x281/0x940 arch/x86/entry/common.c:287\n entry_SYSCALL_64_after_hwframe+0x42/0xb7\n(...snipped...)\nShowing all locks held in the system:\n(...snipped...)\n2 locks held by syz-executor0/6540:\n #0: 00000000566d4c39 (&type->s_umount_key#49/1){+.+.}, at: alloc_super fs/super.c:211 [inline]\n #0: 00000000566d4c39 (&type->s_umount_key#49/1){+.+.}, at: sget_userns+0x3b2/0xe60 fs/super.c:502 /* down_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING); */\n #1: 0000000043ca8836 (&lo->lo_ctl_mutex/1){+.+.}, at: lo_ioctl+0x8b/0x1b70 drivers/block/loop.c:1355 /* mutex_lock_nested(&lo->lo_ctl_mutex, 1); */\n(...snipped...)\n3 locks held by syz-executor7/6541:\n #0: 0000000043ca8836 (&lo->lo_ctl_mutex/1){+.+.}, at: lo_ioctl+0x8b/0x1b70 drivers/block/loop.c:1355 /* mutex_lock_nested(&lo->lo_ctl_mutex, 1); */\n #1: 000000007bf3d3f9 (&bdev->bd_mutex){+.+.}, at: blkdev_reread_part+0x1e/0x40 block/ioctl.c:192\n #2: 00000000566d4c39 (&type->s_umount_key#50){.+.+}, at: __get_super.part.10+0x1d3/0x280 fs/super.c:663 /* down_read(&sb->s_umount); */\n----------------------------------------\n\nWhen reporting an AB-BA deadlock like shown above, it would be nice if\ntrace of PID=6541 is printed as well as trace of PID=6540 before calling\npanic().\n\nShowing hung tasks up to /proc/sys/kernel/hung_task_warnings could delay\ncalling panic() but normally there should not be so many hung tasks.\n\nLink: http://lkml.kernel.org/r/201804050705.BHE57833.HVFOFtSOMQJFOL@I-love.SAKURA.ne.jp\nSigned-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nAcked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>\nAcked-by: Dmitry Vyukov <dvyukov@google.com>\nCc: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Mandeep Singh Baines <msb@chromium.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Ingo Molnar <mingo@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "kernel/hung_task.c||kernel/hung_task.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/hung_task.c||kernel/hung_task.c": [
          "File: kernel/hung_task.c -> kernel/hung_task.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: static int __read_mostly did_panic;",
          "46: static bool hung_task_show_lock;",
          "48: static struct task_struct *watchdog_task;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: static bool hung_task_call_panic;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127:  touch_nmi_watchdog();",
          "129:  if (sysctl_hung_task_panic) {",
          "134:  }",
          "135: }",
          "",
          "[Removed Lines]",
          "130:   if (hung_task_show_lock)",
          "131:    debug_show_all_locks();",
          "132:   trigger_all_cpu_backtrace();",
          "133:   panic(\"hung_task: blocked tasks\");",
          "",
          "[Added Lines]",
          "131:   hung_task_show_lock = true;",
          "132:   hung_task_call_panic = true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "193:  rcu_read_unlock();",
          "194:  if (hung_task_show_lock)",
          "195:   debug_show_all_locks();",
          "196: }",
          "198: static long hung_timeout_jiffies(unsigned long last_checked,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "195:  if (hung_task_call_panic) {",
          "196:   trigger_all_cpu_backtrace();",
          "197:   panic(\"hung_task: blocked tasks\");",
          "198:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a889b9404c084c6fd145020c939a8f688b3e058",
      "candidate_info": {
        "commit_hash": "0a889b9404c084c6fd145020c939a8f688b3e058",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0a889b9404c084c6fd145020c939a8f688b3e058",
        "files": [
          "net/sched/act_ife.c"
        ],
        "message": "net/sched: act_ife: fix recursive lock and idr leak\n\na recursive lock warning [1] can be observed with the following script,\n\n # $TC actions add action ife encode allow prio pass index 42\n IFE type 0xED3E\n # $TC actions replace action ife encode allow tcindex pass index 42\n\nin case the kernel was unable to run the last command (e.g. because of\nthe impossibility to load 'act_meta_skbtcindex'). For a similar reason,\nthe kernel can leak idr in the error path of tcf_ife_init(), because\ntcf_idr_release() is not called after successful idr reservation:\n\n # $TC actions add action ife encode allow tcindex index 47\n IFE type 0xED3E\n RTNETLINK answers: No such file or directory\n We have an error talking to the kernel\n # $TC actions add action ife encode allow tcindex index 47\n IFE type 0xED3E\n RTNETLINK answers: No space left on device\n We have an error talking to the kernel\n # $TC actions add action ife encode use mark 7 type 0xfefe pass index 47\n IFE type 0xFEFE\n RTNETLINK answers: No space left on device\n We have an error talking to the kernel\n\nSince tcfa_lock is already taken when the action is being edited, a call\nto tcf_idr_release() wrongly makes tcf_idr_cleanup() take the same lock\nagain. On the other hand, tcf_idr_release() needs to be called in the\nerror path of tcf_ife_init(), to undo the last tcf_idr_create() invocation.\nFix both problems in tcf_ife_init().\nSince the cleanup() routine can now be called when ife->params is NULL,\nalso add a NULL pointer check to avoid calling kfree_rcu(NULL, rcu).\n\n [1]\n ============================================\n WARNING: possible recursive locking detected\n 4.17.0-rc4.kasan+ #417 Tainted: G            E\n --------------------------------------------\n tc/3932 is trying to acquire lock:\n 000000005097c9a6 (&(&p->tcfa_lock)->rlock){+...}, at: tcf_ife_cleanup+0x19/0x80 [act_ife]\n\n but task is already holding lock:\n 000000005097c9a6 (&(&p->tcfa_lock)->rlock){+...}, at: tcf_ife_init+0xf6d/0x13c0 [act_ife]\n\n other info that might help us debug this:\n  Possible unsafe locking scenario:\n\n        CPU0\n        ----\n   lock(&(&p->tcfa_lock)->rlock);\n   lock(&(&p->tcfa_lock)->rlock);\n\n  *** DEADLOCK ***\n\n  May be due to missing lock nesting notation\n\n 2 locks held by tc/3932:\n  #0: 000000007ca8e990 (rtnl_mutex){+.+.}, at: tcf_ife_init+0xf61/0x13c0 [act_ife]\n  #1: 000000005097c9a6 (&(&p->tcfa_lock)->rlock){+...}, at: tcf_ife_init+0xf6d/0x13c0 [act_ife]\n\n stack backtrace:\n CPU: 3 PID: 3932 Comm: tc Tainted: G            E     4.17.0-rc4.kasan+ #417\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n Call Trace:\n  dump_stack+0x9a/0xeb\n  __lock_acquire+0xf43/0x34a0\n  ? debug_check_no_locks_freed+0x2b0/0x2b0\n  ? debug_check_no_locks_freed+0x2b0/0x2b0\n  ? debug_check_no_locks_freed+0x2b0/0x2b0\n  ? __mutex_lock+0x62f/0x1240\n  ? kvm_sched_clock_read+0x1a/0x30\n  ? sched_clock+0x5/0x10\n  ? sched_clock_cpu+0x18/0x170\n  ? find_held_lock+0x39/0x1d0\n  ? lock_acquire+0x10b/0x330\n  lock_acquire+0x10b/0x330\n  ? tcf_ife_cleanup+0x19/0x80 [act_ife]\n  _raw_spin_lock_bh+0x38/0x70\n  ? tcf_ife_cleanup+0x19/0x80 [act_ife]\n  tcf_ife_cleanup+0x19/0x80 [act_ife]\n  __tcf_idr_release+0xff/0x350\n  tcf_ife_init+0xdde/0x13c0 [act_ife]\n  ? ife_exit_net+0x290/0x290 [act_ife]\n  ? __lock_is_held+0xb4/0x140\n  tcf_action_init_1+0x67b/0xad0\n  ? tcf_action_dump_old+0xa0/0xa0\n  ? sched_clock+0x5/0x10\n  ? sched_clock_cpu+0x18/0x170\n  ? kvm_sched_clock_read+0x1a/0x30\n  ? sched_clock+0x5/0x10\n  ? sched_clock_cpu+0x18/0x170\n  ? memset+0x1f/0x40\n  tcf_action_init+0x30f/0x590\n  ? tcf_action_init_1+0xad0/0xad0\n  ? memset+0x1f/0x40\n  tc_ctl_action+0x48e/0x5e0\n  ? mutex_lock_io_nested+0x1160/0x1160\n  ? tca_action_gd+0x990/0x990\n  ? sched_clock+0x5/0x10\n  ? find_held_lock+0x39/0x1d0\n  rtnetlink_rcv_msg+0x4da/0x990\n  ? validate_linkmsg+0x680/0x680\n  ? sched_clock_cpu+0x18/0x170\n  ? find_held_lock+0x39/0x1d0\n  netlink_rcv_skb+0x127/0x350\n  ? validate_linkmsg+0x680/0x680\n  ? netlink_ack+0x970/0x970\n  ? __kmalloc_node_track_caller+0x304/0x3a0\n  netlink_unicast+0x40f/0x5d0\n  ? netlink_attachskb+0x580/0x580\n  ? _copy_from_iter_full+0x187/0x760\n  ? import_iovec+0x90/0x390\n  netlink_sendmsg+0x67f/0xb50\n  ? netlink_unicast+0x5d0/0x5d0\n  ? copy_msghdr_from_user+0x206/0x340\n  ? netlink_unicast+0x5d0/0x5d0\n  sock_sendmsg+0xb3/0xf0\n  ___sys_sendmsg+0x60a/0x8b0\n  ? copy_msghdr_from_user+0x340/0x340\n  ? lock_downgrade+0x5e0/0x5e0\n  ? tty_write_lock+0x18/0x50\n  ? kvm_sched_clock_read+0x1a/0x30\n  ? sched_clock+0x5/0x10\n  ? sched_clock_cpu+0x18/0x170\n  ? find_held_lock+0x39/0x1d0\n  ? lock_downgrade+0x5e0/0x5e0\n  ? lock_acquire+0x10b/0x330\n  ? __audit_syscall_entry+0x316/0x690\n  ? current_kernel_time64+0x6b/0xd0\n  ? __fget_light+0x55/0x1f0\n  ? __sys_sendmsg+0xd2/0x170\n  __sys_sendmsg+0xd2/0x170\n  ? __ia32_sys_shutdown+0x70/0x70\n  ? syscall_trace_enter+0x57a/0xd60\n  ? rcu_read_lock_sched_held+0xdc/0x110\n  ? __bpf_trace_sys_enter+0x10/0x10\n  ? do_syscall_64+0x22/0x480\n  do_syscall_64+0xa5/0x480\n  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n RIP: 0033:0x7fd646988ba0\n RSP: 002b:00007fffc9fab3c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n RAX: ffffffffffffffda RBX: 00007fffc9fab4f0 RCX: 00007fd646988ba0\n RDX: 0000000000000000 RSI: 00007fffc9fab440 RDI: 0000000000000003\n RBP: 000000005b28c8b3 R08: 0000000000000002 R09: 0000000000000000\n R10: 00007fffc9faae20 R11: 0000000000000246 R12: 0000000000000000\n R13: 00007fffc9fab504 R14: 0000000000000001 R15: 000000000066c100\n\nFixes: 4e8c86155010 (\"net sched: net sched: ife action fix late binding\")\nFixes: ef6980b6becb (\"introduce IFE action\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nAcked-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/act_ife.c||net/sched/act_ife.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/act_ife.c||net/sched/act_ife.c": [
          "File: net/sched/act_ife.c -> net/sched/act_ife.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "415:  spin_unlock_bh(&ife->tcf_lock);",
          "417:  p = rcu_dereference_protected(ife->params, 1);",
          "419: }",
          "",
          "[Removed Lines]",
          "418:  kfree_rcu(p, rcu);",
          "",
          "[Added Lines]",
          "418:  if (p)",
          "419:   kfree_rcu(p, rcu);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "543:            NULL, NULL);",
          "544:   if (err) {",
          "545: metadata_parse_err:",
          "548:    if (ret == ACT_P_CREATED)",
          "551:    if (exists)",
          "552:     spin_unlock_bh(&ife->tcf_lock);",
          "",
          "[Removed Lines]",
          "546:    if (exists)",
          "547:     tcf_idr_release(*a, bind);",
          "549:     _tcf_ife_cleanup(*a);",
          "",
          "[Added Lines]",
          "548:     tcf_idr_release(*a, bind);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "567:   err = use_all_metadata(ife);",
          "568:   if (err) {",
          "569:    if (ret == ACT_P_CREATED)",
          "572:    if (exists)",
          "573:     spin_unlock_bh(&ife->tcf_lock);",
          "",
          "[Removed Lines]",
          "570:     _tcf_ife_cleanup(*a);",
          "",
          "[Added Lines]",
          "569:     tcf_idr_release(*a, bind);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5012284700775a4e6e3fbe7eac4c543c4874b559",
      "candidate_info": {
        "commit_hash": "5012284700775a4e6e3fbe7eac4c543c4874b559",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5012284700775a4e6e3fbe7eac4c543c4874b559",
        "files": [
          "fs/ext4/ialloc.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: fix check to prevent initializing reserved inodes\n\nCommit 8844618d8aa7: \"ext4: only look at the bg_flags field if it is\nvalid\" will complain if block group zero does not have the\nEXT4_BG_INODE_ZEROED flag set.  Unfortunately, this is not correct,\nsince a freshly created file system has this flag cleared.  It gets\nalmost immediately after the file system is mounted read-write --- but\nthe following somewhat unlikely sequence will end up triggering a\nfalse positive report of a corrupted file system:\n\n   mkfs.ext4 /dev/vdc\n   mount -o ro /dev/vdc /vdc\n   mount -o remount,rw /dev/vdc\n\nInstead, when initializing the inode table for block group zero, test\nto make sure that itable_unused count is not too large, since that is\nthe case that will result in some or all of the reserved inodes\ngetting cleared.\n\nThis fixes the failures reported by Eric Whiteney when running\ngeneric/230 and generic/231 in the the nojournal test case.\n\nFixes: 8844618d8aa7 (\"ext4: only look at the bg_flags field if it is valid\")\nReported-by: Eric Whitney <enwlinux@gmail.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ialloc.c||fs/ext4/ialloc.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ialloc.c||fs/ext4/ialloc.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ialloc.c||fs/ext4/ialloc.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ialloc.c||fs/ext4/ialloc.c": [
          "File: fs/ext4/ialloc.c -> fs/ext4/ialloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1388:        ext4_itable_unused_count(sb, gdp)),",
          "1389:        sbi->s_inodes_per_block);",
          "1392:   ext4_error(sb, \"Something is wrong with group %u: \"",
          "1393:       \"used itable blocks: %d; \"",
          "1394:       \"itable unused count: %u\",",
          "",
          "[Removed Lines]",
          "1391:  if ((used_blks < 0) || (used_blks > sbi->s_itb_per_group)) {",
          "",
          "[Added Lines]",
          "1391:  if ((used_blks < 0) || (used_blks > sbi->s_itb_per_group) ||",
          "1392:      ((group == 0) && ((EXT4_INODES_PER_GROUP(sb) -",
          "1393:           ext4_itable_unused_count(sb, gdp)) <",
          "1394:          EXT4_FIRST_INO(sb)))) {",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3141:   if (!gdp)",
          "3142:    continue;",
          "3147:    break;",
          "3152:  }",
          "3154:  return group;",
          "",
          "[Removed Lines]",
          "3144:   if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))",
          "3145:    continue;",
          "3146:   if (group != 0)",
          "3148:   ext4_error(sb, \"Inode table for bg 0 marked as \"",
          "3149:       \"needing zeroing\");",
          "3150:   if (sb_rdonly(sb))",
          "3151:    return ngroups;",
          "",
          "[Added Lines]",
          "3144:   if (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
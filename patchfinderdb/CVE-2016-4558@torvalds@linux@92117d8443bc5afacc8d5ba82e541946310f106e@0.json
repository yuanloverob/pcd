{
  "cve_id": "CVE-2016-4558",
  "cve_desc": "The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count.",
  "repo": "torvalds/linux",
  "patch_hash": "92117d8443bc5afacc8d5ba82e541946310f106e",
  "patch_info": {
    "commit_hash": "92117d8443bc5afacc8d5ba82e541946310f106e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e",
    "files": [
      "include/linux/bpf.h",
      "kernel/bpf/inode.c",
      "kernel/bpf/syscall.c",
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: fix refcnt overflow\n\nOn a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,\nthe malicious application may overflow 32-bit bpf program refcnt.\nIt's also possible to overflow map refcnt on 1Tb system.\nImpose 32k hard limit which means that the same bpf program or\nmap cannot be shared by more than 32k processes.\n\nFixes: 1be7f75d1668 (\"bpf: enable non-root eBPF programs\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "include/linux/bpf.h||include/linux/bpf.h",
      "kernel/bpf/inode.c||kernel/bpf/inode.c",
      "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "include/linux/bpf.h||include/linux/bpf.h": [
      "File: include/linux/bpf.h -> include/linux/bpf.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "171: void bpf_register_map_type(struct bpf_map_type_list *tl);",
      "173: struct bpf_prog *bpf_prog_get(u32 ufd);",
      "174: void bpf_prog_put(struct bpf_prog *prog);",
      "175: void bpf_prog_put_rcu(struct bpf_prog *prog);",
      "177: struct bpf_map *bpf_map_get_with_uref(u32 ufd);",
      "178: struct bpf_map *__bpf_map_get(struct fd f);",
      "180: void bpf_map_put_with_uref(struct bpf_map *map);",
      "181: void bpf_map_put(struct bpf_map *map);",
      "182: int bpf_map_precharge_memlock(u32 pages);",
      "",
      "[Removed Lines]",
      "179: void bpf_map_inc(struct bpf_map *map, bool uref);",
      "",
      "[Added Lines]",
      "174: struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog);",
      "180: struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref);",
      "",
      "---------------"
    ],
    "kernel/bpf/inode.c||kernel/bpf/inode.c": [
      "File: kernel/bpf/inode.c -> kernel/bpf/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "31: {",
      "32:  switch (type) {",
      "33:  case BPF_TYPE_PROG:",
      "35:   break;",
      "36:  case BPF_TYPE_MAP:",
      "38:   break;",
      "39:  default:",
      "40:   WARN_ON_ONCE(1);",
      "",
      "[Removed Lines]",
      "34:   atomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);",
      "37:   bpf_map_inc(raw, true);",
      "",
      "[Added Lines]",
      "34:   raw = bpf_prog_inc(raw);",
      "37:   raw = bpf_map_inc(raw, true);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "297:   goto out;",
      "299:  raw = bpf_any_get(inode->i_private, *type);",
      "302:  path_put(&path);",
      "303:  return raw;",
      "",
      "[Removed Lines]",
      "300:  touch_atime(&path);",
      "",
      "[Added Lines]",
      "300:  if (!IS_ERR(raw))",
      "301:   touch_atime(&path);",
      "",
      "---------------"
    ],
    "kernel/bpf/syscall.c||kernel/bpf/syscall.c": [
      "File: kernel/bpf/syscall.c -> kernel/bpf/syscall.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "218:  return f.file->private_data;",
      "219: }",
      "222: {",
      "224:  if (uref)",
      "225:   atomic_inc(&map->usercnt);",
      "226: }",
      "228: struct bpf_map *bpf_map_get_with_uref(u32 ufd)",
      "",
      "[Removed Lines]",
      "221: void bpf_map_inc(struct bpf_map *map, bool uref)",
      "223:  atomic_inc(&map->refcnt);",
      "",
      "[Added Lines]",
      "222: #define BPF_MAX_REFCNT 32768",
      "224: struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)",
      "226:  if (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {",
      "227:   atomic_dec(&map->refcnt);",
      "228:   return ERR_PTR(-EBUSY);",
      "229:  }",
      "232:  return map;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "234:  if (IS_ERR(map))",
      "235:   return map;",
      "238:  fdput(f);",
      "240:  return map;",
      "",
      "[Removed Lines]",
      "237:  bpf_map_inc(map, true);",
      "",
      "[Added Lines]",
      "244:  map = bpf_map_inc(map, true);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "658:  return f.file->private_data;",
      "659: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "668: struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)",
      "669: {",
      "670:  if (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {",
      "671:   atomic_dec(&prog->aux->refcnt);",
      "672:   return ERR_PTR(-EBUSY);",
      "673:  }",
      "674:  return prog;",
      "675: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "670:  if (IS_ERR(prog))",
      "671:   return prog;",
      "674:  fdput(f);",
      "676:  return prog;",
      "",
      "[Removed Lines]",
      "673:  atomic_inc(&prog->aux->refcnt);",
      "",
      "[Added Lines]",
      "689:  prog = bpf_prog_inc(prog);",
      "",
      "---------------"
    ],
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2049:     return -E2BIG;",
      "2050:    }",
      "2061:    fdput(f);",
      "2062: next_insn:",
      "2063:    insn++;",
      "",
      "[Removed Lines]",
      "2053:    env->used_maps[env->used_map_cnt++] = map;",
      "2060:    bpf_map_inc(map, false);",
      "",
      "[Added Lines]",
      "2057:    map = bpf_map_inc(map, false);",
      "2058:    if (IS_ERR(map)) {",
      "2059:     fdput(f);",
      "2060:     return PTR_ERR(map);",
      "2061:    }",
      "2062:    env->used_maps[env->used_map_cnt++] = map;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "59d3656d5bf504f771fc44fdbc7a9a8590795f22",
      "candidate_info": {
        "commit_hash": "59d3656d5bf504f771fc44fdbc7a9a8590795f22",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/59d3656d5bf504f771fc44fdbc7a9a8590795f22",
        "files": [
          "include/linux/bpf.h",
          "kernel/bpf/syscall.c"
        ],
        "message": "bpf: add bpf_prog_add api for bulk prog refcnt\n\nA subsystem may need to store many copies of a bpf program, each\ndeserving its own reference. Rather than requiring the caller to loop\none by one (with possible mid-loop failure), add a bulk bpf_prog_add\napi.\n\nSigned-off-by: Brenden Blanco <bblanco@plumgrid.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf.h||include/linux/bpf.h",
          "kernel/bpf/syscall.c||kernel/bpf/syscall.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c"
          ],
          "candidate": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "225: struct bpf_prog *bpf_prog_get(u32 ufd);",
          "226: struct bpf_prog *bpf_prog_get_type(u32 ufd, enum bpf_prog_type type);",
          "227: struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog);",
          "228: void bpf_prog_put(struct bpf_prog *prog);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227: struct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i);",
          "",
          "---------------"
        ],
        "kernel/bpf/syscall.c||kernel/bpf/syscall.c": [
          "File: kernel/bpf/syscall.c -> kernel/bpf/syscall.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "670:  return f.file->private_data;",
          "671: }",
          "674: {",
          "677:   return ERR_PTR(-EBUSY);",
          "678:  }",
          "679:  return prog;",
          "680: }",
          "682: static struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *type)",
          "683: {",
          "",
          "[Removed Lines]",
          "673: struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)",
          "675:  if (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {",
          "676:   atomic_dec(&prog->aux->refcnt);",
          "",
          "[Added Lines]",
          "673: struct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i)",
          "675:  if (atomic_add_return(i, &prog->aux->refcnt) > BPF_MAX_REFCNT) {",
          "676:   atomic_sub(i, &prog->aux->refcnt);",
          "681: EXPORT_SYMBOL_GPL(bpf_prog_add);",
          "683: struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)",
          "684: {",
          "685:  return bpf_prog_add(prog, 1);",
          "686: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d67942dd0ebc3dddc86edf9208169d064a9b3d7",
      "candidate_info": {
        "commit_hash": "6d67942dd0ebc3dddc86edf9208169d064a9b3d7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6d67942dd0ebc3dddc86edf9208169d064a9b3d7",
        "files": [
          "include/linux/bpf.h"
        ],
        "message": "bpf: add __must_check attributes to refcount manipulating helpers\n\nHelpers like bpf_prog_add(), bpf_prog_inc(), bpf_map_inc() can fail\nwith an error, so make sure the caller properly checks their return\nvalue and not just ignores it, which could worst-case lead to use\nafter free.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf.h||include/linux/bpf.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf.h||include/linux/bpf.h"
          ],
          "candidate": [
            "include/linux/bpf.h||include/linux/bpf.h"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "234: struct bpf_prog *bpf_prog_get(u32 ufd);",
          "235: struct bpf_prog *bpf_prog_get_type(u32 ufd, enum bpf_prog_type type);",
          "237: void bpf_prog_sub(struct bpf_prog *prog, int i);",
          "239: void bpf_prog_put(struct bpf_prog *prog);",
          "241: struct bpf_map *bpf_map_get_with_uref(u32 ufd);",
          "242: struct bpf_map *__bpf_map_get(struct fd f);",
          "244: void bpf_map_put_with_uref(struct bpf_map *map);",
          "245: void bpf_map_put(struct bpf_map *map);",
          "246: int bpf_map_precharge_memlock(u32 pages);",
          "",
          "[Removed Lines]",
          "236: struct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i);",
          "238: struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog);",
          "243: struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref);",
          "",
          "[Added Lines]",
          "236: struct bpf_prog * __must_check bpf_prog_add(struct bpf_prog *prog, int i);",
          "238: struct bpf_prog * __must_check bpf_prog_inc(struct bpf_prog *prog);",
          "243: struct bpf_map * __must_check bpf_map_inc(struct bpf_map *map, bool uref);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "299: {",
          "300:  return ERR_PTR(-EOPNOTSUPP);",
          "301: }",
          "303: {",
          "304:  return ERR_PTR(-EOPNOTSUPP);",
          "305: }",
          "",
          "[Removed Lines]",
          "302: static inline struct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i)",
          "",
          "[Added Lines]",
          "302: static inline struct bpf_prog * __must_check bpf_prog_add(struct bpf_prog *prog,",
          "303:          int i)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "311: static inline void bpf_prog_put(struct bpf_prog *prog)",
          "312: {",
          "313: }",
          "315: {",
          "316:  return ERR_PTR(-EOPNOTSUPP);",
          "317: }",
          "",
          "[Removed Lines]",
          "314: static inline struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)",
          "",
          "[Added Lines]",
          "316: static inline struct bpf_prog * __must_check bpf_prog_inc(struct bpf_prog *prog)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c9da161c6517ba12154059d3b965c2cbaf16f90f",
      "candidate_info": {
        "commit_hash": "c9da161c6517ba12154059d3b965c2cbaf16f90f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c9da161c6517ba12154059d3b965c2cbaf16f90f",
        "files": [
          "include/linux/bpf.h",
          "kernel/bpf/inode.c",
          "kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: fix clearing on persistent program array maps\n\nCurrently, when having map file descriptors pointing to program arrays,\nthere's still the issue that we unconditionally flush program array\ncontents via bpf_fd_array_map_clear() in bpf_map_release(). This happens\nwhen such a file descriptor is released and is independent of the map's\nrefcount.\n\nHaving this flush independent of the refcount is for a reason: there\ncan be arbitrary complex dependency chains among tail calls, also circular\nones (direct or indirect, nesting limit determined during runtime), and\nwe need to make sure that the map drops all references to eBPF programs\nit holds, so that the map's refcount can eventually drop to zero and\ninitiate its freeing. Btw, a walk of the whole dependency graph would\nnot be possible for various reasons, one being complexity and another\none inconsistency, i.e. new programs can be added to parts of the graph\nat any time, so there's no guaranteed consistent state for the time of\nsuch a walk.\n\nNow, the program array pinning itself works, but the issue is that each\nderived file descriptor on close would nevertheless call unconditionally\ninto bpf_fd_array_map_clear(). Instead, keep track of users and postpone\nthis flush until the last reference to a user is dropped. As this only\nconcerns a subset of references (f.e. a prog array could hold a program\nthat itself has reference on the prog array holding it, etc), we need to\ntrack them separately.\n\nShort analysis on the refcounting: on map creation time usercnt will be\none, so there's no change in behaviour for bpf_map_release(), if unpinned.\nIf we already fail in map_create(), we are immediately freed, and no\nfile descriptor has been made public yet. In bpf_obj_pin_user(), we need\nto probe for a possible map in bpf_fd_probe_obj() already with a usercnt\nreference, so before we drop the reference on the fd with fdput().\nTherefore, if actual pinning fails, we need to drop that reference again\nin bpf_any_put(), otherwise we keep holding it. When last reference\ndrops on the inode, the bpf_any_put() in bpf_evict_inode() will take\ncare of dropping the usercnt again. In the bpf_obj_get_user() case, the\nbpf_any_get() will grab a reference on the usercnt, still at a time when\nwe have the reference on the path. Should we later on fail to grab a new\nfile descriptor, bpf_any_put() will drop it, otherwise we hold it until\nbpf_map_release() time.\n\nJoint work with Alexei.\n\nFixes: b2197755b263 (\"bpf: add support for persistent maps/progs\")\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf.h||include/linux/bpf.h",
          "kernel/bpf/inode.c||kernel/bpf/inode.c",
          "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/inode.c||kernel/bpf/inode.c",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/inode.c||kernel/bpf/inode.c",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:  struct user_struct *user;",
          "41:  const struct bpf_map_ops *ops;",
          "42:  struct work_struct work;",
          "43: };",
          "45: struct bpf_map_type_list {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43:  atomic_t usercnt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167: void bpf_prog_put(struct bpf_prog *prog);",
          "168: void bpf_prog_put_rcu(struct bpf_prog *prog);",
          "171: struct bpf_map *__bpf_map_get(struct fd f);",
          "172: void bpf_map_put(struct bpf_map *map);",
          "174: extern int sysctl_unprivileged_bpf_disabled;",
          "",
          "[Removed Lines]",
          "170: struct bpf_map *bpf_map_get(u32 ufd);",
          "",
          "[Added Lines]",
          "171: struct bpf_map *bpf_map_get_with_uref(u32 ufd);",
          "173: void bpf_map_inc(struct bpf_map *map, bool uref);",
          "174: void bpf_map_put_with_uref(struct bpf_map *map);",
          "",
          "---------------"
        ],
        "kernel/bpf/inode.c||kernel/bpf/inode.c": [
          "File: kernel/bpf/inode.c -> kernel/bpf/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   atomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);",
          "35:   break;",
          "36:  case BPF_TYPE_MAP:",
          "38:   break;",
          "39:  default:",
          "40:   WARN_ON_ONCE(1);",
          "",
          "[Removed Lines]",
          "37:   atomic_inc(&((struct bpf_map *)raw)->refcnt);",
          "",
          "[Added Lines]",
          "37:   bpf_map_inc(raw, true);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51:   bpf_prog_put(raw);",
          "52:   break;",
          "53:  case BPF_TYPE_MAP:",
          "55:   break;",
          "56:  default:",
          "57:   WARN_ON_ONCE(1);",
          "",
          "[Removed Lines]",
          "54:   bpf_map_put(raw);",
          "",
          "[Added Lines]",
          "54:   bpf_map_put_with_uref(raw);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:  void *raw;",
          "68:  if (IS_ERR(raw)) {",
          "70:   raw = bpf_prog_get(ufd);",
          "",
          "[Removed Lines]",
          "67:  raw = bpf_map_get(ufd);",
          "",
          "[Added Lines]",
          "67:  raw = bpf_map_get_with_uref(ufd);",
          "",
          "---------------"
        ],
        "kernel/bpf/syscall.c||kernel/bpf/syscall.c": [
          "File: kernel/bpf/syscall.c -> kernel/bpf/syscall.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:  map->ops->map_free(map);",
          "83: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85: static void bpf_map_put_uref(struct bpf_map *map)",
          "86: {",
          "87:  if (atomic_dec_and_test(&map->usercnt)) {",
          "88:   if (map->map_type == BPF_MAP_TYPE_PROG_ARRAY)",
          "89:    bpf_fd_array_map_clear(map);",
          "90:  }",
          "91: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:  }",
          "94: }",
          "97: {",
          "106:  bpf_map_put(map);",
          "107:  return 0;",
          "108: }",
          "",
          "[Removed Lines]",
          "96: static int bpf_map_release(struct inode *inode, struct file *filp)",
          "98:  struct bpf_map *map = filp->private_data;",
          "100:  if (map->map_type == BPF_MAP_TYPE_PROG_ARRAY)",
          "104:   bpf_fd_array_map_clear(map);",
          "",
          "[Added Lines]",
          "104: void bpf_map_put_with_uref(struct bpf_map *map)",
          "106:  bpf_map_put_uref(map);",
          "108: }",
          "110: static int bpf_map_release(struct inode *inode, struct file *filp)",
          "111: {",
          "112:  bpf_map_put_with_uref(filp->private_data);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "142:   return PTR_ERR(map);",
          "144:  atomic_set(&map->refcnt, 1);",
          "146:  err = bpf_map_charge_memlock(map);",
          "147:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:  atomic_set(&map->usercnt, 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "174:  return f.file->private_data;",
          "175: }",
          "178: {",
          "179:  struct fd f = fdget(ufd);",
          "180:  struct bpf_map *map;",
          "",
          "[Removed Lines]",
          "177: struct bpf_map *bpf_map_get(u32 ufd)",
          "",
          "[Added Lines]",
          "184: void bpf_map_inc(struct bpf_map *map, bool uref)",
          "185: {",
          "186:  atomic_inc(&map->refcnt);",
          "187:  if (uref)",
          "188:   atomic_inc(&map->usercnt);",
          "189: }",
          "191: struct bpf_map *bpf_map_get_with_uref(u32 ufd)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "183:  if (IS_ERR(map))",
          "184:   return map;",
          "187:  fdput(f);",
          "189:  return map;",
          "",
          "[Removed Lines]",
          "186:  atomic_inc(&map->refcnt);",
          "",
          "[Added Lines]",
          "200:  bpf_map_inc(map, true);",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2026:    fdput(f);",
          "2027: next_insn:",
          "2028:    insn++;",
          "",
          "[Removed Lines]",
          "2024:    atomic_inc(&map->refcnt);",
          "",
          "[Added Lines]",
          "2024:    bpf_map_inc(map, false);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b2197755b2633e164a439682fb05a9b5ea48f706",
      "candidate_info": {
        "commit_hash": "b2197755b2633e164a439682fb05a9b5ea48f706",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b2197755b2633e164a439682fb05a9b5ea48f706",
        "files": [
          "include/linux/bpf.h",
          "include/uapi/linux/bpf.h",
          "include/uapi/linux/magic.h",
          "kernel/bpf/Makefile",
          "kernel/bpf/inode.c",
          "kernel/bpf/syscall.c"
        ],
        "message": "bpf: add support for persistent maps/progs\n\nThis work adds support for \"persistent\" eBPF maps/programs. The term\n\"persistent\" is to be understood that maps/programs have a facility\nthat lets them survive process termination. This is desired by various\neBPF subsystem users.\n\nJust to name one example: tc classifier/action. Whenever tc parses\nthe ELF object, extracts and loads maps/progs into the kernel, these\nfile descriptors will be out of reach after the tc instance exits.\nSo a subsequent tc invocation won't be able to access/relocate on this\nresource, and therefore maps cannot easily be shared, f.e. between the\ningress and egress networking data path.\n\nThe current workaround is that Unix domain sockets (UDS) need to be\ninstrumented in order to pass the created eBPF map/program file\ndescriptors to a third party management daemon through UDS' socket\npassing facility. This makes it a bit complicated to deploy shared\neBPF maps or programs (programs f.e. for tail calls) among various\nprocesses.\n\nWe've been brainstorming on how we could tackle this issue and various\napproches have been tried out so far, which can be read up further in\nthe below reference.\n\nThe architecture we eventually ended up with is a minimal file system\nthat can hold map/prog objects. The file system is a per mount namespace\nsingleton, and the default mount point is /sys/fs/bpf/. Any subsequent\nmounts within a given namespace will point to the same instance. The\nfile system allows for creating a user-defined directory structure.\nThe objects for maps/progs are created/fetched through bpf(2) with\ntwo new commands (BPF_OBJ_PIN/BPF_OBJ_GET). I.e. a bpf file descriptor\nalong with a pathname is being passed to bpf(2) that in turn creates\n(we call it eBPF object pinning) the file system nodes. Only the pathname\nis being passed to bpf(2) for getting a new BPF file descriptor to an\nexisting node. The user can use that to access maps and progs later on,\nthrough bpf(2). Removal of file system nodes is being managed through\nnormal VFS functions such as unlink(2), etc. The file system code is\nkept to a very minimum and can be further extended later on.\n\nThe next step I'm working on is to add dump eBPF map/prog commands\nto bpf(2), so that a specification from a given file descriptor can\nbe retrieved. This can be used by things like CRIU but also applications\ncan inspect the meta data after calling BPF_OBJ_GET.\n\nBig thanks also to Alexei and Hannes who significantly contributed\nin the design discussion that eventually let us end up with this\narchitecture here.\n\nReference: https://lkml.org/lkml/2015/10/15/925\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf.h||include/linux/bpf.h",
          "include/uapi/linux/bpf.h||include/uapi/linux/bpf.h",
          "include/uapi/linux/magic.h||include/uapi/linux/magic.h",
          "kernel/bpf/inode.c||kernel/bpf/inode.c",
          "kernel/bpf/syscall.c||kernel/bpf/syscall.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/inode.c||kernel/bpf/inode.c",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c"
          ],
          "candidate": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/inode.c||kernel/bpf/inode.c",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "167: void bpf_prog_put(struct bpf_prog *prog);",
          "168: void bpf_prog_put_rcu(struct bpf_prog *prog);",
          "170: struct bpf_map *__bpf_map_get(struct fd f);",
          "171: void bpf_map_put(struct bpf_map *map);",
          "173: extern int sysctl_unprivileged_bpf_disabled;",
          "176: int bpf_check(struct bpf_prog **fp, union bpf_attr *attr);",
          "177: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170: struct bpf_map *bpf_map_get(u32 ufd);",
          "176: int bpf_map_new_fd(struct bpf_map *map);",
          "177: int bpf_prog_new_fd(struct bpf_prog *prog);",
          "179: int bpf_obj_pin_user(u32 ufd, const char __user *pathname);",
          "180: int bpf_obj_get_user(const char __user *pathname);",
          "",
          "---------------"
        ],
        "include/uapi/linux/bpf.h||include/uapi/linux/bpf.h": [
          "File: include/uapi/linux/bpf.h -> include/uapi/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: };",
          "67: enum bpf_cmd {",
          "73:  BPF_MAP_CREATE,",
          "81:  BPF_MAP_LOOKUP_ELEM,",
          "88:  BPF_MAP_UPDATE_ELEM,",
          "95:  BPF_MAP_DELETE_ELEM,",
          "102:  BPF_MAP_GET_NEXT_KEY,",
          "109:  BPF_PROG_LOAD,",
          "110: };",
          "112: enum bpf_map_type {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74:  BPF_OBJ_PIN,",
          "75:  BPF_OBJ_GET,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162:  };",
          "163: } __attribute__((aligned(8)));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131:   __aligned_u64 pathname;",
          "132:   __u32  bpf_fd;",
          "133:  };",
          "",
          "---------------"
        ],
        "include/uapi/linux/magic.h||include/uapi/linux/magic.h": [
          "File: include/uapi/linux/magic.h -> include/uapi/linux/magic.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "75: #define ANON_INODE_FS_MAGIC 0x09041934",
          "76: #define BTRFS_TEST_MAGIC 0x73727279",
          "77: #define NSFS_MAGIC  0x6e736673",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78: #define BPF_FS_MAGIC  0xcafe4a11",
          "",
          "---------------"
        ],
        "kernel/bpf/inode.c||kernel/bpf/inode.c": [
          "File: kernel/bpf/inode.c -> kernel/bpf/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include <linux/module.h>",
          "15: #include <linux/magic.h>",
          "16: #include <linux/major.h>",
          "17: #include <linux/mount.h>",
          "18: #include <linux/namei.h>",
          "19: #include <linux/fs.h>",
          "20: #include <linux/kdev_t.h>",
          "21: #include <linux/filter.h>",
          "22: #include <linux/bpf.h>",
          "24: enum bpf_type {",
          "25:  BPF_TYPE_UNSPEC = 0,",
          "26:  BPF_TYPE_PROG,",
          "27:  BPF_TYPE_MAP,",
          "28: };",
          "30: static void *bpf_any_get(void *raw, enum bpf_type type)",
          "31: {",
          "32:  switch (type) {",
          "33:  case BPF_TYPE_PROG:",
          "34:   atomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);",
          "35:   break;",
          "36:  case BPF_TYPE_MAP:",
          "37:   atomic_inc(&((struct bpf_map *)raw)->refcnt);",
          "38:   break;",
          "39:  default:",
          "40:   WARN_ON_ONCE(1);",
          "41:   break;",
          "42:  }",
          "44:  return raw;",
          "45: }",
          "47: static void bpf_any_put(void *raw, enum bpf_type type)",
          "48: {",
          "49:  switch (type) {",
          "50:  case BPF_TYPE_PROG:",
          "51:   bpf_prog_put(raw);",
          "52:   break;",
          "53:  case BPF_TYPE_MAP:",
          "54:   bpf_map_put(raw);",
          "55:   break;",
          "56:  default:",
          "57:   WARN_ON_ONCE(1);",
          "58:   break;",
          "59:  }",
          "60: }",
          "62: static void *bpf_fd_probe_obj(u32 ufd, enum bpf_type *type)",
          "63: {",
          "64:  void *raw;",
          "67:  raw = bpf_map_get(ufd);",
          "68:  if (IS_ERR(raw)) {",
          "70:   raw = bpf_prog_get(ufd);",
          "71:  }",
          "73:  return raw;",
          "74: }",
          "76: static const struct inode_operations bpf_dir_iops;",
          "78: static const struct inode_operations bpf_prog_iops = { };",
          "79: static const struct inode_operations bpf_map_iops  = { };",
          "81: static struct inode *bpf_get_inode(struct super_block *sb,",
          "82:        const struct inode *dir,",
          "83:        umode_t mode)",
          "84: {",
          "85:  struct inode *inode;",
          "87:  switch (mode & S_IFMT) {",
          "88:  case S_IFDIR:",
          "89:  case S_IFREG:",
          "90:   break;",
          "91:  default:",
          "92:   return ERR_PTR(-EINVAL);",
          "93:  }",
          "95:  inode = new_inode(sb);",
          "96:  if (!inode)",
          "97:   return ERR_PTR(-ENOSPC);",
          "99:  inode->i_ino = get_next_ino();",
          "100:  inode->i_atime = CURRENT_TIME;",
          "101:  inode->i_mtime = inode->i_atime;",
          "102:  inode->i_ctime = inode->i_atime;",
          "104:  inode_init_owner(inode, dir, mode);",
          "106:  return inode;",
          "107: }",
          "109: static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)",
          "110: {",
          "112:  if (inode->i_op == &bpf_prog_iops)",
          "114:  else if (inode->i_op == &bpf_map_iops)",
          "116:  else",
          "117:   return -EACCES;",
          "119:  return 0;",
          "120: }",
          "122: static bool bpf_dname_reserved(const struct dentry *dentry)",
          "123: {",
          "124:  return strchr(dentry->d_name.name, '.');",
          "125: }",
          "127: static int bpf_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)",
          "128: {",
          "129:  struct inode *inode;",
          "131:  if (bpf_dname_reserved(dentry))",
          "132:   return -EPERM;",
          "134:  inode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);",
          "135:  if (IS_ERR(inode))",
          "136:   return PTR_ERR(inode);",
          "138:  inode->i_op = &bpf_dir_iops;",
          "139:  inode->i_fop = &simple_dir_operations;",
          "141:  inc_nlink(inode);",
          "142:  inc_nlink(dir);",
          "144:  d_instantiate(dentry, inode);",
          "145:  dget(dentry);",
          "147:  return 0;",
          "148: }",
          "150: static int bpf_mkobj_ops(struct inode *dir, struct dentry *dentry,",
          "151:     umode_t mode, const struct inode_operations *iops)",
          "152: {",
          "153:  struct inode *inode;",
          "155:  if (bpf_dname_reserved(dentry))",
          "156:   return -EPERM;",
          "158:  inode = bpf_get_inode(dir->i_sb, dir, mode | S_IFREG);",
          "159:  if (IS_ERR(inode))",
          "160:   return PTR_ERR(inode);",
          "162:  inode->i_op = iops;",
          "163:  inode->i_private = dentry->d_fsdata;",
          "165:  d_instantiate(dentry, inode);",
          "166:  dget(dentry);",
          "168:  return 0;",
          "169: }",
          "171: static int bpf_mkobj(struct inode *dir, struct dentry *dentry, umode_t mode,",
          "172:        dev_t devt)",
          "173: {",
          "174:  enum bpf_type type = MINOR(devt);",
          "176:  if (MAJOR(devt) != UNNAMED_MAJOR || !S_ISREG(mode) ||",
          "177:      dentry->d_fsdata == NULL)",
          "178:   return -EPERM;",
          "180:  switch (type) {",
          "181:  case BPF_TYPE_PROG:",
          "182:   return bpf_mkobj_ops(dir, dentry, mode, &bpf_prog_iops);",
          "183:  case BPF_TYPE_MAP:",
          "184:   return bpf_mkobj_ops(dir, dentry, mode, &bpf_map_iops);",
          "185:  default:",
          "186:   return -EPERM;",
          "187:  }",
          "188: }",
          "190: static const struct inode_operations bpf_dir_iops = {",
          "191:  .lookup  = simple_lookup,",
          "192:  .mknod  = bpf_mkobj,",
          "193:  .mkdir  = bpf_mkdir,",
          "194:  .rmdir  = simple_rmdir,",
          "195:  .unlink  = simple_unlink,",
          "196: };",
          "198: static int bpf_obj_do_pin(const struct filename *pathname, void *raw,",
          "199:      enum bpf_type type)",
          "200: {",
          "201:  struct dentry *dentry;",
          "202:  struct inode *dir;",
          "203:  struct path path;",
          "204:  umode_t mode;",
          "205:  dev_t devt;",
          "206:  int ret;",
          "208:  dentry = kern_path_create(AT_FDCWD, pathname->name, &path, 0);",
          "209:  if (IS_ERR(dentry))",
          "210:   return PTR_ERR(dentry);",
          "212:  mode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
          "213:  devt = MKDEV(UNNAMED_MAJOR, type);",
          "215:  ret = security_path_mknod(&path, dentry, mode, devt);",
          "216:  if (ret)",
          "217:   goto out;",
          "219:  dir = d_inode(path.dentry);",
          "220:  if (dir->i_op != &bpf_dir_iops) {",
          "221:   ret = -EPERM;",
          "222:   goto out;",
          "223:  }",
          "225:  dentry->d_fsdata = raw;",
          "226:  ret = vfs_mknod(dir, dentry, mode, devt);",
          "227:  dentry->d_fsdata = NULL;",
          "228: out:",
          "229:  done_path_create(&path, dentry);",
          "230:  return ret;",
          "231: }",
          "233: int bpf_obj_pin_user(u32 ufd, const char __user *pathname)",
          "234: {",
          "235:  struct filename *pname;",
          "236:  enum bpf_type type;",
          "237:  void *raw;",
          "238:  int ret;",
          "240:  pname = getname(pathname);",
          "241:  if (IS_ERR(pname))",
          "242:   return PTR_ERR(pname);",
          "244:  raw = bpf_fd_probe_obj(ufd, &type);",
          "245:  if (IS_ERR(raw)) {",
          "246:   ret = PTR_ERR(raw);",
          "247:   goto out;",
          "248:  }",
          "250:  ret = bpf_obj_do_pin(pname, raw, type);",
          "251:  if (ret != 0)",
          "252:   bpf_any_put(raw, type);",
          "253: out:",
          "254:  putname(pname);",
          "255:  return ret;",
          "256: }",
          "258: static void *bpf_obj_do_get(const struct filename *pathname,",
          "259:        enum bpf_type *type)",
          "260: {",
          "261:  struct inode *inode;",
          "262:  struct path path;",
          "263:  void *raw;",
          "264:  int ret;",
          "266:  ret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);",
          "267:  if (ret)",
          "268:   return ERR_PTR(ret);",
          "270:  inode = d_backing_inode(path.dentry);",
          "271:  ret = inode_permission(inode, MAY_WRITE);",
          "272:  if (ret)",
          "273:   goto out;",
          "275:  ret = bpf_inode_type(inode, type);",
          "276:  if (ret)",
          "277:   goto out;",
          "279:  raw = bpf_any_get(inode->i_private, *type);",
          "280:  touch_atime(&path);",
          "282:  path_put(&path);",
          "283:  return raw;",
          "284: out:",
          "285:  path_put(&path);",
          "286:  return ERR_PTR(ret);",
          "287: }",
          "289: int bpf_obj_get_user(const char __user *pathname)",
          "290: {",
          "291:  enum bpf_type type = BPF_TYPE_UNSPEC;",
          "292:  struct filename *pname;",
          "293:  int ret = -ENOENT;",
          "294:  void *raw;",
          "296:  pname = getname(pathname);",
          "297:  if (IS_ERR(pname))",
          "298:   return PTR_ERR(pname);",
          "300:  raw = bpf_obj_do_get(pname, &type);",
          "301:  if (IS_ERR(raw)) {",
          "302:   ret = PTR_ERR(raw);",
          "303:   goto out;",
          "304:  }",
          "306:  if (type == BPF_TYPE_PROG)",
          "307:   ret = bpf_prog_new_fd(raw);",
          "308:  else if (type == BPF_TYPE_MAP)",
          "309:   ret = bpf_map_new_fd(raw);",
          "310:  else",
          "311:   goto out;",
          "313:  if (ret < 0)",
          "314:   bpf_any_put(raw, type);",
          "315: out:",
          "316:  putname(pname);",
          "317:  return ret;",
          "318: }",
          "320: static void bpf_evict_inode(struct inode *inode)",
          "321: {",
          "322:  enum bpf_type type;",
          "324:  truncate_inode_pages_final(&inode->i_data);",
          "325:  clear_inode(inode);",
          "327:  if (!bpf_inode_type(inode, &type))",
          "328:   bpf_any_put(inode->i_private, type);",
          "329: }",
          "331: static const struct super_operations bpf_super_ops = {",
          "332:  .statfs  = simple_statfs,",
          "333:  .drop_inode = generic_delete_inode,",
          "334:  .evict_inode = bpf_evict_inode,",
          "335: };",
          "337: static int bpf_fill_super(struct super_block *sb, void *data, int silent)",
          "338: {",
          "339:  static struct tree_descr bpf_rfiles[] = { { \"\" } };",
          "340:  struct inode *inode;",
          "341:  int ret;",
          "343:  ret = simple_fill_super(sb, BPF_FS_MAGIC, bpf_rfiles);",
          "344:  if (ret)",
          "345:   return ret;",
          "347:  sb->s_op = &bpf_super_ops;",
          "349:  inode = sb->s_root->d_inode;",
          "350:  inode->i_op = &bpf_dir_iops;",
          "351:  inode->i_mode &= ~S_IALLUGO;",
          "352:  inode->i_mode |= S_ISVTX | S_IRWXUGO;",
          "354:  return 0;",
          "355: }",
          "357: static struct dentry *bpf_mount(struct file_system_type *type, int flags,",
          "358:     const char *dev_name, void *data)",
          "359: {",
          "360:  return mount_ns(type, flags, current->nsproxy->mnt_ns, bpf_fill_super);",
          "361: }",
          "363: static struct file_system_type bpf_fs_type = {",
          "364:  .owner  = THIS_MODULE,",
          "365:  .name  = \"bpf\",",
          "366:  .mount  = bpf_mount,",
          "367:  .kill_sb = kill_litter_super,",
          "368:  .fs_flags = FS_USERNS_MOUNT,",
          "369: };",
          "371: MODULE_ALIAS_FS(\"bpf\");",
          "373: static int __init bpf_init(void)",
          "374: {",
          "375:  int ret;",
          "377:  ret = sysfs_create_mount_point(fs_kobj, \"bpf\");",
          "378:  if (ret)",
          "379:   return ret;",
          "381:  ret = register_filesystem(&bpf_fs_type);",
          "382:  if (ret)",
          "383:   sysfs_remove_mount_point(fs_kobj, \"bpf\");",
          "385:  return ret;",
          "386: }",
          "387: fs_initcall(bpf_init);",
          "",
          "---------------"
        ],
        "kernel/bpf/syscall.c||kernel/bpf/syscall.c": [
          "File: kernel/bpf/syscall.c -> kernel/bpf/syscall.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:  .release = bpf_map_release,",
          "112: };",
          "115: {",
          "116:  return anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,",
          "117:     O_RDWR | O_CLOEXEC);",
          "",
          "[Removed Lines]",
          "114: static int bpf_map_new_fd(struct bpf_map *map)",
          "",
          "[Added Lines]",
          "114: int bpf_map_new_fd(struct bpf_map *map)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "174:  return f.file->private_data;",
          "175: }",
          "178: {",
          "179:  struct fd f = fdget(ufd);",
          "180:  struct bpf_map *map;",
          "",
          "[Removed Lines]",
          "177: static struct bpf_map *bpf_map_get(u32 ufd)",
          "",
          "[Added Lines]",
          "177: struct bpf_map *bpf_map_get(u32 ufd)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "548:         .release = bpf_prog_release,",
          "549: };",
          "552: {",
          "553:  return anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,",
          "554:     O_RDWR | O_CLOEXEC);",
          "",
          "[Removed Lines]",
          "551: static int bpf_prog_new_fd(struct bpf_prog *prog)",
          "",
          "[Added Lines]",
          "551: int bpf_prog_new_fd(struct bpf_prog *prog)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "674:  return err;",
          "675: }",
          "677: SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)",
          "678: {",
          "679:  union bpf_attr attr = {};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "677: #define BPF_OBJ_LAST_FIELD bpf_fd",
          "679: static int bpf_obj_pin(const union bpf_attr *attr)",
          "680: {",
          "681:  if (CHECK_ATTR(BPF_OBJ))",
          "682:   return -EINVAL;",
          "684:  return bpf_obj_pin_user(attr->bpf_fd, u64_to_ptr(attr->pathname));",
          "685: }",
          "687: static int bpf_obj_get(const union bpf_attr *attr)",
          "688: {",
          "689:  if (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0)",
          "690:   return -EINVAL;",
          "692:  return bpf_obj_get_user(u64_to_ptr(attr->pathname));",
          "693: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "734:  case BPF_PROG_LOAD:",
          "735:   err = bpf_prog_load(&attr);",
          "736:   break;",
          "737:  default:",
          "738:   err = -EINVAL;",
          "739:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "755:  case BPF_OBJ_PIN:",
          "756:   err = bpf_obj_pin(&attr);",
          "757:   break;",
          "758:  case BPF_OBJ_GET:",
          "759:   err = bpf_obj_get(&attr);",
          "760:   break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c210129760a010b555372ef74f4e1a46d4eb8a22",
      "candidate_info": {
        "commit_hash": "c210129760a010b555372ef74f4e1a46d4eb8a22",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c210129760a010b555372ef74f4e1a46d4eb8a22",
        "files": [
          "include/linux/bpf.h",
          "kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: align and clean bpf_{map,prog}_get helpers\n\nAdd a bpf_map_get() function that we're going to use later on and\nalign/clean the remaining helpers a bit so that we have them a bit\nmore consistent:\n\n  - __bpf_map_get() and __bpf_prog_get() that both work on the fd\n    struct, check whether the descriptor is eBPF and return the\n    pointer to the map/prog stored in the private data.\n\n    Also, we can return f.file->private_data directly, the function\n    signature is enough of a documentation already.\n\n  - bpf_map_get() and bpf_prog_get() that both work on u32 user fd,\n    call their respective __bpf_map_get()/__bpf_prog_get() variants,\n    and take a reference.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf.h||include/linux/bpf.h",
          "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "include/linux/bpf.h||include/linux/bpf.h",
            "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "167: void bpf_prog_put(struct bpf_prog *prog);",
          "168: void bpf_prog_put_rcu(struct bpf_prog *prog);",
          "171: void bpf_map_put(struct bpf_map *map);",
          "173: extern int sysctl_unprivileged_bpf_disabled;",
          "",
          "[Removed Lines]",
          "170: struct bpf_map *bpf_map_get(struct fd f);",
          "",
          "[Added Lines]",
          "170: struct bpf_map *__bpf_map_get(struct fd f);",
          "",
          "---------------"
        ],
        "kernel/bpf/syscall.c||kernel/bpf/syscall.c": [
          "File: kernel/bpf/syscall.c -> kernel/bpf/syscall.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "166: {",
          "169:  if (!f.file)",
          "170:   return ERR_PTR(-EBADF);",
          "172:  if (f.file->f_op != &bpf_map_fops) {",
          "173:   fdput(f);",
          "174:   return ERR_PTR(-EINVAL);",
          "175:  }",
          "179:  return map;",
          "180: }",
          "",
          "[Removed Lines]",
          "165: struct bpf_map *bpf_map_get(struct fd f)",
          "167:  struct bpf_map *map;",
          "177:  map = f.file->private_data;",
          "",
          "[Added Lines]",
          "165: struct bpf_map *__bpf_map_get(struct fd f)",
          "174:  return f.file->private_data;",
          "175: }",
          "177: static struct bpf_map *bpf_map_get(u32 ufd)",
          "178: {",
          "179:  struct fd f = fdget(ufd);",
          "180:  struct bpf_map *map;",
          "182:  map = __bpf_map_get(f);",
          "183:  if (IS_ERR(map))",
          "184:   return map;",
          "186:  atomic_inc(&map->refcnt);",
          "187:  fdput(f);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202:   return -EINVAL;",
          "204:  f = fdget(ufd);",
          "206:  if (IS_ERR(map))",
          "207:   return PTR_ERR(map);",
          "",
          "[Removed Lines]",
          "205:  map = bpf_map_get(f);",
          "",
          "[Added Lines]",
          "215:  map = __bpf_map_get(f);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "261:   return -EINVAL;",
          "263:  f = fdget(ufd);",
          "265:  if (IS_ERR(map))",
          "266:   return PTR_ERR(map);",
          "",
          "[Removed Lines]",
          "264:  map = bpf_map_get(f);",
          "",
          "[Added Lines]",
          "274:  map = __bpf_map_get(f);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "314:   return -EINVAL;",
          "316:  f = fdget(ufd);",
          "318:  if (IS_ERR(map))",
          "319:   return PTR_ERR(map);",
          "",
          "[Removed Lines]",
          "317:  map = bpf_map_get(f);",
          "",
          "[Added Lines]",
          "327:  map = __bpf_map_get(f);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "355:   return -EINVAL;",
          "357:  f = fdget(ufd);",
          "359:  if (IS_ERR(map))",
          "360:   return PTR_ERR(map);",
          "",
          "[Removed Lines]",
          "358:  map = bpf_map_get(f);",
          "",
          "[Added Lines]",
          "368:  map = __bpf_map_get(f);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "549:     O_RDWR | O_CLOEXEC);",
          "550: }",
          "553: {",
          "556:  if (!f.file)",
          "557:   return ERR_PTR(-EBADF);",
          "559:  if (f.file->f_op != &bpf_prog_fops) {",
          "560:   fdput(f);",
          "561:   return ERR_PTR(-EINVAL);",
          "562:  }",
          "567: }",
          "",
          "[Removed Lines]",
          "552: static struct bpf_prog *get_prog(struct fd f)",
          "554:  struct bpf_prog *prog;",
          "564:  prog = f.file->private_data;",
          "566:  return prog;",
          "",
          "[Added Lines]",
          "562: static struct bpf_prog *__bpf_prog_get(struct fd f)",
          "571:  return f.file->private_data;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "574:  struct fd f = fdget(ufd);",
          "575:  struct bpf_prog *prog;",
          "579:  if (IS_ERR(prog))",
          "580:   return prog;",
          "582:  atomic_inc(&prog->aux->refcnt);",
          "583:  fdput(f);",
          "584:  return prog;",
          "585: }",
          "586: EXPORT_SYMBOL_GPL(bpf_prog_get);",
          "",
          "[Removed Lines]",
          "577:  prog = get_prog(f);",
          "",
          "[Added Lines]",
          "582:  prog = __bpf_prog_get(f);",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1989:    }",
          "1991:    f = fdget(insn->imm);",
          "1994:    if (IS_ERR(map)) {",
          "1995:     verbose(\"fd %d is not pointing to valid bpf_map\\n\",",
          "1996:      insn->imm);",
          "",
          "[Removed Lines]",
          "1993:    map = bpf_map_get(f);",
          "",
          "[Added Lines]",
          "1992:    map = __bpf_map_get(f);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-8339",
  "cve_desc": "A buffer overflow in Redis 3.2.x prior to 3.2.4 causes arbitrary code execution when a crafted command is sent. An out of bounds write vulnerability exists in the handling of the client-output-buffer-limit option during the CONFIG SET command for the Redis data structure store. A crafted CONFIG SET command can lead to an out of bounds write potentially resulting in code execution.",
  "repo": "antirez/redis",
  "patch_hash": "6d9f8e2462fc2c426d48c941edeb78e5df7d2977",
  "patch_info": {
    "commit_hash": "6d9f8e2462fc2c426d48c941edeb78e5df7d2977",
    "repo": "antirez/redis",
    "commit_url": "https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977",
    "files": [
      "src/config.c"
    ],
    "message": "Security: CONFIG SET client-output-buffer-limit overflow fixed.\n\nThis commit fixes a vunlerability reported by Cory Duplantis\nof Cisco Talos, see TALOS-2016-0206 for reference.\n\nCONFIG SET client-output-buffer-limit accepts as client class \"master\"\nwhich is actually only used to implement CLIENT KILL. The \"master\" class\nhas ID 3. What happens is that the global structure:\n\n    server.client_obuf_limits[class]\n\nIs accessed with class = 3. However it is a 3 elements array, so writing\nthe 4th element means to write up to 24 bytes of memory *after* the end\nof the array, since the structure is defined as:\n\n    typedef struct clientBufferLimitsConfig {\n        unsigned long long hard_limit_bytes;\n        unsigned long long soft_limit_bytes;\n        time_t soft_limit_seconds;\n    } clientBufferLimitsConfig;\n\nEVALUATION OF IMPACT:\n\nChecking what's past the boundaries of the array in the global\n'server' structure, we find AOF state fields:\n\n    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];\n    /* AOF persistence */\n    int aof_state;                  /* AOF_(ON|OFF|WAIT_REWRITE) */\n    int aof_fsync;                  /* Kind of fsync() policy */\n    char *aof_filename;             /* Name of the AOF file */\n    int aof_no_fsync_on_rewrite;    /* Don't fsync if a rewrite is in prog. */\n    int aof_rewrite_perc;           /* Rewrite AOF if % growth is > M and... */\n    off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */\n    off_t aof_rewrite_base_size;    /* AOF size on latest startup or rewrite. */\n    off_t aof_current_size;         /* AOF current size. */\n\nWriting to most of these fields should be harmless and only cause problems in\nRedis persistence that should not escalate to security problems.\nHowever unfortunately writing to \"aof_filename\" could be potentially a\nsecurity issue depending on the access pattern.\n\nSearching for \"aof.filename\" accesses in the source code returns many different\nusages of the field, including using it as input for open(), logging to the\nRedis log file or syslog, and calling the rename() syscall.\n\nIt looks possible that attacks could lead at least to informations\ndisclosure of the state and data inside Redis. However note that the\nattacker must already have access to the server. But, worse than that,\nit looks possible that being able to change the AOF filename can be used\nto mount more powerful attacks: like overwriting random files with AOF\ndata (easily a potential security issue as demostrated here:\nhttp://antirez.com/news/96), or even more subtle attacks where the\nAOF filename is changed to a path were a malicious AOF file is loaded\nin order to exploit other potential issues when the AOF parser is fed\nwith untrusted input (no known issue known currently).\n\nThe fix checks the places where the 'master' class is specifiedf in\norder to access configuration data structures, and return an error in\nthis cases.\n\nWHO IS AT RISK?\n\nThe \"master\" client class was introduced in Redis in Jul 28 2015.\nEvery Redis instance released past this date is not vulnerable\nwhile all the releases after this date are. Notably:\n\n    Redis 3.0.x is NOT vunlerable.\n    Redis 3.2.x IS vulnerable.\n    Redis unstable is vulnerable.\n\nIn order for the instance to be at risk, at least one of the following\nconditions must be true:\n\n    1. The attacker can access Redis remotely and is able to send\n       the CONFIG SET command (often banned in managed Redis instances).\n\n    2. The attacker is able to control the \"redis.conf\" file and\n       can wait or trigger a server restart.\n\nThe problem was fixed 26th September 2016 in all the releases affected.",
    "before_after_code_files": [
      "src/config.c||src/config.c"
    ]
  },
  "patch_diff": {
    "src/config.c||src/config.c": [
      "File: src/config.c -> src/config.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "616:             unsigned long long hard, soft;",
      "617:             int soft_seconds;",
      "621:                 goto loaderr;",
      "622:             }",
      "623:             hard = memtoll(argv[2],NULL);",
      "",
      "[Removed Lines]",
      "619:             if (class == -1) {",
      "620:                 err = \"Unrecognized client limit class\";",
      "",
      "[Added Lines]",
      "619:             if (class == -1 || class == CLIENT_TYPE_MASTER) {",
      "620:                 err = \"Unrecognized client limit class: the user specified \"",
      "621:                 \"an invalid one, or 'master' which has no buffer limits.\";",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "906:             long val;",
      "908:             if ((j % 4) == 0) {",
      "910:                     sdsfreesplitres(v,vlen);",
      "911:                     goto badfmt;",
      "912:                 }",
      "",
      "[Removed Lines]",
      "909:                 if (getClientTypeByName(v[j]) == -1) {",
      "",
      "[Added Lines]",
      "910:                 int class = getClientTypeByName(v[j]);",
      "911:                 if (class == -1 || class == CLIENT_TYPE_MASTER) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "053963477766110b5ee538cfdae2896a7477d471",
      "candidate_info": {
        "commit_hash": "053963477766110b5ee538cfdae2896a7477d471",
        "repo": "antirez/redis",
        "commit_url": "https://github.com/antirez/redis/commit/053963477766110b5ee538cfdae2896a7477d471",
        "files": [
          "src/config.c"
        ],
        "message": "Security: CONFIG SET client-output-buffer-limit overflow fixed.\n\nThis commit fixes a vunlerability reported by Cory Duplantis\nof Cisco Talos, see TALOS-2016-0206 for reference.\n\nCONFIG SET client-output-buffer-limit accepts as client class \"master\"\nwhich is actually only used to implement CLIENT KILL. The \"master\" class\nhas ID 3. What happens is that the global structure:\n\n    server.client_obuf_limits[class]\n\nIs accessed with class = 3. However it is a 3 elements array, so writing\nthe 4th element means to write up to 24 bytes of memory *after* the end\nof the array, since the structure is defined as:\n\n    typedef struct clientBufferLimitsConfig {\n        unsigned long long hard_limit_bytes;\n        unsigned long long soft_limit_bytes;\n        time_t soft_limit_seconds;\n    } clientBufferLimitsConfig;\n\nEVALUATION OF IMPACT:\n\nChecking what's past the boundaries of the array in the global\n'server' structure, we find AOF state fields:\n\n    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];\n    /* AOF persistence */\n    int aof_state;                  /* AOF_(ON|OFF|WAIT_REWRITE) */\n    int aof_fsync;                  /* Kind of fsync() policy */\n    char *aof_filename;             /* Name of the AOF file */\n    int aof_no_fsync_on_rewrite;    /* Don't fsync if a rewrite is in prog. */\n    int aof_rewrite_perc;           /* Rewrite AOF if % growth is > M and... */\n    off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */\n    off_t aof_rewrite_base_size;    /* AOF size on latest startup or rewrite. */\n    off_t aof_current_size;         /* AOF current size. */\n\nWriting to most of these fields should be harmless and only cause problems in\nRedis persistence that should not escalate to security problems.\nHowever unfortunately writing to \"aof_filename\" could be potentially a\nsecurity issue depending on the access pattern.\n\nSearching for \"aof.filename\" accesses in the source code returns many different\nusages of the field, including using it as input for open(), logging to the\nRedis log file or syslog, and calling the rename() syscall.\n\nIt looks possible that attacks could lead at least to informations\ndisclosure of the state and data inside Redis. However note that the\nattacker must already have access to the server. But, worse than that,\nit looks possible that being able to change the AOF filename can be used\nto mount more powerful attacks: like overwriting random files with AOF\ndata (easily a potential security issue as demostrated here:\nhttp://antirez.com/news/96), or even more subtle attacks where the\nAOF filename is changed to a path were a malicious AOF file is loaded\nin order to exploit other potential issues when the AOF parser is fed\nwith untrusted input (no known issue known currently).\n\nThe fix checks the places where the 'master' class is specifiedf in\norder to access configuration data structures, and return an error in\nthis cases.\n\nWHO IS AT RISK?\n\nThe \"master\" client class was introduced in Redis in Jul 28 2015.\nEvery Redis instance released past this date is not vulnerable\nwhile all the releases after this date are. Notably:\n\n    Redis 3.0.x is NOT vunlerable.\n    Redis 3.2.x IS vulnerable.\n    Redis unstable is vulnerable.\n\nIn order for the instance to be at risk, at least one of the following\nconditions must be true:\n\n    1. The attacker can access Redis remotely and is able to send\n       the CONFIG SET command (often banned in managed Redis instances).\n\n    2. The attacker is able to control the \"redis.conf\" file and\n       can wait or trigger a server restart.\n\nThe problem was fixed 26th September 2016 in all the releases affected.",
        "before_after_code_files": [
          "src/config.c||src/config.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/config.c||src/config.c"
          ],
          "candidate": [
            "src/config.c||src/config.c"
          ]
        }
      },
      "candidate_diff": {
        "src/config.c||src/config.c": [
          "File: src/config.c -> src/config.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "549:             unsigned long long hard, soft;",
          "550:             int soft_seconds;",
          "554:                 goto loaderr;",
          "555:             }",
          "556:             hard = memtoll(argv[2],NULL);",
          "",
          "[Removed Lines]",
          "552:             if (class == -1) {",
          "553:                 err = \"Unrecognized client limit class\";",
          "",
          "[Added Lines]",
          "552:             if (class == -1 || class == CLIENT_TYPE_MASTER) {",
          "553:                 err = \"Unrecognized client limit class: the user specified \"",
          "554:                 \"an invalid one, or 'master' which has no buffer limits.\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "834:             long val;",
          "836:             if ((j % 4) == 0) {",
          "838:                     sdsfreesplitres(v,vlen);",
          "839:                     goto badfmt;",
          "840:                 }",
          "",
          "[Removed Lines]",
          "837:                 if (getClientTypeByName(v[j]) == -1) {",
          "",
          "[Added Lines]",
          "838:                 int class = getClientTypeByName(v[j]);",
          "839:                 if (class == -1 || class == CLIENT_TYPE_MASTER) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
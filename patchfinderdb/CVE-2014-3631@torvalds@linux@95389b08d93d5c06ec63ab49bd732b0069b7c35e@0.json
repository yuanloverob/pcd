{
  "cve_id": "CVE-2014-3631",
  "cve_desc": "The assoc_array_gc function in the associative-array implementation in lib/assoc_array.c in the Linux kernel before 3.16.3 does not properly implement garbage collection, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via multiple \"keyctl newring\" operations followed by a \"keyctl timeout\" operation.",
  "repo": "torvalds/linux",
  "patch_hash": "95389b08d93d5c06ec63ab49bd732b0069b7c35e",
  "patch_info": {
    "commit_hash": "95389b08d93d5c06ec63ab49bd732b0069b7c35e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/95389b08d93d5c06ec63ab49bd732b0069b7c35e",
    "files": [
      "lib/assoc_array.c"
    ],
    "message": "KEYS: Fix termination condition in assoc array garbage collection\n\nThis fixes CVE-2014-3631.\n\nIt is possible for an associative array to end up with a shortcut node at the\nroot of the tree if there are more than fan-out leaves in the tree, but they\nall crowd into the same slot in the lowest level (ie. they all have the same\nfirst nibble of their index keys).\n\nWhen assoc_array_gc() returns back up the tree after scanning some leaves, it\ncan fall off of the root and crash because it assumes that the back pointer\nfrom a shortcut (after label ascend_old_tree) must point to a normal node -\nwhich isn't true of a shortcut node at the root.\n\nShould we find we're ascending rootwards over a shortcut, we should check to\nsee if the backpointer is zero - and if it is, we have completed the scan.\n\nThis particular bug cannot occur if the root node is not a shortcut - ie. if\nyou have fewer than 17 keys in a keyring or if you have at least two keys that\nsit into separate slots (eg. a keyring and a non keyring).\n\nThis can be reproduced by:\n\n\tring=`keyctl newring bar @s`\n\tfor ((i=1; i<=18; i++)); do last_key=`keyctl newring foo$i $ring`; done\n\tkeyctl timeout $last_key 2\n\nDoing this:\n\n\techo 3 >/proc/sys/kernel/keys/gc_delay\n\nfirst will speed things up.\n\nIf we do fall off of the top of the tree, we get the following oops:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000018\nIP: [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540\nPGD dae15067 PUD cfc24067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: xt_nat xt_mark nf_conntrack_netbios_ns nf_conntrack_broadcast ip6t_rpfilter ip6t_REJECT xt_conntrack ebtable_nat ebtable_broute bridge stp llc ebtable_filter ebtables ip6table_ni\nCPU: 0 PID: 26011 Comm: kworker/0:1 Not tainted 3.14.9-200.fc20.x86_64 #1\nHardware name: Bochs Bochs, BIOS Bochs 01/01/2011\nWorkqueue: events key_garbage_collector\ntask: ffff8800918bd580 ti: ffff8800aac14000 task.ti: ffff8800aac14000\nRIP: 0010:[<ffffffff8136cea7>] [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540\nRSP: 0018:ffff8800aac15d40  EFLAGS: 00010206\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff8800aaecacc0\nRDX: ffff8800daecf440 RSI: 0000000000000001 RDI: ffff8800aadc2bc0\nRBP: ffff8800aac15da8 R08: 0000000000000001 R09: 0000000000000003\nR10: ffffffff8136ccc7 R11: 0000000000000000 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000070 R15: 0000000000000001\nFS:  0000000000000000(0000) GS:ffff88011fc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 0000000000000018 CR3: 00000000db10d000 CR4: 00000000000006f0\nStack:\n ffff8800aac15d50 0000000000000011 ffff8800aac15db8 ffffffff812e2a70\n ffff880091a00600 0000000000000000 ffff8800aadc2bc3 00000000cd42c987\n ffff88003702df20 ffff88003702dfa0 0000000053b65c09 ffff8800aac15fd8\nCall Trace:\n [<ffffffff812e2a70>] ? keyring_detect_cycle_iterator+0x30/0x30\n [<ffffffff812e3e75>] keyring_gc+0x75/0x80\n [<ffffffff812e1424>] key_garbage_collector+0x154/0x3c0\n [<ffffffff810a67b6>] process_one_work+0x176/0x430\n [<ffffffff810a744b>] worker_thread+0x11b/0x3a0\n [<ffffffff810a7330>] ? rescuer_thread+0x3b0/0x3b0\n [<ffffffff810ae1a8>] kthread+0xd8/0xf0\n [<ffffffff810ae0d0>] ? insert_kthread_work+0x40/0x40\n [<ffffffff816ffb7c>] ret_from_fork+0x7c/0xb0\n [<ffffffff810ae0d0>] ? insert_kthread_work+0x40/0x40\nCode: 08 4c 8b 22 0f 84 bf 00 00 00 41 83 c7 01 49 83 e4 fc 41 83 ff 0f 4c 89 65 c0 0f 8f 5a fe ff ff 48 8b 45 c0 4d 63 cf 49 83 c1 02 <4e> 8b 34 c8 4d 85 f6 0f 84 be 00 00 00 41 f6 c6 01 0f 84 92\nRIP  [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540\n RSP <ffff8800aac15d40>\nCR2: 0000000000000018\n---[ end trace 1129028a088c0cbd ]---\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Don Zickus <dzickus@redhat.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "before_after_code_files": [
      "lib/assoc_array.c||lib/assoc_array.c"
    ]
  },
  "patch_diff": {
    "lib/assoc_array.c||lib/assoc_array.c": [
      "File: lib/assoc_array.c -> lib/assoc_array.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1723:   shortcut = assoc_array_ptr_to_shortcut(ptr);",
      "1724:   slot = shortcut->parent_slot;",
      "1725:   cursor = shortcut->back_pointer;",
      "1726:  } else {",
      "1727:   slot = node->parent_slot;",
      "1728:   cursor = ptr;",
      "1729:  }",
      "1731:  node = assoc_array_ptr_to_node(cursor);",
      "1732:  slot++;",
      "1733:  goto continue_node;",
      "",
      "[Removed Lines]",
      "1730:  BUG_ON(!ptr);",
      "",
      "[Added Lines]",
      "1726:   if (!cursor)",
      "1727:    goto gc_complete;",
      "1732:  BUG_ON(!cursor);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9a72c2da690d78e93cff24b9f616412508678dd5",
      "candidate_info": {
        "commit_hash": "9a72c2da690d78e93cff24b9f616412508678dd5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9a72c2da690d78e93cff24b9f616412508678dd5",
        "files": [
          "drivers/net/bonding/bond_main.c"
        ],
        "message": "bonding: fix div by zero while enslaving and transmitting\n\nThe problem is that the slave is first linked and slave_cnt is\nincremented afterwards leading to a div by zero in the modes that use it\nas a modulus. What happens is that in bond_start_xmit()\nbond_has_slaves() is used to evaluate further transmission and it becomes\ntrue after the slave is linked in, but when slave_cnt is used in the xmit\npath it is still 0, so fetch it once and transmit based on that. Since\nit is used only in round-robin and XOR modes, the fix is only for them.\nThanks to Eric Dumazet for pointing out the fault in my first try to fix\nthis.\n\nCall trace (took it out of net-next kernel, but it's the same with net):\n[46934.330038] divide error: 0000 [#1] SMP\n[46934.330041] Modules linked in: bonding(O) 9p fscache\nsnd_hda_codec_generic crct10dif_pclmul\n[46934.330041] bond0: Enslaving eth1 as an active interface with an up\nlink\n[46934.330051]  ppdev joydev crc32_pclmul crc32c_intel 9pnet_virtio\nghash_clmulni_intel snd_hda_intel 9pnet snd_hda_controller parport_pc\nserio_raw pcspkr snd_hda_codec parport virtio_balloon virtio_console\nsnd_hwdep snd_pcm pvpanic i2c_piix4 snd_timer i2ccore snd soundcore\nvirtio_blk virtio_net virtio_pci virtio_ring virtio ata_generic\npata_acpi floppy [last unloaded: bonding]\n[46934.330053] CPU: 1 PID: 3382 Comm: ping Tainted: G           O\n3.17.0-rc4+ #27\n[46934.330053] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011\n[46934.330054] task: ffff88005aebf2c0 ti: ffff88005b728000 task.ti:\nffff88005b728000\n[46934.330059] RIP: 0010:[<ffffffffa0198c33>]  [<ffffffffa0198c33>]\nbond_start_xmit+0x1c3/0x450 [bonding]\n[46934.330060] RSP: 0018:ffff88005b72b7f8  EFLAGS: 00010246\n[46934.330060] RAX: 0000000000000679 RBX: ffff88004b077000 RCX:\n000000000000002a\n[46934.330061] RDX: 0000000000000000 RSI: ffff88004b3f0500 RDI:\nffff88004b077940\n[46934.330061] RBP: ffff88005b72b830 R08: 00000000000000c0 R09:\nffff88004a83e000\n[46934.330062] R10: 000000000000ffff R11: ffff88004b1f12c0 R12:\nffff88004b3f0500\n[46934.330062] R13: ffff88004b3f0500 R14: 000000000000002a R15:\nffff88004b077940\n[46934.330063] FS:  00007fbd91a4c740(0000) GS:ffff88005f080000(0000)\nknlGS:0000000000000000\n[46934.330064] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[46934.330064] CR2: 00007f803a8bb000 CR3: 000000004b2c9000 CR4:\n00000000000406e0\n[46934.330069] Stack:\n[46934.330071]  ffffffff811e6169 00000000e772fa05 ffff88004b077000\nffff88004b3f0500\n[46934.330072]  ffffffff81d17d18 000000000000002a 0000000000000000\nffff88005b72b8a0\n[46934.330073]  ffffffff81620108 ffffffff8161fe0e ffff88005b72b8c4\nffff88005b302000\n[46934.330073] Call Trace:\n[46934.330077]  [<ffffffff811e6169>] ?\n__kmalloc_node_track_caller+0x119/0x300\n[46934.330084]  [<ffffffff81620108>] dev_hard_start_xmit+0x188/0x410\n[46934.330086]  [<ffffffff8161fe0e>] ? harmonize_features+0x2e/0x90\n[46934.330088]  [<ffffffff81620b06>] __dev_queue_xmit+0x456/0x590\n[46934.330089]  [<ffffffff81620c50>] dev_queue_xmit+0x10/0x20\n[46934.330090]  [<ffffffff8168f022>] arp_xmit+0x22/0x60\n[46934.330091]  [<ffffffff8168f090>] arp_send.part.16+0x30/0x40\n[46934.330092]  [<ffffffff8168f1e5>] arp_solicit+0x115/0x2b0\n[46934.330094]  [<ffffffff8160b5d7>] ? copy_skb_header+0x17/0xa0\n[46934.330096]  [<ffffffff8162875a>] neigh_probe+0x4a/0x70\n[46934.330097]  [<ffffffff8162979c>] __neigh_event_send+0xac/0x230\n[46934.330098]  [<ffffffff8162a00b>] neigh_resolve_output+0x13b/0x220\n[46934.330100]  [<ffffffff8165f120>] ? ip_forward_options+0x1c0/0x1c0\n[46934.330101]  [<ffffffff81660478>] ip_finish_output+0x1f8/0x860\n[46934.330102]  [<ffffffff81661f08>] ip_output+0x58/0x90\n[46934.330103]  [<ffffffff81661602>] ? __ip_local_out+0xa2/0xb0\n[46934.330104]  [<ffffffff81661640>] ip_local_out_sk+0x30/0x40\n[46934.330105]  [<ffffffff81662a66>] ip_send_skb+0x16/0x50\n[46934.330106]  [<ffffffff81662ad3>] ip_push_pending_frames+0x33/0x40\n[46934.330107]  [<ffffffff8168854c>] raw_sendmsg+0x88c/0xa30\n[46934.330110]  [<ffffffff81612b31>] ? skb_recv_datagram+0x41/0x60\n[46934.330111]  [<ffffffff816875a9>] ? raw_recvmsg+0xa9/0x1f0\n[46934.330113]  [<ffffffff816978d4>] inet_sendmsg+0x74/0xc0\n[46934.330114]  [<ffffffff81697a9b>] ? inet_recvmsg+0x8b/0xb0\n[46934.330115] bond0: Adding slave eth2\n[46934.330116]  [<ffffffff8160357c>] sock_sendmsg+0x9c/0xe0\n[46934.330118]  [<ffffffff81603248>] ?\nmove_addr_to_kernel.part.20+0x28/0x80\n[46934.330121]  [<ffffffff811b4477>] ? might_fault+0x47/0x50\n[46934.330122]  [<ffffffff816039b9>] ___sys_sendmsg+0x3a9/0x3c0\n[46934.330125]  [<ffffffff8144a14a>] ? n_tty_write+0x3aa/0x530\n[46934.330127]  [<ffffffff810d1ae4>] ? __wake_up+0x44/0x50\n[46934.330129]  [<ffffffff81242b38>] ? fsnotify+0x238/0x310\n[46934.330130]  [<ffffffff816048a1>] __sys_sendmsg+0x51/0x90\n[46934.330131]  [<ffffffff816048f2>] SyS_sendmsg+0x12/0x20\n[46934.330134]  [<ffffffff81738b29>] system_call_fastpath+0x16/0x1b\n[46934.330144] Code: 48 8b 10 4c 89 ee 4c 89 ff e8 aa bc ff ff 31 c0 e9\n1a ff ff ff 0f 1f 00 4c 89 ee 4c 89 ff e8 65 fb ff ff 31 d2 4c 89 ee 4c\n89 ff <f7> b3 64 09 00 00 e8 02 bd ff ff 31 c0 e9 f2 fe ff ff 0f 1f 00\n[46934.330146] RIP  [<ffffffffa0198c33>] bond_start_xmit+0x1c3/0x450\n[bonding]\n[46934.330146]  RSP <ffff88005b72b7f8>\n\nCC: Eric Dumazet <eric.dumazet@gmail.com>\nCC: Andy Gospodarek <andy@greyhouse.net>\nCC: Jay Vosburgh <j.vosburgh@gmail.com>\nCC: Veaceslav Falico <vfalico@gmail.com>\nFixes: 278b208375 (\"bonding: initial RCU conversion\")\nSigned-off-by: Nikolay Aleksandrov <nikolay@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/bonding/bond_main.c||drivers/net/bonding/bond_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/bonding/bond_main.c||drivers/net/bonding/bond_main.c": [
          "File: drivers/net/bonding/bond_main.c -> drivers/net/bonding/bond_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3659:   else",
          "3660:    bond_xmit_slave_id(bond, skb, 0);",
          "3661:  } else {",
          "3664:  }",
          "3666:  return NETDEV_TX_OK;",
          "",
          "[Removed Lines]",
          "3662:   slave_id = bond_rr_gen_slave_id(bond);",
          "3663:   bond_xmit_slave_id(bond, skb, slave_id % bond->slave_cnt);",
          "",
          "[Added Lines]",
          "3662:   int slave_cnt = ACCESS_ONCE(bond->slave_cnt);",
          "3664:   if (likely(slave_cnt)) {",
          "3665:    slave_id = bond_rr_gen_slave_id(bond);",
          "3666:    bond_xmit_slave_id(bond, skb, slave_id % slave_cnt);",
          "3667:   } else {",
          "3668:    dev_kfree_skb_any(skb);",
          "3669:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3691: static int bond_xmit_xor(struct sk_buff *skb, struct net_device *bond_dev)",
          "3692: {",
          "3693:  struct bonding *bond = netdev_priv(bond_dev);",
          "3697:  return NETDEV_TX_OK;",
          "3698: }",
          "",
          "[Removed Lines]",
          "3695:  bond_xmit_slave_id(bond, skb, bond_xmit_hash(bond, skb) % bond->slave_cnt);",
          "",
          "[Added Lines]",
          "3700:  int slave_cnt = ACCESS_ONCE(bond->slave_cnt);",
          "3702:  if (likely(slave_cnt))",
          "3703:   bond_xmit_slave_id(bond, skb,",
          "3704:        bond_xmit_hash(bond, skb) % slave_cnt);",
          "3705:  else",
          "3706:   dev_kfree_skb_any(skb);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e13cf7a313a44c7279b4b646b5b7056d702ad0b7",
      "candidate_info": {
        "commit_hash": "e13cf7a313a44c7279b4b646b5b7056d702ad0b7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e13cf7a313a44c7279b4b646b5b7056d702ad0b7",
        "files": [
          "drivers/net/wireless/ath/ath10k/core.c",
          "drivers/net/wireless/ath/ath10k/debug.c",
          "drivers/net/wireless/ath/ath10k/debug.h"
        ],
        "message": "ath10k: move fw_crash_dump allocation\n\nThe fw_crash_data was allocated too late. Upon\nearly firmware crash, before registering to\nmac80211, it was possible to crash the whole\nsystem:\n\n ath10k_pci 0000:00:05.0: device has crashed during init\n BUG: unable to handle kernel NULL pointer dereference at           (null)\n IP: [<ffffffffa0058005>] ath10k_debug_get_new_fw_crash_data+0x15/0x30 [ath10k_core]\n PGD 0\n Oops: 0002 [#1] SMP\n Modules linked in: ath10k_pci(O) ath10k_core(O) ath [last unloaded: ath]\n CPU: 3 PID: 29 Comm: kworker/u8:1 Tainted: G           O   3.17.0-rc2-wl-ath+ #447\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n Workqueue: ath10k_wq ath10k_core_register_work [ath10k_core]\n task: ffff88001eb01ad0 ti: ffff88001eb60000 task.ti: ffff88001eb60000\n RIP: 0010:[<ffffffffa0058005>]  [<ffffffffa0058005>] ath10k_debug_get_new_fw_crash_data+0x15/0x30 [ath10k_core]\n RSP: 0018:ffff88001eb63ce8  EFLAGS: 00010246\n RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffffc90001a09030 RDI: 0000000000000001\n RBP: ffff88001eb63cf0 R08: 0000000000000000 R09: ffff8800000bb200\n R10: 00000000000001e2 R11: ffff88001eb638de R12: ffff88001d7459a0\n R13: ffff88001d746ab0 R14: 00000000fffe14d4 R15: ffff88001d747c60\n FS:  0000000000000000(0000) GS:ffff88001fd80000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n CR2: 0000000000000000 CR3: 000000001df34000 CR4: 00000000000006e0\n Stack:\n  ffff88001d7459a0 ffff88001eb63d58 ffffffffa0083bbe ffff880000000010\n  ffff88001eb63d68 ffff88001eb63d18 0000000000000002 0000000000059010\n  ffffffffa0086fef 00000000deadbeef ffff88001d747a28 ffff88001d7459a0\n Call Trace:\n  [<ffffffffa0083bbe>] ath10k_pci_fw_crashed_dump+0x2e/0xd0 [ath10k_pci]\n  [<ffffffffa0085410>] __ath10k_pci_hif_power_up+0x5f0/0x700 [ath10k_pci]\n  [<ffffffffa0085550>] ath10k_pci_hif_power_up+0x30/0xe0 [ath10k_pci]\n  [<ffffffffa005bc7b>] ath10k_core_register_work+0x2b/0x520 [ath10k_core]\n  [<ffffffff810689cc>] process_one_work+0x18c/0x3f0\n  [<ffffffff81069011>] worker_thread+0x121/0x4a0\n  [<ffffffff81068ef0>] ? rescuer_thread+0x2c0/0x2c0\n  [<ffffffff8106daf2>] kthread+0xd2/0xf0\n  [<ffffffff8106da20>] ? kthread_create_on_node+0x170/0x170\n  [<ffffffff81857cfc>] ret_from_fork+0x7c/0xb0\n  [<ffffffff8106da20>] ? kthread_create_on_node+0x170/0x170\n Code: 8b 40 38 48 c7 80 00 01 00 00 00 00 00 00 5b 5d c3 0f 1f 44 00 00 0f 1f 44 00 00 55 48 89 e5 53 48 8b 9f 90 1d 00 00 48 8d 7b 01 <c6> 03 01 e8 e3 ec 2b e1 48 8d 7b 18 e8 6a 4f 05 e1 48 89 d8 5b\n RIP  [<ffffffffa0058005>] ath10k_debug_get_new_fw_crash_data+0x15/0x30 [ath10k_core]\n  RSP <ffff88001eb63ce8>\n CR2: 0000000000000000\n ---[ end trace 5d0ed15b050bcc1f ]---\n Kernel panic - not syncing: Fatal exception in interrupt\n Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)\n ---[ end Kernel panic - not syncing: Fatal exception in interrupt\n\nTo prevent that split debug functions and allocate\nfw_crash_data earlier.\n\nSigned-off-by: Michal Kazior <michal.kazior@tieto.com>\nSigned-off-by: Kalle Valo <kvalo@qca.qualcomm.com>",
        "before_after_code_files": [
          "drivers/net/wireless/ath/ath10k/core.c||drivers/net/wireless/ath/ath10k/core.c",
          "drivers/net/wireless/ath/ath10k/debug.c||drivers/net/wireless/ath/ath10k/debug.c",
          "drivers/net/wireless/ath/ath10k/debug.h||drivers/net/wireless/ath/ath10k/debug.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/ath/ath10k/core.c||drivers/net/wireless/ath/ath10k/core.c": [
          "File: drivers/net/wireless/ath/ath10k/core.c -> drivers/net/wireless/ath/ath10k/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "977:   goto err_release_fw;",
          "978:  }",
          "981:  if (status) {",
          "982:   ath10k_err(ar, \"unable to initialize debugfs\\n\");",
          "983:   goto err_unregister_mac;",
          "",
          "[Removed Lines]",
          "980:  status = ath10k_debug_create(ar);",
          "",
          "[Added Lines]",
          "980:  status = ath10k_debug_register(ar);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1044:  ath10k_core_free_firmware_files(ar);",
          "1047: }",
          "1048: EXPORT_SYMBOL(ath10k_core_unregister);",
          "",
          "[Removed Lines]",
          "1046:  ath10k_debug_destroy(ar);",
          "",
          "[Added Lines]",
          "1046:  ath10k_debug_unregister(ar);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1051:       const struct ath10k_hif_ops *hif_ops)",
          "1052: {",
          "1053:  struct ath10k *ar;",
          "1055:  ar = ath10k_mac_create(priv_size);",
          "1056:  if (!ar)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1054:  int ret;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1077:  ar->workqueue = create_singlethread_workqueue(\"ath10k_wq\");",
          "1078:  if (!ar->workqueue)",
          "1081:  mutex_init(&ar->conf_mutex);",
          "1082:  spin_lock_init(&ar->data_lock);",
          "",
          "[Removed Lines]",
          "1079:   goto err_wq;",
          "",
          "[Added Lines]",
          "1080:   goto err_free_mac;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1094:  INIT_WORK(&ar->register_work, ath10k_core_register_work);",
          "1095:  INIT_WORK(&ar->restart_work, ath10k_core_restart);",
          "1097:  return ar;",
          "1100:  ath10k_mac_destroy(ar);",
          "1101:  return NULL;",
          "1102: }",
          "1103: EXPORT_SYMBOL(ath10k_core_create);",
          "",
          "[Removed Lines]",
          "1099: err_wq:",
          "",
          "[Added Lines]",
          "1098:  ret = ath10k_debug_create(ar);",
          "1099:  if (ret)",
          "1100:   goto err_free_wq;",
          "1104: err_free_wq:",
          "1105:  destroy_workqueue(ar->workqueue);",
          "1107: err_free_mac:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1107:  flush_workqueue(ar->workqueue);",
          "1108:  destroy_workqueue(ar->workqueue);",
          "1110:  ath10k_mac_destroy(ar);",
          "1111: }",
          "1112: EXPORT_SYMBOL(ath10k_core_destroy);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1119:  ath10k_debug_destroy(ar);",
          "",
          "---------------"
        ],
        "drivers/net/wireless/ath/ath10k/debug.c||drivers/net/wireless/ath/ath10k/debug.c": [
          "File: drivers/net/wireless/ath/ath10k/debug.c -> drivers/net/wireless/ath/ath10k/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1133: int ath10k_debug_create(struct ath10k *ar)",
          "1134: {",
          "1137:  ar->debug.fw_crash_data = vzalloc(sizeof(*ar->debug.fw_crash_data));",
          "1143:  ar->debug.debugfs_phy = debugfs_create_dir(\"ath10k\",",
          "1144:          ar->hw->wiphy->debugfsdir);",
          "1150:  INIT_DELAYED_WORK(&ar->debug.htt_stats_dwork,",
          "1151:      ath10k_debug_htt_stats_dwork);",
          "",
          "[Removed Lines]",
          "1135:  int ret;",
          "1138:  if (!ar->debug.fw_crash_data) {",
          "1139:   ret = -ENOMEM;",
          "1140:   goto err;",
          "1141:  }",
          "1145:  if (!ar->debug.debugfs_phy) {",
          "1146:   ret = -ENOMEM;",
          "1147:   goto err_free_fw_crash_data;",
          "1148:  }",
          "",
          "[Added Lines]",
          "1136:  if (!ar->debug.fw_crash_data)",
          "1137:   return -ENOMEM;",
          "1139:  return 0;",
          "1140: }",
          "1142: void ath10k_debug_destroy(struct ath10k *ar)",
          "1143: {",
          "1144:  vfree(ar->debug.fw_crash_data);",
          "1145:  ar->debug.fw_crash_data = NULL;",
          "1146: }",
          "1148: int ath10k_debug_register(struct ath10k *ar)",
          "1149: {",
          "1152:  if (!ar->debug.debugfs_phy)",
          "1153:   return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1192:  }",
          "1194:  return 0;",
          "1201: }",
          "1204: {",
          "1206:  cancel_delayed_work_sync(&ar->debug.htt_stats_dwork);",
          "1207: }",
          "",
          "[Removed Lines]",
          "1196: err_free_fw_crash_data:",
          "1197:  vfree(ar->debug.fw_crash_data);",
          "1199: err:",
          "1200:  return ret;",
          "1203: void ath10k_debug_destroy(struct ath10k *ar)",
          "1205:  vfree(ar->debug.fw_crash_data);",
          "",
          "[Added Lines]",
          "1202: void ath10k_debug_unregister(struct ath10k *ar)",
          "",
          "---------------"
        ],
        "drivers/net/wireless/ath/ath10k/debug.h||drivers/net/wireless/ath/ath10k/debug.h": [
          "File: drivers/net/wireless/ath/ath10k/debug.h -> drivers/net/wireless/ath/ath10k/debug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: void ath10k_debug_stop(struct ath10k *ar);",
          "50: int ath10k_debug_create(struct ath10k *ar);",
          "51: void ath10k_debug_destroy(struct ath10k *ar);",
          "52: void ath10k_debug_read_service_map(struct ath10k *ar,",
          "53:        void *service_map,",
          "54:        size_t map_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: int ath10k_debug_register(struct ath10k *ar);",
          "53: void ath10k_debug_unregister(struct ath10k *ar);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80: {",
          "81: }",
          "83: static inline void ath10k_debug_read_service_map(struct ath10k *ar,",
          "84:        void *service_map,",
          "85:        size_t map_size)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85: static inline int ath10k_debug_register(struct ath10k *ar)",
          "86: {",
          "87:  return 0;",
          "88: }",
          "90: static inline void ath10k_debug_unregister(struct ath10k *ar)",
          "91: {",
          "92: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d46c2dc14e92a7d7153f24b1e03321fc694ae906",
      "candidate_info": {
        "commit_hash": "d46c2dc14e92a7d7153f24b1e03321fc694ae906",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d46c2dc14e92a7d7153f24b1e03321fc694ae906",
        "files": [
          "arch/arm/boot/dts/imx28-apx4devkit.dts"
        ],
        "message": "ARM: dts: imx28-apx4devkit: Fix display duplicate name warning\n\nThe lcdif node has a property named \"display\" and also a child node\ncalled \"display\", which causes the following warning:\n\ndevice-tree: Duplicate name in lcdif@80030000, renamed to \"display#1\"\n\nRename the child node name in order to avoid the warning.\n\nSigned-off-by: Fabio Estevam <fabio.estevam@freescale.com>\nSigned-off-by: Shawn Guo <shawn.guo@freescale.com>",
        "before_after_code_files": [
          "arch/arm/boot/dts/imx28-apx4devkit.dts||arch/arm/boot/dts/imx28-apx4devkit.dts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm/boot/dts/imx28-apx4devkit.dts||arch/arm/boot/dts/imx28-apx4devkit.dts": [
          "File: arch/arm/boot/dts/imx28-apx4devkit.dts -> arch/arm/boot/dts/imx28-apx4devkit.dts",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:     pinctrl-names = \"default\";",
          "95:     pinctrl-0 = <&lcdif_24bit_pins_a",
          "96:           &lcdif_pins_apx4>;",
          "98:     status = \"okay\";",
          "101:      bits-per-pixel = <32>;",
          "102:      bus-width = <24>;",
          "",
          "[Removed Lines]",
          "97:     display = <&display>;",
          "100:     display: display {",
          "",
          "[Added Lines]",
          "97:     display = <&display0>;",
          "100:     display0: display0 {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6314b6796e3c070d4c8086b08dfd453a0aeac4cf",
      "candidate_info": {
        "commit_hash": "6314b6796e3c070d4c8086b08dfd453a0aeac4cf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6314b6796e3c070d4c8086b08dfd453a0aeac4cf",
        "files": [
          "drivers/clk/clk.c",
          "include/linux/clk-private.h"
        ],
        "message": "clk: Don't hold prepare_lock across debugfs creation\n\nRob Clark reports a lockdep splat that involves the prepare_lock\nchained with the mmap semaphore.\n\n======================================================\n[ INFO: possible circular locking dependency detected ]\n3.17.0-rc1-00050-g07a489b #802 Tainted: G        W\n-------------------------------------------------------\nXorg.bin/5413 is trying to acquire lock:\n (prepare_lock){+.+.+.}, at: [<c0781280>] clk_prepare_lock+0x88/0xfc\n\nbut task is already holding lock:\n (qcom_iommu_lock){+.+...}, at: [<c079f664>] qcom_iommu_unmap+0x1c/0x1f0\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #4 (qcom_iommu_lock){+.+...}:\n       [<c079f860>] qcom_iommu_map+0x28/0x450\n       [<c079eb50>] iommu_map+0xc8/0x12c\n       [<c056c1fc>] msm_iommu_map+0xb4/0x130\n       [<c05697bc>] msm_gem_get_iova_locked+0x9c/0xe8\n       [<c0569854>] msm_gem_get_iova+0x4c/0x64\n       [<c0562208>] mdp4_kms_init+0x4c4/0x6c0\n       [<c056881c>] msm_load+0x2ac/0x34c\n       [<c0545724>] drm_dev_register+0xac/0x108\n       [<c0547510>] drm_platform_init+0x50/0xf0\n       [<c0578a60>] try_to_bring_up_master.part.3+0xc8/0x108\n       [<c0578b48>] component_master_add_with_match+0xa8/0x104\n       [<c0568294>] msm_pdev_probe+0x64/0x70\n       [<c057e704>] platform_drv_probe+0x2c/0x60\n       [<c057cff8>] driver_probe_device+0x108/0x234\n       [<c057b65c>] bus_for_each_drv+0x64/0x98\n       [<c057cec0>] device_attach+0x78/0x8c\n       [<c057c590>] bus_probe_device+0x88/0xac\n       [<c057c9b8>] deferred_probe_work_func+0x68/0x9c\n       [<c0259db4>] process_one_work+0x1a0/0x40c\n       [<c025a710>] worker_thread+0x44/0x4d8\n       [<c025ec54>] kthread+0xd8/0xec\n       [<c020e9a8>] ret_from_fork+0x14/0x2c\n\n-> #3 (&dev->struct_mutex){+.+.+.}:\n       [<c0541188>] drm_gem_mmap+0x38/0xd0\n       [<c05695b8>] msm_gem_mmap+0xc/0x5c\n       [<c02f0b6c>] mmap_region+0x35c/0x6c8\n       [<c02f11ec>] do_mmap_pgoff+0x314/0x398\n       [<c02de1e0>] vm_mmap_pgoff+0x84/0xb4\n       [<c02ef83c>] SyS_mmap_pgoff+0x94/0xbc\n       [<c020e8e0>] ret_fast_syscall+0x0/0x48\n\n-> #2 (&mm->mmap_sem){++++++}:\n       [<c0321138>] filldir64+0x68/0x180\n       [<c0333fe0>] dcache_readdir+0x188/0x22c\n       [<c0320ed0>] iterate_dir+0x9c/0x11c\n       [<c03213b0>] SyS_getdents64+0x78/0xe8\n       [<c020e8e0>] ret_fast_syscall+0x0/0x48\n\n-> #1 (&sb->s_type->i_mutex_key#3){+.+.+.}:\n       [<c03fc544>] __create_file+0x58/0x1dc\n       [<c03fc70c>] debugfs_create_dir+0x1c/0x24\n       [<c0781c7c>] clk_debug_create_subtree+0x20/0x170\n       [<c0be2af8>] clk_debug_init+0xec/0x14c\n       [<c0208c70>] do_one_initcall+0x8c/0x1c8\n       [<c0b9cce4>] kernel_init_freeable+0x13c/0x1dc\n       [<c0877bc4>] kernel_init+0x8/0xe8\n       [<c020e9a8>] ret_from_fork+0x14/0x2c\n\n-> #0 (prepare_lock){+.+.+.}:\n       [<c087c408>] mutex_lock_nested+0x70/0x3e8\n       [<c0781280>] clk_prepare_lock+0x88/0xfc\n       [<c0782c50>] clk_prepare+0xc/0x24\n       [<c079f474>] __enable_clocks.isra.4+0x18/0xa4\n       [<c079f614>] __flush_iotlb_va+0xe0/0x114\n       [<c079f6f4>] qcom_iommu_unmap+0xac/0x1f0\n       [<c079ea3c>] iommu_unmap+0x9c/0xe8\n       [<c056c2fc>] msm_iommu_unmap+0x64/0x84\n       [<c0569da4>] msm_gem_free_object+0x11c/0x338\n       [<c05413ec>] drm_gem_object_handle_unreference_unlocked+0xfc/0x130\n       [<c0541604>] drm_gem_object_release_handle+0x50/0x68\n       [<c0447a98>] idr_for_each+0xa8/0xdc\n       [<c0541c10>] drm_gem_release+0x1c/0x28\n       [<c0540b3c>] drm_release+0x370/0x428\n       [<c031105c>] __fput+0x98/0x1e8\n       [<c025d73c>] task_work_run+0xb0/0xfc\n       [<c02477ec>] do_exit+0x2ec/0x948\n       [<c0247ec0>] do_group_exit+0x4c/0xb8\n       [<c025180c>] get_signal+0x28c/0x6ac\n       [<c0211204>] do_signal+0xc4/0x3e4\n       [<c02116cc>] do_work_pending+0xb4/0xc4\n       [<c020e938>] work_pending+0xc/0x20\n\nother info that might help us debug this:\n\nChain exists of:\n  prepare_lock --> &dev->struct_mutex --> qcom_iommu_lock\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(qcom_iommu_lock);\n                               lock(&dev->struct_mutex);\n                               lock(qcom_iommu_lock);\n  lock(prepare_lock);\n\n *** DEADLOCK ***\n\n3 locks held by Xorg.bin/5413:\n #0:  (drm_global_mutex){+.+.+.}, at: [<c0540800>] drm_release+0x34/0x428\n #1:  (&dev->struct_mutex){+.+.+.}, at: [<c05413bc>] drm_gem_object_handle_unreference_unlocked+0xcc/0x130\n #2:  (qcom_iommu_lock){+.+...}, at: [<c079f664>] qcom_iommu_unmap+0x1c/0x1f0\n\nstack backtrace:\nCPU: 1 PID: 5413 Comm: Xorg.bin Tainted: G        W      3.17.0-rc1-00050-g07a489b #802\n[<c0216290>] (unwind_backtrace) from [<c0211d8c>] (show_stack+0x10/0x14)\n[<c0211d8c>] (show_stack) from [<c087a078>] (dump_stack+0x98/0xb8)\n[<c087a078>] (dump_stack) from [<c027f024>] (print_circular_bug+0x218/0x340)\n[<c027f024>] (print_circular_bug) from [<c0283e08>] (__lock_acquire+0x1d24/0x20b8)\n[<c0283e08>] (__lock_acquire) from [<c0284774>] (lock_acquire+0x9c/0xbc)\n[<c0284774>] (lock_acquire) from [<c087c408>] (mutex_lock_nested+0x70/0x3e8)\n[<c087c408>] (mutex_lock_nested) from [<c0781280>] (clk_prepare_lock+0x88/0xfc)\n[<c0781280>] (clk_prepare_lock) from [<c0782c50>] (clk_prepare+0xc/0x24)\n[<c0782c50>] (clk_prepare) from [<c079f474>] (__enable_clocks.isra.4+0x18/0xa4)\n[<c079f474>] (__enable_clocks.isra.4) from [<c079f614>] (__flush_iotlb_va+0xe0/0x114)\n[<c079f614>] (__flush_iotlb_va) from [<c079f6f4>] (qcom_iommu_unmap+0xac/0x1f0)\n[<c079f6f4>] (qcom_iommu_unmap) from [<c079ea3c>] (iommu_unmap+0x9c/0xe8)\n[<c079ea3c>] (iommu_unmap) from [<c056c2fc>] (msm_iommu_unmap+0x64/0x84)\n[<c056c2fc>] (msm_iommu_unmap) from [<c0569da4>] (msm_gem_free_object+0x11c/0x338)\n[<c0569da4>] (msm_gem_free_object) from [<c05413ec>] (drm_gem_object_handle_unreference_unlocked+0xfc/0x130)\n[<c05413ec>] (drm_gem_object_handle_unreference_unlocked) from [<c0541604>] (drm_gem_object_release_handle+0x50/0x68)\n[<c0541604>] (drm_gem_object_release_handle) from [<c0447a98>] (idr_for_each+0xa8/0xdc)\n[<c0447a98>] (idr_for_each) from [<c0541c10>] (drm_gem_release+0x1c/0x28)\n[<c0541c10>] (drm_gem_release) from [<c0540b3c>] (drm_release+0x370/0x428)\n[<c0540b3c>] (drm_release) from [<c031105c>] (__fput+0x98/0x1e8)\n[<c031105c>] (__fput) from [<c025d73c>] (task_work_run+0xb0/0xfc)\n[<c025d73c>] (task_work_run) from [<c02477ec>] (do_exit+0x2ec/0x948)\n[<c02477ec>] (do_exit) from [<c0247ec0>] (do_group_exit+0x4c/0xb8)\n[<c0247ec0>] (do_group_exit) from [<c025180c>] (get_signal+0x28c/0x6ac)\n[<c025180c>] (get_signal) from [<c0211204>] (do_signal+0xc4/0x3e4)\n[<c0211204>] (do_signal) from [<c02116cc>] (do_work_pending+0xb4/0xc4)\n[<c02116cc>] (do_work_pending) from [<c020e938>] (work_pending+0xc/0x20)\n\nWe can break this chain if we don't hold the prepare_lock while\ncreating debugfs directories. We only hold the prepare_lock right\nnow because we're traversing the clock tree recursively and we\ndon't want the hierarchy to change during the traversal.\nReplacing this traversal with a simple linked list walk allows us\nto only grab a list lock instead of the prepare_lock, thus\nbreaking the lock chain.\n\nSigned-off-by: Stephen Boyd <sboyd@codeaurora.org>\nSigned-off-by: Mike Turquette <mturquette@linaro.org>",
        "before_after_code_files": [
          "drivers/clk/clk.c||drivers/clk/clk.c",
          "include/linux/clk-private.h||include/linux/clk-private.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/clk/clk.c||drivers/clk/clk.c": [
          "File: drivers/clk/clk.c -> drivers/clk/clk.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "101: static struct dentry *rootdir;",
          "102: static int inited = 0;",
          "104: static struct hlist_head *all_lists[] = {",
          "105:  &clk_root_list,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103: static DEFINE_MUTEX(clk_debug_lock);",
          "104: static HLIST_HEAD(clk_debug_list);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "300:  return ret;",
          "301: }",
          "",
          "[Removed Lines]",
          "304: static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)",
          "305: {",
          "306:  struct clk *child;",
          "307:  int ret = -EINVAL;;",
          "309:  if (!clk || !pdentry)",
          "310:   goto out;",
          "312:  ret = clk_debug_create_one(clk, pdentry);",
          "314:  if (ret)",
          "315:   goto out;",
          "317:  hlist_for_each_entry(child, &clk->children, child_node)",
          "318:   clk_debug_create_subtree(child, pdentry);",
          "320:  ret = 0;",
          "321: out:",
          "322:  return ret;",
          "323: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "336: static int clk_debug_register(struct clk *clk)",
          "337: {",
          "338:  int ret = 0;",
          "340:  if (!inited)",
          "346:  return ret;",
          "347: }",
          "",
          "[Removed Lines]",
          "341:   goto out;",
          "343:  ret = clk_debug_create_subtree(clk, rootdir);",
          "345: out:",
          "",
          "[Added Lines]",
          "317:  mutex_lock(&clk_debug_lock);",
          "318:  hlist_add_head(&clk->debug_node, &clk_debug_list);",
          "321:   goto unlock;",
          "323:  ret = clk_debug_create_one(clk, rootdir);",
          "324: unlock:",
          "325:  mutex_unlock(&clk_debug_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "359: static void clk_debug_unregister(struct clk *clk)",
          "360: {",
          "361:  debugfs_remove_recursive(clk->dentry);",
          "362: }",
          "364: struct dentry *clk_debugfs_add_file(struct clk *clk, char *name, umode_t mode,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "340:  mutex_lock(&clk_debug_lock);",
          "341:  if (!clk->dentry)",
          "342:   goto out;",
          "344:  hlist_del_init(&clk->debug_node);",
          "346:  clk->dentry = NULL;",
          "347: out:",
          "348:  mutex_unlock(&clk_debug_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "415:  if (!d)",
          "416:   return -ENOMEM;",
          "426:  inited = 1;",
          "430:  return 0;",
          "431: }",
          "",
          "[Removed Lines]",
          "418:  clk_prepare_lock();",
          "420:  hlist_for_each_entry(clk, &clk_root_list, child_node)",
          "421:   clk_debug_create_subtree(clk, rootdir);",
          "423:  hlist_for_each_entry(clk, &clk_orphan_list, child_node)",
          "424:   clk_debug_create_subtree(clk, rootdir);",
          "428:  clk_prepare_unlock();",
          "",
          "[Added Lines]",
          "405:  mutex_lock(&clk_debug_lock);",
          "406:  hlist_for_each_entry(clk, &clk_debug_list, debug_node)",
          "407:   clk_debug_create_one(clk, rootdir);",
          "410:  mutex_unlock(&clk_debug_lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2087: {",
          "2088:  unsigned long flags;",
          "2093:  clk_prepare_lock();",
          "2095:  if (clk->ops == &clk_nodrv_ops) {",
          "2096:   pr_err(\"%s: unregistered clock: %s\\n\", __func__, clk->name);",
          "2098:  }",
          "",
          "[Removed Lines]",
          "2090:        if (!clk || WARN_ON_ONCE(IS_ERR(clk)))",
          "2091:                return;",
          "2097:   goto out;",
          "",
          "[Added Lines]",
          "2072:  if (!clk || WARN_ON_ONCE(IS_ERR(clk)))",
          "2073:   return;",
          "2075:  clk_debug_unregister(clk);",
          "2081:   return;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2113:    clk_set_parent(child, NULL);",
          "2114:  }",
          "2118:  hlist_del_init(&clk->child_node);",
          "2120:  if (clk->prepare_count)",
          "2121:   pr_warn(\"%s: unregistering prepared clock: %s\\n\",",
          "2122:      __func__, clk->name);",
          "2124:  kref_put(&clk->ref, __clk_release);",
          "2126:  clk_prepare_unlock();",
          "2127: }",
          "2128: EXPORT_SYMBOL_GPL(clk_unregister);",
          "",
          "[Removed Lines]",
          "2116:  clk_debug_unregister(clk);",
          "2125: out:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/clk-private.h||include/linux/clk-private.h": [
          "File: include/linux/clk-private.h -> include/linux/clk-private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  unsigned long  accuracy;",
          "49:  struct hlist_head children;",
          "50:  struct hlist_node child_node;",
          "51:  unsigned int  notifier_count;",
          "52: #ifdef CONFIG_DEBUG_FS",
          "53:  struct dentry  *dentry;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51:  struct hlist_node debug_node;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fc62b3fc9021526d096d940ec62e74af72eb1e10",
      "candidate_info": {
        "commit_hash": "fc62b3fc9021526d096d940ec62e74af72eb1e10",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fc62b3fc9021526d096d940ec62e74af72eb1e10",
        "files": [
          "drivers/scsi/megaraid/megaraid_sas.h",
          "drivers/scsi/megaraid/megaraid_sas_base.c",
          "drivers/scsi/megaraid/megaraid_sas_fusion.c"
        ],
        "message": "megaraid_sas : Firmware crash dump feature support\n\nResending the patch. Addressed the review comments from Tomas Henzl.\nMove buff_offset inside spinlock, corrected loop at crash dump buffer free,\nreset_devices check is added to disable fw crash dump feature in kdump kernel.\n\nThis feature will provide similar interface as kernel crash dump feature.\nWhen megaraid firmware encounter any crash, driver will collect the firmware raw image and\ndump it into pre-configured location.\n\nDriver will allocate two different segment of memory.\n#1 Non-DMA able large buffer (will be allocated on demand) to capture actual FW crash dump.\n#2 DMA buffer (persistence allocation) just to do a arbitrator job.\n\nFirmware will keep writing Crash dump data in chucks of DMA buffer size into #2,\nwhich will be copy back by driver to the host memory as described in #1.\n\nDriver-Firmware interface:\n==================\nA.) Host driver can allocate maximum 512MB Host memory to store crash dump data.\n\nThis memory will be internal to the host and will not be exposed to the Firmware.\nDriver may not be able to allocate 512 MB. In that case, driver will do possible memory\n(available at run time) allocation to store crash dump data.\n\nLet\u2019s call this buffer as Host Crash Buffer.\n\nHost Crash buffer will not be contigious as a whole, but it will have multiple chunk of contigious memory.\nThis will be internal to driver and firmware/application are unaware of it.\nPartial allocation of Host Crash buffer may have valid information to debug depending upon\nwhat was collected in that buffer and depending on nature of failure.\n\nComplete Crash dump is the best case, but we do want to capture partial buffer just to grab something rather than nothing.\nHost Crash buffer will be allocated only when FW Crash dump data is available,\nand will be deallocated once application copy Host Crash buffer to the file.\nHost Crash buffer size can be anything between 1MB to 512MB. (It will be multiple of 1MBs)\n\nB.) Irrespective of underlying Firmware capability of crash dump support,\ndriver will allocate DMA buffer at start of the day for each MR controllers.\nLet\u2019s call this buffer as \u201cDMA Crash Buffer\u201d.\n\nFor this feature, size of DMA crash buffer will be 1MB.\n(We will not gain much even if DMA buffer size is increased.)\n\nC.) Driver will now read Controller Info sending existing dcmd \u201cMR_DCMD_CTRL_GET_INFO\u201d.\nDriver should extract the information from ctrl info provided by firmware and\nfigure out if firmware support crash dump feature or not.\n\nDriver will enable crash dump feature only if\n\u201cFirmware support Crash dump\u201d +\n\u201cDriver was able to create DMA Crash Buffer\u201d.\n\nIf either one from above is not set, Crash dump feature should be disable in driver.\nFirmware will enable crash dump feature only if \u201cDriver Send DCMD- MR_DCMD_SET_CRASH_BUF_PARA with MR_CRASH_BUF_TURN_ON\u201d\n\nHelper application/script should use sysfs parameter fw_crash_xxx to actually copy data from\nhost memory to the filesystem.\n\nSigned-off-by: Sumit Saxena <sumit.saxena@avagotech.com>\nSigned-off-by: Kashyap Desai <kashyap.desai@avagotech.com>\nReviewed-by: Tomas Henzl <thenzl@redhat.com>\nSigned-off-by: Christoph Hellwig <hch@lst.de>",
        "before_after_code_files": [
          "drivers/scsi/megaraid/megaraid_sas.h||drivers/scsi/megaraid/megaraid_sas.h",
          "drivers/scsi/megaraid/megaraid_sas_base.c||drivers/scsi/megaraid/megaraid_sas_base.c",
          "drivers/scsi/megaraid/megaraid_sas_fusion.c||drivers/scsi/megaraid/megaraid_sas_fusion.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/megaraid/megaraid_sas.h||drivers/scsi/megaraid/megaraid_sas.h": [
          "File: drivers/scsi/megaraid/megaraid_sas.h -> drivers/scsi/megaraid/megaraid_sas.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "105: #define MFI_STATE_READY    0xB0000000",
          "106: #define MFI_STATE_OPERATIONAL   0xC0000000",
          "107: #define MFI_STATE_FAULT    0xF0000000",
          "108: #define MFI_RESET_REQUIRED   0x00000001",
          "109: #define MFI_RESET_ADAPTER   0x00000002",
          "110: #define MEGAMFI_FRAME_SIZE   64",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108: #define MFI_STATE_FORCE_OCR   0x00000080",
          "109: #define MFI_STATE_DMADONE   0x00000008",
          "110: #define MFI_STATE_CRASH_DUMP_DONE  0x00000004",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191: #define MR_DCMD_CLUSTER_RESET_LD  0x08010200",
          "192: #define MR_DCMD_PD_LIST_QUERY                   0x02010100",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197: #define MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS 0x01190100",
          "198: #define MR_DRIVER_SET_APP_CRASHDUMP_MODE (0xF0010000 | 0x0600)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "263:  MFI_STAT_INVALID_STATUS = 0xFF",
          "264: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "275: #define MAX_CRASH_DUMP_SIZE 512",
          "276: #define CRASH_DMA_BUF_SIZE  (1024 * 1024)",
          "278: enum MR_FW_CRASH_DUMP_STATE {",
          "279:  UNAVAILABLE = 0,",
          "280:  AVAILABLE = 1,",
          "281:  COPYING = 2,",
          "282:  COPIED = 3,",
          "283:  COPY_ERROR = 4,",
          "284: };",
          "286: enum _MR_CRASH_BUF_STATUS {",
          "287:  MR_CRASH_BUF_TURN_OFF = 0,",
          "288:  MR_CRASH_BUF_TURN_ON = 1,",
          "289: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "934:  } iov;",
          "937: } __packed;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "961:  struct {",
          "962: #if defined(__BIG_ENDIAN_BITFIELD)",
          "963:   u32     reserved:25;",
          "964:   u32     supportCrashDump:1;",
          "965:   u32     reserved1:6;",
          "966: #else",
          "967:   u32     reserved1:6;",
          "968:   u32     supportCrashDump:1;",
          "969:   u32     reserved:25;",
          "970: #endif",
          "971:  } adapterOperations3;",
          "973:  u8          pad[0x800-0x7EC];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1559:  u32 *reply_queue;",
          "1560:  dma_addr_t reply_queue_h;",
          "1562:  struct megasas_register_set __iomem *reg_set;",
          "1563:  u32 *reply_post_host_index_addr[MR_MAX_MSIX_REG_ARRAY];",
          "1564:  struct megasas_pd_list          pd_list[MEGASAS_MAX_PD];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1599:  u32 *crash_dump_buf;",
          "1600:  dma_addr_t crash_dump_h;",
          "1601:  void *crash_buf[MAX_CRASH_DUMP_SIZE];",
          "1602:  u32 crash_buf_pages;",
          "1603:  unsigned int    fw_crash_buffer_size;",
          "1604:  unsigned int    fw_crash_state;",
          "1605:  unsigned int    fw_crash_buffer_offset;",
          "1606:  u32 drv_buf_index;",
          "1607:  u32 drv_buf_alloc;",
          "1608:  u32 crash_dump_fw_support;",
          "1609:  u32 crash_dump_drv_support;",
          "1610:  u32 crash_dump_app_support;",
          "1611:  spinlock_t crashdump_lock;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1606:  struct megasas_instance_template *instancet;",
          "1607:  struct tasklet_struct isr_tasklet;",
          "1608:  struct work_struct work_init;",
          "1610:  u8 flag;",
          "1611:  u8 unload;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1660:  struct work_struct crash_init;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1830: u16 MR_PdDevHandleGet(u32 pd, struct MR_FW_RAID_MAP_ALL *map);",
          "1831: u16 MR_GetLDTgtId(u32 ld, struct MR_FW_RAID_MAP_ALL *map);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1885: int megasas_set_crash_dump_params(struct megasas_instance *instance,",
          "1886:   u8 crash_buf_state);",
          "1887: void megasas_free_host_crash_buffer(struct megasas_instance *instance);",
          "1888: void megasas_fusion_crash_dump_wq(struct work_struct *work);",
          "",
          "---------------"
        ],
        "drivers/scsi/megaraid/megaraid_sas_base.c||drivers/scsi/megaraid/megaraid_sas_base.c": [
          "File: drivers/scsi/megaraid/megaraid_sas_base.c -> drivers/scsi/megaraid/megaraid_sas_base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2560:  return queue_depth;",
          "2561: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2563: static ssize_t",
          "2564: megasas_fw_crash_buffer_store(struct device *cdev,",
          "2565:  struct device_attribute *attr, const char *buf, size_t count)",
          "2566: {",
          "2567:  struct Scsi_Host *shost = class_to_shost(cdev);",
          "2568:  struct megasas_instance *instance =",
          "2569:   (struct megasas_instance *) shost->hostdata;",
          "2570:  int val = 0;",
          "2571:  unsigned long flags;",
          "2573:  if (kstrtoint(buf, 0, &val) != 0)",
          "2574:   return -EINVAL;",
          "2576:  spin_lock_irqsave(&instance->crashdump_lock, flags);",
          "2577:  instance->fw_crash_buffer_offset = val;",
          "2578:  spin_unlock_irqrestore(&instance->crashdump_lock, flags);",
          "2579:  return strlen(buf);",
          "2580: }",
          "2582: static ssize_t",
          "2583: megasas_fw_crash_buffer_show(struct device *cdev,",
          "2584:  struct device_attribute *attr, char *buf)",
          "2585: {",
          "2586:  struct Scsi_Host *shost = class_to_shost(cdev);",
          "2587:  struct megasas_instance *instance =",
          "2588:   (struct megasas_instance *) shost->hostdata;",
          "2589:  u32 size;",
          "2590:  unsigned long buff_addr;",
          "2591:  unsigned long dmachunk = CRASH_DMA_BUF_SIZE;",
          "2592:  unsigned long src_addr;",
          "2593:  unsigned long flags;",
          "2594:  u32 buff_offset;",
          "2596:  spin_lock_irqsave(&instance->crashdump_lock, flags);",
          "2597:  buff_offset = instance->fw_crash_buffer_offset;",
          "2598:  if (!instance->crash_dump_buf &&",
          "2599:   !((instance->fw_crash_state == AVAILABLE) ||",
          "2600:   (instance->fw_crash_state == COPYING))) {",
          "2601:   dev_err(&instance->pdev->dev,",
          "2602:    \"Firmware crash dump is not available\\n\");",
          "2603:   spin_unlock_irqrestore(&instance->crashdump_lock, flags);",
          "2604:   return -EINVAL;",
          "2605:  }",
          "2607:  buff_addr = (unsigned long) buf;",
          "2609:  if (buff_offset >",
          "2610:   (instance->fw_crash_buffer_size * dmachunk)) {",
          "2611:   dev_err(&instance->pdev->dev,",
          "2612:    \"Firmware crash dump offset is out of range\\n\");",
          "2613:   spin_unlock_irqrestore(&instance->crashdump_lock, flags);",
          "2614:   return 0;",
          "2615:  }",
          "2617:  size = (instance->fw_crash_buffer_size * dmachunk) - buff_offset;",
          "2618:  size = (size >= PAGE_SIZE) ? (PAGE_SIZE - 1) : size;",
          "2620:  src_addr = (unsigned long)instance->crash_buf[buff_offset / dmachunk] +",
          "2621:   (buff_offset % dmachunk);",
          "2622:  memcpy(buf, (void *)src_addr,  size);",
          "2623:  spin_unlock_irqrestore(&instance->crashdump_lock, flags);",
          "2625:  return size;",
          "2626: }",
          "2628: static ssize_t",
          "2629: megasas_fw_crash_buffer_size_show(struct device *cdev,",
          "2630:  struct device_attribute *attr, char *buf)",
          "2631: {",
          "2632:  struct Scsi_Host *shost = class_to_shost(cdev);",
          "2633:  struct megasas_instance *instance =",
          "2634:   (struct megasas_instance *) shost->hostdata;",
          "2636:  return snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)",
          "2637:   ((instance->fw_crash_buffer_size) * 1024 * 1024)/PAGE_SIZE);",
          "2638: }",
          "2640: static ssize_t",
          "2641: megasas_fw_crash_state_store(struct device *cdev,",
          "2642:  struct device_attribute *attr, const char *buf, size_t count)",
          "2643: {",
          "2644:  struct Scsi_Host *shost = class_to_shost(cdev);",
          "2645:  struct megasas_instance *instance =",
          "2646:   (struct megasas_instance *) shost->hostdata;",
          "2647:  int val = 0;",
          "2648:  unsigned long flags;",
          "2650:  if (kstrtoint(buf, 0, &val) != 0)",
          "2651:   return -EINVAL;",
          "2653:  if ((val <= AVAILABLE || val > COPY_ERROR)) {",
          "2654:   dev_err(&instance->pdev->dev, \"application updates invalid \"",
          "2655:    \"firmware crash state\\n\");",
          "2656:   return -EINVAL;",
          "2657:  }",
          "2659:  instance->fw_crash_state = val;",
          "2661:  if ((val == COPIED) || (val == COPY_ERROR)) {",
          "2662:   spin_lock_irqsave(&instance->crashdump_lock, flags);",
          "2663:   megasas_free_host_crash_buffer(instance);",
          "2664:   spin_unlock_irqrestore(&instance->crashdump_lock, flags);",
          "2665:   if (val == COPY_ERROR)",
          "2666:    dev_info(&instance->pdev->dev, \"application failed to \"",
          "2667:     \"copy Firmware crash dump\\n\");",
          "2668:   else",
          "2669:    dev_info(&instance->pdev->dev, \"Firmware crash dump \"",
          "2670:     \"copied successfully\\n\");",
          "2671:  }",
          "2672:  return strlen(buf);",
          "2673: }",
          "2675: static ssize_t",
          "2676: megasas_fw_crash_state_show(struct device *cdev,",
          "2677:  struct device_attribute *attr, char *buf)",
          "2678: {",
          "2679:  struct Scsi_Host *shost = class_to_shost(cdev);",
          "2680:  struct megasas_instance *instance =",
          "2681:   (struct megasas_instance *) shost->hostdata;",
          "2682:  return snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->fw_crash_state);",
          "2683: }",
          "2685: static ssize_t",
          "2686: megasas_page_size_show(struct device *cdev,",
          "2687:  struct device_attribute *attr, char *buf)",
          "2688: {",
          "2689:  return snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)PAGE_SIZE - 1);",
          "2690: }",
          "2692: static DEVICE_ATTR(fw_crash_buffer, S_IRUGO | S_IWUSR,",
          "2693:  megasas_fw_crash_buffer_show, megasas_fw_crash_buffer_store);",
          "2694: static DEVICE_ATTR(fw_crash_buffer_size, S_IRUGO,",
          "2695:  megasas_fw_crash_buffer_size_show, NULL);",
          "2696: static DEVICE_ATTR(fw_crash_state, S_IRUGO | S_IWUSR,",
          "2697:  megasas_fw_crash_state_show, megasas_fw_crash_state_store);",
          "2698: static DEVICE_ATTR(page_size, S_IRUGO,",
          "2699:  megasas_page_size_show, NULL);",
          "2701: struct device_attribute *megaraid_host_attrs[] = {",
          "2702:  &dev_attr_fw_crash_buffer_size,",
          "2703:  &dev_attr_fw_crash_buffer,",
          "2704:  &dev_attr_fw_crash_state,",
          "2705:  &dev_attr_page_size,",
          "2706:  NULL,",
          "2707: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2575:  .eh_bus_reset_handler = megasas_reset_bus_host,",
          "2576:  .eh_host_reset_handler = megasas_reset_bus_host,",
          "2577:  .eh_timed_out = megasas_reset_timer,",
          "2578:  .bios_param = megasas_bios_param,",
          "2579:  .use_clustering = ENABLE_CLUSTERING,",
          "2580:  .change_queue_depth = megasas_change_queue_depth,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2724:  .shost_attrs = megaraid_host_attrs,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3887:  return ret;",
          "3888: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4043:      MR_CRASH_BUF_TURN_OFF = 0",
          "4044:      MR_CRASH_BUF_TURN_ON = 1",
          "4052: int megasas_set_crash_dump_params(struct megasas_instance *instance,",
          "4053:  u8 crash_buf_state)",
          "4054: {",
          "4055:  int ret = 0;",
          "4056:  struct megasas_cmd *cmd;",
          "4057:  struct megasas_dcmd_frame *dcmd;",
          "4059:  cmd = megasas_get_cmd(instance);",
          "4061:  if (!cmd) {",
          "4062:   dev_err(&instance->pdev->dev, \"Failed to get a free cmd\\n\");",
          "4063:   return -ENOMEM;",
          "4064:  }",
          "4067:  dcmd = &cmd->frame->dcmd;",
          "4069:  memset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);",
          "4070:  dcmd->mbox.b[0] = crash_buf_state;",
          "4071:  dcmd->cmd = MFI_CMD_DCMD;",
          "4072:  dcmd->cmd_status = 0xFF;",
          "4073:  dcmd->sge_count = 1;",
          "4074:  dcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);",
          "4075:  dcmd->timeout = 0;",
          "4076:  dcmd->pad_0 = 0;",
          "4077:  dcmd->data_xfer_len = cpu_to_le32(CRASH_DMA_BUF_SIZE);",
          "4078:  dcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS);",
          "4079:  dcmd->sgl.sge32[0].phys_addr = cpu_to_le32(instance->crash_dump_h);",
          "4080:  dcmd->sgl.sge32[0].length = cpu_to_le32(CRASH_DMA_BUF_SIZE);",
          "4082:  if (!megasas_issue_polled(instance, cmd))",
          "4083:   ret = 0;",
          "4084:  else",
          "4085:   ret = -1;",
          "4086:  megasas_return_cmd(instance, cmd);",
          "4087:  return ret;",
          "4088: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4272:    printk(KERN_WARNING \"megaraid_sas: I am VF \"",
          "4273:           \"requestorId %d\\n\", instance->requestorId);",
          "4274:   }",
          "4275:  }",
          "4276:  instance->max_sectors_per_req = instance->max_num_sge *",
          "4277:       PAGE_SIZE / 512;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4476:   le32_to_cpus((u32 *)&ctrl_info->adapterOperations3);",
          "4477:   instance->crash_dump_fw_support =",
          "4478:    ctrl_info->adapterOperations3.supportCrashDump;",
          "4479:   instance->crash_dump_drv_support =",
          "4480:    (instance->crash_dump_fw_support &&",
          "4481:    instance->crash_dump_buf);",
          "4482:   if (instance->crash_dump_drv_support) {",
          "4483:    dev_info(&instance->pdev->dev, \"Firmware Crash dump \"",
          "4484:     \"feature is supported\\n\");",
          "4485:    megasas_set_crash_dump_params(instance,",
          "4486:     MR_CRASH_BUF_TURN_OFF);",
          "4488:   } else {",
          "4489:    if (instance->crash_dump_buf)",
          "4490:     pci_free_consistent(instance->pdev,",
          "4491:      CRASH_DMA_BUF_SIZE,",
          "4492:      instance->crash_dump_buf,",
          "4493:      instance->crash_dump_h);",
          "4494:    instance->crash_dump_buf = NULL;",
          "4495:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4791:   break;",
          "4792:  }",
          "4794:  megasas_poll_wait_aen = 0;",
          "4795:  instance->flag_ieee = 0;",
          "4796:  instance->ev = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5016:  instance->drv_buf_index = 0;",
          "5017:  instance->drv_buf_alloc = 0;",
          "5018:  instance->crash_dump_fw_support = 0;",
          "5019:  instance->crash_dump_app_support = 0;",
          "5020:  instance->fw_crash_state = UNAVAILABLE;",
          "5021:  spin_lock_init(&instance->crashdump_lock);",
          "5022:  instance->crash_dump_buf = NULL;",
          "5024:  if (!reset_devices)",
          "5025:   instance->crash_dump_buf = pci_alloc_consistent(pdev,",
          "5026:       CRASH_DMA_BUF_SIZE,",
          "5027:       &instance->crash_dump_h);",
          "5028:  if (!instance->crash_dump_buf)",
          "5029:   dev_err(&instance->pdev->dev, \"Can't allocate Firmware \"",
          "5030:    \"crash dump DMA buffer\\n\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4852:  if ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||",
          "4853:      (instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) ||",
          "4854:      (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) ||",
          "4856:   INIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);",
          "4858:   INIT_WORK(&instance->work_init, process_fw_state_change_wq);",
          "",
          "[Removed Lines]",
          "4855:      (instance->pdev->device == PCI_DEVICE_ID_LSI_FURY))",
          "4857:  else",
          "",
          "[Added Lines]",
          "5093:      (instance->pdev->device == PCI_DEVICE_ID_LSI_FURY)) {",
          "5095:   INIT_WORK(&instance->crash_init, megasas_fusion_crash_dump_wq);",
          "5096:  } else",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5342:  if (instance->requestorId && !instance->skip_heartbeat_timer_del)",
          "5343:   del_timer_sync(&instance->sriov_heartbeat_timer);",
          "5345:  scsi_remove_host(instance->host);",
          "5346:  megasas_flush_cache(instance);",
          "5347:  megasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5584:  if (instance->fw_crash_state != UNAVAILABLE)",
          "5585:   megasas_free_host_crash_buffer(instance);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5432:         instance->hb_host_mem,",
          "5433:         instance->hb_host_mem_h);",
          "5435:  scsi_host_put(host);",
          "5437:  pci_disable_device(pdev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5676:  if (instance->crash_dump_buf)",
          "5677:   pci_free_consistent(pdev, CRASH_DMA_BUF_SIZE,",
          "5678:        instance->crash_dump_buf, instance->crash_dump_h);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5523:  return mask;",
          "5524: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5777: static int megasas_set_crash_dump_params_ioctl(",
          "5778:  struct megasas_cmd *cmd)",
          "5779: {",
          "5780:  struct megasas_instance *local_instance;",
          "5781:  int i, error = 0;",
          "5782:  int crash_support;",
          "5784:  crash_support = cmd->frame->dcmd.mbox.w[0];",
          "5786:  for (i = 0; i < megasas_mgmt_info.max_index; i++) {",
          "5787:   local_instance = megasas_mgmt_info.instance[i];",
          "5788:   if (local_instance && local_instance->crash_dump_drv_support) {",
          "5789:    if ((local_instance->adprecovery ==",
          "5790:     MEGASAS_HBA_OPERATIONAL) &&",
          "5791:     !megasas_set_crash_dump_params(local_instance,",
          "5792:      crash_support)) {",
          "5793:     local_instance->crash_dump_app_support =",
          "5794:      crash_support;",
          "5795:     dev_info(&local_instance->pdev->dev,",
          "5796:      \"Application firmware crash \"",
          "5797:      \"dump mode set success\\n\");",
          "5798:     error = 0;",
          "5799:    } else {",
          "5800:     dev_info(&local_instance->pdev->dev,",
          "5801:      \"Application firmware crash \"",
          "5802:      \"dump mode set failed\\n\");",
          "5803:     error = -1;",
          "5804:    }",
          "5805:   }",
          "5806:  }",
          "5807:  return error;",
          "5808: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "5569:             MFI_FRAME_SGL64 |",
          "5570:             MFI_FRAME_SENSE64));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5856:  if (cmd->frame->dcmd.opcode == MR_DRIVER_SET_APP_CRASHDUMP_MODE) {",
          "5857:   error = megasas_set_crash_dump_params_ioctl(cmd);",
          "5858:   megasas_return_cmd(instance, cmd);",
          "5859:   return error;",
          "5860:  }",
          "",
          "---------------"
        ],
        "drivers/scsi/megaraid/megaraid_sas_fusion.c||drivers/scsi/megaraid/megaraid_sas_fusion.c": [
          "File: drivers/scsi/megaraid/megaraid_sas_fusion.c -> drivers/scsi/megaraid/megaraid_sas_fusion.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2055: {",
          "2056:  struct megasas_irq_context *irq_context = devp;",
          "2057:  struct megasas_instance *instance = irq_context->instance;",
          "2060:  if (instance->mask_interrupts)",
          "2061:   return IRQ_NONE;",
          "",
          "[Removed Lines]",
          "2058:  u32 mfiStatus, fw_state;",
          "",
          "[Added Lines]",
          "2060:  u32 mfiStatus, fw_state, dma_state;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2078:   fw_state = instance->instancet->read_fw_status_reg(",
          "2079:    instance->reg_set) & MFI_STATE_MASK;",
          "2081:    printk(KERN_WARNING \"megaraid_sas: Iop2SysDoorbellInt\"",
          "2082:           \"for scsi%d\\n\", instance->host->host_no);",
          "2083:    schedule_work(&instance->work_init);",
          "",
          "[Removed Lines]",
          "2080:   if (fw_state == MFI_STATE_FAULT) {",
          "",
          "[Added Lines]",
          "2082:   dma_state = instance->instancet->read_fw_status_reg",
          "2083:    (instance->reg_set) & MFI_STATE_DMADONE;",
          "2084:   if (instance->crash_dump_drv_support &&",
          "2085:    instance->crash_dump_app_support) {",
          "2087:    if ((fw_state == MFI_STATE_FAULT) && dma_state)",
          "2088:     schedule_work(&instance->crash_init);",
          "2089:    else if (fw_state == MFI_STATE_FAULT)",
          "2090:     schedule_work(&instance->work_init);",
          "2091:   } else if (fw_state == MFI_STATE_FAULT) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2229:  return readl(&(regs)->outbound_scratch_pad);",
          "2230: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2248: static void",
          "2249: megasas_alloc_host_crash_buffer(struct megasas_instance *instance)",
          "2250: {",
          "2251:  unsigned int i;",
          "2253:  instance->crash_buf_pages = get_order(CRASH_DMA_BUF_SIZE);",
          "2254:  for (i = 0; i < MAX_CRASH_DUMP_SIZE; i++) {",
          "2255:   instance->crash_buf[i] = (void *)__get_free_pages(GFP_KERNEL,",
          "2256:     instance->crash_buf_pages);",
          "2257:   if (!instance->crash_buf[i]) {",
          "2258:    dev_info(&instance->pdev->dev, \"Firmware crash dump \"",
          "2259:     \"memory allocation failed at index %d\\n\", i);",
          "2260:    break;",
          "2261:   }",
          "2262:  }",
          "2263:  instance->drv_buf_alloc = i;",
          "2264: }",
          "2270: void",
          "2271: megasas_free_host_crash_buffer(struct megasas_instance *instance)",
          "2272: {",
          "2273:  unsigned int i",
          "2274: ;",
          "2275:  for (i = 0; i < instance->drv_buf_alloc; i++) {",
          "2276:   if (instance->crash_buf[i])",
          "2277:    free_pages((ulong)instance->crash_buf[i],",
          "2278:      instance->crash_buf_pages);",
          "2279:  }",
          "2280:  instance->drv_buf_index = 0;",
          "2281:  instance->drv_buf_alloc = 0;",
          "2282:  instance->fw_crash_state = UNAVAILABLE;",
          "2283:  instance->fw_crash_buffer_size = 0;",
          "2284: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2372:  struct megasas_cmd *cmd_mfi;",
          "2373:  union MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;",
          "2374:  u32 host_diag, abs_state, status_reg, reset_adapter;",
          "2376:  instance = (struct megasas_instance *)shost->hostdata;",
          "2377:  fusion = instance->ctrl_context;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2429:  u32 io_timeout_in_crash_mode = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2385:   mutex_unlock(&instance->reset_mutex);",
          "2386:   return FAILED;",
          "2387:  }",
          "2389:  if (instance->requestorId && !instance->skip_heartbeat_timer_del)",
          "2390:   del_timer_sync(&instance->sriov_heartbeat_timer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2443:  status_reg = instance->instancet->read_fw_status_reg(instance->reg_set);",
          "2444:  abs_state = status_reg & MFI_STATE_MASK;",
          "2447:  if (abs_state != MFI_STATE_FAULT && instance->crash_dump_buf &&",
          "2448:   instance->crash_dump_app_support && iotimeout) {",
          "2449:   dev_info(&instance->pdev->dev, \"IO timeout is detected, \"",
          "2450:    \"forcibly FAULT Firmware\\n\");",
          "2451:   instance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;",
          "2452:   status_reg = readl(&instance->reg_set->doorbell);",
          "2453:   writel(status_reg | MFI_STATE_FORCE_OCR,",
          "2454:    &instance->reg_set->doorbell);",
          "2455:   readl(&instance->reg_set->doorbell);",
          "2456:   mutex_unlock(&instance->reset_mutex);",
          "2457:   do {",
          "2458:    ssleep(3);",
          "2459:    io_timeout_in_crash_mode++;",
          "2460:    dev_dbg(&instance->pdev->dev, \"waiting for [%d] \"",
          "2461:     \"seconds for crash dump collection and OCR \"",
          "2462:     \"to be done\\n\", (io_timeout_in_crash_mode * 3));",
          "2463:   } while ((instance->adprecovery != MEGASAS_HBA_OPERATIONAL) &&",
          "2464:    (io_timeout_in_crash_mode < 80));",
          "2466:   if (instance->adprecovery == MEGASAS_HBA_OPERATIONAL) {",
          "2467:    dev_info(&instance->pdev->dev, \"OCR done for IO \"",
          "2468:     \"timeout case\\n\");",
          "2469:    retval = SUCCESS;",
          "2470:   } else {",
          "2471:    dev_info(&instance->pdev->dev, \"Controller is not \"",
          "2472:     \"operational after 240 seconds wait for IO \"",
          "2473:     \"timeout case in FW crash dump mode\\n do \"",
          "2474:     \"OCR/kill adapter\\n\");",
          "2475:    retval = megasas_reset_fusion(shost, 0);",
          "2476:   }",
          "2477:   return retval;",
          "2478:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2651:    printk(KERN_WARNING \"megaraid_sas: Reset \"",
          "2652:           \"successful for scsi%d.\\n\",",
          "2653:     instance->host->host_no);",
          "2654:    retval = SUCCESS;",
          "2655:    goto out;",
          "2656:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2746:    if (instance->crash_dump_drv_support) {",
          "2747:     if (instance->crash_dump_app_support)",
          "2748:      megasas_set_crash_dump_params(instance,",
          "2749:       MR_CRASH_BUF_TURN_ON);",
          "2750:     else",
          "2751:      megasas_set_crash_dump_params(instance,",
          "2752:       MR_CRASH_BUF_TURN_OFF);",
          "2753:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2679:  return retval;",
          "2680: }",
          "2683: void megasas_fusion_ocr_wq(struct work_struct *work)",
          "2684: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2783: void  megasas_fusion_crash_dump_wq(struct work_struct *work)",
          "2784: {",
          "2785:  struct megasas_instance *instance =",
          "2786:   container_of(work, struct megasas_instance, crash_init);",
          "2787:  u32 status_reg;",
          "2788:  u8 partial_copy = 0;",
          "2791:  status_reg = instance->instancet->read_fw_status_reg(instance->reg_set);",
          "2797:  if (instance->drv_buf_index == 0) {",
          "2801:   if (instance->drv_buf_alloc) {",
          "2802:    dev_info(&instance->pdev->dev, \"earlier crash dump is \"",
          "2803:     \"not yet copied by application, ignoring this \"",
          "2804:     \"crash dump and initiating OCR\\n\");",
          "2805:    status_reg |= MFI_STATE_CRASH_DUMP_DONE;",
          "2806:    writel(status_reg,",
          "2807:     &instance->reg_set->outbound_scratch_pad);",
          "2808:    readl(&instance->reg_set->outbound_scratch_pad);",
          "2809:    return;",
          "2810:   }",
          "2811:   megasas_alloc_host_crash_buffer(instance);",
          "2812:   dev_info(&instance->pdev->dev, \"Number of host crash buffers \"",
          "2813:    \"allocated: %d\\n\", instance->drv_buf_alloc);",
          "2814:  }",
          "2821:  if (instance->drv_buf_index >= (instance->drv_buf_alloc)) {",
          "2822:   dev_info(&instance->pdev->dev, \"Driver is done copying \"",
          "2823:    \"the buffer: %d\\n\", instance->drv_buf_alloc);",
          "2824:   status_reg |= MFI_STATE_CRASH_DUMP_DONE;",
          "2825:   partial_copy = 1;",
          "2826:  } else {",
          "2827:   memcpy(instance->crash_buf[instance->drv_buf_index],",
          "2828:    instance->crash_dump_buf, CRASH_DMA_BUF_SIZE);",
          "2829:   instance->drv_buf_index++;",
          "2830:   status_reg &= ~MFI_STATE_DMADONE;",
          "2831:  }",
          "2833:  if (status_reg & MFI_STATE_CRASH_DUMP_DONE) {",
          "2834:   dev_info(&instance->pdev->dev, \"Crash Dump is available,number \"",
          "2835:    \"of copied buffers: %d\\n\", instance->drv_buf_index);",
          "2836:   instance->fw_crash_buffer_size =  instance->drv_buf_index;",
          "2837:   instance->fw_crash_state = AVAILABLE;",
          "2838:   instance->drv_buf_index = 0;",
          "2839:   writel(status_reg, &instance->reg_set->outbound_scratch_pad);",
          "2840:   readl(&instance->reg_set->outbound_scratch_pad);",
          "2841:   if (!partial_copy)",
          "2842:    megasas_reset_fusion(instance->host, 0);",
          "2843:  } else {",
          "2844:   writel(status_reg, &instance->reg_set->outbound_scratch_pad);",
          "2845:   readl(&instance->reg_set->outbound_scratch_pad);",
          "2846:  }",
          "2847: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
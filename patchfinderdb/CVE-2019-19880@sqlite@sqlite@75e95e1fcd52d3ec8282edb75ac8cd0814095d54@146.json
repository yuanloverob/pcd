{
  "cve_id": "CVE-2019-19880",
  "cve_desc": "exprListAppendList in window.c in SQLite 3.30.1 allows attackers to trigger an invalid pointer dereference because constant integer values in ORDER BY clauses of window definitions are mishandled.",
  "repo": "sqlite/sqlite",
  "patch_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
  "patch_info": {
    "commit_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/window.c"
    ],
    "message": "When processing constant integer values in ORDER BY clauses of window definitions (see check-in [7e4809eadfe99ebf]) be sure to fully disable the constant value to avoid an invalid pointer dereference if the expression is ever duplicated. This fixes a crash report from Yongheng and Rui.\n\nFossilOrigin-Name: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 8223e79f987feda5c8e51ec52cec6798cca16d070b10558939e2888ca1a25b8e",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "895:     int nInit = pList ? pList->nExpr : 0;",
      "896:     for(i=0; i<pAppend->nExpr; i++){",
      "897:       Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);",
      "898:       if( bIntToNull && pDup && pDup->op==TK_INTEGER ){",
      "899:         pDup->op = TK_NULL;",
      "900:         pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);",
      "901:       }",
      "902:       pList = sqlite3ExprListAppend(pParse, pList, pDup);",
      "903:       if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "898:       assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );",
      "902:         pDup->u.zToken = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "de21ad704a15098f33b213ce37680f975eea67d5",
      "candidate_info": {
        "commit_hash": "de21ad704a15098f33b213ce37680f975eea67d5",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/de21ad704a15098f33b213ce37680f975eea67d5",
        "files": [
          "ext/fts5/test/fts5corrupt3.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Fix a test script problem in fts5corrupt3.test.\n\nFossilOrigin-Name: 858f62274eb727109d0452ad2d80c0e0acab0f569494b1218c404501e103ed39",
        "before_after_code_files": [
          "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test": [
          "File: ext/fts5/test/fts5corrupt3.test -> ext/fts5/test/fts5corrupt3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "7994: | end crash-2acc487d09f033.db",
          "7995: }]} {}",
          "8000: } {1 {database disk image is malformed}}",
          "8002: #-------------------------------------------------------------------------",
          "",
          "[Removed Lines]",
          "7997: do_catchsql_test 56.1 {",
          "7998:   INSERT INTO t1(b) VALUES(randomblob(250));",
          "7999:   INSERT INTO t1(b) VALUES(randomblob(250));",
          "",
          "[Added Lines]",
          "7997: do_test 56.1 {",
          "7998:   set res [catchsql {",
          "7999:     INSERT INTO t1(b) VALUES(randomblob(250));",
          "8000:     INSERT INTO t1(b) VALUES(randomblob(250));",
          "8001:   }]",
          "8003:   # For some permutations - those that use the page-cache - this test",
          "8004:   # may return SQLITE_CONSTRAINT instead of SQLITE_CORRUPT. This is because",
          "8005:   # the corrupt db in the test over-reads the page buffer slightly, with",
          "8006:   # different results depending on whether or not the page-cache is in use.",
          "8007:   if {$res==\"1 {constraint failed}\"} {",
          "8008:     set res \"1 {database disk image is malformed}\"",
          "8009:   }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 593a7e6e20a2f91fe3497edd7effad50ac876f7f03c9222e332dfeb43d26882e",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8616cff6c8541e2837ccb7a2bc5792de5aba962f",
      "candidate_info": {
        "commit_hash": "8616cff6c8541e2837ccb7a2bc5792de5aba962f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/8616cff6c8541e2837ccb7a2bc5792de5aba962f",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/os_unix.c",
          "src/vdbe.c"
        ],
        "message": "Remove unreachable \"break\" statements to silence harmless compiler warnings from ICC.\n\nFossilOrigin-Name: 0d7287e1bfdd5a392bf2fb17699e7cfd0b08bf61fab6cbf4b4bb347b3c4b4610",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/os_unix.c||src/os_unix.c",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 18bfb2179ce2c60cec8f5859a84b737731a5e53b28e35072cbb249f18b94262b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/os_unix.c||src/os_unix.c": [
          "File: src/os_unix.c -> src/os_unix.c"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3376:     rc = SQLITE_ERROR;",
          "3377:     goto abort_due_to_error;",
          "3378:   }",
          "3380: }",
          "",
          "[Removed Lines]",
          "3379:   break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4132:     if( (pIn3->flags & (MEM_Int|MEM_IntReal))==0 ){",
          "4133:       if( (pIn3->flags & MEM_Real)==0 ){",
          "4134:         if( (pIn3->flags & MEM_Null) || oc>=OP_SeekGE ){",
          "4137:         }else{",
          "4138:           rc = sqlite3BtreeLast(pC->uc.pCursor, &res);",
          "4139:           if( rc!=SQLITE_OK ) goto abort_due_to_error;",
          "",
          "[Removed Lines]",
          "4135:           VdbeBranchTaken(1,2); goto jump_to_p2;",
          "4136:           break;",
          "",
          "[Added Lines]",
          "4135:           VdbeBranchTaken(1,2);",
          "4136:           goto jump_to_p2;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "98c5ad309fce1eeea6cfe624e1dfd341abca947a",
      "candidate_info": {
        "commit_hash": "98c5ad309fce1eeea6cfe624e1dfd341abca947a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/98c5ad309fce1eeea6cfe624e1dfd341abca947a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Have .recover store all orphaned rows in a single table, with extra columns to indicate the orphaned page and sub-tree they were discovered within.\n\nFossilOrigin-Name: 7221f6e33ed6a5a96ec61e25f2a1f70b84aae66e503d897eb7b7ff1aec42355d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: bee2652ac26370e612a8c81dd7554befc2d523442a2fbbc77dc73479e6a0d7fd",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "6226:     sqlite3_free(pTab->zQuoted);",
          "6227:     if( pTab->azlCol ){",
          "6228:       int i;",
          "6230:         sqlite3_free(pTab->azlCol[i]);",
          "6231:       }",
          "6232:       sqlite3_free(pTab->azlCol);",
          "",
          "[Removed Lines]",
          "6229:       for(i=0; i<pTab->nCol; i++){",
          "",
          "[Added Lines]",
          "6229:       for(i=0; i<=pTab->nCol; i++){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6235:   }",
          "6236: }",
          "6243:   int bIntkey,",
          "",
          "[Removed Lines]",
          "6238: static void recoverOldTable(",
          "6240:   RecoverTable *pTab,",
          "",
          "[Added Lines]",
          "6238: static RecoverTable *recoverOldTable(",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6245: ){",
          "6247:   int rc = *pRc;",
          "6249:   if( rc==SQLITE_OK ){",
          "6250:     int nSqlCol = 0;",
          "6251:     int bSqlIntkey = 0;",
          "6252:     sqlite3_stmt *pStmt = 0;",
          "6254:     rc = sqlite3_open(\"\", &dbtmp);",
          "6255:     if( rc==SQLITE_OK ){",
          "6256:       rc = sqlite3_exec(dbtmp, \"PRAGMA writable_schema = on\", 0, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6247:   RecoverTable *pTab = 0;",
          "6249:   pTab = (RecoverTable*)shellMalloc(&rc, sizeof(RecoverTable));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6285:     shellFinalize(&rc, pStmt);",
          "6287:     if( bIntkey==bSqlIntkey ){",
          "6288:       const char *zPk = \"_rowid_\";",
          "6289:       sqlite3_stmt *pPkFinder = 0;",
          "6292:           \"SELECT cid, name FROM pragma_table_info(%Q) \"",
          "6293:           \"  WHERE pk=1 AND type='integer' COLLATE nocase\"",
          "6300:       }",
          "6302:       pTab->zName = shellMPrintf(&rc, \"%s\", zName);",
          "6303:       pTab->zQuoted = shellMPrintf(&rc, \"%Q\", pTab->zName);",
          "6305:       pTab->nCol = nSqlCol;",
          "6308:         pTab->azlCol[0] = shellMPrintf(&rc, \"%Q\", zPk);",
          "6309:       }else{",
          "6314:           \"FROM pragma_table_info(%Q)\",",
          "6324:       }",
          "6325:       shellFinalize(&rc, pPkFinder);",
          "6326:     }",
          "6327:   }",
          "",
          "[Removed Lines]",
          "6291:       shellPreparePrintf(dbtmp, &rc, &pPkFinder,",
          "6294:           \"  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\",",
          "6295:           zName, zName",
          "6296:       );",
          "6297:       if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){",
          "6298:         pTab->iPk = sqlite3_column_int(pPkFinder, 0);",
          "6299:         zPk = (const char*)sqlite3_column_text(pPkFinder, 1);",
          "6304:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * nSqlCol);",
          "6307:       if( nSqlCol==1 && pTab->iPk==0 ){",
          "6310:         shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6311:           \"SELECT -1+row_number()          OVER (ORDER BY cid),\"",
          "6312:           \"    %Q||%Q||group_concat(name, ', ') FILTER (WHERE cid!=%d) \"",
          "6313:           \"           OVER (ORDER BY cid) \"",
          "6315:           (bIntkey ? zPk : \"\"), (bIntkey ? \", \" : \"\"),",
          "6316:           pTab->iPk, zName",
          "6317:         );",
          "6318:         while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6319:           int idx = sqlite3_column_int(pStmt, 0);",
          "6320:           const char *zText = (const char*)sqlite3_column_text(pStmt, 1);",
          "6321:           pTab->azlCol[idx] = shellMPrintf(&rc, \"%s\", zText);",
          "6322:         }",
          "6323:         shellFinalize(&rc, pStmt);",
          "",
          "[Added Lines]",
          "6289:       int i;",
          "6293:       pTab->iPk = -2;",
          "6294:       if( bIntkey ){",
          "6295:         shellPreparePrintf(dbtmp, &rc, &pPkFinder,",
          "6298:           \"  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\"",
          "6299:           , zName, zName",
          "6300:         );",
          "6301:         if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){",
          "6302:           pTab->iPk = sqlite3_column_int(pPkFinder, 0);",
          "6303:           zPk = (const char*)sqlite3_column_text(pPkFinder, 1);",
          "6304:         }",
          "6309:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * (nSqlCol+1));",
          "6312:       if( bIntkey ){",
          "6315:         pTab->azlCol[0] = shellMPrintf(&rc, \"\");",
          "6316:       }",
          "6317:       i = 1;",
          "6318:       shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6319:           \"SELECT %Q || group_concat(name, ', ') \"",
          "6320:           \"  FILTER (WHERE cid!=%d) OVER (ORDER BY cid) \"",
          "6322:           bIntkey ? \", \" : \"\", pTab->iPk, zName",
          "6323:       );",
          "6324:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6325:         const char *zText = (const char*)sqlite3_column_text(pStmt, 0);",
          "6326:         pTab->azlCol[i] = shellMPrintf(&rc, \"%s%s\", pTab->azlCol[0], zText);",
          "6327:         i++;",
          "6329:       shellFinalize(&rc, pStmt);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6329:  finished:",
          "6330:   sqlite3_close(dbtmp);",
          "6332: }",
          "6334: static RecoverTable *recoverNewTable(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6338:   if( rc!=SQLITE_OK ){",
          "6339:     recoverFreeTable(pTab);",
          "6340:     pTab = 0;",
          "6341:   }",
          "6342:   return pTab;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6336:   int *pRc,",
          "6337:   int iRoot,",
          "6338:   int bIntkey,",
          "6340: ){",
          "6341:   sqlite3_stmt *pStmt = 0;",
          "6342:   RecoverTable *pRet = 0;",
          "",
          "[Removed Lines]",
          "6339:   int nCol",
          "",
          "[Added Lines]",
          "6350:   int nCol,",
          "6351:   int *pbNoop",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6344:   const char *zSql = 0;",
          "6345:   const char *zName = 0;",
          "6351:   shellPreparePrintf(pState->db, pRc, &pStmt,",
          "",
          "[Removed Lines]",
          "6347:   pRet = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6348:   if( pRet ) pRet->iPk = -2;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6360:     if( sqlite3_stricmp(zType, \"table\")==0 ){",
          "6361:       zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6362:       zSql = (const char*)sqlite3_column_text(pStmt, 2);",
          "6364:       break;",
          "6365:     }",
          "6366:   }",
          "6387:     );",
          "6392:     }",
          "6402:       }",
          "6403:     }",
          "6409:   }",
          "6412: }",
          "",
          "[Removed Lines]",
          "6363:       recoverOldTable(pRc, pRet, zName, zSql, bIntkey, nCol);",
          "6367:   shellFinalize(pRc, pStmt);",
          "6368:   if( bNoop ){",
          "6369:     sqlite3_free(pRet);",
          "6370:     return 0;",
          "6371:   }",
          "6373:   if( pRet && pRet->zName==0 ){",
          "6374:     sqlite3_stmt *pStmt = 0;",
          "6376:     pRet->zName = shellMPrintf(pRc, \"orphan_%d_%d\", nCol, iRoot);",
          "6377:     pRet->zQuoted = shellMPrintf(pRc, \"%Q\", pRet->zName);",
          "6378:     pRet->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * nCol);",
          "6379:     pRet->nCol = nCol;",
          "6381:     shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6382:       \"WITH s(i) AS (\"",
          "6383:       \"  SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<%d\"",
          "6384:       \")\"",
          "6385:       \"SELECT i-1, %Q || group_concat('c' || i, ', ') OVER (ORDER BY i) FROM s\",",
          "6386:       nCol, (bIntkey ? \"id, \" : \"\")",
          "6388:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6389:       int idx = sqlite3_column_int(pStmt, 0);",
          "6390:       const char *zText = (const char*)sqlite3_column_text(pStmt, 1);",
          "6391:       pRet->azlCol[idx] = shellMPrintf(pRc, \"%s\", zText);",
          "6393:     shellFinalize(pRc, pStmt);",
          "6395:     if( *pRc==SQLITE_OK ){",
          "6396:       char *zCreate = shellMPrintf(pRc, \"CREATE TABLE %Q (%s)\",",
          "6397:         pRet->zName, pRet->azlCol[nCol-1]",
          "6398:       );",
          "6399:       if( zCreate ){",
          "6400:         raw_printf(pState->out, \"%s;\\n\", zCreate);",
          "6401:         sqlite3_free(zCreate);",
          "6404:   }",
          "6406:   if( *pRc!=SQLITE_OK ){",
          "6407:     recoverFreeTable(pRet);",
          "6408:     pRet = 0;",
          "6411:   return pRet;",
          "",
          "[Added Lines]",
          "6373:       pRet = recoverOldTable(pRc, zName, zSql, bIntkey, nCol);",
          "6378:   shellFinalize(pRc, pStmt);",
          "6380:   return pRet;",
          "6381: }",
          "6383: static RecoverTable *recoverOrphanTable(",
          "6384:   ShellState *pState,",
          "6385:   int *pRc,",
          "6386:   int nCol",
          "6387: ){",
          "6388:   RecoverTable *pTab = 0;",
          "6389:   if( nCol>=0 && *pRc==SQLITE_OK ){",
          "6390:     int i;",
          "6391:     raw_printf(pState->out,",
          "6392:         \"CREATE TABLE recover_orphan(rootpgno INTEGER, \"",
          "6393:         \"pgno INTEGER, nfield INTEGER, id INTEGER\"",
          "6395:     for(i=0; i<nCol; i++){",
          "6396:       raw_printf(pState->out, \", c%d\", i);",
          "6398:     raw_printf(pState->out, \");\\n\");",
          "6400:     pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6401:     if( pTab ){",
          "6402:       pTab->zName = shellMPrintf(pRc, \"%s\", \"recover_orphan\");",
          "6403:       pTab->zQuoted = shellMPrintf(pRc, \"%Q\", pTab->zName);",
          "6404:       pTab->nCol = nCol;",
          "6405:       pTab->iPk = -2;",
          "6406:       if( nCol>0 ){",
          "6407:         pTab->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * (nCol+1));",
          "6408:         if( pTab->azlCol ){",
          "6409:           pTab->azlCol[nCol] = shellMPrintf(pRc, \"\");",
          "6410:           for(i=nCol-1; i>=0; i--){",
          "6411:             pTab->azlCol[i] = shellMPrintf(pRc, \"%s, NULL\", pTab->azlCol[i+1]);",
          "6412:           }",
          "6413:         }",
          "6417:     if( *pRc!=SQLITE_OK ){",
          "6418:       recoverFreeTable(pTab);",
          "6419:       pTab = 0;",
          "6420:     }",
          "6422:   return pTab;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6425:   int i;",
          "6428:   for(i=1; i<nArg; i++){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6437:   int nOrphan = -1;",
          "6438:   RecoverTable *pOrphan = 0;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6545:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6546:     \")\"",
          "6547:     \"GROUP BY pgno, cell;\"",
          "6548:   );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6561:     \"CREATE INDEX recovery.schema_rootpage ON schema(rootpage);\"",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6566:     shellFinalize(&rc, pStmt);",
          "6567:   }",
          "6569:   shellPrepare(pState->db, &rc,",
          "6570:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "6571:   );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6585:   shellPrepare(pState->db, &rc,",
          "6586:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map\"",
          "6587:       \"  WHERE root>1 AND root NOT IN (SELECT rootpage FROM recovery.schema)\"",
          "6588:       , &pLoop",
          "6589:   );",
          "6590:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6591:     nOrphan = sqlite3_column_int(pLoop, 0);",
          "6592:   }",
          "6593:   shellFinalize(&rc, pLoop);",
          "6594:   pLoop = 0;",
          "6595:   pOrphan = recoverOrphanTable(pState, &rc, nOrphan);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "6586:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6587:     int bIntkey = sqlite3_column_int(pLoop, 1);",
          "6588:     int nCol = sqlite3_column_int(pLoop, 2);",
          "6589:     RecoverTable *pTab;",
          "6603:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6605:           );",
          "6606:         }",
          "6608:       }",
          "6610:     }",
          "6612:   }",
          "6613:   shellFinalize(&rc, pLoop);",
          "6614:   shellFinalize(&rc, pPages);",
          "6615:   shellFinalize(&rc, pCells);",
          "6618:   if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "6591:     pTab = recoverNewTable(pState, &rc, iRoot, bIntkey, nCol);",
          "6592:     if( pTab ){",
          "6593:       if( 0==sqlite3_stricmp(pTab->zName, \"sqlite_sequence\") ){",
          "6594:         raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6595:       }",
          "6596:       sqlite3_bind_int(pPages, 1, iRoot);",
          "6597:       sqlite3_bind_int(pCells, 2, pTab->iPk);",
          "6598:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){",
          "6599:         sqlite3_bind_int(pCells, 1, sqlite3_column_int(pPages, 0));",
          "6600:         while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6601:           int iMax = sqlite3_column_int(pCells, 0);",
          "6602:           const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6604:               pTab->zQuoted, pTab->azlCol[iMax>0?iMax:0], zVal",
          "6607:         shellReset(&rc, pCells);",
          "6609:       shellReset(&rc, pPages);",
          "6611:     recoverFreeTable(pTab);",
          "",
          "[Added Lines]",
          "6617:     int bNoop = 0;",
          "6620:     pTab = recoverNewTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6621:     if( bNoop || rc ) continue;",
          "6622:     if( pTab==0 ) pTab = pOrphan;",
          "6624:     if( 0==sqlite3_stricmp(pTab->zName, \"sqlite_sequence\") ){",
          "6625:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6626:     }",
          "6627:     sqlite3_bind_int(pPages, 1, iRoot);",
          "6628:     sqlite3_bind_int(pCells, 2, pTab->iPk);",
          "6630:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){",
          "6631:       int iPgno = sqlite3_column_int(pPages, 0);",
          "6632:       sqlite3_bind_int(pCells, 1, iPgno);",
          "6633:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6634:         int nField = sqlite3_column_int(pCells, 0);",
          "6635:         const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6637:         nField = nField+1;",
          "6638:         if( pTab==pOrphan ){",
          "6639:           raw_printf(pState->out,",
          "6640:               \"INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\\n\",",
          "6641:               pTab->zQuoted, iRoot, iPgno, nField,",
          "6642:               bIntkey ? \"\" : \"NULL, \", zVal, pTab->azlCol[nField]",
          "6643:           );",
          "6644:         }else{",
          "6646:               pTab->zQuoted, pTab->azlCol[nField], zVal",
          "6650:       shellReset(&rc, pCells);",
          "6652:     shellReset(&rc, pPages);",
          "6653:     if( pTab!=pOrphan ) recoverFreeTable(pTab);",
          "6658:   recoverFreeTable(pOrphan);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68c1f9ce9a33d745205d21261cb44124dde057bc",
      "candidate_info": {
        "commit_hash": "68c1f9ce9a33d745205d21261cb44124dde057bc",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/68c1f9ce9a33d745205d21261cb44124dde057bc",
        "files": [
          "ext/fts3/fts3_expr.c",
          "manifest",
          "manifest.uuid",
          "test/fts3expr5.test"
        ],
        "message": "Have fts3 ignore empty sets of parenthesis if built with SQLITE_ENABLE_FTS3_PARENTHESIS.\n\nFossilOrigin-Name: c93c6b45a317c40eb5c0abb6620d21f5821a601632c791e11e5ce62e039eccda",
        "before_after_code_files": [
          "ext/fts3/fts3_expr.c||ext/fts3/fts3_expr.c",
          "manifest.uuid||manifest.uuid",
          "test/fts3expr5.test||test/fts3expr5.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts3/fts3_expr.c||ext/fts3/fts3_expr.c": [
          "File: ext/fts3/fts3_expr.c -> ext/fts3/fts3_expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "497:       int nConsumed = 0;",
          "498:       pParse->nNest++;",
          "499:       rc = fts3ExprParse(pParse, zInput+1, nInput-1, ppExpr, &nConsumed);",
          "502:       return rc;",
          "503:     }else if( *zInput==')' ){",
          "",
          "[Removed Lines]",
          "500:       if( rc==SQLITE_OK && !*ppExpr ){ rc = SQLITE_DONE; }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: cb50509020d952fa9efed8df7fa08b07b71ae9bdbdefea216b6e660863291039",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/fts3expr5.test||test/fts3expr5.test": [
          "File: test/fts3expr5.test -> test/fts3expr5.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:   return",
          "23: }",
          "25: #-------------------------------------------------------------------------",
          "26: # Various forms of empty phrase expressions.",
          "27: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: proc test_fts3expr {expr} {",
          "26:   db one {SELECT fts3_exprtest('simple', $expr, 'a', 'b', 'c')}",
          "27: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:   SELECT rowid FROM t0 WHERE x MATCH '\"\"\"\"';",
          "46: } {}",
          "48: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: #-------------------------------------------------------------------------",
          "53: # Various forms of empty phrase expressions.",
          "54: #",
          "55: set sqlite_fts3_enable_parentheses 1",
          "56: do_test 2.0 {",
          "57:   test_fts3expr {(a:123)(b:234)()(c:456)}",
          "58: } {AND {AND {PHRASE 0 0 123} {PHRASE 1 0 234}} {PHRASE 2 0 456}}",
          "59: do_test 2.1 {",
          "60:   test_fts3expr {(a:123)(b:234)(c:456)}",
          "61: } {AND {AND {PHRASE 0 0 123} {PHRASE 1 0 234}} {PHRASE 2 0 456}}",
          "62: do_test 2.2 {",
          "63:   list [catch { test_fts3expr {\"123\" AND ( )} } msg] $msg",
          "64: } {1 {Error parsing expression}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "480c572f2da02cb6446a55df6c8b2df271446a66",
      "candidate_info": {
        "commit_hash": "480c572f2da02cb6446a55df6c8b2df271446a66",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/480c572f2da02cb6446a55df6c8b2df271446a66",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "test/indexfault.test"
        ],
        "message": "In sqlite3NestedParse() be sure to detect all SQLITE_NOMEM and SQLITE_TOOBIG errors and to distinguish between them.\n\nFossilOrigin-Name: 73056b314bd63288c662752e9bd469b70264c38031c1c857460e64fdb1ed4e2e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "test/indexfault.test||test/indexfault.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: e7144ffd21294d7aebbfa6aa5a262797a6d16de11193f1bf6b75f5f27b04c940",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "260:   zSql = sqlite3VMPrintf(db, zFormat, ap);",
          "261:   va_end(ap);",
          "262:   if( zSql==0 ){",
          "264:   }",
          "265:   pParse->nested++;",
          "266:   memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266:     if( !db->mallocFailed ) pParse->rc = SQLITE_TOOBIG;",
          "267:     return;",
          "",
          "---------------"
        ],
        "test/indexfault.test||test/indexfault.test": [
          "File: test/indexfault.test -> test/indexfault.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "337:   faultsim_test_result {0 {}}",
          "338: }",
          "340: uninstall_custom_faultsim",
          "342: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "340: do_faultsim_test 5 -prep {",
          "341:   reset_db",
          "342: } -body {",
          "343:   execsql {",
          "344:  CREATE TABLE reallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallylongname(a PRIMARY KEY) WITHOUT ROWID;",
          "345:   }",
          "346: } -test {",
          "347:   faultsim_test_result {0 {}}",
          "348: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
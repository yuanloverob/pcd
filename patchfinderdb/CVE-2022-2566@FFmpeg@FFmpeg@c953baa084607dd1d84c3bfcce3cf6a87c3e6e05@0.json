{
  "cve_id": "CVE-2022-2566",
  "cve_desc": "A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "c953baa084607dd1d84c3bfcce3cf6a87c3e6e05",
  "patch_info": {
    "commit_hash": "c953baa084607dd1d84c3bfcce3cf6a87c3e6e05",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c953baa084607dd1d84c3bfcce3cf6a87c3e6e05",
    "files": [
      "libavformat/mov.c"
    ],
    "message": "avformat/mov: Check count sums in build_open_gop_key_points()\n\nFixes: ffmpeg.md\nFixes: Out of array access\nFixes: CVE-2022-2566\n\nFound-by: Andy Nguyen <theflow@google.com>\nFound-by: 3pvd <3pvd@google.com>\nReviewed-by: Andy Nguyen <theflow@google.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavformat/mov.c||libavformat/mov.c"
    ]
  },
  "patch_diff": {
    "libavformat/mov.c||libavformat/mov.c": [
      "File: libavformat/mov.c -> libavformat/mov.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3969:     sc->sample_offsets_count = 0;",
      "3971:         sc->sample_offsets_count += sc->ctts_data[i].count;",
      "3972:     av_freep(&sc->sample_offsets);",
      "3973:     sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));",
      "3974:     if (!sc->sample_offsets)",
      "",
      "[Removed Lines]",
      "3970:     for (uint32_t i = 0; i < sc->ctts_count; i++)",
      "",
      "[Added Lines]",
      "3970:     for (uint32_t i = 0; i < sc->ctts_count; i++) {",
      "3971:         if (sc->ctts_data[i].count > INT_MAX - sc->sample_offsets_count)",
      "3972:             return AVERROR(ENOMEM);",
      "3974:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3988:     sc->open_key_samples_count = 0;",
      "3989:     for (uint32_t i = 0; i < sc->sync_group_count; i++)",
      "3991:             sc->open_key_samples_count += sc->sync_group[i].count;",
      "3992:     av_freep(&sc->open_key_samples);",
      "3993:     sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));",
      "3994:     if (!sc->open_key_samples)",
      "",
      "[Removed Lines]",
      "3990:         if (sc->sync_group[i].index == cra_index)",
      "",
      "[Added Lines]",
      "3993:         if (sc->sync_group[i].index == cra_index) {",
      "3994:             if (sc->sync_group[i].count > INT_MAX - sc->open_key_samples_count)",
      "3995:                 return AVERROR(ENOMEM);",
      "3997:         }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3999:         if (sg->index == cra_index)",
      "4000:             for (uint32_t j = 0; j < sg->count; j++)",
      "4001:                 sc->open_key_samples[k++] = sample_id;",
      "4002:         sample_id += sg->count;",
      "4003:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4008:         if (sg->count > INT_MAX - sample_id)",
      "4009:             return AVERROR_PATCHWELCOME;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6f53f0d09ea4c9c7f7354f018a87ef840315207d",
      "candidate_info": {
        "commit_hash": "6f53f0d09ea4c9c7f7354f018a87ef840315207d",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/6f53f0d09ea4c9c7f7354f018a87ef840315207d",
        "files": [
          "libavformat/mov.c"
        ],
        "message": "avformat/mov: Check count sums in build_open_gop_key_points()\n\nFixes: ffmpeg.md\nFixes: Out of array access\nFixes: CVE-2022-2566\n\nFound-by: Andy Nguyen <theflow@google.com>\nFound-by: 3pvd <3pvd@google.com>\nReviewed-by: Andy Nguyen <theflow@google.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/mov.c||libavformat/mov.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/mov.c||libavformat/mov.c"
          ],
          "candidate": [
            "libavformat/mov.c||libavformat/mov.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/mov.c||libavformat/mov.c": [
          "File: libavformat/mov.c -> libavformat/mov.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3951:     sc->sample_offsets_count = 0;",
          "3953:         sc->sample_offsets_count += sc->ctts_data[i].count;",
          "3954:     av_freep(&sc->sample_offsets);",
          "3955:     sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));",
          "3956:     if (!sc->sample_offsets)",
          "",
          "[Removed Lines]",
          "3952:     for (uint32_t i = 0; i < sc->ctts_count; i++)",
          "",
          "[Added Lines]",
          "3952:     for (uint32_t i = 0; i < sc->ctts_count; i++) {",
          "3953:         if (sc->ctts_data[i].count > INT_MAX - sc->sample_offsets_count)",
          "3954:             return AVERROR(ENOMEM);",
          "3956:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3970:     sc->open_key_samples_count = 0;",
          "3971:     for (uint32_t i = 0; i < sc->sync_group_count; i++)",
          "3973:             sc->open_key_samples_count += sc->sync_group[i].count;",
          "3974:     av_freep(&sc->open_key_samples);",
          "3975:     sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));",
          "3976:     if (!sc->open_key_samples)",
          "",
          "[Removed Lines]",
          "3972:         if (sc->sync_group[i].index == cra_index)",
          "",
          "[Added Lines]",
          "3975:         if (sc->sync_group[i].index == cra_index) {",
          "3976:             if (sc->sync_group[i].count > INT_MAX - sc->open_key_samples_count)",
          "3977:                 return AVERROR(ENOMEM);",
          "3979:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3981:         if (sg->index == cra_index)",
          "3982:             for (uint32_t j = 0; j < sg->count; j++)",
          "3983:                 sc->open_key_samples[k++] = sample_id;",
          "3984:         sample_id += sg->count;",
          "3985:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3990:         if (sg->count > INT_MAX - sample_id)",
          "3991:             return AVERROR_PATCHWELCOME;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ab77b878f1205225c6de1370fb0e998dbcc8bc69",
      "candidate_info": {
        "commit_hash": "ab77b878f1205225c6de1370fb0e998dbcc8bc69",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/ab77b878f1205225c6de1370fb0e998dbcc8bc69",
        "files": [
          "libavformat/isom.h",
          "libavformat/mov.c"
        ],
        "message": "avformat/mov: fix seeking with HEVC open GOP files\n\nThis was tested with medias recorded from an iPhone XR and an iPhone 13.\n\nHere is how a typical stream looks like in coding order:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 sample | PTS | DTS | keyframe |\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u250a        \u250a     \u250a     \u250a          \u250a\n    \u2502   53   \u2502 560 \u2502 510 \u2502    No    \u2502\n    \u2502   54   \u2502 540 \u2502 520 \u2502    No    \u2502\n    \u2502   55   \u2502 530 \u2502 530 \u2502    No    \u2502\n    \u2502   56   \u2502 550 \u2502 540 \u2502    No    \u2502\n    \u2502   57   \u2502 600 \u2502 550 \u2502    Yes   \u2502\n    \u2502 * 58   \u2502 580 \u2502 560 \u2502    No    \u2502\n    \u2502 * 59   \u2502 570 \u2502 570 \u2502    No    \u2502\n    \u2502 * 60   \u2502 590 \u2502 580 \u2502    No    \u2502\n    \u2502   61   \u2502 640 \u2502 590 \u2502    No    \u2502\n    \u2502   62   \u2502 620 \u2502 600 \u2502    No    \u2502\n    \u250a        \u250a     \u250a     \u250a          \u250a\n\nIn composition/display order:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 sample | PTS | DTS | keyframe |\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u250a        \u250a     \u250a     \u250a          \u250a\n    \u2502   55   \u2502 530 \u2502 530 \u2502    No    \u2502\n    \u2502   54   \u2502 540 \u2502 520 \u2502    No    \u2502\n    \u2502   56   \u2502 550 \u2502 540 \u2502    No    \u2502\n    \u2502   53   \u2502 560 \u2502 510 \u2502    No    \u2502\n    \u2502 * 59   \u2502 570 \u2502 570 \u2502    No    \u2502\n    \u2502 * 58   \u2502 580 \u2502 560 \u2502    No    \u2502\n    \u2502 * 60   \u2502 590 \u2502 580 \u2502    No    \u2502\n    \u2502   57   \u2502 600 \u2502 550 \u2502    Yes   \u2502\n    \u2502   63   \u2502 610 \u2502 610 \u2502    No    \u2502\n    \u2502   62   \u2502 620 \u2502 600 \u2502    No    \u2502\n    \u250a        \u250a     \u250a     \u250a          \u250a\n\nSample/frame 58, 59 and 60 are B-frames which actually depends on the\nkey frame (57). Here the key frame is not an IDR but a \"CRA\" (Clean\nRandom Access).\n\nInitially, I thought I could rely on the sdtp box (independent and\ndisposable samples), but unfortunately:\n\n    sdtp[54] is_leading:0 sample_depends_on:1 sample_is_depended_on:0 sample_has_redundancy:0\n    sdtp[55] is_leading:0 sample_depends_on:1 sample_is_depended_on:2 sample_has_redundancy:0\n    sdtp[56] is_leading:0 sample_depends_on:1 sample_is_depended_on:2 sample_has_redundancy:0\n    sdtp[57] is_leading:0 sample_depends_on:2 sample_is_depended_on:0 sample_has_redundancy:0\n    sdtp[58] is_leading:0 sample_depends_on:1 sample_is_depended_on:0 sample_has_redundancy:0\n    sdtp[59] is_leading:0 sample_depends_on:1 sample_is_depended_on:2 sample_has_redundancy:0\n    sdtp[60] is_leading:0 sample_depends_on:1 sample_is_depended_on:2 sample_has_redundancy:0\n    sdtp[61] is_leading:0 sample_depends_on:1 sample_is_depended_on:0 sample_has_redundancy:0\n    sdtp[62] is_leading:0 sample_depends_on:1 sample_is_depended_on:0 sample_has_redundancy:0\n\nThe information that might have been useful here would have been\nis_leading, but all the samples are set to 0 so this was unusable.\n\nInstead, we need to rely on sgpd/sbgp tables. In my case the video track\ncontained 3 sgpd tables with the following grouping types: tscl, sync\nand tsas. In the sync table we have the following 2 entries (only):\n\n    sgpd.sync[1]: sync nal_unit_type:0x14\n    sgpd.sync[2]: sync nal_unit_type:0x15\n\n(The count starts at 1 because 0 carries the undefined semantic, we'll\nsee that later in the reference table).\n\nThe NAL unit types presented here correspond to:\n\n    libavcodec/hevc.h:    HEVC_NAL_IDR_N_LP       = 20,\n    libavcodec/hevc.h:    HEVC_NAL_CRA_NUT        = 21,\n\nIn parallel, the sbgp sync table contains the following:\n\n    \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 id \u2502 count \u2502 gdi \u2502\n    \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  0 \u2502   1   \u2502  1  \u2502\n    \u2502  1 \u2502   56  \u2502  0  \u2502\n    \u2502  2 \u2502   1   \u2502  2  \u2502\n    \u2502  3 \u2502   59  \u2502  0  \u2502\n    \u2502  4 \u2502   1   \u2502  2  \u2502\n    \u2502  5 \u2502   59  \u2502  0  \u2502\n    \u2502  6 \u2502   1   \u2502  2  \u2502\n    \u2502  7 \u2502   59  \u2502  0  \u2502\n    \u2502  8 \u2502   1   \u2502  2  \u2502\n    \u2502  9 \u2502   59  \u2502  0  \u2502\n    \u2502 10 \u2502   1   \u2502  2  \u2502\n    \u2502 11 \u2502   11  \u2502  0  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\nThe gdi column (group description index) directly refers to the index in\nthe sgpd.sync table. This means the first frame is an IDR, then we have\nbatches of undefined frames interlaced with CRA frames. No IDR ever\nappears again (tried on a 30+ seconds sample).\n\nWith that information, we can build an heuristic using the presentation\norder.\n\nA few things needed to be introduced in this commit:\n\n1. min_sample_duration is extracted from the stts: we need the minimal\n   step between sample in order to PTS-step backward to a valid point\n2. In order to avoid a loop over the ctts table systematically during a\n   seek, we build an expanded list of sample offsets which will be used\n   to translate from DTS to PTS\n3. An open_key_samples index to keep track of all the non-IDR key\n   frames; for now it only supports HEVC CRA frames. We should probably\n   add BLA frames as well, but I don't have any sample so I prefered to\n   leave that for later\n\nIt is entirely possible I missed something obvious in my approach, but I\ncouldn't come up with a better solution. Also, as mentioned in the diff,\nwe could optimize is_open_key_sample(), but the linear scaling overhead\nshould be fine for now since it only happens in seek events.\n\nFixing this issue prevents sending broken packets to the decoder. With\nFFmpeg hevc decoder the frames are skipped, with VideoToolbox the frames\nare glitching.",
        "before_after_code_files": [
          "libavformat/isom.h||libavformat/isom.h",
          "libavformat/mov.c||libavformat/mov.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/mov.c||libavformat/mov.c"
          ],
          "candidate": [
            "libavformat/mov.c||libavformat/mov.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/isom.h||libavformat/isom.h": [
          "File: libavformat/isom.h -> libavformat/isom.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:     MOVSbgp *sync_group;",
          "223:     uint8_t *sgpd_sync;",
          "224:     uint32_t sgpd_sync_count;",
          "226:     int nb_frames_for_fps;",
          "227:     int64_t duration_for_fps;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225:     int32_t *sample_offsets;",
          "226:     int sample_offsets_count;",
          "227:     int *open_key_samples;",
          "228:     int open_key_samples_count;",
          "229:     uint32_t min_sample_duration;",
          "",
          "---------------"
        ],
        "libavformat/mov.c||libavformat/mov.c": [
          "File: libavformat/mov.c -> libavformat/mov.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: #include \"libavutil/dovi_meta.h\"",
          "51: #include \"libavcodec/ac3tab.h\"",
          "52: #include \"libavcodec/flac.h\"",
          "53: #include \"libavcodec/mpegaudiodecheader.h\"",
          "54: #include \"libavcodec/mlp_parse.h\"",
          "55: #include \"avformat.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53: #include \"libavcodec/hevc.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3882:     msc->current_index = msc->index_ranges[0].start;",
          "3883: }",
          "3885: static void mov_build_index(MOVContext *mov, AVStream *st)",
          "3886: {",
          "3887:     MOVStreamContext *sc = st->priv_data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3886: static uint32_t get_sgpd_sync_index(const MOVStreamContext *sc, int nal_unit_type)",
          "3887: {",
          "3888:     for (uint32_t i = 0; i < sc->sgpd_sync_count; i++)",
          "3889:         if (sc->sgpd_sync[i] == HEVC_NAL_CRA_NUT)",
          "3890:             return i + 1;",
          "3891:     return 0;",
          "3892: }",
          "3894: static int build_open_gop_key_points(AVStream *st)",
          "3895: {",
          "3896:     int k;",
          "3897:     int sample_id = 0;",
          "3898:     uint32_t cra_index;",
          "3899:     MOVStreamContext *sc = st->priv_data;",
          "3901:     if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)",
          "3902:         return 0;",
          "3905:     sc->sample_offsets_count = 0;",
          "3906:     for (uint32_t i = 0; i < sc->ctts_count; i++)",
          "3907:         sc->sample_offsets_count += sc->ctts_data[i].count;",
          "3908:     av_freep(&sc->sample_offsets);",
          "3909:     sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));",
          "3910:     if (!sc->sample_offsets)",
          "3911:         return AVERROR(ENOMEM);",
          "3912:     k = 0;",
          "3913:     for (uint32_t i = 0; i < sc->ctts_count; i++)",
          "3914:         for (int j = 0; j < sc->ctts_data[i].count; j++)",
          "3915:              sc->sample_offsets[k++] = sc->ctts_data[i].duration;",
          "3920:     if (!cra_index)",
          "3921:         return 0;",
          "3924:     sc->open_key_samples_count = 0;",
          "3925:     for (uint32_t i = 0; i < sc->sync_group_count; i++)",
          "3926:         if (sc->sync_group[i].index == cra_index)",
          "3927:             sc->open_key_samples_count += sc->sync_group[i].count;",
          "3928:     av_freep(&sc->open_key_samples);",
          "3929:     sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));",
          "3930:     if (!sc->open_key_samples)",
          "3931:         return AVERROR(ENOMEM);",
          "3932:     k = 0;",
          "3933:     for (uint32_t i = 0; i < sc->sync_group_count; i++) {",
          "3934:         const MOVSbgp *sg = &sc->sync_group[i];",
          "3935:         if (sg->index == cra_index)",
          "3936:             for (uint32_t j = 0; j < sg->count; j++)",
          "3937:                 sc->open_key_samples[k++] = sample_id;",
          "3938:         sample_id += sg->count;",
          "3939:     }",
          "3942:     sc->min_sample_duration = UINT_MAX;",
          "3943:     for (uint32_t i = 0; i < sc->stts_count; i++)",
          "3944:         sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);",
          "3946:     return 0;",
          "3947: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3897:     MOVCtts *ctts_data_old = sc->ctts_data;",
          "3898:     unsigned int ctts_count_old = sc->ctts_count;",
          "3900:     if (sc->elst_count) {",
          "3901:         int i, edit_start_index = 0, multiple_edits = 0;",
          "3902:         int64_t empty_duration = 0; // empty duration of the first edit list entry",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3964:     int ret = build_open_gop_key_points(st);",
          "3965:     if (ret < 0)",
          "3966:         return;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7774:         av_freep(&sc->rap_group);",
          "7775:         av_freep(&sc->sync_group);",
          "7776:         av_freep(&sc->sgpd_sync);",
          "7777:         av_freep(&sc->display_matrix);",
          "7778:         av_freep(&sc->index_ranges);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7845:         av_freep(&sc->sample_offsets);",
          "7846:         av_freep(&sc->open_key_samples);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "8446:     return 0;",
          "8447: }",
          "8449: static int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)",
          "8450: {",
          "8451:     MOVStreamContext *sc = st->priv_data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8519: static int is_open_key_sample(const MOVStreamContext *sc, int sample)",
          "8520: {",
          "8522:     for (int i = 0; i < sc->open_key_samples_count; i++) {",
          "8523:         const int oks = sc->open_key_samples[i];",
          "8524:         if (oks == sample)",
          "8525:             return 1;",
          "8527:             break;",
          "8528:     }",
          "8529:     return 0;",
          "8530: }",
          "8536: static int can_seek_to_key_sample(AVStream *st, int sample, int64_t requested_pts)",
          "8537: {",
          "8538:     MOVStreamContext *sc = st->priv_data;",
          "8539:     FFStream *const sti = ffstream(st);",
          "8540:     int64_t key_sample_dts, key_sample_pts;",
          "8542:     if (st->codecpar->codec_id != AV_CODEC_ID_HEVC)",
          "8543:         return 1;",
          "8545:     if (sample >= sc->sample_offsets_count)",
          "8546:         return 1;",
          "8548:     key_sample_dts = sti->index_entries[sample].timestamp;",
          "8549:     key_sample_pts = key_sample_dts + sc->sample_offsets[sample] + sc->dts_shift;",
          "8556:     if (is_open_key_sample(sc, sample) && key_sample_pts > requested_pts)",
          "8557:         return 0;",
          "8559:     return 1;",
          "8560: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8461:     if (ret < 0)",
          "8462:         return ret;",
          "8464:     sample = av_index_search_timestamp(st, timestamp, flags);",
          "8465:     av_log(s, AV_LOG_TRACE, \"stream %d, timestamp %\"PRId64\", sample %d\\n\", st->index, timestamp, sample);",
          "8466:     if (sample < 0 && sti->nb_index_entries && timestamp < sti->index_entries[0].timestamp)",
          "8467:         sample = 0;",
          "8469:         return AVERROR_INVALIDDATA;",
          "8470:     mov_current_sample_set(sc, sample);",
          "8471:     av_log(s, AV_LOG_TRACE, \"stream %d, found sample %d\\n\", st->index, sc->current_sample);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8577:     for (;;) {",
          "8585:         if (!sample || can_seek_to_key_sample(st, sample, timestamp))",
          "8586:             break;",
          "8587:         timestamp -= FFMAX(sc->min_sample_duration, 1);",
          "8588:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}